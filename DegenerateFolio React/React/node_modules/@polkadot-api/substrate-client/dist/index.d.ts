import { ConnectProvider } from '@polkadot-api/json-rpc-provider';
export { ConnectProvider, Provider } from '@polkadot-api/json-rpc-provider';

interface IRpcError {
    code: number;
    message: string;
    data?: any;
}
declare class RpcError extends Error implements IRpcError {
    code: number;
    data: any;
    constructor(e: IRpcError);
}

type UnsubscribeFn = () => void;
type WithAbortSignal<T extends Array<any>> = [
    ...args: T,
    abortSignal?: AbortSignal
];
type AbortablePromiseFn<A extends Array<any>, T> = (...args: WithAbortSignal<A>) => Promise<T>;

interface Subscriber<T> {
    next: (data: T) => void;
    error: (e: Error) => void;
}

type FollowSubscriptionCb<T> = (methodName: string, subscriptionId: string, cb: Subscriber<T>) => UnsubscribeFn;
type ClientRequestCb<T, TT> = {
    onSuccess: (result: T, followSubscription: FollowSubscriptionCb<TT>) => void;
    onError: (e: Error) => void;
};
type ClientRequest<T, TT> = (method: string, params: Array<any>, cb?: ClientRequestCb<T, TT>) => UnsubscribeFn;
interface Client {
    disconnect: () => void;
    request: ClientRequest<any, any>;
}

declare class DestroyedError extends Error {
    constructor();
}

type FollowInnerSubscriptionCb<T> = (subscriptionId: string, cb: Subscriber<T>) => UnsubscribeFn;
type ClientInnerRequestCb<T, TT> = {
    onSuccess: (result: T, followSubscription: FollowInnerSubscriptionCb<TT>) => void;
    onError: (e: Error) => void;
};
type ClientInnerRequest<T, TT> = (method: string, params: Array<any>, cb?: ClientInnerRequestCb<T, TT>) => UnsubscribeFn;
interface StorageItemInput {
    key: string;
    type: "value" | "hash" | "closestDescendantMerkleValue" | "descendantsValues" | "descendantsHashes";
}
interface StorageItemResponse {
    key: string;
    value?: string;
    hash?: string;
    closestDescendantMerkleValue?: string;
}
interface Runtime {
    specName: string;
    implName: string;
    specVersion: number;
    implVersion: number;
    transactionVersion: number;
    apis: Record<string, number>;
}
interface Initialized {
    type: "initialized";
    finalizedBlockHashes: string[];
}
type InitializedWithRuntime$1 = Initialized & {
    finalizedBlockRuntime: Runtime;
};
interface NewBlock {
    type: "newBlock";
    blockHash: string;
    parentBlockHash: string;
}
type NewBlockWithRuntime$1 = NewBlock & {
    newRuntime: Runtime | null;
};
interface BestBlockChanged {
    type: "bestBlockChanged";
    bestBlockHash: string;
}
interface Finalized {
    type: "finalized";
    finalizedBlockHashes: Array<string>;
    prunedBlockHashes: Array<string>;
}
type CommonFollowEvents = BestBlockChanged | Finalized;
type FollowEventWithRuntime = InitializedWithRuntime$1 | NewBlockWithRuntime$1 | CommonFollowEvents;
type FollowEventWithoutRuntime = Initialized | NewBlock | CommonFollowEvents;
type StorageResult<Input extends StorageItemInput["type"]> = Input extends "descendantsHashes" ? Array<{
    key: string;
    hash: string;
}> : Input extends "descendantsValues" ? Array<{
    key: string;
    value: string;
}> : string | null;
interface FollowResponse {
    unfollow: UnsubscribeFn;
    body: AbortablePromiseFn<[hash: string], Array<string>>;
    call: AbortablePromiseFn<[
        hash: string,
        fnName: string,
        callParameters: string
    ], string>;
    storage: <Type extends StorageItemInput["type"]>(hash: string, type: Type, key: string, childTrie: string | null, abortSignal?: AbortSignal | undefined) => Promise<StorageResult<Type>>;
    storageSubscription: (hash: string, inputs: Array<StorageItemInput>, childTrie: string | null, onItems: (items: Array<StorageItemResponse>) => void, onError: (e: Error) => void, onDone: () => void, onDiscardedItems: (nDiscarded: number) => void) => () => void;
    header: (hash: string) => Promise<string>;
    unpin: (hashes: Array<string>) => Promise<void>;
    _request: <Reply, Notification>(method: string, params: any[], cb?: ClientInnerRequestCb<Reply, Notification>) => UnsubscribeFn;
}
interface ChainHead {
    (withRuntime: false, cb: (event: FollowEventWithoutRuntime) => void, onError: (error: Error) => void): FollowResponse;
    (withRuntime: true, cb: (event: FollowEventWithRuntime) => void, onError: (error: Error) => void): FollowResponse;
    (withRuntime: boolean, cb: (event: FollowEventWithoutRuntime | FollowEventWithRuntime) => void, onError: (error: Error) => void): FollowResponse;
}

declare class StopError extends Error {
    constructor();
}
declare class DisjointError extends Error {
    constructor();
}
declare class OperationLimitError extends Error {
    constructor();
}
declare class OperationError extends Error {
    constructor(error: string);
}
declare class OperationInaccessibleError extends Error {
    constructor();
}

interface RuntimeRpc {
    specName: string;
    implName: string;
    specVersion: number;
    implVersion: number;
    transactionVersion: number;
    apis: Record<string, number>;
}
type InitializedRpc = {
    event: "initialized";
    finalizedBlockHash: string;
} | {
    event: "initialized";
    finalizedBlockHashes: string[];
};
type InitializedWithRuntime = InitializedRpc & {
    finalizedBlockRuntime: RuntimeRpc;
};
interface NewBlockRpc {
    event: "newBlock";
    blockHash: string;
    parentBlockHash: string;
}
type NewBlockWithRuntime = NewBlockRpc & {
    newRuntime: RuntimeRpc | null;
};
interface BestBlockChangedRpc {
    event: "bestBlockChanged";
    bestBlockHash: string;
}
interface FinalizedRpc {
    event: "finalized";
    finalizedBlockHashes: Array<string>;
    prunedBlockHashes: Array<string>;
}
type CommonFollowEventsRpc = BestBlockChangedRpc | FinalizedRpc;
type FollowEventWithRuntimeRpc = InitializedWithRuntime | NewBlockWithRuntime | CommonFollowEventsRpc;
type FollowEventWithoutRuntimeRpc = InitializedRpc | NewBlockRpc | CommonFollowEventsRpc;
interface StopRpc {
    event: "stop";
}
interface OperationEventRpc {
    operationId: string;
}
type OperationWaitingForContinueRpc = OperationEventRpc & {
    event: "operationWaitingForContinue";
};
type OperationInaccessibleRpc = OperationEventRpc & {
    event: "operationInaccessible";
};
type OperationErrorRpc = OperationEventRpc & {
    event: "operationError";
    error: string;
};
type CommonOperationEventsRpc = OperationInaccessibleRpc | OperationErrorRpc;
type OperationBodyDoneRpc = OperationEventRpc & {
    event: "operationBodyDone";
    value: Array<string>;
};
type OperationCallDoneRpc = OperationEventRpc & {
    event: "operationCallDone";
    output: string;
};
interface StorageItemResponseRpc {
    key: string;
    value?: string;
    hash?: string;
    closestDescendantMerkleValue?: string;
}
type OperationStorageItemsRpc = OperationEventRpc & {
    event: "operationStorageItems";
    items: Array<StorageItemResponseRpc>;
};
type OperationStorageDoneRpc = OperationEventRpc & {
    event: "operationStorageDone";
};
type OperationEventsRpc = OperationBodyDoneRpc | OperationCallDoneRpc | OperationStorageItemsRpc | OperationWaitingForContinueRpc | OperationStorageDoneRpc | CommonOperationEventsRpc;

type FollowEventRpc = FollowEventWithRuntimeRpc | FollowEventWithoutRuntimeRpc | OperationEventsRpc | StopRpc;
declare function getChainHead(request: ClientRequest<string, FollowEventRpc>): ChainHead;

interface TxValidated {
    type: "validated";
}
interface TxBroadcasted {
    type: "broadcasted";
    numPeers: number;
}
interface TxBestChainBlockIncluded {
    type: "bestChainBlockIncluded";
    block: {
        hash: string;
        index: number;
    } | null;
}
interface TxFinalized {
    type: "finalized";
    block: {
        hash: string;
        index: number;
    };
}
interface TxInvalid {
    type: "invalid";
    error: string;
}
interface TxDropped {
    type: "dropped";
    broadcasted: boolean;
    error: string;
}
interface TxError {
    type: "error";
    error: string;
}
type TxEvent = TxValidated | TxBroadcasted | TxBestChainBlockIncluded | TxFinalized | TxInvalid | TxDropped | TxError;
type Transaction = (tx: string, next: (event: TxEvent) => void, error: (e: Error) => void) => UnsubscribeFn;

interface TxValidatedRpc {
    event: "validated";
}
interface TxBroadcastedRpc {
    event: "broadcasted";
    numPeers: number;
}
interface TxBestChainBlockIncludedRpc {
    event: "bestChainBlockIncluded";
    block: {
        hash: string;
        index: number;
    } | null;
}
interface TxFinalizedRpc {
    event: "finalized";
    block: {
        hash: string;
        index: number;
    };
}
interface TxInvalidRpc {
    event: "invalid";
    error: string;
}
interface TxDroppedRpc {
    event: "dropped";
    broadcasted: boolean;
    error: string;
}
interface TxErrorRpc {
    event: "error";
    error: string;
}
type TxEventRpc = TxValidatedRpc | TxBroadcastedRpc | TxBestChainBlockIncludedRpc | TxFinalizedRpc | TxInvalidRpc | TxDroppedRpc | TxErrorRpc;

type ErrorEvents = TxDroppedRpc | TxInvalidRpc | TxErrorRpc;
interface ITxError {
    type: ErrorEvents["event"];
    error: string;
}
declare class TransactionError extends Error implements ITxError {
    type: "error" | "invalid" | "dropped";
    error: string;
    constructor(e: ErrorEvents);
}
declare const getTransaction: (request: ClientRequest<string, TxEventRpc>) => (namespace: string, tx: string, next: (event: TxEvent) => void, error: (e: Error) => void) => () => void;

interface SubstrateClient {
    chainHead: ChainHead;
    transaction: Transaction;
    destroy: UnsubscribeFn;
    request: <T>(method: string, params: any[], abortSignal?: AbortSignal) => Promise<T>;
    _request: <Reply, Notification>(method: string, params: any[], cb?: ClientRequestCb<Reply, Notification>) => UnsubscribeFn;
}
declare const createClient: (provider: ConnectProvider) => SubstrateClient;

export { type AbortablePromiseFn, type BestBlockChanged, type ChainHead, type Client, type ClientInnerRequest, type ClientInnerRequestCb, type ClientRequest, type ClientRequestCb, DestroyedError, DisjointError, type Finalized, type FollowEventWithRuntime, type FollowEventWithoutRuntime, type FollowInnerSubscriptionCb, type FollowResponse, type FollowSubscriptionCb, type IRpcError, type Initialized, type InitializedWithRuntime$1 as InitializedWithRuntime, type NewBlock, type NewBlockWithRuntime$1 as NewBlockWithRuntime, OperationError, OperationInaccessibleError, OperationLimitError, RpcError, type Runtime, StopError, type StorageItemInput, type StorageItemResponse, type StorageResult, type SubstrateClient, type Transaction, TransactionError, type TxBestChainBlockIncluded, type TxBroadcasted, type TxDropped, type TxError, type TxEvent, type TxFinalized, type TxInvalid, type TxValidated, type UnsubscribeFn, createClient, getChainHead, getTransaction };
