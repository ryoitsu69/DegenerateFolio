"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  DestroyedError: () => DestroyedError,
  DisjointError: () => DisjointError,
  OperationError: () => OperationError,
  OperationInaccessibleError: () => OperationInaccessibleError,
  OperationLimitError: () => OperationLimitError,
  RpcError: () => RpcError,
  StopError: () => StopError,
  TransactionError: () => TransactionError,
  createClient: () => createClient2
});
module.exports = __toCommonJS(src_exports);

// src/internal-utils/abortablePromiseFn.ts
var import_utils = require("@polkadot-api/utils");
var abortablePromiseFn = (fn) => (...args) => new Promise((res, rej) => {
  let cancel = import_utils.noop;
  const [actualArgs, abortSignal] = args[args.length - 1] instanceof AbortSignal ? [args.slice(0, args.length - 1), args[args.length - 1]] : [args];
  const onAbort = () => {
    cancel();
    rej(new import_utils.AbortError());
  };
  abortSignal?.addEventListener("abort", onAbort, { once: true });
  const withCleanup = (fn2) => (x) => {
    cancel = import_utils.noop;
    abortSignal?.removeEventListener("abort", onAbort);
    fn2(x);
  };
  cancel = fn(...[withCleanup(res), withCleanup(rej), ...actualArgs]);
});

// src/internal-utils/deferred-promise.ts
function deferred() {
  let res = () => {
  };
  let rej = () => {
  };
  const promise = new Promise((_res, _rej) => {
    res = _res;
    rej = _rej;
  });
  return { promise, res, rej };
}

// src/internal-utils/noop.ts
var noop2 = () => {
};

// src/internal-utils/subscriptions-manager.ts
var MAX_TIME = 2e3;
var getSubscriptionsManager = () => {
  const subscriptions = /* @__PURE__ */ new Map();
  return {
    has: subscriptions.has.bind(subscriptions),
    subscribe(id, subscriber) {
      subscriptions.set(id, subscriber);
    },
    unsubscribe(id) {
      subscriptions.delete(id);
    },
    next(id, data) {
      subscriptions.get(id)?.next(data);
    },
    error(id, e) {
      const subscriber = subscriptions.get(id);
      if (subscriber) {
        subscriptions.delete(id);
        subscriber.error(e);
      }
    },
    errorAll(e) {
      const subscribers = [...subscriptions.values()];
      subscriptions.clear();
      subscribers.forEach((s) => {
        s.error(e);
      });
    }
  };
};
var _messages, _token;
var OrphanMessages = class {
  constructor() {
    __privateAdd(this, _messages, void 0);
    __privateAdd(this, _token, void 0);
    __privateSet(this, _messages, /* @__PURE__ */ new Map());
    __privateSet(this, _token, null);
  }
  checkClear() {
    if (__privateGet(this, _messages).size > 0)
      return;
    clearInterval(__privateGet(this, _token));
    __privateSet(this, _token, null);
  }
  set(key, message) {
    const messages = __privateGet(this, _messages).get(key)?.messages ?? [];
    messages.push(message);
    __privateGet(this, _messages).set(key, { expiry: Date.now() + MAX_TIME, messages });
    __privateSet(this, _token, __privateGet(this, _token) || setInterval(() => {
      const now = Date.now();
      [...__privateGet(this, _messages).entries()].forEach(([key2, entry]) => {
        if (entry.expiry > now)
          __privateGet(this, _messages).delete(key2);
      });
      this.checkClear();
    }, MAX_TIME));
  }
  retrieve(key) {
    const result = __privateGet(this, _messages).get(key);
    if (!result)
      return [];
    __privateGet(this, _messages).delete(key);
    this.checkClear();
    return result.messages;
  }
  clear() {
    __privateGet(this, _messages).clear();
    this.checkClear();
  }
};
_messages = new WeakMap();
_token = new WeakMap();

// src/client/RpcError.ts
var RpcError = class extends Error {
  constructor(e) {
    super(e.message);
    __publicField(this, "code");
    __publicField(this, "data");
    this.code = e.code;
    this.data = e.data;
    this.name = "RpcError";
  }
};

// src/client/DestroyedError.ts
var DestroyedError = class extends Error {
  constructor() {
    super("Client destroyed");
    this.name = "DestroyedError";
  }
};

// src/client/createClient.ts
var createClient = (gProvider) => {
  const responses = /* @__PURE__ */ new Map();
  const subscriptions = getSubscriptionsManager();
  const orphans = new OrphanMessages();
  let provider = null;
  const send = (id, method, params) => {
    provider.send(
      JSON.stringify({
        jsonrpc: "2.0",
        id,
        method,
        params
      })
    );
  };
  function onMessage(message) {
    try {
      let id, result, error, params, subscription;
      const parsed = JSON.parse(message);
      ({ id, result, error, params } = parsed);
      if (id) {
        const cb = responses.get(id);
        if (!cb)
          return;
        responses.delete(id);
        return error ? cb.onError(new RpcError(error)) : cb.onSuccess(result, (methodName, opaqueId, subscriber) => {
          const subscriptionId2 = methodName + opaqueId;
          subscriptions.subscribe(subscriptionId2, subscriber);
          const pending = orphans.retrieve(subscriptionId2);
          if (pending.length) {
            Promise.resolve().then(() => {
              pending.forEach((msg) => {
                subscriptions.next(subscriptionId2, msg);
              });
            });
          }
          return () => {
            subscriptions.unsubscribe(subscriptionId2);
          };
        });
      }
      ;
      ({ subscription, result, error } = params);
      if (!subscription || !error && !Object.hasOwn(params, "result"))
        throw 0;
      const subscriptionId = parsed.method + subscription;
      if (!subscriptions.has(subscriptionId)) {
        orphans.set(subscriptionId, message);
      }
      if (error) {
        subscriptions.error(subscriptionId, new RpcError(error));
      } else {
        subscriptions.next(subscriptionId, result);
      }
    } catch (e) {
      console.warn("Error parsing incomming message: " + message);
      console.error(e);
    }
  }
  provider = gProvider(onMessage);
  const disconnect = () => {
    provider?.disconnect();
    provider = null;
    subscriptions.errorAll(new DestroyedError());
    responses.forEach((r) => r.onError(new DestroyedError()));
    responses.clear();
    orphans.clear();
  };
  let nextId = 1;
  const request = (method, params, cb) => {
    if (!provider)
      throw new Error("Not connected");
    const id = nextId++;
    if (cb)
      responses.set(id, cb);
    send(id, method, params);
    return () => {
      responses.delete(id);
    };
  };
  return {
    request,
    disconnect
  };
};

// src/transaction/transaction.ts
var eventToType = (input) => {
  const { event: type, ...rest } = input;
  return { type, ...rest };
};
var terminalEvents = /* @__PURE__ */ new Set([
  "dropped",
  "invalid",
  "finalized",
  "error"
]);
function isTerminalEvent(event) {
  return terminalEvents.has(event.event);
}
var TransactionError = class extends Error {
  constructor(e) {
    super(`TxError: ${e.event} - ${e.error}`);
    __publicField(this, "type");
    __publicField(this, "error");
    this.type = e.event;
    this.error = e.error;
    this.name = "TransactionError";
  }
};
var getTransaction = (request) => (namespace, tx, next, error) => {
  let cancel = request(namespace + "_unstable_submitAndWatch", [tx], {
    onSuccess: (subscriptionId, follow) => {
      const done = follow(
        namespace + "_unstable_watchEvent",
        subscriptionId,
        {
          next: (event) => {
            if (isTerminalEvent(event)) {
              done();
              cancel = noop2;
              if (event.event !== "finalized")
                return error(new TransactionError(event));
            }
            next(eventToType(event));
          },
          error(e) {
            if (!(e instanceof DestroyedError))
              cancel();
            cancel = noop2;
            error(e);
          }
        }
      );
      cancel = () => {
        done();
        request(namespace + "_unstable_unwatch", [subscriptionId]);
      };
    },
    onError: error
  });
  return () => {
    cancel();
  };
};

// src/chainhead/errors.ts
var StopError = class extends Error {
  constructor() {
    super("ChainHead stopped");
    this.name = "StopError";
  }
};
var DisjointError = class extends Error {
  constructor() {
    super("ChainHead disjointed");
    this.name = "DisjointError";
  }
};
var OperationLimitError = class extends Error {
  constructor() {
    super("ChainHead operations limit reached");
    this.name = "OperationLimitError";
  }
};
var OperationError = class extends Error {
  constructor(error) {
    super(error);
    this.name = "OperationError";
  }
};
var OperationInaccessibleError = class extends Error {
  constructor() {
    super("ChainHead operation inaccessible");
    this.name = "OperationInaccessibleError";
  }
};

// src/chainhead/operation-promise.ts
var createOperationPromise = (operationName, factory) => (request) => abortablePromiseFn((res, rej, ...args) => {
  const [requestArgs, logicCb] = factory(...args);
  let cancel = request(operationName, requestArgs, {
    onSuccess: (response, followSubscription) => {
      if (response.result === "limitReached") {
        cancel = noop2;
        return rej(new OperationLimitError());
      }
      let isOperationGoing = true;
      let done = noop2;
      const _res = (x) => {
        isOperationGoing = false;
        done();
        res(x);
      };
      const _rej = (x) => {
        isOperationGoing = false;
        done();
        rej(x);
      };
      done = followSubscription(response.operationId, {
        next: (e) => {
          const _e = e;
          if (_e.event === "operationError") {
            rej(new OperationError(_e.error));
          } else if (_e.event === "operationInaccessible") {
            rej(new OperationInaccessibleError());
          } else {
            logicCb(e, _res, _rej);
          }
        },
        error: _rej
      });
      cancel = () => {
        if (!isOperationGoing)
          return;
        done();
        request("chainHead_unstable_stopOperation", [response.operationId]);
      };
    },
    onError: rej
  });
  return () => {
    cancel();
  };
});

// src/chainhead/body.ts
var createBodyFn = createOperationPromise(
  "chainHead_unstable_body",
  (hash) => [
    [hash],
    (e, res) => {
      res(e.value);
    }
  ]
);

// src/chainhead/call.ts
var createCallFn = createOperationPromise(
  "chainHead_unstable_call",
  (hash, fnName, callParameters) => [
    [hash, fnName, callParameters],
    (e, res) => {
      res(e.output);
    }
  ]
);

// src/chainhead/header.ts
var createHeaderFn = (request) => (hash) => new Promise((res, rej) => {
  request("chainHead_unstable_header", [hash], {
    onSuccess: res,
    onError: rej
  });
});

// src/chainhead/storage-subscription.ts
var import_utils2 = require("@polkadot-api/utils");
var createStorageCb = (request) => (hash, inputs, childTrie, onItems, onError, onDone, onDiscardedItems) => {
  if (inputs.length === 0) {
    onDone();
    return import_utils2.noop;
  }
  let cancel = request(
    "chainHead_unstable_storage",
    [hash, inputs, childTrie],
    {
      onSuccess: (response, followSubscription) => {
        if (response.result === "limitReached" || response.discardedItems === inputs.length)
          return onError(new OperationLimitError());
        const doneListening = followSubscription(response.operationId, {
          next: (event) => {
            switch (event.event) {
              case "operationStorageItems": {
                onItems(event.items);
                break;
              }
              case "operationStorageDone": {
                _onDone();
                break;
              }
              case "operationError": {
                _onError(new OperationError(event.error));
                break;
              }
              case "operationInaccessible": {
                _onError(new OperationInaccessibleError());
                break;
              }
              default:
                request("chainHead_unstable_continue", []);
            }
          },
          error: onError
        });
        cancel = () => {
          doneListening();
          request("chainHead_unstable_stopOperation", [response.operationId]);
        };
        const _onError = (e) => {
          cancel = import_utils2.noop;
          doneListening();
          onError(e);
        };
        const _onDone = () => {
          cancel = import_utils2.noop;
          doneListening();
          onDone();
        };
        onDiscardedItems(response.discardedItems);
      },
      onError
    }
  );
  return () => {
    cancel();
  };
};

// src/chainhead/storage.ts
var createStorageFn = (request) => {
  const cbStore = createStorageCb(request);
  return abortablePromiseFn((resolve, reject, hash, type, key, childTrie) => {
    const isDescendants = type.startsWith("descendants");
    let result = isDescendants ? [] : null;
    const onItems = isDescendants ? (items) => {
      result.push(...items);
    } : (items) => {
      result = items[0]?.[type];
    };
    const cancel = cbStore(
      hash,
      [{ key, type }],
      childTrie ?? null,
      onItems,
      reject,
      () => {
        resolve(result);
      },
      (nDiscarded) => {
        if (nDiscarded > 0) {
          cancel();
          reject(new OperationLimitError());
        }
      }
    );
    return cancel;
  });
};

// src/chainhead/unpin.ts
var createUnpinFn = (request) => (hashes) => new Promise((res, rej) => {
  request("chainHead_unstable_unpin", [hashes], {
    onSuccess() {
      res();
    },
    onError: rej
  });
});

// src/chainhead/chainhead.ts
function isOperationEvent(event) {
  return event.operationId !== void 0;
}
function getChainHead(request) {
  return (withRuntime, onFollowEvent, onFollowError) => {
    const subscriptions = getSubscriptionsManager();
    const orphans = new OrphanMessages();
    const ongoingRequests = /* @__PURE__ */ new Set();
    const deferredFollow = deferred();
    let followSubscription = deferredFollow.promise;
    const onAllFollowEventsNext = (event) => {
      if (isOperationEvent(event)) {
        if (!subscriptions.has(event.operationId)) {
          orphans.set(event.operationId, event);
        }
        return subscriptions.next(event.operationId, event);
      }
      if (event.event !== "stop") {
        if (event.event === "initialized") {
          return onFollowEvent({
            type: event.event,
            finalizedBlockHashes: "finalizedBlockHash" in event ? [event.finalizedBlockHash] : event.finalizedBlockHashes,
            finalizedBlockRuntime: event.finalizedBlockRuntime
          });
        }
        const { event: type, ...rest } = event;
        return onFollowEvent({ type, ...rest });
      }
      onFollowError(new StopError());
      unfollow(false);
    };
    const onAllFollowEventsError = (error) => {
      onFollowError(error);
      unfollow(!(error instanceof DestroyedError));
    };
    const onFollowRequestSuccess = (subscriptionId, follow) => {
      const done = follow("chainHead_unstable_followEvent", subscriptionId, {
        next: onAllFollowEventsNext,
        error: onAllFollowEventsError
      });
      unfollow = (sendUnfollow = true) => {
        followSubscription = null;
        unfollow = noop2;
        done();
        sendUnfollow && request("chainHead_unstable_unfollow", [subscriptionId]);
        subscriptions.errorAll(new DisjointError());
        ongoingRequests.forEach((cb) => {
          cb();
        });
        ongoingRequests.clear();
        orphans.clear();
      };
      followSubscription = subscriptionId;
      deferredFollow.res(subscriptionId);
    };
    const onFollowRequestError = (e) => {
      if (e instanceof DestroyedError) {
        unfollow(false);
      } else {
        onFollowError(e);
      }
      followSubscription = null;
      deferredFollow.res(e);
    };
    let unfollow = request(
      "chainHead_unstable_follow",
      [withRuntime],
      { onSuccess: onFollowRequestSuccess, onError: onFollowRequestError }
    );
    const fRequest = (method, params, cb) => {
      const disjoint = () => {
        cb?.onError(new DisjointError());
      };
      if (followSubscription === null) {
        disjoint();
        return noop2;
      }
      const onSubscription = (subscription) => {
        if (!cb)
          return request(method, [subscription, ...params]);
        ongoingRequests.add(disjoint);
        const onSubscribeOperation = (operationId, subscriber) => {
          if (followSubscription === null) {
            subscriber.error(new DisjointError());
            return noop2;
          }
          subscriptions.subscribe(operationId, subscriber);
          const pending = orphans.retrieve(operationId);
          if (pending.length) {
            Promise.resolve().then(() => {
              pending.forEach((msg) => {
                subscriptions.next(operationId, msg);
              });
            });
          }
          return () => {
            subscriptions.unsubscribe(operationId);
          };
        };
        const cleanup = request(method, [subscription, ...params], {
          onSuccess: (response) => {
            ongoingRequests.delete(disjoint);
            cb.onSuccess(response, onSubscribeOperation);
          },
          onError: (e) => {
            ongoingRequests.delete(disjoint);
            cb.onError(e);
          }
        });
        return () => {
          ongoingRequests.delete(disjoint);
          cleanup();
        };
      };
      if (typeof followSubscription === "string")
        return onSubscription(followSubscription);
      let onCancel = noop2;
      followSubscription.then((x) => {
        if (x instanceof Error)
          return disjoint();
        if (followSubscription)
          onCancel = onSubscription(x);
      });
      return () => {
        onCancel();
      };
    };
    return {
      unfollow() {
        unfollow();
        followSubscription = null;
      },
      body: createBodyFn(fRequest),
      call: createCallFn(fRequest),
      header: createHeaderFn(fRequest),
      storage: createStorageFn(fRequest),
      storageSubscription: createStorageCb(fRequest),
      unpin: createUnpinFn(fRequest),
      _request: fRequest
    };
  };
}

// src/index.ts
var import_utils3 = require("@polkadot-api/utils");
var createClient2 = (provider) => {
  const client = createClient(provider);
  const request = abortablePromiseFn(
    (onSuccess, onError, method, params) => client.request(method, params, { onSuccess, onError })
  );
  let rpcMethods = request("rpc_methods", []).then(
    (x) => rpcMethods = new Set(Array.isArray(x) ? x : x.methods)
  );
  rpcMethods.catch(import_utils3.noop);
  const getSubmitAndWatchNamespace = (input) => input.has("transaction_unstable_submitAndWatch") ? "transaction" : "transactionWatch";
  const innerTransaction = getTransaction(
    client.request
  );
  return {
    chainHead: getChainHead(client.request),
    transaction: (tx, next, err) => {
      if (rpcMethods instanceof Promise) {
        let cleanup = import_utils3.noop;
        let isRunning = true;
        rpcMethods.then((result) => {
          if (!isRunning)
            return;
          cleanup = innerTransaction(
            getSubmitAndWatchNamespace(result),
            tx,
            next,
            err
          );
        });
        return () => {
          isRunning = false;
          cleanup();
        };
      }
      return innerTransaction(
        getSubmitAndWatchNamespace(rpcMethods),
        tx,
        next,
        err
      );
    },
    destroy: () => {
      client.disconnect();
    },
    request,
    _request: client.request
  };
};
//# sourceMappingURL=index.js.map