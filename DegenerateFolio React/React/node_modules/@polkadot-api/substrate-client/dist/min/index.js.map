{"version":3,"sources":["../../src/index.ts","../../src/internal-utils/abortablePromiseFn.ts","../../src/internal-utils/deferred-promise.ts","../../src/internal-utils/noop.ts","../../src/internal-utils/subscriptions-manager.ts","../../src/client/RpcError.ts","../../src/client/DestroyedError.ts","../../src/client/createClient.ts","../../src/transaction/transaction.ts","../../src/chainhead/errors.ts","../../src/chainhead/operation-promise.ts","../../src/chainhead/body.ts","../../src/chainhead/call.ts","../../src/chainhead/header.ts","../../src/chainhead/storage-subscription.ts","../../src/chainhead/storage.ts","../../src/chainhead/unpin.ts","../../src/chainhead/chainhead.ts"],"sourcesContent":["import {\n  type ConnectProvider,\n  type Provider,\n} from \"@polkadot-api/json-rpc-provider\"\nimport { getTransaction } from \"./transaction/transaction\"\nimport { getChainHead } from \"./chainhead\"\nimport {\n  ClientRequest,\n  ClientRequestCb,\n  createClient as createRawClient,\n} from \"./client\"\nimport type { ChainHead } from \"./chainhead\"\nimport type { Transaction } from \"./transaction\"\nimport { UnsubscribeFn } from \"./common-types\"\nimport { abortablePromiseFn } from \"./internal-utils\"\nimport { noop } from \"@polkadot-api/utils\"\n\nexport type { ConnectProvider, Provider }\n\nexport type * from \"./common-types\"\nexport type * from \"./client\"\nexport type * from \"./transaction\"\nexport type * from \"./chainhead\"\n\nexport { RpcError, DestroyedError } from \"./client\"\nexport { TransactionError } from \"./transaction\"\nexport {\n  StopError,\n  DisjointError,\n  OperationError,\n  OperationInaccessibleError,\n  OperationLimitError,\n} from \"./chainhead\"\n\nexport interface SubstrateClient {\n  chainHead: ChainHead\n  transaction: Transaction\n  destroy: UnsubscribeFn\n  request: <T>(\n    method: string,\n    params: any[],\n    abortSignal?: AbortSignal,\n  ) => Promise<T>\n  _request: <Reply, Notification>(\n    method: string,\n    params: any[],\n    cb?: ClientRequestCb<Reply, Notification>,\n  ) => UnsubscribeFn\n}\n\nexport const createClient = (provider: ConnectProvider): SubstrateClient => {\n  const client = createRawClient(provider)\n\n  const request = abortablePromiseFn(\n    <T>(\n      onSuccess: (value: T) => void,\n      onError: (e: any) => void,\n      method: string,\n      params: any[],\n    ) => client.request(method, params, { onSuccess, onError }),\n  )\n\n  let rpcMethods: Promise<Set<string>> | Set<string> = request<\n    { methods: Array<string> } | Array<string>\n  >(\"rpc_methods\", []).then(\n    (x) => (rpcMethods = new Set(Array.isArray(x) ? x : x.methods)),\n  )\n  rpcMethods.catch(noop)\n\n  const getSubmitAndWatchNamespace = (input: Set<string>) =>\n    input.has(\"transaction_unstable_submitAndWatch\")\n      ? \"transaction\"\n      : \"transactionWatch\"\n\n  const innerTransaction = getTransaction(\n    client.request as ClientRequest<any, any>,\n  )\n  return {\n    chainHead: getChainHead(client.request as ClientRequest<any, any>),\n    transaction: (tx, next, err) => {\n      if (rpcMethods instanceof Promise) {\n        let cleanup = noop\n        let isRunning = true\n\n        rpcMethods.then((result) => {\n          if (!isRunning) return\n          cleanup = innerTransaction(\n            getSubmitAndWatchNamespace(result),\n            tx,\n            next,\n            err,\n          )\n        })\n\n        return () => {\n          isRunning = false\n          cleanup()\n        }\n      }\n\n      return innerTransaction(\n        getSubmitAndWatchNamespace(rpcMethods),\n        tx,\n        next,\n        err,\n      )\n    },\n    destroy: () => {\n      client.disconnect()\n    },\n    request,\n    _request: client.request,\n  }\n}\n","import { AbortError, noop } from \"@polkadot-api/utils\"\nimport { AbortablePromiseFn } from \"../common-types\"\n\nexport const abortablePromiseFn =\n  <T, A extends Array<any>>(\n    fn: (\n      ...args: [...[res: (x: T) => void, rej: (e: any) => void], ...A]\n    ) => () => void,\n  ): AbortablePromiseFn<A, T> =>\n  (...args): Promise<T> =>\n    new Promise((res, rej) => {\n      let cancel = noop\n\n      const [actualArgs, abortSignal] =\n        args[args.length - 1] instanceof AbortSignal\n          ? ([args.slice(0, args.length - 1), args[args.length - 1]] as [\n              A,\n              AbortSignal,\n            ])\n          : ([args] as unknown as [A])\n\n      const onAbort = () => {\n        cancel()\n        rej(new AbortError())\n      }\n\n      abortSignal?.addEventListener(\"abort\", onAbort, { once: true })\n\n      const withCleanup =\n        <T>(fn: (x: T) => void): ((x: T) => void) =>\n        (x) => {\n          cancel = noop\n          abortSignal?.removeEventListener(\"abort\", onAbort)\n          fn(x)\n        }\n\n      cancel = fn(...[withCleanup(res), withCleanup(rej), ...actualArgs])\n    })\n","export interface DeferredPromise<T> {\n  promise: Promise<T>\n  res: (value: T) => void\n  rej: (err: Error) => void\n}\n\nexport function deferred<T>(): DeferredPromise<T> {\n  let res: (value: T) => void = () => {}\n  let rej: (err: Error) => void = () => {}\n\n  const promise = new Promise<T>((_res, _rej) => {\n    res = _res\n    rej = _rej\n  })\n\n  return { promise, res, rej }\n}\n","export const noop = (): void => {}\n","const MAX_TIME = 2_000\n\nexport interface Subscriber<T> {\n  next: (data: T) => void\n  error: (e: Error) => void\n}\n\nexport const getSubscriptionsManager = <T>() => {\n  const subscriptions = new Map<string, Subscriber<T>>()\n\n  return {\n    has: subscriptions.has.bind(subscriptions),\n    subscribe(id: string, subscriber: Subscriber<T>) {\n      subscriptions.set(id, subscriber)\n    },\n    unsubscribe(id: string) {\n      subscriptions.delete(id)\n    },\n    next(id: string, data: T) {\n      subscriptions.get(id)?.next(data)\n    },\n    error(id: string, e: Error) {\n      const subscriber = subscriptions.get(id)\n      if (subscriber) {\n        subscriptions.delete(id)\n        subscriber.error(e)\n      }\n    },\n    errorAll(e: Error) {\n      const subscribers = [...subscriptions.values()]\n      subscriptions.clear()\n      subscribers.forEach((s) => {\n        s.error(e)\n      })\n    },\n  }\n}\n\nexport type SubscriptionManager<T> = ReturnType<\n  typeof getSubscriptionsManager<T>\n>\n\nexport class OrphanMessages<T> {\n  #messages: Map<string, { expiry: number; messages: T[] }>\n  #token: number | null\n\n  constructor() {\n    this.#messages = new Map()\n    this.#token = null\n  }\n\n  private checkClear(): void {\n    if (this.#messages.size > 0) return\n\n    clearInterval(this.#token as any)\n    this.#token = null\n  }\n\n  set(key: string, message: T): void {\n    const messages = this.#messages.get(key)?.messages ?? []\n    messages.push(message)\n    this.#messages.set(key, { expiry: Date.now() + MAX_TIME, messages })\n\n    this.#token =\n      this.#token ||\n      (setInterval(() => {\n        const now = Date.now()\n        ;[...this.#messages.entries()].forEach(([key, entry]) => {\n          if (entry.expiry > now) this.#messages.delete(key)\n        })\n        this.checkClear()\n      }, MAX_TIME) as unknown as number)\n  }\n\n  retrieve(key: string): T[] {\n    const result = this.#messages.get(key)\n    if (!result) return []\n    this.#messages.delete(key)\n    this.checkClear()\n    return result.messages\n  }\n\n  clear() {\n    this.#messages.clear()\n    this.checkClear()\n  }\n}\n","export interface IRpcError {\n  code: number\n  message: string\n  data?: any\n}\n\nexport class RpcError extends Error implements IRpcError {\n  code\n  data\n  constructor(e: IRpcError) {\n    super(e.message)\n    this.code = e.code\n    this.data = e.data\n    this.name = \"RpcError\"\n  }\n}\n","export class DestroyedError extends Error {\n  constructor() {\n    super(\"Client destroyed\")\n    this.name = \"DestroyedError\"\n  }\n}\n","import {\n  type ConnectProvider,\n  type Provider,\n} from \"@polkadot-api/json-rpc-provider\"\nimport { UnsubscribeFn } from \"../common-types\"\nimport { RpcError, IRpcError } from \"./RpcError\"\nimport {\n  OrphanMessages,\n  getSubscriptionsManager,\n  Subscriber,\n} from \"@/internal-utils\"\nimport { DestroyedError } from \"./DestroyedError\"\n\nexport type FollowSubscriptionCb<T> = (\n  methodName: string,\n  subscriptionId: string,\n  cb: Subscriber<T>,\n) => UnsubscribeFn\n\nexport type ClientRequestCb<T, TT> = {\n  onSuccess: (result: T, followSubscription: FollowSubscriptionCb<TT>) => void\n  onError: (e: Error) => void\n}\n\nexport type ClientRequest<T, TT> = (\n  method: string,\n  params: Array<any>,\n  cb?: ClientRequestCb<T, TT>,\n) => UnsubscribeFn\n\nexport interface Client {\n  disconnect: () => void\n  request: ClientRequest<any, any>\n}\n\nexport const createClient = (gProvider: ConnectProvider): Client => {\n  const responses = new Map<number, ClientRequestCb<any, any>>()\n  const subscriptions = getSubscriptionsManager()\n  const orphans = new OrphanMessages<string>()\n\n  let provider: Provider | null = null\n\n  const send = (\n    id: number,\n    method: string,\n    params: Array<boolean | string | number | null>,\n  ) => {\n    provider!.send(\n      JSON.stringify({\n        jsonrpc: \"2.0\",\n        id,\n        method,\n        params,\n      }),\n    )\n  }\n\n  function onMessage(message: string): void {\n    try {\n      let id: number,\n        result,\n        error: IRpcError | undefined,\n        params: { subscription: any; result: any; error?: IRpcError },\n        subscription: string\n\n      const parsed = JSON.parse(message)\n      ;({ id, result, error, params } = parsed)\n\n      if (id) {\n        const cb = responses.get(id)\n        if (!cb) return\n\n        responses.delete(id)\n\n        return error\n          ? cb.onError(new RpcError(error))\n          : cb.onSuccess(result, (methodName, opaqueId, subscriber) => {\n              const subscriptionId = methodName + opaqueId\n              subscriptions.subscribe(subscriptionId, subscriber)\n              const pending = orphans.retrieve(subscriptionId)\n              if (pending.length) {\n                Promise.resolve().then(() => {\n                  pending.forEach((msg) => {\n                    subscriptions.next(subscriptionId, msg)\n                  })\n                })\n              }\n              return () => {\n                subscriptions.unsubscribe(subscriptionId)\n              }\n            })\n      }\n\n      // at this point, it means that it should be a notification\n      ;({ subscription, result, error } = params)\n      if (!subscription || (!error && !Object.hasOwn(params, \"result\"))) throw 0\n\n      const subscriptionId = parsed.method + subscription\n      if (!subscriptions.has(subscriptionId)) {\n        orphans.set(subscriptionId, message)\n      }\n\n      if (error) {\n        subscriptions.error(subscriptionId, new RpcError(error!))\n      } else {\n        subscriptions.next(subscriptionId, result)\n      }\n    } catch (e) {\n      console.warn(\"Error parsing incomming message: \" + message)\n      console.error(e)\n    }\n  }\n  provider = gProvider(onMessage)\n\n  const disconnect = () => {\n    provider?.disconnect()\n    provider = null\n    subscriptions.errorAll(new DestroyedError())\n    responses.forEach((r) => r.onError(new DestroyedError()))\n    responses.clear()\n    orphans.clear()\n  }\n\n  let nextId = 1\n  const request = <T, TT>(\n    method: string,\n    params: Array<any>,\n    cb?: ClientRequestCb<T, TT>,\n  ): UnsubscribeFn => {\n    if (!provider) throw new Error(\"Not connected\")\n    const id = nextId++\n\n    if (cb) responses.set(id, cb)\n    send(id, method, params)\n\n    return (): void => {\n      responses.delete(id)\n    }\n  }\n\n  return {\n    request,\n    disconnect,\n  }\n}\n","import { noop } from \"@/internal-utils\"\nimport { DestroyedError, type ClientRequest } from \"../client\"\nimport type {\n  TxEventRpc,\n  TxFinalizedRpc,\n  TxInvalidRpc,\n  TxDroppedRpc,\n  TxErrorRpc,\n} from \"./json-rpc-types\"\nimport { TxEvent } from \"./public-types\"\n\ntype EventToType<T extends { event: string }> = T extends { event: infer Type }\n  ? Omit<T, \"event\"> & { type: Type }\n  : T\nconst eventToType = <T extends { event: string }>(input: T): EventToType<T> => {\n  const { event: type, ...rest } = input\n  return { type, ...rest } as any\n}\n\ntype TerminalEvent = TxDroppedRpc | TxInvalidRpc | TxFinalizedRpc | TxErrorRpc\nconst terminalEvents: Set<string> = new Set<TerminalEvent[\"event\"]>([\n  \"dropped\",\n  \"invalid\",\n  \"finalized\",\n  \"error\",\n])\n\nfunction isTerminalEvent(event: TxEventRpc): event is TerminalEvent {\n  return terminalEvents.has(event.event)\n}\n\ntype ErrorEvents = TxDroppedRpc | TxInvalidRpc | TxErrorRpc\n\nexport interface ITxError {\n  type: ErrorEvents[\"event\"]\n  error: string\n}\n\nexport class TransactionError extends Error implements ITxError {\n  type\n  error\n  constructor(e: ErrorEvents) {\n    super(`TxError: ${e.event} - ${e.error}`)\n    this.type = e.event\n    this.error = e.error\n    this.name = \"TransactionError\"\n  }\n}\n\nexport const getTransaction =\n  (request: ClientRequest<string, TxEventRpc>) =>\n  (\n    namespace: string,\n    tx: string,\n    next: (event: TxEvent) => void,\n    error: (e: Error) => void,\n  ) => {\n    let cancel = request(namespace + \"_unstable_submitAndWatch\", [tx], {\n      onSuccess: (subscriptionId, follow) => {\n        const done = follow(\n          namespace + \"_unstable_watchEvent\",\n          subscriptionId,\n          {\n            next: (event) => {\n              if (isTerminalEvent(event)) {\n                done()\n                cancel = noop\n                if (event.event !== \"finalized\")\n                  return error(new TransactionError(event))\n              }\n              next(eventToType(event))\n            },\n            error(e) {\n              if (!(e instanceof DestroyedError)) cancel()\n              cancel = noop\n              error(e)\n            },\n          },\n        )\n\n        cancel = () => {\n          done()\n          request(namespace + \"_unstable_unwatch\", [subscriptionId])\n        }\n      },\n      onError: error,\n    })\n\n    return () => {\n      cancel()\n    }\n  }\n","export class StopError extends Error {\n  constructor() {\n    super(\"ChainHead stopped\")\n    this.name = \"StopError\"\n  }\n}\n\nexport class DisjointError extends Error {\n  constructor() {\n    super(\"ChainHead disjointed\")\n    this.name = \"DisjointError\"\n  }\n}\n\nexport class OperationLimitError extends Error {\n  constructor() {\n    super(\"ChainHead operations limit reached\")\n    this.name = \"OperationLimitError\"\n  }\n}\n\nexport class OperationError extends Error {\n  constructor(error: string) {\n    super(error)\n    this.name = \"OperationError\"\n  }\n}\n\nexport class OperationInaccessibleError extends Error {\n  constructor() {\n    super(\"ChainHead operation inaccessible\")\n    this.name = \"OperationInaccessibleError\"\n  }\n}\n","import { abortablePromiseFn, noop } from \"@/internal-utils\"\nimport {\n  CommonOperationEventsRpc,\n  OperationResponseRpc,\n} from \"./json-rpc-types\"\nimport {\n  OperationError,\n  OperationInaccessibleError,\n  OperationLimitError,\n} from \"./errors\"\nimport { ClientInnerRequest } from \"./public-types\"\n\nexport const createOperationPromise =\n  <I extends { operationId: string; event: string }, O, A extends Array<any>>(\n    operationName: string,\n    factory: (\n      ...args: A\n    ) => [\n      Array<any>,\n      (e: I, res: (x: O) => void, rej: (e: Error) => void) => void,\n    ],\n  ) =>\n  (\n    request: ClientInnerRequest<\n      OperationResponseRpc,\n      I | CommonOperationEventsRpc\n    >,\n  ) =>\n    abortablePromiseFn<O, A>((res, rej, ...args) => {\n      const [requestArgs, logicCb] = factory(...args)\n      let cancel = request(operationName, requestArgs, {\n        onSuccess: (response, followSubscription) => {\n          if (response.result === \"limitReached\") {\n            cancel = noop\n            return rej(new OperationLimitError())\n          }\n\n          let isOperationGoing = true\n          let done = noop\n          const _res = (x: O) => {\n            isOperationGoing = false\n            done()\n            res(x)\n          }\n          const _rej = (x: Error) => {\n            isOperationGoing = false\n            done()\n            rej(x)\n          }\n\n          done = followSubscription(response.operationId, {\n            next: (e) => {\n              const _e = e as CommonOperationEventsRpc\n              if (_e.event === \"operationError\") {\n                rej(new OperationError(_e.error))\n              } else if (_e.event === \"operationInaccessible\") {\n                rej(new OperationInaccessibleError())\n              } else {\n                logicCb(e as I, _res, _rej)\n              }\n            },\n            error: _rej,\n          })\n\n          cancel = () => {\n            if (!isOperationGoing) return\n            done()\n            request(\"chainHead_unstable_stopOperation\", [response.operationId])\n          }\n        },\n        onError: rej,\n      })\n\n      return () => {\n        cancel()\n      }\n    })\n","import type { OperationBodyDoneRpc } from \"./json-rpc-types\"\nimport { createOperationPromise } from \"./operation-promise\"\n\nexport const createBodyFn = createOperationPromise(\n  \"chainHead_unstable_body\",\n  (hash: string) => [\n    [hash],\n    (e: OperationBodyDoneRpc, res: (x: Array<string>) => void) => {\n      res(e.value)\n    },\n  ],\n)\n","import type { OperationCallDoneRpc } from \"./json-rpc-types\"\nimport { createOperationPromise } from \"./operation-promise\"\n\nexport const createCallFn = createOperationPromise(\n  \"chainHead_unstable_call\",\n  (hash: string, fnName: string, callParameters: string) => [\n    [hash, fnName, callParameters],\n    (e: OperationCallDoneRpc, res: (output: string) => void) => {\n      res(e.output)\n    },\n  ],\n)\n","import { ClientInnerRequest } from \"./public-types\"\n\nexport const createHeaderFn =\n  (request: ClientInnerRequest<string, unknown>) => (hash: string) =>\n    new Promise<string>((res, rej) => {\n      request(\"chainHead_unstable_header\", [hash], {\n        onSuccess: res,\n        onError: rej,\n      })\n    })\n","import { noop } from \"@polkadot-api/utils\"\nimport {\n  ClientInnerRequest,\n  FollowResponse,\n  OperationError,\n  OperationInaccessibleError,\n  OperationLimitError,\n} from \"..\"\nimport {\n  CommonOperationEventsRpc,\n  LimitReachedRpc,\n  OperationStorageDoneRpc,\n  OperationStorageItemsRpc,\n  OperationWaitingForContinueRpc,\n  OperationStorageStartedRpc,\n} from \"./json-rpc-types\"\n\nexport const createStorageCb =\n  (\n    request: ClientInnerRequest<\n      OperationStorageStartedRpc | LimitReachedRpc,\n      | CommonOperationEventsRpc\n      | OperationStorageItemsRpc\n      | OperationStorageDoneRpc\n      | OperationWaitingForContinueRpc\n    >,\n  ): FollowResponse[\"storageSubscription\"] =>\n  (hash, inputs, childTrie, onItems, onError, onDone, onDiscardedItems) => {\n    if (inputs.length === 0) {\n      onDone()\n      return noop\n    }\n\n    let cancel = request(\n      \"chainHead_unstable_storage\",\n      [hash, inputs, childTrie],\n      {\n        onSuccess: (response, followSubscription) => {\n          if (\n            response.result === \"limitReached\" ||\n            response.discardedItems === inputs.length\n          )\n            return onError(new OperationLimitError())\n\n          const doneListening = followSubscription(response.operationId, {\n            next: (event) => {\n              switch (event.event) {\n                case \"operationStorageItems\": {\n                  onItems(event.items)\n                  break\n                }\n                case \"operationStorageDone\": {\n                  _onDone()\n                  break\n                }\n                case \"operationError\": {\n                  _onError(new OperationError(event.error))\n                  break\n                }\n                case \"operationInaccessible\": {\n                  _onError(new OperationInaccessibleError())\n                  break\n                }\n                default:\n                  request(\"chainHead_unstable_continue\", [])\n              }\n            },\n            error: onError,\n          })\n\n          cancel = () => {\n            doneListening()\n            request(\"chainHead_unstable_stopOperation\", [response.operationId])\n          }\n\n          const _onError = (e: Error) => {\n            cancel = noop\n            doneListening()\n            onError(e)\n          }\n\n          const _onDone = () => {\n            cancel = noop\n            doneListening()\n            onDone()\n          }\n\n          onDiscardedItems(response.discardedItems)\n        },\n        onError,\n      },\n    )\n\n    return () => {\n      cancel()\n    }\n  }\n","import { ClientInnerRequest, FollowResponse, OperationLimitError } from \"..\"\nimport type {\n  CommonOperationEventsRpc,\n  LimitReachedRpc,\n  OperationStorageDoneRpc,\n  OperationStorageItemsRpc,\n  OperationWaitingForContinueRpc,\n  OperationStorageStartedRpc,\n} from \"./json-rpc-types\"\nimport { abortablePromiseFn } from \"@/internal-utils\"\nimport { createStorageCb } from \"./storage-subscription\"\n\nexport const createStorageFn = (\n  request: ClientInnerRequest<\n    OperationStorageStartedRpc | LimitReachedRpc,\n    | CommonOperationEventsRpc\n    | OperationStorageItemsRpc\n    | OperationStorageDoneRpc\n    | OperationWaitingForContinueRpc\n  >,\n): FollowResponse[\"storage\"] => {\n  const cbStore = createStorageCb(request)\n  return abortablePromiseFn((resolve, reject, hash, type, key, childTrie) => {\n    const isDescendants = type.startsWith(\"descendants\")\n    let result: any = isDescendants ? [] : null\n\n    const onItems: Parameters<typeof cbStore>[3] = isDescendants\n      ? (items) => {\n          result.push(...items)\n        }\n      : (items) => {\n          result = items[0]?.[type as \"value\"]\n        }\n\n    const cancel = cbStore(\n      hash,\n      [{ key, type }],\n      childTrie ?? null,\n      onItems,\n      reject,\n      () => {\n        resolve(result)\n      },\n      (nDiscarded) => {\n        if (nDiscarded > 0) {\n          cancel()\n          reject(new OperationLimitError())\n        }\n      },\n    )\n    return cancel\n  })\n}\n","import { ClientInnerRequest } from \"./public-types\"\n\nexport const createUnpinFn =\n  (request: ClientInnerRequest<null, unknown>) => (hashes: string[]) =>\n    new Promise<void>((res, rej) => {\n      request(\"chainHead_unstable_unpin\", [hashes], {\n        onSuccess() {\n          res()\n        },\n        onError: rej,\n      })\n    })\n","import type { ClientRequest, FollowSubscriptionCb } from \"@/client\"\nimport type {\n  FollowEventWithRuntimeRpc,\n  FollowEventWithoutRuntimeRpc,\n  OperationEventsRpc,\n  StopRpc,\n} from \"./json-rpc-types\"\nimport type {\n  ChainHead,\n  ClientInnerRequest,\n  FollowEventWithoutRuntime,\n  FollowEventWithRuntime,\n  FollowResponse,\n} from \"./public-types\"\nimport {\n  Subscriber,\n  getSubscriptionsManager,\n  noop,\n  deferred,\n  OrphanMessages,\n} from \"@/internal-utils\"\nimport { createBodyFn } from \"./body\"\nimport { createCallFn } from \"./call\"\nimport { createHeaderFn } from \"./header\"\nimport { createStorageFn } from \"./storage\"\nimport { createUnpinFn } from \"./unpin\"\nimport { DisjointError, StopError } from \"./errors\"\nimport { createStorageCb } from \"./storage-subscription\"\nimport { DestroyedError } from \"@/client/DestroyedError\"\n\ntype FollowEventRpc =\n  | FollowEventWithRuntimeRpc\n  | FollowEventWithoutRuntimeRpc\n  | OperationEventsRpc\n  | StopRpc\n\nfunction isOperationEvent(event: FollowEventRpc): event is OperationEventsRpc {\n  return (event as OperationEventsRpc).operationId !== undefined\n}\n\nexport function getChainHead(\n  request: ClientRequest<string, FollowEventRpc>,\n): ChainHead {\n  return (\n    withRuntime: boolean,\n    onFollowEvent:\n      | ((event: FollowEventWithoutRuntime) => void)\n      | ((event: FollowEventWithRuntime) => void),\n    onFollowError: (e: Error) => void,\n  ): FollowResponse => {\n    const subscriptions = getSubscriptionsManager<OperationEventsRpc>()\n    const orphans = new OrphanMessages<OperationEventsRpc>()\n\n    const ongoingRequests = new Set<() => void>()\n    const deferredFollow = deferred<string | Error>()\n    let followSubscription: Promise<string | Error> | string | null =\n      deferredFollow.promise\n\n    const onAllFollowEventsNext = (event: FollowEventRpc) => {\n      if (isOperationEvent(event)) {\n        if (!subscriptions.has(event.operationId)) {\n          orphans.set(event.operationId, event)\n        }\n        return subscriptions.next(event.operationId, event)\n      }\n\n      if (event.event !== \"stop\") {\n        if (event.event === \"initialized\") {\n          return onFollowEvent({\n            type: event.event,\n            finalizedBlockHashes:\n              \"finalizedBlockHash\" in event\n                ? [event.finalizedBlockHash]\n                : event.finalizedBlockHashes,\n            finalizedBlockRuntime: (event as any).finalizedBlockRuntime,\n          })\n        }\n\n        const { event: type, ...rest } = event\n        // This is kinda dangerous, but YOLO\n        return onFollowEvent({ type, ...rest } as any)\n      }\n\n      onFollowError(new StopError())\n      unfollow(false)\n    }\n\n    const onAllFollowEventsError = (error: Error) => {\n      onFollowError(error)\n      unfollow(!(error instanceof DestroyedError))\n    }\n\n    const onFollowRequestSuccess = (\n      subscriptionId: string,\n      follow: FollowSubscriptionCb<FollowEventRpc>,\n    ) => {\n      const done = follow(\"chainHead_unstable_followEvent\", subscriptionId, {\n        next: onAllFollowEventsNext,\n        error: onAllFollowEventsError,\n      })\n\n      unfollow = (sendUnfollow = true) => {\n        followSubscription = null\n        unfollow = noop\n        done()\n        sendUnfollow && request(\"chainHead_unstable_unfollow\", [subscriptionId])\n        subscriptions.errorAll(new DisjointError())\n        ongoingRequests.forEach((cb) => {\n          cb()\n        })\n        ongoingRequests.clear()\n        orphans.clear()\n      }\n\n      followSubscription = subscriptionId\n      deferredFollow.res(subscriptionId)\n    }\n\n    const onFollowRequestError = (e: Error) => {\n      if (e instanceof DestroyedError) {\n        unfollow(false)\n      } else {\n        onFollowError(e)\n      }\n      followSubscription = null\n      deferredFollow.res(e)\n    }\n\n    let unfollow: (internal?: boolean) => void = request(\n      \"chainHead_unstable_follow\",\n      [withRuntime],\n      { onSuccess: onFollowRequestSuccess, onError: onFollowRequestError },\n    )\n\n    const fRequest: ClientInnerRequest<any, any> = (method, params, cb) => {\n      const disjoint = () => {\n        cb?.onError(new DisjointError())\n      }\n\n      if (followSubscription === null) {\n        disjoint()\n        return noop\n      }\n\n      const onSubscription = (subscription: string) => {\n        if (!cb) return request(method, [subscription, ...params])\n\n        ongoingRequests.add(disjoint)\n\n        const onSubscribeOperation = (\n          operationId: string,\n          subscriber: Subscriber<any>,\n        ) => {\n          if (followSubscription === null) {\n            subscriber.error(new DisjointError())\n            return noop\n          }\n\n          subscriptions.subscribe(operationId, subscriber)\n\n          const pending = orphans.retrieve(operationId)\n          if (pending.length) {\n            Promise.resolve().then(() => {\n              pending.forEach((msg) => {\n                subscriptions.next(operationId, msg)\n              })\n            })\n          }\n\n          return () => {\n            subscriptions.unsubscribe(operationId)\n          }\n        }\n\n        const cleanup = request(method, [subscription, ...params], {\n          onSuccess: (response) => {\n            ongoingRequests.delete(disjoint)\n            cb.onSuccess(response, onSubscribeOperation)\n          },\n          onError: (e) => {\n            ongoingRequests.delete(disjoint)\n            cb.onError(e)\n          },\n        })\n\n        return () => {\n          ongoingRequests.delete(disjoint)\n          cleanup()\n        }\n      }\n\n      if (typeof followSubscription === \"string\")\n        return onSubscription(followSubscription)\n\n      let onCancel = noop\n      followSubscription.then((x) => {\n        if (x instanceof Error) return disjoint()\n        if (followSubscription) onCancel = onSubscription(x)\n      })\n\n      return () => {\n        onCancel()\n      }\n    }\n\n    return {\n      unfollow() {\n        unfollow()\n        followSubscription = null\n      },\n      body: createBodyFn(fRequest),\n      call: createCallFn(fRequest),\n      header: createHeaderFn(fRequest),\n      storage: createStorageFn(fRequest),\n      storageSubscription: createStorageCb(fRequest),\n      unpin: createUnpinFn(fRequest),\n      _request: fRequest,\n    }\n  }\n}\n"],"mappings":"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","names":["src_exports","__export","DestroyedError","DisjointError","OperationError","OperationInaccessibleError","OperationLimitError","RpcError","StopError","TransactionError","createClient","__toCommonJS","import_utils","abortablePromiseFn","fn","args","res","rej","cancel","actualArgs","abortSignal","onAbort","withCleanup","x","deferred","res","rej","_res","_rej","noop","getSubscriptionsManager","subscriptions","id","subscriber","data","e","subscribers","s","_messages","_token","OrphanMessages","__privateAdd","__privateSet","__privateGet","key","message","messages","now","entry","result","RpcError","e","__publicField","DestroyedError","createClient","gProvider","responses","subscriptions","getSubscriptionsManager","orphans","OrphanMessages","provider","send","id","method","params","onMessage","message","result","error","subscription","parsed","cb","RpcError","methodName","opaqueId","subscriber","subscriptionId","pending","msg","e","disconnect","DestroyedError","r","nextId","eventToType","input","type","rest","terminalEvents","isTerminalEvent","event","TransactionError","e","__publicField","getTransaction","request","namespace","tx","next","error","cancel","subscriptionId","follow","done","noop","DestroyedError","StopError","DisjointError","OperationLimitError","OperationError","error","OperationInaccessibleError","createOperationPromise","operationName","factory","request","abortablePromiseFn","res","rej","args","requestArgs","logicCb","cancel","response","followSubscription","noop","OperationLimitError","isOperationGoing","done","_res","x","_rej","e","_e","OperationError","OperationInaccessibleError","createBodyFn","createOperationPromise","hash","res","createCallFn","createOperationPromise","hash","fnName","callParameters","e","res","createHeaderFn","request","hash","res","rej","import_utils","createStorageCb","request","hash","inputs","childTrie","onItems","onError","onDone","onDiscardedItems","cancel","response","followSubscription","OperationLimitError","doneListening","event","_onDone","_onError","OperationError","OperationInaccessibleError","e","createStorageFn","request","cbStore","createStorageCb","abortablePromiseFn","resolve","reject","hash","type","key","childTrie","isDescendants","result","cancel","items","nDiscarded","OperationLimitError","createUnpinFn","request","hashes","res","rej","isOperationEvent","event","getChainHead","request","withRuntime","onFollowEvent","onFollowError","subscriptions","getSubscriptionsManager","orphans","OrphanMessages","ongoingRequests","deferredFollow","deferred","followSubscription","onAllFollowEventsNext","type","rest","StopError","unfollow","onAllFollowEventsError","error","DestroyedError","subscriptionId","follow","done","sendUnfollow","noop","DisjointError","cb","e","fRequest","method","params","disjoint","onSubscription","subscription","onSubscribeOperation","operationId","subscriber","pending","msg","cleanup","response","onCancel","x","createBodyFn","createCallFn","createHeaderFn","createStorageFn","createStorageCb","createUnpinFn","import_utils","createClient","provider","client","request","abortablePromiseFn","onSuccess","onError","method","params","rpcMethods","x","getSubmitAndWatchNamespace","input","innerTransaction","getTransaction","getChainHead","tx","next","err","cleanup","isRunning","result"]}