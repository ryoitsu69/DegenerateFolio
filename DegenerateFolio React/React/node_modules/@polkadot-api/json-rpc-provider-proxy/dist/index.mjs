// src/subscription-manager/chainHeadFollow.ts
var START_METHOD = "chainHead_unstable_follow";
var STOP_METHOD = "chainHead_unstable_unfollow";
var NOTIFICATION_METHOD = "chainHead_unstable_followEvent";
var ABORT_EVENT = "stop";
var terminalEvents = /* @__PURE__ */ new Set([
  ABORT_EVENT,
  "operationInaccessible",
  "operationError"
]);
var chainHeadFollow = (onMessage) => ({
  onSent(parsed) {
    if (parsed.method === START_METHOD)
      return {
        type: "subscribe",
        id: parsed.id,
        onRes: (innerParsed) => innerParsed.id === parsed.id ? { id: innerParsed.result } : null
      };
    if (parsed.method === STOP_METHOD)
      return {
        type: "unsubscribe",
        id: Object.values(parsed.params)[0]
      };
    return null;
  },
  onNotification(parsed) {
    if (parsed.method !== NOTIFICATION_METHOD)
      return null;
    return terminalEvents.has(parsed.params.result.event) ? {
      type: "end",
      id: parsed.params.subscription
    } : null;
  },
  onAbort: (id) => {
    onMessage(
      JSON.stringify({
        jsonrpc: "2.0",
        method: NOTIFICATION_METHOD,
        params: {
          subscription: id,
          result: {
            event: ABORT_EVENT
          }
        }
      })
    );
  }
});

// src/subscription-manager/transaction-submit-watch.ts
var START_METHOD2 = "transaction_unstable_submitAndWatch";
var STOP_METHOD2 = "transaction_unstable_unwatch";
var NOTIFICATION_METHOD2 = "transaction_unstable_watchEvent";
var ABORT_EVENT2 = "dropped";
var terminalEvents2 = /* @__PURE__ */ new Set([ABORT_EVENT2, "finalized", "error", "invalid"]);
var txSubmitAndWatch = (onMessage) => ({
  onSent(parsed) {
    if (parsed.method === START_METHOD2)
      return {
        type: "subscribe",
        id: parsed.id,
        onRes: (innerParsed) => innerParsed.id === parsed.id ? { id: innerParsed.result } : null
      };
    if (parsed.method === STOP_METHOD2)
      return {
        type: "unsubscribe",
        id: Object.values(parsed.params)[0]
      };
    return null;
  },
  onNotification(parsed) {
    if (parsed.method !== NOTIFICATION_METHOD2)
      return null;
    return terminalEvents2.has(parsed.params.result.event) ? {
      type: "end",
      id: parsed.params.subscription
    } : null;
  },
  onAbort: (id) => {
    onMessage(
      JSON.stringify({
        jsonrpc: "2.0",
        method: NOTIFICATION_METHOD2,
        params: {
          subscription: id,
          result: {
            event: ABORT_EVENT2
          }
        }
      })
    );
  }
});

// src/subscription-manager/subscription-manager.ts
var addSubscription = ({
  onSent,
  onNotification,
  onAbort
}) => {
  const preActive = /* @__PURE__ */ new Map();
  const active = /* @__PURE__ */ new Set();
  const onDisconnect = () => {
    preActive.clear();
    active.clear();
  };
  return {
    onSent(parsed) {
      const result = onSent(parsed);
      if (!result)
        return;
      if (result.type === "subscribe") {
        preActive.set(result.id, result.onRes);
      } else {
        active.delete(result.id);
      }
    },
    onResponse(parsed) {
      const match = preActive.get(parsed.id)?.(parsed);
      if (!match)
        return;
      preActive.delete(parsed.id);
      active.add(match.id);
    },
    onNotifiaction(parsed) {
      const result = onNotification(parsed);
      if (!result)
        return;
      active.delete(result.id);
    },
    onDisconnect,
    onAbort() {
      const activeCopy = [...active];
      onDisconnect();
      activeCopy.forEach(onAbort);
    }
  };
};
var getSubscriptionManager = (onMessage) => {
  const subscriptions = [chainHeadFollow, txSubmitAndWatch].map(
    (logic) => addSubscription(logic(onMessage))
  );
  return {
    onSent(parsed) {
      subscriptions.forEach((s) => {
        s.onSent(parsed);
      });
    },
    onResponse(parsed) {
      subscriptions.forEach((s) => {
        s.onResponse(parsed);
      });
    },
    onNotifiaction(parsed) {
      subscriptions.forEach((s) => {
        s.onNotifiaction(parsed);
      });
    },
    onDisconnect() {
      subscriptions.forEach((s) => s.onDisconnect());
    },
    onAbort() {
      subscriptions.forEach((s) => s.onAbort());
    }
  };
};

// src/get-sync-provider.ts
var getSyncProvider = (input) => (onMessage) => {
  let provider;
  let bufferedMessages = [];
  const pendingResponses = /* @__PURE__ */ new Set();
  const subscriptionManager = getSubscriptionManager(onMessage);
  const onMessageProxy = (message) => {
    let parsed;
    try {
      parsed = JSON.parse(message);
    } catch (_) {
      console.error(`Unable to parse incoming message: ${message}`);
      return;
    }
    if (parsed.id !== void 0) {
      pendingResponses.delete(parsed.id);
      subscriptionManager.onResponse(parsed);
    } else {
      subscriptionManager.onNotifiaction(parsed);
    }
    onMessage(message);
  };
  const send = (message) => {
    if (!provider)
      return;
    const parsed = JSON.parse(message);
    subscriptionManager.onSent(parsed);
    if (parsed.id)
      pendingResponses.add(parsed.id);
    if (provider instanceof Promise) {
      bufferedMessages.push(message);
    } else
      provider.send(message);
  };
  const onHalt = () => {
    bufferedMessages = [];
    const pendingResponsesCopy = [...pendingResponses];
    pendingResponses.clear();
    if (!provider)
      throw null;
    const result = start();
    subscriptionManager.onAbort();
    pendingResponsesCopy.forEach((id) => {
      onMessage(
        JSON.stringify({
          jsonrpc: "2.0",
          error: { code: -32603, message: "Internal error" },
          id
        })
      );
    });
    return result;
  };
  const start = () => {
    const onResolve = (getProvider) => {
      let halted = false;
      const _onHalt = () => {
        if (halted)
          return;
        halted = true;
        onHalt();
      };
      const _onMessageProxy = (msg) => {
        if (halted)
          return;
        onMessageProxy(msg);
      };
      const result = getProvider(_onMessageProxy, _onHalt);
      bufferedMessages.forEach((m) => {
        result.send(m);
      });
      bufferedMessages = [];
      return provider = result;
    };
    provider = input().then(onResolve, withMacroTask(onHalt));
    return provider;
  };
  const disconnect = () => {
    if (!provider)
      return;
    const finishIt = (input2) => {
      subscriptionManager.onDisconnect();
      pendingResponses.clear();
      provider = null;
      input2?.disconnect();
    };
    if (provider instanceof Promise) {
      provider.then(finishIt, finishIt);
      provider = null;
    } else
      finishIt(provider);
  };
  start();
  return {
    send,
    disconnect
  };
};
var withMacroTask = (inputFn) => (...args) => new Promise((res) => setTimeout(res, 0)).then(() => inputFn(...args));
export {
  getSyncProvider
};
//# sourceMappingURL=index.mjs.map