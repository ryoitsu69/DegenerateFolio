{"version":3,"sources":["../src/index.ts","../src/client.ts","../src/event.ts","../src/utils/shareLatest.ts","../src/utils/firstValueFromWithSignal.ts","../src/utils/concatMapEager.ts","../src/utils/withoutComplete.ts","../src/utils/selfDependant.ts","../src/utils/with-default-value.ts","../src/observableClient/chainHead/chainHead.ts","../src/observableClient/chainHead/streams/follow.ts","../src/observableClient/chainHead/streams/get-runtime-creator.ts","../src/observableClient/chainHead/streams/pinned-blocks.ts","../src/observableClient/chainHead/enhancers/operationLimitRecovery.ts","../src/observableClient/chainHead/enhancers/optionalHash.ts","../src/observableClient/chainHead/enhancers/fromAbortControllerFn.ts","../src/observableClient/chainHead/enhancers/lazyFollower.ts","../src/observableClient/chainHead/enhancers/whileBestBlock.ts","../src/observableClient/chainHead/streams/block-operations.ts","../src/observableClient/chainHead/enhancers/operationInaccessibleRecovery.ts","../src/observableClient/chainHead/storage-queries.ts","../src/observableClient/chainHead/track-tx.ts","../src/observableClient/tx.ts","../src/observableClient/getObservableClient.ts","../src/runtime.ts","../src/runtime-call.ts","../src/storage.ts","../src/tx.ts","../src/re-exports.ts"],"sourcesContent":["export * from \"./client\"\nexport * from \"./observableClient\"\nexport * from \"./re-exports\"\nexport type { BlockInfo } from \"./observableClient\"\nexport type { EventPhase } from \"./event\"\n","import { Descriptors } from \"@polkadot-api/substrate-bindings\"\nimport {\n  SubstrateClient,\n  createClient as createRawClient,\n} from \"@polkadot-api/substrate-client\"\nimport { firstValueFrom } from \"rxjs\"\nimport { EvClient, createEventEntry } from \"./event\"\nimport { getObservableClient } from \"./observableClient\"\nimport { getRuntimeApi } from \"./runtime\"\nimport { RuntimeCall, createRuntimeCallEntry } from \"./runtime-call\"\nimport { createStorageEntry, type StorageEntry } from \"./storage\"\nimport { Transaction, createTxEntry } from \"./tx\"\nimport {\n  CreateClient,\n  CreateTx,\n  HintedSignedExtensions,\n  TypedApi,\n} from \"./types\"\n\nconst createTypedApi = <D extends Descriptors>(\n  descriptors: D,\n  createTxFromAddress: (\n    address: string | Uint8Array,\n    callData: Uint8Array,\n  ) => Promise<Uint8Array>,\n  chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n  client: ReturnType<typeof getObservableClient>,\n): TypedApi<D> => {\n  const { pallets, apis: runtimeApis } = descriptors\n  const query = {} as Record<string, Record<string, StorageEntry<any, any>>>\n  for (const pallet in pallets) {\n    query[pallet] ||= {}\n    const [stgEntries] = pallets[pallet]\n    for (const name in stgEntries) {\n      query[pallet][name] = createStorageEntry(\n        stgEntries[name],\n        pallet,\n        name,\n        chainHead,\n      )\n    }\n  }\n\n  const tx = {} as Record<\n    string,\n    Record<string, (a: any) => Transaction<any, any, any, any>>\n  >\n  for (const pallet in pallets) {\n    tx[pallet] ||= {}\n    const [, txEntries] = pallets[pallet]\n    for (const name in txEntries) {\n      tx[pallet][name] = createTxEntry(\n        txEntries[name],\n        pallet,\n        name,\n        descriptors.asset,\n        chainHead,\n        client,\n        createTxFromAddress,\n      )\n    }\n  }\n\n  const events = {} as Record<string, Record<string, EvClient<any>>>\n  for (const pallet in pallets) {\n    events[pallet] ||= {}\n    const [, , evEntries] = pallets[pallet]\n    for (const name in evEntries) {\n      events[pallet][name] = createEventEntry(\n        evEntries[name],\n        pallet,\n        name,\n        chainHead,\n      )\n    }\n  }\n\n  const apis = {} as Record<string, Record<string, RuntimeCall<any, any>>>\n  for (const api in runtimeApis) {\n    apis[api] ||= {}\n    const methods = runtimeApis[api]\n    for (const method in methods) {\n      apis[api][method] = createRuntimeCallEntry(\n        methods[method],\n        api,\n        method,\n        chainHead,\n      )\n    }\n  }\n\n  return {\n    query: query,\n    tx: tx,\n    event: events,\n    apis,\n    runtime: getRuntimeApi(descriptors, chainHead),\n  } as any\n}\n\nexport const createClient: CreateClient = (connect) => {\n  let createTx: CreateTx\n  const rawClient: SubstrateClient = createRawClient((onMsg) => {\n    const result = connect(onMsg)\n    createTx = result.createTx\n    return result\n  })\n  const client = getObservableClient(rawClient)\n  const chainHead = client.chainHead$()\n\n  const createTxFromAddress = async (\n    address: string | Uint8Array,\n    callData: Uint8Array,\n    hinted?: HintedSignedExtensions,\n  ) => {\n    let publicKey: Uint8Array\n\n    if (address instanceof Uint8Array) publicKey = address\n    else {\n      const { accountId } = await firstValueFrom(\n        chainHead.getRuntimeContext$(null),\n      )\n      publicKey = accountId.enc(address)\n    }\n\n    return createTx(publicKey, callData, hinted)\n  }\n\n  return {\n    finalized$: chainHead.finalized$,\n    bestBlocks$: chainHead.bestBlocks$,\n    getBlockHeader: (hash?: string) =>\n      firstValueFrom(chainHead.header$(hash ?? null)),\n    getBlockBody: chainHead.body$,\n    destroy: () => {\n      chainHead.unfollow()\n      client.destroy()\n    },\n    getTypedApi: <D extends Descriptors>(descriptors: D) =>\n      createTypedApi(descriptors, createTxFromAddress, chainHead, client),\n  }\n}\n","import { PlainDescriptor } from \"@polkadot-api/substrate-bindings\"\nimport { Observable, firstValueFrom, map, mergeMap } from \"rxjs\"\nimport { concatMapEager, shareLatest } from \"./utils\"\nimport {\n  getObservableClient,\n  BlockInfo,\n  RuntimeContext,\n} from \"./observableClient\"\n\nexport type EventPhase =\n  | { type: \"ApplyExtrinsic\"; value: number }\n  | { type: \"Finalization\" }\n  | { type: \"Initialization\" }\n\nexport type EvWatch<T> = (filter?: (value: T) => boolean) => Observable<{\n  meta: {\n    block: BlockInfo\n    phase: EventPhase\n  }\n  payload: T\n}>\n\nexport type EvPull<T> = () => Promise<\n  Array<{\n    meta: {\n      block: BlockInfo\n      phase: EventPhase\n    }\n    payload: T\n  }>\n>\n\nexport type EvFilter<T> = (collection: SystemEvent[\"event\"][]) => Array<T>\n\nexport type EvClient<T> = {\n  watch: EvWatch<T>\n  pull: EvPull<T>\n  filter: EvFilter<T>\n}\n\ntype SystemEvent = {\n  phase: EventPhase\n  event: {\n    type: string\n    value: {\n      type: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\nexport const createEventEntry = <T>(\n  checksum: PlainDescriptor<T>,\n  pallet: string,\n  name: string,\n  chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n): EvClient<T> => {\n  const checksumCheck = (ctx: RuntimeContext) => {\n    const actualChecksum = ctx.checksumBuilder.buildEvent(pallet, name)\n    if (checksum !== actualChecksum)\n      throw new Error(`Incompatible runtime entry Event(${pallet}.${name})`)\n  }\n\n  const shared$ = chainHead.finalized$.pipe(\n    chainHead.withRuntime((x) => x.hash),\n    concatMapEager(([block, ctx]) => {\n      checksumCheck(ctx)\n      return chainHead.eventsAt$(block.hash).pipe(\n        map((events) => {\n          const winners = events.filter(\n            (e) => e.event.type === pallet && e.event.value.type === name,\n          )\n          return winners.map((x) => {\n            return {\n              meta: {\n                phase: x.phase,\n                block,\n              },\n              payload: x.event.value.value,\n            }\n          })\n        }),\n      )\n    }),\n    shareLatest,\n  )\n\n  const watch: EvWatch<T> = (f) =>\n    shared$.pipe(mergeMap((x) => (f ? x.filter((d) => f(d.payload)) : x)))\n\n  const pull: EvPull<T> = () => firstValueFrom(shared$)\n\n  const filter: EvFilter<T> = (events) =>\n    events\n      .filter((e) => e.type === pallet && e.value.type === name)\n      .map((x) => x.value.value)\n\n  return { watch, pull, filter }\n}\n","import { Observable, ReplaySubject, share } from \"rxjs\"\n\nexport const shareLatest: <T>(base: Observable<T>) => Observable<T> = share({\n  connector: () => new ReplaySubject(1),\n  resetOnError: true,\n  resetOnComplete: true,\n  resetOnRefCountZero: true,\n})\n","import { Observable, noop } from \"rxjs\"\n\nexport function firstValueFromWithSignal<T>(\n  source: Observable<T>,\n  signal?: AbortSignal,\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    const onAbort = signal\n      ? () => {\n          subscription.unsubscribe()\n        }\n      : noop\n\n    let isDone = false\n    const subscription = source.subscribe({\n      next: (value) => {\n        resolve(value)\n\n        // if the Observable emits synchronously, then `subscription`\n        // won't exist yet.\n        isDone = true\n        subscription?.unsubscribe()\n      },\n      error: (e) => {\n        reject(e)\n        signal?.removeEventListener(\"abort\", onAbort)\n      },\n      complete: () => {\n        reject(new Error(\"Observable completed without emitting\"))\n        signal?.removeEventListener(\"abort\", onAbort)\n      },\n    })\n\n    // in case that the observable emitted synchronously\n    if (isDone) {\n      subscription.unsubscribe()\n    } else {\n      signal?.addEventListener(\"abort\", onAbort)\n    }\n  })\n}\n","import { defer, Observable, ObservableInput, Subscription } from \"rxjs\"\n\nexport const concatMapEager =\n  <I, O>(\n    mapper: (outterValue: I, index: number) => ObservableInput<O>,\n    concurrent = Infinity,\n  ) =>\n  (source$: Observable<I>) =>\n    new Observable<O>((observer) => {\n      const queues = new Map<number, Observable<O>>()\n      const innerSubscriptions = new Map<number, Subscription>()\n      const results = new Map<number, O[]>()\n\n      let mapperIdx = 0\n      let subscriptionIdx = 0\n      let observerIdx = 0\n\n      const nextSubscription = () => {\n        const inner$ = queues.get(subscriptionIdx)\n        if (!inner$) {\n          if (topSubscription.closed && innerSubscriptions.size === 0) {\n            observer.complete()\n          }\n          return\n        }\n        const idx = subscriptionIdx++\n        queues.delete(idx)\n        if (observerIdx !== idx) {\n          results.set(idx, [])\n        }\n        innerSubscriptions.set(\n          idx,\n          inner$.subscribe({\n            next(x: O) {\n              if (observerIdx === idx) {\n                observer.next(x)\n              } else {\n                results.get(idx)!.push(x)\n              }\n            },\n            complete() {\n              innerSubscriptions.delete(idx)\n              if (idx === observerIdx) {\n                observerIdx++\n                while (results.has(observerIdx)) {\n                  results.get(observerIdx)!.forEach((x) => observer.next(x))\n                  results.delete(observerIdx)\n                  if (innerSubscriptions.has(observerIdx)) {\n                    break\n                  }\n                  observerIdx++\n                }\n              }\n              nextSubscription()\n            },\n            error(e: any) {\n              observer.error(e)\n            },\n          }),\n        )\n      }\n\n      const topSubscription = source$.subscribe({\n        next(outterValue: I) {\n          const idx = mapperIdx++\n          queues.set(\n            idx,\n            defer(() => mapper(outterValue, idx)),\n          )\n          if (innerSubscriptions.size < concurrent) {\n            nextSubscription()\n          }\n        },\n        error(e: any) {\n          observer.error(e)\n        },\n        complete() {\n          if (innerSubscriptions.size === 0) {\n            observer.complete()\n          }\n        },\n      })\n\n      return () => {\n        innerSubscriptions.forEach((subscription) => subscription.unsubscribe())\n        topSubscription.unsubscribe()\n        queues.clear()\n        results.clear()\n      }\n    })\n","import { Observable } from \"rxjs\"\n\nexport const withoutComplete = <T>(source: Observable<T>) =>\n  new Observable<T>((observer) =>\n    source.subscribe({\n      next(x) {\n        observer.next(x)\n      },\n      error(e) {\n        observer.error(e)\n      },\n    }),\n  )\n","import {\n  Observable,\n  Subject,\n  MonoTypeOperatorFunction,\n  BehaviorSubject,\n} from \"rxjs\"\nimport { switchAll, tap } from \"rxjs/operators\"\n\n/**\n * A creation operator that helps at creating observables that have circular\n * dependencies\n *\n * @returns [1, 2]\n * 1. The inner subject as an Observable\n * 2. A pipable operator that taps into the inner Subject\n */\nexport const selfDependent = <T>(): [\n  Observable<T>,\n  () => MonoTypeOperatorFunction<T>,\n] => {\n  const activeSubject: BehaviorSubject<Subject<T>> = new BehaviorSubject(\n    new Subject<T>(),\n  )\n  return [\n    activeSubject.pipe(switchAll()),\n    () =>\n      tap({\n        next: (v) => activeSubject.value.next(v),\n        error: (e) => {\n          activeSubject.value.error(e)\n          activeSubject.next(new Subject<T>())\n        },\n        complete: () => {\n          activeSubject.value.complete()\n          activeSubject.next(new Subject<T>())\n        },\n      }) as MonoTypeOperatorFunction<T>,\n  ]\n}\n","import { Observable } from \"rxjs\"\n\nexport const withDefaultValue =\n  <V, T>(defaultValue: V) =>\n  (source$: Observable<T>): Observable<V | T> =>\n    new Observable((observer) => {\n      let hasEmited = false\n\n      const subscription = source$.subscribe({\n        next(v) {\n          hasEmited = true\n          observer.next(v)\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          observer.complete()\n        },\n      })\n\n      if (!hasEmited) observer.next(defaultValue)\n\n      return subscription\n    })\n","import { concatMapEager, shareLatest } from \"@/utils\"\nimport { blockHeader } from \"@polkadot-api/substrate-bindings\"\nimport {\n  ChainHead,\n  DisjointError,\n  FollowEventWithRuntime,\n  StorageItemInput,\n  StorageResult,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  ReplaySubject,\n  Subject,\n  distinctUntilChanged,\n  from,\n  map,\n  merge,\n  mergeMap,\n  scan,\n  share,\n  switchMap,\n  take,\n} from \"rxjs\"\n\nimport type {\n  PinnedBlock,\n  BlockUsageEvent,\n  RuntimeContext,\n  SystemEvent,\n} from \"./streams\"\nimport { getFollow$, getPinnedBlocks$ } from \"./streams\"\nimport {\n  fromAbortControllerFn,\n  getWithOptionalhash$,\n  getWithRecovery,\n  withLazyFollower,\n  withOperationInaccessibleRecovery,\n  withEnsureCanonicalChain,\n} from \"./enhancers\"\nimport { withDefaultValue } from \"@/utils\"\nimport { getRecoveralStorage$ } from \"./storage-queries\"\nimport { getTrackTx } from \"./track-tx\"\n\nexport type { RuntimeContext, SystemEvent }\nexport type { FollowEventWithRuntime }\n\nexport type BlockInfo = {\n  hash: string\n  number: number\n  parent: string\n}\n\nconst toBlockInfo = ({ hash, number, parent }: PinnedBlock): BlockInfo => ({\n  hash,\n  number,\n  parent,\n})\n\nexport const getChainHead$ = (chainHead: ChainHead) => {\n  const { getFollower, unfollow, follow$ } = getFollow$(chainHead)\n  const lazyFollower = withLazyFollower(getFollower)\n  const { withRecovery, withRecoveryFn } = getWithRecovery()\n\n  const blockUsage$ = new Subject<BlockUsageEvent>()\n  const withRefcount =\n    <A extends Array<any>, T>(\n      fn: (hash: string, ...args: A) => Observable<T>,\n    ): ((hash: string, ...args: A) => Observable<T>) =>\n    (hash, ...args) =>\n      new Observable((observer) => {\n        blockUsage$.next({ type: \"blockUsage\", value: { type: \"hold\", hash } })\n        const subscription = fn(hash, ...args).subscribe(observer)\n        return () => {\n          blockUsage$.next({\n            type: \"blockUsage\",\n            value: { type: \"release\", hash },\n          })\n          subscription.unsubscribe()\n        }\n      })\n\n  const getHeader = (hash: string) =>\n    getFollower().header(hash).then(blockHeader.dec)\n\n  const unpin = (hashes: string[]) =>\n    getFollower()\n      .unpin(hashes)\n      .catch((e) => {\n        if (e instanceof DisjointError) return\n        throw e\n      })\n\n  const commonEnhancer = <A extends Array<any>, T>(\n    fn: (\n      key: string,\n      ...args: [...A, ...[abortSignal: AbortSignal]]\n    ) => Promise<T>,\n  ) =>\n    withRefcount(\n      withEnsureCanonicalChain(\n        pinnedBlocks$,\n        follow$,\n        withOperationInaccessibleRecovery(\n          withRecoveryFn(fromAbortControllerFn(fn)),\n        ),\n      ),\n    )\n\n  const _call$ = withOperationInaccessibleRecovery(\n    withRecoveryFn(fromAbortControllerFn(lazyFollower(\"call\"))),\n  )\n\n  const cache = new Map<string, Map<string, Observable<any>>>()\n  const pinnedBlocks$ = getPinnedBlocks$(\n    follow$,\n    getHeader,\n    _call$,\n    blockUsage$,\n    (blocks) => {\n      unpin(blocks)\n      blocks.forEach((hash) => {\n        cache.delete(hash)\n      })\n    },\n  )\n\n  const getRuntimeContext$ = (hash: string) =>\n    pinnedBlocks$.pipe(\n      take(1),\n      mergeMap(\n        (pinned) => pinned.runtimes[pinned.blocks.get(hash)!.runtime].runtime,\n      ),\n    )\n\n  const withRuntime =\n    <T>(mapper: (x: T) => string) =>\n    (source$: Observable<T>): Observable<[T, RuntimeContext]> =>\n      source$.pipe(\n        concatMapEager((x) =>\n          getRuntimeContext$(mapper(x)).pipe(map((runtime) => [x, runtime])),\n        ),\n      )\n\n  const upsertCachedStream = <T>(\n    hash: string,\n    key: string,\n    stream: Observable<T>,\n  ): Observable<T> => {\n    const cached = cache.get(hash)?.get(key)\n    if (cached) return cached\n\n    if (!cache.has(hash)) cache.set(hash, new Map())\n\n    const result = stream.pipe(\n      share({\n        connector: () => new ReplaySubject<T>(),\n        resetOnError: true,\n        resetOnRefCountZero: true,\n        resetOnComplete: false,\n      }),\n    )\n    cache.get(hash)!.set(key, result)\n\n    return result\n  }\n\n  const finalized$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.finalized === b.finalized),\n    map((pinned) => toBlockInfo(pinned.blocks.get(pinned.finalized)!)),\n    shareLatest,\n  )\n\n  const bestBlocks$ = pinnedBlocks$.pipe(\n    distinctUntilChanged(\n      (prev, current) =>\n        prev.finalized === current.finalized && prev.best === current.best,\n    ),\n    scan((acc, pinned) => {\n      let current = pinned.best\n      const result = new Map<string, BlockInfo>()\n      while (current !== pinned.finalized) {\n        const block =\n          acc.get(current) || toBlockInfo(pinned.blocks.get(current)!)\n        result.set(current, block)\n        current = block.parent\n      }\n      return result\n    }, new Map<string, BlockInfo>()),\n    map((x) => [...x.values()]),\n    shareLatest,\n  )\n\n  const runtime$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.finalizedRuntime === b.finalizedRuntime),\n    switchMap(({ finalizedRuntime: { runtime } }) =>\n      runtime.pipe(withDefaultValue(null)),\n    ),\n    shareLatest,\n  )\n\n  const metadata$ = runtime$.pipe(map((x) => x?.metadata ?? null))\n\n  const withOptionalHash$ = getWithOptionalhash$(\n    finalized$.pipe(map((x) => x.hash)),\n  )\n\n  const _body$ = commonEnhancer(lazyFollower(\"body\"))\n  const body$ = (hash: string) => upsertCachedStream(hash, \"body\", _body$(hash))\n  const trackTx$ = getTrackTx(pinnedBlocks$, body$)\n\n  const _storage$ = commonEnhancer(lazyFollower(\"storage\"))\n\n  const storage$ = withOptionalHash$(\n    <Type extends StorageItemInput[\"type\"], T>(\n      hash: string,\n      type: Type,\n      keyMapper: (ctx: RuntimeContext) => string,\n      childTrie: string | null = null,\n      mapper?: (data: StorageResult<Type>, ctx: RuntimeContext) => T,\n    ): Observable<unknown extends T ? StorageResult<Type> : T> =>\n      pinnedBlocks$.pipe(\n        take(1),\n        mergeMap(\n          (pinned) => pinned.runtimes[pinned.blocks.get(hash)!.runtime].runtime,\n        ),\n        mergeMap((ctx) => {\n          const key = keyMapper(ctx)\n          const unMapped$ = upsertCachedStream(\n            hash,\n            `storage-${type}-${key}-${childTrie ?? \"\"}`,\n            _storage$(hash, type, key, childTrie),\n          )\n\n          return mapper\n            ? upsertCachedStream(\n                hash,\n                `storage-${type}-${key}-${childTrie ?? \"\"}-dec`,\n                unMapped$.pipe(map((x) => mapper(x, ctx))),\n              )\n            : unMapped$\n        }),\n      ) as Observable<unknown extends T ? StorageResult<Type> : T>,\n  )\n\n  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery)\n  const storageQueries$ = withOperationInaccessibleRecovery(\n    withOptionalHash$(\n      withRefcount(\n        (hash: string, queries: Array<StorageItemInput>, childTrie?: string) =>\n          recoveralStorage$(hash, queries, childTrie ?? null, false),\n      ),\n    ),\n  )\n\n  const header$ = withOptionalHash$(\n    withRefcount((hash: string) => from(getHeader(hash))),\n  )\n\n  // calling `unfollow` also kills the subscription due to the fact\n  // that `follow$` completes, which makes all other streams to\n  // also complete (or error, in the case of ongoing operations)\n  merge(runtime$, bestBlocks$).subscribe()\n\n  const eventsAt$ = (hash: string | null) =>\n    storage$(\n      hash,\n      \"value\",\n      (ctx) => ctx.events.key,\n      null,\n      (x, ctx) => ctx.events.dec(x!),\n    )\n\n  return {\n    follow$,\n    finalized$,\n    bestBlocks$,\n    runtime$,\n    metadata$,\n\n    header$,\n    body$,\n    call$: withOptionalHash$(withRefcount(_call$)),\n    storage$,\n    storageQueries$,\n    eventsAt$,\n\n    trackTx$,\n    withRuntime,\n    getRuntimeContext$: withOptionalHash$(getRuntimeContext$),\n    unfollow,\n  }\n}\n","import {\n  ChainHead,\n  FollowEventWithRuntime,\n  FollowResponse,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, noop, share } from \"rxjs\"\n\nexport const getFollow$ = (chainHead: ChainHead) => {\n  let follower: FollowResponse\n  let unfollow: () => void = noop\n\n  const follow$ = new Observable<FollowEventWithRuntime>((observer) => {\n    follower = chainHead(\n      true,\n      (e) => {\n        observer.next(e)\n      },\n      (e) => {\n        console.warn(\"chainHead crashed\")\n        console.error(e)\n        observer.error(e)\n      },\n    )\n    unfollow = () => {\n      observer.complete()\n      follower.unfollow()\n    }\n  }).pipe(share())\n\n  return {\n    getFollower: () => {\n      if (!follower) throw new Error(\"Missing chainHead subscription\")\n      return follower\n    },\n    unfollow: () => {\n      unfollow()\n    },\n    follow$,\n  }\n}\n","import {\n  getChecksumBuilder,\n  getDynamicBuilder,\n  getLookupFn,\n} from \"@polkadot-api/metadata-builders\"\nimport {\n  AccountId,\n  Codec,\n  Decoder,\n  SS58String,\n  Tuple,\n  Option,\n  V15,\n  compact,\n  metadata,\n  u32,\n  Encoder,\n  _void,\n} from \"@polkadot-api/substrate-bindings\"\nimport { toHex } from \"@polkadot-api/utils\"\nimport { Observable, map, shareReplay } from \"rxjs\"\n\nexport type SystemEvent = {\n  phase:\n    | { type: \"ApplyExtrinsic\"; value: number }\n    | { type: \"Finalization\" }\n    | { type: \"Initialization\" }\n  event: {\n    type: string\n    value: {\n      type: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\nexport interface RuntimeContext {\n  metadata: V15\n  checksumBuilder: ReturnType<typeof getChecksumBuilder>\n  dynamicBuilder: ReturnType<typeof getDynamicBuilder>\n  events: {\n    key: string\n    dec: Decoder<Array<SystemEvent>>\n  }\n  accountId: Codec<SS58String>\n  asset: [Encoder<any>, string | null]\n}\n\nexport interface Runtime {\n  at: string\n  runtime: Observable<RuntimeContext>\n  addBlock: (block: string) => Runtime\n  deleteBlocks: (blocks: string[]) => number\n  usages: Set<string>\n}\n\nconst opaqueMeta = Option(Tuple(compact, metadata))\n\nconst v15Args = toHex(u32.enc(15))\nexport const getRuntimeCreator =\n  (call$: (hash: string, method: string, args: string) => Observable<string>) =>\n  (hash: string): Runtime => {\n    const usages = new Set<string>([hash])\n\n    const runtimeContext$: Observable<RuntimeContext> = call$(\n      hash,\n      \"Metadata_metadata_at_version\",\n      v15Args,\n    ).pipe(\n      map((response) => {\n        const metadata = opaqueMeta.dec(response)![1]\n        if (metadata.metadata.tag !== \"v15\")\n          throw new Error(\"Wrong metadata version\")\n        const v15 = metadata.metadata.value\n        const checksumBuilder = getChecksumBuilder(v15)\n        const dynamicBuilder = getDynamicBuilder(v15)\n        const events = dynamicBuilder.buildStorage(\"System\", \"Events\")\n\n        const assetPayment =\n          metadata.metadata.value.extrinsic.signedExtensions.find(\n            (x) => x.identifier === \"ChargeAssetTxPayment\",\n          )\n\n        let _assetId: null | number = null\n        if (assetPayment) {\n          const assetTxPayment = getLookupFn(metadata.metadata.value.lookup)(\n            assetPayment.type,\n          )\n          if (assetTxPayment.type === \"struct\") {\n            const optionalAssetId = assetTxPayment.value.asset_id\n            if (optionalAssetId.type === \"option\")\n              _assetId = optionalAssetId.value.id\n          }\n        }\n\n        const asset: [Encoder<any>, string | null] =\n          _assetId === null\n            ? [_void.enc, null]\n            : [\n                dynamicBuilder.buildDefinition(_assetId).enc,\n                checksumBuilder.buildDefinition(_assetId),\n              ]\n\n        return {\n          asset,\n          metadata: v15,\n          checksumBuilder,\n          dynamicBuilder,\n          events: {\n            key: events.enc(),\n            dec: events.dec as any,\n          },\n          accountId: AccountId(dynamicBuilder.ss58Prefix),\n        }\n      }),\n      shareReplay(1),\n    )\n\n    const result: Runtime = {\n      at: hash,\n      runtime: runtimeContext$,\n      addBlock: (block: string) => {\n        usages.add(block)\n        return result\n      },\n      deleteBlocks: (blocks) => {\n        blocks.forEach((block) => {\n          usages.delete(block)\n        })\n        return usages.size\n      },\n      usages,\n    }\n    runtimeContext$.subscribe()\n\n    return result\n  }\n","import { selfDependent, shareLatest } from \"@/utils\"\nimport { BlockHeader } from \"@polkadot-api/substrate-bindings\"\nimport { FollowEventWithRuntime } from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  Subject,\n  Subscription,\n  concatMap,\n  defer,\n  filter,\n  interval,\n  map,\n  merge,\n  of,\n  pairwise,\n  scan,\n  tap,\n  withLatestFrom,\n} from \"rxjs\"\nimport { Runtime, getRuntimeCreator } from \"./get-runtime-creator\"\n\nexport interface PinnedBlock {\n  hash: string\n  number: number\n  parent: string\n  children: Set<string>\n  runtime: string\n  refCount: number\n}\n\nexport interface BlockUsageEvent {\n  type: \"blockUsage\"\n  value: { type: \"hold\"; hash: string } | { type: \"release\"; hash: string }\n}\n\nexport type PinnedBlocks = {\n  best: string\n  finalized: string\n  runtimes: Record<string, Runtime>\n  blocks: Map<string, PinnedBlock>\n  finalizedRuntime: Runtime\n}\n\nexport const getPinnedBlocks$ = (\n  follow$: Observable<FollowEventWithRuntime>,\n  getHeader: (hash: string) => Promise<BlockHeader>,\n  call$: (hash: string, method: string, args: string) => Observable<string>,\n  blockUsage$: Observable<BlockUsageEvent>,\n  onUnpin: (blocks: string[]) => void,\n) => {\n  const getRuntime = getRuntimeCreator(call$)\n  const followWithInitializedNumber$ = follow$.pipe(\n    concatMap((event) => {\n      return event.type !== \"initialized\"\n        ? of(event)\n        : getHeader(event.finalizedBlockHashes.slice(-1)[0]).then((header) => ({\n            ...event,\n            number: header.number,\n            parentHash: header.parentHash,\n          }))\n    }),\n  )\n\n  const [unpinnedBlocks$, connectUnpinnedBlocks] = selfDependent<string[]>()\n\n  const prunedBlocks$ = new Subject<string[]>()\n  const cleaner$ = merge(\n    prunedBlocks$,\n    interval(100).pipe(\n      withLatestFrom(defer(() => pinnedBlocks$)),\n      map(([, pinned]) => {\n        const result = new Set<string>()\n\n        let current = pinned.blocks.get(pinned.finalized)!\n        while (pinned.blocks.has(current.parent)) {\n          current = pinned.blocks.get(current.parent)!\n          if (!current.refCount) result.add(current.hash)\n        }\n\n        return result\n      }),\n      pairwise(),\n      map(([prev, current]) => [...current].filter((x) => prev.has(x))),\n      filter((x) => x.length > 0),\n    ),\n  ).pipe(\n    connectUnpinnedBlocks(),\n    tap(onUnpin),\n    <T>(source$: Observable<T>) =>\n      new Observable<never>((observer) => {\n        let subscription: Subscription | null = null\n        // let's delay the initial subscription\n        const token = setTimeout(() => {\n          subscription = source$.subscribe({\n            error(e) {\n              observer.error(e)\n            },\n          })\n          subscription.add(\n            // and let's make sure that it completes when follow$ is done\n            follow$.subscribe({\n              complete() {\n                observer.complete()\n              },\n            }),\n          )\n        }, 0)\n\n        return () => {\n          clearTimeout(token)\n          subscription?.unsubscribe()\n        }\n      }),\n  )\n\n  const pinnedBlocks$: Observable<PinnedBlocks> = merge(\n    blockUsage$,\n    followWithInitializedNumber$,\n    unpinnedBlocks$.pipe(\n      map((hashes) => ({ type: \"unpin\" as \"unpin\", hashes })),\n    ),\n    cleaner$,\n  ).pipe(\n    scan(\n      (acc, event) => {\n        switch (event.type) {\n          case \"initialized\":\n            const [hash] = event.finalizedBlockHashes.slice(-1)\n            acc.finalized = acc.best = hash\n\n            acc.blocks.set(hash, {\n              hash,\n              parent: event.parentHash,\n              children: new Set(),\n              runtime: hash,\n              refCount: 0,\n              number: event.number,\n            })\n            acc.runtimes[hash] = getRuntime(hash)\n            acc.finalizedRuntime = acc.runtimes[hash]\n            return acc\n\n          case \"newBlock\": {\n            const { parentBlockHash: parent, blockHash: hash } = event\n            const parentNode = acc.blocks.get(parent)!\n            parentNode.children.add(hash)\n            if (event.newRuntime) {\n              acc.runtimes[hash] = getRuntime(hash)\n              acc.runtimes[hash].runtime.subscribe()\n            }\n            const block = {\n              hash,\n              number: parentNode.number + 1,\n              parent: parent,\n              children: new Set<string>(),\n              runtime: event.newRuntime ? hash : parentNode.runtime,\n              refCount: 0,\n            }\n            acc.blocks.set(hash, block)\n            acc.runtimes[block.runtime].addBlock(hash)\n            return acc\n          }\n\n          case \"bestBlockChanged\": {\n            acc.best = event.bestBlockHash\n            return acc\n          }\n\n          case \"finalized\": {\n            acc.finalized = event.finalizedBlockHashes.slice(-1)[0]\n            acc.finalizedRuntime =\n              acc.runtimes[acc.blocks.get(acc.finalized)!.runtime]\n            if (event.prunedBlockHashes.length > 0)\n              prunedBlocks$.next(event.prunedBlockHashes)\n            return acc\n          }\n\n          case \"blockUsage\": {\n            acc.blocks.get(event.value.hash)!.refCount +=\n              event.value.type === \"hold\" ? 1 : -1\n            return acc\n          }\n\n          case \"unpin\": {\n            event.hashes.forEach((h) => {\n              if (!acc.blocks.has(h)) return\n\n              acc.blocks.get(acc.blocks.get(h)!.parent)?.children.delete(h)\n              acc.blocks.delete(h)\n            })\n\n            Object.entries(acc.runtimes)\n              .map(([key, value]) => ({\n                key,\n                usages: value.deleteBlocks(event.hashes),\n              }))\n              .filter((x) => x.usages === 0)\n              .map((x) => x.key)\n              .forEach((unsusedRuntime) => {\n                delete acc.runtimes[unsusedRuntime]\n              })\n\n            return acc\n          }\n        }\n      },\n      {\n        best: \"\",\n        finalized: \"\",\n        runtimes: {},\n        blocks: new Map(),\n        finalizedRuntime: {},\n      } as PinnedBlocks,\n    ),\n    map((x) => ({ ...x })),\n    shareLatest,\n  )\n\n  return pinnedBlocks$\n}\n","import { OperationLimitError } from \"@polkadot-api/substrate-client\"\nimport type { Subscriber } from \"rxjs\"\nimport { Observable } from \"rxjs\"\n\ninterface PendingTaskNode<T> {\n  value: T\n  next?: PendingTaskNode<T>\n  prev?: PendingTaskNode<T>\n}\n\nexport default class PendingTaskQueue<T> {\n  private first?: PendingTaskNode<T>\n  private last?: PendingTaskNode<T>\n\n  private getRemoveFn(node: PendingTaskNode<T>) {\n    return () => {\n      if (node.prev) {\n        node.prev.next = node.next\n      } else {\n        this.first = node.next\n      }\n\n      if (node.next) {\n        node.next.prev = node.prev\n      } else {\n        this.last = node.prev\n      }\n\n      delete node.prev\n      delete node.next\n    }\n  }\n\n  push(value: T) {\n    const newNode: PendingTaskNode<T> = { value }\n\n    if (this.last === undefined) {\n      this.last = this.first = newNode\n    } else {\n      this.last.next = newNode\n      newNode.prev = this.last\n\n      this.last = newNode\n    }\n\n    return this.getRemoveFn(newNode)\n  }\n\n  unshift(value: T) {\n    this.first = { value, next: this.first }\n    this.first.next && (this.first.next.prev = this.first)\n    this.last ||= this.first\n    return this.getRemoveFn(this.first)\n  }\n\n  pop() {\n    const result = this.first?.value\n\n    if (this.first) {\n      this.first = this.first.next\n\n      if (!this.first) {\n        this.last = undefined\n      } else {\n        delete this.first.prev?.next\n        delete this.first.prev\n      }\n    }\n\n    return result\n  }\n\n  isEmpty() {\n    return !this.first\n  }\n}\n\nexport const getWithRecovery = () => {\n  const tearDownOperations = new Map<Observable<any>, () => void>()\n\n  const setTeardown = (observable: Observable<any>, cb: () => void) => {\n    tearDownOperations.set(observable, () => {\n      tearDownOperations.delete(observable)\n      cb()\n    })\n  }\n\n  const teardown = (observable: Observable<any>) => {\n    tearDownOperations.get(observable)?.()\n  }\n\n  const pendingTasks = new PendingTaskQueue<{\n    observer: Subscriber<any>\n    source$: Observable<any>\n  }>()\n  const unshift = pendingTasks.unshift.bind(pendingTasks)\n  const push = pendingTasks.push.bind(pendingTasks)\n\n  const addTask = (\n    task: {\n      observer: Subscriber<any>\n      source$: Observable<any>\n    },\n    topPriority: boolean,\n  ) => {\n    const fn = topPriority ? unshift : push\n    setTeardown(task.source$, fn(task))\n  }\n\n  const onEmptySlot = () => {\n    const data = pendingTasks.pop()\n    if (!data) return\n\n    tearDownOperations.delete(data.source$)\n    process(data)\n  }\n\n  const process = <T>(data: {\n    observer: Subscriber<T>\n    source$: Observable<T>\n  }) => {\n    const { source$, observer } = data\n\n    const subscription = source$.subscribe({\n      next(x) {\n        observer.next(x)\n      },\n      error(e) {\n        teardown(source$)\n        if (e instanceof OperationLimitError) return addTask(data, true)\n\n        observer.error(e)\n        onEmptySlot()\n      },\n      complete() {\n        observer.complete()\n        onEmptySlot()\n      },\n    })\n\n    if (!observer.closed) {\n      setTeardown(source$, () => {\n        subscription.unsubscribe()\n      })\n    }\n  }\n\n  const withRecovery =\n    (topPriority = false) =>\n    <T>(source$: Observable<T>): Observable<T> =>\n      new Observable((observer) => {\n        const pendingTask = { observer, source$ }\n\n        if (pendingTasks.isEmpty()) {\n          process(pendingTask)\n        } else {\n          addTask(pendingTask, topPriority)\n        }\n\n        return () => {\n          teardown(source$)\n        }\n      })\n\n  const withNormalRecovery = withRecovery()\n  const withRecoveryFn =\n    <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n    (...args: Args) =>\n      withNormalRecovery(fn(...args))\n\n  return { withRecovery, withRecoveryFn }\n}\n","import { withoutComplete } from \"@/utils\"\nimport {\n  Observable,\n  ReplaySubject,\n  concat,\n  mergeMap,\n  of,\n  share,\n  take,\n  takeWhile,\n} from \"rxjs\"\n\nconst DONE = Symbol(\"DONE\")\ntype DONE = typeof DONE\n\nconst delayUnsubscription = <T>(source$: Observable<T>) =>\n  new Observable<T>((observer) => {\n    const subscription = source$.subscribe(observer)\n    return () => {\n      setTimeout(() => {\n        subscription.unsubscribe()\n      }, 0)\n    }\n  })\n\nexport const getWithOptionalhash$ = (finalized$: Observable<string>) => {\n  const current$ = finalized$.pipe(\n    take(1),\n    withoutComplete,\n    share({\n      connector: () => new ReplaySubject(1),\n      resetOnError: true,\n      resetOnRefCountZero: true,\n      resetOnComplete: false,\n    }),\n    delayUnsubscription,\n  )\n\n  return <Args extends Array<any>, T>(\n      fn: (hash: string, ...args: Args) => Observable<T>,\n    ) =>\n    (hash: string | null, ...args: Args) =>\n      hash\n        ? fn(hash, ...args)\n        : current$.pipe(\n            mergeMap((h) => concat(fn(h, ...args), of(DONE))),\n            takeWhile((x): x is T => x !== DONE),\n          )\n}\n","import { Observable } from \"rxjs\"\n\nexport const fromAbortControllerFn =\n  <A extends Array<any>, T>(\n    fn: (...args: [...A, ...[abortSignal: AbortSignal]]) => Promise<T>,\n  ) =>\n  (...args: A): Observable<T> =>\n    new Observable((observer) => {\n      let aborter: AbortController | undefined = new AbortController()\n\n      fn(...[...args, aborter.signal]).then(\n        (value: any) => {\n          observer.next(value)\n          observer.complete()\n        },\n        (error: any) => {\n          observer.error(error)\n        },\n      )\n\n      return () => {\n        observer.unsubscribe()\n        aborter!.abort()\n        aborter = undefined\n      }\n    })\n","import { FollowResponse } from \"@polkadot-api/substrate-client\"\n\nexport const withLazyFollower =\n  (getFollower: () => FollowResponse) =>\n  <Key extends keyof FollowResponse>(key: Key): FollowResponse[Key] =>\n  (...args: any[]) =>\n    (getFollower() as any)[key](...args)\n","import {\n  Finalized,\n  FollowEventWithRuntime,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, filter, mergeMap, switchMap, take, throwError } from \"rxjs\"\nimport { PinnedBlocks } from \"../streams\"\nimport { isBestOrFinalizedBlock } from \"../streams/block-operations\"\n\nexport class BlockPrunedError extends Error {\n  constructor() {\n    super(\"Block pruned\")\n    this.name = \"BlockPrunedError\"\n  }\n}\nexport class NotBestBlockError extends Error {\n  constructor() {\n    super(\"Block is not best block or finalized\")\n    this.name = \"NotBestBlockError\"\n  }\n}\n\nexport function withEnsureCanonicalChain<A extends Array<any>, T>(\n  blocks$: Observable<PinnedBlocks>,\n  follow$: Observable<FollowEventWithRuntime>,\n  fn: (hash: string, ...args: A) => Observable<T>,\n) {\n  return (hash: string, ...args: A) =>\n    fn(hash, ...args).pipe(\n      throwWhenPrune(\n        hash,\n        follow$.pipe(\n          filter((evt): evt is Finalized => evt.type === \"finalized\"),\n          mergeMap((evt) => evt.prunedBlockHashes),\n        ),\n      ),\n      onlyIfIsBestOrFinalized(hash, blocks$),\n    )\n}\n\nconst onlyIfIsBestOrFinalized =\n  <T>(hash: string, blocks$: Observable<PinnedBlocks>) =>\n  (source$: Observable<T>) =>\n    blocks$.pipe(\n      isBestOrFinalizedBlock(hash),\n      take(1),\n      switchMap((isBest) =>\n        isBest ? source$ : throwError(() => new NotBestBlockError()),\n      ),\n    )\n\nconst throwWhenPrune =\n  <T>(hash: string, pruned$: Observable<string>) =>\n  (source$: Observable<T>) =>\n    new Observable<T>((subscriber) => {\n      const prunedSubscription = pruned$\n        .pipe(filter((h) => h === hash))\n        .subscribe(() => {\n          subscriber.error(new BlockPrunedError())\n        })\n      const sourceSubscription = source$.subscribe(subscriber)\n\n      return () => {\n        prunedSubscription.unsubscribe()\n        sourceSubscription.unsubscribe()\n      }\n    })\n","import {\n  Observable,\n  distinctUntilChanged,\n  filter,\n  map,\n  take,\n  takeWhile,\n} from \"rxjs\"\nimport { PinnedBlocks } from \"./pinned-blocks\"\n\nexport const isFinalized =\n  (blockHash: string) => (blocks$: Observable<PinnedBlocks>) =>\n    blocks$.pipe(\n      takeWhile((b) => b.blocks.has(blockHash)),\n      distinctUntilChanged((a, b) => a.finalized === b.finalized),\n      filter(\n        (x) =>\n          x.blocks.get(x.finalized)!.number >= x.blocks.get(blockHash)!.number,\n      ),\n      take(1),\n      map((pinned) => {\n        const { number } = pinned.blocks.get(blockHash)!\n        let current = pinned.blocks.get(pinned.finalized)!\n        while (current.number > number)\n          current = pinned.blocks.get(current.parent)!\n        return current.hash === blockHash\n      }),\n    )\n\nexport const isBestOrFinalizedBlock =\n  (blockHash: string) => (blocks$: Observable<PinnedBlocks>) =>\n    blocks$.pipe(\n      takeWhile((b) => b.blocks.has(blockHash)),\n      distinctUntilChanged((a, b) => a.best === b.best),\n      filter(\n        (x) => x.blocks.get(x.best)!.number >= x.blocks.get(blockHash)!.number,\n      ),\n      map((pinned) => {\n        const { number } = pinned.blocks.get(blockHash)!\n        let current = pinned.blocks.get(pinned.best)!\n        let isFinalized = pinned.finalized === current.hash\n        while (current.number > number) {\n          current = pinned.blocks.get(current.parent)!\n          isFinalized = isFinalized || pinned.finalized === current.hash\n        }\n        return { isBest: current.hash === blockHash, isFinalized }\n      }),\n      takeWhile(({ isFinalized }) => !isFinalized, true),\n      map(({ isBest }) => isBest),\n    )\n","import { OperationInaccessibleError } from \"@polkadot-api/substrate-client\"\nimport { Observable, catchError, concatMap, throwError, timer } from \"rxjs\"\n\nconst operable = <T>(source$: Observable<T>) => {\n  const result: Observable<T> = source$.pipe(\n    catchError((e) =>\n      e instanceof OperationInaccessibleError\n        ? timer(750).pipe(concatMap(() => result))\n        : throwError(() => e),\n    ),\n  )\n  return result\n}\n\nexport const withOperationInaccessibleRecovery =\n  <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n  (...args: Args): Observable<T> =>\n    operable(fn(...args))\n","import {\n  FollowResponse,\n  StorageItemInput,\n  StorageItemResponse,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, mergeAll } from \"rxjs\"\nimport { getWithRecovery } from \"./enhancers\"\n\nexport const getRecoveralStorage$ = (\n  getFollower: () => FollowResponse,\n  withRecovery: ReturnType<typeof getWithRecovery>[\"withRecovery\"],\n) => {\n  const recoveralStorage$ = (\n    hash: string,\n    queries: Array<StorageItemInput>,\n    childTrie: string | null,\n    isHighPriority: boolean,\n  ): Observable<StorageItemResponse> =>\n    new Observable<StorageItemResponse[] | Observable<StorageItemResponse>>(\n      (observer) =>\n        getFollower().storageSubscription(\n          hash,\n          queries,\n          childTrie ?? null,\n          (items) => {\n            observer.next(items)\n          },\n          (error) => {\n            observer.error(error)\n          },\n          () => {\n            observer.complete()\n          },\n          (nDiscarded) => {\n            if (nDiscarded === 0) return\n\n            observer.next(\n              recoveralStorage$(\n                hash,\n                queries.slice(-nDiscarded),\n                childTrie,\n                true,\n              ),\n            )\n          },\n        ),\n    ).pipe(mergeAll(), withRecovery(isHighPriority))\n\n  return recoveralStorage$\n}\n","import {\n  TxBestChainBlockIncluded,\n  TxFinalized,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  concat,\n  concatMap,\n  distinct,\n  filter,\n  map,\n  mergeMap,\n  of,\n  take,\n  takeUntil,\n  takeWhile,\n} from \"rxjs\"\nimport { PinnedBlocks } from \"./streams\"\nimport { isBestOrFinalizedBlock, isFinalized } from \"./streams/block-operations\"\n\nexport const getTrackTx =\n  (\n    blocks$: Observable<PinnedBlocks>,\n    getBody: (block: string) => Observable<string[]>,\n  ) =>\n  (tx: string): Observable<TxBestChainBlockIncluded | TxFinalized> =>\n    blocks$.pipe(\n      take(1),\n      concatMap((x) => {\n        const alreadyPresent = new Set(x.blocks.keys())\n\n        const findInBody = (hash: string): Observable<number> =>\n          alreadyPresent.has(hash)\n            ? of(-1)\n            : getBody(hash).pipe(\n                takeUntil(\n                  blocks$.pipe(filter(({ blocks }) => !blocks.has(hash))),\n                ),\n                map((txs) => txs.indexOf(tx)),\n              )\n\n        const findInBranch = (\n          hash: string,\n        ): Observable<{ hash: string; idx: number }> =>\n          findInBody(hash).pipe(\n            concatMap((idx) =>\n              idx > -1\n                ? of({ hash, idx })\n                : blocks$.pipe(\n                    takeWhile((x) => x.blocks.has(hash)),\n                    mergeMap((x) => x.blocks.get(hash)!.children),\n                    distinct(),\n                    mergeMap(findInBranch),\n                  ),\n            ),\n          )\n\n        return findInBranch(x.finalized).pipe(\n          mergeMap(({ hash, idx }) =>\n            concat(\n              blocks$.pipe(\n                isBestOrFinalizedBlock(hash),\n                filter(Boolean),\n                take(1),\n                map(() => ({\n                  type: \"bestChainBlockIncluded\" as const,\n                  block: { hash, index: idx },\n                })),\n              ),\n              blocks$.pipe(\n                isFinalized(hash),\n                filter(Boolean),\n                map(() => ({\n                  type: \"finalized\" as const,\n                  block: { hash, index: idx },\n                })),\n              ),\n            ),\n          ),\n        )\n      }),\n      takeWhile((x) => x.type !== \"finalized\", true),\n    )\n","import type {\n  SubstrateClient,\n  TxBestChainBlockIncluded,\n  TxBroadcasted,\n  TxDropped,\n  TxFinalized,\n  TxInvalid,\n  TxValidated,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable } from \"rxjs\"\n\nconst terminalTxEvents = new Set([\"error\", \"finalized\", \"invalid\", \"dropped\"])\n\nexport default (baseTransaction: SubstrateClient[\"transaction\"]) =>\n  (transaction: string) =>\n    new Observable<\n      | TxValidated\n      | TxBroadcasted\n      | TxBestChainBlockIncluded\n      | TxFinalized\n      | TxInvalid\n      | TxDropped\n    >((observer) =>\n      baseTransaction(\n        transaction,\n        (event) => {\n          if (event.type === \"error\")\n            return observer.error(new Error(event.error))\n\n          observer.next(event)\n          if (terminalTxEvents.has(event.type)) observer.complete()\n        },\n        (error) => {\n          observer.error(error)\n        },\n      ),\n    )\n","import type { SubstrateClient } from \"@polkadot-api/substrate-client\"\nexport type * from \"./chainHead\"\n\nimport { getChainHead$ } from \"./chainHead\"\nimport getTx$ from \"./tx\"\n\nexport const getObservableClient = ({\n  chainHead,\n  transaction,\n  destroy,\n}: SubstrateClient) => ({\n  chainHead$: () => getChainHead$(chainHead),\n  tx$: getTx$(transaction),\n  destroy,\n})\n","import {\n  ConstFromDescriptors,\n  Descriptors,\n  EventsFromDescriptors,\n  HexString,\n  QueryFromDescriptors,\n  TxFromDescriptors,\n} from \"@polkadot-api/substrate-bindings\"\nimport { RuntimeContext, getObservableClient } from \"./observableClient\"\nimport { Observable, filter, map } from \"rxjs\"\nimport { mapObject } from \"@polkadot-api/utils\"\n\ntype StorageRuntime<\n  A extends Record<\n    string,\n    Record<\n      string,\n      | {\n          KeyArgs: Array<any>\n          Value: any\n          IsOptional: false | true\n        }\n      | unknown\n    >\n  >,\n> = {\n  [K in keyof A]: {\n    [KK in keyof A[K]]: boolean\n  }\n}\n\ntype TxRuntime<A extends Record<string, Record<string, Array<any> | unknown>>> =\n  {\n    [K in keyof A]: {\n      [KK in keyof A[K]]: boolean\n    }\n  }\n\ntype PlainRuntime<A extends Record<string, Record<string, any>>> = {\n  [K in keyof A]: {\n    [KK in keyof A[K]]: boolean\n  }\n}\n\ntype MappedKey<K extends string, V> = `${K}${V extends Record<string, any>\n  ? `.${Paths<V>}`\n  : \"\"}`\ntype KeyMap<T> = {\n  [K in keyof T & string]: MappedKey<K, T[K]>\n}\ntype Paths<T> = KeyMap<T>[keyof T & string]\n\nexport interface Runtime<D extends Descriptors> {\n  constants: ConstFromDescriptors<D>\n  isCompatible: (\n    cb: (api: {\n      query: StorageRuntime<QueryFromDescriptors<D>>\n      tx: TxRuntime<TxFromDescriptors<D>>\n      event: PlainRuntime<EventsFromDescriptors<D>>\n      const: PlainRuntime<ConstFromDescriptors<D>>\n    }) => boolean,\n  ) => boolean\n}\n\nexport type RuntimeApi<T extends Descriptors> = Observable<Runtime<T>> & {\n  latest: () => Promise<Runtime<T>>\n}\n\nconst createRuntime = <D extends Descriptors>(\n  descriptors: D,\n  ctx: RuntimeContext,\n): Runtime<D> => {\n  const constants = mapObject(descriptors.pallets, (_, palletName) => {\n    const pallet = ctx.metadata.pallets.find((p) => p.name === palletName)\n    const palletConstants: Record<\n      string,\n      { cache: false; value: HexString } | { cache: true; value: any }\n    > = {}\n    pallet?.constants.forEach((c) => {\n      palletConstants[c.name] = { cache: false, value: c.value }\n    })\n\n    return new Proxy(\n      {},\n      {\n        get(_, name: string) {\n          const cached = palletConstants[name]\n          if (cached.cache) return cached.value\n\n          cached.cache = true as any\n          return (cached.value = ctx.dynamicBuilder\n            .buildConstant(palletName, name)\n            .dec(cached.value))\n        },\n      },\n    )\n  })\n  const isCompatibleMapper = (\n    idx: 0 | 1 | 2 | 4,\n    builder: \"buildStorage\" | \"buildEvent\" | \"buildCall\" | \"buildConstant\",\n  ) =>\n    mapObject(\n      descriptors.pallets,\n      (x, pallet: string) =>\n        new Proxy(\n          {},\n          {\n            get(_, name: string) {\n              return ctx.checksumBuilder[builder](pallet, name) === x[idx][name]\n            },\n          },\n        ),\n    )\n\n  const isCompatibleApi = {\n    query: isCompatibleMapper(0, \"buildStorage\"),\n    tx: isCompatibleMapper(1, \"buildCall\"),\n    event: isCompatibleMapper(2, \"buildEvent\"),\n    const: isCompatibleMapper(4, \"buildConstant\"),\n  }\n\n  const isCompatible: (cb: (api: any) => boolean) => boolean = (cb) =>\n    cb(isCompatibleApi)\n\n  return {\n    constants,\n    isCompatible,\n  } as any\n}\n\nexport const getRuntimeApi = <D extends Descriptors>(\n  descriptors: D,\n  chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n): RuntimeApi<D> => {\n  let latestRuntime: Promise<Runtime<D>>\n  let resolve: ((r: Runtime<D>) => void) | null = null\n\n  latestRuntime = new Promise<Runtime<D>>((res) => {\n    resolve = res\n  })\n\n  chainHead.runtime$.subscribe((x) => {\n    if (x) {\n      resolve!(createRuntime(descriptors, x))\n      resolve = null\n    } else if (!resolve) {\n      latestRuntime = new Promise<Runtime<D>>((res) => {\n        resolve = res\n      })\n    }\n  })\n\n  const result = chainHead.runtime$.pipe(\n    filter(Boolean),\n    map((x) => createRuntime(descriptors, x)),\n  ) as RuntimeApi<D>\n  result.latest = () => latestRuntime\n\n  return result\n}\n","import { map, mergeMap } from \"rxjs\"\nimport { firstValueFromWithSignal } from \"@/utils\"\nimport { getObservableClient, RuntimeContext } from \"./observableClient\"\nimport { toHex } from \"@polkadot-api/utils\"\n\ntype CallOptions = Partial<{\n  at: string\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = Args[\"length\"] extends 0\n  ? [options?: CallOptions]\n  : [...args: Args, options?: CallOptions]\n\nexport type RuntimeCall<Args extends Array<any>, Payload> = (\n  ...args: WithCallOptions<Args>\n) => Promise<Payload>\n\nconst isOptionalArg = (lastArg: any) => {\n  if (typeof lastArg !== \"object\") return false\n\n  return Object.keys(lastArg).every(\n    (k) =>\n      (k === \"at\" && typeof lastArg.at === \"string\") ||\n      (k === \"signal\" && lastArg.signal instanceof AbortSignal),\n  )\n}\n\nexport const createRuntimeCallEntry = (\n  checksum: string,\n  api: string,\n  method: string,\n  chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n): RuntimeCall<any, any> => {\n  const callName = `${api}_${method}`\n  const checksumCheck = (ctx: RuntimeContext) => {\n    const actualChecksum = ctx.checksumBuilder.buildRuntimeCall(api, method)\n    if (checksum !== actualChecksum)\n      throw new Error(`Incompatible runtime entry RuntimeCall(${callName})`)\n  }\n\n  return (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = chainHead.getRuntimeContext$(at).pipe(\n      mergeMap((ctx) => {\n        checksumCheck(ctx)\n        const codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method)\n        return chainHead\n          .call$(at, callName, toHex(codecs.args.enc(args)))\n          .pipe(map(codecs.value.dec))\n      }),\n    )\n\n    return firstValueFromWithSignal(result$, signal)\n  }\n}\n","import {\n  Observable,\n  debounceTime,\n  distinctUntilChanged,\n  exhaustMap,\n  map,\n} from \"rxjs\"\nimport { firstValueFromWithSignal } from \"@/utils\"\nimport { StorageItemInput, StorageResult } from \"@polkadot-api/substrate-client\"\nimport { getObservableClient, RuntimeContext } from \"./observableClient\"\n\ntype CallOptions = Partial<{\n  at: string\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: CallOptions,\n]\n\ntype PossibleParents<A extends Array<any>> = A extends [...infer Left, any]\n  ? Left | PossibleParents<Left>\n  : []\n\ntype StorageEntryWithoutKeys<Payload> = {\n  getValue: (options?: CallOptions) => Promise<Payload>\n  watchValue: () => Observable<Payload>\n}\n\ntype StorageEntryWithKeys<Args extends Array<any>, Payload> = {\n  getValue: (...args: [...WithCallOptions<Args>]) => Promise<Payload>\n  watchValue: (...args: Args) => Observable<Payload>\n  getValues: (\n    keys: Array<[...Args]>,\n    options?: CallOptions,\n  ) => Promise<Array<Payload>>\n  getEntries: (\n    ...args: WithCallOptions<PossibleParents<Args>>\n  ) => Promise<Array<{ keyArgs: Args; value: NonNullable<Payload> }>>\n}\n\nexport type StorageEntry<Args extends Array<any>, Payload> = Args extends []\n  ? StorageEntryWithoutKeys<Payload>\n  : StorageEntryWithKeys<Args, Payload>\n\nexport type Storage$ = <Type extends StorageItemInput[\"type\"]>(\n  hash: string | null,\n  type: Type,\n  key: string,\n  childTrie: string | null,\n) => Observable<StorageResult<Type>>\n\nconst isOptionalArg = (lastArg: any) => {\n  if (typeof lastArg !== \"object\") return false\n\n  return Object.keys(lastArg).every(\n    (k) =>\n      (k === \"at\" && typeof lastArg.at === \"string\") ||\n      (k === \"signal\" && lastArg.signal instanceof AbortSignal),\n  )\n}\n\nexport const createStorageEntry = (\n  checksum: string,\n  pallet: string,\n  name: string,\n  chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n) => {\n  const checksumCheck = (ctx: RuntimeContext) => {\n    const actualChecksum = ctx.checksumBuilder.buildStorage(pallet, name)\n    if (checksum !== actualChecksum)\n      throw new Error(`Incompatible runtime entry Storage(${pallet}.${name})`)\n  }\n\n  const invalidArgs = (args: Array<any>) =>\n    new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`)\n\n  const watchValue = (...args: Array<any>) =>\n    chainHead.finalized$.pipe(\n      debounceTime(0),\n      chainHead.withRuntime((x) => x.hash),\n      exhaustMap(([block, ctx]) => {\n        checksumCheck(ctx)\n        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n        return chainHead\n          .storage$(block.hash, \"value\", () => codecs.enc(...args))\n          .pipe(\n            distinctUntilChanged(),\n            map((val) => (val === null ? codecs.fallback : codecs.dec(val))),\n          )\n      }),\n    )\n\n  const getValue = (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = chainHead.storage$(\n      at,\n      \"value\",\n      (ctx) => {\n        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n        const actualArgs = args.length === codecs.len ? args : args.slice(0, -1)\n        if (args !== actualArgs && !isLastArgOptional) throw invalidArgs(args)\n        checksumCheck(ctx)\n        return codecs.enc(...actualArgs)\n      },\n      null,\n      (data, ctx) => {\n        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n        return data === null ? codecs.fallback : codecs.dec(data)\n      },\n    )\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  const getEntries = (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = chainHead.storage$(\n      at,\n      \"descendantsValues\",\n      (ctx) => {\n        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n        if (args.length > codecs.len) throw invalidArgs(args)\n        const actualArgs =\n          args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args\n        if (args.length === codecs.len && actualArgs === args)\n          throw invalidArgs(args)\n        checksumCheck(ctx)\n        return codecs.enc(...actualArgs)\n      },\n      null,\n      (values, ctx) => {\n        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n        return values.map(({ key, value }) => ({\n          keyArgs: codecs.keyDecoder(key),\n          value: codecs.dec(value),\n        }))\n      },\n    )\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  const getValues = (keyArgs: Array<Array<any>>, options?: CallOptions) =>\n    Promise.all(\n      keyArgs.map((args) => getValue(...(options ? [...args, options] : args))),\n    )\n\n  return { getValue, getValues, getEntries, watchValue }\n}\n","import {\n  Binary,\n  Enum,\n  PlainDescriptor,\n  SS58String,\n  TxDescriptor,\n} from \"@polkadot-api/substrate-bindings\"\nimport type {\n  TxBestChainBlockIncluded,\n  TxBroadcasted,\n  TxFinalized,\n  TxValidated,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  concat,\n  firstValueFrom,\n  lastValueFrom,\n  map,\n  mergeMap,\n  of,\n  take,\n  takeWhile,\n} from \"rxjs\"\nimport { mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport { getObservableClient, SystemEvent } from \"./observableClient\"\n\ntype TxSuccess = {\n  ok: boolean\n  events: Array<SystemEvent[\"event\"]>\n}\n\ntype TxFunction<Asset> = (\n  from: SS58String | Uint8Array,\n  hintedSignExtensions?: Partial<\n    void extends Asset\n      ? {\n          tip: bigint\n          mortal: { mortal: false } | { mortal: true; period: number }\n        }\n      : {\n          tip: bigint\n          mortal: { mortal: false } | { mortal: true; period: number }\n          asset: Asset\n        }\n  >,\n) => Promise<TxSuccess>\n\ntype TxObservable<Asset> = (\n  from: SS58String | Uint8Array,\n  hintedSignExtensions?: Partial<\n    void extends Asset\n      ? {\n          tip: bigint\n          mortal: { mortal: false } | { mortal: true; period: number }\n        }\n      : {\n          tip: bigint\n          mortal: { mortal: false } | { mortal: true; period: number }\n          asset: Asset\n        }\n  >,\n) => Observable<\n  | TxValidated\n  | TxBroadcasted\n  | TxBestChainBlockIncluded\n  | (TxFinalized & TxSuccess)\n>\n\ntype TxCall = () => Promise<Binary>\n\ntype TxSigned<Asset> = (\n  from: SS58String | Uint8Array,\n  hintedSignExtensions?: Partial<\n    void extends Asset\n      ? {\n          tip: bigint\n          mortal: { mortal: false } | { mortal: true; period: number }\n        }\n      : {\n          tip: bigint\n          mortal: { mortal: false } | { mortal: true; period: number }\n          asset: Asset\n        }\n  >,\n) => Promise<string>\n\nexport type Transaction<\n  Arg extends {} | undefined,\n  Pallet extends string,\n  Name extends string,\n  Asset,\n> = {\n  callData: Enum<{\n    type: Pallet\n    value: Enum<{\n      type: Name\n      value: Arg\n    }>\n  }>\n  getEncodedData: TxCall\n  getTx: TxSigned<Asset>\n  submit: TxFunction<Asset>\n  submit$: TxObservable<Asset>\n}\n\nconst getTxSuccessFromSystemEvents = (\n  systemEvents: Array<SystemEvent>,\n  txIdx: number,\n): TxSuccess => {\n  const events = systemEvents\n    .filter((x) => x.phase.type === \"ApplyExtrinsic\" && x.phase.value === txIdx)\n    .map((x) => x.event)\n\n  const lastEvent = events[events.length - 1]\n  const ok =\n    lastEvent.type === \"System\" && lastEvent.value.type === \"ExtrinsicSuccess\"\n\n  return { ok, events }\n}\n\nexport const createTxEntry =\n  <\n    Arg extends {} | undefined,\n    Pallet extends string,\n    Name extends string,\n    Asset extends PlainDescriptor<any>,\n  >(\n    descriptor: TxDescriptor<Arg>,\n    pallet: Pallet,\n    name: Name,\n    assetChecksum: Asset,\n    chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n    client: ReturnType<typeof getObservableClient>,\n    signer: (\n      from: string | Uint8Array,\n      callData: Uint8Array,\n      hinted?: Partial<{}>,\n    ) => Promise<Uint8Array>,\n  ): ((arg: any) => Transaction<Arg, Pallet, Name, Asset[\"_type\"]>) =>\n  (arg?: Arg): any => {\n    const tx$ = (tx: string) =>\n      concat(\n        client.tx$(tx).pipe(takeWhile((x) => x.type !== \"broadcasted\", true)),\n        chainHead.trackTx$(tx),\n      )\n\n    const getCallData$ = (arg: any, hinted: Partial<{ asset: any }> = {}) =>\n      chainHead.getRuntimeContext$(null).pipe(\n        map(\n          ({\n            checksumBuilder,\n            dynamicBuilder,\n            asset: [assetEnc, assetCheck],\n          }) => {\n            const checksum = checksumBuilder.buildCall(pallet, name)\n            if (checksum !== descriptor)\n              throw new Error(\n                `Incompatible runtime entry Tx(${pallet}.${name})`,\n              )\n\n            let returnHinted = hinted\n            if (hinted.asset) {\n              if (assetChecksum !== assetCheck)\n                throw new Error(`Incompatible runtime asset`)\n              returnHinted = { ...hinted, asset: assetEnc(hinted.asset) }\n            }\n\n            const { location, args } = dynamicBuilder.buildCall(pallet, name)\n            return {\n              callData: Binary.fromBytes(\n                mergeUint8(new Uint8Array(location), args.enc(arg)),\n              ),\n              hinted: returnHinted,\n            }\n          },\n        ),\n      )\n\n    const getEncodedData: TxCall = () =>\n      firstValueFrom(getCallData$(arg).pipe(map((x) => x.callData)))\n\n    const getTx: TxSigned<Asset> = (from, _hinted) =>\n      firstValueFrom(\n        getCallData$(arg, _hinted as any).pipe(\n          mergeMap(({ callData, hinted }) =>\n            signer(from, callData.asBytes(), hinted),\n          ),\n          map(toHex),\n        ),\n      )\n\n    const submit: TxFunction<Asset> = async (from, _hinted) => {\n      const tx = await firstValueFrom(\n        getCallData$(arg, _hinted as any).pipe(\n          mergeMap(({ callData, hinted }) =>\n            signer(from, callData.asBytes(), hinted).then(toHex),\n          ),\n        ),\n      )\n\n      const result = await lastValueFrom(tx$(tx))\n\n      switch (result.type) {\n        case \"invalid\":\n          throw new Error(\"Invalid\")\n        case \"dropped\":\n          throw new Error(\"Dropped\")\n        case \"finalized\": {\n          const systemEvents = await firstValueFrom(\n            chainHead.eventsAt$(result.block.hash),\n          )\n\n          return getTxSuccessFromSystemEvents(\n            systemEvents,\n            Number(result.block.index),\n          )\n        }\n        default:\n          return { ok: true, events: [] }\n      }\n    }\n\n    const submit$: TxObservable<Asset> = (from, _hinted) =>\n      getCallData$(arg, _hinted as any).pipe(\n        mergeMap(({ callData, hinted }) =>\n          signer(from, callData.asBytes(), hinted),\n        ),\n        take(1),\n        mergeMap((result) => {\n          return tx$(toHex(result)).pipe(\n            mergeMap((result) => {\n              switch (result.type) {\n                case \"invalid\":\n                  throw new Error(\"Invalid\")\n                case \"dropped\":\n                  throw new Error(\"Dropped\")\n                case \"finalized\": {\n                  return chainHead.eventsAt$(result.block.hash).pipe(\n                    map((events) => ({\n                      ...result,\n                      ...getTxSuccessFromSystemEvents(\n                        events,\n                        Number(result.block.index),\n                      ),\n                    })),\n                  )\n                }\n                default:\n                  return of(result)\n              }\n            }),\n          )\n        }),\n      )\n\n    return {\n      callData: Enum(pallet, Enum(name, arg as any)) as Enum<{\n        type: Pallet\n        value: any\n      }>,\n      getEncodedData,\n      getTx,\n      submit,\n      submit$,\n    }\n  }\n","export type {\n  Codec,\n  SS58String,\n  HexString,\n  GetEnum,\n  PlainDescriptor,\n  TxDescriptor,\n  StorageDescriptor,\n  QueryFromDescriptors,\n  TxFromDescriptors,\n  EventsFromDescriptors,\n  ErrorsFromDescriptors,\n  ConstFromDescriptors,\n  RuntimeDescriptor,\n  ResultPayload,\n} from \"@polkadot-api/substrate-bindings\"\nexport {\n  AccountId,\n  Binary,\n  Enum,\n  _Enum,\n} from \"@polkadot-api/substrate-bindings\"\n"],"mappings":"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","names":["import_substrate_client","import_rxjs","import_rxjs","import_rxjs","import_rxjs","import_rxjs","import_rxjs","import_rxjs","filter","import_substrate_bindings","import_substrate_client","import_rxjs","import_rxjs","import_utils","import_rxjs","metadata","import_rxjs","hash","import_rxjs","import_rxjs","import_rxjs","import_rxjs","import_rxjs","isFinalized","import_substrate_client","import_rxjs","import_rxjs","import_rxjs","x","import_rxjs","import_rxjs","import_utils","_","import_rxjs","import_utils","import_rxjs","isOptionalArg","import_substrate_bindings","import_rxjs","import_utils","arg","from","result","createRawClient","import_substrate_bindings"]}