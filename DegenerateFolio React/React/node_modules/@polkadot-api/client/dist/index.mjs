var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/client.ts
import {
  createClient as createRawClient
} from "@polkadot-api/substrate-client";
import { firstValueFrom as firstValueFrom3 } from "rxjs";

// src/event.ts
import { firstValueFrom, map, mergeMap } from "rxjs";

// src/utils/shareLatest.ts
import { ReplaySubject, share } from "rxjs";
var shareLatest = share({
  connector: () => new ReplaySubject(1),
  resetOnError: true,
  resetOnComplete: true,
  resetOnRefCountZero: true
});

// src/utils/firstValueFromWithSignal.ts
import { noop } from "rxjs";
function firstValueFromWithSignal(source, signal) {
  return new Promise((resolve, reject) => {
    const onAbort = signal ? () => {
      subscription.unsubscribe();
    } : noop;
    let isDone = false;
    const subscription = source.subscribe({
      next: (value) => {
        resolve(value);
        isDone = true;
        subscription?.unsubscribe();
      },
      error: (e) => {
        reject(e);
        signal?.removeEventListener("abort", onAbort);
      },
      complete: () => {
        reject(new Error("Observable completed without emitting"));
        signal?.removeEventListener("abort", onAbort);
      }
    });
    if (isDone) {
      subscription.unsubscribe();
    } else {
      signal?.addEventListener("abort", onAbort);
    }
  });
}

// src/utils/concatMapEager.ts
import { defer, Observable as Observable3 } from "rxjs";
var concatMapEager = (mapper, concurrent = Infinity) => (source$) => new Observable3((observer) => {
  const queues = /* @__PURE__ */ new Map();
  const innerSubscriptions = /* @__PURE__ */ new Map();
  const results = /* @__PURE__ */ new Map();
  let mapperIdx = 0;
  let subscriptionIdx = 0;
  let observerIdx = 0;
  const nextSubscription = () => {
    const inner$ = queues.get(subscriptionIdx);
    if (!inner$) {
      if (topSubscription.closed && innerSubscriptions.size === 0) {
        observer.complete();
      }
      return;
    }
    const idx = subscriptionIdx++;
    queues.delete(idx);
    if (observerIdx !== idx) {
      results.set(idx, []);
    }
    innerSubscriptions.set(
      idx,
      inner$.subscribe({
        next(x) {
          if (observerIdx === idx) {
            observer.next(x);
          } else {
            results.get(idx).push(x);
          }
        },
        complete() {
          innerSubscriptions.delete(idx);
          if (idx === observerIdx) {
            observerIdx++;
            while (results.has(observerIdx)) {
              results.get(observerIdx).forEach((x) => observer.next(x));
              results.delete(observerIdx);
              if (innerSubscriptions.has(observerIdx)) {
                break;
              }
              observerIdx++;
            }
          }
          nextSubscription();
        },
        error(e) {
          observer.error(e);
        }
      })
    );
  };
  const topSubscription = source$.subscribe({
    next(outterValue) {
      const idx = mapperIdx++;
      queues.set(
        idx,
        defer(() => mapper(outterValue, idx))
      );
      if (innerSubscriptions.size < concurrent) {
        nextSubscription();
      }
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (innerSubscriptions.size === 0) {
        observer.complete();
      }
    }
  });
  return () => {
    innerSubscriptions.forEach((subscription) => subscription.unsubscribe());
    topSubscription.unsubscribe();
    queues.clear();
    results.clear();
  };
});

// src/utils/withoutComplete.ts
import { Observable as Observable4 } from "rxjs";
var withoutComplete = (source) => new Observable4(
  (observer) => source.subscribe({
    next(x) {
      observer.next(x);
    },
    error(e) {
      observer.error(e);
    }
  })
);

// src/utils/selfDependant.ts
import {
  Subject,
  BehaviorSubject
} from "rxjs";
import { switchAll, tap } from "rxjs/operators";
var selfDependent = () => {
  const activeSubject = new BehaviorSubject(
    new Subject()
  );
  return [
    activeSubject.pipe(switchAll()),
    () => tap({
      next: (v) => activeSubject.value.next(v),
      error: (e) => {
        activeSubject.value.error(e);
        activeSubject.next(new Subject());
      },
      complete: () => {
        activeSubject.value.complete();
        activeSubject.next(new Subject());
      }
    })
  ];
};

// src/utils/with-default-value.ts
import { Observable as Observable6 } from "rxjs";
var withDefaultValue = (defaultValue) => (source$) => new Observable6((observer) => {
  let hasEmited = false;
  const subscription = source$.subscribe({
    next(v) {
      hasEmited = true;
      observer.next(v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      observer.complete();
    }
  });
  if (!hasEmited)
    observer.next(defaultValue);
  return subscription;
});

// src/event.ts
var createEventEntry = (checksum, pallet, name, chainHead) => {
  const checksumCheck = (ctx) => {
    const actualChecksum = ctx.checksumBuilder.buildEvent(pallet, name);
    if (checksum !== actualChecksum)
      throw new Error(`Incompatible runtime entry Event(${pallet}.${name})`);
  };
  const shared$ = chainHead.finalized$.pipe(
    chainHead.withRuntime((x) => x.hash),
    concatMapEager(([block, ctx]) => {
      checksumCheck(ctx);
      return chainHead.eventsAt$(block.hash).pipe(
        map((events) => {
          const winners = events.filter(
            (e) => e.event.type === pallet && e.event.value.type === name
          );
          return winners.map((x) => {
            return {
              meta: {
                phase: x.phase,
                block
              },
              payload: x.event.value.value
            };
          });
        })
      );
    }),
    shareLatest
  );
  const watch = (f) => shared$.pipe(mergeMap((x) => f ? x.filter((d) => f(d.payload)) : x));
  const pull = () => firstValueFrom(shared$);
  const filter6 = (events) => events.filter((e) => e.type === pallet && e.value.type === name).map((x) => x.value.value);
  return { watch, pull, filter: filter6 };
};

// src/observableClient/chainHead/chainHead.ts
import { blockHeader } from "@polkadot-api/substrate-bindings";
import {
  DisjointError
} from "@polkadot-api/substrate-client";
import {
  Observable as Observable19,
  ReplaySubject as ReplaySubject3,
  Subject as Subject3,
  distinctUntilChanged as distinctUntilChanged2,
  from,
  map as map6,
  merge as merge2,
  mergeMap as mergeMap5,
  scan as scan2,
  share as share4,
  switchMap as switchMap2,
  take as take5
} from "rxjs";

// src/observableClient/chainHead/streams/follow.ts
import { Observable as Observable8, noop as noop2, share as share2 } from "rxjs";
var getFollow$ = (chainHead) => {
  let follower;
  let unfollow = noop2;
  const follow$ = new Observable8((observer) => {
    follower = chainHead(
      true,
      (e) => {
        observer.next(e);
      },
      (e) => {
        console.warn("chainHead crashed");
        console.error(e);
        observer.error(e);
      }
    );
    unfollow = () => {
      observer.complete();
      follower.unfollow();
    };
  }).pipe(share2());
  return {
    getFollower: () => {
      if (!follower)
        throw new Error("Missing chainHead subscription");
      return follower;
    },
    unfollow: () => {
      unfollow();
    },
    follow$
  };
};

// src/observableClient/chainHead/streams/get-runtime-creator.ts
import {
  getChecksumBuilder,
  getDynamicBuilder,
  getLookupFn
} from "@polkadot-api/metadata-builders";
import {
  AccountId,
  Tuple,
  Option,
  compact,
  metadata,
  u32,
  _void
} from "@polkadot-api/substrate-bindings";
import { toHex } from "@polkadot-api/utils";
import { map as map2, shareReplay } from "rxjs";
var opaqueMeta = Option(Tuple(compact, metadata));
var v15Args = toHex(u32.enc(15));
var getRuntimeCreator = (call$) => (hash) => {
  const usages = /* @__PURE__ */ new Set([hash]);
  const runtimeContext$ = call$(
    hash,
    "Metadata_metadata_at_version",
    v15Args
  ).pipe(
    map2((response) => {
      const metadata2 = opaqueMeta.dec(response)[1];
      if (metadata2.metadata.tag !== "v15")
        throw new Error("Wrong metadata version");
      const v15 = metadata2.metadata.value;
      const checksumBuilder = getChecksumBuilder(v15);
      const dynamicBuilder = getDynamicBuilder(v15);
      const events = dynamicBuilder.buildStorage("System", "Events");
      const assetPayment = metadata2.metadata.value.extrinsic.signedExtensions.find(
        (x) => x.identifier === "ChargeAssetTxPayment"
      );
      let _assetId = null;
      if (assetPayment) {
        const assetTxPayment = getLookupFn(metadata2.metadata.value.lookup)(
          assetPayment.type
        );
        if (assetTxPayment.type === "struct") {
          const optionalAssetId = assetTxPayment.value.asset_id;
          if (optionalAssetId.type === "option")
            _assetId = optionalAssetId.value.id;
        }
      }
      const asset = _assetId === null ? [_void.enc, null] : [
        dynamicBuilder.buildDefinition(_assetId).enc,
        checksumBuilder.buildDefinition(_assetId)
      ];
      return {
        asset,
        metadata: v15,
        checksumBuilder,
        dynamicBuilder,
        events: {
          key: events.enc(),
          dec: events.dec
        },
        accountId: AccountId(dynamicBuilder.ss58Prefix)
      };
    }),
    shareReplay(1)
  );
  const result = {
    at: hash,
    runtime: runtimeContext$,
    addBlock: (block) => {
      usages.add(block);
      return result;
    },
    deleteBlocks: (blocks) => {
      blocks.forEach((block) => {
        usages.delete(block);
      });
      return usages.size;
    },
    usages
  };
  runtimeContext$.subscribe();
  return result;
};

// src/observableClient/chainHead/streams/pinned-blocks.ts
import {
  Observable as Observable10,
  Subject as Subject2,
  concatMap,
  defer as defer2,
  filter,
  interval,
  map as map3,
  merge,
  of,
  pairwise,
  scan,
  tap as tap2,
  withLatestFrom
} from "rxjs";
var getPinnedBlocks$ = (follow$, getHeader, call$, blockUsage$, onUnpin) => {
  const getRuntime = getRuntimeCreator(call$);
  const followWithInitializedNumber$ = follow$.pipe(
    concatMap((event) => {
      return event.type !== "initialized" ? of(event) : getHeader(event.finalizedBlockHashes.slice(-1)[0]).then((header) => ({
        ...event,
        number: header.number,
        parentHash: header.parentHash
      }));
    })
  );
  const [unpinnedBlocks$, connectUnpinnedBlocks] = selfDependent();
  const prunedBlocks$ = new Subject2();
  const cleaner$ = merge(
    prunedBlocks$,
    interval(100).pipe(
      withLatestFrom(defer2(() => pinnedBlocks$)),
      map3(([, pinned]) => {
        const result = /* @__PURE__ */ new Set();
        let current = pinned.blocks.get(pinned.finalized);
        while (pinned.blocks.has(current.parent)) {
          current = pinned.blocks.get(current.parent);
          if (!current.refCount)
            result.add(current.hash);
        }
        return result;
      }),
      pairwise(),
      map3(([prev, current]) => [...current].filter((x) => prev.has(x))),
      filter((x) => x.length > 0)
    )
  ).pipe(
    connectUnpinnedBlocks(),
    tap2(onUnpin),
    (source$) => new Observable10((observer) => {
      let subscription = null;
      const token = setTimeout(() => {
        subscription = source$.subscribe({
          error(e) {
            observer.error(e);
          }
        });
        subscription.add(
          // and let's make sure that it completes when follow$ is done
          follow$.subscribe({
            complete() {
              observer.complete();
            }
          })
        );
      }, 0);
      return () => {
        clearTimeout(token);
        subscription?.unsubscribe();
      };
    })
  );
  const pinnedBlocks$ = merge(
    blockUsage$,
    followWithInitializedNumber$,
    unpinnedBlocks$.pipe(
      map3((hashes) => ({ type: "unpin", hashes }))
    ),
    cleaner$
  ).pipe(
    scan(
      (acc, event) => {
        switch (event.type) {
          case "initialized":
            const [hash] = event.finalizedBlockHashes.slice(-1);
            acc.finalized = acc.best = hash;
            acc.blocks.set(hash, {
              hash,
              parent: event.parentHash,
              children: /* @__PURE__ */ new Set(),
              runtime: hash,
              refCount: 0,
              number: event.number
            });
            acc.runtimes[hash] = getRuntime(hash);
            acc.finalizedRuntime = acc.runtimes[hash];
            return acc;
          case "newBlock": {
            const { parentBlockHash: parent, blockHash: hash2 } = event;
            const parentNode = acc.blocks.get(parent);
            parentNode.children.add(hash2);
            if (event.newRuntime) {
              acc.runtimes[hash2] = getRuntime(hash2);
              acc.runtimes[hash2].runtime.subscribe();
            }
            const block = {
              hash: hash2,
              number: parentNode.number + 1,
              parent,
              children: /* @__PURE__ */ new Set(),
              runtime: event.newRuntime ? hash2 : parentNode.runtime,
              refCount: 0
            };
            acc.blocks.set(hash2, block);
            acc.runtimes[block.runtime].addBlock(hash2);
            return acc;
          }
          case "bestBlockChanged": {
            acc.best = event.bestBlockHash;
            return acc;
          }
          case "finalized": {
            acc.finalized = event.finalizedBlockHashes.slice(-1)[0];
            acc.finalizedRuntime = acc.runtimes[acc.blocks.get(acc.finalized).runtime];
            if (event.prunedBlockHashes.length > 0)
              prunedBlocks$.next(event.prunedBlockHashes);
            return acc;
          }
          case "blockUsage": {
            acc.blocks.get(event.value.hash).refCount += event.value.type === "hold" ? 1 : -1;
            return acc;
          }
          case "unpin": {
            event.hashes.forEach((h) => {
              if (!acc.blocks.has(h))
                return;
              acc.blocks.get(acc.blocks.get(h).parent)?.children.delete(h);
              acc.blocks.delete(h);
            });
            Object.entries(acc.runtimes).map(([key, value]) => ({
              key,
              usages: value.deleteBlocks(event.hashes)
            })).filter((x) => x.usages === 0).map((x) => x.key).forEach((unsusedRuntime) => {
              delete acc.runtimes[unsusedRuntime];
            });
            return acc;
          }
        }
      },
      {
        best: "",
        finalized: "",
        runtimes: {},
        blocks: /* @__PURE__ */ new Map(),
        finalizedRuntime: {}
      }
    ),
    map3((x) => ({ ...x })),
    shareLatest
  );
  return pinnedBlocks$;
};

// src/observableClient/chainHead/enhancers/operationLimitRecovery.ts
import { OperationLimitError } from "@polkadot-api/substrate-client";
import { Observable as Observable11 } from "rxjs";
var PendingTaskQueue = class {
  constructor() {
    __publicField(this, "first");
    __publicField(this, "last");
  }
  getRemoveFn(node) {
    return () => {
      if (node.prev) {
        node.prev.next = node.next;
      } else {
        this.first = node.next;
      }
      if (node.next) {
        node.next.prev = node.prev;
      } else {
        this.last = node.prev;
      }
      delete node.prev;
      delete node.next;
    };
  }
  push(value) {
    const newNode = { value };
    if (this.last === void 0) {
      this.last = this.first = newNode;
    } else {
      this.last.next = newNode;
      newNode.prev = this.last;
      this.last = newNode;
    }
    return this.getRemoveFn(newNode);
  }
  unshift(value) {
    this.first = { value, next: this.first };
    this.first.next && (this.first.next.prev = this.first);
    this.last || (this.last = this.first);
    return this.getRemoveFn(this.first);
  }
  pop() {
    const result = this.first?.value;
    if (this.first) {
      this.first = this.first.next;
      if (!this.first) {
        this.last = void 0;
      } else {
        delete this.first.prev?.next;
        delete this.first.prev;
      }
    }
    return result;
  }
  isEmpty() {
    return !this.first;
  }
};
var getWithRecovery = () => {
  const tearDownOperations = /* @__PURE__ */ new Map();
  const setTeardown = (observable, cb) => {
    tearDownOperations.set(observable, () => {
      tearDownOperations.delete(observable);
      cb();
    });
  };
  const teardown = (observable) => {
    tearDownOperations.get(observable)?.();
  };
  const pendingTasks = new PendingTaskQueue();
  const unshift = pendingTasks.unshift.bind(pendingTasks);
  const push = pendingTasks.push.bind(pendingTasks);
  const addTask = (task, topPriority) => {
    const fn = topPriority ? unshift : push;
    setTeardown(task.source$, fn(task));
  };
  const onEmptySlot = () => {
    const data = pendingTasks.pop();
    if (!data)
      return;
    tearDownOperations.delete(data.source$);
    process(data);
  };
  const process = (data) => {
    const { source$, observer } = data;
    const subscription = source$.subscribe({
      next(x) {
        observer.next(x);
      },
      error(e) {
        teardown(source$);
        if (e instanceof OperationLimitError)
          return addTask(data, true);
        observer.error(e);
        onEmptySlot();
      },
      complete() {
        observer.complete();
        onEmptySlot();
      }
    });
    if (!observer.closed) {
      setTeardown(source$, () => {
        subscription.unsubscribe();
      });
    }
  };
  const withRecovery = (topPriority = false) => (source$) => new Observable11((observer) => {
    const pendingTask = { observer, source$ };
    if (pendingTasks.isEmpty()) {
      process(pendingTask);
    } else {
      addTask(pendingTask, topPriority);
    }
    return () => {
      teardown(source$);
    };
  });
  const withNormalRecovery = withRecovery();
  const withRecoveryFn = (fn) => (...args) => withNormalRecovery(fn(...args));
  return { withRecovery, withRecoveryFn };
};

// src/observableClient/chainHead/enhancers/optionalHash.ts
import {
  Observable as Observable12,
  ReplaySubject as ReplaySubject2,
  concat,
  mergeMap as mergeMap2,
  of as of2,
  share as share3,
  take,
  takeWhile
} from "rxjs";
var DONE = Symbol("DONE");
var delayUnsubscription = (source$) => new Observable12((observer) => {
  const subscription = source$.subscribe(observer);
  return () => {
    setTimeout(() => {
      subscription.unsubscribe();
    }, 0);
  };
});
var getWithOptionalhash$ = (finalized$) => {
  const current$ = finalized$.pipe(
    take(1),
    withoutComplete,
    share3({
      connector: () => new ReplaySubject2(1),
      resetOnError: true,
      resetOnRefCountZero: true,
      resetOnComplete: false
    }),
    delayUnsubscription
  );
  return (fn) => (hash, ...args) => hash ? fn(hash, ...args) : current$.pipe(
    mergeMap2((h) => concat(fn(h, ...args), of2(DONE))),
    takeWhile((x) => x !== DONE)
  );
};

// src/observableClient/chainHead/enhancers/fromAbortControllerFn.ts
import { Observable as Observable13 } from "rxjs";
var fromAbortControllerFn = (fn) => (...args) => new Observable13((observer) => {
  let aborter = new AbortController();
  fn(...[...args, aborter.signal]).then(
    (value) => {
      observer.next(value);
      observer.complete();
    },
    (error) => {
      observer.error(error);
    }
  );
  return () => {
    observer.unsubscribe();
    aborter.abort();
    aborter = void 0;
  };
});

// src/observableClient/chainHead/enhancers/lazyFollower.ts
var withLazyFollower = (getFollower) => (key) => (...args) => getFollower()[key](...args);

// src/observableClient/chainHead/enhancers/whileBestBlock.ts
import { Observable as Observable15, filter as filter3, mergeMap as mergeMap3, switchMap, take as take3, throwError } from "rxjs";

// src/observableClient/chainHead/streams/block-operations.ts
import {
  distinctUntilChanged,
  filter as filter2,
  map as map4,
  take as take2,
  takeWhile as takeWhile2
} from "rxjs";
var isFinalized = (blockHash) => (blocks$) => blocks$.pipe(
  takeWhile2((b) => b.blocks.has(blockHash)),
  distinctUntilChanged((a, b) => a.finalized === b.finalized),
  filter2(
    (x) => x.blocks.get(x.finalized).number >= x.blocks.get(blockHash).number
  ),
  take2(1),
  map4((pinned) => {
    const { number } = pinned.blocks.get(blockHash);
    let current = pinned.blocks.get(pinned.finalized);
    while (current.number > number)
      current = pinned.blocks.get(current.parent);
    return current.hash === blockHash;
  })
);
var isBestOrFinalizedBlock = (blockHash) => (blocks$) => blocks$.pipe(
  takeWhile2((b) => b.blocks.has(blockHash)),
  distinctUntilChanged((a, b) => a.best === b.best),
  filter2(
    (x) => x.blocks.get(x.best).number >= x.blocks.get(blockHash).number
  ),
  map4((pinned) => {
    const { number } = pinned.blocks.get(blockHash);
    let current = pinned.blocks.get(pinned.best);
    let isFinalized2 = pinned.finalized === current.hash;
    while (current.number > number) {
      current = pinned.blocks.get(current.parent);
      isFinalized2 = isFinalized2 || pinned.finalized === current.hash;
    }
    return { isBest: current.hash === blockHash, isFinalized: isFinalized2 };
  }),
  takeWhile2(({ isFinalized: isFinalized2 }) => !isFinalized2, true),
  map4(({ isBest }) => isBest)
);

// src/observableClient/chainHead/enhancers/whileBestBlock.ts
var BlockPrunedError = class extends Error {
  constructor() {
    super("Block pruned");
    this.name = "BlockPrunedError";
  }
};
var NotBestBlockError = class extends Error {
  constructor() {
    super("Block is not best block or finalized");
    this.name = "NotBestBlockError";
  }
};
function withEnsureCanonicalChain(blocks$, follow$, fn) {
  return (hash, ...args) => fn(hash, ...args).pipe(
    throwWhenPrune(
      hash,
      follow$.pipe(
        filter3((evt) => evt.type === "finalized"),
        mergeMap3((evt) => evt.prunedBlockHashes)
      )
    ),
    onlyIfIsBestOrFinalized(hash, blocks$)
  );
}
var onlyIfIsBestOrFinalized = (hash, blocks$) => (source$) => blocks$.pipe(
  isBestOrFinalizedBlock(hash),
  take3(1),
  switchMap(
    (isBest) => isBest ? source$ : throwError(() => new NotBestBlockError())
  )
);
var throwWhenPrune = (hash, pruned$) => (source$) => new Observable15((subscriber) => {
  const prunedSubscription = pruned$.pipe(filter3((h) => h === hash)).subscribe(() => {
    subscriber.error(new BlockPrunedError());
  });
  const sourceSubscription = source$.subscribe(subscriber);
  return () => {
    prunedSubscription.unsubscribe();
    sourceSubscription.unsubscribe();
  };
});

// src/observableClient/chainHead/enhancers/operationInaccessibleRecovery.ts
import { OperationInaccessibleError } from "@polkadot-api/substrate-client";
import { catchError, concatMap as concatMap2, throwError as throwError2, timer } from "rxjs";
var operable = (source$) => {
  const result = source$.pipe(
    catchError(
      (e) => e instanceof OperationInaccessibleError ? timer(750).pipe(concatMap2(() => result)) : throwError2(() => e)
    )
  );
  return result;
};
var withOperationInaccessibleRecovery = (fn) => (...args) => operable(fn(...args));

// src/observableClient/chainHead/storage-queries.ts
import { Observable as Observable17, mergeAll } from "rxjs";
var getRecoveralStorage$ = (getFollower, withRecovery) => {
  const recoveralStorage$ = (hash, queries, childTrie, isHighPriority) => new Observable17(
    (observer) => getFollower().storageSubscription(
      hash,
      queries,
      childTrie ?? null,
      (items) => {
        observer.next(items);
      },
      (error) => {
        observer.error(error);
      },
      () => {
        observer.complete();
      },
      (nDiscarded) => {
        if (nDiscarded === 0)
          return;
        observer.next(
          recoveralStorage$(
            hash,
            queries.slice(-nDiscarded),
            childTrie,
            true
          )
        );
      }
    )
  ).pipe(mergeAll(), withRecovery(isHighPriority));
  return recoveralStorage$;
};

// src/observableClient/chainHead/track-tx.ts
import {
  concat as concat2,
  concatMap as concatMap3,
  distinct,
  filter as filter4,
  map as map5,
  mergeMap as mergeMap4,
  of as of3,
  take as take4,
  takeUntil,
  takeWhile as takeWhile3
} from "rxjs";
var getTrackTx = (blocks$, getBody) => (tx) => blocks$.pipe(
  take4(1),
  concatMap3((x) => {
    const alreadyPresent = new Set(x.blocks.keys());
    const findInBody = (hash) => alreadyPresent.has(hash) ? of3(-1) : getBody(hash).pipe(
      takeUntil(
        blocks$.pipe(filter4(({ blocks }) => !blocks.has(hash)))
      ),
      map5((txs) => txs.indexOf(tx))
    );
    const findInBranch = (hash) => findInBody(hash).pipe(
      concatMap3(
        (idx) => idx > -1 ? of3({ hash, idx }) : blocks$.pipe(
          takeWhile3((x2) => x2.blocks.has(hash)),
          mergeMap4((x2) => x2.blocks.get(hash).children),
          distinct(),
          mergeMap4(findInBranch)
        )
      )
    );
    return findInBranch(x.finalized).pipe(
      mergeMap4(
        ({ hash, idx }) => concat2(
          blocks$.pipe(
            isBestOrFinalizedBlock(hash),
            filter4(Boolean),
            take4(1),
            map5(() => ({
              type: "bestChainBlockIncluded",
              block: { hash, index: idx }
            }))
          ),
          blocks$.pipe(
            isFinalized(hash),
            filter4(Boolean),
            map5(() => ({
              type: "finalized",
              block: { hash, index: idx }
            }))
          )
        )
      )
    );
  }),
  takeWhile3((x) => x.type !== "finalized", true)
);

// src/observableClient/chainHead/chainHead.ts
var toBlockInfo = ({ hash, number, parent }) => ({
  hash,
  number,
  parent
});
var getChainHead$ = (chainHead) => {
  const { getFollower, unfollow, follow$ } = getFollow$(chainHead);
  const lazyFollower = withLazyFollower(getFollower);
  const { withRecovery, withRecoveryFn } = getWithRecovery();
  const blockUsage$ = new Subject3();
  const withRefcount = (fn) => (hash, ...args) => new Observable19((observer) => {
    blockUsage$.next({ type: "blockUsage", value: { type: "hold", hash } });
    const subscription = fn(hash, ...args).subscribe(observer);
    return () => {
      blockUsage$.next({
        type: "blockUsage",
        value: { type: "release", hash }
      });
      subscription.unsubscribe();
    };
  });
  const getHeader = (hash) => getFollower().header(hash).then(blockHeader.dec);
  const unpin = (hashes) => getFollower().unpin(hashes).catch((e) => {
    if (e instanceof DisjointError)
      return;
    throw e;
  });
  const commonEnhancer = (fn) => withRefcount(
    withEnsureCanonicalChain(
      pinnedBlocks$,
      follow$,
      withOperationInaccessibleRecovery(
        withRecoveryFn(fromAbortControllerFn(fn))
      )
    )
  );
  const _call$ = withOperationInaccessibleRecovery(
    withRecoveryFn(fromAbortControllerFn(lazyFollower("call")))
  );
  const cache = /* @__PURE__ */ new Map();
  const pinnedBlocks$ = getPinnedBlocks$(
    follow$,
    getHeader,
    _call$,
    blockUsage$,
    (blocks) => {
      unpin(blocks);
      blocks.forEach((hash) => {
        cache.delete(hash);
      });
    }
  );
  const getRuntimeContext$ = (hash) => pinnedBlocks$.pipe(
    take5(1),
    mergeMap5(
      (pinned) => pinned.runtimes[pinned.blocks.get(hash).runtime].runtime
    )
  );
  const withRuntime = (mapper) => (source$) => source$.pipe(
    concatMapEager(
      (x) => getRuntimeContext$(mapper(x)).pipe(map6((runtime) => [x, runtime]))
    )
  );
  const upsertCachedStream = (hash, key, stream) => {
    const cached = cache.get(hash)?.get(key);
    if (cached)
      return cached;
    if (!cache.has(hash))
      cache.set(hash, /* @__PURE__ */ new Map());
    const result = stream.pipe(
      share4({
        connector: () => new ReplaySubject3(),
        resetOnError: true,
        resetOnRefCountZero: true,
        resetOnComplete: false
      })
    );
    cache.get(hash).set(key, result);
    return result;
  };
  const finalized$ = pinnedBlocks$.pipe(
    distinctUntilChanged2((a, b) => a.finalized === b.finalized),
    map6((pinned) => toBlockInfo(pinned.blocks.get(pinned.finalized))),
    shareLatest
  );
  const bestBlocks$ = pinnedBlocks$.pipe(
    distinctUntilChanged2(
      (prev, current) => prev.finalized === current.finalized && prev.best === current.best
    ),
    scan2((acc, pinned) => {
      let current = pinned.best;
      const result = /* @__PURE__ */ new Map();
      while (current !== pinned.finalized) {
        const block = acc.get(current) || toBlockInfo(pinned.blocks.get(current));
        result.set(current, block);
        current = block.parent;
      }
      return result;
    }, /* @__PURE__ */ new Map()),
    map6((x) => [...x.values()]),
    shareLatest
  );
  const runtime$ = pinnedBlocks$.pipe(
    distinctUntilChanged2((a, b) => a.finalizedRuntime === b.finalizedRuntime),
    switchMap2(
      ({ finalizedRuntime: { runtime } }) => runtime.pipe(withDefaultValue(null))
    ),
    shareLatest
  );
  const metadata$ = runtime$.pipe(map6((x) => x?.metadata ?? null));
  const withOptionalHash$ = getWithOptionalhash$(
    finalized$.pipe(map6((x) => x.hash))
  );
  const _body$ = commonEnhancer(lazyFollower("body"));
  const body$ = (hash) => upsertCachedStream(hash, "body", _body$(hash));
  const trackTx$ = getTrackTx(pinnedBlocks$, body$);
  const _storage$ = commonEnhancer(lazyFollower("storage"));
  const storage$ = withOptionalHash$(
    (hash, type, keyMapper, childTrie = null, mapper) => pinnedBlocks$.pipe(
      take5(1),
      mergeMap5(
        (pinned) => pinned.runtimes[pinned.blocks.get(hash).runtime].runtime
      ),
      mergeMap5((ctx) => {
        const key = keyMapper(ctx);
        const unMapped$ = upsertCachedStream(
          hash,
          `storage-${type}-${key}-${childTrie ?? ""}`,
          _storage$(hash, type, key, childTrie)
        );
        return mapper ? upsertCachedStream(
          hash,
          `storage-${type}-${key}-${childTrie ?? ""}-dec`,
          unMapped$.pipe(map6((x) => mapper(x, ctx)))
        ) : unMapped$;
      })
    )
  );
  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery);
  const storageQueries$ = withOperationInaccessibleRecovery(
    withOptionalHash$(
      withRefcount(
        (hash, queries, childTrie) => recoveralStorage$(hash, queries, childTrie ?? null, false)
      )
    )
  );
  const header$ = withOptionalHash$(
    withRefcount((hash) => from(getHeader(hash)))
  );
  merge2(runtime$, bestBlocks$).subscribe();
  const eventsAt$ = (hash) => storage$(
    hash,
    "value",
    (ctx) => ctx.events.key,
    null,
    (x, ctx) => ctx.events.dec(x)
  );
  return {
    follow$,
    finalized$,
    bestBlocks$,
    runtime$,
    metadata$,
    header$,
    body$,
    call$: withOptionalHash$(withRefcount(_call$)),
    storage$,
    storageQueries$,
    eventsAt$,
    trackTx$,
    withRuntime,
    getRuntimeContext$: withOptionalHash$(getRuntimeContext$),
    unfollow
  };
};

// src/observableClient/tx.ts
import { Observable as Observable20 } from "rxjs";
var terminalTxEvents = /* @__PURE__ */ new Set(["error", "finalized", "invalid", "dropped"]);
var tx_default = (baseTransaction) => (transaction) => new Observable20(
  (observer) => baseTransaction(
    transaction,
    (event) => {
      if (event.type === "error")
        return observer.error(new Error(event.error));
      observer.next(event);
      if (terminalTxEvents.has(event.type))
        observer.complete();
    },
    (error) => {
      observer.error(error);
    }
  )
);

// src/observableClient/getObservableClient.ts
var getObservableClient = ({
  chainHead,
  transaction,
  destroy
}) => ({
  chainHead$: () => getChainHead$(chainHead),
  tx$: tx_default(transaction),
  destroy
});

// src/runtime.ts
import { filter as filter5, map as map7 } from "rxjs";
import { mapObject } from "@polkadot-api/utils";
var createRuntime = (descriptors, ctx) => {
  const constants = mapObject(descriptors.pallets, (_, palletName) => {
    const pallet = ctx.metadata.pallets.find((p) => p.name === palletName);
    const palletConstants = {};
    pallet?.constants.forEach((c) => {
      palletConstants[c.name] = { cache: false, value: c.value };
    });
    return new Proxy(
      {},
      {
        get(_2, name) {
          const cached = palletConstants[name];
          if (cached.cache)
            return cached.value;
          cached.cache = true;
          return cached.value = ctx.dynamicBuilder.buildConstant(palletName, name).dec(cached.value);
        }
      }
    );
  });
  const isCompatibleMapper = (idx, builder) => mapObject(
    descriptors.pallets,
    (x, pallet) => new Proxy(
      {},
      {
        get(_, name) {
          return ctx.checksumBuilder[builder](pallet, name) === x[idx][name];
        }
      }
    )
  );
  const isCompatibleApi = {
    query: isCompatibleMapper(0, "buildStorage"),
    tx: isCompatibleMapper(1, "buildCall"),
    event: isCompatibleMapper(2, "buildEvent"),
    const: isCompatibleMapper(4, "buildConstant")
  };
  const isCompatible = (cb) => cb(isCompatibleApi);
  return {
    constants,
    isCompatible
  };
};
var getRuntimeApi = (descriptors, chainHead) => {
  let latestRuntime;
  let resolve = null;
  latestRuntime = new Promise((res) => {
    resolve = res;
  });
  chainHead.runtime$.subscribe((x) => {
    if (x) {
      resolve(createRuntime(descriptors, x));
      resolve = null;
    } else if (!resolve) {
      latestRuntime = new Promise((res) => {
        resolve = res;
      });
    }
  });
  const result = chainHead.runtime$.pipe(
    filter5(Boolean),
    map7((x) => createRuntime(descriptors, x))
  );
  result.latest = () => latestRuntime;
  return result;
};

// src/runtime-call.ts
import { map as map8, mergeMap as mergeMap6 } from "rxjs";
import { toHex as toHex2 } from "@polkadot-api/utils";
var isOptionalArg = (lastArg) => {
  if (typeof lastArg !== "object")
    return false;
  return Object.keys(lastArg).every(
    (k) => k === "at" && typeof lastArg.at === "string" || k === "signal" && lastArg.signal instanceof AbortSignal
  );
};
var createRuntimeCallEntry = (checksum, api, method, chainHead) => {
  const callName = `${api}_${method}`;
  const checksumCheck = (ctx) => {
    const actualChecksum = ctx.checksumBuilder.buildRuntimeCall(api, method);
    if (checksum !== actualChecksum)
      throw new Error(`Incompatible runtime entry RuntimeCall(${callName})`);
  };
  return (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = chainHead.getRuntimeContext$(at).pipe(
      mergeMap6((ctx) => {
        checksumCheck(ctx);
        const codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method);
        return chainHead.call$(at, callName, toHex2(codecs.args.enc(args))).pipe(map8(codecs.value.dec));
      })
    );
    return firstValueFromWithSignal(result$, signal);
  };
};

// src/storage.ts
import {
  debounceTime,
  distinctUntilChanged as distinctUntilChanged3,
  exhaustMap,
  map as map9
} from "rxjs";
var isOptionalArg2 = (lastArg) => {
  if (typeof lastArg !== "object")
    return false;
  return Object.keys(lastArg).every(
    (k) => k === "at" && typeof lastArg.at === "string" || k === "signal" && lastArg.signal instanceof AbortSignal
  );
};
var createStorageEntry = (checksum, pallet, name, chainHead) => {
  const checksumCheck = (ctx) => {
    const actualChecksum = ctx.checksumBuilder.buildStorage(pallet, name);
    if (checksum !== actualChecksum)
      throw new Error(`Incompatible runtime entry Storage(${pallet}.${name})`);
  };
  const invalidArgs = (args) => new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`);
  const watchValue = (...args) => chainHead.finalized$.pipe(
    debounceTime(0),
    chainHead.withRuntime((x) => x.hash),
    exhaustMap(([block, ctx]) => {
      checksumCheck(ctx);
      const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
      return chainHead.storage$(block.hash, "value", () => codecs.enc(...args)).pipe(
        distinctUntilChanged3(),
        map9((val) => val === null ? codecs.fallback : codecs.dec(val))
      );
    })
  );
  const getValue = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg2(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = chainHead.storage$(
      at,
      "value",
      (ctx) => {
        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
        const actualArgs = args.length === codecs.len ? args : args.slice(0, -1);
        if (args !== actualArgs && !isLastArgOptional)
          throw invalidArgs(args);
        checksumCheck(ctx);
        return codecs.enc(...actualArgs);
      },
      null,
      (data, ctx) => {
        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
        return data === null ? codecs.fallback : codecs.dec(data);
      }
    );
    return firstValueFromWithSignal(result$, signal);
  };
  const getEntries = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg2(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = chainHead.storage$(
      at,
      "descendantsValues",
      (ctx) => {
        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
        if (args.length > codecs.len)
          throw invalidArgs(args);
        const actualArgs = args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args;
        if (args.length === codecs.len && actualArgs === args)
          throw invalidArgs(args);
        checksumCheck(ctx);
        return codecs.enc(...actualArgs);
      },
      null,
      (values, ctx) => {
        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
        return values.map(({ key, value }) => ({
          keyArgs: codecs.keyDecoder(key),
          value: codecs.dec(value)
        }));
      }
    );
    return firstValueFromWithSignal(result$, signal);
  };
  const getValues = (keyArgs, options) => Promise.all(
    keyArgs.map((args) => getValue(...options ? [...args, options] : args))
  );
  return { getValue, getValues, getEntries, watchValue };
};

// src/tx.ts
import {
  Binary,
  Enum
} from "@polkadot-api/substrate-bindings";
import {
  concat as concat3,
  firstValueFrom as firstValueFrom2,
  lastValueFrom,
  map as map10,
  mergeMap as mergeMap7,
  of as of4,
  take as take6,
  takeWhile as takeWhile4
} from "rxjs";
import { mergeUint8, toHex as toHex3 } from "@polkadot-api/utils";
var getTxSuccessFromSystemEvents = (systemEvents, txIdx) => {
  const events = systemEvents.filter((x) => x.phase.type === "ApplyExtrinsic" && x.phase.value === txIdx).map((x) => x.event);
  const lastEvent = events[events.length - 1];
  const ok = lastEvent.type === "System" && lastEvent.value.type === "ExtrinsicSuccess";
  return { ok, events };
};
var createTxEntry = (descriptor, pallet, name, assetChecksum, chainHead, client, signer) => (arg) => {
  const tx$ = (tx) => concat3(
    client.tx$(tx).pipe(takeWhile4((x) => x.type !== "broadcasted", true)),
    chainHead.trackTx$(tx)
  );
  const getCallData$ = (arg2, hinted = {}) => chainHead.getRuntimeContext$(null).pipe(
    map10(
      ({
        checksumBuilder,
        dynamicBuilder,
        asset: [assetEnc, assetCheck]
      }) => {
        const checksum = checksumBuilder.buildCall(pallet, name);
        if (checksum !== descriptor)
          throw new Error(
            `Incompatible runtime entry Tx(${pallet}.${name})`
          );
        let returnHinted = hinted;
        if (hinted.asset) {
          if (assetChecksum !== assetCheck)
            throw new Error(`Incompatible runtime asset`);
          returnHinted = { ...hinted, asset: assetEnc(hinted.asset) };
        }
        const { location, args } = dynamicBuilder.buildCall(pallet, name);
        return {
          callData: Binary.fromBytes(
            mergeUint8(new Uint8Array(location), args.enc(arg2))
          ),
          hinted: returnHinted
        };
      }
    )
  );
  const getEncodedData = () => firstValueFrom2(getCallData$(arg).pipe(map10((x) => x.callData)));
  const getTx = (from2, _hinted) => firstValueFrom2(
    getCallData$(arg, _hinted).pipe(
      mergeMap7(
        ({ callData, hinted }) => signer(from2, callData.asBytes(), hinted)
      ),
      map10(toHex3)
    )
  );
  const submit = async (from2, _hinted) => {
    const tx = await firstValueFrom2(
      getCallData$(arg, _hinted).pipe(
        mergeMap7(
          ({ callData, hinted }) => signer(from2, callData.asBytes(), hinted).then(toHex3)
        )
      )
    );
    const result = await lastValueFrom(tx$(tx));
    switch (result.type) {
      case "invalid":
        throw new Error("Invalid");
      case "dropped":
        throw new Error("Dropped");
      case "finalized": {
        const systemEvents = await firstValueFrom2(
          chainHead.eventsAt$(result.block.hash)
        );
        return getTxSuccessFromSystemEvents(
          systemEvents,
          Number(result.block.index)
        );
      }
      default:
        return { ok: true, events: [] };
    }
  };
  const submit$ = (from2, _hinted) => getCallData$(arg, _hinted).pipe(
    mergeMap7(
      ({ callData, hinted }) => signer(from2, callData.asBytes(), hinted)
    ),
    take6(1),
    mergeMap7((result) => {
      return tx$(toHex3(result)).pipe(
        mergeMap7((result2) => {
          switch (result2.type) {
            case "invalid":
              throw new Error("Invalid");
            case "dropped":
              throw new Error("Dropped");
            case "finalized": {
              return chainHead.eventsAt$(result2.block.hash).pipe(
                map10((events) => ({
                  ...result2,
                  ...getTxSuccessFromSystemEvents(
                    events,
                    Number(result2.block.index)
                  )
                }))
              );
            }
            default:
              return of4(result2);
          }
        })
      );
    })
  );
  return {
    callData: Enum(pallet, Enum(name, arg)),
    getEncodedData,
    getTx,
    submit,
    submit$
  };
};

// src/client.ts
var createTypedApi = (descriptors, createTxFromAddress, chainHead, client) => {
  const { pallets, apis: runtimeApis } = descriptors;
  const query = {};
  for (const pallet in pallets) {
    query[pallet] || (query[pallet] = {});
    const [stgEntries] = pallets[pallet];
    for (const name in stgEntries) {
      query[pallet][name] = createStorageEntry(
        stgEntries[name],
        pallet,
        name,
        chainHead
      );
    }
  }
  const tx = {};
  for (const pallet in pallets) {
    tx[pallet] || (tx[pallet] = {});
    const [, txEntries] = pallets[pallet];
    for (const name in txEntries) {
      tx[pallet][name] = createTxEntry(
        txEntries[name],
        pallet,
        name,
        descriptors.asset,
        chainHead,
        client,
        createTxFromAddress
      );
    }
  }
  const events = {};
  for (const pallet in pallets) {
    events[pallet] || (events[pallet] = {});
    const [, , evEntries] = pallets[pallet];
    for (const name in evEntries) {
      events[pallet][name] = createEventEntry(
        evEntries[name],
        pallet,
        name,
        chainHead
      );
    }
  }
  const apis = {};
  for (const api in runtimeApis) {
    apis[api] || (apis[api] = {});
    const methods = runtimeApis[api];
    for (const method in methods) {
      apis[api][method] = createRuntimeCallEntry(
        methods[method],
        api,
        method,
        chainHead
      );
    }
  }
  return {
    query,
    tx,
    event: events,
    apis,
    runtime: getRuntimeApi(descriptors, chainHead)
  };
};
var createClient = (connect) => {
  let createTx;
  const rawClient = createRawClient((onMsg) => {
    const result = connect(onMsg);
    createTx = result.createTx;
    return result;
  });
  const client = getObservableClient(rawClient);
  const chainHead = client.chainHead$();
  const createTxFromAddress = async (address, callData, hinted) => {
    let publicKey;
    if (address instanceof Uint8Array)
      publicKey = address;
    else {
      const { accountId } = await firstValueFrom3(
        chainHead.getRuntimeContext$(null)
      );
      publicKey = accountId.enc(address);
    }
    return createTx(publicKey, callData, hinted);
  };
  return {
    finalized$: chainHead.finalized$,
    bestBlocks$: chainHead.bestBlocks$,
    getBlockHeader: (hash) => firstValueFrom3(chainHead.header$(hash ?? null)),
    getBlockBody: chainHead.body$,
    destroy: () => {
      chainHead.unfollow();
      client.destroy();
    },
    getTypedApi: (descriptors) => createTypedApi(descriptors, createTxFromAddress, chainHead, client)
  };
};

// src/re-exports.ts
import {
  AccountId as AccountId2,
  Binary as Binary2,
  Enum as Enum2,
  _Enum
} from "@polkadot-api/substrate-bindings";
export {
  AccountId2 as AccountId,
  Binary2 as Binary,
  BlockPrunedError,
  Enum2 as Enum,
  NotBestBlockError,
  _Enum,
  createClient,
  getObservableClient
};
//# sourceMappingURL=index.mjs.map