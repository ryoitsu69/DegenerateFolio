{"version":3,"sources":["../../src/index.ts","../../src/client.ts","../../src/event.ts","../../src/utils/shareLatest.ts","../../src/utils/firstValueFromWithSignal.ts","../../src/utils/concatMapEager.ts","../../src/utils/withoutComplete.ts","../../src/utils/selfDependant.ts","../../src/utils/with-default-value.ts","../../src/observableClient/chainHead/chainHead.ts","../../src/observableClient/chainHead/streams/follow.ts","../../src/observableClient/chainHead/streams/get-runtime-creator.ts","../../src/observableClient/chainHead/streams/pinned-blocks.ts","../../src/observableClient/chainHead/enhancers/operationLimitRecovery.ts","../../src/observableClient/chainHead/enhancers/optionalHash.ts","../../src/observableClient/chainHead/enhancers/fromAbortControllerFn.ts","../../src/observableClient/chainHead/enhancers/lazyFollower.ts","../../src/observableClient/chainHead/enhancers/whileBestBlock.ts","../../src/observableClient/chainHead/streams/block-operations.ts","../../src/observableClient/chainHead/enhancers/operationInaccessibleRecovery.ts","../../src/observableClient/chainHead/storage-queries.ts","../../src/observableClient/chainHead/track-tx.ts","../../src/observableClient/tx.ts","../../src/observableClient/getObservableClient.ts","../../src/runtime.ts","../../src/runtime-call.ts","../../src/storage.ts","../../src/tx.ts","../../src/re-exports.ts"],"sourcesContent":["export * from \"./client\"\nexport * from \"./observableClient\"\nexport * from \"./re-exports\"\nexport type { BlockInfo } from \"./observableClient\"\nexport type { EventPhase } from \"./event\"\n","import { Descriptors } from \"@polkadot-api/substrate-bindings\"\nimport {\n  SubstrateClient,\n  createClient as createRawClient,\n} from \"@polkadot-api/substrate-client\"\nimport { firstValueFrom } from \"rxjs\"\nimport { EvClient, createEventEntry } from \"./event\"\nimport { getObservableClient } from \"./observableClient\"\nimport { getRuntimeApi } from \"./runtime\"\nimport { RuntimeCall, createRuntimeCallEntry } from \"./runtime-call\"\nimport { createStorageEntry, type StorageEntry } from \"./storage\"\nimport { Transaction, createTxEntry } from \"./tx\"\nimport {\n  CreateClient,\n  CreateTx,\n  HintedSignedExtensions,\n  TypedApi,\n} from \"./types\"\n\nconst createTypedApi = <D extends Descriptors>(\n  descriptors: D,\n  createTxFromAddress: (\n    address: string | Uint8Array,\n    callData: Uint8Array,\n  ) => Promise<Uint8Array>,\n  chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n  client: ReturnType<typeof getObservableClient>,\n): TypedApi<D> => {\n  const { pallets, apis: runtimeApis } = descriptors\n  const query = {} as Record<string, Record<string, StorageEntry<any, any>>>\n  for (const pallet in pallets) {\n    query[pallet] ||= {}\n    const [stgEntries] = pallets[pallet]\n    for (const name in stgEntries) {\n      query[pallet][name] = createStorageEntry(\n        stgEntries[name],\n        pallet,\n        name,\n        chainHead,\n      )\n    }\n  }\n\n  const tx = {} as Record<\n    string,\n    Record<string, (a: any) => Transaction<any, any, any, any>>\n  >\n  for (const pallet in pallets) {\n    tx[pallet] ||= {}\n    const [, txEntries] = pallets[pallet]\n    for (const name in txEntries) {\n      tx[pallet][name] = createTxEntry(\n        txEntries[name],\n        pallet,\n        name,\n        descriptors.asset,\n        chainHead,\n        client,\n        createTxFromAddress,\n      )\n    }\n  }\n\n  const events = {} as Record<string, Record<string, EvClient<any>>>\n  for (const pallet in pallets) {\n    events[pallet] ||= {}\n    const [, , evEntries] = pallets[pallet]\n    for (const name in evEntries) {\n      events[pallet][name] = createEventEntry(\n        evEntries[name],\n        pallet,\n        name,\n        chainHead,\n      )\n    }\n  }\n\n  const apis = {} as Record<string, Record<string, RuntimeCall<any, any>>>\n  for (const api in runtimeApis) {\n    apis[api] ||= {}\n    const methods = runtimeApis[api]\n    for (const method in methods) {\n      apis[api][method] = createRuntimeCallEntry(\n        methods[method],\n        api,\n        method,\n        chainHead,\n      )\n    }\n  }\n\n  return {\n    query: query,\n    tx: tx,\n    event: events,\n    apis,\n    runtime: getRuntimeApi(descriptors, chainHead),\n  } as any\n}\n\nexport const createClient: CreateClient = (connect) => {\n  let createTx: CreateTx\n  const rawClient: SubstrateClient = createRawClient((onMsg) => {\n    const result = connect(onMsg)\n    createTx = result.createTx\n    return result\n  })\n  const client = getObservableClient(rawClient)\n  const chainHead = client.chainHead$()\n\n  const createTxFromAddress = async (\n    address: string | Uint8Array,\n    callData: Uint8Array,\n    hinted?: HintedSignedExtensions,\n  ) => {\n    let publicKey: Uint8Array\n\n    if (address instanceof Uint8Array) publicKey = address\n    else {\n      const { accountId } = await firstValueFrom(\n        chainHead.getRuntimeContext$(null),\n      )\n      publicKey = accountId.enc(address)\n    }\n\n    return createTx(publicKey, callData, hinted)\n  }\n\n  return {\n    finalized$: chainHead.finalized$,\n    bestBlocks$: chainHead.bestBlocks$,\n    getBlockHeader: (hash?: string) =>\n      firstValueFrom(chainHead.header$(hash ?? null)),\n    getBlockBody: chainHead.body$,\n    destroy: () => {\n      chainHead.unfollow()\n      client.destroy()\n    },\n    getTypedApi: <D extends Descriptors>(descriptors: D) =>\n      createTypedApi(descriptors, createTxFromAddress, chainHead, client),\n  }\n}\n","import { PlainDescriptor } from \"@polkadot-api/substrate-bindings\"\nimport { Observable, firstValueFrom, map, mergeMap } from \"rxjs\"\nimport { concatMapEager, shareLatest } from \"./utils\"\nimport {\n  getObservableClient,\n  BlockInfo,\n  RuntimeContext,\n} from \"./observableClient\"\n\nexport type EventPhase =\n  | { type: \"ApplyExtrinsic\"; value: number }\n  | { type: \"Finalization\" }\n  | { type: \"Initialization\" }\n\nexport type EvWatch<T> = (filter?: (value: T) => boolean) => Observable<{\n  meta: {\n    block: BlockInfo\n    phase: EventPhase\n  }\n  payload: T\n}>\n\nexport type EvPull<T> = () => Promise<\n  Array<{\n    meta: {\n      block: BlockInfo\n      phase: EventPhase\n    }\n    payload: T\n  }>\n>\n\nexport type EvFilter<T> = (collection: SystemEvent[\"event\"][]) => Array<T>\n\nexport type EvClient<T> = {\n  watch: EvWatch<T>\n  pull: EvPull<T>\n  filter: EvFilter<T>\n}\n\ntype SystemEvent = {\n  phase: EventPhase\n  event: {\n    type: string\n    value: {\n      type: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\nexport const createEventEntry = <T>(\n  checksum: PlainDescriptor<T>,\n  pallet: string,\n  name: string,\n  chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n): EvClient<T> => {\n  const checksumCheck = (ctx: RuntimeContext) => {\n    const actualChecksum = ctx.checksumBuilder.buildEvent(pallet, name)\n    if (checksum !== actualChecksum)\n      throw new Error(`Incompatible runtime entry Event(${pallet}.${name})`)\n  }\n\n  const shared$ = chainHead.finalized$.pipe(\n    chainHead.withRuntime((x) => x.hash),\n    concatMapEager(([block, ctx]) => {\n      checksumCheck(ctx)\n      return chainHead.eventsAt$(block.hash).pipe(\n        map((events) => {\n          const winners = events.filter(\n            (e) => e.event.type === pallet && e.event.value.type === name,\n          )\n          return winners.map((x) => {\n            return {\n              meta: {\n                phase: x.phase,\n                block,\n              },\n              payload: x.event.value.value,\n            }\n          })\n        }),\n      )\n    }),\n    shareLatest,\n  )\n\n  const watch: EvWatch<T> = (f) =>\n    shared$.pipe(mergeMap((x) => (f ? x.filter((d) => f(d.payload)) : x)))\n\n  const pull: EvPull<T> = () => firstValueFrom(shared$)\n\n  const filter: EvFilter<T> = (events) =>\n    events\n      .filter((e) => e.type === pallet && e.value.type === name)\n      .map((x) => x.value.value)\n\n  return { watch, pull, filter }\n}\n","import { Observable, ReplaySubject, share } from \"rxjs\"\n\nexport const shareLatest: <T>(base: Observable<T>) => Observable<T> = share({\n  connector: () => new ReplaySubject(1),\n  resetOnError: true,\n  resetOnComplete: true,\n  resetOnRefCountZero: true,\n})\n","import { Observable, noop } from \"rxjs\"\n\nexport function firstValueFromWithSignal<T>(\n  source: Observable<T>,\n  signal?: AbortSignal,\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    const onAbort = signal\n      ? () => {\n          subscription.unsubscribe()\n        }\n      : noop\n\n    let isDone = false\n    const subscription = source.subscribe({\n      next: (value) => {\n        resolve(value)\n\n        // if the Observable emits synchronously, then `subscription`\n        // won't exist yet.\n        isDone = true\n        subscription?.unsubscribe()\n      },\n      error: (e) => {\n        reject(e)\n        signal?.removeEventListener(\"abort\", onAbort)\n      },\n      complete: () => {\n        reject(new Error(\"Observable completed without emitting\"))\n        signal?.removeEventListener(\"abort\", onAbort)\n      },\n    })\n\n    // in case that the observable emitted synchronously\n    if (isDone) {\n      subscription.unsubscribe()\n    } else {\n      signal?.addEventListener(\"abort\", onAbort)\n    }\n  })\n}\n","import { defer, Observable, ObservableInput, Subscription } from \"rxjs\"\n\nexport const concatMapEager =\n  <I, O>(\n    mapper: (outterValue: I, index: number) => ObservableInput<O>,\n    concurrent = Infinity,\n  ) =>\n  (source$: Observable<I>) =>\n    new Observable<O>((observer) => {\n      const queues = new Map<number, Observable<O>>()\n      const innerSubscriptions = new Map<number, Subscription>()\n      const results = new Map<number, O[]>()\n\n      let mapperIdx = 0\n      let subscriptionIdx = 0\n      let observerIdx = 0\n\n      const nextSubscription = () => {\n        const inner$ = queues.get(subscriptionIdx)\n        if (!inner$) {\n          if (topSubscription.closed && innerSubscriptions.size === 0) {\n            observer.complete()\n          }\n          return\n        }\n        const idx = subscriptionIdx++\n        queues.delete(idx)\n        if (observerIdx !== idx) {\n          results.set(idx, [])\n        }\n        innerSubscriptions.set(\n          idx,\n          inner$.subscribe({\n            next(x: O) {\n              if (observerIdx === idx) {\n                observer.next(x)\n              } else {\n                results.get(idx)!.push(x)\n              }\n            },\n            complete() {\n              innerSubscriptions.delete(idx)\n              if (idx === observerIdx) {\n                observerIdx++\n                while (results.has(observerIdx)) {\n                  results.get(observerIdx)!.forEach((x) => observer.next(x))\n                  results.delete(observerIdx)\n                  if (innerSubscriptions.has(observerIdx)) {\n                    break\n                  }\n                  observerIdx++\n                }\n              }\n              nextSubscription()\n            },\n            error(e: any) {\n              observer.error(e)\n            },\n          }),\n        )\n      }\n\n      const topSubscription = source$.subscribe({\n        next(outterValue: I) {\n          const idx = mapperIdx++\n          queues.set(\n            idx,\n            defer(() => mapper(outterValue, idx)),\n          )\n          if (innerSubscriptions.size < concurrent) {\n            nextSubscription()\n          }\n        },\n        error(e: any) {\n          observer.error(e)\n        },\n        complete() {\n          if (innerSubscriptions.size === 0) {\n            observer.complete()\n          }\n        },\n      })\n\n      return () => {\n        innerSubscriptions.forEach((subscription) => subscription.unsubscribe())\n        topSubscription.unsubscribe()\n        queues.clear()\n        results.clear()\n      }\n    })\n","import { Observable } from \"rxjs\"\n\nexport const withoutComplete = <T>(source: Observable<T>) =>\n  new Observable<T>((observer) =>\n    source.subscribe({\n      next(x) {\n        observer.next(x)\n      },\n      error(e) {\n        observer.error(e)\n      },\n    }),\n  )\n","import {\n  Observable,\n  Subject,\n  MonoTypeOperatorFunction,\n  BehaviorSubject,\n} from \"rxjs\"\nimport { switchAll, tap } from \"rxjs/operators\"\n\n/**\n * A creation operator that helps at creating observables that have circular\n * dependencies\n *\n * @returns [1, 2]\n * 1. The inner subject as an Observable\n * 2. A pipable operator that taps into the inner Subject\n */\nexport const selfDependent = <T>(): [\n  Observable<T>,\n  () => MonoTypeOperatorFunction<T>,\n] => {\n  const activeSubject: BehaviorSubject<Subject<T>> = new BehaviorSubject(\n    new Subject<T>(),\n  )\n  return [\n    activeSubject.pipe(switchAll()),\n    () =>\n      tap({\n        next: (v) => activeSubject.value.next(v),\n        error: (e) => {\n          activeSubject.value.error(e)\n          activeSubject.next(new Subject<T>())\n        },\n        complete: () => {\n          activeSubject.value.complete()\n          activeSubject.next(new Subject<T>())\n        },\n      }) as MonoTypeOperatorFunction<T>,\n  ]\n}\n","import { Observable } from \"rxjs\"\n\nexport const withDefaultValue =\n  <V, T>(defaultValue: V) =>\n  (source$: Observable<T>): Observable<V | T> =>\n    new Observable((observer) => {\n      let hasEmited = false\n\n      const subscription = source$.subscribe({\n        next(v) {\n          hasEmited = true\n          observer.next(v)\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          observer.complete()\n        },\n      })\n\n      if (!hasEmited) observer.next(defaultValue)\n\n      return subscription\n    })\n","import { concatMapEager, shareLatest } from \"@/utils\"\nimport { blockHeader } from \"@polkadot-api/substrate-bindings\"\nimport {\n  ChainHead,\n  DisjointError,\n  FollowEventWithRuntime,\n  StorageItemInput,\n  StorageResult,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  ReplaySubject,\n  Subject,\n  distinctUntilChanged,\n  from,\n  map,\n  merge,\n  mergeMap,\n  scan,\n  share,\n  switchMap,\n  take,\n} from \"rxjs\"\n\nimport type {\n  PinnedBlock,\n  BlockUsageEvent,\n  RuntimeContext,\n  SystemEvent,\n} from \"./streams\"\nimport { getFollow$, getPinnedBlocks$ } from \"./streams\"\nimport {\n  fromAbortControllerFn,\n  getWithOptionalhash$,\n  getWithRecovery,\n  withLazyFollower,\n  withOperationInaccessibleRecovery,\n  withEnsureCanonicalChain,\n} from \"./enhancers\"\nimport { withDefaultValue } from \"@/utils\"\nimport { getRecoveralStorage$ } from \"./storage-queries\"\nimport { getTrackTx } from \"./track-tx\"\n\nexport type { RuntimeContext, SystemEvent }\nexport type { FollowEventWithRuntime }\n\nexport type BlockInfo = {\n  hash: string\n  number: number\n  parent: string\n}\n\nconst toBlockInfo = ({ hash, number, parent }: PinnedBlock): BlockInfo => ({\n  hash,\n  number,\n  parent,\n})\n\nexport const getChainHead$ = (chainHead: ChainHead) => {\n  const { getFollower, unfollow, follow$ } = getFollow$(chainHead)\n  const lazyFollower = withLazyFollower(getFollower)\n  const { withRecovery, withRecoveryFn } = getWithRecovery()\n\n  const blockUsage$ = new Subject<BlockUsageEvent>()\n  const withRefcount =\n    <A extends Array<any>, T>(\n      fn: (hash: string, ...args: A) => Observable<T>,\n    ): ((hash: string, ...args: A) => Observable<T>) =>\n    (hash, ...args) =>\n      new Observable((observer) => {\n        blockUsage$.next({ type: \"blockUsage\", value: { type: \"hold\", hash } })\n        const subscription = fn(hash, ...args).subscribe(observer)\n        return () => {\n          blockUsage$.next({\n            type: \"blockUsage\",\n            value: { type: \"release\", hash },\n          })\n          subscription.unsubscribe()\n        }\n      })\n\n  const getHeader = (hash: string) =>\n    getFollower().header(hash).then(blockHeader.dec)\n\n  const unpin = (hashes: string[]) =>\n    getFollower()\n      .unpin(hashes)\n      .catch((e) => {\n        if (e instanceof DisjointError) return\n        throw e\n      })\n\n  const commonEnhancer = <A extends Array<any>, T>(\n    fn: (\n      key: string,\n      ...args: [...A, ...[abortSignal: AbortSignal]]\n    ) => Promise<T>,\n  ) =>\n    withRefcount(\n      withEnsureCanonicalChain(\n        pinnedBlocks$,\n        follow$,\n        withOperationInaccessibleRecovery(\n          withRecoveryFn(fromAbortControllerFn(fn)),\n        ),\n      ),\n    )\n\n  const _call$ = withOperationInaccessibleRecovery(\n    withRecoveryFn(fromAbortControllerFn(lazyFollower(\"call\"))),\n  )\n\n  const cache = new Map<string, Map<string, Observable<any>>>()\n  const pinnedBlocks$ = getPinnedBlocks$(\n    follow$,\n    getHeader,\n    _call$,\n    blockUsage$,\n    (blocks) => {\n      unpin(blocks)\n      blocks.forEach((hash) => {\n        cache.delete(hash)\n      })\n    },\n  )\n\n  const getRuntimeContext$ = (hash: string) =>\n    pinnedBlocks$.pipe(\n      take(1),\n      mergeMap(\n        (pinned) => pinned.runtimes[pinned.blocks.get(hash)!.runtime].runtime,\n      ),\n    )\n\n  const withRuntime =\n    <T>(mapper: (x: T) => string) =>\n    (source$: Observable<T>): Observable<[T, RuntimeContext]> =>\n      source$.pipe(\n        concatMapEager((x) =>\n          getRuntimeContext$(mapper(x)).pipe(map((runtime) => [x, runtime])),\n        ),\n      )\n\n  const upsertCachedStream = <T>(\n    hash: string,\n    key: string,\n    stream: Observable<T>,\n  ): Observable<T> => {\n    const cached = cache.get(hash)?.get(key)\n    if (cached) return cached\n\n    if (!cache.has(hash)) cache.set(hash, new Map())\n\n    const result = stream.pipe(\n      share({\n        connector: () => new ReplaySubject<T>(),\n        resetOnError: true,\n        resetOnRefCountZero: true,\n        resetOnComplete: false,\n      }),\n    )\n    cache.get(hash)!.set(key, result)\n\n    return result\n  }\n\n  const finalized$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.finalized === b.finalized),\n    map((pinned) => toBlockInfo(pinned.blocks.get(pinned.finalized)!)),\n    shareLatest,\n  )\n\n  const bestBlocks$ = pinnedBlocks$.pipe(\n    distinctUntilChanged(\n      (prev, current) =>\n        prev.finalized === current.finalized && prev.best === current.best,\n    ),\n    scan((acc, pinned) => {\n      let current = pinned.best\n      const result = new Map<string, BlockInfo>()\n      while (current !== pinned.finalized) {\n        const block =\n          acc.get(current) || toBlockInfo(pinned.blocks.get(current)!)\n        result.set(current, block)\n        current = block.parent\n      }\n      return result\n    }, new Map<string, BlockInfo>()),\n    map((x) => [...x.values()]),\n    shareLatest,\n  )\n\n  const runtime$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.finalizedRuntime === b.finalizedRuntime),\n    switchMap(({ finalizedRuntime: { runtime } }) =>\n      runtime.pipe(withDefaultValue(null)),\n    ),\n    shareLatest,\n  )\n\n  const metadata$ = runtime$.pipe(map((x) => x?.metadata ?? null))\n\n  const withOptionalHash$ = getWithOptionalhash$(\n    finalized$.pipe(map((x) => x.hash)),\n  )\n\n  const _body$ = commonEnhancer(lazyFollower(\"body\"))\n  const body$ = (hash: string) => upsertCachedStream(hash, \"body\", _body$(hash))\n  const trackTx$ = getTrackTx(pinnedBlocks$, body$)\n\n  const _storage$ = commonEnhancer(lazyFollower(\"storage\"))\n\n  const storage$ = withOptionalHash$(\n    <Type extends StorageItemInput[\"type\"], T>(\n      hash: string,\n      type: Type,\n      keyMapper: (ctx: RuntimeContext) => string,\n      childTrie: string | null = null,\n      mapper?: (data: StorageResult<Type>, ctx: RuntimeContext) => T,\n    ): Observable<unknown extends T ? StorageResult<Type> : T> =>\n      pinnedBlocks$.pipe(\n        take(1),\n        mergeMap(\n          (pinned) => pinned.runtimes[pinned.blocks.get(hash)!.runtime].runtime,\n        ),\n        mergeMap((ctx) => {\n          const key = keyMapper(ctx)\n          const unMapped$ = upsertCachedStream(\n            hash,\n            `storage-${type}-${key}-${childTrie ?? \"\"}`,\n            _storage$(hash, type, key, childTrie),\n          )\n\n          return mapper\n            ? upsertCachedStream(\n                hash,\n                `storage-${type}-${key}-${childTrie ?? \"\"}-dec`,\n                unMapped$.pipe(map((x) => mapper(x, ctx))),\n              )\n            : unMapped$\n        }),\n      ) as Observable<unknown extends T ? StorageResult<Type> : T>,\n  )\n\n  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery)\n  const storageQueries$ = withOperationInaccessibleRecovery(\n    withOptionalHash$(\n      withRefcount(\n        (hash: string, queries: Array<StorageItemInput>, childTrie?: string) =>\n          recoveralStorage$(hash, queries, childTrie ?? null, false),\n      ),\n    ),\n  )\n\n  const header$ = withOptionalHash$(\n    withRefcount((hash: string) => from(getHeader(hash))),\n  )\n\n  // calling `unfollow` also kills the subscription due to the fact\n  // that `follow$` completes, which makes all other streams to\n  // also complete (or error, in the case of ongoing operations)\n  merge(runtime$, bestBlocks$).subscribe()\n\n  const eventsAt$ = (hash: string | null) =>\n    storage$(\n      hash,\n      \"value\",\n      (ctx) => ctx.events.key,\n      null,\n      (x, ctx) => ctx.events.dec(x!),\n    )\n\n  return {\n    follow$,\n    finalized$,\n    bestBlocks$,\n    runtime$,\n    metadata$,\n\n    header$,\n    body$,\n    call$: withOptionalHash$(withRefcount(_call$)),\n    storage$,\n    storageQueries$,\n    eventsAt$,\n\n    trackTx$,\n    withRuntime,\n    getRuntimeContext$: withOptionalHash$(getRuntimeContext$),\n    unfollow,\n  }\n}\n","import {\n  ChainHead,\n  FollowEventWithRuntime,\n  FollowResponse,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, noop, share } from \"rxjs\"\n\nexport const getFollow$ = (chainHead: ChainHead) => {\n  let follower: FollowResponse\n  let unfollow: () => void = noop\n\n  const follow$ = new Observable<FollowEventWithRuntime>((observer) => {\n    follower = chainHead(\n      true,\n      (e) => {\n        observer.next(e)\n      },\n      (e) => {\n        console.warn(\"chainHead crashed\")\n        console.error(e)\n        observer.error(e)\n      },\n    )\n    unfollow = () => {\n      observer.complete()\n      follower.unfollow()\n    }\n  }).pipe(share())\n\n  return {\n    getFollower: () => {\n      if (!follower) throw new Error(\"Missing chainHead subscription\")\n      return follower\n    },\n    unfollow: () => {\n      unfollow()\n    },\n    follow$,\n  }\n}\n","import {\n  getChecksumBuilder,\n  getDynamicBuilder,\n  getLookupFn,\n} from \"@polkadot-api/metadata-builders\"\nimport {\n  AccountId,\n  Codec,\n  Decoder,\n  SS58String,\n  Tuple,\n  Option,\n  V15,\n  compact,\n  metadata,\n  u32,\n  Encoder,\n  _void,\n} from \"@polkadot-api/substrate-bindings\"\nimport { toHex } from \"@polkadot-api/utils\"\nimport { Observable, map, shareReplay } from \"rxjs\"\n\nexport type SystemEvent = {\n  phase:\n    | { type: \"ApplyExtrinsic\"; value: number }\n    | { type: \"Finalization\" }\n    | { type: \"Initialization\" }\n  event: {\n    type: string\n    value: {\n      type: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\nexport interface RuntimeContext {\n  metadata: V15\n  checksumBuilder: ReturnType<typeof getChecksumBuilder>\n  dynamicBuilder: ReturnType<typeof getDynamicBuilder>\n  events: {\n    key: string\n    dec: Decoder<Array<SystemEvent>>\n  }\n  accountId: Codec<SS58String>\n  asset: [Encoder<any>, string | null]\n}\n\nexport interface Runtime {\n  at: string\n  runtime: Observable<RuntimeContext>\n  addBlock: (block: string) => Runtime\n  deleteBlocks: (blocks: string[]) => number\n  usages: Set<string>\n}\n\nconst opaqueMeta = Option(Tuple(compact, metadata))\n\nconst v15Args = toHex(u32.enc(15))\nexport const getRuntimeCreator =\n  (call$: (hash: string, method: string, args: string) => Observable<string>) =>\n  (hash: string): Runtime => {\n    const usages = new Set<string>([hash])\n\n    const runtimeContext$: Observable<RuntimeContext> = call$(\n      hash,\n      \"Metadata_metadata_at_version\",\n      v15Args,\n    ).pipe(\n      map((response) => {\n        const metadata = opaqueMeta.dec(response)![1]\n        if (metadata.metadata.tag !== \"v15\")\n          throw new Error(\"Wrong metadata version\")\n        const v15 = metadata.metadata.value\n        const checksumBuilder = getChecksumBuilder(v15)\n        const dynamicBuilder = getDynamicBuilder(v15)\n        const events = dynamicBuilder.buildStorage(\"System\", \"Events\")\n\n        const assetPayment =\n          metadata.metadata.value.extrinsic.signedExtensions.find(\n            (x) => x.identifier === \"ChargeAssetTxPayment\",\n          )\n\n        let _assetId: null | number = null\n        if (assetPayment) {\n          const assetTxPayment = getLookupFn(metadata.metadata.value.lookup)(\n            assetPayment.type,\n          )\n          if (assetTxPayment.type === \"struct\") {\n            const optionalAssetId = assetTxPayment.value.asset_id\n            if (optionalAssetId.type === \"option\")\n              _assetId = optionalAssetId.value.id\n          }\n        }\n\n        const asset: [Encoder<any>, string | null] =\n          _assetId === null\n            ? [_void.enc, null]\n            : [\n                dynamicBuilder.buildDefinition(_assetId).enc,\n                checksumBuilder.buildDefinition(_assetId),\n              ]\n\n        return {\n          asset,\n          metadata: v15,\n          checksumBuilder,\n          dynamicBuilder,\n          events: {\n            key: events.enc(),\n            dec: events.dec as any,\n          },\n          accountId: AccountId(dynamicBuilder.ss58Prefix),\n        }\n      }),\n      shareReplay(1),\n    )\n\n    const result: Runtime = {\n      at: hash,\n      runtime: runtimeContext$,\n      addBlock: (block: string) => {\n        usages.add(block)\n        return result\n      },\n      deleteBlocks: (blocks) => {\n        blocks.forEach((block) => {\n          usages.delete(block)\n        })\n        return usages.size\n      },\n      usages,\n    }\n    runtimeContext$.subscribe()\n\n    return result\n  }\n","import { selfDependent, shareLatest } from \"@/utils\"\nimport { BlockHeader } from \"@polkadot-api/substrate-bindings\"\nimport { FollowEventWithRuntime } from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  Subject,\n  Subscription,\n  concatMap,\n  defer,\n  filter,\n  interval,\n  map,\n  merge,\n  of,\n  pairwise,\n  scan,\n  tap,\n  withLatestFrom,\n} from \"rxjs\"\nimport { Runtime, getRuntimeCreator } from \"./get-runtime-creator\"\n\nexport interface PinnedBlock {\n  hash: string\n  number: number\n  parent: string\n  children: Set<string>\n  runtime: string\n  refCount: number\n}\n\nexport interface BlockUsageEvent {\n  type: \"blockUsage\"\n  value: { type: \"hold\"; hash: string } | { type: \"release\"; hash: string }\n}\n\nexport type PinnedBlocks = {\n  best: string\n  finalized: string\n  runtimes: Record<string, Runtime>\n  blocks: Map<string, PinnedBlock>\n  finalizedRuntime: Runtime\n}\n\nexport const getPinnedBlocks$ = (\n  follow$: Observable<FollowEventWithRuntime>,\n  getHeader: (hash: string) => Promise<BlockHeader>,\n  call$: (hash: string, method: string, args: string) => Observable<string>,\n  blockUsage$: Observable<BlockUsageEvent>,\n  onUnpin: (blocks: string[]) => void,\n) => {\n  const getRuntime = getRuntimeCreator(call$)\n  const followWithInitializedNumber$ = follow$.pipe(\n    concatMap((event) => {\n      return event.type !== \"initialized\"\n        ? of(event)\n        : getHeader(event.finalizedBlockHashes.slice(-1)[0]).then((header) => ({\n            ...event,\n            number: header.number,\n            parentHash: header.parentHash,\n          }))\n    }),\n  )\n\n  const [unpinnedBlocks$, connectUnpinnedBlocks] = selfDependent<string[]>()\n\n  const prunedBlocks$ = new Subject<string[]>()\n  const cleaner$ = merge(\n    prunedBlocks$,\n    interval(100).pipe(\n      withLatestFrom(defer(() => pinnedBlocks$)),\n      map(([, pinned]) => {\n        const result = new Set<string>()\n\n        let current = pinned.blocks.get(pinned.finalized)!\n        while (pinned.blocks.has(current.parent)) {\n          current = pinned.blocks.get(current.parent)!\n          if (!current.refCount) result.add(current.hash)\n        }\n\n        return result\n      }),\n      pairwise(),\n      map(([prev, current]) => [...current].filter((x) => prev.has(x))),\n      filter((x) => x.length > 0),\n    ),\n  ).pipe(\n    connectUnpinnedBlocks(),\n    tap(onUnpin),\n    <T>(source$: Observable<T>) =>\n      new Observable<never>((observer) => {\n        let subscription: Subscription | null = null\n        // let's delay the initial subscription\n        const token = setTimeout(() => {\n          subscription = source$.subscribe({\n            error(e) {\n              observer.error(e)\n            },\n          })\n          subscription.add(\n            // and let's make sure that it completes when follow$ is done\n            follow$.subscribe({\n              complete() {\n                observer.complete()\n              },\n            }),\n          )\n        }, 0)\n\n        return () => {\n          clearTimeout(token)\n          subscription?.unsubscribe()\n        }\n      }),\n  )\n\n  const pinnedBlocks$: Observable<PinnedBlocks> = merge(\n    blockUsage$,\n    followWithInitializedNumber$,\n    unpinnedBlocks$.pipe(\n      map((hashes) => ({ type: \"unpin\" as \"unpin\", hashes })),\n    ),\n    cleaner$,\n  ).pipe(\n    scan(\n      (acc, event) => {\n        switch (event.type) {\n          case \"initialized\":\n            const [hash] = event.finalizedBlockHashes.slice(-1)\n            acc.finalized = acc.best = hash\n\n            acc.blocks.set(hash, {\n              hash,\n              parent: event.parentHash,\n              children: new Set(),\n              runtime: hash,\n              refCount: 0,\n              number: event.number,\n            })\n            acc.runtimes[hash] = getRuntime(hash)\n            acc.finalizedRuntime = acc.runtimes[hash]\n            return acc\n\n          case \"newBlock\": {\n            const { parentBlockHash: parent, blockHash: hash } = event\n            const parentNode = acc.blocks.get(parent)!\n            parentNode.children.add(hash)\n            if (event.newRuntime) {\n              acc.runtimes[hash] = getRuntime(hash)\n              acc.runtimes[hash].runtime.subscribe()\n            }\n            const block = {\n              hash,\n              number: parentNode.number + 1,\n              parent: parent,\n              children: new Set<string>(),\n              runtime: event.newRuntime ? hash : parentNode.runtime,\n              refCount: 0,\n            }\n            acc.blocks.set(hash, block)\n            acc.runtimes[block.runtime].addBlock(hash)\n            return acc\n          }\n\n          case \"bestBlockChanged\": {\n            acc.best = event.bestBlockHash\n            return acc\n          }\n\n          case \"finalized\": {\n            acc.finalized = event.finalizedBlockHashes.slice(-1)[0]\n            acc.finalizedRuntime =\n              acc.runtimes[acc.blocks.get(acc.finalized)!.runtime]\n            if (event.prunedBlockHashes.length > 0)\n              prunedBlocks$.next(event.prunedBlockHashes)\n            return acc\n          }\n\n          case \"blockUsage\": {\n            acc.blocks.get(event.value.hash)!.refCount +=\n              event.value.type === \"hold\" ? 1 : -1\n            return acc\n          }\n\n          case \"unpin\": {\n            event.hashes.forEach((h) => {\n              if (!acc.blocks.has(h)) return\n\n              acc.blocks.get(acc.blocks.get(h)!.parent)?.children.delete(h)\n              acc.blocks.delete(h)\n            })\n\n            Object.entries(acc.runtimes)\n              .map(([key, value]) => ({\n                key,\n                usages: value.deleteBlocks(event.hashes),\n              }))\n              .filter((x) => x.usages === 0)\n              .map((x) => x.key)\n              .forEach((unsusedRuntime) => {\n                delete acc.runtimes[unsusedRuntime]\n              })\n\n            return acc\n          }\n        }\n      },\n      {\n        best: \"\",\n        finalized: \"\",\n        runtimes: {},\n        blocks: new Map(),\n        finalizedRuntime: {},\n      } as PinnedBlocks,\n    ),\n    map((x) => ({ ...x })),\n    shareLatest,\n  )\n\n  return pinnedBlocks$\n}\n","import { OperationLimitError } from \"@polkadot-api/substrate-client\"\nimport type { Subscriber } from \"rxjs\"\nimport { Observable } from \"rxjs\"\n\ninterface PendingTaskNode<T> {\n  value: T\n  next?: PendingTaskNode<T>\n  prev?: PendingTaskNode<T>\n}\n\nexport default class PendingTaskQueue<T> {\n  private first?: PendingTaskNode<T>\n  private last?: PendingTaskNode<T>\n\n  private getRemoveFn(node: PendingTaskNode<T>) {\n    return () => {\n      if (node.prev) {\n        node.prev.next = node.next\n      } else {\n        this.first = node.next\n      }\n\n      if (node.next) {\n        node.next.prev = node.prev\n      } else {\n        this.last = node.prev\n      }\n\n      delete node.prev\n      delete node.next\n    }\n  }\n\n  push(value: T) {\n    const newNode: PendingTaskNode<T> = { value }\n\n    if (this.last === undefined) {\n      this.last = this.first = newNode\n    } else {\n      this.last.next = newNode\n      newNode.prev = this.last\n\n      this.last = newNode\n    }\n\n    return this.getRemoveFn(newNode)\n  }\n\n  unshift(value: T) {\n    this.first = { value, next: this.first }\n    this.first.next && (this.first.next.prev = this.first)\n    this.last ||= this.first\n    return this.getRemoveFn(this.first)\n  }\n\n  pop() {\n    const result = this.first?.value\n\n    if (this.first) {\n      this.first = this.first.next\n\n      if (!this.first) {\n        this.last = undefined\n      } else {\n        delete this.first.prev?.next\n        delete this.first.prev\n      }\n    }\n\n    return result\n  }\n\n  isEmpty() {\n    return !this.first\n  }\n}\n\nexport const getWithRecovery = () => {\n  const tearDownOperations = new Map<Observable<any>, () => void>()\n\n  const setTeardown = (observable: Observable<any>, cb: () => void) => {\n    tearDownOperations.set(observable, () => {\n      tearDownOperations.delete(observable)\n      cb()\n    })\n  }\n\n  const teardown = (observable: Observable<any>) => {\n    tearDownOperations.get(observable)?.()\n  }\n\n  const pendingTasks = new PendingTaskQueue<{\n    observer: Subscriber<any>\n    source$: Observable<any>\n  }>()\n  const unshift = pendingTasks.unshift.bind(pendingTasks)\n  const push = pendingTasks.push.bind(pendingTasks)\n\n  const addTask = (\n    task: {\n      observer: Subscriber<any>\n      source$: Observable<any>\n    },\n    topPriority: boolean,\n  ) => {\n    const fn = topPriority ? unshift : push\n    setTeardown(task.source$, fn(task))\n  }\n\n  const onEmptySlot = () => {\n    const data = pendingTasks.pop()\n    if (!data) return\n\n    tearDownOperations.delete(data.source$)\n    process(data)\n  }\n\n  const process = <T>(data: {\n    observer: Subscriber<T>\n    source$: Observable<T>\n  }) => {\n    const { source$, observer } = data\n\n    const subscription = source$.subscribe({\n      next(x) {\n        observer.next(x)\n      },\n      error(e) {\n        teardown(source$)\n        if (e instanceof OperationLimitError) return addTask(data, true)\n\n        observer.error(e)\n        onEmptySlot()\n      },\n      complete() {\n        observer.complete()\n        onEmptySlot()\n      },\n    })\n\n    if (!observer.closed) {\n      setTeardown(source$, () => {\n        subscription.unsubscribe()\n      })\n    }\n  }\n\n  const withRecovery =\n    (topPriority = false) =>\n    <T>(source$: Observable<T>): Observable<T> =>\n      new Observable((observer) => {\n        const pendingTask = { observer, source$ }\n\n        if (pendingTasks.isEmpty()) {\n          process(pendingTask)\n        } else {\n          addTask(pendingTask, topPriority)\n        }\n\n        return () => {\n          teardown(source$)\n        }\n      })\n\n  const withNormalRecovery = withRecovery()\n  const withRecoveryFn =\n    <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n    (...args: Args) =>\n      withNormalRecovery(fn(...args))\n\n  return { withRecovery, withRecoveryFn }\n}\n","import { withoutComplete } from \"@/utils\"\nimport {\n  Observable,\n  ReplaySubject,\n  concat,\n  mergeMap,\n  of,\n  share,\n  take,\n  takeWhile,\n} from \"rxjs\"\n\nconst DONE = Symbol(\"DONE\")\ntype DONE = typeof DONE\n\nconst delayUnsubscription = <T>(source$: Observable<T>) =>\n  new Observable<T>((observer) => {\n    const subscription = source$.subscribe(observer)\n    return () => {\n      setTimeout(() => {\n        subscription.unsubscribe()\n      }, 0)\n    }\n  })\n\nexport const getWithOptionalhash$ = (finalized$: Observable<string>) => {\n  const current$ = finalized$.pipe(\n    take(1),\n    withoutComplete,\n    share({\n      connector: () => new ReplaySubject(1),\n      resetOnError: true,\n      resetOnRefCountZero: true,\n      resetOnComplete: false,\n    }),\n    delayUnsubscription,\n  )\n\n  return <Args extends Array<any>, T>(\n      fn: (hash: string, ...args: Args) => Observable<T>,\n    ) =>\n    (hash: string | null, ...args: Args) =>\n      hash\n        ? fn(hash, ...args)\n        : current$.pipe(\n            mergeMap((h) => concat(fn(h, ...args), of(DONE))),\n            takeWhile((x): x is T => x !== DONE),\n          )\n}\n","import { Observable } from \"rxjs\"\n\nexport const fromAbortControllerFn =\n  <A extends Array<any>, T>(\n    fn: (...args: [...A, ...[abortSignal: AbortSignal]]) => Promise<T>,\n  ) =>\n  (...args: A): Observable<T> =>\n    new Observable((observer) => {\n      let aborter: AbortController | undefined = new AbortController()\n\n      fn(...[...args, aborter.signal]).then(\n        (value: any) => {\n          observer.next(value)\n          observer.complete()\n        },\n        (error: any) => {\n          observer.error(error)\n        },\n      )\n\n      return () => {\n        observer.unsubscribe()\n        aborter!.abort()\n        aborter = undefined\n      }\n    })\n","import { FollowResponse } from \"@polkadot-api/substrate-client\"\n\nexport const withLazyFollower =\n  (getFollower: () => FollowResponse) =>\n  <Key extends keyof FollowResponse>(key: Key): FollowResponse[Key] =>\n  (...args: any[]) =>\n    (getFollower() as any)[key](...args)\n","import {\n  Finalized,\n  FollowEventWithRuntime,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, filter, mergeMap, switchMap, take, throwError } from \"rxjs\"\nimport { PinnedBlocks } from \"../streams\"\nimport { isBestOrFinalizedBlock } from \"../streams/block-operations\"\n\nexport class BlockPrunedError extends Error {\n  constructor() {\n    super(\"Block pruned\")\n    this.name = \"BlockPrunedError\"\n  }\n}\nexport class NotBestBlockError extends Error {\n  constructor() {\n    super(\"Block is not best block or finalized\")\n    this.name = \"NotBestBlockError\"\n  }\n}\n\nexport function withEnsureCanonicalChain<A extends Array<any>, T>(\n  blocks$: Observable<PinnedBlocks>,\n  follow$: Observable<FollowEventWithRuntime>,\n  fn: (hash: string, ...args: A) => Observable<T>,\n) {\n  return (hash: string, ...args: A) =>\n    fn(hash, ...args).pipe(\n      throwWhenPrune(\n        hash,\n        follow$.pipe(\n          filter((evt): evt is Finalized => evt.type === \"finalized\"),\n          mergeMap((evt) => evt.prunedBlockHashes),\n        ),\n      ),\n      onlyIfIsBestOrFinalized(hash, blocks$),\n    )\n}\n\nconst onlyIfIsBestOrFinalized =\n  <T>(hash: string, blocks$: Observable<PinnedBlocks>) =>\n  (source$: Observable<T>) =>\n    blocks$.pipe(\n      isBestOrFinalizedBlock(hash),\n      take(1),\n      switchMap((isBest) =>\n        isBest ? source$ : throwError(() => new NotBestBlockError()),\n      ),\n    )\n\nconst throwWhenPrune =\n  <T>(hash: string, pruned$: Observable<string>) =>\n  (source$: Observable<T>) =>\n    new Observable<T>((subscriber) => {\n      const prunedSubscription = pruned$\n        .pipe(filter((h) => h === hash))\n        .subscribe(() => {\n          subscriber.error(new BlockPrunedError())\n        })\n      const sourceSubscription = source$.subscribe(subscriber)\n\n      return () => {\n        prunedSubscription.unsubscribe()\n        sourceSubscription.unsubscribe()\n      }\n    })\n","import {\n  Observable,\n  distinctUntilChanged,\n  filter,\n  map,\n  take,\n  takeWhile,\n} from \"rxjs\"\nimport { PinnedBlocks } from \"./pinned-blocks\"\n\nexport const isFinalized =\n  (blockHash: string) => (blocks$: Observable<PinnedBlocks>) =>\n    blocks$.pipe(\n      takeWhile((b) => b.blocks.has(blockHash)),\n      distinctUntilChanged((a, b) => a.finalized === b.finalized),\n      filter(\n        (x) =>\n          x.blocks.get(x.finalized)!.number >= x.blocks.get(blockHash)!.number,\n      ),\n      take(1),\n      map((pinned) => {\n        const { number } = pinned.blocks.get(blockHash)!\n        let current = pinned.blocks.get(pinned.finalized)!\n        while (current.number > number)\n          current = pinned.blocks.get(current.parent)!\n        return current.hash === blockHash\n      }),\n    )\n\nexport const isBestOrFinalizedBlock =\n  (blockHash: string) => (blocks$: Observable<PinnedBlocks>) =>\n    blocks$.pipe(\n      takeWhile((b) => b.blocks.has(blockHash)),\n      distinctUntilChanged((a, b) => a.best === b.best),\n      filter(\n        (x) => x.blocks.get(x.best)!.number >= x.blocks.get(blockHash)!.number,\n      ),\n      map((pinned) => {\n        const { number } = pinned.blocks.get(blockHash)!\n        let current = pinned.blocks.get(pinned.best)!\n        let isFinalized = pinned.finalized === current.hash\n        while (current.number > number) {\n          current = pinned.blocks.get(current.parent)!\n          isFinalized = isFinalized || pinned.finalized === current.hash\n        }\n        return { isBest: current.hash === blockHash, isFinalized }\n      }),\n      takeWhile(({ isFinalized }) => !isFinalized, true),\n      map(({ isBest }) => isBest),\n    )\n","import { OperationInaccessibleError } from \"@polkadot-api/substrate-client\"\nimport { Observable, catchError, concatMap, throwError, timer } from \"rxjs\"\n\nconst operable = <T>(source$: Observable<T>) => {\n  const result: Observable<T> = source$.pipe(\n    catchError((e) =>\n      e instanceof OperationInaccessibleError\n        ? timer(750).pipe(concatMap(() => result))\n        : throwError(() => e),\n    ),\n  )\n  return result\n}\n\nexport const withOperationInaccessibleRecovery =\n  <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n  (...args: Args): Observable<T> =>\n    operable(fn(...args))\n","import {\n  FollowResponse,\n  StorageItemInput,\n  StorageItemResponse,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, mergeAll } from \"rxjs\"\nimport { getWithRecovery } from \"./enhancers\"\n\nexport const getRecoveralStorage$ = (\n  getFollower: () => FollowResponse,\n  withRecovery: ReturnType<typeof getWithRecovery>[\"withRecovery\"],\n) => {\n  const recoveralStorage$ = (\n    hash: string,\n    queries: Array<StorageItemInput>,\n    childTrie: string | null,\n    isHighPriority: boolean,\n  ): Observable<StorageItemResponse> =>\n    new Observable<StorageItemResponse[] | Observable<StorageItemResponse>>(\n      (observer) =>\n        getFollower().storageSubscription(\n          hash,\n          queries,\n          childTrie ?? null,\n          (items) => {\n            observer.next(items)\n          },\n          (error) => {\n            observer.error(error)\n          },\n          () => {\n            observer.complete()\n          },\n          (nDiscarded) => {\n            if (nDiscarded === 0) return\n\n            observer.next(\n              recoveralStorage$(\n                hash,\n                queries.slice(-nDiscarded),\n                childTrie,\n                true,\n              ),\n            )\n          },\n        ),\n    ).pipe(mergeAll(), withRecovery(isHighPriority))\n\n  return recoveralStorage$\n}\n","import {\n  TxBestChainBlockIncluded,\n  TxFinalized,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  concat,\n  concatMap,\n  distinct,\n  filter,\n  map,\n  mergeMap,\n  of,\n  take,\n  takeUntil,\n  takeWhile,\n} from \"rxjs\"\nimport { PinnedBlocks } from \"./streams\"\nimport { isBestOrFinalizedBlock, isFinalized } from \"./streams/block-operations\"\n\nexport const getTrackTx =\n  (\n    blocks$: Observable<PinnedBlocks>,\n    getBody: (block: string) => Observable<string[]>,\n  ) =>\n  (tx: string): Observable<TxBestChainBlockIncluded | TxFinalized> =>\n    blocks$.pipe(\n      take(1),\n      concatMap((x) => {\n        const alreadyPresent = new Set(x.blocks.keys())\n\n        const findInBody = (hash: string): Observable<number> =>\n          alreadyPresent.has(hash)\n            ? of(-1)\n            : getBody(hash).pipe(\n                takeUntil(\n                  blocks$.pipe(filter(({ blocks }) => !blocks.has(hash))),\n                ),\n                map((txs) => txs.indexOf(tx)),\n              )\n\n        const findInBranch = (\n          hash: string,\n        ): Observable<{ hash: string; idx: number }> =>\n          findInBody(hash).pipe(\n            concatMap((idx) =>\n              idx > -1\n                ? of({ hash, idx })\n                : blocks$.pipe(\n                    takeWhile((x) => x.blocks.has(hash)),\n                    mergeMap((x) => x.blocks.get(hash)!.children),\n                    distinct(),\n                    mergeMap(findInBranch),\n                  ),\n            ),\n          )\n\n        return findInBranch(x.finalized).pipe(\n          mergeMap(({ hash, idx }) =>\n            concat(\n              blocks$.pipe(\n                isBestOrFinalizedBlock(hash),\n                filter(Boolean),\n                take(1),\n                map(() => ({\n                  type: \"bestChainBlockIncluded\" as const,\n                  block: { hash, index: idx },\n                })),\n              ),\n              blocks$.pipe(\n                isFinalized(hash),\n                filter(Boolean),\n                map(() => ({\n                  type: \"finalized\" as const,\n                  block: { hash, index: idx },\n                })),\n              ),\n            ),\n          ),\n        )\n      }),\n      takeWhile((x) => x.type !== \"finalized\", true),\n    )\n","import type {\n  SubstrateClient,\n  TxBestChainBlockIncluded,\n  TxBroadcasted,\n  TxDropped,\n  TxFinalized,\n  TxInvalid,\n  TxValidated,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable } from \"rxjs\"\n\nconst terminalTxEvents = new Set([\"error\", \"finalized\", \"invalid\", \"dropped\"])\n\nexport default (baseTransaction: SubstrateClient[\"transaction\"]) =>\n  (transaction: string) =>\n    new Observable<\n      | TxValidated\n      | TxBroadcasted\n      | TxBestChainBlockIncluded\n      | TxFinalized\n      | TxInvalid\n      | TxDropped\n    >((observer) =>\n      baseTransaction(\n        transaction,\n        (event) => {\n          if (event.type === \"error\")\n            return observer.error(new Error(event.error))\n\n          observer.next(event)\n          if (terminalTxEvents.has(event.type)) observer.complete()\n        },\n        (error) => {\n          observer.error(error)\n        },\n      ),\n    )\n","import type { SubstrateClient } from \"@polkadot-api/substrate-client\"\nexport type * from \"./chainHead\"\n\nimport { getChainHead$ } from \"./chainHead\"\nimport getTx$ from \"./tx\"\n\nexport const getObservableClient = ({\n  chainHead,\n  transaction,\n  destroy,\n}: SubstrateClient) => ({\n  chainHead$: () => getChainHead$(chainHead),\n  tx$: getTx$(transaction),\n  destroy,\n})\n","import {\n  ConstFromDescriptors,\n  Descriptors,\n  EventsFromDescriptors,\n  HexString,\n  QueryFromDescriptors,\n  TxFromDescriptors,\n} from \"@polkadot-api/substrate-bindings\"\nimport { RuntimeContext, getObservableClient } from \"./observableClient\"\nimport { Observable, filter, map } from \"rxjs\"\nimport { mapObject } from \"@polkadot-api/utils\"\n\ntype StorageRuntime<\n  A extends Record<\n    string,\n    Record<\n      string,\n      | {\n          KeyArgs: Array<any>\n          Value: any\n          IsOptional: false | true\n        }\n      | unknown\n    >\n  >,\n> = {\n  [K in keyof A]: {\n    [KK in keyof A[K]]: boolean\n  }\n}\n\ntype TxRuntime<A extends Record<string, Record<string, Array<any> | unknown>>> =\n  {\n    [K in keyof A]: {\n      [KK in keyof A[K]]: boolean\n    }\n  }\n\ntype PlainRuntime<A extends Record<string, Record<string, any>>> = {\n  [K in keyof A]: {\n    [KK in keyof A[K]]: boolean\n  }\n}\n\ntype MappedKey<K extends string, V> = `${K}${V extends Record<string, any>\n  ? `.${Paths<V>}`\n  : \"\"}`\ntype KeyMap<T> = {\n  [K in keyof T & string]: MappedKey<K, T[K]>\n}\ntype Paths<T> = KeyMap<T>[keyof T & string]\n\nexport interface Runtime<D extends Descriptors> {\n  constants: ConstFromDescriptors<D>\n  isCompatible: (\n    cb: (api: {\n      query: StorageRuntime<QueryFromDescriptors<D>>\n      tx: TxRuntime<TxFromDescriptors<D>>\n      event: PlainRuntime<EventsFromDescriptors<D>>\n      const: PlainRuntime<ConstFromDescriptors<D>>\n    }) => boolean,\n  ) => boolean\n}\n\nexport type RuntimeApi<T extends Descriptors> = Observable<Runtime<T>> & {\n  latest: () => Promise<Runtime<T>>\n}\n\nconst createRuntime = <D extends Descriptors>(\n  descriptors: D,\n  ctx: RuntimeContext,\n): Runtime<D> => {\n  const constants = mapObject(descriptors.pallets, (_, palletName) => {\n    const pallet = ctx.metadata.pallets.find((p) => p.name === palletName)\n    const palletConstants: Record<\n      string,\n      { cache: false; value: HexString } | { cache: true; value: any }\n    > = {}\n    pallet?.constants.forEach((c) => {\n      palletConstants[c.name] = { cache: false, value: c.value }\n    })\n\n    return new Proxy(\n      {},\n      {\n        get(_, name: string) {\n          const cached = palletConstants[name]\n          if (cached.cache) return cached.value\n\n          cached.cache = true as any\n          return (cached.value = ctx.dynamicBuilder\n            .buildConstant(palletName, name)\n            .dec(cached.value))\n        },\n      },\n    )\n  })\n  const isCompatibleMapper = (\n    idx: 0 | 1 | 2 | 4,\n    builder: \"buildStorage\" | \"buildEvent\" | \"buildCall\" | \"buildConstant\",\n  ) =>\n    mapObject(\n      descriptors.pallets,\n      (x, pallet: string) =>\n        new Proxy(\n          {},\n          {\n            get(_, name: string) {\n              return ctx.checksumBuilder[builder](pallet, name) === x[idx][name]\n            },\n          },\n        ),\n    )\n\n  const isCompatibleApi = {\n    query: isCompatibleMapper(0, \"buildStorage\"),\n    tx: isCompatibleMapper(1, \"buildCall\"),\n    event: isCompatibleMapper(2, \"buildEvent\"),\n    const: isCompatibleMapper(4, \"buildConstant\"),\n  }\n\n  const isCompatible: (cb: (api: any) => boolean) => boolean = (cb) =>\n    cb(isCompatibleApi)\n\n  return {\n    constants,\n    isCompatible,\n  } as any\n}\n\nexport const getRuntimeApi = <D extends Descriptors>(\n  descriptors: D,\n  chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n): RuntimeApi<D> => {\n  let latestRuntime: Promise<Runtime<D>>\n  let resolve: ((r: Runtime<D>) => void) | null = null\n\n  latestRuntime = new Promise<Runtime<D>>((res) => {\n    resolve = res\n  })\n\n  chainHead.runtime$.subscribe((x) => {\n    if (x) {\n      resolve!(createRuntime(descriptors, x))\n      resolve = null\n    } else if (!resolve) {\n      latestRuntime = new Promise<Runtime<D>>((res) => {\n        resolve = res\n      })\n    }\n  })\n\n  const result = chainHead.runtime$.pipe(\n    filter(Boolean),\n    map((x) => createRuntime(descriptors, x)),\n  ) as RuntimeApi<D>\n  result.latest = () => latestRuntime\n\n  return result\n}\n","import { map, mergeMap } from \"rxjs\"\nimport { firstValueFromWithSignal } from \"@/utils\"\nimport { getObservableClient, RuntimeContext } from \"./observableClient\"\nimport { toHex } from \"@polkadot-api/utils\"\n\ntype CallOptions = Partial<{\n  at: string\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = Args[\"length\"] extends 0\n  ? [options?: CallOptions]\n  : [...args: Args, options?: CallOptions]\n\nexport type RuntimeCall<Args extends Array<any>, Payload> = (\n  ...args: WithCallOptions<Args>\n) => Promise<Payload>\n\nconst isOptionalArg = (lastArg: any) => {\n  if (typeof lastArg !== \"object\") return false\n\n  return Object.keys(lastArg).every(\n    (k) =>\n      (k === \"at\" && typeof lastArg.at === \"string\") ||\n      (k === \"signal\" && lastArg.signal instanceof AbortSignal),\n  )\n}\n\nexport const createRuntimeCallEntry = (\n  checksum: string,\n  api: string,\n  method: string,\n  chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n): RuntimeCall<any, any> => {\n  const callName = `${api}_${method}`\n  const checksumCheck = (ctx: RuntimeContext) => {\n    const actualChecksum = ctx.checksumBuilder.buildRuntimeCall(api, method)\n    if (checksum !== actualChecksum)\n      throw new Error(`Incompatible runtime entry RuntimeCall(${callName})`)\n  }\n\n  return (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = chainHead.getRuntimeContext$(at).pipe(\n      mergeMap((ctx) => {\n        checksumCheck(ctx)\n        const codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method)\n        return chainHead\n          .call$(at, callName, toHex(codecs.args.enc(args)))\n          .pipe(map(codecs.value.dec))\n      }),\n    )\n\n    return firstValueFromWithSignal(result$, signal)\n  }\n}\n","import {\n  Observable,\n  debounceTime,\n  distinctUntilChanged,\n  exhaustMap,\n  map,\n} from \"rxjs\"\nimport { firstValueFromWithSignal } from \"@/utils\"\nimport { StorageItemInput, StorageResult } from \"@polkadot-api/substrate-client\"\nimport { getObservableClient, RuntimeContext } from \"./observableClient\"\n\ntype CallOptions = Partial<{\n  at: string\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: CallOptions,\n]\n\ntype PossibleParents<A extends Array<any>> = A extends [...infer Left, any]\n  ? Left | PossibleParents<Left>\n  : []\n\ntype StorageEntryWithoutKeys<Payload> = {\n  getValue: (options?: CallOptions) => Promise<Payload>\n  watchValue: () => Observable<Payload>\n}\n\ntype StorageEntryWithKeys<Args extends Array<any>, Payload> = {\n  getValue: (...args: [...WithCallOptions<Args>]) => Promise<Payload>\n  watchValue: (...args: Args) => Observable<Payload>\n  getValues: (\n    keys: Array<[...Args]>,\n    options?: CallOptions,\n  ) => Promise<Array<Payload>>\n  getEntries: (\n    ...args: WithCallOptions<PossibleParents<Args>>\n  ) => Promise<Array<{ keyArgs: Args; value: NonNullable<Payload> }>>\n}\n\nexport type StorageEntry<Args extends Array<any>, Payload> = Args extends []\n  ? StorageEntryWithoutKeys<Payload>\n  : StorageEntryWithKeys<Args, Payload>\n\nexport type Storage$ = <Type extends StorageItemInput[\"type\"]>(\n  hash: string | null,\n  type: Type,\n  key: string,\n  childTrie: string | null,\n) => Observable<StorageResult<Type>>\n\nconst isOptionalArg = (lastArg: any) => {\n  if (typeof lastArg !== \"object\") return false\n\n  return Object.keys(lastArg).every(\n    (k) =>\n      (k === \"at\" && typeof lastArg.at === \"string\") ||\n      (k === \"signal\" && lastArg.signal instanceof AbortSignal),\n  )\n}\n\nexport const createStorageEntry = (\n  checksum: string,\n  pallet: string,\n  name: string,\n  chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n) => {\n  const checksumCheck = (ctx: RuntimeContext) => {\n    const actualChecksum = ctx.checksumBuilder.buildStorage(pallet, name)\n    if (checksum !== actualChecksum)\n      throw new Error(`Incompatible runtime entry Storage(${pallet}.${name})`)\n  }\n\n  const invalidArgs = (args: Array<any>) =>\n    new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`)\n\n  const watchValue = (...args: Array<any>) =>\n    chainHead.finalized$.pipe(\n      debounceTime(0),\n      chainHead.withRuntime((x) => x.hash),\n      exhaustMap(([block, ctx]) => {\n        checksumCheck(ctx)\n        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n        return chainHead\n          .storage$(block.hash, \"value\", () => codecs.enc(...args))\n          .pipe(\n            distinctUntilChanged(),\n            map((val) => (val === null ? codecs.fallback : codecs.dec(val))),\n          )\n      }),\n    )\n\n  const getValue = (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = chainHead.storage$(\n      at,\n      \"value\",\n      (ctx) => {\n        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n        const actualArgs = args.length === codecs.len ? args : args.slice(0, -1)\n        if (args !== actualArgs && !isLastArgOptional) throw invalidArgs(args)\n        checksumCheck(ctx)\n        return codecs.enc(...actualArgs)\n      },\n      null,\n      (data, ctx) => {\n        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n        return data === null ? codecs.fallback : codecs.dec(data)\n      },\n    )\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  const getEntries = (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = chainHead.storage$(\n      at,\n      \"descendantsValues\",\n      (ctx) => {\n        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n        if (args.length > codecs.len) throw invalidArgs(args)\n        const actualArgs =\n          args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args\n        if (args.length === codecs.len && actualArgs === args)\n          throw invalidArgs(args)\n        checksumCheck(ctx)\n        return codecs.enc(...actualArgs)\n      },\n      null,\n      (values, ctx) => {\n        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n        return values.map(({ key, value }) => ({\n          keyArgs: codecs.keyDecoder(key),\n          value: codecs.dec(value),\n        }))\n      },\n    )\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  const getValues = (keyArgs: Array<Array<any>>, options?: CallOptions) =>\n    Promise.all(\n      keyArgs.map((args) => getValue(...(options ? [...args, options] : args))),\n    )\n\n  return { getValue, getValues, getEntries, watchValue }\n}\n","import {\n  Binary,\n  Enum,\n  PlainDescriptor,\n  SS58String,\n  TxDescriptor,\n} from \"@polkadot-api/substrate-bindings\"\nimport type {\n  TxBestChainBlockIncluded,\n  TxBroadcasted,\n  TxFinalized,\n  TxValidated,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  concat,\n  firstValueFrom,\n  lastValueFrom,\n  map,\n  mergeMap,\n  of,\n  take,\n  takeWhile,\n} from \"rxjs\"\nimport { mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport { getObservableClient, SystemEvent } from \"./observableClient\"\n\ntype TxSuccess = {\n  ok: boolean\n  events: Array<SystemEvent[\"event\"]>\n}\n\ntype TxFunction<Asset> = (\n  from: SS58String | Uint8Array,\n  hintedSignExtensions?: Partial<\n    void extends Asset\n      ? {\n          tip: bigint\n          mortal: { mortal: false } | { mortal: true; period: number }\n        }\n      : {\n          tip: bigint\n          mortal: { mortal: false } | { mortal: true; period: number }\n          asset: Asset\n        }\n  >,\n) => Promise<TxSuccess>\n\ntype TxObservable<Asset> = (\n  from: SS58String | Uint8Array,\n  hintedSignExtensions?: Partial<\n    void extends Asset\n      ? {\n          tip: bigint\n          mortal: { mortal: false } | { mortal: true; period: number }\n        }\n      : {\n          tip: bigint\n          mortal: { mortal: false } | { mortal: true; period: number }\n          asset: Asset\n        }\n  >,\n) => Observable<\n  | TxValidated\n  | TxBroadcasted\n  | TxBestChainBlockIncluded\n  | (TxFinalized & TxSuccess)\n>\n\ntype TxCall = () => Promise<Binary>\n\ntype TxSigned<Asset> = (\n  from: SS58String | Uint8Array,\n  hintedSignExtensions?: Partial<\n    void extends Asset\n      ? {\n          tip: bigint\n          mortal: { mortal: false } | { mortal: true; period: number }\n        }\n      : {\n          tip: bigint\n          mortal: { mortal: false } | { mortal: true; period: number }\n          asset: Asset\n        }\n  >,\n) => Promise<string>\n\nexport type Transaction<\n  Arg extends {} | undefined,\n  Pallet extends string,\n  Name extends string,\n  Asset,\n> = {\n  callData: Enum<{\n    type: Pallet\n    value: Enum<{\n      type: Name\n      value: Arg\n    }>\n  }>\n  getEncodedData: TxCall\n  getTx: TxSigned<Asset>\n  submit: TxFunction<Asset>\n  submit$: TxObservable<Asset>\n}\n\nconst getTxSuccessFromSystemEvents = (\n  systemEvents: Array<SystemEvent>,\n  txIdx: number,\n): TxSuccess => {\n  const events = systemEvents\n    .filter((x) => x.phase.type === \"ApplyExtrinsic\" && x.phase.value === txIdx)\n    .map((x) => x.event)\n\n  const lastEvent = events[events.length - 1]\n  const ok =\n    lastEvent.type === \"System\" && lastEvent.value.type === \"ExtrinsicSuccess\"\n\n  return { ok, events }\n}\n\nexport const createTxEntry =\n  <\n    Arg extends {} | undefined,\n    Pallet extends string,\n    Name extends string,\n    Asset extends PlainDescriptor<any>,\n  >(\n    descriptor: TxDescriptor<Arg>,\n    pallet: Pallet,\n    name: Name,\n    assetChecksum: Asset,\n    chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n    client: ReturnType<typeof getObservableClient>,\n    signer: (\n      from: string | Uint8Array,\n      callData: Uint8Array,\n      hinted?: Partial<{}>,\n    ) => Promise<Uint8Array>,\n  ): ((arg: any) => Transaction<Arg, Pallet, Name, Asset[\"_type\"]>) =>\n  (arg?: Arg): any => {\n    const tx$ = (tx: string) =>\n      concat(\n        client.tx$(tx).pipe(takeWhile((x) => x.type !== \"broadcasted\", true)),\n        chainHead.trackTx$(tx),\n      )\n\n    const getCallData$ = (arg: any, hinted: Partial<{ asset: any }> = {}) =>\n      chainHead.getRuntimeContext$(null).pipe(\n        map(\n          ({\n            checksumBuilder,\n            dynamicBuilder,\n            asset: [assetEnc, assetCheck],\n          }) => {\n            const checksum = checksumBuilder.buildCall(pallet, name)\n            if (checksum !== descriptor)\n              throw new Error(\n                `Incompatible runtime entry Tx(${pallet}.${name})`,\n              )\n\n            let returnHinted = hinted\n            if (hinted.asset) {\n              if (assetChecksum !== assetCheck)\n                throw new Error(`Incompatible runtime asset`)\n              returnHinted = { ...hinted, asset: assetEnc(hinted.asset) }\n            }\n\n            const { location, args } = dynamicBuilder.buildCall(pallet, name)\n            return {\n              callData: Binary.fromBytes(\n                mergeUint8(new Uint8Array(location), args.enc(arg)),\n              ),\n              hinted: returnHinted,\n            }\n          },\n        ),\n      )\n\n    const getEncodedData: TxCall = () =>\n      firstValueFrom(getCallData$(arg).pipe(map((x) => x.callData)))\n\n    const getTx: TxSigned<Asset> = (from, _hinted) =>\n      firstValueFrom(\n        getCallData$(arg, _hinted as any).pipe(\n          mergeMap(({ callData, hinted }) =>\n            signer(from, callData.asBytes(), hinted),\n          ),\n          map(toHex),\n        ),\n      )\n\n    const submit: TxFunction<Asset> = async (from, _hinted) => {\n      const tx = await firstValueFrom(\n        getCallData$(arg, _hinted as any).pipe(\n          mergeMap(({ callData, hinted }) =>\n            signer(from, callData.asBytes(), hinted).then(toHex),\n          ),\n        ),\n      )\n\n      const result = await lastValueFrom(tx$(tx))\n\n      switch (result.type) {\n        case \"invalid\":\n          throw new Error(\"Invalid\")\n        case \"dropped\":\n          throw new Error(\"Dropped\")\n        case \"finalized\": {\n          const systemEvents = await firstValueFrom(\n            chainHead.eventsAt$(result.block.hash),\n          )\n\n          return getTxSuccessFromSystemEvents(\n            systemEvents,\n            Number(result.block.index),\n          )\n        }\n        default:\n          return { ok: true, events: [] }\n      }\n    }\n\n    const submit$: TxObservable<Asset> = (from, _hinted) =>\n      getCallData$(arg, _hinted as any).pipe(\n        mergeMap(({ callData, hinted }) =>\n          signer(from, callData.asBytes(), hinted),\n        ),\n        take(1),\n        mergeMap((result) => {\n          return tx$(toHex(result)).pipe(\n            mergeMap((result) => {\n              switch (result.type) {\n                case \"invalid\":\n                  throw new Error(\"Invalid\")\n                case \"dropped\":\n                  throw new Error(\"Dropped\")\n                case \"finalized\": {\n                  return chainHead.eventsAt$(result.block.hash).pipe(\n                    map((events) => ({\n                      ...result,\n                      ...getTxSuccessFromSystemEvents(\n                        events,\n                        Number(result.block.index),\n                      ),\n                    })),\n                  )\n                }\n                default:\n                  return of(result)\n              }\n            }),\n          )\n        }),\n      )\n\n    return {\n      callData: Enum(pallet, Enum(name, arg as any)) as Enum<{\n        type: Pallet\n        value: any\n      }>,\n      getEncodedData,\n      getTx,\n      submit,\n      submit$,\n    }\n  }\n","export type {\n  Codec,\n  SS58String,\n  HexString,\n  GetEnum,\n  PlainDescriptor,\n  TxDescriptor,\n  StorageDescriptor,\n  QueryFromDescriptors,\n  TxFromDescriptors,\n  EventsFromDescriptors,\n  ErrorsFromDescriptors,\n  ConstFromDescriptors,\n  RuntimeDescriptor,\n  ResultPayload,\n} from \"@polkadot-api/substrate-bindings\"\nexport {\n  AccountId,\n  Binary,\n  Enum,\n  _Enum,\n} from \"@polkadot-api/substrate-bindings\"\n"],"mappings":"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","names":["src_exports","__export","BlockPrunedError","NotBestBlockError","createClient","getObservableClient","__toCommonJS","import_substrate_client","import_rxjs","import_rxjs","import_rxjs","shareLatest","import_rxjs","firstValueFromWithSignal","source","signal","resolve","reject","onAbort","subscription","isDone","value","e","import_rxjs","concatMapEager","mapper","concurrent","source$","observer","queues","innerSubscriptions","results","mapperIdx","subscriptionIdx","observerIdx","nextSubscription","inner$","topSubscription","idx","x","e","outterValue","subscription","import_rxjs","withoutComplete","source","observer","x","import_rxjs","import_operators","selfDependent","activeSubject","v","e","import_rxjs","withDefaultValue","defaultValue","source$","observer","hasEmited","subscription","v","e","createEventEntry","checksum","pallet","name","chainHead","checksumCheck","ctx","actualChecksum","shared$","x","concatMapEager","block","events","e","shareLatest","f","d","import_substrate_bindings","import_substrate_client","import_rxjs","import_rxjs","getFollow$","chainHead","follower","unfollow","follow$","observer","e","import_metadata_builders","import_substrate_bindings","import_utils","import_rxjs","opaqueMeta","v15Args","getRuntimeCreator","call$","hash","usages","runtimeContext$","response","metadata","v15","checksumBuilder","dynamicBuilder","events","assetPayment","x","_assetId","assetTxPayment","optionalAssetId","result","block","blocks","import_rxjs","getPinnedBlocks$","follow$","getHeader","call$","blockUsage$","onUnpin","getRuntime","getRuntimeCreator","followWithInitializedNumber$","event","header","unpinnedBlocks$","connectUnpinnedBlocks","selfDependent","prunedBlocks$","cleaner$","pinnedBlocks$","pinned","result","current","prev","x","source$","observer","subscription","token","e","hashes","acc","hash","parent","parentNode","block","h","key","value","unsusedRuntime","shareLatest","import_substrate_client","import_rxjs","PendingTaskQueue","__publicField","node","value","newNode","result","getWithRecovery","tearDownOperations","setTeardown","observable","cb","teardown","pendingTasks","unshift","push","addTask","task","topPriority","fn","onEmptySlot","data","process","source$","observer","subscription","e","withRecovery","pendingTask","withNormalRecovery","args","import_rxjs","DONE","delayUnsubscription","source$","observer","subscription","getWithOptionalhash$","finalized$","current$","withoutComplete","fn","hash","args","h","x","import_rxjs","fromAbortControllerFn","fn","args","observer","aborter","value","error","withLazyFollower","getFollower","key","args","import_rxjs","import_rxjs","isFinalized","blockHash","blocks$","b","a","x","pinned","number","current","isBestOrFinalizedBlock","isBest","BlockPrunedError","NotBestBlockError","withEnsureCanonicalChain","blocks$","follow$","fn","hash","args","throwWhenPrune","evt","onlyIfIsBestOrFinalized","source$","isBestOrFinalizedBlock","isBest","pruned$","subscriber","prunedSubscription","h","sourceSubscription","import_substrate_client","import_rxjs","operable","source$","result","withOperationInaccessibleRecovery","fn","args","import_rxjs","getRecoveralStorage$","getFollower","withRecovery","recoveralStorage$","hash","queries","childTrie","isHighPriority","observer","items","error","nDiscarded","import_rxjs","getTrackTx","blocks$","getBody","tx","x","alreadyPresent","findInBody","hash","blocks","txs","findInBranch","idx","isBestOrFinalizedBlock","isFinalized","toBlockInfo","hash","number","parent","getChainHead$","chainHead","getFollower","unfollow","follow$","getFollow$","lazyFollower","withLazyFollower","withRecovery","withRecoveryFn","getWithRecovery","blockUsage$","withRefcount","fn","args","observer","subscription","getHeader","unpin","hashes","e","commonEnhancer","withEnsureCanonicalChain","pinnedBlocks$","withOperationInaccessibleRecovery","fromAbortControllerFn","_call$","cache","getPinnedBlocks$","blocks","getRuntimeContext$","pinned","withRuntime","mapper","source$","concatMapEager","x","runtime","upsertCachedStream","key","stream","cached","result","finalized$","a","b","shareLatest","bestBlocks$","prev","current","acc","block","runtime$","withDefaultValue","metadata$","withOptionalHash$","getWithOptionalhash$","_body$","body$","trackTx$","getTrackTx","_storage$","storage$","type","keyMapper","childTrie","ctx","unMapped$","recoveralStorage$","getRecoveralStorage$","storageQueries$","queries","header$","eventsAt$","import_rxjs","terminalTxEvents","tx_default","baseTransaction","transaction","observer","event","error","getObservableClient","chainHead","transaction","destroy","getChainHead$","tx_default","import_rxjs","import_utils","createRuntime","descriptors","ctx","constants","_","palletName","pallet","p","palletConstants","c","name","cached","isCompatibleMapper","idx","builder","x","isCompatibleApi","cb","getRuntimeApi","chainHead","latestRuntime","resolve","res","result","import_rxjs","import_utils","isOptionalArg","lastArg","k","createRuntimeCallEntry","checksum","api","method","chainHead","callName","checksumCheck","ctx","actualChecksum","args","isLastArgOptional","signal","_at","at","result$","codecs","firstValueFromWithSignal","import_rxjs","isOptionalArg","lastArg","k","createStorageEntry","checksum","pallet","name","chainHead","checksumCheck","ctx","actualChecksum","invalidArgs","args","watchValue","x","block","codecs","val","getValue","isLastArgOptional","signal","_at","at","result$","actualArgs","data","firstValueFromWithSignal","keyArgs","options","values","key","value","import_substrate_bindings","import_rxjs","import_utils","getTxSuccessFromSystemEvents","systemEvents","txIdx","events","x","lastEvent","createTxEntry","descriptor","pallet","name","assetChecksum","chainHead","client","signer","arg","tx$","tx","getCallData$","hinted","checksumBuilder","dynamicBuilder","assetEnc","assetCheck","returnHinted","location","args","getEncodedData","getTx","from","_hinted","callData","submit","result","submit$","createTypedApi","descriptors","createTxFromAddress","chainHead","client","pallets","runtimeApis","query","pallet","stgEntries","name","createStorageEntry","tx","txEntries","createTxEntry","events","evEntries","createEventEntry","apis","api","methods","method","createRuntimeCallEntry","getRuntimeApi","createClient","connect","createTx","rawClient","createRawClient","onMsg","result","getObservableClient","address","callData","hinted","publicKey","accountId","hash","import_substrate_bindings"]}