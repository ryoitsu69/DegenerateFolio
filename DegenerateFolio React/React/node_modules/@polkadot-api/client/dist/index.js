"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AccountId: () => import_substrate_bindings4.AccountId,
  Binary: () => import_substrate_bindings4.Binary,
  BlockPrunedError: () => BlockPrunedError,
  Enum: () => import_substrate_bindings4.Enum,
  NotBestBlockError: () => NotBestBlockError,
  _Enum: () => import_substrate_bindings4._Enum,
  createClient: () => createClient,
  getObservableClient: () => getObservableClient
});
module.exports = __toCommonJS(src_exports);

// src/client.ts
var import_substrate_client4 = require("@polkadot-api/substrate-client");
var import_rxjs25 = require("rxjs");

// src/event.ts
var import_rxjs7 = require("rxjs");

// src/utils/shareLatest.ts
var import_rxjs = require("rxjs");
var shareLatest = (0, import_rxjs.share)({
  connector: () => new import_rxjs.ReplaySubject(1),
  resetOnError: true,
  resetOnComplete: true,
  resetOnRefCountZero: true
});

// src/utils/firstValueFromWithSignal.ts
var import_rxjs2 = require("rxjs");
function firstValueFromWithSignal(source, signal) {
  return new Promise((resolve, reject) => {
    const onAbort = signal ? () => {
      subscription.unsubscribe();
    } : import_rxjs2.noop;
    let isDone = false;
    const subscription = source.subscribe({
      next: (value) => {
        resolve(value);
        isDone = true;
        subscription?.unsubscribe();
      },
      error: (e) => {
        reject(e);
        signal?.removeEventListener("abort", onAbort);
      },
      complete: () => {
        reject(new Error("Observable completed without emitting"));
        signal?.removeEventListener("abort", onAbort);
      }
    });
    if (isDone) {
      subscription.unsubscribe();
    } else {
      signal?.addEventListener("abort", onAbort);
    }
  });
}

// src/utils/concatMapEager.ts
var import_rxjs3 = require("rxjs");
var concatMapEager = (mapper, concurrent = Infinity) => (source$) => new import_rxjs3.Observable((observer) => {
  const queues = /* @__PURE__ */ new Map();
  const innerSubscriptions = /* @__PURE__ */ new Map();
  const results = /* @__PURE__ */ new Map();
  let mapperIdx = 0;
  let subscriptionIdx = 0;
  let observerIdx = 0;
  const nextSubscription = () => {
    const inner$ = queues.get(subscriptionIdx);
    if (!inner$) {
      if (topSubscription.closed && innerSubscriptions.size === 0) {
        observer.complete();
      }
      return;
    }
    const idx = subscriptionIdx++;
    queues.delete(idx);
    if (observerIdx !== idx) {
      results.set(idx, []);
    }
    innerSubscriptions.set(
      idx,
      inner$.subscribe({
        next(x) {
          if (observerIdx === idx) {
            observer.next(x);
          } else {
            results.get(idx).push(x);
          }
        },
        complete() {
          innerSubscriptions.delete(idx);
          if (idx === observerIdx) {
            observerIdx++;
            while (results.has(observerIdx)) {
              results.get(observerIdx).forEach((x) => observer.next(x));
              results.delete(observerIdx);
              if (innerSubscriptions.has(observerIdx)) {
                break;
              }
              observerIdx++;
            }
          }
          nextSubscription();
        },
        error(e) {
          observer.error(e);
        }
      })
    );
  };
  const topSubscription = source$.subscribe({
    next(outterValue) {
      const idx = mapperIdx++;
      queues.set(
        idx,
        (0, import_rxjs3.defer)(() => mapper(outterValue, idx))
      );
      if (innerSubscriptions.size < concurrent) {
        nextSubscription();
      }
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (innerSubscriptions.size === 0) {
        observer.complete();
      }
    }
  });
  return () => {
    innerSubscriptions.forEach((subscription) => subscription.unsubscribe());
    topSubscription.unsubscribe();
    queues.clear();
    results.clear();
  };
});

// src/utils/withoutComplete.ts
var import_rxjs4 = require("rxjs");
var withoutComplete = (source) => new import_rxjs4.Observable(
  (observer) => source.subscribe({
    next(x) {
      observer.next(x);
    },
    error(e) {
      observer.error(e);
    }
  })
);

// src/utils/selfDependant.ts
var import_rxjs5 = require("rxjs");
var import_operators = require("rxjs/operators");
var selfDependent = () => {
  const activeSubject = new import_rxjs5.BehaviorSubject(
    new import_rxjs5.Subject()
  );
  return [
    activeSubject.pipe((0, import_operators.switchAll)()),
    () => (0, import_operators.tap)({
      next: (v) => activeSubject.value.next(v),
      error: (e) => {
        activeSubject.value.error(e);
        activeSubject.next(new import_rxjs5.Subject());
      },
      complete: () => {
        activeSubject.value.complete();
        activeSubject.next(new import_rxjs5.Subject());
      }
    })
  ];
};

// src/utils/with-default-value.ts
var import_rxjs6 = require("rxjs");
var withDefaultValue = (defaultValue) => (source$) => new import_rxjs6.Observable((observer) => {
  let hasEmited = false;
  const subscription = source$.subscribe({
    next(v) {
      hasEmited = true;
      observer.next(v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      observer.complete();
    }
  });
  if (!hasEmited)
    observer.next(defaultValue);
  return subscription;
});

// src/event.ts
var createEventEntry = (checksum, pallet, name, chainHead) => {
  const checksumCheck = (ctx) => {
    const actualChecksum = ctx.checksumBuilder.buildEvent(pallet, name);
    if (checksum !== actualChecksum)
      throw new Error(`Incompatible runtime entry Event(${pallet}.${name})`);
  };
  const shared$ = chainHead.finalized$.pipe(
    chainHead.withRuntime((x) => x.hash),
    concatMapEager(([block, ctx]) => {
      checksumCheck(ctx);
      return chainHead.eventsAt$(block.hash).pipe(
        (0, import_rxjs7.map)((events) => {
          const winners = events.filter(
            (e) => e.event.type === pallet && e.event.value.type === name
          );
          return winners.map((x) => {
            return {
              meta: {
                phase: x.phase,
                block
              },
              payload: x.event.value.value
            };
          });
        })
      );
    }),
    shareLatest
  );
  const watch = (f) => shared$.pipe((0, import_rxjs7.mergeMap)((x) => f ? x.filter((d) => f(d.payload)) : x));
  const pull = () => (0, import_rxjs7.firstValueFrom)(shared$);
  const filter6 = (events) => events.filter((e) => e.type === pallet && e.value.type === name).map((x) => x.value.value);
  return { watch, pull, filter: filter6 };
};

// src/observableClient/chainHead/chainHead.ts
var import_substrate_bindings2 = require("@polkadot-api/substrate-bindings");
var import_substrate_client3 = require("@polkadot-api/substrate-client");
var import_rxjs19 = require("rxjs");

// src/observableClient/chainHead/streams/follow.ts
var import_rxjs8 = require("rxjs");
var getFollow$ = (chainHead) => {
  let follower;
  let unfollow = import_rxjs8.noop;
  const follow$ = new import_rxjs8.Observable((observer) => {
    follower = chainHead(
      true,
      (e) => {
        observer.next(e);
      },
      (e) => {
        console.warn("chainHead crashed");
        console.error(e);
        observer.error(e);
      }
    );
    unfollow = () => {
      observer.complete();
      follower.unfollow();
    };
  }).pipe((0, import_rxjs8.share)());
  return {
    getFollower: () => {
      if (!follower)
        throw new Error("Missing chainHead subscription");
      return follower;
    },
    unfollow: () => {
      unfollow();
    },
    follow$
  };
};

// src/observableClient/chainHead/streams/get-runtime-creator.ts
var import_metadata_builders = require("@polkadot-api/metadata-builders");
var import_substrate_bindings = require("@polkadot-api/substrate-bindings");
var import_utils2 = require("@polkadot-api/utils");
var import_rxjs9 = require("rxjs");
var opaqueMeta = (0, import_substrate_bindings.Option)((0, import_substrate_bindings.Tuple)(import_substrate_bindings.compact, import_substrate_bindings.metadata));
var v15Args = (0, import_utils2.toHex)(import_substrate_bindings.u32.enc(15));
var getRuntimeCreator = (call$) => (hash) => {
  const usages = /* @__PURE__ */ new Set([hash]);
  const runtimeContext$ = call$(
    hash,
    "Metadata_metadata_at_version",
    v15Args
  ).pipe(
    (0, import_rxjs9.map)((response) => {
      const metadata2 = opaqueMeta.dec(response)[1];
      if (metadata2.metadata.tag !== "v15")
        throw new Error("Wrong metadata version");
      const v15 = metadata2.metadata.value;
      const checksumBuilder = (0, import_metadata_builders.getChecksumBuilder)(v15);
      const dynamicBuilder = (0, import_metadata_builders.getDynamicBuilder)(v15);
      const events = dynamicBuilder.buildStorage("System", "Events");
      const assetPayment = metadata2.metadata.value.extrinsic.signedExtensions.find(
        (x) => x.identifier === "ChargeAssetTxPayment"
      );
      let _assetId = null;
      if (assetPayment) {
        const assetTxPayment = (0, import_metadata_builders.getLookupFn)(metadata2.metadata.value.lookup)(
          assetPayment.type
        );
        if (assetTxPayment.type === "struct") {
          const optionalAssetId = assetTxPayment.value.asset_id;
          if (optionalAssetId.type === "option")
            _assetId = optionalAssetId.value.id;
        }
      }
      const asset = _assetId === null ? [import_substrate_bindings._void.enc, null] : [
        dynamicBuilder.buildDefinition(_assetId).enc,
        checksumBuilder.buildDefinition(_assetId)
      ];
      return {
        asset,
        metadata: v15,
        checksumBuilder,
        dynamicBuilder,
        events: {
          key: events.enc(),
          dec: events.dec
        },
        accountId: (0, import_substrate_bindings.AccountId)(dynamicBuilder.ss58Prefix)
      };
    }),
    (0, import_rxjs9.shareReplay)(1)
  );
  const result = {
    at: hash,
    runtime: runtimeContext$,
    addBlock: (block) => {
      usages.add(block);
      return result;
    },
    deleteBlocks: (blocks) => {
      blocks.forEach((block) => {
        usages.delete(block);
      });
      return usages.size;
    },
    usages
  };
  runtimeContext$.subscribe();
  return result;
};

// src/observableClient/chainHead/streams/pinned-blocks.ts
var import_rxjs10 = require("rxjs");
var getPinnedBlocks$ = (follow$, getHeader, call$, blockUsage$, onUnpin) => {
  const getRuntime = getRuntimeCreator(call$);
  const followWithInitializedNumber$ = follow$.pipe(
    (0, import_rxjs10.concatMap)((event) => {
      return event.type !== "initialized" ? (0, import_rxjs10.of)(event) : getHeader(event.finalizedBlockHashes.slice(-1)[0]).then((header) => ({
        ...event,
        number: header.number,
        parentHash: header.parentHash
      }));
    })
  );
  const [unpinnedBlocks$, connectUnpinnedBlocks] = selfDependent();
  const prunedBlocks$ = new import_rxjs10.Subject();
  const cleaner$ = (0, import_rxjs10.merge)(
    prunedBlocks$,
    (0, import_rxjs10.interval)(100).pipe(
      (0, import_rxjs10.withLatestFrom)((0, import_rxjs10.defer)(() => pinnedBlocks$)),
      (0, import_rxjs10.map)(([, pinned]) => {
        const result = /* @__PURE__ */ new Set();
        let current = pinned.blocks.get(pinned.finalized);
        while (pinned.blocks.has(current.parent)) {
          current = pinned.blocks.get(current.parent);
          if (!current.refCount)
            result.add(current.hash);
        }
        return result;
      }),
      (0, import_rxjs10.pairwise)(),
      (0, import_rxjs10.map)(([prev, current]) => [...current].filter((x) => prev.has(x))),
      (0, import_rxjs10.filter)((x) => x.length > 0)
    )
  ).pipe(
    connectUnpinnedBlocks(),
    (0, import_rxjs10.tap)(onUnpin),
    (source$) => new import_rxjs10.Observable((observer) => {
      let subscription = null;
      const token = setTimeout(() => {
        subscription = source$.subscribe({
          error(e) {
            observer.error(e);
          }
        });
        subscription.add(
          // and let's make sure that it completes when follow$ is done
          follow$.subscribe({
            complete() {
              observer.complete();
            }
          })
        );
      }, 0);
      return () => {
        clearTimeout(token);
        subscription?.unsubscribe();
      };
    })
  );
  const pinnedBlocks$ = (0, import_rxjs10.merge)(
    blockUsage$,
    followWithInitializedNumber$,
    unpinnedBlocks$.pipe(
      (0, import_rxjs10.map)((hashes) => ({ type: "unpin", hashes }))
    ),
    cleaner$
  ).pipe(
    (0, import_rxjs10.scan)(
      (acc, event) => {
        switch (event.type) {
          case "initialized":
            const [hash] = event.finalizedBlockHashes.slice(-1);
            acc.finalized = acc.best = hash;
            acc.blocks.set(hash, {
              hash,
              parent: event.parentHash,
              children: /* @__PURE__ */ new Set(),
              runtime: hash,
              refCount: 0,
              number: event.number
            });
            acc.runtimes[hash] = getRuntime(hash);
            acc.finalizedRuntime = acc.runtimes[hash];
            return acc;
          case "newBlock": {
            const { parentBlockHash: parent, blockHash: hash2 } = event;
            const parentNode = acc.blocks.get(parent);
            parentNode.children.add(hash2);
            if (event.newRuntime) {
              acc.runtimes[hash2] = getRuntime(hash2);
              acc.runtimes[hash2].runtime.subscribe();
            }
            const block = {
              hash: hash2,
              number: parentNode.number + 1,
              parent,
              children: /* @__PURE__ */ new Set(),
              runtime: event.newRuntime ? hash2 : parentNode.runtime,
              refCount: 0
            };
            acc.blocks.set(hash2, block);
            acc.runtimes[block.runtime].addBlock(hash2);
            return acc;
          }
          case "bestBlockChanged": {
            acc.best = event.bestBlockHash;
            return acc;
          }
          case "finalized": {
            acc.finalized = event.finalizedBlockHashes.slice(-1)[0];
            acc.finalizedRuntime = acc.runtimes[acc.blocks.get(acc.finalized).runtime];
            if (event.prunedBlockHashes.length > 0)
              prunedBlocks$.next(event.prunedBlockHashes);
            return acc;
          }
          case "blockUsage": {
            acc.blocks.get(event.value.hash).refCount += event.value.type === "hold" ? 1 : -1;
            return acc;
          }
          case "unpin": {
            event.hashes.forEach((h) => {
              if (!acc.blocks.has(h))
                return;
              acc.blocks.get(acc.blocks.get(h).parent)?.children.delete(h);
              acc.blocks.delete(h);
            });
            Object.entries(acc.runtimes).map(([key, value]) => ({
              key,
              usages: value.deleteBlocks(event.hashes)
            })).filter((x) => x.usages === 0).map((x) => x.key).forEach((unsusedRuntime) => {
              delete acc.runtimes[unsusedRuntime];
            });
            return acc;
          }
        }
      },
      {
        best: "",
        finalized: "",
        runtimes: {},
        blocks: /* @__PURE__ */ new Map(),
        finalizedRuntime: {}
      }
    ),
    (0, import_rxjs10.map)((x) => ({ ...x })),
    shareLatest
  );
  return pinnedBlocks$;
};

// src/observableClient/chainHead/enhancers/operationLimitRecovery.ts
var import_substrate_client = require("@polkadot-api/substrate-client");
var import_rxjs11 = require("rxjs");
var PendingTaskQueue = class {
  constructor() {
    __publicField(this, "first");
    __publicField(this, "last");
  }
  getRemoveFn(node) {
    return () => {
      if (node.prev) {
        node.prev.next = node.next;
      } else {
        this.first = node.next;
      }
      if (node.next) {
        node.next.prev = node.prev;
      } else {
        this.last = node.prev;
      }
      delete node.prev;
      delete node.next;
    };
  }
  push(value) {
    const newNode = { value };
    if (this.last === void 0) {
      this.last = this.first = newNode;
    } else {
      this.last.next = newNode;
      newNode.prev = this.last;
      this.last = newNode;
    }
    return this.getRemoveFn(newNode);
  }
  unshift(value) {
    this.first = { value, next: this.first };
    this.first.next && (this.first.next.prev = this.first);
    this.last || (this.last = this.first);
    return this.getRemoveFn(this.first);
  }
  pop() {
    const result = this.first?.value;
    if (this.first) {
      this.first = this.first.next;
      if (!this.first) {
        this.last = void 0;
      } else {
        delete this.first.prev?.next;
        delete this.first.prev;
      }
    }
    return result;
  }
  isEmpty() {
    return !this.first;
  }
};
var getWithRecovery = () => {
  const tearDownOperations = /* @__PURE__ */ new Map();
  const setTeardown = (observable, cb) => {
    tearDownOperations.set(observable, () => {
      tearDownOperations.delete(observable);
      cb();
    });
  };
  const teardown = (observable) => {
    tearDownOperations.get(observable)?.();
  };
  const pendingTasks = new PendingTaskQueue();
  const unshift = pendingTasks.unshift.bind(pendingTasks);
  const push = pendingTasks.push.bind(pendingTasks);
  const addTask = (task, topPriority) => {
    const fn = topPriority ? unshift : push;
    setTeardown(task.source$, fn(task));
  };
  const onEmptySlot = () => {
    const data = pendingTasks.pop();
    if (!data)
      return;
    tearDownOperations.delete(data.source$);
    process(data);
  };
  const process = (data) => {
    const { source$, observer } = data;
    const subscription = source$.subscribe({
      next(x) {
        observer.next(x);
      },
      error(e) {
        teardown(source$);
        if (e instanceof import_substrate_client.OperationLimitError)
          return addTask(data, true);
        observer.error(e);
        onEmptySlot();
      },
      complete() {
        observer.complete();
        onEmptySlot();
      }
    });
    if (!observer.closed) {
      setTeardown(source$, () => {
        subscription.unsubscribe();
      });
    }
  };
  const withRecovery = (topPriority = false) => (source$) => new import_rxjs11.Observable((observer) => {
    const pendingTask = { observer, source$ };
    if (pendingTasks.isEmpty()) {
      process(pendingTask);
    } else {
      addTask(pendingTask, topPriority);
    }
    return () => {
      teardown(source$);
    };
  });
  const withNormalRecovery = withRecovery();
  const withRecoveryFn = (fn) => (...args) => withNormalRecovery(fn(...args));
  return { withRecovery, withRecoveryFn };
};

// src/observableClient/chainHead/enhancers/optionalHash.ts
var import_rxjs12 = require("rxjs");
var DONE = Symbol("DONE");
var delayUnsubscription = (source$) => new import_rxjs12.Observable((observer) => {
  const subscription = source$.subscribe(observer);
  return () => {
    setTimeout(() => {
      subscription.unsubscribe();
    }, 0);
  };
});
var getWithOptionalhash$ = (finalized$) => {
  const current$ = finalized$.pipe(
    (0, import_rxjs12.take)(1),
    withoutComplete,
    (0, import_rxjs12.share)({
      connector: () => new import_rxjs12.ReplaySubject(1),
      resetOnError: true,
      resetOnRefCountZero: true,
      resetOnComplete: false
    }),
    delayUnsubscription
  );
  return (fn) => (hash, ...args) => hash ? fn(hash, ...args) : current$.pipe(
    (0, import_rxjs12.mergeMap)((h) => (0, import_rxjs12.concat)(fn(h, ...args), (0, import_rxjs12.of)(DONE))),
    (0, import_rxjs12.takeWhile)((x) => x !== DONE)
  );
};

// src/observableClient/chainHead/enhancers/fromAbortControllerFn.ts
var import_rxjs13 = require("rxjs");
var fromAbortControllerFn = (fn) => (...args) => new import_rxjs13.Observable((observer) => {
  let aborter = new AbortController();
  fn(...[...args, aborter.signal]).then(
    (value) => {
      observer.next(value);
      observer.complete();
    },
    (error) => {
      observer.error(error);
    }
  );
  return () => {
    observer.unsubscribe();
    aborter.abort();
    aborter = void 0;
  };
});

// src/observableClient/chainHead/enhancers/lazyFollower.ts
var withLazyFollower = (getFollower) => (key) => (...args) => getFollower()[key](...args);

// src/observableClient/chainHead/enhancers/whileBestBlock.ts
var import_rxjs15 = require("rxjs");

// src/observableClient/chainHead/streams/block-operations.ts
var import_rxjs14 = require("rxjs");
var isFinalized = (blockHash) => (blocks$) => blocks$.pipe(
  (0, import_rxjs14.takeWhile)((b) => b.blocks.has(blockHash)),
  (0, import_rxjs14.distinctUntilChanged)((a, b) => a.finalized === b.finalized),
  (0, import_rxjs14.filter)(
    (x) => x.blocks.get(x.finalized).number >= x.blocks.get(blockHash).number
  ),
  (0, import_rxjs14.take)(1),
  (0, import_rxjs14.map)((pinned) => {
    const { number } = pinned.blocks.get(blockHash);
    let current = pinned.blocks.get(pinned.finalized);
    while (current.number > number)
      current = pinned.blocks.get(current.parent);
    return current.hash === blockHash;
  })
);
var isBestOrFinalizedBlock = (blockHash) => (blocks$) => blocks$.pipe(
  (0, import_rxjs14.takeWhile)((b) => b.blocks.has(blockHash)),
  (0, import_rxjs14.distinctUntilChanged)((a, b) => a.best === b.best),
  (0, import_rxjs14.filter)(
    (x) => x.blocks.get(x.best).number >= x.blocks.get(blockHash).number
  ),
  (0, import_rxjs14.map)((pinned) => {
    const { number } = pinned.blocks.get(blockHash);
    let current = pinned.blocks.get(pinned.best);
    let isFinalized2 = pinned.finalized === current.hash;
    while (current.number > number) {
      current = pinned.blocks.get(current.parent);
      isFinalized2 = isFinalized2 || pinned.finalized === current.hash;
    }
    return { isBest: current.hash === blockHash, isFinalized: isFinalized2 };
  }),
  (0, import_rxjs14.takeWhile)(({ isFinalized: isFinalized2 }) => !isFinalized2, true),
  (0, import_rxjs14.map)(({ isBest }) => isBest)
);

// src/observableClient/chainHead/enhancers/whileBestBlock.ts
var BlockPrunedError = class extends Error {
  constructor() {
    super("Block pruned");
    this.name = "BlockPrunedError";
  }
};
var NotBestBlockError = class extends Error {
  constructor() {
    super("Block is not best block or finalized");
    this.name = "NotBestBlockError";
  }
};
function withEnsureCanonicalChain(blocks$, follow$, fn) {
  return (hash, ...args) => fn(hash, ...args).pipe(
    throwWhenPrune(
      hash,
      follow$.pipe(
        (0, import_rxjs15.filter)((evt) => evt.type === "finalized"),
        (0, import_rxjs15.mergeMap)((evt) => evt.prunedBlockHashes)
      )
    ),
    onlyIfIsBestOrFinalized(hash, blocks$)
  );
}
var onlyIfIsBestOrFinalized = (hash, blocks$) => (source$) => blocks$.pipe(
  isBestOrFinalizedBlock(hash),
  (0, import_rxjs15.take)(1),
  (0, import_rxjs15.switchMap)(
    (isBest) => isBest ? source$ : (0, import_rxjs15.throwError)(() => new NotBestBlockError())
  )
);
var throwWhenPrune = (hash, pruned$) => (source$) => new import_rxjs15.Observable((subscriber) => {
  const prunedSubscription = pruned$.pipe((0, import_rxjs15.filter)((h) => h === hash)).subscribe(() => {
    subscriber.error(new BlockPrunedError());
  });
  const sourceSubscription = source$.subscribe(subscriber);
  return () => {
    prunedSubscription.unsubscribe();
    sourceSubscription.unsubscribe();
  };
});

// src/observableClient/chainHead/enhancers/operationInaccessibleRecovery.ts
var import_substrate_client2 = require("@polkadot-api/substrate-client");
var import_rxjs16 = require("rxjs");
var operable = (source$) => {
  const result = source$.pipe(
    (0, import_rxjs16.catchError)(
      (e) => e instanceof import_substrate_client2.OperationInaccessibleError ? (0, import_rxjs16.timer)(750).pipe((0, import_rxjs16.concatMap)(() => result)) : (0, import_rxjs16.throwError)(() => e)
    )
  );
  return result;
};
var withOperationInaccessibleRecovery = (fn) => (...args) => operable(fn(...args));

// src/observableClient/chainHead/storage-queries.ts
var import_rxjs17 = require("rxjs");
var getRecoveralStorage$ = (getFollower, withRecovery) => {
  const recoveralStorage$ = (hash, queries, childTrie, isHighPriority) => new import_rxjs17.Observable(
    (observer) => getFollower().storageSubscription(
      hash,
      queries,
      childTrie ?? null,
      (items) => {
        observer.next(items);
      },
      (error) => {
        observer.error(error);
      },
      () => {
        observer.complete();
      },
      (nDiscarded) => {
        if (nDiscarded === 0)
          return;
        observer.next(
          recoveralStorage$(
            hash,
            queries.slice(-nDiscarded),
            childTrie,
            true
          )
        );
      }
    )
  ).pipe((0, import_rxjs17.mergeAll)(), withRecovery(isHighPriority));
  return recoveralStorage$;
};

// src/observableClient/chainHead/track-tx.ts
var import_rxjs18 = require("rxjs");
var getTrackTx = (blocks$, getBody) => (tx) => blocks$.pipe(
  (0, import_rxjs18.take)(1),
  (0, import_rxjs18.concatMap)((x) => {
    const alreadyPresent = new Set(x.blocks.keys());
    const findInBody = (hash) => alreadyPresent.has(hash) ? (0, import_rxjs18.of)(-1) : getBody(hash).pipe(
      (0, import_rxjs18.takeUntil)(
        blocks$.pipe((0, import_rxjs18.filter)(({ blocks }) => !blocks.has(hash)))
      ),
      (0, import_rxjs18.map)((txs) => txs.indexOf(tx))
    );
    const findInBranch = (hash) => findInBody(hash).pipe(
      (0, import_rxjs18.concatMap)(
        (idx) => idx > -1 ? (0, import_rxjs18.of)({ hash, idx }) : blocks$.pipe(
          (0, import_rxjs18.takeWhile)((x2) => x2.blocks.has(hash)),
          (0, import_rxjs18.mergeMap)((x2) => x2.blocks.get(hash).children),
          (0, import_rxjs18.distinct)(),
          (0, import_rxjs18.mergeMap)(findInBranch)
        )
      )
    );
    return findInBranch(x.finalized).pipe(
      (0, import_rxjs18.mergeMap)(
        ({ hash, idx }) => (0, import_rxjs18.concat)(
          blocks$.pipe(
            isBestOrFinalizedBlock(hash),
            (0, import_rxjs18.filter)(Boolean),
            (0, import_rxjs18.take)(1),
            (0, import_rxjs18.map)(() => ({
              type: "bestChainBlockIncluded",
              block: { hash, index: idx }
            }))
          ),
          blocks$.pipe(
            isFinalized(hash),
            (0, import_rxjs18.filter)(Boolean),
            (0, import_rxjs18.map)(() => ({
              type: "finalized",
              block: { hash, index: idx }
            }))
          )
        )
      )
    );
  }),
  (0, import_rxjs18.takeWhile)((x) => x.type !== "finalized", true)
);

// src/observableClient/chainHead/chainHead.ts
var toBlockInfo = ({ hash, number, parent }) => ({
  hash,
  number,
  parent
});
var getChainHead$ = (chainHead) => {
  const { getFollower, unfollow, follow$ } = getFollow$(chainHead);
  const lazyFollower = withLazyFollower(getFollower);
  const { withRecovery, withRecoveryFn } = getWithRecovery();
  const blockUsage$ = new import_rxjs19.Subject();
  const withRefcount = (fn) => (hash, ...args) => new import_rxjs19.Observable((observer) => {
    blockUsage$.next({ type: "blockUsage", value: { type: "hold", hash } });
    const subscription = fn(hash, ...args).subscribe(observer);
    return () => {
      blockUsage$.next({
        type: "blockUsage",
        value: { type: "release", hash }
      });
      subscription.unsubscribe();
    };
  });
  const getHeader = (hash) => getFollower().header(hash).then(import_substrate_bindings2.blockHeader.dec);
  const unpin = (hashes) => getFollower().unpin(hashes).catch((e) => {
    if (e instanceof import_substrate_client3.DisjointError)
      return;
    throw e;
  });
  const commonEnhancer = (fn) => withRefcount(
    withEnsureCanonicalChain(
      pinnedBlocks$,
      follow$,
      withOperationInaccessibleRecovery(
        withRecoveryFn(fromAbortControllerFn(fn))
      )
    )
  );
  const _call$ = withOperationInaccessibleRecovery(
    withRecoveryFn(fromAbortControllerFn(lazyFollower("call")))
  );
  const cache = /* @__PURE__ */ new Map();
  const pinnedBlocks$ = getPinnedBlocks$(
    follow$,
    getHeader,
    _call$,
    blockUsage$,
    (blocks) => {
      unpin(blocks);
      blocks.forEach((hash) => {
        cache.delete(hash);
      });
    }
  );
  const getRuntimeContext$ = (hash) => pinnedBlocks$.pipe(
    (0, import_rxjs19.take)(1),
    (0, import_rxjs19.mergeMap)(
      (pinned) => pinned.runtimes[pinned.blocks.get(hash).runtime].runtime
    )
  );
  const withRuntime = (mapper) => (source$) => source$.pipe(
    concatMapEager(
      (x) => getRuntimeContext$(mapper(x)).pipe((0, import_rxjs19.map)((runtime) => [x, runtime]))
    )
  );
  const upsertCachedStream = (hash, key, stream) => {
    const cached = cache.get(hash)?.get(key);
    if (cached)
      return cached;
    if (!cache.has(hash))
      cache.set(hash, /* @__PURE__ */ new Map());
    const result = stream.pipe(
      (0, import_rxjs19.share)({
        connector: () => new import_rxjs19.ReplaySubject(),
        resetOnError: true,
        resetOnRefCountZero: true,
        resetOnComplete: false
      })
    );
    cache.get(hash).set(key, result);
    return result;
  };
  const finalized$ = pinnedBlocks$.pipe(
    (0, import_rxjs19.distinctUntilChanged)((a, b) => a.finalized === b.finalized),
    (0, import_rxjs19.map)((pinned) => toBlockInfo(pinned.blocks.get(pinned.finalized))),
    shareLatest
  );
  const bestBlocks$ = pinnedBlocks$.pipe(
    (0, import_rxjs19.distinctUntilChanged)(
      (prev, current) => prev.finalized === current.finalized && prev.best === current.best
    ),
    (0, import_rxjs19.scan)((acc, pinned) => {
      let current = pinned.best;
      const result = /* @__PURE__ */ new Map();
      while (current !== pinned.finalized) {
        const block = acc.get(current) || toBlockInfo(pinned.blocks.get(current));
        result.set(current, block);
        current = block.parent;
      }
      return result;
    }, /* @__PURE__ */ new Map()),
    (0, import_rxjs19.map)((x) => [...x.values()]),
    shareLatest
  );
  const runtime$ = pinnedBlocks$.pipe(
    (0, import_rxjs19.distinctUntilChanged)((a, b) => a.finalizedRuntime === b.finalizedRuntime),
    (0, import_rxjs19.switchMap)(
      ({ finalizedRuntime: { runtime } }) => runtime.pipe(withDefaultValue(null))
    ),
    shareLatest
  );
  const metadata$ = runtime$.pipe((0, import_rxjs19.map)((x) => x?.metadata ?? null));
  const withOptionalHash$ = getWithOptionalhash$(
    finalized$.pipe((0, import_rxjs19.map)((x) => x.hash))
  );
  const _body$ = commonEnhancer(lazyFollower("body"));
  const body$ = (hash) => upsertCachedStream(hash, "body", _body$(hash));
  const trackTx$ = getTrackTx(pinnedBlocks$, body$);
  const _storage$ = commonEnhancer(lazyFollower("storage"));
  const storage$ = withOptionalHash$(
    (hash, type, keyMapper, childTrie = null, mapper) => pinnedBlocks$.pipe(
      (0, import_rxjs19.take)(1),
      (0, import_rxjs19.mergeMap)(
        (pinned) => pinned.runtimes[pinned.blocks.get(hash).runtime].runtime
      ),
      (0, import_rxjs19.mergeMap)((ctx) => {
        const key = keyMapper(ctx);
        const unMapped$ = upsertCachedStream(
          hash,
          `storage-${type}-${key}-${childTrie ?? ""}`,
          _storage$(hash, type, key, childTrie)
        );
        return mapper ? upsertCachedStream(
          hash,
          `storage-${type}-${key}-${childTrie ?? ""}-dec`,
          unMapped$.pipe((0, import_rxjs19.map)((x) => mapper(x, ctx)))
        ) : unMapped$;
      })
    )
  );
  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery);
  const storageQueries$ = withOperationInaccessibleRecovery(
    withOptionalHash$(
      withRefcount(
        (hash, queries, childTrie) => recoveralStorage$(hash, queries, childTrie ?? null, false)
      )
    )
  );
  const header$ = withOptionalHash$(
    withRefcount((hash) => (0, import_rxjs19.from)(getHeader(hash)))
  );
  (0, import_rxjs19.merge)(runtime$, bestBlocks$).subscribe();
  const eventsAt$ = (hash) => storage$(
    hash,
    "value",
    (ctx) => ctx.events.key,
    null,
    (x, ctx) => ctx.events.dec(x)
  );
  return {
    follow$,
    finalized$,
    bestBlocks$,
    runtime$,
    metadata$,
    header$,
    body$,
    call$: withOptionalHash$(withRefcount(_call$)),
    storage$,
    storageQueries$,
    eventsAt$,
    trackTx$,
    withRuntime,
    getRuntimeContext$: withOptionalHash$(getRuntimeContext$),
    unfollow
  };
};

// src/observableClient/tx.ts
var import_rxjs20 = require("rxjs");
var terminalTxEvents = /* @__PURE__ */ new Set(["error", "finalized", "invalid", "dropped"]);
var tx_default = (baseTransaction) => (transaction) => new import_rxjs20.Observable(
  (observer) => baseTransaction(
    transaction,
    (event) => {
      if (event.type === "error")
        return observer.error(new Error(event.error));
      observer.next(event);
      if (terminalTxEvents.has(event.type))
        observer.complete();
    },
    (error) => {
      observer.error(error);
    }
  )
);

// src/observableClient/getObservableClient.ts
var getObservableClient = ({
  chainHead,
  transaction,
  destroy
}) => ({
  chainHead$: () => getChainHead$(chainHead),
  tx$: tx_default(transaction),
  destroy
});

// src/runtime.ts
var import_rxjs21 = require("rxjs");
var import_utils7 = require("@polkadot-api/utils");
var createRuntime = (descriptors, ctx) => {
  const constants = (0, import_utils7.mapObject)(descriptors.pallets, (_, palletName) => {
    const pallet = ctx.metadata.pallets.find((p) => p.name === palletName);
    const palletConstants = {};
    pallet?.constants.forEach((c) => {
      palletConstants[c.name] = { cache: false, value: c.value };
    });
    return new Proxy(
      {},
      {
        get(_2, name) {
          const cached = palletConstants[name];
          if (cached.cache)
            return cached.value;
          cached.cache = true;
          return cached.value = ctx.dynamicBuilder.buildConstant(palletName, name).dec(cached.value);
        }
      }
    );
  });
  const isCompatibleMapper = (idx, builder) => (0, import_utils7.mapObject)(
    descriptors.pallets,
    (x, pallet) => new Proxy(
      {},
      {
        get(_, name) {
          return ctx.checksumBuilder[builder](pallet, name) === x[idx][name];
        }
      }
    )
  );
  const isCompatibleApi = {
    query: isCompatibleMapper(0, "buildStorage"),
    tx: isCompatibleMapper(1, "buildCall"),
    event: isCompatibleMapper(2, "buildEvent"),
    const: isCompatibleMapper(4, "buildConstant")
  };
  const isCompatible = (cb) => cb(isCompatibleApi);
  return {
    constants,
    isCompatible
  };
};
var getRuntimeApi = (descriptors, chainHead) => {
  let latestRuntime;
  let resolve = null;
  latestRuntime = new Promise((res) => {
    resolve = res;
  });
  chainHead.runtime$.subscribe((x) => {
    if (x) {
      resolve(createRuntime(descriptors, x));
      resolve = null;
    } else if (!resolve) {
      latestRuntime = new Promise((res) => {
        resolve = res;
      });
    }
  });
  const result = chainHead.runtime$.pipe(
    (0, import_rxjs21.filter)(Boolean),
    (0, import_rxjs21.map)((x) => createRuntime(descriptors, x))
  );
  result.latest = () => latestRuntime;
  return result;
};

// src/runtime-call.ts
var import_rxjs22 = require("rxjs");
var import_utils9 = require("@polkadot-api/utils");
var isOptionalArg = (lastArg) => {
  if (typeof lastArg !== "object")
    return false;
  return Object.keys(lastArg).every(
    (k) => k === "at" && typeof lastArg.at === "string" || k === "signal" && lastArg.signal instanceof AbortSignal
  );
};
var createRuntimeCallEntry = (checksum, api, method, chainHead) => {
  const callName = `${api}_${method}`;
  const checksumCheck = (ctx) => {
    const actualChecksum = ctx.checksumBuilder.buildRuntimeCall(api, method);
    if (checksum !== actualChecksum)
      throw new Error(`Incompatible runtime entry RuntimeCall(${callName})`);
  };
  return (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = chainHead.getRuntimeContext$(at).pipe(
      (0, import_rxjs22.mergeMap)((ctx) => {
        checksumCheck(ctx);
        const codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method);
        return chainHead.call$(at, callName, (0, import_utils9.toHex)(codecs.args.enc(args))).pipe((0, import_rxjs22.map)(codecs.value.dec));
      })
    );
    return firstValueFromWithSignal(result$, signal);
  };
};

// src/storage.ts
var import_rxjs23 = require("rxjs");
var isOptionalArg2 = (lastArg) => {
  if (typeof lastArg !== "object")
    return false;
  return Object.keys(lastArg).every(
    (k) => k === "at" && typeof lastArg.at === "string" || k === "signal" && lastArg.signal instanceof AbortSignal
  );
};
var createStorageEntry = (checksum, pallet, name, chainHead) => {
  const checksumCheck = (ctx) => {
    const actualChecksum = ctx.checksumBuilder.buildStorage(pallet, name);
    if (checksum !== actualChecksum)
      throw new Error(`Incompatible runtime entry Storage(${pallet}.${name})`);
  };
  const invalidArgs = (args) => new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`);
  const watchValue = (...args) => chainHead.finalized$.pipe(
    (0, import_rxjs23.debounceTime)(0),
    chainHead.withRuntime((x) => x.hash),
    (0, import_rxjs23.exhaustMap)(([block, ctx]) => {
      checksumCheck(ctx);
      const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
      return chainHead.storage$(block.hash, "value", () => codecs.enc(...args)).pipe(
        (0, import_rxjs23.distinctUntilChanged)(),
        (0, import_rxjs23.map)((val) => val === null ? codecs.fallback : codecs.dec(val))
      );
    })
  );
  const getValue = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg2(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = chainHead.storage$(
      at,
      "value",
      (ctx) => {
        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
        const actualArgs = args.length === codecs.len ? args : args.slice(0, -1);
        if (args !== actualArgs && !isLastArgOptional)
          throw invalidArgs(args);
        checksumCheck(ctx);
        return codecs.enc(...actualArgs);
      },
      null,
      (data, ctx) => {
        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
        return data === null ? codecs.fallback : codecs.dec(data);
      }
    );
    return firstValueFromWithSignal(result$, signal);
  };
  const getEntries = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg2(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = chainHead.storage$(
      at,
      "descendantsValues",
      (ctx) => {
        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
        if (args.length > codecs.len)
          throw invalidArgs(args);
        const actualArgs = args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args;
        if (args.length === codecs.len && actualArgs === args)
          throw invalidArgs(args);
        checksumCheck(ctx);
        return codecs.enc(...actualArgs);
      },
      null,
      (values, ctx) => {
        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
        return values.map(({ key, value }) => ({
          keyArgs: codecs.keyDecoder(key),
          value: codecs.dec(value)
        }));
      }
    );
    return firstValueFromWithSignal(result$, signal);
  };
  const getValues = (keyArgs, options) => Promise.all(
    keyArgs.map((args) => getValue(...options ? [...args, options] : args))
  );
  return { getValue, getValues, getEntries, watchValue };
};

// src/tx.ts
var import_substrate_bindings3 = require("@polkadot-api/substrate-bindings");
var import_rxjs24 = require("rxjs");
var import_utils11 = require("@polkadot-api/utils");
var getTxSuccessFromSystemEvents = (systemEvents, txIdx) => {
  const events = systemEvents.filter((x) => x.phase.type === "ApplyExtrinsic" && x.phase.value === txIdx).map((x) => x.event);
  const lastEvent = events[events.length - 1];
  const ok = lastEvent.type === "System" && lastEvent.value.type === "ExtrinsicSuccess";
  return { ok, events };
};
var createTxEntry = (descriptor, pallet, name, assetChecksum, chainHead, client, signer) => (arg) => {
  const tx$ = (tx) => (0, import_rxjs24.concat)(
    client.tx$(tx).pipe((0, import_rxjs24.takeWhile)((x) => x.type !== "broadcasted", true)),
    chainHead.trackTx$(tx)
  );
  const getCallData$ = (arg2, hinted = {}) => chainHead.getRuntimeContext$(null).pipe(
    (0, import_rxjs24.map)(
      ({
        checksumBuilder,
        dynamicBuilder,
        asset: [assetEnc, assetCheck]
      }) => {
        const checksum = checksumBuilder.buildCall(pallet, name);
        if (checksum !== descriptor)
          throw new Error(
            `Incompatible runtime entry Tx(${pallet}.${name})`
          );
        let returnHinted = hinted;
        if (hinted.asset) {
          if (assetChecksum !== assetCheck)
            throw new Error(`Incompatible runtime asset`);
          returnHinted = { ...hinted, asset: assetEnc(hinted.asset) };
        }
        const { location, args } = dynamicBuilder.buildCall(pallet, name);
        return {
          callData: import_substrate_bindings3.Binary.fromBytes(
            (0, import_utils11.mergeUint8)(new Uint8Array(location), args.enc(arg2))
          ),
          hinted: returnHinted
        };
      }
    )
  );
  const getEncodedData = () => (0, import_rxjs24.firstValueFrom)(getCallData$(arg).pipe((0, import_rxjs24.map)((x) => x.callData)));
  const getTx = (from2, _hinted) => (0, import_rxjs24.firstValueFrom)(
    getCallData$(arg, _hinted).pipe(
      (0, import_rxjs24.mergeMap)(
        ({ callData, hinted }) => signer(from2, callData.asBytes(), hinted)
      ),
      (0, import_rxjs24.map)(import_utils11.toHex)
    )
  );
  const submit = async (from2, _hinted) => {
    const tx = await (0, import_rxjs24.firstValueFrom)(
      getCallData$(arg, _hinted).pipe(
        (0, import_rxjs24.mergeMap)(
          ({ callData, hinted }) => signer(from2, callData.asBytes(), hinted).then(import_utils11.toHex)
        )
      )
    );
    const result = await (0, import_rxjs24.lastValueFrom)(tx$(tx));
    switch (result.type) {
      case "invalid":
        throw new Error("Invalid");
      case "dropped":
        throw new Error("Dropped");
      case "finalized": {
        const systemEvents = await (0, import_rxjs24.firstValueFrom)(
          chainHead.eventsAt$(result.block.hash)
        );
        return getTxSuccessFromSystemEvents(
          systemEvents,
          Number(result.block.index)
        );
      }
      default:
        return { ok: true, events: [] };
    }
  };
  const submit$ = (from2, _hinted) => getCallData$(arg, _hinted).pipe(
    (0, import_rxjs24.mergeMap)(
      ({ callData, hinted }) => signer(from2, callData.asBytes(), hinted)
    ),
    (0, import_rxjs24.take)(1),
    (0, import_rxjs24.mergeMap)((result) => {
      return tx$((0, import_utils11.toHex)(result)).pipe(
        (0, import_rxjs24.mergeMap)((result2) => {
          switch (result2.type) {
            case "invalid":
              throw new Error("Invalid");
            case "dropped":
              throw new Error("Dropped");
            case "finalized": {
              return chainHead.eventsAt$(result2.block.hash).pipe(
                (0, import_rxjs24.map)((events) => ({
                  ...result2,
                  ...getTxSuccessFromSystemEvents(
                    events,
                    Number(result2.block.index)
                  )
                }))
              );
            }
            default:
              return (0, import_rxjs24.of)(result2);
          }
        })
      );
    })
  );
  return {
    callData: (0, import_substrate_bindings3.Enum)(pallet, (0, import_substrate_bindings3.Enum)(name, arg)),
    getEncodedData,
    getTx,
    submit,
    submit$
  };
};

// src/client.ts
var createTypedApi = (descriptors, createTxFromAddress, chainHead, client) => {
  const { pallets, apis: runtimeApis } = descriptors;
  const query = {};
  for (const pallet in pallets) {
    query[pallet] || (query[pallet] = {});
    const [stgEntries] = pallets[pallet];
    for (const name in stgEntries) {
      query[pallet][name] = createStorageEntry(
        stgEntries[name],
        pallet,
        name,
        chainHead
      );
    }
  }
  const tx = {};
  for (const pallet in pallets) {
    tx[pallet] || (tx[pallet] = {});
    const [, txEntries] = pallets[pallet];
    for (const name in txEntries) {
      tx[pallet][name] = createTxEntry(
        txEntries[name],
        pallet,
        name,
        descriptors.asset,
        chainHead,
        client,
        createTxFromAddress
      );
    }
  }
  const events = {};
  for (const pallet in pallets) {
    events[pallet] || (events[pallet] = {});
    const [, , evEntries] = pallets[pallet];
    for (const name in evEntries) {
      events[pallet][name] = createEventEntry(
        evEntries[name],
        pallet,
        name,
        chainHead
      );
    }
  }
  const apis = {};
  for (const api in runtimeApis) {
    apis[api] || (apis[api] = {});
    const methods = runtimeApis[api];
    for (const method in methods) {
      apis[api][method] = createRuntimeCallEntry(
        methods[method],
        api,
        method,
        chainHead
      );
    }
  }
  return {
    query,
    tx,
    event: events,
    apis,
    runtime: getRuntimeApi(descriptors, chainHead)
  };
};
var createClient = (connect) => {
  let createTx;
  const rawClient = (0, import_substrate_client4.createClient)((onMsg) => {
    const result = connect(onMsg);
    createTx = result.createTx;
    return result;
  });
  const client = getObservableClient(rawClient);
  const chainHead = client.chainHead$();
  const createTxFromAddress = async (address, callData, hinted) => {
    let publicKey;
    if (address instanceof Uint8Array)
      publicKey = address;
    else {
      const { accountId } = await (0, import_rxjs25.firstValueFrom)(
        chainHead.getRuntimeContext$(null)
      );
      publicKey = accountId.enc(address);
    }
    return createTx(publicKey, callData, hinted);
  };
  return {
    finalized$: chainHead.finalized$,
    bestBlocks$: chainHead.bestBlocks$,
    getBlockHeader: (hash) => (0, import_rxjs25.firstValueFrom)(chainHead.header$(hash ?? null)),
    getBlockBody: chainHead.body$,
    destroy: () => {
      chainHead.unfollow();
      client.destroy();
    },
    getTypedApi: (descriptors) => createTypedApi(descriptors, createTxFromAddress, chainHead, client)
  };
};

// src/re-exports.ts
var import_substrate_bindings4 = require("@polkadot-api/substrate-bindings");
//# sourceMappingURL=index.js.map