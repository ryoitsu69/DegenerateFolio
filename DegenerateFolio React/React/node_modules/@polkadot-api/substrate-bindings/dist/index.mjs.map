{"version":3,"sources":["../src/codecs/scale/AccountId.ts","../src/codecs/scale/Binary.ts","../src/codecs/scale/bitSequence.ts","../src/codecs/scale/compact.ts","../src/codecs/scale/char.ts","../src/codecs/scale/Hex.ts","../src/codecs/scale/fixed-str.ts","../src/codecs/scale/re-exported.ts","../src/codecs/scale/Self.ts","../src/codecs/scale/Variant.ts","../src/codecs/blockHeader.ts","../src/codecs/metadata/v15/v15.ts","../src/codecs/metadata/v15/lookup.ts","../src/codecs/metadata/v15/pallets.ts","../src/codecs/metadata/metadata.ts","../src/hashes/blake2.ts","../src/hashes/identity.ts","../src/hashes/twoX.ts","../src/hashes/h64.ts","../src/storage.ts"],"sourcesContent":["import { Bytes, enhanceCodec } from \"scale-ts\"\nimport { blake2b } from \"@noble/hashes/blake2b\"\nimport { base58 } from \"@scure/base\"\n\nconst SS58_PREFIX = new TextEncoder().encode(\"SS58PRE\")\n\nconst CHECKSUM_LENGTH = 2\n\nexport type SS58String = string & { __SS58String?: unknown }\n\nconst fromBufferToBase58 = (ss58Format: number) => {\n  const prefixBytes =\n    ss58Format < 64\n      ? Uint8Array.of(ss58Format)\n      : Uint8Array.of(\n          ((ss58Format & 0b0000_0000_1111_1100) >> 2) | 0b0100_0000,\n          (ss58Format >> 8) | ((ss58Format & 0b0000_0000_0000_0011) << 6),\n        )\n  return (publicKey: Uint8Array): SS58String => {\n    const checksum = blake2b(\n      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),\n      {\n        dkLen: 64,\n      },\n    ).subarray(0, CHECKSUM_LENGTH)\n    return base58.encode(\n      Uint8Array.of(...prefixBytes, ...publicKey, ...checksum),\n    )\n  }\n}\n\nfunction fromBase58ToBuffer(nBytes: number, ss58Format: number) {\n  return (address: SS58String) => {\n    const decoded = base58.decode(address)\n    const prefixBytes = decoded.subarray(0, decoded[0] & 0b0100_0000 ? 2 : 1)\n    const publicKey = decoded.subarray(\n      prefixBytes.length,\n      decoded.length - CHECKSUM_LENGTH,\n    )\n    if (publicKey.length !== nBytes)\n      throw new Error(\"Invalid public key length\")\n    const checksum = decoded.subarray(prefixBytes.length + publicKey.length)\n    const expectedChecksum = blake2b(\n      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),\n      {\n        dkLen: 64,\n      },\n    ).subarray(0, CHECKSUM_LENGTH)\n    if (\n      checksum[0] !== expectedChecksum[0] ||\n      checksum[1] !== expectedChecksum[1]\n    )\n      throw new Error(\"Invalid checksum\")\n\n    if (prefixBytesToNumber(prefixBytes) != ss58Format)\n      throw new Error(\"Invalid SS58 prefix\")\n\n    return publicKey.slice()\n  }\n}\n\nexport const AccountId = (ss58Format: number = 42, nBytes: 32 | 33 = 32) =>\n  enhanceCodec(\n    Bytes(nBytes),\n    fromBase58ToBuffer(nBytes, ss58Format),\n    fromBufferToBase58(ss58Format),\n  )\n\nconst prefixBytesToNumber = (bytes: Uint8Array) => {\n  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  return dv.byteLength === 1 ? dv.getUint8(0) : dv.getUint16(0)\n}\n","import { Bytes, Codec, Decoder, Encoder, createCodec } from \"scale-ts\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\nimport { HexString } from \"./Hex\"\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport class Binary {\n  #bytes: Uint8Array\n  #hex: HexString | null = null\n  #str: string | null = null\n\n  constructor(data: Uint8Array) {\n    this.#bytes = data\n  }\n\n  asText = () =>\n    this.#str === null\n      ? (this.#str = textDecoder.decode(this.#bytes))\n      : this.#str\n\n  asHex = () =>\n    this.#hex === null ? (this.#hex = toHex(this.#bytes)) : this.#hex\n\n  asBytes = () => this.#bytes\n\n  static fromText(input: string): Binary {\n    return new Binary(textEncoder.encode(input))\n  }\n  static fromHex(input: HexString): Binary {\n    return new Binary(fromHex(input))\n  }\n  static fromBytes(input: Uint8Array): Binary {\n    return new Binary(input)\n  }\n}\n\nconst enc = (nBytes?: number): Encoder<Binary> => {\n  const _enc = Bytes.enc(nBytes)\n  return (value) => _enc(value.asBytes())\n}\n\nconst dec = (nBytes?: number): Decoder<Binary> => {\n  const _dec = Bytes.dec(nBytes)\n  return (value) => Binary.fromBytes(_dec(value))\n}\n\nexport const Bin = (nBytes?: number): Codec<Binary> =>\n  createCodec(enc(nBytes), dec(nBytes))\n\nBin.enc = enc\nBin.dec = dec\n","import { Bytes, Decoder, Encoder, createCodec, createDecoder } from \"scale-ts\"\nimport { compactNumber } from \"./compact\"\n\nexport interface BitSequence {\n  bitsLen: number\n  bytes: Uint8Array\n}\n\nconst bitSequenceDecoder: Decoder<BitSequence> = createDecoder((data) => {\n  const bitsLen = compactNumber.dec(data)\n  const bytesLen = Math.ceil(bitsLen / 8)\n  const bytes = Bytes(bytesLen).dec(data)\n  return { bytes, bitsLen }\n})\n\nconst bitSequenceEncoder: Encoder<BitSequence> = (input) => {\n  if (input.bitsLen > input.bytes.length * 8)\n    throw new Error(\n      `Not enough bytes. (bitsLen:${input.bitsLen}, bytesLen:${input.bytes.length})`,\n    )\n\n  const lenEncoded = compactNumber.enc(input.bitsLen)\n  const result = new Uint8Array(input.bytes.length + lenEncoded.length)\n  result.set(lenEncoded, 0)\n  result.set(input.bytes, lenEncoded.length)\n  return result\n}\n\nexport const bitSequence = createCodec(bitSequenceEncoder, bitSequenceDecoder)\n","import { Codec, compact } from \"scale-ts\"\n\nexport const compactNumber = compact as Codec<number>\nexport const compactBn = compact as Codec<bigint>\n","import { enhanceCodec, u8 } from \"scale-ts\"\n\nexport const char = enhanceCodec(\n  u8,\n  (str: string) => str.charCodeAt(0),\n  String.fromCharCode,\n)\n","import { fromHex, toHex } from \"@polkadot-api/utils\"\nimport { Bytes, Codec, Decoder, Encoder, createCodec } from \"scale-ts\"\n\nexport type HexString = string & { __hexString?: unknown }\n\nconst enc = (nBytes?: number): Encoder<HexString> => {\n  const _enc = Bytes.enc(nBytes)\n  return (value: string) => _enc(fromHex(value))\n}\n\nconst dec = (nBytes?: number): Decoder<HexString> => {\n  const _dec = Bytes.dec(nBytes)\n  return (value) => toHex(_dec(value)) as HexString\n}\n\nexport const Hex = (nBytes?: number): Codec<HexString> =>\n  createCodec(enc(nBytes), dec(nBytes))\n\nHex.enc = enc\nHex.dec = dec\n","import { Bytes, enhanceCodec } from \"scale-ts\"\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const fixedStr = (nBytes: number) =>\n  enhanceCodec(\n    Bytes(nBytes),\n    (str: string) => textEncoder.encode(str),\n    (bytes) => textDecoder.decode(bytes),\n  )\n","export {\n  _void,\n  bool,\n  compact,\n  str,\n  u8,\n  u16,\n  u32,\n  u64,\n  u128,\n  u256,\n  i8,\n  i16,\n  i32,\n  i64,\n  i128,\n  i256,\n  Option,\n  Result,\n  Vector,\n  Tuple,\n  Struct,\n  Bytes,\n  enhanceCodec,\n  enhanceEncoder,\n  enhanceDecoder,\n  createCodec,\n  createDecoder,\n} from \"scale-ts\"\n\nexport type {\n  Encoder,\n  Decoder,\n  Codec,\n  CodecType,\n  EncoderType,\n  DecoderType,\n  StringRecord,\n  ResultPayload,\n} from \"scale-ts\"\n","import { Codec, Decoder, Encoder, createCodec, _void } from \"scale-ts\"\n\nexport const selfEncoder = <T>(value: () => Encoder<T>): Encoder<T> => {\n  let cache: Encoder<T> = (x) => {\n    const encoder = value()\n    cache = encoder\n    return encoder(x)\n  }\n\n  return (x) => cache(x)\n}\n\nexport const selfDecoder = <T>(value: () => Decoder<T>): Decoder<T> => {\n  let cache: Decoder<T> = (x) => {\n    const decoder = value()\n    const result = decoder\n    cache = decoder\n    return result(x)\n  }\n\n  return (x) => cache(x)\n}\n\nexport const Self = <T>(value: () => Codec<T>): Codec<T> =>\n  createCodec(\n    selfEncoder(() => value().enc),\n    selfDecoder(() => value().dec),\n  )\n","import {\n  Codec,\n  CodecType,\n  Decoder,\n  DecoderType,\n  Encoder,\n  EncoderType,\n  Enum as ScaleEnum,\n  StringRecord,\n  createCodec,\n} from \"scale-ts\"\nimport { Binary } from \"./Binary\"\nimport { mapObject } from \"@polkadot-api/utils\"\n\ntype Tuple<T, N extends number> = readonly [T, ...T[]] & { length: N }\n\ntype Push<T extends any[], V> = [...T, V]\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never\n\ntype LastOf<T> = UnionToIntersection<\n  T extends any ? () => T : never\n> extends () => infer R\n  ? R\n  : never\n\ntype TuplifyUnion<\n  T,\n  L = LastOf<T>,\n  N = [T] extends [never] ? true : false,\n> = true extends N ? [] : Push<TuplifyUnion<Exclude<T, L>>, L>\n\ntype RestrictedLenTuple<T, O extends StringRecord<any>> = Tuple<\n  T,\n  TuplifyUnion<keyof O> extends Tuple<any, infer V> ? V : 0\n>\n\ntype ExtractValue<\n  T extends { type: string; value?: any },\n  K extends string,\n> = T extends { type: K; value: infer R } ? R : never\n\nexport interface Discriminant<T extends { type: string; value?: any }> {\n  is<K extends T[\"type\"]>(\n    this: Enum<T>,\n    type: K,\n  ): this is Enum<{ type: K; value: ExtractValue<T, K> }>\n  as<K extends T[\"type\"]>(type: K): ExtractValue<T, K>\n}\n\nexport type Enum<T extends { type: string; value?: any }> = T & Discriminant<T>\n\ntype MyTuple<T> = [T, ...T[]]\n\ntype List<T> = Array<T>\n\ntype SeparateUndefined<T> = undefined extends T\n  ? undefined | Exclude<T, undefined>\n  : T\n\nexport type Anonymize<T> = SeparateUndefined<\n  T extends\n    | string\n    | number\n    | bigint\n    | boolean\n    | void\n    | undefined\n    | null\n    | symbol\n    | Binary\n    | Enum<{ type: string; value: any }>\n    | Uint8Array\n    ? T\n    : T extends (...args: infer Args) => infer R\n      ? (\n          ...args: {\n            [K in keyof Args]: Anonymize<Args[K]>\n          }\n        ) => Anonymize<R>\n      : T extends MyTuple<any>\n        ? {\n            [K in keyof T]: Anonymize<T[K]>\n          }\n        : T extends []\n          ? []\n          : T extends Array<infer A>\n            ? List<Anonymize<A>>\n            : {\n                [K in keyof T]: Anonymize<T[K]>\n              }\n>\n\nexport const _Enum = new Proxy(\n  {},\n  {\n    get(_, prop: string) {\n      return (value: string) =>\n        Enum<{ type: string; value: any }, string>(prop, value)\n    },\n  },\n)\n\nexport type EnumOption<\n  T extends { type: string; value?: any },\n  Key extends T[\"type\"],\n> = Anonymize<ExtractValue<T, Key>>\n\nexport type GetEnum<T extends Enum<{ type: string; value: any }>> = {\n  [K in T[\"type\"]]: (\n    ...args: ExtractValue<T, K> extends undefined\n      ? []\n      : [value: Anonymize<ExtractValue<T, K>>]\n  ) => T\n}\n\nexport const Enum: <\n  T extends { type: string; value?: any },\n  Key extends T[\"type\"],\n>(\n  type: Key,\n  ...args: ExtractValue<T, Key> extends undefined\n    ? []\n    : [value: Anonymize<ExtractValue<T, Key>>]\n) => Enum<\n  ExtractValue<T, Key> extends undefined\n    ? T\n    : ExtractValue<T, Key> extends never\n      ? T\n      : {\n          type: Key\n          value: ExtractValue<T, Key>\n        }\n> = ((_type: string, _value: any) => ({\n  as: (type: string) => {\n    if (type !== _type)\n      // TODO: fix error\n      throw new Error(`Enum.as(${type}) used with actual type ${_type}`)\n    return _value\n  },\n  is: (type: string) => type === _type,\n  type: _type,\n  value: _value,\n})) as any\n\nconst VariantEnc = <O extends StringRecord<Encoder<any>>>(\n  ...args: [inner: O, x?: RestrictedLenTuple<number, O>]\n): Encoder<\n  Enum<\n    {\n      [K in keyof O]: K extends string\n        ? { type: K; value: EncoderType<O[K]> }\n        : never\n    }[keyof O]\n  >\n> => {\n  const enc = ScaleEnum.enc<O>(...(args as [any, any]))\n  return (v) => enc({ tag: v.type, value: v.value })\n}\n\nconst VariantDec = <O extends StringRecord<Decoder<any>>>(\n  ...args: [inner: O, x?: RestrictedLenTuple<number, O>]\n): Decoder<\n  Enum<\n    {\n      [K in keyof O]: K extends string\n        ? { type: K; value: DecoderType<O[K]> }\n        : never\n    }[keyof O]\n  >\n> => {\n  const dec = ScaleEnum.dec<O>(...(args as [any, any]))\n  return (v) => {\n    const { tag, value } = dec(v)\n    return Enum(tag as any, value as any) as any\n  }\n}\n\nexport const Variant = <O extends StringRecord<Codec<any>>>(\n  inner: O,\n  ...args: [indexes?: RestrictedLenTuple<number, O>]\n): Codec<\n  Enum<\n    {\n      [K in keyof O]: K extends string\n        ? { type: K; value: CodecType<O[K]> }\n        : never\n    }[keyof O]\n  >\n> =>\n  createCodec(\n    VariantEnc(\n      mapObject(inner, ([encoder]) => encoder) as StringRecord<\n        O[keyof O][\"enc\"]\n      >,\n      ...(args as any[]),\n    ) as Encoder<\n      Enum<\n        {\n          [K in keyof O]: K extends string\n            ? { type: K; value: CodecType<O[K]> }\n            : never\n        }[keyof O]\n      >\n    >,\n    VariantDec(\n      mapObject(inner, ([, decoder]) => decoder) as StringRecord<\n        O[keyof O][\"dec\"]\n      >,\n      ...(args as any[]),\n    ) as Decoder<\n      Enum<\n        {\n          [K in keyof O]: K extends string\n            ? { type: K; value: CodecType<O[K]> }\n            : never\n        }[keyof O]\n      >\n    >,\n  )\n\nVariant.enc = VariantEnc\nVariant.dec = VariantDec\n","import {\n  Bytes,\n  CodecType,\n  Struct,\n  Vector,\n  _void,\n  enhanceCodec,\n  Hex,\n  Variant,\n  compactNumber,\n} from \"./scale\"\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nconst fourChars = enhanceCodec(\n  Bytes(4),\n  textEncoder.encode.bind(textEncoder),\n  textDecoder.decode.bind(textDecoder),\n)\n\nconst diggestVal = Struct({\n  engine: fourChars,\n  payload: Hex(),\n})\n\nconst diggest = Variant(\n  {\n    consensus: diggestVal,\n    seal: diggestVal,\n    preRuntime: diggestVal,\n    runtimeUpdated: _void,\n  },\n  [4, 5, 6, 8],\n)\n\nconst hex32 = Hex(32)\nexport const blockHeader = Struct({\n  parentHash: hex32,\n  number: compactNumber,\n  stateRoot: hex32,\n  extrinsicRoot: hex32,\n  digests: Vector(diggest),\n})\n\nexport type BlockHeader = CodecType<typeof blockHeader>\n","import { CodecType, Struct, Tuple, Vector, str, u8 } from \"scale-ts\"\nimport { lookup } from \"./lookup\"\nimport { pallets } from \"./pallets\"\nimport { Hex, compactNumber as ty } from \"../../scale\"\nexport type { V14Lookup } from \"./lookup\"\n\nconst docs = Vector(str)\n\nconst runtimeApi = Struct({\n  name: str,\n  methods: Vector(\n    Struct({\n      name: str,\n      inputs: Vector(\n        Struct({\n          name: str,\n          type: ty,\n        }),\n      ),\n      output: ty,\n      docs,\n    }),\n  ),\n  docs,\n})\n\nconst extrinsic = Struct({\n  version: u8,\n  address: ty,\n  call: ty,\n  signature: ty,\n  extra: ty,\n  signedExtensions: Vector(\n    Struct({\n      identifier: str,\n      type: ty,\n      additionalSigned: ty,\n    }),\n  ),\n})\nexport type V15Extrinsic = CodecType<typeof extrinsic>\n\nexport const v15 = Struct({\n  lookup,\n  pallets,\n  extrinsic,\n  type: ty,\n  apis: Vector(runtimeApi),\n  outerEnums: Struct({\n    call: ty,\n    event: ty,\n    error: ty,\n  }),\n  custom: Vector(Tuple(str, Struct({ type: ty, value: Hex() }))),\n})\nexport type V15 = CodecType<typeof v15>\n","import { compactNumber } from \"../../scale/compact\"\nimport {\n  CodecType,\n  Enum,\n  Option,\n  Struct,\n  Vector,\n  _void,\n  str,\n  u32,\n  u8,\n} from \"scale-ts\"\n\nconst oStr = Option(str)\nconst strs = Vector(str)\n\nconst primitive = Enum({\n  bool: _void,\n  char: _void,\n  str: _void,\n  u8: _void,\n  u16: _void,\n  u32: _void,\n  u64: _void,\n  u128: _void,\n  u256: _void,\n  i8: _void,\n  i16: _void,\n  i32: _void,\n  i64: _void,\n  i128: _void,\n  i256: _void,\n})\n\nconst fields = Vector(\n  Struct({\n    name: oStr,\n    type: compactNumber,\n    typeName: oStr,\n    docs: strs,\n  }),\n)\n\nconst arr = Struct({\n  len: u32,\n  type: compactNumber,\n})\n\nconst bitSequence = Struct({\n  bitStoreType: compactNumber,\n  bitOrderType: compactNumber,\n})\n\nconst variant = Vector(\n  Struct({\n    name: str,\n    fields,\n    index: u8,\n    docs: strs,\n  }),\n)\n\nconst def = Enum({\n  composite: fields,\n  variant,\n  sequence: compactNumber,\n  array: arr,\n  tuple: Vector(compactNumber),\n  primitive,\n  compact: compactNumber,\n  bitSequence,\n})\n\nconst param = Struct({\n  name: str,\n  type: Option(compactNumber),\n})\nconst params = Vector(param)\n\nconst entry = Struct({\n  id: compactNumber,\n  path: strs,\n  params,\n  def,\n  docs: strs,\n})\n\nexport const lookup = Vector(entry)\nexport type V14Lookup = CodecType<typeof lookup>\n","import { Hex, compactNumber } from \"@/codecs/scale\"\nimport {\n  Struct,\n  Option,\n  Vector,\n  u8,\n  str,\n  Enum,\n  _void,\n  CodecType,\n} from \"scale-ts\"\n\nconst hashType = Enum({\n  Blake2128: _void,\n  Blake2256: _void,\n  Blake2128Concat: _void,\n  Twox128: _void,\n  Twox256: _void,\n  Twox64Concat: _void,\n  Identity: _void,\n})\n\nconst hashers = Vector(hashType)\n\nconst storageMap = Struct({\n  hashers,\n  key: compactNumber,\n  value: compactNumber,\n})\n\nconst storageItem = Struct({\n  name: str,\n  modifier: u8,\n  type: Enum({\n    plain: compactNumber,\n    map: storageMap,\n  }),\n  fallback: Hex(),\n  docs: Vector(str),\n})\n\nconst storage = Option(\n  Struct({\n    prefix: str,\n    items: Vector(storageItem),\n  }),\n)\n\nexport const pallets = Vector(\n  Struct({\n    name: str,\n    storage,\n    calls: Option(compactNumber),\n    events: Option(compactNumber),\n    constants: Vector(\n      Struct({\n        name: str,\n        type: compactNumber,\n        value: Hex(),\n        docs: Vector(str),\n      }),\n    ),\n    errors: Option(compactNumber),\n    index: u8,\n    docs: Vector(str),\n  }),\n)\n\nexport type V15Pallets = CodecType<typeof pallets>\n","import { Enum, Struct, u32, Codec, createCodec } from \"scale-ts\"\nimport { v15 } from \"./v15\"\n\nconst unsupportedFn = () => {\n  throw new Error(\"Unsupported metadata version!\")\n}\n\nconst unsupported = createCodec(\n  unsupportedFn,\n  unsupportedFn,\n) as unknown as Codec<unknown>\n\nexport const metadata = Struct({\n  magicNumber: u32,\n  metadata: Enum({\n    v0: unsupported,\n    v1: unsupported,\n    v2: unsupported,\n    v3: unsupported,\n    v4: unsupported,\n    v5: unsupported,\n    v6: unsupported,\n    v7: unsupported,\n    v8: unsupported,\n    v9: unsupported,\n    v10: unsupported,\n    v11: unsupported,\n    v12: unsupported,\n    v13: unsupported,\n    v14: unsupported,\n    v15,\n  }),\n})\n","import { mergeUint8 } from \"@polkadot-api/utils\"\nimport { blake2b } from \"@noble/hashes/blake2b\"\n\nconst len32 = { dkLen: 32 }\nexport const Blake2256 = (encoded: Uint8Array) => blake2b(encoded, len32)\n\nconst len16 = { dkLen: 16 }\nexport const Blake2128 = (encoded: Uint8Array) => blake2b(encoded, len16)\n\nexport const Blake2128Concat = (encoded: Uint8Array) =>\n  mergeUint8(Blake2128(encoded), encoded)\n","export const Identity = (encoded: Uint8Array): Uint8Array => encoded\n","import { mergeUint8 } from \"@polkadot-api/utils\"\nimport { u64 } from \"scale-ts\"\nimport { h64 } from \"./h64\"\n\nexport const Twox128 = (input: Uint8Array): Uint8Array => {\n  const result = new Uint8Array(16)\n  const dv = new DataView(result.buffer)\n\n  dv.setBigUint64(0, h64(input), true)\n  dv.setBigUint64(8, h64(input, 1n), true)\n\n  return result\n}\n\nexport const Twox256 = (input: Uint8Array): Uint8Array => {\n  const result = new Uint8Array(32)\n  const dv = new DataView(result.buffer)\n\n  dv.setBigUint64(0, h64(input), true)\n  dv.setBigUint64(8, h64(input, 1n), true)\n  dv.setBigUint64(16, h64(input, 2n), true)\n  dv.setBigUint64(24, h64(input, 3n), true)\n\n  return result\n}\n\nexport const Twox64Concat = (encoded: Uint8Array): Uint8Array =>\n  mergeUint8(u64.enc(h64(encoded)), encoded)\n","// Adapted implementation based on: https://github.com/pierrec/js-xxhash/blob/7ff5ced282f97dba121109d7013e0fa80360398c/lib/xxhash64.js\n\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n\n// helper functions\nconst bigintFromU16 = (\n  v0: number,\n  v1: number,\n  v2: number,\n  v3: number,\n): bigint =>\n  new DataView(new Uint16Array([v0, v1, v2, v3]).buffer).getBigUint64(0, true)\n\nconst MASK_64 = 2n ** 64n - 1n\n\nconst rotl = (input: bigint, nBits: bigint) =>\n  ((input << nBits) & MASK_64) | (input >> (64n - nBits))\n\nconst multiply = (a: bigint, b: bigint) => (a * b) & MASK_64\n\nconst add = (a: bigint, b: bigint) => (a + b) & MASK_64\n\n// constants\nconst PRIME64_1 = 11400714785074694791n\nconst PRIME64_2 = 14029467366897019727n\nconst PRIME64_3 = 1609587929392839161n\nconst PRIME64_4 = 9650029242287828579n\nconst PRIME64_5 = 2870177450012600261n\n\nexport function h64(input: Uint8Array, seed: bigint = 0n) {\n  let v1 = add(add(seed, PRIME64_1), PRIME64_2)\n  let v2 = add(seed, PRIME64_2)\n  let v3 = seed\n  let v4 = seed - PRIME64_1\n  let totalLen = input.length\n  let memsize = 0\n  let memory: Uint8Array | null = null\n\n  ;(function update() {\n    let p = 0\n    let bEnd = p + totalLen\n\n    if (!totalLen) return\n\n    memory = new Uint8Array(32)\n\n    if (totalLen < 32) {\n      memory.set(input.subarray(0, totalLen), memsize)\n\n      memsize += totalLen\n      return\n    }\n\n    if (p <= bEnd - 32) {\n      const limit = bEnd - 32\n\n      do {\n        let other\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n        v1 = multiply(rotl(add(v1, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n\n        v2 = multiply(rotl(add(v2, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n\n        v3 = multiply(rotl(add(v3, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n        v4 = multiply(rotl(add(v4, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n      } while (p <= limit)\n    }\n\n    if (p < bEnd) {\n      memory.set(input.subarray(p, bEnd), memsize)\n      memsize = bEnd - p\n    }\n  })()\n\n  input = memory || input\n\n  let result: bigint\n  let p = 0\n\n  if (totalLen >= 32) {\n    result = rotl(v1, 1n)\n    result = add(result, rotl(v2, 7n))\n    result = add(result, rotl(v3, 12n))\n    result = add(result, rotl(v4, 18n))\n\n    v1 = multiply(rotl(multiply(v1, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v1\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n\n    v2 = multiply(rotl(multiply(v2, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v2\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n\n    v3 = multiply(rotl(multiply(v3, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v3\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n\n    v4 = multiply(rotl(multiply(v4, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v4\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n  } else {\n    result = add(seed, PRIME64_5)\n  }\n\n  result = add(result, BigInt(totalLen))\n\n  while (p <= memsize - 8) {\n    let temp = bigintFromU16(\n      (input[p + 1] << 8) | input[p],\n      (input[p + 3] << 8) | input[p + 2],\n      (input[p + 5] << 8) | input[p + 4],\n      (input[p + 7] << 8) | input[p + 6],\n    )\n    temp = multiply(rotl(multiply(temp, PRIME64_2), 31n), PRIME64_1)\n    result = add(multiply(rotl(result ^ temp, 27n), PRIME64_1), PRIME64_4)\n    p += 8\n  }\n\n  if (p + 4 <= memsize) {\n    let temp = multiply(\n      bigintFromU16(\n        (input[p + 1] << 8) | input[p],\n        (input[p + 3] << 8) | input[p + 2],\n        0,\n        0,\n      ),\n      PRIME64_1,\n    )\n\n    result = add(multiply(rotl(result ^ temp, 23n), PRIME64_2), PRIME64_3)\n    p += 4\n  }\n\n  while (p < memsize) {\n    const temp = multiply(bigintFromU16(input[p++], 0, 0, 0), PRIME64_5)\n    result = multiply(rotl(result ^ temp, 11n), PRIME64_1)\n  }\n\n  let temp = result >> 33n\n  result = multiply(result ^ temp, PRIME64_2)\n\n  temp = result >> 29n\n  result = multiply(result ^ temp, PRIME64_3)\n\n  temp = result >> 32n\n  result ^= temp\n\n  return result\n}\n","import { mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport { Codec, Decoder } from \"scale-ts\"\nimport { Blake2128Concat, Identity, Twox128, Twox64Concat } from \"./hashes\"\n\nexport type EncoderWithHash<T> = [Codec<T>, (input: Uint8Array) => Uint8Array]\n\nconst textEncoder = new TextEncoder()\n\nexport const Storage = (pallet: string) => {\n  const palledEncoded = Twox128(textEncoder.encode(pallet))\n  return <T, A extends Array<EncoderWithHash<any>>>(\n    name: string,\n    dec: Decoder<T>,\n    ...encoders: [...A]\n  ): {\n    enc: (\n      ...args: {\n        [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n      }\n    ) => string\n    dec: Decoder<T>\n    keyDecoder: (value: string) => {\n      [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n    }\n  } => {\n    const palletItemEncoded = mergeUint8(\n      palledEncoded,\n      Twox128(textEncoder.encode(name)),\n    )\n\n    const palletItemEncodedHex = toHex(palletItemEncoded)\n    const bytesToSkip = encoders\n      .map((e) => e[1])\n      .map((x) => {\n        if (x === Identity) return 0\n        if (x === Twox64Concat) return 8\n        if (x === Blake2128Concat) return 16\n        return null\n      })\n      .filter(Boolean) as Array<number>\n\n    const keyDecoder = (\n      key: string,\n    ): {\n      [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n    } => {\n      if (!key.startsWith(palletItemEncodedHex))\n        throw new Error(`key does not match this storage (${pallet}.${name})`)\n\n      if (bytesToSkip.length !== encoders.length)\n        throw new Error(\"Impossible to decode this key\")\n\n      if (encoders.length === 0) return [] as any\n\n      const argsKey = key.slice(palletItemEncodedHex.length)\n      const result = new Array<any>(encoders.length)\n      for (let i = 0, cur = 0; i < bytesToSkip.length; i++) {\n        const codec = encoders[i][0]\n        cur += bytesToSkip[i]\n        result[i] = codec.dec(argsKey.slice(cur * 2))\n        cur += codec.enc(result[i]).length\n      }\n      return result as any\n    }\n\n    const fns = encoders.map(\n      ([{ enc }, hash]) =>\n        (val: any) =>\n          hash(enc(val)),\n    )\n\n    const enc = (\n      ...args: {\n        [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n      }\n    ): string =>\n      toHex(\n        mergeUint8(palletItemEncoded, ...args.map((val, idx) => fns[idx](val))),\n      )\n\n    return {\n      enc,\n      dec,\n      keyDecoder,\n    }\n  }\n}\n"],"mappings":"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","names":["Bytes","Bytes","Bytes","createCodec","Bytes","createCodec","enhanceCodec","str","fromHex","toHex","Bytes","createCodec","enc","dec","Bytes","enhanceCodec","textEncoder","textDecoder","str","compact","u8","Bytes","enhanceCodec","createCodec","createDecoder","createCodec","createCodec","enc","dec","textEncoder","textDecoder","enhanceCodec","Bytes","Struct","Tuple","Vector","str","u8","Enum","Option","Struct","Vector","_void","str","u32","u8","bitSequence","Struct","Option","Vector","u8","str","Enum","_void","Vector","str","Struct","u8","Tuple","Enum","Struct","u32","createCodec","createCodec","Struct","u32","Enum","blake2b","mergeUint8","u64","p","temp","mergeUint8","u64","mergeUint8","toHex","textEncoder","dec","mergeUint8","toHex","enc"]}