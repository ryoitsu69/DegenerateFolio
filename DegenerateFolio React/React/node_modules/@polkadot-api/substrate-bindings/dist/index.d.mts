import * as scale_ts from 'scale-ts';
import { Codec, Encoder, Decoder, StringRecord, CodecType, EncoderType, DecoderType } from 'scale-ts';
export { Bytes, Codec, CodecType, Decoder, DecoderType, Encoder, EncoderType, Option, Result, ResultPayload, StringRecord, Struct, Tuple, Vector, _void, bool, compact, createCodec, createDecoder, enhanceCodec, enhanceDecoder, enhanceEncoder, i128, i16, i256, i32, i64, i8, str, u128, u16, u256, u32, u64, u8 } from 'scale-ts';
import * as scale_ts_dist_types from 'scale-ts/dist/types';

type SS58String = string & {
    __SS58String?: unknown;
};
declare const AccountId: (ss58Format?: number, nBytes?: 32 | 33) => scale_ts.Codec<SS58String>;

type HexString = string & {
    __hexString?: unknown;
};
declare const Hex: {
    (nBytes?: number): Codec<HexString>;
    enc: (nBytes?: number) => Encoder<HexString>;
    dec: (nBytes?: number) => Decoder<HexString>;
};

declare class Binary {
    #private;
    constructor(data: Uint8Array);
    asText: () => string;
    asHex: () => string;
    asBytes: () => Uint8Array;
    static fromText(input: string): Binary;
    static fromHex(input: HexString): Binary;
    static fromBytes(input: Uint8Array): Binary;
}
declare const Bin: {
    (nBytes?: number): Codec<Binary>;
    enc: (nBytes?: number) => Encoder<Binary>;
    dec: (nBytes?: number) => Decoder<Binary>;
};

interface BitSequence {
    bitsLen: number;
    bytes: Uint8Array;
}
declare const bitSequence: scale_ts.Codec<BitSequence>;

declare const char: scale_ts.Codec<string>;

declare const compactNumber: Codec<number>;
declare const compactBn: Codec<bigint>;

declare const fixedStr: (nBytes: number) => scale_ts.Codec<string>;

declare const selfEncoder: <T>(value: () => Encoder<T>) => Encoder<T>;
declare const selfDecoder: <T>(value: () => Decoder<T>) => Decoder<T>;
declare const Self: <T>(value: () => Codec<T>) => Codec<T>;

type Tuple<T, N extends number> = readonly [T, ...T[]] & {
    length: N;
};
type Push<T extends any[], V> = [...T, V];
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
type LastOf<T> = UnionToIntersection<T extends any ? () => T : never> extends () => infer R ? R : never;
type TuplifyUnion<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = true extends N ? [] : Push<TuplifyUnion<Exclude<T, L>>, L>;
type RestrictedLenTuple<T, O extends StringRecord<any>> = Tuple<T, TuplifyUnion<keyof O> extends Tuple<any, infer V> ? V : 0>;
type ExtractValue<T extends {
    type: string;
    value?: any;
}, K extends string> = T extends {
    type: K;
    value: infer R;
} ? R : never;
interface Discriminant<T extends {
    type: string;
    value?: any;
}> {
    is<K extends T["type"]>(this: Enum<T>, type: K): this is Enum<{
        type: K;
        value: ExtractValue<T, K>;
    }>;
    as<K extends T["type"]>(type: K): ExtractValue<T, K>;
}
type MyTuple<T> = [T, ...T[]];
type List<T> = Array<T>;
type SeparateUndefined<T> = undefined extends T ? undefined | Exclude<T, undefined> : T;
type Anonymize<T> = SeparateUndefined<T extends string | number | bigint | boolean | void | undefined | null | symbol | Binary | Enum<{
    type: string;
    value: any;
}> | Uint8Array ? T : T extends (...args: infer Args) => infer R ? (...args: {
    [K in keyof Args]: Anonymize<Args[K]>;
}) => Anonymize<R> : T extends MyTuple<any> ? {
    [K in keyof T]: Anonymize<T[K]>;
} : T extends [] ? [] : T extends Array<infer A> ? List<Anonymize<A>> : {
    [K in keyof T]: Anonymize<T[K]>;
}>;
declare const _Enum: {};
type EnumOption<T extends {
    type: string;
    value?: any;
}, Key extends T["type"]> = Anonymize<ExtractValue<T, Key>>;
type GetEnum<T extends Enum<{
    type: string;
    value: any;
}>> = {
    [K in T["type"]]: (...args: ExtractValue<T, K> extends undefined ? [] : [value: Anonymize<ExtractValue<T, K>>]) => T;
};
type Enum<T extends {
    type: string;
    value?: any;
}> = T & Discriminant<T>;
declare const Enum: <T extends {
    type: string;
    value?: any;
}, Key extends T["type"]>(type: Key, ...args: ExtractValue<T, Key> extends undefined ? [] : [value: Anonymize<ExtractValue<T, Key>>]) => Enum<ExtractValue<T, Key> extends undefined ? T : ExtractValue<T, Key> extends never ? T : {
    type: Key;
    value: ExtractValue<T, Key>;
}>;
declare const Variant: {
    <O extends StringRecord<Codec<any>>>(inner: O, indexes?: RestrictedLenTuple<number, O> | undefined): Codec<Enum<{ [K in keyof O]: K extends string ? {
        type: K;
        value: CodecType<O[K]>;
    } : never; }[keyof O]>>;
    enc: <O_1 extends StringRecord<Encoder<any>>>(inner: O_1, x?: RestrictedLenTuple<number, O_1> | undefined) => Encoder<Enum<{ [K_1 in keyof O_1]: K_1 extends string ? {
        type: K_1;
        value: EncoderType<O_1[K_1]>;
    } : never; }[keyof O_1]>>;
    dec: <O_2 extends StringRecord<Decoder<any>>>(inner: O_2, x?: RestrictedLenTuple<number, O_2> | undefined) => Decoder<Enum<{ [K_2 in keyof O_2]: K_2 extends string ? {
        type: K_2;
        value: DecoderType<O_2[K_2]>;
    } : never; }[keyof O_2]>>;
};

declare const blockHeader: scale_ts_dist_types.Codec<{
    parentHash: HexString;
    number: number;
    stateRoot: HexString;
    extrinsicRoot: HexString;
    digests: Enum<{
        type: "consensus";
        value: {
            engine: string;
            payload: HexString;
        };
    } | {
        type: "seal";
        value: {
            engine: string;
            payload: HexString;
        };
    } | {
        type: "preRuntime";
        value: {
            engine: string;
            payload: HexString;
        };
    } | {
        type: "runtimeUpdated";
        value: undefined;
    }>[];
}>;
type BlockHeader = CodecType<typeof blockHeader>;

declare const lookup: scale_ts.Codec<{
    id: number;
    path: string[];
    params: {
        name: string;
        type: number | undefined;
    }[];
    def: {
        tag: "composite";
        value: {
            name: string | undefined;
            type: number;
            typeName: string | undefined;
            docs: string[];
        }[];
    } | {
        tag: "variant";
        value: {
            name: string;
            fields: {
                name: string | undefined;
                type: number;
                typeName: string | undefined;
                docs: string[];
            }[];
            index: number;
            docs: string[];
        }[];
    } | {
        tag: "sequence";
        value: number;
    } | {
        tag: "array";
        value: {
            len: number;
            type: number;
        };
    } | {
        tag: "tuple";
        value: number[];
    } | {
        tag: "primitive";
        value: {
            tag: "bool";
            value: undefined;
        } | {
            tag: "char";
            value: undefined;
        } | {
            tag: "str";
            value: undefined;
        } | {
            tag: "u8";
            value: undefined;
        } | {
            tag: "u16";
            value: undefined;
        } | {
            tag: "u32";
            value: undefined;
        } | {
            tag: "u64";
            value: undefined;
        } | {
            tag: "u128";
            value: undefined;
        } | {
            tag: "u256";
            value: undefined;
        } | {
            tag: "i8";
            value: undefined;
        } | {
            tag: "i16";
            value: undefined;
        } | {
            tag: "i32";
            value: undefined;
        } | {
            tag: "i64";
            value: undefined;
        } | {
            tag: "i128";
            value: undefined;
        } | {
            tag: "i256";
            value: undefined;
        };
    } | {
        tag: "compact";
        value: number;
    } | {
        tag: "bitSequence";
        value: {
            bitStoreType: number;
            bitOrderType: number;
        };
    };
    docs: string[];
}[]>;
type V14Lookup = CodecType<typeof lookup>;

declare const extrinsic: scale_ts.Codec<{
    version: number;
    address: number;
    call: number;
    signature: number;
    extra: number;
    signedExtensions: {
        identifier: string;
        type: number;
        additionalSigned: number;
    }[];
}>;
type V15Extrinsic = CodecType<typeof extrinsic>;
declare const v15: scale_ts.Codec<{
    lookup: {
        id: number;
        path: string[];
        params: {
            name: string;
            type: number | undefined;
        }[];
        def: {
            tag: "composite";
            value: {
                name: string | undefined;
                type: number;
                typeName: string | undefined;
                docs: string[];
            }[];
        } | {
            tag: "variant";
            value: {
                name: string;
                fields: {
                    name: string | undefined;
                    type: number;
                    typeName: string | undefined;
                    docs: string[];
                }[];
                index: number;
                docs: string[];
            }[];
        } | {
            tag: "sequence";
            value: number;
        } | {
            tag: "array";
            value: {
                len: number;
                type: number;
            };
        } | {
            tag: "tuple";
            value: number[];
        } | {
            tag: "primitive";
            value: {
                tag: "bool";
                value: undefined;
            } | {
                tag: "char";
                value: undefined;
            } | {
                tag: "str";
                value: undefined;
            } | {
                tag: "u8";
                value: undefined;
            } | {
                tag: "u16";
                value: undefined;
            } | {
                tag: "u32";
                value: undefined;
            } | {
                tag: "u64";
                value: undefined;
            } | {
                tag: "u128";
                value: undefined;
            } | {
                tag: "u256";
                value: undefined;
            } | {
                tag: "i8";
                value: undefined;
            } | {
                tag: "i16";
                value: undefined;
            } | {
                tag: "i32";
                value: undefined;
            } | {
                tag: "i64";
                value: undefined;
            } | {
                tag: "i128";
                value: undefined;
            } | {
                tag: "i256";
                value: undefined;
            };
        } | {
            tag: "compact";
            value: number;
        } | {
            tag: "bitSequence";
            value: {
                bitStoreType: number;
                bitOrderType: number;
            };
        };
        docs: string[];
    }[];
    pallets: {
        name: string;
        storage: {
            prefix: string;
            items: {
                name: string;
                modifier: number;
                type: {
                    tag: "map";
                    value: {
                        hashers: ({
                            tag: "Blake2128";
                            value: undefined;
                        } | {
                            tag: "Blake2256";
                            value: undefined;
                        } | {
                            tag: "Blake2128Concat";
                            value: undefined;
                        } | {
                            tag: "Twox128";
                            value: undefined;
                        } | {
                            tag: "Twox256";
                            value: undefined;
                        } | {
                            tag: "Twox64Concat";
                            value: undefined;
                        } | {
                            tag: "Identity";
                            value: undefined;
                        })[];
                        key: number;
                        value: number;
                    };
                } | {
                    tag: "plain";
                    value: number;
                };
                fallback: HexString;
                docs: string[];
            }[];
        } | undefined;
        calls: number | undefined;
        events: number | undefined;
        constants: {
            name: string;
            type: number;
            value: HexString;
            docs: string[];
        }[];
        errors: number | undefined;
        index: number;
        docs: string[];
    }[];
    extrinsic: {
        version: number;
        address: number;
        call: number;
        signature: number;
        extra: number;
        signedExtensions: {
            identifier: string;
            type: number;
            additionalSigned: number;
        }[];
    };
    type: number;
    apis: {
        name: string;
        methods: {
            name: string;
            inputs: {
                name: string;
                type: number;
            }[];
            output: number;
            docs: string[];
        }[];
        docs: string[];
    }[];
    outerEnums: {
        call: number;
        event: number;
        error: number;
    };
    custom: [string, {
        type: number;
        value: HexString;
    }][];
}>;
type V15 = CodecType<typeof v15>;

declare const metadata: Codec<{
    magicNumber: number;
    metadata: {
        tag: "v0";
        value: unknown;
    } | {
        tag: "v1";
        value: unknown;
    } | {
        tag: "v2";
        value: unknown;
    } | {
        tag: "v3";
        value: unknown;
    } | {
        tag: "v4";
        value: unknown;
    } | {
        tag: "v5";
        value: unknown;
    } | {
        tag: "v6";
        value: unknown;
    } | {
        tag: "v7";
        value: unknown;
    } | {
        tag: "v8";
        value: unknown;
    } | {
        tag: "v9";
        value: unknown;
    } | {
        tag: "v10";
        value: unknown;
    } | {
        tag: "v11";
        value: unknown;
    } | {
        tag: "v12";
        value: unknown;
    } | {
        tag: "v13";
        value: unknown;
    } | {
        tag: "v14";
        value: unknown;
    } | {
        tag: "v15";
        value: {
            lookup: {
                id: number;
                path: string[];
                params: {
                    name: string;
                    type: number | undefined;
                }[];
                def: {
                    tag: "composite";
                    value: {
                        name: string | undefined;
                        type: number;
                        typeName: string | undefined;
                        docs: string[];
                    }[];
                } | {
                    tag: "variant";
                    value: {
                        name: string;
                        fields: {
                            name: string | undefined;
                            type: number;
                            typeName: string | undefined;
                            docs: string[];
                        }[];
                        index: number;
                        docs: string[];
                    }[];
                } | {
                    tag: "sequence";
                    value: number;
                } | {
                    tag: "array";
                    value: {
                        len: number;
                        type: number;
                    };
                } | {
                    tag: "tuple";
                    value: number[];
                } | {
                    tag: "primitive";
                    value: {
                        tag: "bool";
                        value: undefined;
                    } | {
                        tag: "char";
                        value: undefined;
                    } | {
                        tag: "str";
                        value: undefined;
                    } | {
                        tag: "u8";
                        value: undefined;
                    } | {
                        tag: "u16";
                        value: undefined;
                    } | {
                        tag: "u32";
                        value: undefined;
                    } | {
                        tag: "u64";
                        value: undefined;
                    } | {
                        tag: "u128";
                        value: undefined;
                    } | {
                        tag: "u256";
                        value: undefined;
                    } | {
                        tag: "i8";
                        value: undefined;
                    } | {
                        tag: "i16";
                        value: undefined;
                    } | {
                        tag: "i32";
                        value: undefined;
                    } | {
                        tag: "i64";
                        value: undefined;
                    } | {
                        tag: "i128";
                        value: undefined;
                    } | {
                        tag: "i256";
                        value: undefined;
                    };
                } | {
                    tag: "compact";
                    value: number;
                } | {
                    tag: "bitSequence";
                    value: {
                        bitStoreType: number;
                        bitOrderType: number;
                    };
                };
                docs: string[];
            }[];
            pallets: {
                name: string;
                storage: {
                    prefix: string;
                    items: {
                        name: string;
                        modifier: number;
                        type: {
                            tag: "map";
                            value: {
                                hashers: ({
                                    tag: "Blake2128";
                                    value: undefined;
                                } | {
                                    tag: "Blake2256";
                                    value: undefined;
                                } | {
                                    tag: "Blake2128Concat";
                                    value: undefined;
                                } | {
                                    tag: "Twox128";
                                    value: undefined;
                                } | {
                                    tag: "Twox256";
                                    value: undefined;
                                } | {
                                    tag: "Twox64Concat";
                                    value: undefined;
                                } | {
                                    tag: "Identity";
                                    value: undefined;
                                })[];
                                key: number;
                                value: number;
                            };
                        } | {
                            tag: "plain";
                            value: number;
                        };
                        fallback: HexString;
                        docs: string[];
                    }[];
                } | undefined;
                calls: number | undefined;
                events: number | undefined;
                constants: {
                    name: string;
                    type: number;
                    value: HexString;
                    docs: string[];
                }[];
                errors: number | undefined;
                index: number;
                docs: string[];
            }[];
            extrinsic: {
                version: number;
                address: number;
                call: number;
                signature: number;
                extra: number;
                signedExtensions: {
                    identifier: string;
                    type: number;
                    additionalSigned: number;
                }[];
            };
            type: number;
            apis: {
                name: string;
                methods: {
                    name: string;
                    inputs: {
                        name: string;
                        type: number;
                    }[];
                    output: number;
                    docs: string[];
                }[];
                docs: string[];
            }[];
            outerEnums: {
                call: number;
                event: number;
                error: number;
            };
            custom: [string, {
                type: number;
                value: HexString;
            }][];
        };
    };
}>;

declare const Blake2256: (encoded: Uint8Array) => Uint8Array;
declare const Blake2128: (encoded: Uint8Array) => Uint8Array;
declare const Blake2128Concat: (encoded: Uint8Array) => Uint8Array;

declare const Identity: (encoded: Uint8Array) => Uint8Array;

declare const Twox128: (input: Uint8Array) => Uint8Array;
declare const Twox256: (input: Uint8Array) => Uint8Array;
declare const Twox64Concat: (encoded: Uint8Array) => Uint8Array;

declare function h64(input: Uint8Array, seed?: bigint): bigint;

type EncoderWithHash<T> = [Codec<T>, (input: Uint8Array) => Uint8Array];
declare const Storage: (pallet: string) => <T, A extends EncoderWithHash<any>[]>(name: string, dec: Decoder<T>, ...encoders_0: A) => {
    enc: (...args: { [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown; }) => string;
    dec: Decoder<T>;
    keyDecoder: (value: string) => { [K_1 in keyof A]: A[K_1] extends EncoderWithHash<infer V_1> ? V_1 : unknown; };
};

type PlainDescriptor<T> = string & {
    _type?: T;
};
type StorageDescriptor<Args extends Array<any>, T, Optional extends true | false> = string & {
    _type: T;
    _args: Args;
    _optional: Optional;
};
type TxDescriptor<Args extends {} | undefined> = string & {
    ___: Args;
};
type RuntimeDescriptor<Args extends Array<any>, T> = string & {
    __: [Args, T];
};
type Descriptors = {
    pallets: Record<string, [
        Record<string, StorageDescriptor<any, any, any>>,
        Record<string, TxDescriptor<any>>,
        Record<string, PlainDescriptor<any>>,
        Record<string, PlainDescriptor<any>>,
        Record<string, PlainDescriptor<any>>
    ]>;
    apis: Record<string, Record<string, RuntimeDescriptor<any, any>>>;
    asset: PlainDescriptor<any>;
};
type PickDescriptors<Idx extends 0 | 1 | 2 | 3 | 4, T extends Descriptors["pallets"]> = {
    [K in keyof T]: T[K][Idx];
};
type ExtractStorage<T extends Record<string, Record<string, StorageDescriptor<any, any, any>>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends StorageDescriptor<infer Key, infer Value, infer Optional> ? {
            KeyArgs: Anonymize<Key>;
            Value: Anonymize<Value>;
            IsOptional: Optional;
        } : unknown;
    };
};
type ExtractTx<T extends Record<string, Record<string, TxDescriptor<any>>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends TxDescriptor<infer Args> ? Anonymize<Args> : unknown;
    };
};
type ExtractPlain<T extends Record<string, Record<string, PlainDescriptor<any>>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends PlainDescriptor<infer Value> ? Anonymize<Value> : unknown;
    };
};
type QueryFromDescriptors<T extends Descriptors> = ExtractStorage<PickDescriptors<0, T["pallets"]>>;
type TxFromDescriptors<T extends Descriptors> = ExtractTx<PickDescriptors<1, T["pallets"]>>;
type EventsFromDescriptors<T extends Descriptors> = ExtractPlain<PickDescriptors<2, T["pallets"]>>;
type ErrorsFromDescriptors<T extends Descriptors> = ExtractPlain<PickDescriptors<3, T["pallets"]>>;
type ConstFromDescriptors<T extends Descriptors> = ExtractPlain<PickDescriptors<4, T["pallets"]>>;

export { AccountId, type Anonymize, Bin, Binary, type BitSequence, Blake2128, Blake2128Concat, Blake2256, type BlockHeader, type ConstFromDescriptors, type Descriptors, type Discriminant, type EncoderWithHash, Enum, type EnumOption, type ErrorsFromDescriptors, type EventsFromDescriptors, type GetEnum, Hex, type HexString, Identity, type PlainDescriptor, type QueryFromDescriptors, type RuntimeDescriptor, type SS58String, Self, Storage, type StorageDescriptor, Twox128, Twox256, Twox64Concat, type TxDescriptor, type TxFromDescriptors, type V14Lookup, type V15, type V15Extrinsic, Variant, _Enum, bitSequence, blockHeader, char, compactBn, compactNumber, fixedStr, h64, metadata, selfDecoder, selfEncoder, v15 };
