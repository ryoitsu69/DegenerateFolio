var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// src/codecs/scale/AccountId.ts
import { Bytes, enhanceCodec } from "scale-ts";
import { blake2b } from "@noble/hashes/blake2b";
import { base58 } from "@scure/base";
var SS58_PREFIX = new TextEncoder().encode("SS58PRE");
var CHECKSUM_LENGTH = 2;
var fromBufferToBase58 = (ss58Format) => {
  const prefixBytes = ss58Format < 64 ? Uint8Array.of(ss58Format) : Uint8Array.of(
    (ss58Format & 252) >> 2 | 64,
    ss58Format >> 8 | (ss58Format & 3) << 6
  );
  return (publicKey) => {
    const checksum = blake2b(
      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),
      {
        dkLen: 64
      }
    ).subarray(0, CHECKSUM_LENGTH);
    return base58.encode(
      Uint8Array.of(...prefixBytes, ...publicKey, ...checksum)
    );
  };
};
function fromBase58ToBuffer(nBytes, ss58Format) {
  return (address) => {
    const decoded = base58.decode(address);
    const prefixBytes = decoded.subarray(0, decoded[0] & 64 ? 2 : 1);
    const publicKey = decoded.subarray(
      prefixBytes.length,
      decoded.length - CHECKSUM_LENGTH
    );
    if (publicKey.length !== nBytes)
      throw new Error("Invalid public key length");
    const checksum = decoded.subarray(prefixBytes.length + publicKey.length);
    const expectedChecksum = blake2b(
      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),
      {
        dkLen: 64
      }
    ).subarray(0, CHECKSUM_LENGTH);
    if (checksum[0] !== expectedChecksum[0] || checksum[1] !== expectedChecksum[1])
      throw new Error("Invalid checksum");
    if (prefixBytesToNumber(prefixBytes) != ss58Format)
      throw new Error("Invalid SS58 prefix");
    return publicKey.slice();
  };
}
var AccountId = (ss58Format = 42, nBytes = 32) => enhanceCodec(
  Bytes(nBytes),
  fromBase58ToBuffer(nBytes, ss58Format),
  fromBufferToBase58(ss58Format)
);
var prefixBytesToNumber = (bytes) => {
  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  return dv.byteLength === 1 ? dv.getUint8(0) : dv.getUint16(0);
};

// src/codecs/scale/Binary.ts
import { Bytes as Bytes2, createCodec } from "scale-ts";
import { fromHex, toHex } from "@polkadot-api/utils";
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();
var _bytes, _hex, _str;
var _Binary = class _Binary {
  constructor(data) {
    __privateAdd(this, _bytes, void 0);
    __privateAdd(this, _hex, null);
    __privateAdd(this, _str, null);
    __publicField(this, "asText", () => __privateGet(this, _str) === null ? __privateSet(this, _str, textDecoder.decode(__privateGet(this, _bytes))) : __privateGet(this, _str));
    __publicField(this, "asHex", () => __privateGet(this, _hex) === null ? __privateSet(this, _hex, toHex(__privateGet(this, _bytes))) : __privateGet(this, _hex));
    __publicField(this, "asBytes", () => __privateGet(this, _bytes));
    __privateSet(this, _bytes, data);
  }
  static fromText(input) {
    return new _Binary(textEncoder.encode(input));
  }
  static fromHex(input) {
    return new _Binary(fromHex(input));
  }
  static fromBytes(input) {
    return new _Binary(input);
  }
};
_bytes = new WeakMap();
_hex = new WeakMap();
_str = new WeakMap();
var Binary = _Binary;
var enc = (nBytes) => {
  const _enc = Bytes2.enc(nBytes);
  return (value) => _enc(value.asBytes());
};
var dec = (nBytes) => {
  const _dec = Bytes2.dec(nBytes);
  return (value) => Binary.fromBytes(_dec(value));
};
var Bin = (nBytes) => createCodec(enc(nBytes), dec(nBytes));
Bin.enc = enc;
Bin.dec = dec;

// src/codecs/scale/bitSequence.ts
import { Bytes as Bytes3, createCodec as createCodec2, createDecoder } from "scale-ts";

// src/codecs/scale/compact.ts
import { compact } from "scale-ts";
var compactNumber = compact;
var compactBn = compact;

// src/codecs/scale/bitSequence.ts
var bitSequenceDecoder = createDecoder((data) => {
  const bitsLen = compactNumber.dec(data);
  const bytesLen = Math.ceil(bitsLen / 8);
  const bytes = Bytes3(bytesLen).dec(data);
  return { bytes, bitsLen };
});
var bitSequenceEncoder = (input) => {
  if (input.bitsLen > input.bytes.length * 8)
    throw new Error(
      `Not enough bytes. (bitsLen:${input.bitsLen}, bytesLen:${input.bytes.length})`
    );
  const lenEncoded = compactNumber.enc(input.bitsLen);
  const result = new Uint8Array(input.bytes.length + lenEncoded.length);
  result.set(lenEncoded, 0);
  result.set(input.bytes, lenEncoded.length);
  return result;
};
var bitSequence = createCodec2(bitSequenceEncoder, bitSequenceDecoder);

// src/codecs/scale/char.ts
import { enhanceCodec as enhanceCodec2, u8 } from "scale-ts";
var char = enhanceCodec2(
  u8,
  (str5) => str5.charCodeAt(0),
  String.fromCharCode
);

// src/codecs/scale/Hex.ts
import { fromHex as fromHex2, toHex as toHex2 } from "@polkadot-api/utils";
import { Bytes as Bytes4, createCodec as createCodec3 } from "scale-ts";
var enc2 = (nBytes) => {
  const _enc = Bytes4.enc(nBytes);
  return (value) => _enc(fromHex2(value));
};
var dec2 = (nBytes) => {
  const _dec = Bytes4.dec(nBytes);
  return (value) => toHex2(_dec(value));
};
var Hex = (nBytes) => createCodec3(enc2(nBytes), dec2(nBytes));
Hex.enc = enc2;
Hex.dec = dec2;

// src/codecs/scale/fixed-str.ts
import { Bytes as Bytes5, enhanceCodec as enhanceCodec3 } from "scale-ts";
var textEncoder2 = new TextEncoder();
var textDecoder2 = new TextDecoder();
var fixedStr = (nBytes) => enhanceCodec3(
  Bytes5(nBytes),
  (str5) => textEncoder2.encode(str5),
  (bytes) => textDecoder2.decode(bytes)
);

// src/codecs/scale/re-exported.ts
import {
  _void,
  bool,
  compact as compact2,
  str,
  u8 as u82,
  u16,
  u32,
  u64,
  u128,
  u256,
  i8,
  i16,
  i32,
  i64,
  i128,
  i256,
  Option,
  Result,
  Vector,
  Tuple,
  Struct,
  Bytes as Bytes6,
  enhanceCodec as enhanceCodec4,
  enhanceEncoder,
  enhanceDecoder,
  createCodec as createCodec4,
  createDecoder as createDecoder2
} from "scale-ts";

// src/codecs/scale/Self.ts
import { createCodec as createCodec5 } from "scale-ts";
var selfEncoder = (value) => {
  let cache = (x) => {
    const encoder = value();
    cache = encoder;
    return encoder(x);
  };
  return (x) => cache(x);
};
var selfDecoder = (value) => {
  let cache = (x) => {
    const decoder = value();
    const result = decoder;
    cache = decoder;
    return result(x);
  };
  return (x) => cache(x);
};
var Self = (value) => createCodec5(
  selfEncoder(() => value().enc),
  selfDecoder(() => value().dec)
);

// src/codecs/scale/Variant.ts
import {
  Enum as ScaleEnum,
  createCodec as createCodec6
} from "scale-ts";
import { mapObject } from "@polkadot-api/utils";
var _Enum = new Proxy(
  {},
  {
    get(_, prop) {
      return (value) => Enum(prop, value);
    }
  }
);
var Enum = (_type, _value) => ({
  as: (type) => {
    if (type !== _type)
      throw new Error(`Enum.as(${type}) used with actual type ${_type}`);
    return _value;
  },
  is: (type) => type === _type,
  type: _type,
  value: _value
});
var VariantEnc = (...args) => {
  const enc3 = ScaleEnum.enc(...args);
  return (v) => enc3({ tag: v.type, value: v.value });
};
var VariantDec = (...args) => {
  const dec3 = ScaleEnum.dec(...args);
  return (v) => {
    const { tag, value } = dec3(v);
    return Enum(tag, value);
  };
};
var Variant = (inner, ...args) => createCodec6(
  VariantEnc(
    mapObject(inner, ([encoder]) => encoder),
    ...args
  ),
  VariantDec(
    mapObject(inner, ([, decoder]) => decoder),
    ...args
  )
);
Variant.enc = VariantEnc;
Variant.dec = VariantDec;

// src/codecs/blockHeader.ts
var textEncoder3 = new TextEncoder();
var textDecoder3 = new TextDecoder();
var fourChars = enhanceCodec4(
  Bytes6(4),
  textEncoder3.encode.bind(textEncoder3),
  textDecoder3.decode.bind(textDecoder3)
);
var diggestVal = Struct({
  engine: fourChars,
  payload: Hex()
});
var diggest = Variant(
  {
    consensus: diggestVal,
    seal: diggestVal,
    preRuntime: diggestVal,
    runtimeUpdated: _void
  },
  [4, 5, 6, 8]
);
var hex32 = Hex(32);
var blockHeader = Struct({
  parentHash: hex32,
  number: compactNumber,
  stateRoot: hex32,
  extrinsicRoot: hex32,
  digests: Vector(diggest)
});

// src/codecs/metadata/v15/v15.ts
import { Struct as Struct4, Tuple as Tuple2, Vector as Vector4, str as str4, u8 as u85 } from "scale-ts";

// src/codecs/metadata/v15/lookup.ts
import {
  Enum as Enum2,
  Option as Option2,
  Struct as Struct2,
  Vector as Vector2,
  _void as _void3,
  str as str2,
  u32 as u322,
  u8 as u83
} from "scale-ts";
var oStr = Option2(str2);
var strs = Vector2(str2);
var primitive = Enum2({
  bool: _void3,
  char: _void3,
  str: _void3,
  u8: _void3,
  u16: _void3,
  u32: _void3,
  u64: _void3,
  u128: _void3,
  u256: _void3,
  i8: _void3,
  i16: _void3,
  i32: _void3,
  i64: _void3,
  i128: _void3,
  i256: _void3
});
var fields = Vector2(
  Struct2({
    name: oStr,
    type: compactNumber,
    typeName: oStr,
    docs: strs
  })
);
var arr = Struct2({
  len: u322,
  type: compactNumber
});
var bitSequence2 = Struct2({
  bitStoreType: compactNumber,
  bitOrderType: compactNumber
});
var variant = Vector2(
  Struct2({
    name: str2,
    fields,
    index: u83,
    docs: strs
  })
);
var def = Enum2({
  composite: fields,
  variant,
  sequence: compactNumber,
  array: arr,
  tuple: Vector2(compactNumber),
  primitive,
  compact: compactNumber,
  bitSequence: bitSequence2
});
var param = Struct2({
  name: str2,
  type: Option2(compactNumber)
});
var params = Vector2(param);
var entry = Struct2({
  id: compactNumber,
  path: strs,
  params,
  def,
  docs: strs
});
var lookup = Vector2(entry);

// src/codecs/metadata/v15/pallets.ts
import {
  Struct as Struct3,
  Option as Option3,
  Vector as Vector3,
  u8 as u84,
  str as str3,
  Enum as Enum3,
  _void as _void4
} from "scale-ts";
var hashType = Enum3({
  Blake2128: _void4,
  Blake2256: _void4,
  Blake2128Concat: _void4,
  Twox128: _void4,
  Twox256: _void4,
  Twox64Concat: _void4,
  Identity: _void4
});
var hashers = Vector3(hashType);
var storageMap = Struct3({
  hashers,
  key: compactNumber,
  value: compactNumber
});
var storageItem = Struct3({
  name: str3,
  modifier: u84,
  type: Enum3({
    plain: compactNumber,
    map: storageMap
  }),
  fallback: Hex(),
  docs: Vector3(str3)
});
var storage = Option3(
  Struct3({
    prefix: str3,
    items: Vector3(storageItem)
  })
);
var pallets = Vector3(
  Struct3({
    name: str3,
    storage,
    calls: Option3(compactNumber),
    events: Option3(compactNumber),
    constants: Vector3(
      Struct3({
        name: str3,
        type: compactNumber,
        value: Hex(),
        docs: Vector3(str3)
      })
    ),
    errors: Option3(compactNumber),
    index: u84,
    docs: Vector3(str3)
  })
);

// src/codecs/metadata/v15/v15.ts
var docs = Vector4(str4);
var runtimeApi = Struct4({
  name: str4,
  methods: Vector4(
    Struct4({
      name: str4,
      inputs: Vector4(
        Struct4({
          name: str4,
          type: compactNumber
        })
      ),
      output: compactNumber,
      docs
    })
  ),
  docs
});
var extrinsic = Struct4({
  version: u85,
  address: compactNumber,
  call: compactNumber,
  signature: compactNumber,
  extra: compactNumber,
  signedExtensions: Vector4(
    Struct4({
      identifier: str4,
      type: compactNumber,
      additionalSigned: compactNumber
    })
  )
});
var v15 = Struct4({
  lookup,
  pallets,
  extrinsic,
  type: compactNumber,
  apis: Vector4(runtimeApi),
  outerEnums: Struct4({
    call: compactNumber,
    event: compactNumber,
    error: compactNumber
  }),
  custom: Vector4(Tuple2(str4, Struct4({ type: compactNumber, value: Hex() })))
});

// src/codecs/metadata/metadata.ts
import { Enum as Enum4, Struct as Struct5, u32 as u323, createCodec as createCodec7 } from "scale-ts";
var unsupportedFn = () => {
  throw new Error("Unsupported metadata version!");
};
var unsupported = createCodec7(
  unsupportedFn,
  unsupportedFn
);
var metadata = Struct5({
  magicNumber: u323,
  metadata: Enum4({
    v0: unsupported,
    v1: unsupported,
    v2: unsupported,
    v3: unsupported,
    v4: unsupported,
    v5: unsupported,
    v6: unsupported,
    v7: unsupported,
    v8: unsupported,
    v9: unsupported,
    v10: unsupported,
    v11: unsupported,
    v12: unsupported,
    v13: unsupported,
    v14: unsupported,
    v15
  })
});

// src/hashes/blake2.ts
import { mergeUint8 } from "@polkadot-api/utils";
import { blake2b as blake2b2 } from "@noble/hashes/blake2b";
var len32 = { dkLen: 32 };
var Blake2256 = (encoded) => blake2b2(encoded, len32);
var len16 = { dkLen: 16 };
var Blake2128 = (encoded) => blake2b2(encoded, len16);
var Blake2128Concat = (encoded) => mergeUint8(Blake2128(encoded), encoded);

// src/hashes/identity.ts
var Identity = (encoded) => encoded;

// src/hashes/twoX.ts
import { mergeUint8 as mergeUint82 } from "@polkadot-api/utils";
import { u64 as u642 } from "scale-ts";

// src/hashes/h64.ts
var bigintFromU16 = (v0, v1, v2, v3) => new DataView(new Uint16Array([v0, v1, v2, v3]).buffer).getBigUint64(0, true);
var MASK_64 = 2n ** 64n - 1n;
var rotl = (input, nBits) => input << nBits & MASK_64 | input >> 64n - nBits;
var multiply = (a, b) => a * b & MASK_64;
var add = (a, b) => a + b & MASK_64;
var PRIME64_1 = 11400714785074694791n;
var PRIME64_2 = 14029467366897019727n;
var PRIME64_3 = 1609587929392839161n;
var PRIME64_4 = 9650029242287828579n;
var PRIME64_5 = 2870177450012600261n;
function h64(input, seed = 0n) {
  let v1 = add(add(seed, PRIME64_1), PRIME64_2);
  let v2 = add(seed, PRIME64_2);
  let v3 = seed;
  let v4 = seed - PRIME64_1;
  let totalLen = input.length;
  let memsize = 0;
  let memory = null;
  (function update() {
    let p2 = 0;
    let bEnd = p2 + totalLen;
    if (!totalLen)
      return;
    memory = new Uint8Array(32);
    if (totalLen < 32) {
      memory.set(input.subarray(0, totalLen), memsize);
      memsize += totalLen;
      return;
    }
    if (p2 <= bEnd - 32) {
      const limit = bEnd - 32;
      do {
        let other;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v1 = multiply(rotl(add(v1, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v2 = multiply(rotl(add(v2, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v3 = multiply(rotl(add(v3, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v4 = multiply(rotl(add(v4, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
      } while (p2 <= limit);
    }
    if (p2 < bEnd) {
      memory.set(input.subarray(p2, bEnd), memsize);
      memsize = bEnd - p2;
    }
  })();
  input = memory || input;
  let result;
  let p = 0;
  if (totalLen >= 32) {
    result = rotl(v1, 1n);
    result = add(result, rotl(v2, 7n));
    result = add(result, rotl(v3, 12n));
    result = add(result, rotl(v4, 18n));
    v1 = multiply(rotl(multiply(v1, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v1;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
    v2 = multiply(rotl(multiply(v2, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v2;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
    v3 = multiply(rotl(multiply(v3, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v3;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
    v4 = multiply(rotl(multiply(v4, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v4;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
  } else {
    result = add(seed, PRIME64_5);
  }
  result = add(result, BigInt(totalLen));
  while (p <= memsize - 8) {
    let temp2 = bigintFromU16(
      input[p + 1] << 8 | input[p],
      input[p + 3] << 8 | input[p + 2],
      input[p + 5] << 8 | input[p + 4],
      input[p + 7] << 8 | input[p + 6]
    );
    temp2 = multiply(rotl(multiply(temp2, PRIME64_2), 31n), PRIME64_1);
    result = add(multiply(rotl(result ^ temp2, 27n), PRIME64_1), PRIME64_4);
    p += 8;
  }
  if (p + 4 <= memsize) {
    let temp2 = multiply(
      bigintFromU16(
        input[p + 1] << 8 | input[p],
        input[p + 3] << 8 | input[p + 2],
        0,
        0
      ),
      PRIME64_1
    );
    result = add(multiply(rotl(result ^ temp2, 23n), PRIME64_2), PRIME64_3);
    p += 4;
  }
  while (p < memsize) {
    const temp2 = multiply(bigintFromU16(input[p++], 0, 0, 0), PRIME64_5);
    result = multiply(rotl(result ^ temp2, 11n), PRIME64_1);
  }
  let temp = result >> 33n;
  result = multiply(result ^ temp, PRIME64_2);
  temp = result >> 29n;
  result = multiply(result ^ temp, PRIME64_3);
  temp = result >> 32n;
  result ^= temp;
  return result;
}

// src/hashes/twoX.ts
var Twox128 = (input) => {
  const result = new Uint8Array(16);
  const dv = new DataView(result.buffer);
  dv.setBigUint64(0, h64(input), true);
  dv.setBigUint64(8, h64(input, 1n), true);
  return result;
};
var Twox256 = (input) => {
  const result = new Uint8Array(32);
  const dv = new DataView(result.buffer);
  dv.setBigUint64(0, h64(input), true);
  dv.setBigUint64(8, h64(input, 1n), true);
  dv.setBigUint64(16, h64(input, 2n), true);
  dv.setBigUint64(24, h64(input, 3n), true);
  return result;
};
var Twox64Concat = (encoded) => mergeUint82(u642.enc(h64(encoded)), encoded);

// src/storage.ts
import { mergeUint8 as mergeUint83, toHex as toHex3 } from "@polkadot-api/utils";
var textEncoder4 = new TextEncoder();
var Storage = (pallet) => {
  const palledEncoded = Twox128(textEncoder4.encode(pallet));
  return (name, dec3, ...encoders) => {
    const palletItemEncoded = mergeUint83(
      palledEncoded,
      Twox128(textEncoder4.encode(name))
    );
    const palletItemEncodedHex = toHex3(palletItemEncoded);
    const bytesToSkip = encoders.map((e) => e[1]).map((x) => {
      if (x === Identity)
        return 0;
      if (x === Twox64Concat)
        return 8;
      if (x === Blake2128Concat)
        return 16;
      return null;
    }).filter(Boolean);
    const keyDecoder = (key) => {
      if (!key.startsWith(palletItemEncodedHex))
        throw new Error(`key does not match this storage (${pallet}.${name})`);
      if (bytesToSkip.length !== encoders.length)
        throw new Error("Impossible to decode this key");
      if (encoders.length === 0)
        return [];
      const argsKey = key.slice(palletItemEncodedHex.length);
      const result = new Array(encoders.length);
      for (let i = 0, cur = 0; i < bytesToSkip.length; i++) {
        const codec = encoders[i][0];
        cur += bytesToSkip[i];
        result[i] = codec.dec(argsKey.slice(cur * 2));
        cur += codec.enc(result[i]).length;
      }
      return result;
    };
    const fns = encoders.map(
      ([{ enc: enc4 }, hash]) => (val) => hash(enc4(val))
    );
    const enc3 = (...args) => toHex3(
      mergeUint83(palletItemEncoded, ...args.map((val, idx) => fns[idx](val)))
    );
    return {
      enc: enc3,
      dec: dec3,
      keyDecoder
    };
  };
};
export {
  AccountId,
  Bin,
  Binary,
  Blake2128,
  Blake2128Concat,
  Blake2256,
  Bytes6 as Bytes,
  Enum,
  Hex,
  Identity,
  Option,
  Result,
  Self,
  Storage,
  Struct,
  Tuple,
  Twox128,
  Twox256,
  Twox64Concat,
  Variant,
  Vector,
  _Enum,
  _void,
  bitSequence,
  blockHeader,
  bool,
  char,
  compact2 as compact,
  compactBn,
  compactNumber,
  createCodec4 as createCodec,
  createDecoder2 as createDecoder,
  enhanceCodec4 as enhanceCodec,
  enhanceDecoder,
  enhanceEncoder,
  fixedStr,
  h64,
  i128,
  i16,
  i256,
  i32,
  i64,
  i8,
  metadata,
  selfDecoder,
  selfEncoder,
  str,
  u128,
  u16,
  u256,
  u32,
  u64,
  u82 as u8,
  v15
};
//# sourceMappingURL=index.mjs.map