{"version":3,"sources":["../../src/index.ts","../../src/codecs/scale/AccountId.ts","../../src/codecs/scale/Binary.ts","../../src/codecs/scale/bitSequence.ts","../../src/codecs/scale/compact.ts","../../src/codecs/scale/char.ts","../../src/codecs/scale/Hex.ts","../../src/codecs/scale/fixed-str.ts","../../src/codecs/scale/re-exported.ts","../../src/codecs/scale/Self.ts","../../src/codecs/scale/Variant.ts","../../src/codecs/blockHeader.ts","../../src/codecs/metadata/v15/v15.ts","../../src/codecs/metadata/v15/lookup.ts","../../src/codecs/metadata/v15/pallets.ts","../../src/codecs/metadata/metadata.ts","../../src/hashes/blake2.ts","../../src/hashes/identity.ts","../../src/hashes/twoX.ts","../../src/hashes/h64.ts","../../src/storage.ts"],"sourcesContent":["export * from \"./codecs\"\nexport * from \"./hashes\"\nexport * from \"./storage\"\nexport * from \"./descriptors\"\n","import { Bytes, enhanceCodec } from \"scale-ts\"\nimport { blake2b } from \"@noble/hashes/blake2b\"\nimport { base58 } from \"@scure/base\"\n\nconst SS58_PREFIX = new TextEncoder().encode(\"SS58PRE\")\n\nconst CHECKSUM_LENGTH = 2\n\nexport type SS58String = string & { __SS58String?: unknown }\n\nconst fromBufferToBase58 = (ss58Format: number) => {\n  const prefixBytes =\n    ss58Format < 64\n      ? Uint8Array.of(ss58Format)\n      : Uint8Array.of(\n          ((ss58Format & 0b0000_0000_1111_1100) >> 2) | 0b0100_0000,\n          (ss58Format >> 8) | ((ss58Format & 0b0000_0000_0000_0011) << 6),\n        )\n  return (publicKey: Uint8Array): SS58String => {\n    const checksum = blake2b(\n      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),\n      {\n        dkLen: 64,\n      },\n    ).subarray(0, CHECKSUM_LENGTH)\n    return base58.encode(\n      Uint8Array.of(...prefixBytes, ...publicKey, ...checksum),\n    )\n  }\n}\n\nfunction fromBase58ToBuffer(nBytes: number, ss58Format: number) {\n  return (address: SS58String) => {\n    const decoded = base58.decode(address)\n    const prefixBytes = decoded.subarray(0, decoded[0] & 0b0100_0000 ? 2 : 1)\n    const publicKey = decoded.subarray(\n      prefixBytes.length,\n      decoded.length - CHECKSUM_LENGTH,\n    )\n    if (publicKey.length !== nBytes)\n      throw new Error(\"Invalid public key length\")\n    const checksum = decoded.subarray(prefixBytes.length + publicKey.length)\n    const expectedChecksum = blake2b(\n      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),\n      {\n        dkLen: 64,\n      },\n    ).subarray(0, CHECKSUM_LENGTH)\n    if (\n      checksum[0] !== expectedChecksum[0] ||\n      checksum[1] !== expectedChecksum[1]\n    )\n      throw new Error(\"Invalid checksum\")\n\n    if (prefixBytesToNumber(prefixBytes) != ss58Format)\n      throw new Error(\"Invalid SS58 prefix\")\n\n    return publicKey.slice()\n  }\n}\n\nexport const AccountId = (ss58Format: number = 42, nBytes: 32 | 33 = 32) =>\n  enhanceCodec(\n    Bytes(nBytes),\n    fromBase58ToBuffer(nBytes, ss58Format),\n    fromBufferToBase58(ss58Format),\n  )\n\nconst prefixBytesToNumber = (bytes: Uint8Array) => {\n  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  return dv.byteLength === 1 ? dv.getUint8(0) : dv.getUint16(0)\n}\n","import { Bytes, Codec, Decoder, Encoder, createCodec } from \"scale-ts\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\nimport { HexString } from \"./Hex\"\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport class Binary {\n  #bytes: Uint8Array\n  #hex: HexString | null = null\n  #str: string | null = null\n\n  constructor(data: Uint8Array) {\n    this.#bytes = data\n  }\n\n  asText = () =>\n    this.#str === null\n      ? (this.#str = textDecoder.decode(this.#bytes))\n      : this.#str\n\n  asHex = () =>\n    this.#hex === null ? (this.#hex = toHex(this.#bytes)) : this.#hex\n\n  asBytes = () => this.#bytes\n\n  static fromText(input: string): Binary {\n    return new Binary(textEncoder.encode(input))\n  }\n  static fromHex(input: HexString): Binary {\n    return new Binary(fromHex(input))\n  }\n  static fromBytes(input: Uint8Array): Binary {\n    return new Binary(input)\n  }\n}\n\nconst enc = (nBytes?: number): Encoder<Binary> => {\n  const _enc = Bytes.enc(nBytes)\n  return (value) => _enc(value.asBytes())\n}\n\nconst dec = (nBytes?: number): Decoder<Binary> => {\n  const _dec = Bytes.dec(nBytes)\n  return (value) => Binary.fromBytes(_dec(value))\n}\n\nexport const Bin = (nBytes?: number): Codec<Binary> =>\n  createCodec(enc(nBytes), dec(nBytes))\n\nBin.enc = enc\nBin.dec = dec\n","import { Bytes, Decoder, Encoder, createCodec, createDecoder } from \"scale-ts\"\nimport { compactNumber } from \"./compact\"\n\nexport interface BitSequence {\n  bitsLen: number\n  bytes: Uint8Array\n}\n\nconst bitSequenceDecoder: Decoder<BitSequence> = createDecoder((data) => {\n  const bitsLen = compactNumber.dec(data)\n  const bytesLen = Math.ceil(bitsLen / 8)\n  const bytes = Bytes(bytesLen).dec(data)\n  return { bytes, bitsLen }\n})\n\nconst bitSequenceEncoder: Encoder<BitSequence> = (input) => {\n  if (input.bitsLen > input.bytes.length * 8)\n    throw new Error(\n      `Not enough bytes. (bitsLen:${input.bitsLen}, bytesLen:${input.bytes.length})`,\n    )\n\n  const lenEncoded = compactNumber.enc(input.bitsLen)\n  const result = new Uint8Array(input.bytes.length + lenEncoded.length)\n  result.set(lenEncoded, 0)\n  result.set(input.bytes, lenEncoded.length)\n  return result\n}\n\nexport const bitSequence = createCodec(bitSequenceEncoder, bitSequenceDecoder)\n","import { Codec, compact } from \"scale-ts\"\n\nexport const compactNumber = compact as Codec<number>\nexport const compactBn = compact as Codec<bigint>\n","import { enhanceCodec, u8 } from \"scale-ts\"\n\nexport const char = enhanceCodec(\n  u8,\n  (str: string) => str.charCodeAt(0),\n  String.fromCharCode,\n)\n","import { fromHex, toHex } from \"@polkadot-api/utils\"\nimport { Bytes, Codec, Decoder, Encoder, createCodec } from \"scale-ts\"\n\nexport type HexString = string & { __hexString?: unknown }\n\nconst enc = (nBytes?: number): Encoder<HexString> => {\n  const _enc = Bytes.enc(nBytes)\n  return (value: string) => _enc(fromHex(value))\n}\n\nconst dec = (nBytes?: number): Decoder<HexString> => {\n  const _dec = Bytes.dec(nBytes)\n  return (value) => toHex(_dec(value)) as HexString\n}\n\nexport const Hex = (nBytes?: number): Codec<HexString> =>\n  createCodec(enc(nBytes), dec(nBytes))\n\nHex.enc = enc\nHex.dec = dec\n","import { Bytes, enhanceCodec } from \"scale-ts\"\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const fixedStr = (nBytes: number) =>\n  enhanceCodec(\n    Bytes(nBytes),\n    (str: string) => textEncoder.encode(str),\n    (bytes) => textDecoder.decode(bytes),\n  )\n","export {\n  _void,\n  bool,\n  compact,\n  str,\n  u8,\n  u16,\n  u32,\n  u64,\n  u128,\n  u256,\n  i8,\n  i16,\n  i32,\n  i64,\n  i128,\n  i256,\n  Option,\n  Result,\n  Vector,\n  Tuple,\n  Struct,\n  Bytes,\n  enhanceCodec,\n  enhanceEncoder,\n  enhanceDecoder,\n  createCodec,\n  createDecoder,\n} from \"scale-ts\"\n\nexport type {\n  Encoder,\n  Decoder,\n  Codec,\n  CodecType,\n  EncoderType,\n  DecoderType,\n  StringRecord,\n  ResultPayload,\n} from \"scale-ts\"\n","import { Codec, Decoder, Encoder, createCodec, _void } from \"scale-ts\"\n\nexport const selfEncoder = <T>(value: () => Encoder<T>): Encoder<T> => {\n  let cache: Encoder<T> = (x) => {\n    const encoder = value()\n    cache = encoder\n    return encoder(x)\n  }\n\n  return (x) => cache(x)\n}\n\nexport const selfDecoder = <T>(value: () => Decoder<T>): Decoder<T> => {\n  let cache: Decoder<T> = (x) => {\n    const decoder = value()\n    const result = decoder\n    cache = decoder\n    return result(x)\n  }\n\n  return (x) => cache(x)\n}\n\nexport const Self = <T>(value: () => Codec<T>): Codec<T> =>\n  createCodec(\n    selfEncoder(() => value().enc),\n    selfDecoder(() => value().dec),\n  )\n","import {\n  Codec,\n  CodecType,\n  Decoder,\n  DecoderType,\n  Encoder,\n  EncoderType,\n  Enum as ScaleEnum,\n  StringRecord,\n  createCodec,\n} from \"scale-ts\"\nimport { Binary } from \"./Binary\"\nimport { mapObject } from \"@polkadot-api/utils\"\n\ntype Tuple<T, N extends number> = readonly [T, ...T[]] & { length: N }\n\ntype Push<T extends any[], V> = [...T, V]\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never\n\ntype LastOf<T> = UnionToIntersection<\n  T extends any ? () => T : never\n> extends () => infer R\n  ? R\n  : never\n\ntype TuplifyUnion<\n  T,\n  L = LastOf<T>,\n  N = [T] extends [never] ? true : false,\n> = true extends N ? [] : Push<TuplifyUnion<Exclude<T, L>>, L>\n\ntype RestrictedLenTuple<T, O extends StringRecord<any>> = Tuple<\n  T,\n  TuplifyUnion<keyof O> extends Tuple<any, infer V> ? V : 0\n>\n\ntype ExtractValue<\n  T extends { type: string; value?: any },\n  K extends string,\n> = T extends { type: K; value: infer R } ? R : never\n\nexport interface Discriminant<T extends { type: string; value?: any }> {\n  is<K extends T[\"type\"]>(\n    this: Enum<T>,\n    type: K,\n  ): this is Enum<{ type: K; value: ExtractValue<T, K> }>\n  as<K extends T[\"type\"]>(type: K): ExtractValue<T, K>\n}\n\nexport type Enum<T extends { type: string; value?: any }> = T & Discriminant<T>\n\ntype MyTuple<T> = [T, ...T[]]\n\ntype List<T> = Array<T>\n\ntype SeparateUndefined<T> = undefined extends T\n  ? undefined | Exclude<T, undefined>\n  : T\n\nexport type Anonymize<T> = SeparateUndefined<\n  T extends\n    | string\n    | number\n    | bigint\n    | boolean\n    | void\n    | undefined\n    | null\n    | symbol\n    | Binary\n    | Enum<{ type: string; value: any }>\n    | Uint8Array\n    ? T\n    : T extends (...args: infer Args) => infer R\n      ? (\n          ...args: {\n            [K in keyof Args]: Anonymize<Args[K]>\n          }\n        ) => Anonymize<R>\n      : T extends MyTuple<any>\n        ? {\n            [K in keyof T]: Anonymize<T[K]>\n          }\n        : T extends []\n          ? []\n          : T extends Array<infer A>\n            ? List<Anonymize<A>>\n            : {\n                [K in keyof T]: Anonymize<T[K]>\n              }\n>\n\nexport const _Enum = new Proxy(\n  {},\n  {\n    get(_, prop: string) {\n      return (value: string) =>\n        Enum<{ type: string; value: any }, string>(prop, value)\n    },\n  },\n)\n\nexport type EnumOption<\n  T extends { type: string; value?: any },\n  Key extends T[\"type\"],\n> = Anonymize<ExtractValue<T, Key>>\n\nexport type GetEnum<T extends Enum<{ type: string; value: any }>> = {\n  [K in T[\"type\"]]: (\n    ...args: ExtractValue<T, K> extends undefined\n      ? []\n      : [value: Anonymize<ExtractValue<T, K>>]\n  ) => T\n}\n\nexport const Enum: <\n  T extends { type: string; value?: any },\n  Key extends T[\"type\"],\n>(\n  type: Key,\n  ...args: ExtractValue<T, Key> extends undefined\n    ? []\n    : [value: Anonymize<ExtractValue<T, Key>>]\n) => Enum<\n  ExtractValue<T, Key> extends undefined\n    ? T\n    : ExtractValue<T, Key> extends never\n      ? T\n      : {\n          type: Key\n          value: ExtractValue<T, Key>\n        }\n> = ((_type: string, _value: any) => ({\n  as: (type: string) => {\n    if (type !== _type)\n      // TODO: fix error\n      throw new Error(`Enum.as(${type}) used with actual type ${_type}`)\n    return _value\n  },\n  is: (type: string) => type === _type,\n  type: _type,\n  value: _value,\n})) as any\n\nconst VariantEnc = <O extends StringRecord<Encoder<any>>>(\n  ...args: [inner: O, x?: RestrictedLenTuple<number, O>]\n): Encoder<\n  Enum<\n    {\n      [K in keyof O]: K extends string\n        ? { type: K; value: EncoderType<O[K]> }\n        : never\n    }[keyof O]\n  >\n> => {\n  const enc = ScaleEnum.enc<O>(...(args as [any, any]))\n  return (v) => enc({ tag: v.type, value: v.value })\n}\n\nconst VariantDec = <O extends StringRecord<Decoder<any>>>(\n  ...args: [inner: O, x?: RestrictedLenTuple<number, O>]\n): Decoder<\n  Enum<\n    {\n      [K in keyof O]: K extends string\n        ? { type: K; value: DecoderType<O[K]> }\n        : never\n    }[keyof O]\n  >\n> => {\n  const dec = ScaleEnum.dec<O>(...(args as [any, any]))\n  return (v) => {\n    const { tag, value } = dec(v)\n    return Enum(tag as any, value as any) as any\n  }\n}\n\nexport const Variant = <O extends StringRecord<Codec<any>>>(\n  inner: O,\n  ...args: [indexes?: RestrictedLenTuple<number, O>]\n): Codec<\n  Enum<\n    {\n      [K in keyof O]: K extends string\n        ? { type: K; value: CodecType<O[K]> }\n        : never\n    }[keyof O]\n  >\n> =>\n  createCodec(\n    VariantEnc(\n      mapObject(inner, ([encoder]) => encoder) as StringRecord<\n        O[keyof O][\"enc\"]\n      >,\n      ...(args as any[]),\n    ) as Encoder<\n      Enum<\n        {\n          [K in keyof O]: K extends string\n            ? { type: K; value: CodecType<O[K]> }\n            : never\n        }[keyof O]\n      >\n    >,\n    VariantDec(\n      mapObject(inner, ([, decoder]) => decoder) as StringRecord<\n        O[keyof O][\"dec\"]\n      >,\n      ...(args as any[]),\n    ) as Decoder<\n      Enum<\n        {\n          [K in keyof O]: K extends string\n            ? { type: K; value: CodecType<O[K]> }\n            : never\n        }[keyof O]\n      >\n    >,\n  )\n\nVariant.enc = VariantEnc\nVariant.dec = VariantDec\n","import {\n  Bytes,\n  CodecType,\n  Struct,\n  Vector,\n  _void,\n  enhanceCodec,\n  Hex,\n  Variant,\n  compactNumber,\n} from \"./scale\"\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nconst fourChars = enhanceCodec(\n  Bytes(4),\n  textEncoder.encode.bind(textEncoder),\n  textDecoder.decode.bind(textDecoder),\n)\n\nconst diggestVal = Struct({\n  engine: fourChars,\n  payload: Hex(),\n})\n\nconst diggest = Variant(\n  {\n    consensus: diggestVal,\n    seal: diggestVal,\n    preRuntime: diggestVal,\n    runtimeUpdated: _void,\n  },\n  [4, 5, 6, 8],\n)\n\nconst hex32 = Hex(32)\nexport const blockHeader = Struct({\n  parentHash: hex32,\n  number: compactNumber,\n  stateRoot: hex32,\n  extrinsicRoot: hex32,\n  digests: Vector(diggest),\n})\n\nexport type BlockHeader = CodecType<typeof blockHeader>\n","import { CodecType, Struct, Tuple, Vector, str, u8 } from \"scale-ts\"\nimport { lookup } from \"./lookup\"\nimport { pallets } from \"./pallets\"\nimport { Hex, compactNumber as ty } from \"../../scale\"\nexport type { V14Lookup } from \"./lookup\"\n\nconst docs = Vector(str)\n\nconst runtimeApi = Struct({\n  name: str,\n  methods: Vector(\n    Struct({\n      name: str,\n      inputs: Vector(\n        Struct({\n          name: str,\n          type: ty,\n        }),\n      ),\n      output: ty,\n      docs,\n    }),\n  ),\n  docs,\n})\n\nconst extrinsic = Struct({\n  version: u8,\n  address: ty,\n  call: ty,\n  signature: ty,\n  extra: ty,\n  signedExtensions: Vector(\n    Struct({\n      identifier: str,\n      type: ty,\n      additionalSigned: ty,\n    }),\n  ),\n})\nexport type V15Extrinsic = CodecType<typeof extrinsic>\n\nexport const v15 = Struct({\n  lookup,\n  pallets,\n  extrinsic,\n  type: ty,\n  apis: Vector(runtimeApi),\n  outerEnums: Struct({\n    call: ty,\n    event: ty,\n    error: ty,\n  }),\n  custom: Vector(Tuple(str, Struct({ type: ty, value: Hex() }))),\n})\nexport type V15 = CodecType<typeof v15>\n","import { compactNumber } from \"../../scale/compact\"\nimport {\n  CodecType,\n  Enum,\n  Option,\n  Struct,\n  Vector,\n  _void,\n  str,\n  u32,\n  u8,\n} from \"scale-ts\"\n\nconst oStr = Option(str)\nconst strs = Vector(str)\n\nconst primitive = Enum({\n  bool: _void,\n  char: _void,\n  str: _void,\n  u8: _void,\n  u16: _void,\n  u32: _void,\n  u64: _void,\n  u128: _void,\n  u256: _void,\n  i8: _void,\n  i16: _void,\n  i32: _void,\n  i64: _void,\n  i128: _void,\n  i256: _void,\n})\n\nconst fields = Vector(\n  Struct({\n    name: oStr,\n    type: compactNumber,\n    typeName: oStr,\n    docs: strs,\n  }),\n)\n\nconst arr = Struct({\n  len: u32,\n  type: compactNumber,\n})\n\nconst bitSequence = Struct({\n  bitStoreType: compactNumber,\n  bitOrderType: compactNumber,\n})\n\nconst variant = Vector(\n  Struct({\n    name: str,\n    fields,\n    index: u8,\n    docs: strs,\n  }),\n)\n\nconst def = Enum({\n  composite: fields,\n  variant,\n  sequence: compactNumber,\n  array: arr,\n  tuple: Vector(compactNumber),\n  primitive,\n  compact: compactNumber,\n  bitSequence,\n})\n\nconst param = Struct({\n  name: str,\n  type: Option(compactNumber),\n})\nconst params = Vector(param)\n\nconst entry = Struct({\n  id: compactNumber,\n  path: strs,\n  params,\n  def,\n  docs: strs,\n})\n\nexport const lookup = Vector(entry)\nexport type V14Lookup = CodecType<typeof lookup>\n","import { Hex, compactNumber } from \"@/codecs/scale\"\nimport {\n  Struct,\n  Option,\n  Vector,\n  u8,\n  str,\n  Enum,\n  _void,\n  CodecType,\n} from \"scale-ts\"\n\nconst hashType = Enum({\n  Blake2128: _void,\n  Blake2256: _void,\n  Blake2128Concat: _void,\n  Twox128: _void,\n  Twox256: _void,\n  Twox64Concat: _void,\n  Identity: _void,\n})\n\nconst hashers = Vector(hashType)\n\nconst storageMap = Struct({\n  hashers,\n  key: compactNumber,\n  value: compactNumber,\n})\n\nconst storageItem = Struct({\n  name: str,\n  modifier: u8,\n  type: Enum({\n    plain: compactNumber,\n    map: storageMap,\n  }),\n  fallback: Hex(),\n  docs: Vector(str),\n})\n\nconst storage = Option(\n  Struct({\n    prefix: str,\n    items: Vector(storageItem),\n  }),\n)\n\nexport const pallets = Vector(\n  Struct({\n    name: str,\n    storage,\n    calls: Option(compactNumber),\n    events: Option(compactNumber),\n    constants: Vector(\n      Struct({\n        name: str,\n        type: compactNumber,\n        value: Hex(),\n        docs: Vector(str),\n      }),\n    ),\n    errors: Option(compactNumber),\n    index: u8,\n    docs: Vector(str),\n  }),\n)\n\nexport type V15Pallets = CodecType<typeof pallets>\n","import { Enum, Struct, u32, Codec, createCodec } from \"scale-ts\"\nimport { v15 } from \"./v15\"\n\nconst unsupportedFn = () => {\n  throw new Error(\"Unsupported metadata version!\")\n}\n\nconst unsupported = createCodec(\n  unsupportedFn,\n  unsupportedFn,\n) as unknown as Codec<unknown>\n\nexport const metadata = Struct({\n  magicNumber: u32,\n  metadata: Enum({\n    v0: unsupported,\n    v1: unsupported,\n    v2: unsupported,\n    v3: unsupported,\n    v4: unsupported,\n    v5: unsupported,\n    v6: unsupported,\n    v7: unsupported,\n    v8: unsupported,\n    v9: unsupported,\n    v10: unsupported,\n    v11: unsupported,\n    v12: unsupported,\n    v13: unsupported,\n    v14: unsupported,\n    v15,\n  }),\n})\n","import { mergeUint8 } from \"@polkadot-api/utils\"\nimport { blake2b } from \"@noble/hashes/blake2b\"\n\nconst len32 = { dkLen: 32 }\nexport const Blake2256 = (encoded: Uint8Array) => blake2b(encoded, len32)\n\nconst len16 = { dkLen: 16 }\nexport const Blake2128 = (encoded: Uint8Array) => blake2b(encoded, len16)\n\nexport const Blake2128Concat = (encoded: Uint8Array) =>\n  mergeUint8(Blake2128(encoded), encoded)\n","export const Identity = (encoded: Uint8Array): Uint8Array => encoded\n","import { mergeUint8 } from \"@polkadot-api/utils\"\nimport { u64 } from \"scale-ts\"\nimport { h64 } from \"./h64\"\n\nexport const Twox128 = (input: Uint8Array): Uint8Array => {\n  const result = new Uint8Array(16)\n  const dv = new DataView(result.buffer)\n\n  dv.setBigUint64(0, h64(input), true)\n  dv.setBigUint64(8, h64(input, 1n), true)\n\n  return result\n}\n\nexport const Twox256 = (input: Uint8Array): Uint8Array => {\n  const result = new Uint8Array(32)\n  const dv = new DataView(result.buffer)\n\n  dv.setBigUint64(0, h64(input), true)\n  dv.setBigUint64(8, h64(input, 1n), true)\n  dv.setBigUint64(16, h64(input, 2n), true)\n  dv.setBigUint64(24, h64(input, 3n), true)\n\n  return result\n}\n\nexport const Twox64Concat = (encoded: Uint8Array): Uint8Array =>\n  mergeUint8(u64.enc(h64(encoded)), encoded)\n","// Adapted implementation based on: https://github.com/pierrec/js-xxhash/blob/7ff5ced282f97dba121109d7013e0fa80360398c/lib/xxhash64.js\n\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n\n// helper functions\nconst bigintFromU16 = (\n  v0: number,\n  v1: number,\n  v2: number,\n  v3: number,\n): bigint =>\n  new DataView(new Uint16Array([v0, v1, v2, v3]).buffer).getBigUint64(0, true)\n\nconst MASK_64 = 2n ** 64n - 1n\n\nconst rotl = (input: bigint, nBits: bigint) =>\n  ((input << nBits) & MASK_64) | (input >> (64n - nBits))\n\nconst multiply = (a: bigint, b: bigint) => (a * b) & MASK_64\n\nconst add = (a: bigint, b: bigint) => (a + b) & MASK_64\n\n// constants\nconst PRIME64_1 = 11400714785074694791n\nconst PRIME64_2 = 14029467366897019727n\nconst PRIME64_3 = 1609587929392839161n\nconst PRIME64_4 = 9650029242287828579n\nconst PRIME64_5 = 2870177450012600261n\n\nexport function h64(input: Uint8Array, seed: bigint = 0n) {\n  let v1 = add(add(seed, PRIME64_1), PRIME64_2)\n  let v2 = add(seed, PRIME64_2)\n  let v3 = seed\n  let v4 = seed - PRIME64_1\n  let totalLen = input.length\n  let memsize = 0\n  let memory: Uint8Array | null = null\n\n  ;(function update() {\n    let p = 0\n    let bEnd = p + totalLen\n\n    if (!totalLen) return\n\n    memory = new Uint8Array(32)\n\n    if (totalLen < 32) {\n      memory.set(input.subarray(0, totalLen), memsize)\n\n      memsize += totalLen\n      return\n    }\n\n    if (p <= bEnd - 32) {\n      const limit = bEnd - 32\n\n      do {\n        let other\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n        v1 = multiply(rotl(add(v1, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n\n        v2 = multiply(rotl(add(v2, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n\n        v3 = multiply(rotl(add(v3, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n        other = bigintFromU16(\n          (input[p + 1] << 8) | input[p],\n          (input[p + 3] << 8) | input[p + 2],\n          (input[p + 5] << 8) | input[p + 4],\n          (input[p + 7] << 8) | input[p + 6],\n        )\n        v4 = multiply(rotl(add(v4, multiply(other, PRIME64_2)), 31n), PRIME64_1)\n        p += 8\n      } while (p <= limit)\n    }\n\n    if (p < bEnd) {\n      memory.set(input.subarray(p, bEnd), memsize)\n      memsize = bEnd - p\n    }\n  })()\n\n  input = memory || input\n\n  let result: bigint\n  let p = 0\n\n  if (totalLen >= 32) {\n    result = rotl(v1, 1n)\n    result = add(result, rotl(v2, 7n))\n    result = add(result, rotl(v3, 12n))\n    result = add(result, rotl(v4, 18n))\n\n    v1 = multiply(rotl(multiply(v1, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v1\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n\n    v2 = multiply(rotl(multiply(v2, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v2\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n\n    v3 = multiply(rotl(multiply(v3, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v3\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n\n    v4 = multiply(rotl(multiply(v4, PRIME64_2), 31n), PRIME64_1)\n    result = result ^ v4\n    result = add(multiply(result, PRIME64_1), PRIME64_4)\n  } else {\n    result = add(seed, PRIME64_5)\n  }\n\n  result = add(result, BigInt(totalLen))\n\n  while (p <= memsize - 8) {\n    let temp = bigintFromU16(\n      (input[p + 1] << 8) | input[p],\n      (input[p + 3] << 8) | input[p + 2],\n      (input[p + 5] << 8) | input[p + 4],\n      (input[p + 7] << 8) | input[p + 6],\n    )\n    temp = multiply(rotl(multiply(temp, PRIME64_2), 31n), PRIME64_1)\n    result = add(multiply(rotl(result ^ temp, 27n), PRIME64_1), PRIME64_4)\n    p += 8\n  }\n\n  if (p + 4 <= memsize) {\n    let temp = multiply(\n      bigintFromU16(\n        (input[p + 1] << 8) | input[p],\n        (input[p + 3] << 8) | input[p + 2],\n        0,\n        0,\n      ),\n      PRIME64_1,\n    )\n\n    result = add(multiply(rotl(result ^ temp, 23n), PRIME64_2), PRIME64_3)\n    p += 4\n  }\n\n  while (p < memsize) {\n    const temp = multiply(bigintFromU16(input[p++], 0, 0, 0), PRIME64_5)\n    result = multiply(rotl(result ^ temp, 11n), PRIME64_1)\n  }\n\n  let temp = result >> 33n\n  result = multiply(result ^ temp, PRIME64_2)\n\n  temp = result >> 29n\n  result = multiply(result ^ temp, PRIME64_3)\n\n  temp = result >> 32n\n  result ^= temp\n\n  return result\n}\n","import { mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport { Codec, Decoder } from \"scale-ts\"\nimport { Blake2128Concat, Identity, Twox128, Twox64Concat } from \"./hashes\"\n\nexport type EncoderWithHash<T> = [Codec<T>, (input: Uint8Array) => Uint8Array]\n\nconst textEncoder = new TextEncoder()\n\nexport const Storage = (pallet: string) => {\n  const palledEncoded = Twox128(textEncoder.encode(pallet))\n  return <T, A extends Array<EncoderWithHash<any>>>(\n    name: string,\n    dec: Decoder<T>,\n    ...encoders: [...A]\n  ): {\n    enc: (\n      ...args: {\n        [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n      }\n    ) => string\n    dec: Decoder<T>\n    keyDecoder: (value: string) => {\n      [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n    }\n  } => {\n    const palletItemEncoded = mergeUint8(\n      palledEncoded,\n      Twox128(textEncoder.encode(name)),\n    )\n\n    const palletItemEncodedHex = toHex(palletItemEncoded)\n    const bytesToSkip = encoders\n      .map((e) => e[1])\n      .map((x) => {\n        if (x === Identity) return 0\n        if (x === Twox64Concat) return 8\n        if (x === Blake2128Concat) return 16\n        return null\n      })\n      .filter(Boolean) as Array<number>\n\n    const keyDecoder = (\n      key: string,\n    ): {\n      [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n    } => {\n      if (!key.startsWith(palletItemEncodedHex))\n        throw new Error(`key does not match this storage (${pallet}.${name})`)\n\n      if (bytesToSkip.length !== encoders.length)\n        throw new Error(\"Impossible to decode this key\")\n\n      if (encoders.length === 0) return [] as any\n\n      const argsKey = key.slice(palletItemEncodedHex.length)\n      const result = new Array<any>(encoders.length)\n      for (let i = 0, cur = 0; i < bytesToSkip.length; i++) {\n        const codec = encoders[i][0]\n        cur += bytesToSkip[i]\n        result[i] = codec.dec(argsKey.slice(cur * 2))\n        cur += codec.enc(result[i]).length\n      }\n      return result as any\n    }\n\n    const fns = encoders.map(\n      ([{ enc }, hash]) =>\n        (val: any) =>\n          hash(enc(val)),\n    )\n\n    const enc = (\n      ...args: {\n        [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n      }\n    ): string =>\n      toHex(\n        mergeUint8(palletItemEncoded, ...args.map((val, idx) => fns[idx](val))),\n      )\n\n    return {\n      enc,\n      dec,\n      keyDecoder,\n    }\n  }\n}\n"],"mappings":"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","names":["src_exports","__export","AccountId","Bin","Binary","Blake2128","Blake2128Concat","Blake2256","Enum","Hex","Identity","Self","Storage","Twox128","Twox256","Twox64Concat","Variant","_Enum","bitSequence","blockHeader","char","compactBn","compactNumber","fixedStr","h64","metadata","selfDecoder","selfEncoder","v15","__toCommonJS","import_scale_ts","import_blake2b","import_base","SS58_PREFIX","CHECKSUM_LENGTH","fromBufferToBase58","ss58Format","prefixBytes","publicKey","checksum","fromBase58ToBuffer","nBytes","address","decoded","expectedChecksum","prefixBytesToNumber","AccountId","bytes","dv","import_scale_ts","import_utils","textEncoder","textDecoder","_bytes","_hex","_str","_Binary","data","__privateAdd","__publicField","__privateGet","__privateSet","input","Binary","enc","nBytes","_enc","value","dec","_dec","Bin","import_scale_ts","import_scale_ts","compactNumber","compactBn","bitSequenceDecoder","data","bitsLen","compactNumber","bytesLen","bitSequenceEncoder","input","lenEncoded","result","bitSequence","import_scale_ts","char","str","import_utils","import_scale_ts","enc","nBytes","_enc","value","dec","_dec","Hex","import_scale_ts","textEncoder","textDecoder","fixedStr","nBytes","str","bytes","import_scale_ts","import_scale_ts","selfEncoder","value","cache","x","encoder","selfDecoder","decoder","result","Self","import_scale_ts","import_utils","_Enum","_","prop","value","Enum","_type","_value","type","VariantEnc","args","enc","ScaleEnum","v","VariantDec","dec","tag","Variant","inner","encoder","decoder","textEncoder","textDecoder","fourChars","diggestVal","Hex","diggest","Variant","hex32","blockHeader","compactNumber","import_scale_ts","import_scale_ts","oStr","strs","primitive","fields","compactNumber","arr","bitSequence","variant","def","param","params","entry","lookup","import_scale_ts","hashType","hashers","storageMap","compactNumber","storageItem","Hex","storage","pallets","docs","runtimeApi","compactNumber","extrinsic","v15","lookup","pallets","Hex","import_scale_ts","unsupportedFn","unsupported","metadata","v15","import_utils","import_blake2b","len32","Blake2256","encoded","len16","Blake2128","Blake2128Concat","Identity","encoded","import_utils","import_scale_ts","bigintFromU16","v0","v1","v2","v3","MASK_64","rotl","input","nBits","multiply","a","b","add","PRIME64_1","PRIME64_2","PRIME64_3","PRIME64_4","PRIME64_5","h64","seed","v4","totalLen","memsize","memory","p","bEnd","limit","other","result","temp","Twox128","input","result","dv","h64","Twox256","Twox64Concat","encoded","import_utils","textEncoder","Storage","pallet","palledEncoded","Twox128","name","dec","encoders","palletItemEncoded","palletItemEncodedHex","bytesToSkip","e","x","Identity","Twox64Concat","Blake2128Concat","keyDecoder","key","argsKey","result","i","cur","codec","fns","enc","hash","val","args","idx"]}