"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  getChecksumBuilder: () => getChecksumBuilder,
  getDynamicBuilder: () => getDynamicBuilder,
  getLookupFn: () => getLookupFn,
  getStaticBuilder: () => getStaticBuilder,
  getViewBuilder: () => getViewBuilder,
  primitiveTypes: () => primitiveTypes
});
module.exports = __toCommonJS(src_exports);

// src/lookups.ts
var voidVar = { type: "primitive", value: "_void" };
var getLookupFn = (lookupData) => {
  const lookups = /* @__PURE__ */ new Map();
  const from = /* @__PURE__ */ new Set();
  const withCache2 = (fn) => {
    return (id) => {
      let entry = lookups.get(id);
      if (entry)
        return entry;
      if (from.has(id)) {
        const entry2 = {
          id
        };
        lookups.set(id, entry2);
        return entry2;
      }
      from.add(id);
      const value = fn(id);
      entry = lookups.get(id);
      if (entry) {
        Object.assign(entry, value);
      } else {
        entry = {
          id,
          ...value
        };
        lookups.set(id, entry);
      }
      from.delete(id);
      return entry;
    };
  };
  let isAccountId32SearchOn = true;
  const getLookupEntryDef = withCache2((id) => {
    const { def, path, params } = lookupData[id];
    if (def.tag === "composite") {
      if (def.value.length === 0)
        return voidVar;
      if (def.value.length === 1) {
        if (isAccountId32SearchOn && path.join(",") === "sp_core,crypto,AccountId32") {
          isAccountId32SearchOn = false;
          return { type: "AccountId32" };
        }
        return getLookupEntryDef(def.value[0].type);
      }
      let allKey = true;
      const values = {};
      const innerDocs = {};
      def.value.forEach((x, idx) => {
        allKey = allKey && !!x.name;
        const key = x.name || idx;
        values[key] = getLookupEntryDef(x.type);
        innerDocs[key] = x.docs;
      });
      return allKey ? {
        type: "struct",
        value: values,
        innerDocs
      } : {
        type: "tuple",
        value: Object.values(values),
        innerDocs: Object.values(innerDocs)
      };
    }
    if (def.tag === "variant") {
      if (path.length === 1 && path[0] === "Option" && params.length === 1 && params[0].name === "T") {
        const value = getLookupEntryDef(params[0].type);
        return value.type === "primitive" && value.value === "_void" ? (
          // Option(_void) would return a Codec<undefined> which makes no sense
          // Therefore, we better treat it as a bool
          { type: "primitive", value: "bool" }
        ) : {
          type: "option",
          value
        };
      }
      if (path.length === 1 && path[0] === "Result" && params.length === 2 && params[0].name === "T" && params[1].name === "E") {
        return {
          type: "result",
          value: {
            ok: getLookupEntryDef(params[0].type),
            ko: getLookupEntryDef(params[1].type)
          }
        };
      }
      if (def.value.length === 0)
        return voidVar;
      const enumValue = {};
      const enumDocs = {};
      def.value.forEach((x) => {
        const key = x.name;
        enumDocs[key] = x.docs;
        if (x.fields.length === 0) {
          enumValue[key] = { ...voidVar, idx: x.index };
          return;
        }
        let allKey = true;
        const values = {};
        const innerDocs = {};
        x.fields.forEach((x2, idx) => {
          allKey = allKey && !!x2.name;
          const key2 = x2.name || idx;
          values[key2] = getLookupEntryDef(x2.type);
          innerDocs[key2] = x2.docs;
        });
        enumValue[key] = allKey ? {
          type: "struct",
          value: values,
          innerDocs,
          idx: x.index
        } : {
          type: "tuple",
          value: Object.values(values),
          innerDocs: Object.values(innerDocs),
          idx: x.index
        };
      });
      return {
        type: "enum",
        value: enumValue,
        innerDocs: enumDocs
      };
    }
    if (def.tag === "sequence") {
      const value = getLookupEntryDef(def.value);
      return {
        type: "sequence",
        value
      };
    }
    if (def.tag === "array") {
      const value = getLookupEntryDef(def.value.type);
      return {
        type: "array",
        value,
        len: def.value.len
      };
    }
    if (def.tag === "tuple") {
      if (def.value.length === 0)
        return voidVar;
      if (def.value.length === 1)
        return getLookupEntryDef(def.value[0]);
      const value = def.value.map((x) => getLookupEntryDef(x));
      const innerDocs = def.value.map((x) => lookupData[x].docs);
      return {
        type: "tuple",
        value,
        innerDocs
      };
    }
    if (def.tag === "primitive") {
      return {
        type: "primitive",
        value: def.value.tag
      };
    }
    if (def.tag === "compact") {
      const translated = getLookupEntryDef(def.value);
      const isBig = Number(translated.value.slice(1)) > 32;
      return {
        type: "compact",
        isBig
      };
    }
    return {
      type: def.tag
    };
  });
  return getLookupEntryDef;
};

// src/with-cache.ts
var withCache = (fn, onEnterCircular, onExitCircular) => (input, cache, stack, ...rest) => {
  const { id } = input;
  if (cache.has(id))
    return cache.get(id);
  if (stack.has(id)) {
    const res = onEnterCircular(() => cache.get(id), input, ...rest);
    cache.set(id, res);
    return res;
  }
  stack.add(id);
  let result = fn(input, cache, stack, ...rest);
  stack.delete(id);
  if (cache.has(id))
    result = onExitCircular(result, cache.get(id), input, ...rest);
  cache.set(id, result);
  return result;
};

// src/static-builder.ts
var primitiveTypes = {
  _void: "undefined",
  bool: "boolean",
  char: "string",
  str: "string",
  u8: "number",
  u16: "number",
  u32: "number",
  u64: "bigint",
  u128: "bigint",
  u256: "bigint",
  i8: "number",
  i16: "number",
  i32: "number",
  i64: "bigint",
  i128: "bigint",
  i256: "bigint",
  compactNumber: "number",
  compactBn: "bigint",
  bitSequence: "{bitsLen: number, bytes: Uint8Array}"
};
var toCamelCase = (...parts) => parts.map((part) => part[0].toUpperCase() + part.slice(1)).join("");
var getTypes = (varName) => primitiveTypes[varName] ?? varName;
var _buildSyntax = (input, cache, stack, declarations, getVarName) => {
  if (input.type === "primitive") {
    declarations.imports.add(input.value);
    return input.value;
  }
  if (input.type === "AccountId32") {
    declarations.imports.add("AccountId");
    const id = "_accountId";
    declarations.variables.set(id, {
      id,
      value: `AccountId()`,
      types: "SS58String",
      directDependencies: /* @__PURE__ */ new Set()
    });
    declarations.typeImports.add("SS58String");
    return id;
  }
  if (input.type === "compact") {
    const importVal = input.isBig ? "compactBn" : "compactNumber";
    declarations.imports.add(importVal);
    return importVal;
  }
  if (input.type === "bitSequence") {
    declarations.imports.add(input.type);
    return input.type;
  }
  if (input.type === "sequence" && input.value.type === "primitive" && input.value.value === "u8") {
    declarations.imports.add("Bin");
    declarations.typeImports.add("HexString");
    declarations.typeImports.add("Binary");
    const variable = {
      id: "_bytesSeq",
      value: "Bin()",
      types: "Binary",
      directDependencies: /* @__PURE__ */ new Set()
    };
    if (!declarations.variables.has(variable.id)) {
      declarations.variables.set(variable.id, variable);
    }
    return variable.id;
  }
  if (declarations.variables.has(getVarName(input.id, "circular")))
    return getVarName(input.id, "circular");
  if (declarations.variables.has(getVarName(input.id)))
    return getVarName(input.id);
  const buildNextSyntax = (nextInput) => buildSyntax(nextInput, cache, stack, declarations, getVarName);
  const buildVector = (id, inner, len) => {
    declarations.imports.add("Vector");
    const dependsVar = buildNextSyntax(inner);
    const args = len ? [dependsVar, len] : [dependsVar];
    const variable = {
      id,
      value: `Vector(${args.join(", ")})`,
      types: `Array<${getTypes(dependsVar)}>`,
      directDependencies: /* @__PURE__ */ new Set([dependsVar])
    };
    declarations.variables.set(id, variable);
    return id;
  };
  const buildTuple = (id, value) => {
    declarations.imports.add("Tuple");
    const deps = value.map(buildNextSyntax);
    const variable = {
      id,
      value: `Tuple(${deps.join(", ")})`,
      types: `[${deps.map(getTypes).join(", ")}]`,
      directDependencies: new Set(deps)
    };
    declarations.variables.set(id, variable);
    return id;
  };
  const buildStruct = (id, value) => {
    declarations.imports.add("Struct");
    const deps = Object.values(value).map(buildNextSyntax);
    const variable = {
      id,
      value: `Struct({${Object.keys(value).map((key, idx) => `${key}: ${deps[idx]}`).join(", ")}})`,
      types: `{${Object.keys(value).map((key, idx) => `${key}: ${getTypes(deps[idx])}`).join(", ")}}`,
      directDependencies: new Set(deps)
    };
    declarations.variables.set(id, variable);
    return id;
  };
  const varId = getVarName(input.id);
  if (input.type === "array") {
    if (input.value.type === "primitive" && input.value.value === "u8") {
      declarations.imports.add("Bin");
      declarations.variables.set(varId, {
        id: varId,
        value: `Bin(${input.len})`,
        types: "Binary",
        directDependencies: /* @__PURE__ */ new Set()
      });
      declarations.typeImports.add("HexString");
      declarations.typeImports.add("Binary");
      return varId;
    }
    return buildVector(varId, input.value, input.len);
  }
  if (input.type === "sequence")
    return buildVector(varId, input.value);
  if (input.type === "tuple")
    return buildTuple(varId, input.value);
  if (input.type === "struct")
    return buildStruct(varId, input.value);
  if (input.type === "option") {
    declarations.imports.add("Option");
    const inner = buildNextSyntax(input.value);
    const id = `_Option_${inner}`;
    const variable = {
      id,
      value: `Option(${inner})`,
      types: `${getTypes(inner)} | undefined`,
      directDependencies: /* @__PURE__ */ new Set([inner])
    };
    declarations.variables.set(id, variable);
    return id;
  }
  if (input.type === "result") {
    declarations.imports.add("Result");
    declarations.typeImports.add("ResultPayload");
    const ok = buildNextSyntax(input.value.ok);
    const ko = buildNextSyntax(input.value.ko);
    const id = `_Result_${ok}_${ko}`;
    const variable = {
      id,
      value: `Result(${ok}, ${ko})`,
      types: `ResultPayload<${getTypes(ok)}, ${getTypes(ko)}>`,
      directDependencies: /* @__PURE__ */ new Set([ok, ko])
    };
    declarations.variables.set(id, variable);
    return id;
  }
  declarations.imports.add("Variant");
  declarations.typeImports.add("Enum");
  const dependencies = Object.entries(input.value).map(([key, value]) => {
    if (value.type === "primitive") {
      declarations.imports.add(value.value);
      return value.value;
    }
    const varName = toCamelCase(varId, key);
    if (value.type === "tuple") {
      if (value.value.length === 1) {
        let result = buildNextSyntax(value.value[0]);
        if (!declarations.variables.has(varName)) {
          declarations.variables.set(varName, {
            id: varName,
            value: result,
            types: getTypes(result),
            directDependencies: /* @__PURE__ */ new Set([result])
          });
        }
        return varName;
      }
      return buildTuple(varName, value.value);
    } else {
      buildStruct(varName, value.value);
    }
    return varName;
  });
  const indexes = Object.values(input.value).map((x) => x.idx);
  const areIndexesSorted = indexes.every((idx, i) => idx === i);
  const innerEnum = `{${Object.keys(input.value).map(
    (key, idx) => `${key}: ${dependencies[idx]}`
  )}}${areIndexesSorted ? "" : `, [${indexes.join(", ")}]`}`;
  declarations.enums.set(
    varId,
    Object.keys(input.value).map(
      (key, idx) => `{type: '${key}', value: ${getTypes(dependencies[idx])}}`
    ).join(" | ")
  );
  declarations.variables.set(varId, {
    id: varId,
    value: `Variant(${innerEnum})`,
    types: `Enum<E${varId}>`,
    directDependencies: new Set(dependencies)
  });
  return varId;
};
var buildSyntax = withCache(
  _buildSyntax,
  (_getter, entry, declarations, getVarName) => {
    declarations.imports.add("Self");
    const nonCircular = getVarName(entry.id);
    const variable = {
      id: getVarName(entry.id, "circular"),
      types: nonCircular,
      value: `Self(() => ${nonCircular})`,
      directDependencies: /* @__PURE__ */ new Set([nonCircular])
    };
    declarations.variables.set(variable.id, variable);
    return variable.id;
  },
  (x) => x
);
var getStaticBuilder = (metadata) => {
  const declarations = {
    imports: /* @__PURE__ */ new Set(),
    typeImports: /* @__PURE__ */ new Set(["Codec"]),
    variables: /* @__PURE__ */ new Map(),
    enums: /* @__PURE__ */ new Map()
  };
  const lookupData = metadata.lookup;
  const getLookupEntryDef = getLookupFn(lookupData);
  const getVarName = (idx, ...post) => {
    const { path } = lookupData[idx];
    let parts;
    if (path.length === 0)
      parts = ["cdc" + idx];
    else if (path[0] === "sp_runtime")
      parts = [path.slice(-1)[0]];
    else if (
      // Junctions Junctions, etc
      path.length > 2 && path.slice(-2)[0].toUpperCase() === path.slice(-2)[1].toUpperCase()
    )
      parts = path.slice(0, -1);
    else
      parts = [...path];
    parts.push(...post);
    return toCamelCase(...parts);
  };
  const cache = /* @__PURE__ */ new Map();
  const buildDefinition = (id) => buildSyntax(
    getLookupEntryDef(id),
    cache,
    /* @__PURE__ */ new Set(),
    declarations,
    getVarName
  );
  const buildNamedTuple = (params, varName) => {
    if (declarations.variables.has(varName))
      return varName;
    const args = params.map((p) => p.type).map(buildDefinition);
    const names = params.map((p) => p.name);
    declarations.imports.add("Tuple");
    const variable = {
      id: varName,
      types: `[${names.map(
        (name, pIdx) => `${name[0].toUpperCase() + name.slice(1)}: ${getTypes(args[pIdx])}`
      ).join(", ")}]`,
      value: `Tuple(${args.join(", ")})`,
      directDependencies: new Set(args)
    };
    declarations.variables.set(varName, variable);
    return varName;
  };
  const EMPTY_TUPLE_VAR_NAME = "_emptyTuple";
  const getEmptyTuple = () => {
    if (!declarations.variables.has(EMPTY_TUPLE_VAR_NAME)) {
      declarations.imports.add("Tuple");
      declarations.variables.set(EMPTY_TUPLE_VAR_NAME, {
        id: EMPTY_TUPLE_VAR_NAME,
        types: `[]`,
        value: `Tuple()`,
        directDependencies: /* @__PURE__ */ new Set()
      });
    }
    return EMPTY_TUPLE_VAR_NAME;
  };
  const buildStorage = (pallet, entry) => {
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).storage.items.find((s) => s.name === entry);
    if (storageEntry.type.tag === "plain")
      return {
        key: getEmptyTuple(),
        val: buildDefinition(storageEntry.type.value)
      };
    const { key, value } = storageEntry.type.value;
    const val = buildDefinition(value);
    const returnKey = storageEntry.type.value.hashers.length === 1 ? buildNamedTuple(
      [{ name: "key", type: key }],
      getVarName(key, "Tupled")
    ) : buildDefinition(key);
    return { key: returnKey, val };
  };
  const buildRuntimeCall = (api, method) => {
    const entry = metadata.apis.find((x) => x.name === api)?.methods.find((x) => x.name === method);
    if (!entry)
      throw null;
    return {
      args: buildNamedTuple(entry.inputs, `${api}${method}Args`),
      value: buildDefinition(entry.output)
    };
  };
  const buildVariant = (type) => (pallet, name) => {
    const lookupEntry = getLookupEntryDef(
      metadata.pallets.find((x) => x.name === pallet)[type]
    );
    if (lookupEntry.type !== "enum")
      throw null;
    const returnVar = toCamelCase(buildDefinition(lookupEntry.id), name);
    if (!declarations.variables.has(returnVar) && lookupEntry.value[name].type === "primitive") {
      declarations.variables.set(returnVar, {
        id: returnVar,
        value: "_void",
        types: "undefined",
        directDependencies: /* @__PURE__ */ new Set()
      });
    }
    return returnVar;
  };
  const buildConstant = (pallet, constantName) => {
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).constants.find((s) => s.name === constantName);
    return buildDefinition(storageEntry.type);
  };
  const getCode = () => {
    const typeImports = `import type {${[...declarations.typeImports].join(
      ", "
    )}} from "@polkadot-api/client";
`;
    const varImports = `import {${[...declarations.imports].join(
      ", "
    )}} from "@polkadot-api/substrate-bindings";

`;
    const code = [...declarations.variables.values()].map((variable) => {
      const ePrefix = declarations.enums.has(variable.id) ? `type E${variable.id} = ${declarations.enums.get(
        variable.id
      )};
export ` : "";
      return `${ePrefix}type ${variable.id} = ${variable.types};
const ${variable.id}: Codec<${variable.id}> = ${variable.value};`;
    }).join("\n\n");
    return `${typeImports}${varImports}${code}`;
  };
  const getEnums = () => [...declarations.enums.keys()];
  const getTypeFromVarName = (varName) => primitiveTypes[varName] ?? declarations.variables.get(varName)?.types ?? varName;
  return {
    buildDefinition,
    buildStorage,
    buildEvent: buildVariant("events"),
    buildError: buildVariant("errors"),
    buildCall: buildVariant("calls"),
    buildRuntimeCall,
    buildConstant,
    getTypeFromVarName,
    getCode,
    getEnums
  };
};

// src/dynamic-builder.ts
var scale = __toESM(require("@polkadot-api/substrate-bindings"));
var import_utils = require("@polkadot-api/utils");
var _bytes = scale.Bin();
var _buildCodec = (input, cache, stack, _accountId) => {
  if (input.type === "primitive")
    return scale[input.value];
  if (input.type === "AccountId32")
    return _accountId;
  if (input.type === "compact")
    return scale.compact;
  if (input.type === "bitSequence")
    return scale.bitSequence;
  if (input.type === "sequence" && input.value.type === "primitive" && input.value.value === "u8") {
    return _bytes;
  }
  const buildNextCodec = (nextInput) => buildCodec(nextInput, cache, stack, _accountId);
  const buildVector = (inner2, len) => {
    const innerCodec = buildNextCodec(inner2);
    return len ? scale.Vector(innerCodec, len) : scale.Vector(innerCodec);
  };
  const buildTuple = (value) => scale.Tuple(...value.map(buildNextCodec));
  const buildStruct = (value) => {
    const inner2 = Object.fromEntries(
      Object.entries(value).map(([key, value2]) => [key, buildNextCodec(value2)])
    );
    return scale.Struct(inner2);
  };
  if (input.type === "array") {
    if (input.value.type === "primitive" && input.value.value === "u8")
      return scale.Bin(input.len);
    return buildVector(input.value, input.len);
  }
  if (input.type === "sequence")
    return buildVector(input.value);
  if (input.type === "tuple")
    return buildTuple(input.value);
  if (input.type === "struct")
    return buildStruct(input.value);
  if (input.type === "option")
    return scale.Option(buildNextCodec(input.value));
  if (input.type === "result")
    return scale.Result(
      buildNextCodec(input.value.ok),
      buildNextCodec(input.value.ko)
    );
  const dependencies = Object.values(input.value).map((v) => {
    if (v.type === "primitive")
      return scale._void;
    if (v.type === "tuple" && v.value.length === 1)
      return buildNextCodec(v.value[0]);
    return v.type === "tuple" ? buildTuple(v.value) : buildStruct(v.value);
  });
  const inner = Object.fromEntries(
    Object.keys(input.value).map((key, idx) => {
      return [key, dependencies[idx]];
    })
  );
  const indexes = Object.values(input.value).map((x) => x.idx);
  const areIndexesSorted = indexes.every((idx, i) => idx === i);
  return areIndexesSorted ? scale.Variant(inner) : scale.Variant(inner, indexes);
};
var buildCodec = withCache(_buildCodec, scale.Self, (res) => res);
var getDynamicBuilder = (metadata) => {
  const lookupData = metadata.lookup;
  const getLookupEntryDef = getLookupFn(lookupData);
  let _accountId = scale.AccountId();
  const cache = /* @__PURE__ */ new Map();
  const buildDefinition = (id) => buildCodec(getLookupEntryDef(id), cache, /* @__PURE__ */ new Set(), _accountId);
  const prefix = metadata.pallets.find((x) => x.name === "System")?.constants.find((x) => x.name === "SS58Prefix");
  let ss58Prefix;
  if (prefix) {
    try {
      const prefixVal = buildDefinition(prefix.type).dec(prefix.value);
      if (typeof prefixVal === "number") {
        ss58Prefix = prefixVal;
        _accountId = scale.AccountId(prefixVal);
      }
    } catch (_) {
    }
  }
  const storagePallets = /* @__PURE__ */ new Map();
  const buildStorage = (pallet, entry) => {
    let storagePallet = storagePallets.get(pallet);
    if (!storagePallet)
      storagePallets.set(pallet, storagePallet = scale.Storage(pallet));
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).storage.items.find((s) => s.name === entry);
    const storageWithFallback = (len, ...args) => {
      const result = storagePallet(...args);
      return {
        ...result,
        len,
        fallback: storageEntry.modifier === 1 ? result.dec(storageEntry.fallback) : void 0
      };
    };
    if (storageEntry.type.tag === "plain")
      return storageWithFallback(
        0,
        entry,
        buildDefinition(storageEntry.type.value).dec
      );
    const { key, value, hashers } = storageEntry.type.value;
    const val = buildDefinition(value);
    const hashes = hashers.map((x) => scale[x.tag]);
    const hashArgs = hashes.length === 1 ? [[buildDefinition(key), hashes[0]]] : getLookupEntryDef(key).value.map(
      (x, idx) => [
        buildDefinition(x.id),
        hashes[idx]
      ]
    );
    return storageWithFallback(hashes.length, entry, val.dec, ...hashArgs);
  };
  const buildEnumEntry = (entry) => {
    if (entry.type === "primitive")
      return scale._void;
    return entry.type === "tuple" ? scale.Tuple(
      ...Object.values(entry.value).map((l) => buildDefinition(l.id))
    ) : scale.Struct(
      (0, import_utils.mapObject)(entry.value, (x) => buildDefinition(x.id))
    );
  };
  const buildConstant = (pallet, constantName) => {
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).constants.find((s) => s.name === constantName);
    return buildDefinition(storageEntry.type);
  };
  const buildVariant = (type) => (pallet, name) => {
    const palletEntry = metadata.pallets.find((x) => x.name === pallet);
    const lookup = getLookupEntryDef(palletEntry[type]);
    if (lookup.type !== "enum")
      throw null;
    const entry = lookup.value[name];
    return {
      location: [palletEntry.index, entry.idx],
      codec: buildEnumEntry(lookup.value[name])
    };
  };
  const buildCall = (pallet, name) => {
    const palletEntry = metadata.pallets.find((x) => x.name === pallet);
    const lookup = getLookupEntryDef(palletEntry.calls);
    if (lookup.type !== "enum")
      throw null;
    const entry = lookup.value[name];
    return {
      location: [palletEntry.index, entry.idx],
      args: buildEnumEntry(lookup.value[name])
    };
  };
  const buildRuntimeCall = (api, method) => {
    const entry = metadata.apis.find((x) => x.name === api)?.methods.find((x) => x.name === method);
    if (!entry)
      throw null;
    return {
      args: scale.Tuple(...entry.inputs.map((x) => buildDefinition(x.type))),
      value: buildDefinition(entry.output)
    };
  };
  return {
    buildDefinition,
    buildStorage,
    buildEvent: buildVariant("events"),
    buildError: buildVariant("errors"),
    buildRuntimeCall,
    buildCall,
    buildConstant,
    ss58Prefix
  };
};

// src/checksum-builder.ts
var import_substrate_bindings = require("@polkadot-api/substrate-bindings");
var textEncoder = new TextEncoder();
var encodeText = textEncoder.encode.bind(textEncoder);
var getChecksum = (values) => {
  const res = new Uint8Array(values.length * 8);
  const dv = new DataView(res.buffer);
  for (let i = 0; i < values.length; i++)
    dv.setBigUint64(i * 8, values[i]);
  return (0, import_substrate_bindings.h64)(res);
};
var getStringChecksum = (values) => getChecksum(values.map((v) => (0, import_substrate_bindings.h64)(encodeText(v))));
var shapeIds = {
  primitive: 0n,
  vector: 1n,
  tuple: 2n,
  struct: 3n,
  option: 4n,
  result: 5n,
  enum: 6n
};
var runtimePrimitiveIds = {
  undefined: 0n,
  number: 1n,
  string: 2n,
  bigint: 3n,
  boolean: 4n,
  bitSequence: 5n,
  // {bitsLen: number, bytes: Uint8Array}
  byteSequence: 6n,
  // Binary
  accountId: 7n
  // SS58String
};
var metadataPrimitiveIds = {
  _void: runtimePrimitiveIds.undefined,
  bool: runtimePrimitiveIds.boolean,
  char: runtimePrimitiveIds.string,
  str: runtimePrimitiveIds.string,
  u8: runtimePrimitiveIds.number,
  u16: runtimePrimitiveIds.number,
  u32: runtimePrimitiveIds.number,
  u64: runtimePrimitiveIds.bigint,
  u128: runtimePrimitiveIds.bigint,
  u256: runtimePrimitiveIds.bigint,
  i8: runtimePrimitiveIds.number,
  i16: runtimePrimitiveIds.number,
  i32: runtimePrimitiveIds.number,
  i64: runtimePrimitiveIds.bigint,
  i128: runtimePrimitiveIds.bigint,
  i256: runtimePrimitiveIds.bigint
};
var structLikeBuilder = (shapeId, input, innerChecksum) => {
  const sortedEntries = Object.entries(input).sort(
    ([a], [b]) => a.localeCompare(b)
  );
  const keysChecksum = getStringChecksum(sortedEntries.map(([key]) => key));
  const valuesChecksum = getChecksum(
    sortedEntries.map(([, entry]) => innerChecksum(entry))
  );
  return getChecksum([shapeId, keysChecksum, valuesChecksum]);
};
var _buildChecksum = (input, cache, stack) => {
  if (cache.has(input.id))
    return cache.get(input.id);
  if (input.type === "primitive")
    return getChecksum([shapeIds.primitive, metadataPrimitiveIds[input.value]]);
  if (input.type === "compact")
    return getChecksum([
      shapeIds.primitive,
      runtimePrimitiveIds[input.isBig ? "bigint" : "number"]
    ]);
  if (input.type === "bitSequence")
    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.bitSequence]);
  if (input.type === "sequence" && input.value.type === "primitive" && input.value.value === "u8") {
    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.byteSequence]);
  }
  if (input.type === "AccountId32") {
    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.accountId]);
  }
  const buildNextChecksum = (nextInput) => buildChecksum(nextInput, cache, stack);
  if (input.type === "array") {
    const innerChecksum = buildNextChecksum(input.value);
    return getChecksum([shapeIds.vector, innerChecksum, BigInt(input.len)]);
  }
  if (input.type === "sequence") {
    const innerChecksum = buildNextChecksum(input.value);
    return getChecksum([shapeIds.vector, innerChecksum]);
  }
  const buildTuple = (entries) => getChecksum([shapeIds.tuple, ...entries.map(buildNextChecksum)]);
  const buildStruct = (entries) => structLikeBuilder(shapeIds.struct, entries, buildNextChecksum);
  if (input.type === "tuple")
    return buildTuple(input.value);
  if (input.type === "struct")
    return buildStruct(input.value);
  if (input.type === "option")
    return getChecksum([shapeIds.option, buildNextChecksum(input.value)]);
  if (input.type === "result")
    return getChecksum([
      shapeIds.result,
      buildNextChecksum(input.value.ok),
      buildNextChecksum(input.value.ko)
    ]);
  return structLikeBuilder(shapeIds.enum, input.value, (entry) => {
    switch (entry.type) {
      case "primitive":
        return metadataPrimitiveIds._void;
      case "tuple":
        return buildTuple(entry.value);
      case "struct":
        return buildStruct(entry.value);
    }
  });
};
var buildChecksum = withCache(
  _buildChecksum,
  () => 0n,
  (result) => result
);
var getChecksumBuilder = (metadata) => {
  const lookupData = metadata.lookup;
  const getLookupEntryDef = getLookupFn(lookupData);
  const cache = /* @__PURE__ */ new Map();
  const buildDefinition = (id) => buildChecksum(getLookupEntryDef(id), cache, /* @__PURE__ */ new Set());
  const buildStorage = (pallet, entry) => {
    try {
      const storageEntry = metadata.pallets.find((x) => x.name === pallet).storage.items.find((s) => s.name === entry);
      if (storageEntry.type.tag === "plain")
        return buildDefinition(storageEntry.type.value);
      const { key, value } = storageEntry.type.value;
      const val = buildDefinition(value);
      const returnKey = buildDefinition(key);
      return getChecksum([val, returnKey]);
    } catch (_) {
      return null;
    }
  };
  const buildRuntimeCall = (api, method) => {
    try {
      const entry = metadata.apis.find((x) => x.name === api)?.methods.find((x) => x.name === method);
      if (!entry)
        throw null;
      const argNamesChecksum = getStringChecksum(
        entry.inputs.map((x) => x.name)
      );
      const argValuesChecksum = getChecksum(
        entry.inputs.map((x) => buildDefinition(x.type))
      );
      const outputChecksum = buildDefinition(entry.output);
      return getChecksum([argNamesChecksum, argValuesChecksum, outputChecksum]);
    } catch (_) {
      return null;
    }
  };
  const buildComposite = (input) => {
    if (input.type === "primitive")
      return getChecksum([0n]);
    if (input.type === "tuple") {
      const values = Object.values(input.value).map(
        (entry) => buildDefinition(entry.id)
      );
      return getChecksum([shapeIds.tuple, ...values]);
    }
    return structLikeBuilder(
      shapeIds.struct,
      input.value,
      (entry) => buildDefinition(entry.id)
    );
  };
  const buildVariant = (variantType) => (pallet, name) => {
    try {
      const palletEntry = metadata.pallets.find((x) => x.name === pallet);
      const callsLookup = getLookupEntryDef(
        palletEntry[variantType]
      );
      if (callsLookup.type !== "enum")
        throw null;
      return buildComposite(callsLookup.value[name]);
    } catch (_) {
      return null;
    }
  };
  const buildConstant = (pallet, constantName) => {
    try {
      const storageEntry = metadata.pallets.find((x) => x.name === pallet).constants.find((s) => s.name === constantName);
      return buildDefinition(storageEntry.type);
    } catch (_) {
      return null;
    }
  };
  const toStringEnhancer = (fn) => (...args) => fn(...args)?.toString(32) ?? null;
  return {
    buildDefinition: toStringEnhancer(buildDefinition),
    buildRuntimeCall: toStringEnhancer(buildRuntimeCall),
    buildStorage: toStringEnhancer(buildStorage),
    buildCall: toStringEnhancer(buildVariant("calls")),
    buildEvent: toStringEnhancer(buildVariant("events")),
    buildError: toStringEnhancer(buildVariant("errors")),
    buildConstant: toStringEnhancer(buildConstant),
    buildComposite: toStringEnhancer(buildComposite)
  };
};

// src/view-builder/view-builder.ts
var import_utils3 = require("@polkadot-api/utils");
var import_substrate_bindings2 = require("@polkadot-api/substrate-bindings");

// src/view-builder/shaped-decoders.ts
var import_utils2 = require("@polkadot-api/utils");
var scale2 = __toESM(require("@polkadot-api/substrate-bindings"));
var toHex = import_utils2.toHex;
var createInputValueDecoder = (dec, rest) => scale2.createDecoder((_bytes2) => {
  const bytes = _bytes2;
  const start = bytes.i;
  const value = dec(bytes);
  const input = toHex(new Uint8Array(bytes.buffer.slice(start, bytes.i)));
  return { ...rest, value, input };
});
var primitiveShapedDecoder = (codec, input, rest) => {
  const decoder = createInputValueDecoder(input, { codec, ...rest });
  return Object.assign(decoder, {
    shape: { codec }
  });
};
var complexShapedDecoder = (shape, input, rest) => {
  const decoder = createInputValueDecoder(input, { codec: shape.codec, ...rest });
  return Object.assign(decoder, {
    shape
  });
};
var AccountIdShaped = (ss58Prefix = 42) => {
  const enhanced = scale2.enhanceDecoder(
    scale2.AccountId(ss58Prefix).dec,
    (address) => ({
      address,
      ss58Prefix
    })
  );
  return primitiveShapedDecoder("AccountId", enhanced, {});
};
var BytesArray = (len) => primitiveShapedDecoder("BytesArray", scale2.Hex.dec(len), { len });
var _primitives = [
  "_void",
  "bool",
  "char",
  "str",
  "u8",
  "u16",
  "u32",
  "i8",
  "i16",
  "i32",
  "u64",
  "u128",
  "u256",
  "i64",
  "i128",
  "i256",
  "compactNumber",
  "compactBn",
  "bitSequence"
];
var corePrimitives = Object.fromEntries(
  _primitives.map((x) => [x, primitiveShapedDecoder(x, scale2[x].dec)])
);
var primitives = {
  ...corePrimitives,
  Bytes: primitiveShapedDecoder("Bytes", scale2.Hex.dec()),
  BytesArray,
  AccountId: AccountIdShaped()
};
var Sequence = (input) => complexShapedDecoder(
  { codec: "Sequence", shape: input.shape },
  scale2.Vector.dec(input)
);
var ArrayDec = (input, len) => complexShapedDecoder(
  { codec: "Array", shape: input.shape, len },
  scale2.Vector.dec(input, len)
);
var TupleDec = (...input) => complexShapedDecoder(
  { codec: "Tuple", shape: input.map((x) => x.shape) },
  scale2.Tuple.dec(...input)
);
var StructDec = (input) => complexShapedDecoder(
  { codec: "Struct", shape: (0, import_utils2.mapStringRecord)(input, (x) => x.shape) },
  scale2.Struct.dec(input)
);
var EnumDec = (input, args) => complexShapedDecoder(
  { codec: "Enum", shape: (0, import_utils2.mapStringRecord)(input, (x) => x.shape) },
  scale2.Variant.dec(input, args)
);
var OptionDec = (input) => complexShapedDecoder(
  { codec: "Option", shape: input.shape },
  scale2.Option.dec(input)
);
var ResultDec = (ok, ko) => complexShapedDecoder(
  { codec: "Result", shape: { ok: ok.shape, ko: ko.shape } },
  scale2.Result.dec(ok, ko)
);
var selfDecoder = (value) => {
  let cache = (x) => {
    const decoder = value();
    const result2 = decoder;
    cache = decoder;
    return result2(x);
  };
  const result = (x) => cache(x);
  result.shape = { codec: "_void" };
  return result;
};
var complex = {
  Sequence,
  Array: ArrayDec,
  Tuple: TupleDec,
  Struct: StructDec,
  Enum: EnumDec,
  Option: OptionDec,
  Result: ResultDec
};

// src/view-builder/view-builder.ts
var emptyTuple = complex.Tuple();
var toUnshapedDecoder = (fn) => (...args) => {
  const value = fn(...args);
  return {
    shape: value.shape,
    decoder: value
  };
};
var withProp = (input, propName, propValue) => {
  const decoder = (0, import_substrate_bindings2.enhanceDecoder)(input, (x) => ({
    ...x,
    [propName]: propValue
  }));
  decoder.shape = input.shape;
  return decoder;
};
var addPath = (fn) => (input, cache, stack, lookupData, ...rest) => {
  const { path } = lookupData[input.id];
  const base = fn(input, cache, stack, lookupData, ...rest);
  return path.length ? withProp(base, "path", path) : base;
};
var _buildShapedDecoder = (input, cache, stack, lookupData, _accountId) => {
  if (input.type === "primitive")
    return primitives[input.value];
  if (input.type === "AccountId32")
    return _accountId;
  if (input.type === "compact")
    return input.isBig ? primitives.compactBn : primitives.compactNumber;
  if (input.type === "bitSequence")
    return primitives.bitSequence;
  if (input.type === "sequence" && input.value.type === "primitive" && input.value.value === "u8") {
    return primitives.Bytes;
  }
  const buildNext = (nextInput) => buildShapedDecoder(nextInput, cache, stack, lookupData, _accountId);
  const buildVector = (inner2, len) => {
    const _inner = buildNext(inner2);
    return len ? complex.Array(_inner, len) : complex.Sequence(_inner);
  };
  const buildTuple = (value, innerDocs) => withProp(complex.Tuple(...value.map(buildNext)), "innerDocs", innerDocs);
  const buildStruct = (value, innerDocs) => withProp(
    complex.Struct((0, import_utils3.mapStringRecord)(value, buildNext)),
    "innerDocs",
    innerDocs
  );
  if (input.type === "array") {
    if (input.value.type === "primitive" && input.value.value === "u8") {
      return primitives.BytesArray(input.len);
    }
    return buildVector(input.value, input.len);
  }
  if (input.type === "sequence")
    return buildVector(input.value);
  if (input.type === "tuple")
    return buildTuple(input.value, input.innerDocs);
  if (input.type === "struct")
    return buildStruct(input.value, input.innerDocs);
  if (input.type === "option")
    return complex.Option(buildNext(input.value));
  if (input.type === "result")
    return complex.Result(buildNext(input.value.ok), buildNext(input.value.ko));
  const dependencies = Object.values(input.value).map((v) => {
    if (v.type === "primitive")
      return primitives._void;
    if (v.type === "tuple" && v.value.length === 1) {
      return buildNext(v.value[0]);
    }
    return v.type === "tuple" ? buildTuple(v.value, v.innerDocs) : buildStruct(v.value, v.innerDocs);
  });
  const inner = Object.fromEntries(
    Object.keys(input.value).map((key, idx) => [key, dependencies[idx]])
  );
  const indexes = Object.values(input.value).map((x) => x.idx);
  const areIndexesSorted = indexes.every((idx, i) => idx === i);
  const withoutDocs = areIndexesSorted ? complex.Enum(inner) : complex.Enum(inner, indexes);
  const withDocs = (0, import_substrate_bindings2.enhanceDecoder)(withoutDocs, (val) => {
    const docs = input.innerDocs[val.value.type];
    return {
      ...val,
      docs
    };
  });
  withDocs.shape = withoutDocs.shape;
  return withDocs;
};
var withPath = addPath(_buildShapedDecoder);
var buildShapedDecoder = withCache(withPath, selfDecoder, (outter, inner) => {
  inner.shape = outter.shape;
  return outter;
});
var hexStrFromByte = (input) => `0x${input.toString(16).padEnd(2, "0")}`;
var getViewBuilder = (metadata) => {
  const lookupData = metadata.lookup;
  const cache = /* @__PURE__ */ new Map();
  const getDecoder = (id) => buildShapedDecoder(
    getLookupEntryDef(id),
    cache,
    /* @__PURE__ */ new Set(),
    lookupData,
    _accountId
  );
  const getLookupEntryDef = getLookupFn(lookupData);
  let _accountId = primitives.AccountId;
  const prefix = metadata.pallets.find((x) => x.name === "System")?.constants.find((x) => x.name === "SS58Prefix");
  if (prefix) {
    try {
      const prefixVal = getDecoder(prefix.type)(prefix.value).value;
      if (typeof prefixVal === "number")
        _accountId = AccountIdShaped(prefixVal);
    } catch (_) {
    }
  }
  const buildDefinition = toUnshapedDecoder(getDecoder);
  const callDecoder = (0, import_substrate_bindings2.createDecoder)((bytes) => {
    const palletIdx = import_substrate_bindings2.u8.dec(bytes);
    const palletEntry = metadata.pallets.find((x) => x.index === palletIdx);
    if (!palletEntry)
      throw new Error("Invalid Pallet");
    const pallet = {
      value: {
        name: palletEntry.name,
        idx: palletIdx
      },
      input: hexStrFromByte(bytes[0])
    };
    const callsDecoder = getDecoder(palletEntry.calls);
    const decoded = callsDecoder(bytes);
    if (decoded.codec !== "Enum")
      throw null;
    const call = {
      value: {
        name: decoded.value.type,
        idx: bytes[1]
      },
      input: hexStrFromByte(bytes[1]),
      docs: decoded.docs
    };
    return {
      pallet,
      call,
      args: { value: decoded.value.value, shape: callsDecoder.shape }
    };
  });
  const buildEnumEntry = toUnshapedDecoder(
    (entry, forceTuple = false) => {
      if (entry.type === "primitive")
        return forceTuple ? emptyTuple : primitives._void;
      return entry.type === "tuple" ? complex.Tuple(
        ...Object.values(entry.value).map((l) => getDecoder(l.id))
      ) : complex.Struct(
        (0, import_utils3.mapObject)(
          entry.value,
          (x) => getDecoder(x.id)
        )
      );
    }
  );
  const buildVariant = (type) => (pallet, name) => {
    const palletEntry = metadata.pallets.find((x) => x.name === pallet);
    const lookup = getLookupEntryDef(palletEntry[type]);
    if (lookup.type !== "enum")
      throw null;
    const event = lookup.value[name];
    return {
      location: [palletEntry.index, event.idx],
      view: buildEnumEntry(event, type === "calls")
    };
  };
  const buildConstant = (pallet, constantName) => {
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).constants.find((s) => s.name === constantName);
    return buildDefinition(storageEntry.type);
  };
  return {
    buildDefinition,
    callDecoder,
    buildEvent: buildVariant("events"),
    buildError: buildVariant("errors"),
    buildCall: buildVariant("calls"),
    buildConstant
  };
};
//# sourceMappingURL=index.js.map