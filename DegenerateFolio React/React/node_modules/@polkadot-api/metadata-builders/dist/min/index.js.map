{"version":3,"sources":["../../src/index.ts","../../src/lookups.ts","../../src/with-cache.ts","../../src/static-builder.ts","../../src/dynamic-builder.ts","../../src/checksum-builder.ts","../../src/view-builder/view-builder.ts","../../src/view-builder/shaped-decoders.ts"],"sourcesContent":["export * from \"./lookups\"\nexport * from \"./static-builder\"\nexport * from \"./dynamic-builder\"\nexport * from \"./checksum-builder\"\nexport * from \"./view-builder\"\n","import type { StringRecord, V14Lookup } from \"@polkadot-api/substrate-bindings\"\n\nexport type VoidVar = { type: \"primitive\"; value: \"_void\" }\nconst voidVar: VoidVar = { type: \"primitive\", value: \"_void\" }\n\nexport type MetadataPrimitives =\n  | \"bool\"\n  | \"char\"\n  | \"str\"\n  | \"u8\"\n  | \"u16\"\n  | \"u32\"\n  | \"u64\"\n  | \"u128\"\n  | \"u256\"\n  | \"i8\"\n  | \"i16\"\n  | \"i32\"\n  | \"i64\"\n  | \"i128\"\n  | \"i256\"\n\nexport type PrimitiveVar =\n  | {\n      type: \"primitive\"\n      value: MetadataPrimitives\n    }\n  | VoidVar\n\nexport type CompactVar = { type: \"compact\"; isBig: boolean }\nexport type BitSequenceVar = { type: \"bitSequence\" }\nexport type AccountId32 = { type: \"AccountId32\" }\nexport type TerminalVar =\n  | PrimitiveVar\n  | CompactVar\n  | BitSequenceVar\n  | AccountId32\n\nexport type TupleVar = {\n  type: \"tuple\"\n  value: LookupEntry[]\n  innerDocs: Array<string[]>\n}\nexport type StructVar = {\n  type: \"struct\"\n  value: StringRecord<LookupEntry>\n  innerDocs: StringRecord<string[]>\n}\nexport type EnumVar = {\n  type: \"enum\"\n  value: StringRecord<(TupleVar | StructVar | VoidVar) & { idx: number }>\n  innerDocs: StringRecord<string[]>\n}\nexport type OptionVar = {\n  type: \"option\"\n  value: LookupEntry\n}\nexport type ResultVar = {\n  type: \"result\"\n  value: { ok: LookupEntry; ko: LookupEntry }\n}\nexport type SequenceVar = {\n  type: \"sequence\"\n  value: LookupEntry\n}\nexport type ArrayVar = {\n  type: \"array\"\n  value: LookupEntry\n  len: number\n}\n\nexport type ComposedVar =\n  | TupleVar\n  | StructVar\n  | SequenceVar\n  | ArrayVar\n  | OptionVar\n  | ResultVar\n  | EnumVar\n\nexport type Var = TerminalVar | ComposedVar\n\nexport type LookupEntry = {\n  id: number\n} & Var\n\nexport const getLookupFn = (lookupData: V14Lookup) => {\n  const lookups = new Map<number, LookupEntry>()\n  const from = new Set<number>()\n\n  const withCache = (\n    fn: (id: number) => Var,\n  ): ((id: number) => LookupEntry) => {\n    return (id) => {\n      let entry = lookups.get(id)\n\n      if (entry) return entry\n\n      if (from.has(id)) {\n        const entry = {\n          id,\n        } as LookupEntry\n\n        lookups.set(id, entry)\n        return entry\n      }\n\n      from.add(id)\n      const value = fn(id)\n      entry = lookups.get(id)\n\n      if (entry) {\n        Object.assign(entry, value)\n      } else {\n        entry = {\n          id,\n          ...value,\n        }\n        lookups.set(id, entry!)\n      }\n      from.delete(id)\n      return entry\n    }\n  }\n\n  let isAccountId32SearchOn = true\n  const getLookupEntryDef = withCache((id): Var => {\n    const { def, path, params } = lookupData[id]\n\n    if (def.tag === \"composite\") {\n      if (def.value.length === 0) return voidVar\n\n      // used to be a \"pointer\"\n      if (def.value.length === 1) {\n        if (\n          isAccountId32SearchOn &&\n          path.join(\",\") === \"sp_core,crypto,AccountId32\"\n        ) {\n          isAccountId32SearchOn = false\n          return { type: \"AccountId32\" }\n        }\n        return getLookupEntryDef(def.value[0].type as number)\n      }\n\n      let allKey = true\n\n      const values: Record<string | number, LookupEntry> = {}\n      const innerDocs: Record<string | number, string[]> = {}\n      def.value.forEach((x, idx) => {\n        allKey = allKey && !!x.name\n        const key = x.name || idx\n        values[key] = getLookupEntryDef(x.type)\n        innerDocs[key] = x.docs\n      })\n\n      return allKey\n        ? {\n            type: \"struct\",\n            value: values as StringRecord<LookupEntry>,\n            innerDocs: innerDocs as StringRecord<string[]>,\n          }\n        : {\n            type: \"tuple\",\n            value: Object.values(values),\n            innerDocs: Object.values(innerDocs),\n          }\n    }\n\n    if (def.tag === \"variant\") {\n      if (\n        path.length === 1 &&\n        path[0] === \"Option\" &&\n        params.length === 1 &&\n        params[0].name === \"T\"\n      ) {\n        const value = getLookupEntryDef(params[0].type!)\n        return value.type === \"primitive\" && value.value === \"_void\"\n          ? // Option(_void) would return a Codec<undefined> which makes no sense\n            // Therefore, we better treat it as a bool\n            { type: \"primitive\", value: \"bool\" }\n          : {\n              type: \"option\",\n              value,\n            }\n      }\n\n      if (\n        path.length === 1 &&\n        path[0] === \"Result\" &&\n        params.length === 2 &&\n        params[0].name === \"T\" &&\n        params[1].name === \"E\"\n      ) {\n        return {\n          type: \"result\",\n          value: {\n            ok: getLookupEntryDef(params[0].type as number),\n            ko: getLookupEntryDef(params[1].type as number),\n          },\n        }\n      }\n      if (def.value.length === 0) return voidVar\n\n      const enumValue: StringRecord<EnumVar[\"value\"][keyof EnumVar[\"value\"]]> =\n        {}\n      const enumDocs: StringRecord<string[]> = {}\n\n      def.value.forEach((x) => {\n        const key = x.name\n        enumDocs[key] = x.docs\n\n        if (x.fields.length === 0) {\n          enumValue[key] = { ...voidVar, idx: x.index }\n          return\n        }\n\n        let allKey = true\n\n        const values: Record<string | number, LookupEntry> = {}\n        const innerDocs: Record<string | number, string[]> = {}\n\n        x.fields.forEach((x, idx) => {\n          allKey = allKey && !!x.name\n          const key = x.name || idx\n          values[key] = getLookupEntryDef(x.type as number)\n          innerDocs[key] = x.docs\n        })\n\n        enumValue[key] = allKey\n          ? {\n              type: \"struct\",\n              value: values as StringRecord<LookupEntry>,\n              innerDocs: innerDocs as StringRecord<string[]>,\n              idx: x.index,\n            }\n          : {\n              type: \"tuple\",\n              value: Object.values(values),\n              innerDocs: Object.values(innerDocs),\n              idx: x.index,\n            }\n      })\n\n      return {\n        type: \"enum\",\n        value: enumValue,\n        innerDocs: enumDocs,\n      }\n    }\n\n    if (def.tag === \"sequence\") {\n      const value = getLookupEntryDef(def.value as number)\n      return {\n        type: \"sequence\",\n        value,\n      }\n    }\n\n    if (def.tag === \"array\") {\n      const value = getLookupEntryDef(def.value.type as number)\n      return {\n        type: \"array\",\n        value,\n        len: def.value.len,\n      }\n    }\n\n    if (def.tag === \"tuple\") {\n      if (def.value.length === 0) return voidVar\n\n      // use to be a \"pointer\"\n      if (def.value.length === 1)\n        return getLookupEntryDef(def.value[0] as number)\n\n      const value = def.value.map((x) => getLookupEntryDef(x as number))\n      const innerDocs = def.value.map((x) => lookupData[x].docs)\n\n      return {\n        type: \"tuple\",\n        value,\n        innerDocs,\n      }\n    }\n\n    if (def.tag === \"primitive\") {\n      return {\n        type: \"primitive\",\n        value: def.value.tag,\n      }\n    }\n\n    if (def.tag === \"compact\") {\n      const translated = getLookupEntryDef(def.value as number) as PrimitiveVar\n      const isBig = Number(translated.value.slice(1)) > 32\n\n      return {\n        type: \"compact\",\n        isBig,\n      }\n    }\n\n    // bitSequence\n    return {\n      type: def.tag,\n    }\n  })\n\n  return getLookupEntryDef\n}\n","import { LookupEntry } from \"./lookups\"\n\ntype FnWithStack<Other extends Array<any>, T> = (\n  input: LookupEntry,\n  cache: Map<number, T>,\n  stack: Set<number>,\n  ...rest: Other\n) => T\n\nexport const withCache =\n  <Other extends Array<any>, T>(\n    fn: FnWithStack<Other, T>,\n    onEnterCircular: (\n      cacheGetter: () => T,\n      circular: LookupEntry,\n      ...rest: Other\n    ) => T,\n    onExitCircular: (\n      outter: T,\n      inner: T,\n      circular: LookupEntry,\n      ...rest: Other\n    ) => T,\n  ): FnWithStack<Other, T> =>\n  (input, cache, stack, ...rest) => {\n    const { id } = input\n    if (cache.has(id)) return cache.get(id)!\n\n    if (stack.has(id)) {\n      const res = onEnterCircular(() => cache.get(id)!, input, ...rest)\n      cache.set(id, res)\n      return res\n    }\n\n    stack.add(id)\n    let result = fn(input, cache, stack, ...rest)\n    stack.delete(id)\n\n    if (cache.has(id))\n      result = onExitCircular(result, cache.get(id)!, input, ...rest)\n\n    cache.set(id, result)\n    return result\n  }\n","import { StringRecord, V15 } from \"@polkadot-api/substrate-bindings\"\nimport { LookupEntry, getLookupFn } from \"./lookups\"\nimport { withCache } from \"./with-cache\"\n\ntype MetadataPrimitives =\n  | \"bool\"\n  | \"char\"\n  | \"str\"\n  | \"u8\"\n  | \"u16\"\n  | \"u32\"\n  | \"u64\"\n  | \"u128\"\n  | \"u256\"\n  | \"i8\"\n  | \"i16\"\n  | \"i32\"\n  | \"i64\"\n  | \"i128\"\n  | \"i256\"\n\nexport const primitiveTypes: Record<\n  MetadataPrimitives | \"_void\" | \"compactNumber\" | \"compactBn\" | \"bitSequence\",\n  string\n> = {\n  _void: \"undefined\",\n  bool: \"boolean\",\n  char: \"string\",\n  str: \"string\",\n  u8: \"number\",\n  u16: \"number\",\n  u32: \"number\",\n  u64: \"bigint\",\n  u128: \"bigint\",\n  u256: \"bigint\",\n  i8: \"number\",\n  i16: \"number\",\n  i32: \"number\",\n  i64: \"bigint\",\n  i128: \"bigint\",\n  i256: \"bigint\",\n  compactNumber: \"number\",\n  compactBn: \"bigint\",\n  bitSequence: \"{bitsLen: number, bytes: Uint8Array}\",\n}\n\nexport interface Variable {\n  id: string\n  types: string\n  value: string\n  directDependencies: Set<string>\n}\n\nexport interface CodeDeclarations {\n  imports: Set<string>\n  typeImports: Set<string>\n  enums: Map<string, string>\n  variables: Map<string, Variable>\n}\n\nconst toCamelCase = (...parts: string[]): string =>\n  parts.map((part) => part[0].toUpperCase() + part.slice(1)).join(\"\")\n\nconst getTypes = (varName: string) =>\n  primitiveTypes[varName as keyof typeof primitiveTypes] ?? varName\n\nconst _buildSyntax = (\n  input: LookupEntry,\n  cache: Map<number, string>,\n  stack: Set<number>,\n  declarations: CodeDeclarations,\n  getVarName: (id: number, ...post: string[]) => string,\n): string => {\n  if (input.type === \"primitive\") {\n    declarations.imports.add(input.value)\n    return input.value\n  }\n\n  if (input.type === \"AccountId32\") {\n    declarations.imports.add(\"AccountId\")\n    const id = \"_accountId\"\n    declarations.variables.set(id, {\n      id,\n      value: `AccountId()`,\n      types: \"SS58String\",\n      directDependencies: new Set<string>(),\n    })\n    declarations.typeImports.add(\"SS58String\")\n    return id\n  }\n\n  if (input.type === \"compact\") {\n    const importVal = input.isBig ? \"compactBn\" : \"compactNumber\"\n    declarations.imports.add(importVal)\n    return importVal\n  }\n\n  if (input.type === \"bitSequence\") {\n    declarations.imports.add(input.type)\n    return input.type\n  }\n\n  if (\n    input.type === \"sequence\" &&\n    input.value.type === \"primitive\" &&\n    input.value.value === \"u8\"\n  ) {\n    declarations.imports.add(\"Bin\")\n    declarations.typeImports.add(\"HexString\")\n    declarations.typeImports.add(\"Binary\")\n    const variable = {\n      id: \"_bytesSeq\",\n      value: \"Bin()\",\n      types: \"Binary\",\n      directDependencies: new Set<string>(),\n    }\n\n    if (!declarations.variables.has(variable.id)) {\n      declarations.variables.set(variable.id, variable)\n    }\n\n    return variable.id\n  }\n\n  if (declarations.variables.has(getVarName(input.id, \"circular\")))\n    return getVarName(input.id, \"circular\")\n\n  if (declarations.variables.has(getVarName(input.id)))\n    return getVarName(input.id)\n\n  const buildNextSyntax = (nextInput: LookupEntry): string =>\n    buildSyntax(nextInput, cache, stack, declarations, getVarName)\n\n  const buildVector = (id: string, inner: LookupEntry, len?: number) => {\n    declarations.imports.add(\"Vector\")\n    const dependsVar = buildNextSyntax(inner)\n    const args = len ? [dependsVar, len] : [dependsVar]\n    const variable = {\n      id,\n      value: `Vector(${args.join(\", \")})`,\n      types: `Array<${getTypes(dependsVar)}>`,\n      directDependencies: new Set<string>([dependsVar]),\n    }\n    declarations.variables.set(id, variable)\n    return id\n  }\n\n  const buildTuple = (id: string, value: LookupEntry[]) => {\n    declarations.imports.add(\"Tuple\")\n    const deps = value.map(buildNextSyntax)\n    const variable = {\n      id,\n      value: `Tuple(${deps.join(\", \")})`,\n      types: `[${deps.map(getTypes).join(\", \")}]`,\n      directDependencies: new Set(deps),\n    }\n    declarations.variables.set(id, variable)\n    return id\n  }\n\n  const buildStruct = (id: string, value: StringRecord<LookupEntry>) => {\n    declarations.imports.add(\"Struct\")\n    const deps = Object.values(value).map(buildNextSyntax)\n    const variable = {\n      id,\n      value: `Struct({${Object.keys(value)\n        .map((key, idx) => `${key}: ${deps[idx]}`)\n        .join(\", \")}})`,\n      types: `{${Object.keys(value)\n        .map((key, idx) => `${key}: ${getTypes(deps[idx])}`)\n        .join(\", \")}}`,\n      directDependencies: new Set(deps),\n    }\n    declarations.variables.set(id, variable)\n    return id\n  }\n\n  const varId = getVarName(input.id)\n  if (input.type === \"array\") {\n    // Bytes case\n    if (input.value.type === \"primitive\" && input.value.value === \"u8\") {\n      declarations.imports.add(\"Bin\")\n      declarations.variables.set(varId, {\n        id: varId,\n        value: `Bin(${input.len})`,\n        types: \"Binary\",\n        directDependencies: new Set<string>(),\n      })\n      declarations.typeImports.add(\"HexString\")\n      declarations.typeImports.add(\"Binary\")\n      return varId\n    }\n\n    // non-fixed size Vector case\n    return buildVector(varId, input.value, input.len)\n  }\n\n  if (input.type === \"sequence\") return buildVector(varId, input.value)\n  if (input.type === \"tuple\") return buildTuple(varId, input.value)\n  if (input.type === \"struct\") return buildStruct(varId, input.value)\n\n  if (input.type === \"option\") {\n    declarations.imports.add(\"Option\")\n    const inner = buildNextSyntax(input.value)\n    const id = `_Option_${inner}`\n    const variable = {\n      id,\n      value: `Option(${inner})`,\n      types: `${getTypes(inner)} | undefined`,\n      directDependencies: new Set<string>([inner]),\n    }\n    declarations.variables.set(id, variable)\n    return id\n  }\n\n  if (input.type === \"result\") {\n    declarations.imports.add(\"Result\")\n    declarations.typeImports.add(\"ResultPayload\")\n    const ok = buildNextSyntax(input.value.ok)\n    const ko = buildNextSyntax(input.value.ko)\n    const id = `_Result_${ok}_${ko}`\n    const variable = {\n      id,\n      value: `Result(${ok}, ${ko})`,\n      types: `ResultPayload<${getTypes(ok)}, ${getTypes(ko)}>`,\n      directDependencies: new Set<string>([ok, ko]),\n    }\n    declarations.variables.set(id, variable)\n    return id\n  }\n\n  // it has to be an enum by now\n  declarations.imports.add(\"Variant\")\n  declarations.typeImports.add(\"Enum\")\n  const dependencies = Object.entries(input.value).map(([key, value]) => {\n    if (value.type === \"primitive\") {\n      declarations.imports.add(value.value)\n      return value.value\n    }\n\n    const varName = toCamelCase(varId, key)\n    if (value.type === \"tuple\") {\n      if (value.value.length === 1) {\n        let result: string = buildNextSyntax(value.value[0])\n\n        if (!declarations.variables.has(varName)) {\n          declarations.variables.set(varName, {\n            id: varName,\n            value: result,\n            types: getTypes(result),\n            directDependencies: new Set([result]),\n          })\n        }\n\n        return varName\n      }\n      return buildTuple(varName, value.value)\n    } else {\n      buildStruct(varName, value.value)\n    }\n    return varName\n  })\n\n  const indexes = Object.values(input.value).map((x) => x.idx)\n  const areIndexesSorted = indexes.every((idx, i) => idx === i)\n\n  const innerEnum = `{${Object.keys(input.value).map(\n    (key, idx) => `${key}: ${dependencies[idx]}`,\n  )}}${areIndexesSorted ? \"\" : `, [${indexes.join(\", \")}]`}`\n\n  declarations.enums.set(\n    varId,\n    Object.keys(input.value)\n      .map(\n        (key, idx) => `{type: '${key}', value: ${getTypes(dependencies[idx])}}`,\n      )\n      .join(\" | \"),\n  )\n\n  declarations.variables.set(varId, {\n    id: varId,\n    value: `Variant(${innerEnum})`,\n    types: `Enum<E${varId}>`,\n    directDependencies: new Set<string>(dependencies),\n  })\n  return varId\n}\n\nconst buildSyntax = withCache(\n  _buildSyntax,\n  (_getter, entry, declarations, getVarName) => {\n    declarations.imports.add(\"Self\")\n\n    const nonCircular = getVarName(entry.id)\n    const variable: Variable = {\n      id: getVarName(entry.id, \"circular\"),\n      types: nonCircular,\n      value: `Self(() => ${nonCircular})`,\n      directDependencies: new Set([nonCircular]),\n    }\n    declarations.variables.set(variable.id, variable)\n    return variable.id\n  },\n  (x) => x,\n)\n\nexport const getStaticBuilder = (metadata: V15) => {\n  const declarations: CodeDeclarations = {\n    imports: new Set<string>(),\n    typeImports: new Set<string>([\"Codec\"]),\n    variables: new Map(),\n    enums: new Map(),\n  }\n\n  const lookupData = metadata.lookup\n  const getLookupEntryDef = getLookupFn(lookupData)\n\n  const getVarName = (idx: number, ...post: string[]): string => {\n    const { path } = lookupData[idx]\n    let parts: string[]\n    if (path.length === 0) parts = [\"cdc\" + idx]\n    else if (path[0] === \"sp_runtime\") parts = [path.slice(-1)[0]]\n    else if (\n      // Junctions Junctions, etc\n      path.length > 2 &&\n      path.slice(-2)[0].toUpperCase() === path.slice(-2)[1].toUpperCase()\n    )\n      parts = path.slice(0, -1)\n    else parts = [...path]\n\n    parts.push(...post)\n\n    return toCamelCase(...parts)\n  }\n\n  const cache = new Map()\n  const buildDefinition = (id: number) =>\n    buildSyntax(\n      getLookupEntryDef(id),\n      cache,\n      new Set(),\n      declarations,\n      getVarName,\n    )\n\n  const buildNamedTuple = (\n    params: Array<{ name: string; type: number }>,\n    varName: string,\n  ) => {\n    if (declarations.variables.has(varName)) return varName\n\n    const args = params.map((p) => p.type).map(buildDefinition)\n    const names = params.map((p) => p.name)\n    declarations.imports.add(\"Tuple\")\n\n    const variable: Variable = {\n      id: varName,\n      types: `[${names\n        .map(\n          (name, pIdx) =>\n            `${name[0].toUpperCase() + name.slice(1)}: ${getTypes(args[pIdx])}`,\n        )\n        .join(\", \")}]`,\n      value: `Tuple(${args.join(\", \")})`,\n      directDependencies: new Set(args),\n    }\n    declarations.variables.set(varName, variable)\n\n    return varName\n  }\n\n  const EMPTY_TUPLE_VAR_NAME = \"_emptyTuple\"\n  const getEmptyTuple = () => {\n    if (!declarations.variables.has(EMPTY_TUPLE_VAR_NAME)) {\n      declarations.imports.add(\"Tuple\")\n\n      declarations.variables.set(EMPTY_TUPLE_VAR_NAME, {\n        id: EMPTY_TUPLE_VAR_NAME,\n        types: `[]`,\n        value: `Tuple()`,\n        directDependencies: new Set(),\n      })\n    }\n    return EMPTY_TUPLE_VAR_NAME\n  }\n\n  const buildStorage = (pallet: string, entry: string) => {\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .storage!.items.find((s) => s.name === entry)!\n\n    if (storageEntry.type.tag === \"plain\")\n      return {\n        key: getEmptyTuple(),\n        val: buildDefinition(storageEntry.type.value),\n      }\n\n    const { key, value } = storageEntry.type.value\n    const val = buildDefinition(value)\n\n    const returnKey =\n      storageEntry.type.value.hashers.length === 1\n        ? buildNamedTuple(\n            [{ name: \"key\", type: key }],\n            getVarName(key, \"Tupled\"),\n          )\n        : buildDefinition(key)\n\n    return { key: returnKey, val }\n  }\n\n  const buildRuntimeCall = (api: string, method: string) => {\n    const entry = metadata.apis\n      .find((x) => x.name === api)\n      ?.methods.find((x) => x.name === method)\n    if (!entry) throw null\n    return {\n      args: buildNamedTuple(entry.inputs, `${api}${method}Args`),\n      value: buildDefinition(entry.output),\n    }\n  }\n\n  const buildVariant =\n    (type: \"errors\" | \"events\" | \"calls\") => (pallet: string, name: string) => {\n      const lookupEntry = getLookupEntryDef(\n        metadata.pallets.find((x) => x.name === pallet)![type]! as number,\n      )\n      if (lookupEntry.type !== \"enum\") throw null\n\n      const returnVar = toCamelCase(buildDefinition(lookupEntry.id), name)\n\n      if (\n        !declarations.variables.has(returnVar) &&\n        lookupEntry.value[name].type === \"primitive\"\n      ) {\n        declarations.variables.set(returnVar, {\n          id: returnVar,\n          value: \"_void\",\n          types: \"undefined\",\n          directDependencies: new Set(),\n        })\n      }\n\n      return returnVar\n    }\n\n  const buildConstant = (pallet: string, constantName: string) => {\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .constants!.find((s) => s.name === constantName)!\n\n    return buildDefinition(storageEntry.type as number)\n  }\n\n  const getCode = (): string => {\n    const typeImports = `import type {${[...declarations.typeImports].join(\n      \", \",\n    )}} from \"@polkadot-api/client\";\\n`\n\n    const varImports = `import {${[...declarations.imports].join(\n      \", \",\n    )}} from \"@polkadot-api/substrate-bindings\";\\n\\n`\n\n    const code = [...declarations.variables.values()]\n      .map((variable) => {\n        const ePrefix = declarations.enums.has(variable.id)\n          ? `type E${variable.id} = ${declarations.enums.get(\n              variable.id,\n            )!};\\nexport `\n          : \"\"\n        return `${ePrefix}type ${variable.id} = ${variable.types};\nconst ${variable.id}: Codec<${variable.id}> = ${variable.value};`\n      })\n      .join(\"\\n\\n\")\n\n    return `${typeImports}${varImports}${code}`\n  }\n\n  const getEnums = () => [...declarations.enums.keys()]\n\n  const getTypeFromVarName = (varName: string) =>\n    primitiveTypes[varName as keyof typeof primitiveTypes] ??\n    declarations.variables.get(varName)?.types ??\n    varName\n\n  return {\n    buildDefinition,\n    buildStorage,\n    buildEvent: buildVariant(\"events\"),\n    buildError: buildVariant(\"errors\"),\n    buildCall: buildVariant(\"calls\"),\n    buildRuntimeCall,\n    buildConstant,\n    getTypeFromVarName,\n    getCode,\n    getEnums,\n  }\n}\n","import type { Codec, StringRecord, V15 } from \"@polkadot-api/substrate-bindings\"\nimport type { EnumVar, LookupEntry, TupleVar } from \"./lookups\"\nimport { getLookupFn } from \"./lookups\"\nimport * as scale from \"@polkadot-api/substrate-bindings\"\nimport { withCache } from \"./with-cache\"\nimport { mapObject } from \"@polkadot-api/utils\"\n\nconst _bytes = scale.Bin()\n\nconst _buildCodec = (\n  input: LookupEntry,\n  cache: Map<number, Codec<any>>,\n  stack: Set<number>,\n  _accountId: Codec<scale.SS58String>,\n): Codec<any> => {\n  if (input.type === \"primitive\") return scale[input.value]\n  if (input.type === \"AccountId32\") return _accountId\n  if (input.type === \"compact\") return scale.compact\n  if (input.type === \"bitSequence\") return scale.bitSequence\n\n  if (\n    input.type === \"sequence\" &&\n    input.value.type === \"primitive\" &&\n    input.value.value === \"u8\"\n  ) {\n    return _bytes\n  }\n\n  const buildNextCodec = (nextInput: LookupEntry): Codec<any> =>\n    buildCodec(nextInput, cache, stack, _accountId)\n\n  const buildVector = (inner: LookupEntry, len?: number) => {\n    const innerCodec = buildNextCodec(inner)\n    return len ? scale.Vector(innerCodec, len) : scale.Vector(innerCodec)\n  }\n\n  const buildTuple = (value: LookupEntry[]) =>\n    scale.Tuple(...value.map(buildNextCodec))\n\n  const buildStruct = (value: StringRecord<LookupEntry>) => {\n    const inner = Object.fromEntries(\n      Object.entries(value).map(([key, value]) => [key, buildNextCodec(value)]),\n    ) as StringRecord<Codec<any>>\n    return scale.Struct(inner)\n  }\n\n  if (input.type === \"array\") {\n    // Bytes case\n    if (input.value.type === \"primitive\" && input.value.value === \"u8\")\n      return scale.Bin(input.len)\n\n    return buildVector(input.value, input.len)\n  }\n\n  if (input.type === \"sequence\") return buildVector(input.value)\n  if (input.type === \"tuple\") return buildTuple(input.value)\n  if (input.type === \"struct\") return buildStruct(input.value)\n\n  if (input.type === \"option\") return scale.Option(buildNextCodec(input.value))\n\n  if (input.type === \"result\")\n    return scale.Result(\n      buildNextCodec(input.value.ok),\n      buildNextCodec(input.value.ko),\n    )\n\n  // it has to be an enum by now\n  const dependencies = Object.values(input.value).map((v) => {\n    if (v.type === \"primitive\") return scale._void\n    if (v.type === \"tuple\" && v.value.length === 1)\n      return buildNextCodec(v.value[0])\n\n    return v.type === \"tuple\" ? buildTuple(v.value) : buildStruct(v.value)\n  })\n\n  const inner = Object.fromEntries(\n    Object.keys(input.value).map((key, idx) => {\n      return [key, dependencies[idx]]\n    }),\n  ) as StringRecord<Codec<any>>\n\n  const indexes = Object.values(input.value).map((x) => x.idx)\n  const areIndexesSorted = indexes.every((idx, i) => idx === i)\n\n  return areIndexesSorted\n    ? scale.Variant(inner)\n    : scale.Variant(inner, indexes as any)\n}\nconst buildCodec = withCache(_buildCodec, scale.Self, (res) => res)\n\nexport const getDynamicBuilder = (metadata: V15) => {\n  const lookupData = metadata.lookup\n  const getLookupEntryDef = getLookupFn(lookupData)\n  let _accountId = scale.AccountId()\n\n  const cache = new Map()\n  const buildDefinition = (id: number): Codec<any> =>\n    buildCodec(getLookupEntryDef(id), cache, new Set(), _accountId)\n\n  const prefix = metadata.pallets\n    .find((x) => x.name === \"System\")\n    ?.constants.find((x) => x.name === \"SS58Prefix\")\n\n  let ss58Prefix: number | undefined\n  if (prefix) {\n    try {\n      const prefixVal = buildDefinition(prefix.type).dec(prefix.value)\n      if (typeof prefixVal === \"number\") {\n        ss58Prefix = prefixVal\n        _accountId = scale.AccountId(prefixVal)\n      }\n    } catch (_) {}\n  }\n\n  const storagePallets = new Map<string, ReturnType<typeof scale.Storage>>()\n\n  const buildStorage = (pallet: string, entry: string) => {\n    let storagePallet = storagePallets.get(pallet)\n    if (!storagePallet)\n      storagePallets.set(pallet, (storagePallet = scale.Storage(pallet)))\n\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .storage!.items.find((s) => s.name === entry)!\n\n    const storageWithFallback = (\n      len: number,\n      ...args: Parameters<ReturnType<typeof scale.Storage>>\n    ) => {\n      const result = storagePallet!(...args)\n      return {\n        ...result,\n        len,\n        fallback:\n          storageEntry.modifier === 1\n            ? result.dec(storageEntry.fallback)\n            : undefined,\n      }\n    }\n\n    if (storageEntry.type.tag === \"plain\")\n      return storageWithFallback(\n        0,\n        entry,\n        buildDefinition(storageEntry.type.value).dec,\n      )\n\n    const { key, value, hashers } = storageEntry.type.value\n    const val = buildDefinition(value)\n    const hashes = hashers.map((x) => scale[x.tag])\n\n    const hashArgs: Array<scale.EncoderWithHash<any>> =\n      hashes.length === 1\n        ? [[buildDefinition(key), hashes[0]]]\n        : (getLookupEntryDef(key) as TupleVar).value.map(\n            (x, idx): scale.EncoderWithHash<any> => [\n              buildDefinition(x.id),\n              hashes[idx],\n            ],\n          )\n    return storageWithFallback(hashes.length, entry, val.dec, ...hashArgs)\n  }\n\n  const buildEnumEntry = (\n    entry: EnumVar[\"value\"][keyof EnumVar[\"value\"]],\n  ): Codec<any> => {\n    if (entry.type === \"primitive\") return scale._void\n\n    return entry.type === \"tuple\"\n      ? scale.Tuple(\n          ...Object.values(entry.value).map((l) => buildDefinition(l.id)),\n        )\n      : scale.Struct(\n          mapObject(entry.value, (x) => buildDefinition(x.id)) as StringRecord<\n            Codec<any>\n          >,\n        )\n  }\n\n  const buildConstant = (pallet: string, constantName: string) => {\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .constants!.find((s) => s.name === constantName)!\n\n    return buildDefinition(storageEntry.type as number)\n  }\n\n  const buildVariant =\n    (type: \"errors\" | \"events\") =>\n    (\n      pallet: string,\n      name: string,\n    ): {\n      codec: Codec<any>\n      location: [number, number]\n    } => {\n      const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n      const lookup = getLookupEntryDef(palletEntry[type]!)\n      if (lookup.type !== \"enum\") throw null\n      const entry = lookup.value[name]\n\n      return {\n        location: [palletEntry.index, entry.idx],\n        codec: buildEnumEntry(lookup.value[name]),\n      }\n    }\n\n  const buildCall = (\n    pallet: string,\n    name: string,\n  ): {\n    args: Codec<any>\n    location: [number, number]\n  } => {\n    const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n    const lookup = getLookupEntryDef(palletEntry.calls!)\n    if (lookup.type !== \"enum\") throw null\n    const entry = lookup.value[name]\n\n    return {\n      location: [palletEntry.index, entry.idx],\n      args: buildEnumEntry(lookup.value[name]),\n    }\n  }\n\n  const buildRuntimeCall = (api: string, method: string) => {\n    const entry = metadata.apis\n      .find((x) => x.name === api)\n      ?.methods.find((x) => x.name === method)\n    if (!entry) throw null\n\n    return {\n      args: scale.Tuple(...entry.inputs.map((x) => buildDefinition(x.type))),\n      value: buildDefinition(entry.output),\n    }\n  }\n\n  return {\n    buildDefinition,\n    buildStorage,\n    buildEvent: buildVariant(\"events\"),\n    buildError: buildVariant(\"errors\"),\n    buildRuntimeCall,\n    buildCall,\n    buildConstant,\n    ss58Prefix,\n  }\n}\n","import type { StringRecord, V15 } from \"@polkadot-api/substrate-bindings\"\nimport { h64 } from \"@polkadot-api/substrate-bindings\"\nimport {\n  LookupEntry,\n  MetadataPrimitives,\n  StructVar,\n  TupleVar,\n  VoidVar,\n  getLookupFn,\n} from \"./lookups\"\nimport { withCache } from \"./with-cache\"\n\nconst textEncoder = new TextEncoder()\nconst encodeText = textEncoder.encode.bind(textEncoder)\n\nconst getChecksum = (values: Array<bigint>) => {\n  const res = new Uint8Array(values.length * 8)\n  const dv = new DataView(res.buffer)\n\n  for (let i = 0; i < values.length; i++) dv.setBigUint64(i * 8, values[i])\n\n  return h64(res)\n}\nconst getStringChecksum = (values: Array<string>) =>\n  getChecksum(values.map((v) => h64(encodeText(v))))\n\ntype Shape =\n  | \"primitive\"\n  | \"vector\"\n  | \"tuple\"\n  | \"struct\"\n  | \"option\"\n  | \"result\"\n  | \"enum\"\nconst shapeIds: Record<Shape, bigint> = {\n  primitive: 0n,\n  vector: 1n,\n  tuple: 2n,\n  struct: 3n,\n  option: 4n,\n  result: 5n,\n  enum: 6n,\n}\n\ntype RuntimePrimitives =\n  | \"undefined\"\n  | \"number\"\n  | \"string\"\n  | \"bigint\"\n  | \"boolean\"\n  | \"bitSequence\"\n  | \"byteSequence\"\n  | \"accountId\"\n\nconst runtimePrimitiveIds: Record<RuntimePrimitives, bigint> = {\n  undefined: 0n,\n  number: 1n,\n  string: 2n,\n  bigint: 3n,\n  boolean: 4n,\n  bitSequence: 5n, // {bitsLen: number, bytes: Uint8Array}\n  byteSequence: 6n, // Binary\n  accountId: 7n, // SS58String\n}\n\nconst metadataPrimitiveIds: Record<MetadataPrimitives | \"_void\", bigint> = {\n  _void: runtimePrimitiveIds.undefined,\n  bool: runtimePrimitiveIds.boolean,\n  char: runtimePrimitiveIds.string,\n  str: runtimePrimitiveIds.string,\n  u8: runtimePrimitiveIds.number,\n  u16: runtimePrimitiveIds.number,\n  u32: runtimePrimitiveIds.number,\n  u64: runtimePrimitiveIds.bigint,\n  u128: runtimePrimitiveIds.bigint,\n  u256: runtimePrimitiveIds.bigint,\n  i8: runtimePrimitiveIds.number,\n  i16: runtimePrimitiveIds.number,\n  i32: runtimePrimitiveIds.number,\n  i64: runtimePrimitiveIds.bigint,\n  i128: runtimePrimitiveIds.bigint,\n  i256: runtimePrimitiveIds.bigint,\n}\n\nconst structLikeBuilder = <T>(\n  shapeId: bigint,\n  input: StringRecord<T>,\n  innerChecksum: (value: T) => bigint,\n) => {\n  const sortedEntries = Object.entries(input).sort(([a], [b]) =>\n    a.localeCompare(b),\n  )\n  const keysChecksum = getStringChecksum(sortedEntries.map(([key]) => key))\n  const valuesChecksum = getChecksum(\n    sortedEntries.map(([, entry]) => innerChecksum(entry)),\n  )\n\n  return getChecksum([shapeId, keysChecksum, valuesChecksum])\n}\n\nconst _buildChecksum = (\n  input: LookupEntry,\n  cache: Map<number, bigint>,\n  stack: Set<number>,\n): bigint => {\n  if (cache.has(input.id)) return cache.get(input.id)!\n\n  if (input.type === \"primitive\")\n    return getChecksum([shapeIds.primitive, metadataPrimitiveIds[input.value]])\n\n  if (input.type === \"compact\")\n    return getChecksum([\n      shapeIds.primitive,\n      runtimePrimitiveIds[input.isBig ? \"bigint\" : \"number\"],\n    ])\n\n  if (input.type === \"bitSequence\")\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.bitSequence])\n\n  if (\n    input.type === \"sequence\" &&\n    input.value.type === \"primitive\" &&\n    input.value.value === \"u8\"\n  ) {\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.byteSequence])\n  }\n\n  if (input.type === \"AccountId32\") {\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.accountId])\n  }\n\n  const buildNextChecksum = (nextInput: LookupEntry): bigint =>\n    buildChecksum(nextInput, cache, stack)\n\n  if (input.type === \"array\") {\n    const innerChecksum = buildNextChecksum(input.value)\n    return getChecksum([shapeIds.vector, innerChecksum, BigInt(input.len)])\n  }\n\n  if (input.type === \"sequence\") {\n    const innerChecksum = buildNextChecksum(input.value)\n    return getChecksum([shapeIds.vector, innerChecksum])\n  }\n\n  const buildTuple = (entries: LookupEntry[]) =>\n    getChecksum([shapeIds.tuple, ...entries.map(buildNextChecksum)])\n\n  const buildStruct = (entries: StringRecord<LookupEntry>) =>\n    structLikeBuilder(shapeIds.struct, entries, buildNextChecksum)\n\n  if (input.type === \"tuple\") return buildTuple(input.value)\n\n  if (input.type === \"struct\") return buildStruct(input.value)\n\n  if (input.type === \"option\")\n    return getChecksum([shapeIds.option, buildNextChecksum(input.value)])\n\n  if (input.type === \"result\")\n    return getChecksum([\n      shapeIds.result,\n      buildNextChecksum(input.value.ok),\n      buildNextChecksum(input.value.ko),\n    ])\n\n  return structLikeBuilder(shapeIds.enum, input.value, (entry) => {\n    switch (entry.type) {\n      case \"primitive\":\n        return metadataPrimitiveIds._void\n      case \"tuple\":\n        return buildTuple(entry.value)\n      case \"struct\":\n        return buildStruct(entry.value)\n    }\n  })\n}\nconst buildChecksum = withCache(\n  _buildChecksum,\n  () => 0n,\n  (result) => result,\n)\n\nexport const getChecksumBuilder = (metadata: V15) => {\n  const lookupData = metadata.lookup\n  const getLookupEntryDef = getLookupFn(lookupData)\n\n  const cache = new Map<number, bigint>()\n\n  const buildDefinition = (id: number): bigint =>\n    buildChecksum(getLookupEntryDef(id), cache, new Set())\n\n  const buildStorage = (pallet: string, entry: string): bigint | null => {\n    try {\n      const storageEntry = metadata.pallets\n        .find((x) => x.name === pallet)!\n        .storage!.items.find((s) => s.name === entry)!\n\n      if (storageEntry.type.tag === \"plain\")\n        return buildDefinition(storageEntry.type.value)\n\n      const { key, value } = storageEntry.type.value\n      const val = buildDefinition(value)\n      const returnKey = buildDefinition(key)\n      return getChecksum([val, returnKey])\n    } catch (_) {\n      return null\n    }\n  }\n\n  const buildRuntimeCall = (api: string, method: string): bigint | null => {\n    try {\n      const entry = metadata.apis\n        .find((x) => x.name === api)\n        ?.methods.find((x) => x.name === method)\n      if (!entry) throw null\n\n      const argNamesChecksum = getStringChecksum(\n        entry.inputs.map((x) => x.name),\n      )\n      const argValuesChecksum = getChecksum(\n        entry.inputs.map((x) => buildDefinition(x.type)),\n      )\n      const outputChecksum = buildDefinition(entry.output)\n\n      return getChecksum([argNamesChecksum, argValuesChecksum, outputChecksum])\n    } catch (_) {\n      return null\n    }\n  }\n\n  const buildComposite = (input: TupleVar | StructVar | VoidVar): bigint => {\n    if (input.type === \"primitive\") return getChecksum([0n])\n\n    if (input.type === \"tuple\") {\n      const values = Object.values(input.value).map((entry) =>\n        buildDefinition(entry.id),\n      )\n\n      return getChecksum([shapeIds.tuple, ...values])\n    }\n\n    // Otherwise struct\n    return structLikeBuilder(shapeIds.struct, input.value, (entry) =>\n      buildDefinition(entry.id),\n    )\n  }\n\n  const buildVariant =\n    (variantType: \"errors\" | \"events\" | \"calls\") =>\n    (pallet: string, name: string): bigint | null => {\n      try {\n        const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n        const callsLookup = getLookupEntryDef(\n          palletEntry[variantType]! as number,\n        )\n\n        if (callsLookup.type !== \"enum\") throw null\n        return buildComposite(callsLookup.value[name])\n      } catch (_) {\n        return null\n      }\n    }\n\n  const buildConstant = (\n    pallet: string,\n    constantName: string,\n  ): bigint | null => {\n    try {\n      const storageEntry = metadata.pallets\n        .find((x) => x.name === pallet)!\n        .constants!.find((s) => s.name === constantName)!\n\n      return buildDefinition(storageEntry.type)\n    } catch (_) {\n      return null\n    }\n  }\n\n  const toStringEnhancer =\n    <Args extends Array<any>>(\n      fn: (...args: Args) => bigint | null,\n    ): ((...args: Args) => string | null) =>\n    (...args) =>\n      fn(...args)?.toString(32) ?? null\n\n  return {\n    buildDefinition: toStringEnhancer(buildDefinition),\n    buildRuntimeCall: toStringEnhancer(buildRuntimeCall),\n    buildStorage: toStringEnhancer(buildStorage),\n    buildCall: toStringEnhancer(buildVariant(\"calls\")),\n    buildEvent: toStringEnhancer(buildVariant(\"events\")),\n    buildError: toStringEnhancer(buildVariant(\"errors\")),\n    buildConstant: toStringEnhancer(buildConstant),\n    buildComposite: toStringEnhancer(buildComposite),\n  }\n}\n","import { mapObject, mapStringRecord } from \"@polkadot-api/utils\"\nimport {\n  Decoder,\n  type StringRecord,\n  type V15,\n  type V14Lookup,\n  createDecoder,\n  u8,\n  HexString,\n  enhanceDecoder,\n} from \"@polkadot-api/substrate-bindings\"\nimport type { EnumVar, LookupEntry } from \"@/lookups\"\nimport { getLookupFn } from \"@/lookups\"\nimport {\n  primitives,\n  complex,\n  WithShapeWithoutExtra,\n  ShapedDecoder,\n  selfDecoder,\n  AccountIdShaped,\n  WithoutExtra,\n} from \"./shaped-decoders\"\nimport {\n  AccountIdDecoded,\n  Decoded,\n  DecodedCall,\n  GetViewBuilder,\n  PrimitiveDecoded,\n  UnshapedDecoder,\n} from \"./types\"\nimport { withCache } from \"@/with-cache\"\n\nconst emptyTuple = complex.Tuple()\n\nconst toUnshapedDecoder =\n  <A extends Array<any>>(\n    fn: (...args: A) => ShapedDecoder,\n  ): ((...args: A) => UnshapedDecoder) =>\n  (...args) => {\n    const value = fn(...args)\n    return {\n      shape: value.shape,\n      decoder: value as Decoder<Decoded>,\n    }\n  }\n\ntype WithProp<\n  T extends Decoder<any> & { shape: any },\n  PropName extends string,\n  PropValue,\n> = T extends Decoder<infer D> & { shape: infer S }\n  ? Decoder<\n      D extends WithoutExtra<PrimitiveDecoded>\n        ? PrimitiveDecoded\n        : D & { [P in PropName]: PropValue }\n    > & { shape: S }\n  : T\n\nconst withProp = <PropName extends string, PropValue>(\n  input: ShapedDecoder,\n  propName: PropName,\n  propValue: PropValue,\n): WithProp<ShapedDecoder, PropName, PropValue> => {\n  const decoder = enhanceDecoder(input as Decoder<{}>, (x) => ({\n    ...x,\n    [propName]: propValue,\n  })) as WithProp<ShapedDecoder, PropName, PropValue>\n  decoder.shape = input.shape\n  return decoder\n}\n\nconst addPath =\n  <Other extends Array<any>>(\n    fn: (\n      input: LookupEntry,\n      cache: Map<number, ShapedDecoder>,\n      stack: Set<number>,\n      lookupData: V14Lookup,\n      ...rest: Other\n    ) => ShapedDecoder,\n  ): ((\n    input: LookupEntry,\n    cache: Map<number, ShapedDecoder>,\n    stack: Set<number>,\n    lookupData: V14Lookup,\n    ...rest: Other\n  ) => ShapedDecoder | WithProp<ShapedDecoder, \"path\", string[]>) =>\n  (input, cache, stack, lookupData, ...rest) => {\n    const { path } = lookupData[input.id]\n    const base = fn(input, cache, stack, lookupData, ...rest)\n    return path.length ? withProp(base, \"path\", path) : base\n  }\n\nconst _buildShapedDecoder = (\n  input: LookupEntry,\n  cache: Map<number, ShapedDecoder>,\n  stack: Set<number>,\n  lookupData: V14Lookup,\n  _accountId: WithShapeWithoutExtra<AccountIdDecoded>,\n): ShapedDecoder => {\n  if (input.type === \"primitive\") return primitives[input.value]\n  if (input.type === \"AccountId32\") return _accountId\n  if (input.type === \"compact\")\n    return input.isBig ? primitives.compactBn : primitives.compactNumber\n  if (input.type === \"bitSequence\") return primitives.bitSequence\n\n  if (\n    input.type === \"sequence\" &&\n    input.value.type === \"primitive\" &&\n    input.value.value === \"u8\"\n  ) {\n    return primitives.Bytes\n  }\n\n  const buildNext = (nextInput: LookupEntry): ShapedDecoder =>\n    buildShapedDecoder(nextInput, cache, stack, lookupData, _accountId)\n\n  const buildVector = (inner: LookupEntry, len?: number) => {\n    const _inner = buildNext(inner)\n    return len ? complex.Array(_inner, len) : complex.Sequence(_inner)\n  }\n\n  const buildTuple = (value: LookupEntry[], innerDocs: string[][]) =>\n    withProp(complex.Tuple(...value.map(buildNext)), \"innerDocs\", innerDocs)\n\n  const buildStruct = (\n    value: StringRecord<LookupEntry>,\n    innerDocs: StringRecord<string[]>,\n  ) =>\n    withProp(\n      complex.Struct(mapStringRecord(value, buildNext)),\n      \"innerDocs\",\n      innerDocs,\n    )\n\n  if (input.type === \"array\") {\n    // Bytes case\n    if (input.value.type === \"primitive\" && input.value.value === \"u8\") {\n      return primitives.BytesArray(input.len)\n    }\n\n    return buildVector(input.value, input.len)\n  }\n\n  if (input.type === \"sequence\") return buildVector(input.value)\n  if (input.type === \"tuple\") return buildTuple(input.value, input.innerDocs)\n  if (input.type === \"struct\") return buildStruct(input.value, input.innerDocs)\n  if (input.type === \"option\") return complex.Option(buildNext(input.value))\n\n  if (input.type === \"result\")\n    return complex.Result(buildNext(input.value.ok), buildNext(input.value.ko))\n\n  // it has to be an enum by now\n  const dependencies = Object.values(input.value).map((v) => {\n    if (v.type === \"primitive\") return primitives._void\n    if (v.type === \"tuple\" && v.value.length === 1) {\n      return buildNext(v.value[0])\n    }\n    return v.type === \"tuple\"\n      ? buildTuple(v.value, v.innerDocs)\n      : buildStruct(v.value, v.innerDocs)\n  })\n\n  const inner = Object.fromEntries(\n    Object.keys(input.value).map((key, idx) => [key, dependencies[idx]]),\n  ) as StringRecord<ShapedDecoder>\n\n  const indexes = Object.values(input.value).map((x) => x.idx)\n  const areIndexesSorted = indexes.every((idx, i) => idx === i)\n\n  const withoutDocs = areIndexesSorted\n    ? complex.Enum(inner)\n    : complex.Enum(inner, indexes as any)\n\n  const withDocs = enhanceDecoder(withoutDocs, (val) => {\n    const docs = input.innerDocs[val.value.type]\n    return {\n      ...val,\n      docs,\n    }\n  }) as unknown as typeof withoutDocs\n  withDocs.shape = withoutDocs.shape\n  return withDocs\n}\n\nconst withPath = addPath(_buildShapedDecoder)\nconst buildShapedDecoder = withCache(withPath, selfDecoder, (outter, inner) => {\n  inner.shape = outter.shape\n  return outter\n})\n\nconst hexStrFromByte = (input: number) =>\n  `0x${input.toString(16).padEnd(2, \"0\")}` as HexString\n\nexport const getViewBuilder: GetViewBuilder = (metadata: V15) => {\n  const lookupData = metadata.lookup\n  const cache = new Map<number, ShapedDecoder>()\n\n  const getDecoder = (id: number) =>\n    buildShapedDecoder(\n      getLookupEntryDef(id),\n      cache,\n      new Set(),\n      lookupData,\n      _accountId,\n    )\n\n  const getLookupEntryDef = getLookupFn(lookupData)\n\n  let _accountId: WithShapeWithoutExtra<AccountIdDecoded> = primitives.AccountId\n\n  const prefix = metadata.pallets\n    .find((x) => x.name === \"System\")\n    ?.constants.find((x) => x.name === \"SS58Prefix\")\n  if (prefix) {\n    try {\n      const prefixVal = getDecoder(prefix.type)(prefix.value).value\n\n      if (typeof prefixVal === \"number\") _accountId = AccountIdShaped(prefixVal)\n    } catch (_) {}\n  }\n\n  const buildDefinition = toUnshapedDecoder(getDecoder)\n\n  const callDecoder: Decoder<DecodedCall> = createDecoder((bytes) => {\n    const palletIdx = u8.dec(bytes)\n\n    const palletEntry = metadata.pallets.find((x) => x.index === palletIdx)\n    if (!palletEntry) throw new Error(\"Invalid Pallet\")\n\n    const pallet = {\n      value: {\n        name: palletEntry.name,\n        idx: palletIdx,\n      },\n      input: hexStrFromByte(bytes[0]),\n    }\n\n    const callsDecoder = getDecoder(palletEntry.calls!)\n\n    const decoded = callsDecoder(bytes)\n\n    if (decoded.codec !== \"Enum\") throw null\n\n    const call = {\n      value: {\n        name: decoded.value.type,\n        idx: bytes[1],\n      },\n      input: hexStrFromByte(bytes[1]),\n      docs: (decoded as any).docs as string[],\n    }\n\n    return {\n      pallet,\n      call,\n      args: { value: decoded.value.value as any, shape: callsDecoder.shape },\n    }\n  })\n\n  const buildEnumEntry = toUnshapedDecoder(\n    (\n      entry: EnumVar[\"value\"][keyof EnumVar[\"value\"]],\n      forceTuple = false,\n    ): ShapedDecoder => {\n      if (entry.type === \"primitive\")\n        return forceTuple ? emptyTuple : primitives._void\n\n      return entry.type === \"tuple\"\n        ? complex.Tuple(\n            ...Object.values(entry.value).map((l) => getDecoder(l.id)),\n          )\n        : complex.Struct(\n            mapObject(entry.value, (x) =>\n              getDecoder(x.id),\n            ) as StringRecord<ShapedDecoder>,\n          )\n    },\n  )\n\n  const buildVariant =\n    (type: \"errors\" | \"events\" | \"calls\") =>\n    (\n      pallet: string,\n      name: string,\n    ): {\n      view: UnshapedDecoder\n      location: [number, number]\n    } => {\n      const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n\n      const lookup = getLookupEntryDef(palletEntry[type]!)\n      if (lookup.type !== \"enum\") throw null\n\n      const event = lookup.value[name]\n\n      return {\n        location: [palletEntry.index, event.idx],\n        view: buildEnumEntry(event, type === \"calls\"),\n      }\n    }\n\n  const buildConstant = (pallet: string, constantName: string) => {\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .constants!.find((s) => s.name === constantName)!\n\n    return buildDefinition(storageEntry.type as number)\n  }\n\n  return {\n    buildDefinition,\n    callDecoder,\n\n    buildEvent: buildVariant(\"events\"),\n    buildError: buildVariant(\"errors\"),\n    buildCall: buildVariant(\"calls\"),\n    buildConstant,\n  }\n}\n","import { toHex as _toHex, mapStringRecord } from \"@polkadot-api/utils\"\nimport * as scale from \"@polkadot-api/substrate-bindings\"\nimport type {\n  Decoder,\n  HexString,\n  StringRecord,\n} from \"@polkadot-api/substrate-bindings\"\nimport {\n  ArrayDecoded,\n  ArrayShape,\n  BytesArrayDecoded,\n  ComplexDecoded,\n  ComplexShape,\n  Decoded,\n  EnumDecoded,\n  EnumShape,\n  OptionDecoded,\n  OptionShape,\n  PrimitiveDecoded,\n  ResultDecoded,\n  ResultShape,\n  SequenceDecoded,\n  SequenceShape,\n  StructDecoded,\n  StructShape,\n  TupleDecoded,\n  TupleShape,\n} from \"./types\"\n\nconst toHex = _toHex as (input: Uint8Array) => HexString\n\ntype Extras = \"docs\" | \"path\" | \"innerDocs\"\nexport type WithoutExtra<T extends {}> = Omit<T, Extras>\ntype PrimitiveCodec = PrimitiveDecoded[\"codec\"]\ntype ComplexCodec = ComplexDecoded[\"codec\"]\n\nexport type WithShapeWithoutExtra<T extends PrimitiveDecoded> = Decoder<\n  WithoutExtra<T>\n> & {\n  shape: { codec: T[\"codec\"] }\n}\ntype PrimitiveShapeDecoder = WithShapeWithoutExtra<PrimitiveDecoded>\n\ntype SequenceShapedDecoder = Decoder<WithoutExtra<SequenceDecoded>> & {\n  shape: SequenceShape\n}\ntype ArrayShapedDecoder = Decoder<WithoutExtra<ArrayDecoded>> & {\n  shape: ArrayShape\n}\ntype TupleShapedDecoder = Decoder<WithoutExtra<TupleDecoded>> & {\n  shape: TupleShape\n}\ntype StructShapedDecoder = Decoder<WithoutExtra<StructDecoded>> & {\n  shape: StructShape\n}\n\ntype OptionShapedDecoder = Decoder<WithoutExtra<OptionDecoded>> & {\n  shape: OptionShape\n}\n\ntype ResultShapedDecoder = Decoder<WithoutExtra<ResultDecoded>> & {\n  shape: ResultShape\n}\n\ntype EnumShapedDecoder = Decoder<WithoutExtra<EnumDecoded>> & {\n  shape: EnumShape\n}\ntype ComplexShapedDecoder =\n  | SequenceShapedDecoder\n  | ArrayShapedDecoder\n  | TupleShapedDecoder\n  | StructShapedDecoder\n  | OptionShapedDecoder\n  | ResultShapedDecoder\n  | EnumShapedDecoder\n\nexport type ShapedDecoder = PrimitiveShapeDecoder | ComplexShapedDecoder\n\ntype PrimitiveDecodedValue<C extends PrimitiveCodec> = (PrimitiveDecoded & {\n  codec: C\n})[\"value\"]\ntype PrimitiveDecodedRest<C extends PrimitiveCodec> = Omit<\n  PrimitiveDecoded & { codec: C },\n  \"value\" | \"input\" | \"codec\" | Extras\n>\n\ntype ComplexDecodedValue<C extends ComplexCodec> = (ComplexDecoded & {\n  codec: C\n})[\"value\"]\ntype ComplexDecodedRest<C extends ComplexCodec> = Omit<\n  ComplexDecoded & { codec: C },\n  \"value\" | \"input\" | \"codec\" | Extras\n>\n\nconst createInputValueDecoder = <T, Rest extends { codec: Decoded[\"codec\"] }>(\n  dec: Decoder<T>,\n  rest: Rest,\n): Decoder<\n  Rest & {\n    input: HexString\n    value: T\n  }\n> =>\n  scale.createDecoder((_bytes) => {\n    const bytes = _bytes as Uint8Array & { i: number; v: DataView }\n    const start = bytes.i\n    const value = dec(bytes)\n    const input = toHex(new Uint8Array(bytes.buffer.slice(start, bytes.i)))\n    return { ...rest, value, input }\n  })\n\nconst primitiveShapedDecoder = <C extends PrimitiveCodec>(\n  codec: C,\n  input: Decoder<PrimitiveDecodedValue<C>>,\n  rest?: PrimitiveDecodedRest<C>,\n): WithShapeWithoutExtra<\n  PrimitiveDecoded & {\n    codec: C\n  }\n> => {\n  const decoder: Decoder<WithoutExtra<PrimitiveDecoded>> =\n    createInputValueDecoder(input, { codec, ...rest })\n\n  return Object.assign(decoder, {\n    shape: { codec },\n  }) as any\n}\n\nconst complexShapedDecoder = <Shape extends ComplexShape>(\n  shape: Shape,\n  input: Decoder<ComplexDecodedValue<Shape[\"codec\"]>>,\n  rest?: ComplexDecodedRest<Shape[\"codec\"]>,\n): Decoder<\n  WithoutExtra<\n    ComplexDecoded & {\n      codec: Shape[\"codec\"]\n    }\n  >\n> & {\n  shape: Shape\n} => {\n  const decoder: Decoder<WithoutExtra<ComplexDecoded>> =\n    createInputValueDecoder(input, { codec: shape.codec, ...rest })\n\n  return Object.assign(decoder, {\n    shape,\n  })\n}\n\nexport const AccountIdShaped = (ss58Prefix = 42) => {\n  const enhanced = scale.enhanceDecoder(\n    scale.AccountId(ss58Prefix).dec,\n    (address) => ({\n      address,\n      ss58Prefix,\n    }),\n  )\n\n  return primitiveShapedDecoder(\"AccountId\", enhanced, {})\n}\n\nconst BytesArray = (len: number): WithShapeWithoutExtra<BytesArrayDecoded> =>\n  primitiveShapedDecoder(\"BytesArray\", scale.Hex.dec(len), { len })\n\nconst _primitives = [\n  \"_void\",\n  \"bool\",\n  \"char\",\n  \"str\",\n  \"u8\",\n  \"u16\",\n  \"u32\",\n  \"i8\",\n  \"i16\",\n  \"i32\",\n  \"u64\",\n  \"u128\",\n  \"u256\",\n  \"i64\",\n  \"i128\",\n  \"i256\",\n  \"compactNumber\",\n  \"compactBn\",\n  \"bitSequence\",\n] as const\n\ntype PrimitivesList = typeof _primitives\ntype PrimitivesKeys = PrimitivesList[number]\n\nconst corePrimitives: {\n  [P in PrimitivesKeys]: WithShapeWithoutExtra<\n    PrimitiveDecoded & {\n      codec: P\n    }\n  >\n} = Object.fromEntries(\n  _primitives.map((x) => [x, primitiveShapedDecoder(x, scale[x].dec)]),\n) as any\n\nexport const primitives = {\n  ...corePrimitives,\n  Bytes: primitiveShapedDecoder(\"Bytes\", scale.Hex.dec()),\n  BytesArray,\n  AccountId: AccountIdShaped(),\n}\n\nconst Sequence = (input: ShapedDecoder): SequenceShapedDecoder =>\n  complexShapedDecoder(\n    { codec: \"Sequence\", shape: input.shape },\n    scale.Vector.dec(input as any),\n  )\n\nconst ArrayDec = (input: ShapedDecoder, len: number): ArrayShapedDecoder =>\n  complexShapedDecoder(\n    { codec: \"Array\", shape: input.shape, len },\n    scale.Vector.dec(input as any, len),\n  )\n\nconst TupleDec = (...input: Array<ShapedDecoder>): TupleShapedDecoder =>\n  complexShapedDecoder(\n    { codec: \"Tuple\", shape: input.map((x) => x.shape) },\n    scale.Tuple.dec(...(input as Array<Decoder<any>>)),\n  )\n\nconst StructDec = (input: StringRecord<ShapedDecoder>): StructShapedDecoder =>\n  complexShapedDecoder(\n    { codec: \"Struct\", shape: mapStringRecord(input, (x) => x.shape) },\n    scale.Struct.dec(input as {}),\n  )\n\nconst EnumDec = (\n  input: StringRecord<ShapedDecoder>,\n  args?: number[],\n): EnumShapedDecoder =>\n  complexShapedDecoder(\n    { codec: \"Enum\", shape: mapStringRecord(input, (x) => x.shape) },\n    scale.Variant.dec(input as {}, args as any),\n  )\n\nexport const OptionDec = (input: ShapedDecoder): OptionShapedDecoder =>\n  complexShapedDecoder(\n    { codec: \"Option\", shape: input.shape },\n    scale.Option.dec(input as any) as any,\n  )\n\nexport const ResultDec = (\n  ok: ShapedDecoder,\n  ko: ShapedDecoder,\n): ResultShapedDecoder =>\n  complexShapedDecoder(\n    { codec: \"Result\", shape: { ok: ok.shape, ko: ko.shape } },\n    scale.Result.dec(ok as Decoder<any>, ko as Decoder<any>) as any,\n  )\n\nexport const selfDecoder = (value: () => ShapedDecoder): ShapedDecoder => {\n  let cache: Decoder<any> = (x) => {\n    const decoder = value()\n    const result = decoder\n    cache = decoder\n    return result(x)\n  }\n\n  const result = ((x) => cache(x)) as ShapedDecoder\n  result.shape = { codec: \"_void\" }\n  return result\n}\n\nexport const complex = {\n  Sequence,\n  Array: ArrayDec,\n  Tuple: TupleDec,\n  Struct: StructDec,\n  Enum: EnumDec,\n  Option: OptionDec,\n  Result: ResultDec,\n}\n"],"mappings":"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","names":["src_exports","__export","getChecksumBuilder","getDynamicBuilder","getLookupFn","getStaticBuilder","getViewBuilder","primitiveTypes","__toCommonJS","voidVar","getLookupFn","lookupData","lookups","from","withCache","fn","id","entry","value","isAccountId32SearchOn","getLookupEntryDef","def","path","params","allKey","values","innerDocs","x","idx","key","enumValue","enumDocs","translated","withCache","fn","onEnterCircular","onExitCircular","input","cache","stack","rest","id","res","result","primitiveTypes","toCamelCase","parts","part","getTypes","varName","_buildSyntax","input","cache","stack","declarations","getVarName","id","importVal","variable","buildNextSyntax","nextInput","buildSyntax","buildVector","inner","len","dependsVar","buildTuple","value","deps","buildStruct","key","idx","varId","ok","ko","dependencies","result","indexes","x","areIndexesSorted","i","innerEnum","withCache","_getter","entry","nonCircular","getStaticBuilder","metadata","lookupData","getLookupEntryDef","getLookupFn","post","path","buildDefinition","buildNamedTuple","params","args","p","names","name","pIdx","EMPTY_TUPLE_VAR_NAME","getEmptyTuple","buildStorage","pallet","storageEntry","s","val","buildRuntimeCall","api","method","buildVariant","type","lookupEntry","returnVar","buildConstant","constantName","getCode","typeImports","varImports","code","getEnums","getTypeFromVarName","scale","import_utils","_bytes","_buildCodec","input","cache","stack","_accountId","scale","buildNextCodec","nextInput","buildCodec","buildVector","inner","len","innerCodec","buildTuple","value","buildStruct","key","dependencies","v","idx","indexes","x","i","withCache","res","getDynamicBuilder","metadata","lookupData","getLookupEntryDef","getLookupFn","buildDefinition","id","prefix","ss58Prefix","prefixVal","storagePallets","buildStorage","pallet","entry","storagePallet","storageEntry","s","storageWithFallback","args","result","hashers","val","hashes","hashArgs","buildEnumEntry","l","buildConstant","constantName","buildVariant","type","name","palletEntry","lookup","buildCall","buildRuntimeCall","api","method","import_substrate_bindings","textEncoder","encodeText","getChecksum","values","res","dv","i","getStringChecksum","v","shapeIds","runtimePrimitiveIds","metadataPrimitiveIds","structLikeBuilder","shapeId","input","innerChecksum","sortedEntries","a","b","keysChecksum","key","valuesChecksum","entry","_buildChecksum","cache","stack","buildNextChecksum","nextInput","buildChecksum","buildTuple","entries","buildStruct","withCache","result","getChecksumBuilder","metadata","lookupData","getLookupEntryDef","getLookupFn","buildDefinition","id","buildStorage","pallet","storageEntry","x","s","value","val","returnKey","buildRuntimeCall","api","method","argNamesChecksum","argValuesChecksum","outputChecksum","buildComposite","buildVariant","variantType","name","palletEntry","callsLookup","buildConstant","constantName","toStringEnhancer","fn","args","import_utils","import_substrate_bindings","import_utils","scale","toHex","_toHex","createInputValueDecoder","dec","rest","_bytes","bytes","start","value","input","primitiveShapedDecoder","codec","decoder","complexShapedDecoder","shape","AccountIdShaped","ss58Prefix","enhanced","address","BytesArray","len","_primitives","corePrimitives","x","primitives","Sequence","ArrayDec","TupleDec","StructDec","EnumDec","args","OptionDec","ResultDec","ok","ko","selfDecoder","cache","result","complex","emptyTuple","complex","toUnshapedDecoder","fn","args","value","withProp","input","propName","propValue","decoder","x","addPath","cache","stack","lookupData","rest","path","base","_buildShapedDecoder","_accountId","primitives","buildNext","nextInput","buildShapedDecoder","buildVector","inner","len","_inner","buildTuple","innerDocs","buildStruct","dependencies","v","key","idx","indexes","withoutDocs","i","withDocs","val","docs","withPath","withCache","selfDecoder","outter","hexStrFromByte","getViewBuilder","metadata","getDecoder","id","getLookupEntryDef","getLookupFn","prefix","prefixVal","AccountIdShaped","buildDefinition","callDecoder","bytes","palletIdx","palletEntry","pallet","callsDecoder","decoded","call","buildEnumEntry","entry","forceTuple","l","buildVariant","type","name","lookup","event","buildConstant","constantName","storageEntry","s"]}