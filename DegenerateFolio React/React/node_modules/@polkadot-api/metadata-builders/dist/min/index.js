"use strict";var me=Object.create;var B=Object.defineProperty;var ye=Object.getOwnPropertyDescriptor;var ve=Object.getOwnPropertyNames;var he=Object.getPrototypeOf,be=Object.prototype.hasOwnProperty;var ge=(e,n)=>{for(var d in n)B(e,d,{get:n[d],enumerable:!0})},Q=(e,n,d,r)=>{if(n&&typeof n=="object"||typeof n=="function")for(let a of ve(n))!be.call(e,a)&&a!==d&&B(e,a,{get:()=>n[a],enumerable:!(r=ye(n,a))||r.enumerable});return e};var X=(e,n,d)=>(d=e!=null?me(he(e)):{},Q(n||!e||!e.__esModule?B(d,"default",{value:e,enumerable:!0}):d,e)),Se=e=>Q(B({},"__esModule",{value:!0}),e);var He={};ge(He,{getChecksumBuilder:()=>Te,getDynamicBuilder:()=>ke,getLookupFn:()=>L,getStaticBuilder:()=>De,getViewBuilder:()=>de,primitiveTypes:()=>N});module.exports=Se(He);var W={type:"primitive",value:"_void"},L=e=>{let n=new Map,d=new Set,r=l=>c=>{let b=n.get(c);if(b)return b;if(d.has(c)){let h={id:c};return n.set(c,h),h}d.add(c);let g=l(c);return b=n.get(c),b?Object.assign(b,g):(b={id:c,...g},n.set(c,b)),d.delete(c),b},a=!0,p=r(l=>{let{def:c,path:b,params:g}=e[l];if(c.tag==="composite"){if(c.value.length===0)return W;if(c.value.length===1)return a&&b.join(",")==="sp_core,crypto,AccountId32"?(a=!1,{type:"AccountId32"}):p(c.value[0].type);let h=!0,f={},o={};return c.value.forEach((y,i)=>{h=h&&!!y.name;let t=y.name||i;f[t]=p(y.type),o[t]=y.docs}),h?{type:"struct",value:f,innerDocs:o}:{type:"tuple",value:Object.values(f),innerDocs:Object.values(o)}}if(c.tag==="variant"){if(b.length===1&&b[0]==="Option"&&g.length===1&&g[0].name==="T"){let o=p(g[0].type);return o.type==="primitive"&&o.value==="_void"?{type:"primitive",value:"bool"}:{type:"option",value:o}}if(b.length===1&&b[0]==="Result"&&g.length===2&&g[0].name==="T"&&g[1].name==="E")return{type:"result",value:{ok:p(g[0].type),ko:p(g[1].type)}};if(c.value.length===0)return W;let h={},f={};return c.value.forEach(o=>{let y=o.name;if(f[y]=o.docs,o.fields.length===0){h[y]={...W,idx:o.index};return}let i=!0,t={},u={};o.fields.forEach((s,m)=>{i=i&&!!s.name;let v=s.name||m;t[v]=p(s.type),u[v]=s.docs}),h[y]=i?{type:"struct",value:t,innerDocs:u,idx:o.index}:{type:"tuple",value:Object.values(t),innerDocs:Object.values(u),idx:o.index}}),{type:"enum",value:h,innerDocs:f}}if(c.tag==="sequence")return{type:"sequence",value:p(c.value)};if(c.tag==="array")return{type:"array",value:p(c.value.type),len:c.value.len};if(c.tag==="tuple"){if(c.value.length===0)return W;if(c.value.length===1)return p(c.value[0]);let h=c.value.map(o=>p(o)),f=c.value.map(o=>e[o].docs);return{type:"tuple",value:h,innerDocs:f}}if(c.tag==="primitive")return{type:"primitive",value:c.value.tag};if(c.tag==="compact"){let h=p(c.value);return{type:"compact",isBig:Number(h.value.slice(1))>32}}return{type:c.tag}});return p};var I=(e,n,d)=>(r,a,p,...l)=>{let{id:c}=r;if(a.has(c))return a.get(c);if(p.has(c)){let g=n(()=>a.get(c),r,...l);return a.set(c,g),g}p.add(c);let b=e(r,a,p,...l);return p.delete(c),a.has(c)&&(b=d(b,a.get(c),r,...l)),a.set(c,b),b};var N={_void:"undefined",bool:"boolean",char:"string",str:"string",u8:"number",u16:"number",u32:"number",u64:"bigint",u128:"bigint",u256:"bigint",i8:"number",i16:"number",i32:"number",i64:"bigint",i128:"bigint",i256:"bigint",compactNumber:"number",compactBn:"bigint",bitSequence:"{bitsLen: number, bytes: Uint8Array}"},F=(...e)=>e.map(n=>n[0].toUpperCase()+n.slice(1)).join(""),w=e=>N[e]??e,fe=(e,n,d,r,a)=>{if(e.type==="primitive")return r.imports.add(e.value),e.value;if(e.type==="AccountId32"){r.imports.add("AccountId");let i="_accountId";return r.variables.set(i,{id:i,value:"AccountId()",types:"SS58String",directDependencies:new Set}),r.typeImports.add("SS58String"),i}if(e.type==="compact"){let i=e.isBig?"compactBn":"compactNumber";return r.imports.add(i),i}if(e.type==="bitSequence")return r.imports.add(e.type),e.type;if(e.type==="sequence"&&e.value.type==="primitive"&&e.value.value==="u8"){r.imports.add("Bin"),r.typeImports.add("HexString"),r.typeImports.add("Binary");let i={id:"_bytesSeq",value:"Bin()",types:"Binary",directDependencies:new Set};return r.variables.has(i.id)||r.variables.set(i.id,i),i.id}if(r.variables.has(a(e.id,"circular")))return a(e.id,"circular");if(r.variables.has(a(e.id)))return a(e.id);let p=i=>Z(i,n,d,r,a),l=(i,t,u)=>{r.imports.add("Vector");let s=p(t),v={id:i,value:`Vector(${(u?[s,u]:[s]).join(", ")})`,types:`Array<${w(s)}>`,directDependencies:new Set([s])};return r.variables.set(i,v),i},c=(i,t)=>{r.imports.add("Tuple");let u=t.map(p),s={id:i,value:`Tuple(${u.join(", ")})`,types:`[${u.map(w).join(", ")}]`,directDependencies:new Set(u)};return r.variables.set(i,s),i},b=(i,t)=>{r.imports.add("Struct");let u=Object.values(t).map(p),s={id:i,value:`Struct({${Object.keys(t).map((m,v)=>`${m}: ${u[v]}`).join(", ")}})`,types:`{${Object.keys(t).map((m,v)=>`${m}: ${w(u[v])}`).join(", ")}}`,directDependencies:new Set(u)};return r.variables.set(i,s),i},g=a(e.id);if(e.type==="array")return e.value.type==="primitive"&&e.value.value==="u8"?(r.imports.add("Bin"),r.variables.set(g,{id:g,value:`Bin(${e.len})`,types:"Binary",directDependencies:new Set}),r.typeImports.add("HexString"),r.typeImports.add("Binary"),g):l(g,e.value,e.len);if(e.type==="sequence")return l(g,e.value);if(e.type==="tuple")return c(g,e.value);if(e.type==="struct")return b(g,e.value);if(e.type==="option"){r.imports.add("Option");let i=p(e.value),t=`_Option_${i}`,u={id:t,value:`Option(${i})`,types:`${w(i)} | undefined`,directDependencies:new Set([i])};return r.variables.set(t,u),t}if(e.type==="result"){r.imports.add("Result"),r.typeImports.add("ResultPayload");let i=p(e.value.ok),t=p(e.value.ko),u=`_Result_${i}_${t}`,s={id:u,value:`Result(${i}, ${t})`,types:`ResultPayload<${w(i)}, ${w(t)}>`,directDependencies:new Set([i,t])};return r.variables.set(u,s),u}r.imports.add("Variant"),r.typeImports.add("Enum");let h=Object.entries(e.value).map(([i,t])=>{if(t.type==="primitive")return r.imports.add(t.value),t.value;let u=F(g,i);if(t.type==="tuple"){if(t.value.length===1){let s=p(t.value[0]);return r.variables.has(u)||r.variables.set(u,{id:u,value:s,types:w(s),directDependencies:new Set([s])}),u}return c(u,t.value)}else b(u,t.value);return u}),f=Object.values(e.value).map(i=>i.idx),o=f.every((i,t)=>i===t),y=`{${Object.keys(e.value).map((i,t)=>`${i}: ${h[t]}`)}}${o?"":`, [${f.join(", ")}]`}`;return r.enums.set(g,Object.keys(e.value).map((i,t)=>`{type: '${i}', value: ${w(h[t])}}`).join(" | ")),r.variables.set(g,{id:g,value:`Variant(${y})`,types:`Enum<E${g}>`,directDependencies:new Set(h)}),g},Z=I(fe,(e,n,d,r)=>{d.imports.add("Self");let a=r(n.id),p={id:r(n.id,"circular"),types:a,value:`Self(() => ${a})`,directDependencies:new Set([a])};return d.variables.set(p.id,p),p.id},e=>e),De=e=>{let n={imports:new Set,typeImports:new Set(["Codec"]),variables:new Map,enums:new Map},d=e.lookup,r=L(d),a=(s,...m)=>{let{path:v}=d[s],S;return v.length===0?S=["cdc"+s]:v[0]==="sp_runtime"?S=[v.slice(-1)[0]]:v.length>2&&v.slice(-2)[0].toUpperCase()===v.slice(-2)[1].toUpperCase()?S=v.slice(0,-1):S=[...v],S.push(...m),F(...S)},p=new Map,l=s=>Z(r(s),p,new Set,n,a),c=(s,m)=>{if(n.variables.has(m))return m;let v=s.map(T=>T.type).map(l),S=s.map(T=>T.name);n.imports.add("Tuple");let C={id:m,types:`[${S.map((T,q)=>`${T[0].toUpperCase()+T.slice(1)}: ${w(v[q])}`).join(", ")}]`,value:`Tuple(${v.join(", ")})`,directDependencies:new Set(v)};return n.variables.set(m,C),m},b="_emptyTuple",g=()=>(n.variables.has(b)||(n.imports.add("Tuple"),n.variables.set(b,{id:b,types:"[]",value:"Tuple()",directDependencies:new Set})),b),h=(s,m)=>{let v=e.pallets.find(O=>O.name===s).storage.items.find(O=>O.name===m);if(v.type.tag==="plain")return{key:g(),val:l(v.type.value)};let{key:S,value:C}=v.type.value,T=l(C);return{key:v.type.value.hashers.length===1?c([{name:"key",type:S}],a(S,"Tupled")):l(S),val:T}},f=(s,m)=>{let v=e.apis.find(S=>S.name===s)?.methods.find(S=>S.name===m);if(!v)throw null;return{args:c(v.inputs,`${s}${m}Args`),value:l(v.output)}},o=s=>(m,v)=>{let S=r(e.pallets.find(T=>T.name===m)[s]);if(S.type!=="enum")throw null;let C=F(l(S.id),v);return!n.variables.has(C)&&S.value[v].type==="primitive"&&n.variables.set(C,{id:C,value:"_void",types:"undefined",directDependencies:new Set}),C},y=(s,m)=>{let v=e.pallets.find(S=>S.name===s).constants.find(S=>S.name===m);return l(v.type)},i=()=>{let s=`import type {${[...n.typeImports].join(", ")}} from "@polkadot-api/client";
`,m=`import {${[...n.imports].join(", ")}} from "@polkadot-api/substrate-bindings";

`,v=[...n.variables.values()].map(S=>`${n.enums.has(S.id)?`type E${S.id} = ${n.enums.get(S.id)};
export `:""}type ${S.id} = ${S.types};
const ${S.id}: Codec<${S.id}> = ${S.value};`).join(`

`);return`${s}${m}${v}`},t=()=>[...n.enums.keys()],u=s=>N[s]??n.variables.get(s)?.types??s;return{buildDefinition:l,buildStorage:h,buildEvent:o("events"),buildError:o("errors"),buildCall:o("calls"),buildRuntimeCall:f,buildConstant:y,getTypeFromVarName:u,getCode:i,getEnums:t}};var D=X(require("@polkadot-api/substrate-bindings"));var ee=require("@polkadot-api/utils"),xe=D.Bin(),Ee=(e,n,d,r)=>{if(e.type==="primitive")return D[e.value];if(e.type==="AccountId32")return r;if(e.type==="compact")return D.compact;if(e.type==="bitSequence")return D.bitSequence;if(e.type==="sequence"&&e.value.type==="primitive"&&e.value.value==="u8")return xe;let a=o=>te(o,n,d,r),p=(o,y)=>{let i=a(o);return y?D.Vector(i,y):D.Vector(i)},l=o=>D.Tuple(...o.map(a)),c=o=>{let y=Object.fromEntries(Object.entries(o).map(([i,t])=>[i,a(t)]));return D.Struct(y)};if(e.type==="array")return e.value.type==="primitive"&&e.value.value==="u8"?D.Bin(e.len):p(e.value,e.len);if(e.type==="sequence")return p(e.value);if(e.type==="tuple")return l(e.value);if(e.type==="struct")return c(e.value);if(e.type==="option")return D.Option(a(e.value));if(e.type==="result")return D.Result(a(e.value.ok),a(e.value.ko));let b=Object.values(e.value).map(o=>o.type==="primitive"?D._void:o.type==="tuple"&&o.value.length===1?a(o.value[0]):o.type==="tuple"?l(o.value):c(o.value)),g=Object.fromEntries(Object.keys(e.value).map((o,y)=>[o,b[y]])),h=Object.values(e.value).map(o=>o.idx);return h.every((o,y)=>o===y)?D.Variant(g):D.Variant(g,h)},te=I(Ee,D.Self,e=>e),ke=e=>{let n=e.lookup,d=L(n),r=D.AccountId(),a=new Map,p=t=>te(d(t),a,new Set,r),l=e.pallets.find(t=>t.name==="System")?.constants.find(t=>t.name==="SS58Prefix"),c;if(l)try{let t=p(l.type).dec(l.value);typeof t=="number"&&(c=t,r=D.AccountId(t))}catch{}let b=new Map,g=(t,u)=>{let s=b.get(t);s||b.set(t,s=D.Storage(t));let m=e.pallets.find(A=>A.name===t).storage.items.find(A=>A.name===u),v=(A,...H)=>{let J=s(...H);return{...J,len:A,fallback:m.modifier===1?J.dec(m.fallback):void 0}};if(m.type.tag==="plain")return v(0,u,p(m.type.value).dec);let{key:S,value:C,hashers:T}=m.type.value,q=p(C),O=T.map(A=>D[A.tag]),le=O.length===1?[[p(S),O[0]]]:d(S).value.map((A,H)=>[p(A.id),O[H]]);return v(O.length,u,q.dec,...le)},h=t=>t.type==="primitive"?D._void:t.type==="tuple"?D.Tuple(...Object.values(t.value).map(u=>p(u.id))):D.Struct((0,ee.mapObject)(t.value,u=>p(u.id))),f=(t,u)=>{let s=e.pallets.find(m=>m.name===t).constants.find(m=>m.name===u);return p(s.type)},o=t=>(u,s)=>{let m=e.pallets.find(C=>C.name===u),v=d(m[t]);if(v.type!=="enum")throw null;let S=v.value[s];return{location:[m.index,S.idx],codec:h(v.value[s])}},y=(t,u)=>{let s=e.pallets.find(S=>S.name===t),m=d(s.calls);if(m.type!=="enum")throw null;let v=m.value[u];return{location:[s.index,v.idx],args:h(m.value[u])}},i=(t,u)=>{let s=e.apis.find(m=>m.name===t)?.methods.find(m=>m.name===u);if(!s)throw null;return{args:D.Tuple(...s.inputs.map(m=>p(m.type))),value:p(s.output)}};return{buildDefinition:p,buildStorage:g,buildEvent:o("events"),buildError:o("errors"),buildRuntimeCall:i,buildCall:y,buildConstant:f,ss58Prefix:c}};var G=require("@polkadot-api/substrate-bindings");var re=new TextEncoder,Ve=re.encode.bind(re),k=e=>{let n=new Uint8Array(e.length*8),d=new DataView(n.buffer);for(let r=0;r<e.length;r++)d.setBigUint64(r*8,e[r]);return(0,G.h64)(n)},oe=e=>k(e.map(n=>(0,G.h64)(Ve(n)))),V={primitive:0n,vector:1n,tuple:2n,struct:3n,option:4n,result:5n,enum:6n},E={undefined:0n,number:1n,string:2n,bigint:3n,boolean:4n,bitSequence:5n,byteSequence:6n,accountId:7n},ne={_void:E.undefined,bool:E.boolean,char:E.string,str:E.string,u8:E.number,u16:E.number,u32:E.number,u64:E.bigint,u128:E.bigint,u256:E.bigint,i8:E.number,i16:E.number,i32:E.number,i64:E.bigint,i128:E.bigint,i256:E.bigint},K=(e,n,d)=>{let r=Object.entries(n).sort(([l],[c])=>l.localeCompare(c)),a=oe(r.map(([l])=>l)),p=k(r.map(([,l])=>d(l)));return k([e,a,p])},Ce=(e,n,d)=>{if(n.has(e.id))return n.get(e.id);if(e.type==="primitive")return k([V.primitive,ne[e.value]]);if(e.type==="compact")return k([V.primitive,E[e.isBig?"bigint":"number"]]);if(e.type==="bitSequence")return k([V.primitive,E.bitSequence]);if(e.type==="sequence"&&e.value.type==="primitive"&&e.value.value==="u8")return k([V.primitive,E.byteSequence]);if(e.type==="AccountId32")return k([V.primitive,E.accountId]);let r=l=>ie(l,n,d);if(e.type==="array"){let l=r(e.value);return k([V.vector,l,BigInt(e.len)])}if(e.type==="sequence"){let l=r(e.value);return k([V.vector,l])}let a=l=>k([V.tuple,...l.map(r)]),p=l=>K(V.struct,l,r);return e.type==="tuple"?a(e.value):e.type==="struct"?p(e.value):e.type==="option"?k([V.option,r(e.value)]):e.type==="result"?k([V.result,r(e.value.ok),r(e.value.ko)]):K(V.enum,e.value,l=>{switch(l.type){case"primitive":return ne._void;case"tuple":return a(l.value);case"struct":return p(l.value)}})},ie=I(Ce,()=>0n,e=>e),Te=e=>{let n=e.lookup,d=L(n),r=new Map,a=f=>ie(d(f),r,new Set),p=(f,o)=>{try{let y=e.pallets.find(m=>m.name===f).storage.items.find(m=>m.name===o);if(y.type.tag==="plain")return a(y.type.value);let{key:i,value:t}=y.type.value,u=a(t),s=a(i);return k([u,s])}catch{return null}},l=(f,o)=>{try{let y=e.apis.find(s=>s.name===f)?.methods.find(s=>s.name===o);if(!y)throw null;let i=oe(y.inputs.map(s=>s.name)),t=k(y.inputs.map(s=>a(s.type))),u=a(y.output);return k([i,t,u])}catch{return null}},c=f=>{if(f.type==="primitive")return k([0n]);if(f.type==="tuple"){let o=Object.values(f.value).map(y=>a(y.id));return k([V.tuple,...o])}return K(V.struct,f.value,o=>a(o.id))},b=f=>(o,y)=>{try{let i=e.pallets.find(u=>u.name===o),t=d(i[f]);if(t.type!=="enum")throw null;return c(t.value[y])}catch{return null}},g=(f,o)=>{try{let y=e.pallets.find(i=>i.name===f).constants.find(i=>i.name===o);return a(y.type)}catch{return null}},h=f=>(...o)=>f(...o)?.toString(32)??null;return{buildDefinition:h(a),buildRuntimeCall:h(l),buildStorage:h(p),buildCall:h(b("calls")),buildEvent:h(b("events")),buildError:h(b("errors")),buildConstant:h(g),buildComposite:h(c)}};var U=require("@polkadot-api/utils"),j=require("@polkadot-api/substrate-bindings");var _=require("@polkadot-api/utils"),x=X(require("@polkadot-api/substrate-bindings")),Re=_.toHex,se=(e,n)=>x.createDecoder(d=>{let r=d,a=r.i,p=e(r),l=Re(new Uint8Array(r.buffer.slice(a,r.i)));return{...n,value:p,input:l}}),M=(e,n,d)=>{let r=se(n,{codec:e,...d});return Object.assign(r,{shape:{codec:e}})},$=(e,n,d)=>{let r=se(n,{codec:e.codec,...d});return Object.assign(r,{shape:e})},Y=(e=42)=>{let n=x.enhanceDecoder(x.AccountId(e).dec,d=>({address:d,ss58Prefix:e}));return M("AccountId",n,{})},Pe=e=>M("BytesArray",x.Hex.dec(e),{len:e}),Ae=["_void","bool","char","str","u8","u16","u32","i8","i16","i32","u64","u128","u256","i64","i128","i256","compactNumber","compactBn","bitSequence"],Le=Object.fromEntries(Ae.map(e=>[e,M(e,x[e].dec)])),P={...Le,Bytes:M("Bytes",x.Hex.dec()),BytesArray:Pe,AccountId:Y()},we=e=>$({codec:"Sequence",shape:e.shape},x.Vector.dec(e)),Oe=(e,n)=>$({codec:"Array",shape:e.shape,len:n},x.Vector.dec(e,n)),Ie=(...e)=>$({codec:"Tuple",shape:e.map(n=>n.shape)},x.Tuple.dec(...e)),$e=e=>$({codec:"Struct",shape:(0,_.mapStringRecord)(e,n=>n.shape)},x.Struct.dec(e)),je=(e,n)=>$({codec:"Enum",shape:(0,_.mapStringRecord)(e,d=>d.shape)},x.Variant.dec(e,n)),_e=e=>$({codec:"Option",shape:e.shape},x.Option.dec(e)),qe=(e,n)=>$({codec:"Result",shape:{ok:e.shape,ko:n.shape}},x.Result.dec(e,n)),ae=e=>{let n=r=>{let a=e(),p=a;return n=a,p(r)},d=r=>n(r);return d.shape={codec:"_void"},d},R={Sequence:we,Array:Oe,Tuple:Ie,Struct:$e,Enum:je,Option:_e,Result:qe};var Be=R.Tuple(),ce=e=>(...n)=>{let d=e(...n);return{shape:d.shape,decoder:d}},z=(e,n,d)=>{let r=(0,j.enhanceDecoder)(e,a=>({...a,[n]:d}));return r.shape=e.shape,r},We=e=>(n,d,r,a,...p)=>{let{path:l}=a[n.id],c=e(n,d,r,a,...p);return l.length?z(c,"path",l):c},Me=(e,n,d,r,a)=>{if(e.type==="primitive")return P[e.value];if(e.type==="AccountId32")return a;if(e.type==="compact")return e.isBig?P.compactBn:P.compactNumber;if(e.type==="bitSequence")return P.bitSequence;if(e.type==="sequence"&&e.value.type==="primitive"&&e.value.value==="u8")return P.Bytes;let p=t=>pe(t,n,d,r,a),l=(t,u)=>{let s=p(t);return u?R.Array(s,u):R.Sequence(s)},c=(t,u)=>z(R.Tuple(...t.map(p)),"innerDocs",u),b=(t,u)=>z(R.Struct((0,U.mapStringRecord)(t,p)),"innerDocs",u);if(e.type==="array")return e.value.type==="primitive"&&e.value.value==="u8"?P.BytesArray(e.len):l(e.value,e.len);if(e.type==="sequence")return l(e.value);if(e.type==="tuple")return c(e.value,e.innerDocs);if(e.type==="struct")return b(e.value,e.innerDocs);if(e.type==="option")return R.Option(p(e.value));if(e.type==="result")return R.Result(p(e.value.ok),p(e.value.ko));let g=Object.values(e.value).map(t=>t.type==="primitive"?P._void:t.type==="tuple"&&t.value.length===1?p(t.value[0]):t.type==="tuple"?c(t.value,t.innerDocs):b(t.value,t.innerDocs)),h=Object.fromEntries(Object.keys(e.value).map((t,u)=>[t,g[u]])),f=Object.values(e.value).map(t=>t.idx),y=f.every((t,u)=>t===u)?R.Enum(h):R.Enum(h,f),i=(0,j.enhanceDecoder)(y,t=>{let u=e.innerDocs[t.value.type];return{...t,docs:u}});return i.shape=y.shape,i},Ue=We(Me),pe=I(Ue,ae,(e,n)=>(n.shape=e.shape,e)),ue=e=>`0x${e.toString(16).padEnd(2,"0")}`,de=e=>{let n=e.lookup,d=new Map,r=o=>pe(a(o),d,new Set,n,p),a=L(n),p=P.AccountId,l=e.pallets.find(o=>o.name==="System")?.constants.find(o=>o.name==="SS58Prefix");if(l)try{let o=r(l.type)(l.value).value;typeof o=="number"&&(p=Y(o))}catch{}let c=ce(r),b=(0,j.createDecoder)(o=>{let y=j.u8.dec(o),i=e.pallets.find(v=>v.index===y);if(!i)throw new Error("Invalid Pallet");let t={value:{name:i.name,idx:y},input:ue(o[0])},u=r(i.calls),s=u(o);if(s.codec!=="Enum")throw null;let m={value:{name:s.value.type,idx:o[1]},input:ue(o[1]),docs:s.docs};return{pallet:t,call:m,args:{value:s.value.value,shape:u.shape}}}),g=ce((o,y=!1)=>o.type==="primitive"?y?Be:P._void:o.type==="tuple"?R.Tuple(...Object.values(o.value).map(i=>r(i.id))):R.Struct((0,U.mapObject)(o.value,i=>r(i.id)))),h=o=>(y,i)=>{let t=e.pallets.find(m=>m.name===y),u=a(t[o]);if(u.type!=="enum")throw null;let s=u.value[i];return{location:[t.index,s.idx],view:g(s,o==="calls")}},f=(o,y)=>{let i=e.pallets.find(t=>t.name===o).constants.find(t=>t.name===y);return c(i.type)};return{buildDefinition:c,callDecoder:b,buildEvent:h("events"),buildError:h("errors"),buildCall:h("calls"),buildConstant:f}};
//# sourceMappingURL=index.js.map