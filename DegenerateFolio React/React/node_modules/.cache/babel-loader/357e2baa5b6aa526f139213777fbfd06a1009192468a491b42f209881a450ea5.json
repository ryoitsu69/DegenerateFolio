{"ast":null,"code":"import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { CanvasPool } from '../../shared/texture/CanvasPool.mjs';\nimport { BindGroup } from '../shader/BindGroup.mjs';\nimport { gpuUploadBufferImageResource } from './uploaders/gpuUploadBufferImageResource.mjs';\nimport { gpuUploadCompressedTextureResource, blockDataMap } from './uploaders/gpuUploadCompressedTextureResource.mjs';\nimport { gpuUploadImageResource } from './uploaders/gpuUploadImageSource.mjs';\nimport { gpuUploadVideoResource } from './uploaders/gpuUploadVideoSource.mjs';\nimport { GpuMipmapGenerator } from './utils/GpuMipmapGenerator.mjs';\n\"use strict\";\nclass GpuTextureSystem {\n  constructor(renderer) {\n    this.managedTextures = [];\n    this._gpuSources = /* @__PURE__ */Object.create(null);\n    this._gpuSamplers = /* @__PURE__ */Object.create(null);\n    this._bindGroupHash = /* @__PURE__ */Object.create(null);\n    this._textureViewHash = /* @__PURE__ */Object.create(null);\n    this._uploads = {\n      image: gpuUploadImageResource,\n      buffer: gpuUploadBufferImageResource,\n      video: gpuUploadVideoResource,\n      compressed: gpuUploadCompressedTextureResource\n    };\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  initSource(source) {\n    if (source.autoGenerateMipmaps) {\n      const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n    }\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n    if (source.uploadMethodId !== \"compressed\") {\n      usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n      usage |= GPUTextureUsage.COPY_SRC;\n    }\n    const blockData = blockDataMap[source.format] || {\n      blockBytes: 4,\n      blockWidth: 1,\n      blockHeight: 1\n    };\n    const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n    const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n    const textureDescriptor = {\n      label: source.label,\n      size: {\n        width,\n        height\n      },\n      format: source.format,\n      sampleCount: source.sampleCount,\n      mipLevelCount: source.mipLevelCount,\n      dimension: source.dimension,\n      usage\n    };\n    const gpuTexture = this._gpu.device.createTexture(textureDescriptor);\n    this._gpuSources[source.uid] = gpuTexture;\n    if (!this.managedTextures.includes(source)) {\n      source.on(\"update\", this.onSourceUpdate, this);\n      source.on(\"resize\", this.onSourceResize, this);\n      source.on(\"destroy\", this.onSourceDestroy, this);\n      source.on(\"unload\", this.onSourceUnload, this);\n      source.on(\"updateMipmaps\", this.onUpdateMipmaps, this);\n      this.managedTextures.push(source);\n    }\n    this.onSourceUpdate(source);\n    return gpuTexture;\n  }\n  onSourceUpdate(source) {\n    const gpuTexture = this.getGpuSource(source);\n    if (!gpuTexture) return;\n    if (this._uploads[source.uploadMethodId]) {\n      this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n    }\n    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {\n      this.onUpdateMipmaps(source);\n    }\n  }\n  onSourceUnload(source) {\n    const gpuTexture = this._gpuSources[source.uid];\n    if (gpuTexture) {\n      this._gpuSources[source.uid] = null;\n      gpuTexture.destroy();\n    }\n  }\n  onUpdateMipmaps(source) {\n    if (!this._mipmapGenerator) {\n      this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n    }\n    const gpuTexture = this.getGpuSource(source);\n    this._mipmapGenerator.generateMipmap(gpuTexture);\n  }\n  onSourceDestroy(source) {\n    source.off(\"update\", this.onSourceUpdate, this);\n    source.off(\"unload\", this.onSourceUnload, this);\n    source.off(\"destroy\", this.onSourceDestroy, this);\n    source.off(\"resize\", this.onSourceResize, this);\n    source.off(\"updateMipmaps\", this.onUpdateMipmaps, this);\n    this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n    this.onSourceUnload(source);\n  }\n  onSourceResize(source) {\n    const gpuTexture = this._gpuSources[source.uid];\n    if (!gpuTexture) {\n      this.initSource(source);\n    } else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight) {\n      this._textureViewHash[source.uid] = null;\n      this._bindGroupHash[source.uid] = null;\n      this.onSourceUnload(source);\n      this.initSource(source);\n    }\n  }\n  _initSampler(sampler) {\n    this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n    return this._gpuSamplers[sampler._resourceId];\n  }\n  getGpuSampler(sampler) {\n    return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n  }\n  getGpuSource(source) {\n    return this._gpuSources[source.uid] || this.initSource(source);\n  }\n  getTextureBindGroup(texture) {\n    return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);\n  }\n  _createTextureBindGroup(texture) {\n    const source = texture.source;\n    const bindGroupId = source.uid;\n    this._bindGroupHash[bindGroupId] = new BindGroup({\n      0: source,\n      1: source.style\n    });\n    return this._bindGroupHash[bindGroupId];\n  }\n  getTextureView(texture) {\n    const source = texture.source;\n    return this._textureViewHash[source.uid] ?? this._createTextureView(source);\n  }\n  _createTextureView(texture) {\n    this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();\n    return this._textureViewHash[texture.uid];\n  }\n  generateCanvas(texture) {\n    const renderer = this._renderer;\n    const commandEncoder = renderer.gpu.device.createCommandEncoder();\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = texture.source.pixelWidth;\n    canvas.height = texture.source.pixelHeight;\n    const context = canvas.getContext(\"webgpu\");\n    context.configure({\n      device: renderer.gpu.device,\n      // eslint-disable-next-line max-len\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n      format: navigator.gpu.getPreferredCanvasFormat(),\n      alphaMode: \"premultiplied\"\n    });\n    commandEncoder.copyTextureToTexture({\n      texture: renderer.texture.getGpuSource(texture.source),\n      origin: {\n        x: 0,\n        y: 0\n      }\n    }, {\n      texture: context.getCurrentTexture()\n    }, {\n      width: canvas.width,\n      height: canvas.height\n    });\n    renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    return canvas;\n  }\n  getPixels(texture) {\n    const webGPUCanvas = this.generateCanvas(texture);\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n    const context = canvasAndContext.context;\n    context.drawImage(webGPUCanvas, 0, 0);\n    const {\n      width,\n      height\n    } = webGPUCanvas;\n    const imageData = context.getImageData(0, 0, width, height);\n    const pixels = new Uint8ClampedArray(imageData.data.buffer);\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n    return {\n      pixels,\n      width,\n      height\n    };\n  }\n  destroy() {\n    this.managedTextures.slice().forEach(source => this.onSourceDestroy(source));\n    this.managedTextures = null;\n    for (const k of Object.keys(this._bindGroupHash)) {\n      const key = Number(k);\n      const bindGroup = this._bindGroupHash[key];\n      bindGroup?.destroy();\n      this._bindGroupHash[key] = null;\n    }\n    this._gpu = null;\n    this._mipmapGenerator = null;\n    this._gpuSources = null;\n    this._bindGroupHash = null;\n    this._textureViewHash = null;\n    this._gpuSamplers = null;\n  }\n}\n/** @ignore */\nGpuTextureSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"texture\"\n};\nexport { GpuTextureSystem };","map":{"version":3,"names":["GpuTextureSystem","constructor","renderer","managedTextures","_gpuSources","Object","create","_gpuSamplers","_bindGroupHash","_textureViewHash","_uploads","image","gpuUploadImageResource","buffer","gpuUploadBufferImageResource","video","gpuUploadVideoResource","compressed","gpuUploadCompressedTextureResource","_renderer","contextChange","gpu","_gpu","initSource","source","autoGenerateMipmaps","biggestDimension","Math","max","pixelWidth","pixelHeight","mipLevelCount","floor","log2","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","uploadMethodId","RENDER_ATTACHMENT","COPY_SRC","blockData","blockDataMap","format","blockBytes","blockWidth","blockHeight","width","ceil","height","textureDescriptor","label","size","sampleCount","dimension","gpuTexture","device","createTexture","uid","includes","on","onSourceUpdate","onSourceResize","onSourceDestroy","onSourceUnload","onUpdateMipmaps","push","getGpuSource","upload","destroy","_mipmapGenerator","GpuMipmapGenerator","generateMipmap","off","splice","indexOf","_initSampler","sampler","_resourceId","createSampler","getGpuSampler","getTextureBindGroup","texture","_createTextureBindGroup","bindGroupId","BindGroup","style","getTextureView","_createTextureView","createView","generateCanvas","commandEncoder","createCommandEncoder","canvas","DOMAdapter","get","createCanvas","context","getContext","configure","navigator","getPreferredCanvasFormat","alphaMode","copyTextureToTexture","origin","x","y","getCurrentTexture","queue","submit","finish","getPixels","webGPUCanvas","canvasAndContext","CanvasPool","getOptimalCanvasAndContext","drawImage","imageData","getImageData","pixels","Uint8ClampedArray","data","returnCanvasAndContext","slice","forEach","k","keys","key","Number","bindGroup","extension","type","ExtensionType","WebGPUSystem","name"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gpu/texture/GpuTextureSystem.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { CanvasPool } from '../../shared/texture/CanvasPool';\nimport { BindGroup } from '../shader/BindGroup';\nimport { gpuUploadBufferImageResource } from './uploaders/gpuUploadBufferImageResource';\nimport { blockDataMap, gpuUploadCompressedTextureResource } from './uploaders/gpuUploadCompressedTextureResource';\nimport { gpuUploadImageResource } from './uploaders/gpuUploadImageSource';\nimport { gpuUploadVideoResource } from './uploaders/gpuUploadVideoSource';\nimport { GpuMipmapGenerator } from './utils/GpuMipmapGenerator';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { BindableTexture, Texture } from '../../shared/texture/Texture';\nimport type { TextureStyle } from '../../shared/texture/TextureStyle';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuTextureUploader } from './uploaders/GpuTextureUploader';\n\n/**\n * The system that handles textures for the GPU.\n * @memberof rendering\n */\nexport class GpuTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    public readonly managedTextures: TextureSource[] = [];\n\n    protected CONTEXT_UID: number;\n    private _gpuSources: Record<number, GPUTexture> = Object.create(null);\n    private _gpuSamplers: Record<string, GPUSampler> = Object.create(null);\n    private _bindGroupHash: Record<string, BindGroup> = Object.create(null);\n    private _textureViewHash: Record<string, GPUTextureView> = Object.create(null);\n\n    private readonly _uploads: Record<string, GpuTextureUploader> = {\n        image: gpuUploadImageResource,\n        buffer: gpuUploadBufferImageResource,\n        video: gpuUploadVideoResource,\n        compressed: gpuUploadCompressedTextureResource\n    };\n\n    private _gpu: GPU;\n    private _mipmapGenerator?: GpuMipmapGenerator;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public initSource(source: TextureSource): GPUTexture\n    {\n        if (source.autoGenerateMipmaps)\n        {\n            const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n\n        let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n\n        if (source.uploadMethodId !== 'compressed')\n        {\n            usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n            usage |= GPUTextureUsage.COPY_SRC;\n        }\n\n        const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\n        const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n        const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n\n        const textureDescriptor: GPUTextureDescriptor = {\n            label: source.label,\n            size: { width, height },\n            format: source.format,\n            sampleCount: source.sampleCount,\n            mipLevelCount: source.mipLevelCount,\n            dimension: source.dimension,\n            usage\n        };\n\n        const gpuTexture = this._gpu.device.createTexture(textureDescriptor);\n\n        this._gpuSources[source.uid] = gpuTexture;\n\n        if (!this.managedTextures.includes(source))\n        {\n            source.on('update', this.onSourceUpdate, this);\n            source.on('resize', this.onSourceResize, this);\n            source.on('destroy', this.onSourceDestroy, this);\n            source.on('unload', this.onSourceUnload, this);\n            source.on('updateMipmaps', this.onUpdateMipmaps, this);\n\n            this.managedTextures.push(source);\n        }\n\n        this.onSourceUpdate(source);\n\n        return gpuTexture;\n    }\n\n    protected onSourceUpdate(source: TextureSource): void\n    {\n        const gpuTexture = this.getGpuSource(source);\n\n        // destroyed!\n        if (!gpuTexture) return;\n\n        if (this._uploads[source.uploadMethodId])\n        {\n            this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n        }\n\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1)\n        {\n            this.onUpdateMipmaps(source);\n        }\n    }\n\n    protected onSourceUnload(source: TextureSource): void\n    {\n        const gpuTexture = this._gpuSources[source.uid];\n\n        if (gpuTexture)\n        {\n            this._gpuSources[source.uid] = null;\n\n            gpuTexture.destroy();\n        }\n    }\n\n    protected onUpdateMipmaps(source: TextureSource): void\n    {\n        if (!this._mipmapGenerator)\n        {\n            this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n        }\n\n        const gpuTexture = this.getGpuSource(source);\n\n        this._mipmapGenerator.generateMipmap(gpuTexture);\n    }\n\n    protected onSourceDestroy(source: TextureSource): void\n    {\n        source.off('update', this.onSourceUpdate, this);\n        source.off('unload', this.onSourceUnload, this);\n        source.off('destroy', this.onSourceDestroy, this);\n        source.off('resize', this.onSourceResize, this);\n        source.off('updateMipmaps', this.onUpdateMipmaps, this);\n\n        this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n\n        this.onSourceUnload(source);\n    }\n\n    protected onSourceResize(source: TextureSource): void\n    {\n        const gpuTexture = this._gpuSources[source.uid];\n\n        if (!gpuTexture)\n        {\n            this.initSource(source);\n        }\n        else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight)\n        {\n            this._textureViewHash[source.uid] = null;\n            this._bindGroupHash[source.uid] = null;\n\n            this.onSourceUnload(source);\n            this.initSource(source);\n        }\n    }\n\n    private _initSampler(sampler: TextureStyle): GPUSampler\n    {\n        this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n\n        return this._gpuSamplers[sampler._resourceId];\n    }\n\n    public getGpuSampler(sampler: TextureStyle): GPUSampler\n    {\n        return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n\n    public getGpuSource(source: TextureSource): GPUTexture\n    {\n        return this._gpuSources[source.uid] || this.initSource(source);\n    }\n\n    public getTextureBindGroup(texture: Texture)\n    {\n        return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);\n    }\n\n    private _createTextureBindGroup(texture: BindableTexture)\n    {\n        const source = texture.source;\n\n        const bindGroupId = source.uid;\n\n        this._bindGroupHash[bindGroupId] = new BindGroup({\n            0: source,\n            1: source.style,\n        });\n\n        return this._bindGroupHash[bindGroupId];\n    }\n\n    public getTextureView(texture: BindableTexture)\n    {\n        const source = texture.source;\n\n        return this._textureViewHash[source.uid] ?? this._createTextureView(source);\n    }\n\n    private _createTextureView(texture: TextureSource)\n    {\n        this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();\n\n        return this._textureViewHash[texture.uid];\n    }\n\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const renderer = this._renderer;\n\n        const commandEncoder = renderer.gpu.device.createCommandEncoder();\n\n        // create canvas\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = texture.source.pixelWidth;\n        canvas.height = texture.source.pixelHeight;\n\n        const context = canvas.getContext('webgpu') as unknown as GPUCanvasContext;\n\n        context.configure({\n            device: renderer.gpu.device,\n            // eslint-disable-next-line max-len\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n            format: navigator.gpu.getPreferredCanvasFormat(),\n            alphaMode: 'premultiplied',\n        });\n\n        commandEncoder.copyTextureToTexture({\n            texture: renderer.texture.getGpuSource(texture.source),\n            origin: {\n                x: 0,\n                y: 0,\n            },\n        }, {\n            texture: context.getCurrentTexture(),\n        }, {\n            width: canvas.width,\n            height: canvas.height,\n        });\n\n        renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n\n        return canvas;\n    }\n\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const webGPUCanvas = this.generateCanvas(texture);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n\n        const context = canvasAndContext.context;\n\n        context.drawImage(webGPUCanvas, 0, 0);\n\n        const { width, height } = webGPUCanvas;\n\n        const imageData = context.getImageData(0, 0, width, height);\n\n        const pixels = new Uint8ClampedArray(imageData.data.buffer);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return { pixels, width, height };\n    }\n\n    public destroy(): void\n    {\n        // we copy the array as the aarry with a slice as onSourceDestroy\n        // will remove the source from the real managedTextures array\n        this.managedTextures\n            .slice()\n            .forEach((source) => this.onSourceDestroy(source));\n\n        (this.managedTextures as null) = null;\n\n        for (const k of Object.keys(this._bindGroupHash))\n        {\n            const key = Number(k);\n            const bindGroup = this._bindGroupHash[key];\n\n            bindGroup?.destroy();\n            this._bindGroupHash[key] = null;\n        }\n\n        this._gpu = null;\n        this._mipmapGenerator = null;\n        this._gpuSources = null;\n        this._bindGroupHash = null;\n        this._textureViewHash = null;\n        this._gpuSamplers = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}