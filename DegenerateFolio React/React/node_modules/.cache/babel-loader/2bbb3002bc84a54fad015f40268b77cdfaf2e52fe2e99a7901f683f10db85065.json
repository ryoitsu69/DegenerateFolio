{"ast":null,"code":"import { genericHash } from '../nacl/naclWrappers';\nimport { ABIType, ABITupleType } from './abi_type';\nimport { abiTypeIsTransaction } from './transaction';\nimport { abiTypeIsReference } from './reference';\nfunction parseMethodSignature(signature) {\n  const argsStart = signature.indexOf('(');\n  if (argsStart === -1) {\n    throw new Error(\"Invalid method signature: \".concat(signature));\n  }\n  let argsEnd = -1;\n  let depth = 0;\n  for (let i = argsStart; i < signature.length; i++) {\n    const char = signature[i];\n    if (char === '(') {\n      depth += 1;\n    } else if (char === ')') {\n      if (depth === 0) {\n        // unpaired parenthesis\n        break;\n      }\n      depth -= 1;\n      if (depth === 0) {\n        argsEnd = i;\n        break;\n      }\n    }\n  }\n  if (argsEnd === -1) {\n    throw new Error(\"Invalid method signature: \".concat(signature));\n  }\n  return {\n    name: signature.slice(0, argsStart),\n    args: ABITupleType.parseTupleContent(signature.slice(argsStart + 1, argsEnd)),\n    returns: signature.slice(argsEnd + 1)\n  };\n}\nexport class ABIMethod {\n  constructor(params) {\n    if (typeof params.name !== 'string' || typeof params.returns !== 'object' || !Array.isArray(params.args)) {\n      throw new Error('Invalid ABIMethod parameters');\n    }\n    this.name = params.name;\n    this.description = params.desc;\n    this.args = params.args.map(_ref => {\n      let {\n        type,\n        name,\n        desc\n      } = _ref;\n      if (abiTypeIsTransaction(type) || abiTypeIsReference(type)) {\n        return {\n          type,\n          name,\n          description: desc\n        };\n      }\n      return {\n        type: ABIType.from(type),\n        name,\n        description: desc\n      };\n    });\n    this.returns = {\n      type: params.returns.type === 'void' ? params.returns.type : ABIType.from(params.returns.type),\n      description: params.returns.desc\n    };\n  }\n  getSignature() {\n    const args = this.args.map(arg => arg.type.toString()).join(',');\n    const returns = this.returns.type.toString();\n    return \"\".concat(this.name, \"(\").concat(args, \")\").concat(returns);\n  }\n  getSelector() {\n    const hash = genericHash(this.getSignature());\n    return new Uint8Array(hash.slice(0, 4));\n  }\n  txnCount() {\n    let count = 1;\n    for (const arg of this.args) {\n      if (typeof arg.type === 'string' && abiTypeIsTransaction(arg.type)) {\n        count += 1;\n      }\n    }\n    return count;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      desc: this.description,\n      args: this.args.map(_ref2 => {\n        let {\n          type,\n          name,\n          description\n        } = _ref2;\n        return {\n          type: type.toString(),\n          name,\n          desc: description\n        };\n      }),\n      returns: {\n        type: this.returns.type.toString(),\n        desc: this.returns.description\n      }\n    };\n  }\n  static fromSignature(signature) {\n    const {\n      name,\n      args,\n      returns\n    } = parseMethodSignature(signature);\n    return new ABIMethod({\n      name,\n      args: args.map(arg => ({\n        type: arg\n      })),\n      returns: {\n        type: returns\n      }\n    });\n  }\n}\nexport function getMethodByName(methods, name) {\n  if (methods === null || !Array.isArray(methods) || !methods.every(item => item instanceof ABIMethod)) throw new Error('Methods list provided is null or not the correct type');\n  const filteredMethods = methods.filter(m => m.name === name);\n  if (filteredMethods.length > 1) throw new Error(\"found \".concat(filteredMethods.length, \" methods with the same name \").concat(filteredMethods.map(m => m.getSignature()).join(',')));\n  if (filteredMethods.length === 0) throw new Error(\"found 0 methods with the name \".concat(name));\n  return filteredMethods[0];\n}","map":{"version":3,"names":["genericHash","ABIType","ABITupleType","abiTypeIsTransaction","abiTypeIsReference","parseMethodSignature","signature","argsStart","indexOf","Error","concat","argsEnd","depth","i","length","char","name","slice","args","parseTupleContent","returns","ABIMethod","constructor","params","Array","isArray","description","desc","map","_ref","type","from","getSignature","arg","toString","join","getSelector","hash","Uint8Array","txnCount","count","toJSON","_ref2","fromSignature","getMethodByName","methods","every","item","filteredMethods","filter","m"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/algosdk/src/abi/method.ts"],"sourcesContent":["import { genericHash } from '../nacl/naclWrappers';\nimport { ABIType, ABITupleType } from './abi_type';\nimport { ABITransactionType, abiTypeIsTransaction } from './transaction';\nimport { ABIReferenceType, abiTypeIsReference } from './reference';\n\nfunction parseMethodSignature(\n  signature: string\n): { name: string; args: string[]; returns: string } {\n  const argsStart = signature.indexOf('(');\n  if (argsStart === -1) {\n    throw new Error(`Invalid method signature: ${signature}`);\n  }\n\n  let argsEnd = -1;\n  let depth = 0;\n  for (let i = argsStart; i < signature.length; i++) {\n    const char = signature[i];\n\n    if (char === '(') {\n      depth += 1;\n    } else if (char === ')') {\n      if (depth === 0) {\n        // unpaired parenthesis\n        break;\n      }\n\n      depth -= 1;\n      if (depth === 0) {\n        argsEnd = i;\n        break;\n      }\n    }\n  }\n\n  if (argsEnd === -1) {\n    throw new Error(`Invalid method signature: ${signature}`);\n  }\n\n  return {\n    name: signature.slice(0, argsStart),\n    args: ABITupleType.parseTupleContent(\n      signature.slice(argsStart + 1, argsEnd)\n    ),\n    returns: signature.slice(argsEnd + 1),\n  };\n}\n\nexport interface ABIMethodArgParams {\n  type: string;\n  name?: string;\n  desc?: string;\n}\n\nexport interface ABIMethodReturnParams {\n  type: string;\n  desc?: string;\n}\n\nexport interface ABIMethodParams {\n  name: string;\n  desc?: string;\n  args: ABIMethodArgParams[];\n  returns: ABIMethodReturnParams;\n}\n\nexport type ABIArgumentType = ABIType | ABITransactionType | ABIReferenceType;\n\nexport type ABIReturnType = ABIType | 'void';\n\nexport class ABIMethod {\n  public readonly name: string;\n  public readonly description?: string;\n  public readonly args: Array<{\n    type: ABIArgumentType;\n    name?: string;\n    description?: string;\n  }>;\n\n  public readonly returns: { type: ABIReturnType; description?: string };\n\n  constructor(params: ABIMethodParams) {\n    if (\n      typeof params.name !== 'string' ||\n      typeof params.returns !== 'object' ||\n      !Array.isArray(params.args)\n    ) {\n      throw new Error('Invalid ABIMethod parameters');\n    }\n\n    this.name = params.name;\n    this.description = params.desc;\n    this.args = params.args.map(({ type, name, desc }) => {\n      if (abiTypeIsTransaction(type) || abiTypeIsReference(type)) {\n        return {\n          type,\n          name,\n          description: desc,\n        };\n      }\n\n      return {\n        type: ABIType.from(type),\n        name,\n        description: desc,\n      };\n    });\n    this.returns = {\n      type:\n        params.returns.type === 'void'\n          ? params.returns.type\n          : ABIType.from(params.returns.type),\n      description: params.returns.desc,\n    };\n  }\n\n  getSignature(): string {\n    const args = this.args.map((arg) => arg.type.toString()).join(',');\n    const returns = this.returns.type.toString();\n    return `${this.name}(${args})${returns}`;\n  }\n\n  getSelector(): Uint8Array {\n    const hash = genericHash(this.getSignature());\n    return new Uint8Array(hash.slice(0, 4));\n  }\n\n  txnCount(): number {\n    let count = 1;\n    for (const arg of this.args) {\n      if (typeof arg.type === 'string' && abiTypeIsTransaction(arg.type)) {\n        count += 1;\n      }\n    }\n    return count;\n  }\n\n  toJSON(): ABIMethodParams {\n    return {\n      name: this.name,\n      desc: this.description,\n      args: this.args.map(({ type, name, description }) => ({\n        type: type.toString(),\n        name,\n        desc: description,\n      })),\n      returns: {\n        type: this.returns.type.toString(),\n        desc: this.returns.description,\n      },\n    };\n  }\n\n  static fromSignature(signature: string): ABIMethod {\n    const { name, args, returns } = parseMethodSignature(signature);\n\n    return new ABIMethod({\n      name,\n      args: args.map((arg) => ({ type: arg })),\n      returns: { type: returns },\n    });\n  }\n}\n\nexport function getMethodByName(methods: ABIMethod[], name: string): ABIMethod {\n  if (\n    methods === null ||\n    !Array.isArray(methods) ||\n    !methods.every((item) => item instanceof ABIMethod)\n  )\n    throw new Error('Methods list provided is null or not the correct type');\n\n  const filteredMethods = methods.filter((m: ABIMethod) => m.name === name);\n  if (filteredMethods.length > 1)\n    throw new Error(\n      `found ${\n        filteredMethods.length\n      } methods with the same name ${filteredMethods\n        .map((m: ABIMethod) => m.getSignature())\n        .join(',')}`\n    );\n\n  if (filteredMethods.length === 0)\n    throw new Error(`found 0 methods with the name ${name}`);\n\n  return filteredMethods[0];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}