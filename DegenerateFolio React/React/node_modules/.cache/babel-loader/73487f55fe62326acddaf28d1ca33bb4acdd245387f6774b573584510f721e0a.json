{"ast":null,"code":"import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { BN_BILLION, BN_ZERO, objectSpread } from '@polkadot/util';\nimport { firstMemo, memo } from '../util/index.js';\nfunction extractCompatRewards(ledger) {\n  return ledger ? ledger.legacyClaimedRewards || ledger.claimedRewards : [];\n}\nfunction parseRewards(api, stashId, [erasPoints, erasPrefs, erasRewards], exposures) {\n  return exposures.map(({\n    era,\n    isEmpty,\n    isValidator,\n    nominating,\n    validators: eraValidators\n  }) => {\n    const {\n      eraPoints,\n      validators: allValPoints\n    } = erasPoints.find(p => p.era.eq(era)) || {\n      eraPoints: BN_ZERO,\n      validators: {}\n    };\n    const {\n      eraReward\n    } = erasRewards.find(r => r.era.eq(era)) || {\n      eraReward: api.registry.createType('Balance')\n    };\n    const {\n      validators: allValPrefs\n    } = erasPrefs.find(p => p.era.eq(era)) || {\n      validators: {}\n    };\n    const validators = {};\n    const stakerId = stashId.toString();\n    Object.entries(eraValidators).forEach(([validatorId, exposure]) => {\n      const valPoints = allValPoints[validatorId] || BN_ZERO;\n      const valComm = allValPrefs[validatorId]?.commission.unwrap() || BN_ZERO;\n      const expTotal = exposure.total ? exposure.total?.unwrap() : exposure.pageTotal ? exposure.pageTotal?.unwrap() : BN_ZERO;\n      let avail = BN_ZERO;\n      let value;\n      if (!(expTotal.isZero() || valPoints.isZero() || eraPoints.isZero())) {\n        avail = eraReward.mul(valPoints).div(eraPoints);\n        const valCut = valComm.mul(avail).div(BN_BILLION);\n        let staked;\n        if (validatorId === stakerId) {\n          if (exposure.own) {\n            staked = exposure.own.unwrap();\n          } else {\n            const expAccount = exposure.others.find(({\n              who\n            }) => who.eq(validatorId));\n            staked = expAccount ? expAccount.value.unwrap() : BN_ZERO;\n          }\n        } else {\n          const stakerExp = exposure.others.find(({\n            who\n          }) => who.eq(stakerId));\n          staked = stakerExp ? stakerExp.value.unwrap() : BN_ZERO;\n        }\n        value = avail.sub(valCut).imul(staked).div(expTotal).iadd(validatorId === stakerId ? valCut : BN_ZERO);\n      }\n      validators[validatorId] = {\n        total: api.registry.createType('Balance', avail),\n        value: api.registry.createType('Balance', value)\n      };\n    });\n    return {\n      era,\n      eraReward,\n      isEmpty,\n      isValidator,\n      nominating,\n      validators\n    };\n  });\n}\nfunction allUniqValidators(rewards) {\n  return rewards.reduce(([all, perStash], rewards) => {\n    const uniq = [];\n    perStash.push(uniq);\n    rewards.forEach(({\n      validators\n    }) => Object.keys(validators).forEach(validatorId => {\n      if (!uniq.includes(validatorId)) {\n        uniq.push(validatorId);\n        if (!all.includes(validatorId)) {\n          all.push(validatorId);\n        }\n      }\n    }));\n    return [all, perStash];\n  }, [[], []]);\n}\nfunction removeClaimed(validators, queryValidators, reward) {\n  const rm = [];\n  Object.keys(reward.validators).forEach(validatorId => {\n    const index = validators.indexOf(validatorId);\n    if (index !== -1) {\n      const valLedger = queryValidators[index].stakingLedger;\n      if (extractCompatRewards(valLedger).some(e => reward.era.eq(e))) {\n        rm.push(validatorId);\n      }\n    }\n  });\n  rm.forEach(validatorId => {\n    delete reward.validators[validatorId];\n  });\n}\nfunction filterRewards(eras, valInfo, {\n  rewards,\n  stakingLedger\n}) {\n  const filter = eras.filter(e => !extractCompatRewards(stakingLedger).some(s => s.eq(e)));\n  const validators = valInfo.map(([v]) => v);\n  const queryValidators = valInfo.map(([, q]) => q);\n  return rewards.filter(({\n    isEmpty\n  }) => !isEmpty).filter(reward => {\n    if (!filter.some(e => reward.era.eq(e))) {\n      return false;\n    }\n    removeClaimed(validators, queryValidators, reward);\n    return true;\n  }).filter(({\n    validators\n  }) => Object.keys(validators).length !== 0).map(reward => objectSpread({}, reward, {\n    nominators: reward.nominating.filter(n => reward.validators[n.validatorId])\n  }));\n}\nexport function _stakerRewardsEras(instanceId, api) {\n  return memo(instanceId, (eras, withActive = false) => combineLatest([api.derive.staking._erasPoints(eras, withActive), api.derive.staking._erasPrefs(eras, withActive), api.derive.staking._erasRewards(eras, withActive)]));\n}\nexport function _stakerRewards(instanceId, api) {\n  return memo(instanceId, (accountIds, eras, withActive = false) => combineLatest([api.derive.staking.queryMulti(accountIds, {\n    withLedger: true\n  }), api.derive.staking._stakerExposures(accountIds, eras, withActive), api.derive.staking._stakerRewardsEras(eras, withActive)]).pipe(switchMap(([queries, exposures, erasResult]) => {\n    const allRewards = queries.map(({\n      stakingLedger,\n      stashId\n    }, index) => !stashId || !stakingLedger ? [] : parseRewards(api, stashId, erasResult, exposures[index]));\n    if (withActive) {\n      return of(allRewards);\n    }\n    const [allValidators, stashValidators] = allUniqValidators(allRewards);\n    return api.derive.staking.queryMulti(allValidators, {\n      withLedger: true\n    }).pipe(map(queriedVals => queries.map(({\n      stakingLedger\n    }, index) => filterRewards(eras, stashValidators[index].map(validatorId => [validatorId, queriedVals.find(q => q.accountId.eq(validatorId))]).filter(v => !!v[1]), {\n      rewards: allRewards[index],\n      stakingLedger\n    }))));\n  })));\n}\nexport const stakerRewards = /*#__PURE__*/firstMemo((api, accountId, withActive) => api.derive.staking.erasHistoric(withActive).pipe(switchMap(eras => api.derive.staking._stakerRewards([accountId], eras, withActive))));\nexport function stakerRewardsMultiEras(instanceId, api) {\n  return memo(instanceId, (accountIds, eras) => accountIds.length && eras.length ? api.derive.staking._stakerRewards(accountIds, eras, false) : of([]));\n}\nexport function stakerRewardsMulti(instanceId, api) {\n  return memo(instanceId, (accountIds, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe(switchMap(eras => api.derive.staking.stakerRewardsMultiEras(accountIds, eras))));\n}","map":{"version":3,"names":["combineLatest","map","of","switchMap","BN_BILLION","BN_ZERO","objectSpread","firstMemo","memo","extractCompatRewards","ledger","legacyClaimedRewards","claimedRewards","parseRewards","api","stashId","erasPoints","erasPrefs","erasRewards","exposures","era","isEmpty","isValidator","nominating","validators","eraValidators","eraPoints","allValPoints","find","p","eq","eraReward","r","registry","createType","allValPrefs","stakerId","toString","Object","entries","forEach","validatorId","exposure","valPoints","valComm","commission","unwrap","expTotal","total","pageTotal","avail","value","isZero","mul","div","valCut","staked","own","expAccount","others","who","stakerExp","sub","imul","iadd","allUniqValidators","rewards","reduce","all","perStash","uniq","push","keys","includes","removeClaimed","queryValidators","reward","rm","index","indexOf","valLedger","stakingLedger","some","e","filterRewards","eras","valInfo","filter","s","v","q","length","nominators","n","_stakerRewardsEras","instanceId","withActive","derive","staking","_erasPoints","_erasPrefs","_erasRewards","_stakerRewards","accountIds","queryMulti","withLedger","_stakerExposures","pipe","queries","erasResult","allRewards","allValidators","stashValidators","queriedVals","accountId","stakerRewards","erasHistoric","stakerRewardsMultiEras","stakerRewardsMulti"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api-derive/staking/stakerRewards.js"],"sourcesContent":["import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { BN_BILLION, BN_ZERO, objectSpread } from '@polkadot/util';\nimport { firstMemo, memo } from '../util/index.js';\nfunction extractCompatRewards(ledger) {\n    return ledger\n        ? (ledger.legacyClaimedRewards ||\n            ledger.claimedRewards)\n        : [];\n}\nfunction parseRewards(api, stashId, [erasPoints, erasPrefs, erasRewards], exposures) {\n    return exposures.map(({ era, isEmpty, isValidator, nominating, validators: eraValidators }) => {\n        const { eraPoints, validators: allValPoints } = erasPoints.find((p) => p.era.eq(era)) || { eraPoints: BN_ZERO, validators: {} };\n        const { eraReward } = erasRewards.find((r) => r.era.eq(era)) || { eraReward: api.registry.createType('Balance') };\n        const { validators: allValPrefs } = erasPrefs.find((p) => p.era.eq(era)) || { validators: {} };\n        const validators = {};\n        const stakerId = stashId.toString();\n        Object.entries(eraValidators).forEach(([validatorId, exposure]) => {\n            const valPoints = allValPoints[validatorId] || BN_ZERO;\n            const valComm = allValPrefs[validatorId]?.commission.unwrap() || BN_ZERO;\n            const expTotal = exposure.total\n                ? exposure.total?.unwrap()\n                : exposure.pageTotal\n                    ? exposure.pageTotal?.unwrap()\n                    : BN_ZERO;\n            let avail = BN_ZERO;\n            let value;\n            if (!(expTotal.isZero() || valPoints.isZero() || eraPoints.isZero())) {\n                avail = eraReward.mul(valPoints).div(eraPoints);\n                const valCut = valComm.mul(avail).div(BN_BILLION);\n                let staked;\n                if (validatorId === stakerId) {\n                    if (exposure.own) {\n                        staked = exposure.own.unwrap();\n                    }\n                    else {\n                        const expAccount = exposure.others.find(({ who }) => who.eq(validatorId));\n                        staked = expAccount\n                            ? expAccount.value.unwrap()\n                            : BN_ZERO;\n                    }\n                }\n                else {\n                    const stakerExp = exposure.others.find(({ who }) => who.eq(stakerId));\n                    staked = stakerExp\n                        ? stakerExp.value.unwrap()\n                        : BN_ZERO;\n                }\n                value = avail.sub(valCut).imul(staked).div(expTotal).iadd(validatorId === stakerId ? valCut : BN_ZERO);\n            }\n            validators[validatorId] = {\n                total: api.registry.createType('Balance', avail),\n                value: api.registry.createType('Balance', value)\n            };\n        });\n        return {\n            era,\n            eraReward,\n            isEmpty,\n            isValidator,\n            nominating,\n            validators\n        };\n    });\n}\nfunction allUniqValidators(rewards) {\n    return rewards.reduce(([all, perStash], rewards) => {\n        const uniq = [];\n        perStash.push(uniq);\n        rewards.forEach(({ validators }) => Object.keys(validators).forEach((validatorId) => {\n            if (!uniq.includes(validatorId)) {\n                uniq.push(validatorId);\n                if (!all.includes(validatorId)) {\n                    all.push(validatorId);\n                }\n            }\n        }));\n        return [all, perStash];\n    }, [[], []]);\n}\nfunction removeClaimed(validators, queryValidators, reward) {\n    const rm = [];\n    Object.keys(reward.validators).forEach((validatorId) => {\n        const index = validators.indexOf(validatorId);\n        if (index !== -1) {\n            const valLedger = queryValidators[index].stakingLedger;\n            if (extractCompatRewards(valLedger).some((e) => reward.era.eq(e))) {\n                rm.push(validatorId);\n            }\n        }\n    });\n    rm.forEach((validatorId) => {\n        delete reward.validators[validatorId];\n    });\n}\nfunction filterRewards(eras, valInfo, { rewards, stakingLedger }) {\n    const filter = eras.filter((e) => !extractCompatRewards(stakingLedger).some((s) => s.eq(e)));\n    const validators = valInfo.map(([v]) => v);\n    const queryValidators = valInfo.map(([, q]) => q);\n    return rewards\n        .filter(({ isEmpty }) => !isEmpty)\n        .filter((reward) => {\n        if (!filter.some((e) => reward.era.eq(e))) {\n            return false;\n        }\n        removeClaimed(validators, queryValidators, reward);\n        return true;\n    })\n        .filter(({ validators }) => Object.keys(validators).length !== 0)\n        .map((reward) => objectSpread({}, reward, {\n        nominators: reward.nominating.filter((n) => reward.validators[n.validatorId])\n    }));\n}\nexport function _stakerRewardsEras(instanceId, api) {\n    return memo(instanceId, (eras, withActive = false) => combineLatest([\n        api.derive.staking._erasPoints(eras, withActive),\n        api.derive.staking._erasPrefs(eras, withActive),\n        api.derive.staking._erasRewards(eras, withActive)\n    ]));\n}\nexport function _stakerRewards(instanceId, api) {\n    return memo(instanceId, (accountIds, eras, withActive = false) => combineLatest([\n        api.derive.staking.queryMulti(accountIds, { withLedger: true }),\n        api.derive.staking._stakerExposures(accountIds, eras, withActive),\n        api.derive.staking._stakerRewardsEras(eras, withActive)\n    ]).pipe(switchMap(([queries, exposures, erasResult]) => {\n        const allRewards = queries.map(({ stakingLedger, stashId }, index) => (!stashId || !stakingLedger)\n            ? []\n            : parseRewards(api, stashId, erasResult, exposures[index]));\n        if (withActive) {\n            return of(allRewards);\n        }\n        const [allValidators, stashValidators] = allUniqValidators(allRewards);\n        return api.derive.staking.queryMulti(allValidators, { withLedger: true }).pipe(map((queriedVals) => queries.map(({ stakingLedger }, index) => filterRewards(eras, stashValidators[index]\n            .map((validatorId) => [\n            validatorId,\n            queriedVals.find((q) => q.accountId.eq(validatorId))\n        ])\n            .filter((v) => !!v[1]), {\n            rewards: allRewards[index],\n            stakingLedger\n        }))));\n    })));\n}\nexport const stakerRewards = /*#__PURE__*/ firstMemo((api, accountId, withActive) => api.derive.staking.erasHistoric(withActive).pipe(switchMap((eras) => api.derive.staking._stakerRewards([accountId], eras, withActive))));\nexport function stakerRewardsMultiEras(instanceId, api) {\n    return memo(instanceId, (accountIds, eras) => accountIds.length && eras.length\n        ? api.derive.staking._stakerRewards(accountIds, eras, false)\n        : of([]));\n}\nexport function stakerRewardsMulti(instanceId, api) {\n    return memo(instanceId, (accountIds, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe(switchMap((eras) => api.derive.staking.stakerRewardsMultiEras(accountIds, eras))));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}