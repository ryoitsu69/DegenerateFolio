{"ast":null,"code":"import { lazyMethod, objectSpread, stringCamelCase } from '@polkadot/util';\nimport { lazyVariants } from '../../../create/lazy.js';\nimport { getSiName } from '../../util/index.js';\nimport { objectNameToCamel } from '../util.js';\nimport { createUnchecked } from './createUnchecked.js';\nexport function filterCallsSome({\n  calls\n}) {\n  return calls.isSome;\n}\nexport function createCallFunction(registry, lookup, variant, sectionName, sectionIndex) {\n  const {\n    fields,\n    index\n  } = variant;\n  const count = fields.length;\n  const args = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const {\n      name,\n      type,\n      typeName\n    } = fields[i];\n    args[i] = objectSpread({\n      name: stringCamelCase(name.unwrapOr(`param${i}`)),\n      type: getSiName(lookup, type)\n    }, typeName.isSome ? {\n      typeName: typeName.unwrap()\n    } : null);\n  }\n  return createUnchecked(registry, sectionName, new Uint8Array([sectionIndex, index.toNumber()]), registry.createTypeUnsafe('FunctionMetadataLatest', [objectSpread({\n    args\n  }, variant)]));\n}\n/** @internal */\nexport function decorateExtrinsics(registry, {\n  lookup,\n  pallets\n}, version) {\n  const result = {};\n  const filtered = pallets.filter(filterCallsSome);\n  for (let i = 0, count = filtered.length; i < count; i++) {\n    const {\n      calls,\n      index,\n      name\n    } = filtered[i];\n    const sectionName = stringCamelCase(name);\n    const sectionIndex = version >= 12 ? index.toNumber() : i;\n    lazyMethod(result, sectionName, () => lazyVariants(lookup, calls.unwrap(), objectNameToCamel, variant => createCallFunction(registry, lookup, variant, sectionName, sectionIndex)));\n  }\n  return result;\n}","map":{"version":3,"names":["lazyMethod","objectSpread","stringCamelCase","lazyVariants","getSiName","objectNameToCamel","createUnchecked","filterCallsSome","calls","isSome","createCallFunction","registry","lookup","variant","sectionName","sectionIndex","fields","index","count","length","args","Array","i","name","type","typeName","unwrapOr","unwrap","Uint8Array","toNumber","createTypeUnsafe","decorateExtrinsics","pallets","version","result","filtered","filter"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/metadata/decorate/extrinsics/index.js"],"sourcesContent":["import { lazyMethod, objectSpread, stringCamelCase } from '@polkadot/util';\nimport { lazyVariants } from '../../../create/lazy.js';\nimport { getSiName } from '../../util/index.js';\nimport { objectNameToCamel } from '../util.js';\nimport { createUnchecked } from './createUnchecked.js';\nexport function filterCallsSome({ calls }) {\n    return calls.isSome;\n}\nexport function createCallFunction(registry, lookup, variant, sectionName, sectionIndex) {\n    const { fields, index } = variant;\n    const count = fields.length;\n    const args = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const { name, type, typeName } = fields[i];\n        args[i] = objectSpread({\n            name: stringCamelCase(name.unwrapOr(`param${i}`)),\n            type: getSiName(lookup, type)\n        }, typeName.isSome\n            ? { typeName: typeName.unwrap() }\n            : null);\n    }\n    return createUnchecked(registry, sectionName, new Uint8Array([sectionIndex, index.toNumber()]), registry.createTypeUnsafe('FunctionMetadataLatest', [objectSpread({ args }, variant)]));\n}\n/** @internal */\nexport function decorateExtrinsics(registry, { lookup, pallets }, version) {\n    const result = {};\n    const filtered = pallets.filter(filterCallsSome);\n    for (let i = 0, count = filtered.length; i < count; i++) {\n        const { calls, index, name } = filtered[i];\n        const sectionName = stringCamelCase(name);\n        const sectionIndex = version >= 12 ? index.toNumber() : i;\n        lazyMethod(result, sectionName, () => lazyVariants(lookup, calls.unwrap(), objectNameToCamel, (variant) => createCallFunction(registry, lookup, variant, sectionName, sectionIndex)));\n    }\n    return result;\n}\n"],"mappings":"AAAA,SAASA,UAAU,EAAEC,YAAY,EAAEC,eAAe,QAAQ,gBAAgB;AAC1E,SAASC,YAAY,QAAQ,yBAAyB;AACtD,SAASC,SAAS,QAAQ,qBAAqB;AAC/C,SAASC,iBAAiB,QAAQ,YAAY;AAC9C,SAASC,eAAe,QAAQ,sBAAsB;AACtD,OAAO,SAASC,eAAeA,CAAC;EAAEC;AAAM,CAAC,EAAE;EACvC,OAAOA,KAAK,CAACC,MAAM;AACvB;AACA,OAAO,SAASC,kBAAkBA,CAACC,QAAQ,EAAEC,MAAM,EAAEC,OAAO,EAAEC,WAAW,EAAEC,YAAY,EAAE;EACrF,MAAM;IAAEC,MAAM;IAAEC;EAAM,CAAC,GAAGJ,OAAO;EACjC,MAAMK,KAAK,GAAGF,MAAM,CAACG,MAAM;EAC3B,MAAMC,IAAI,GAAG,IAAIC,KAAK,CAACH,KAAK,CAAC;EAC7B,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,EAAEI,CAAC,EAAE,EAAE;IAC5B,MAAM;MAAEC,IAAI;MAAEC,IAAI;MAAEC;IAAS,CAAC,GAAGT,MAAM,CAACM,CAAC,CAAC;IAC1CF,IAAI,CAACE,CAAC,CAAC,GAAGrB,YAAY,CAAC;MACnBsB,IAAI,EAAErB,eAAe,CAACqB,IAAI,CAACG,QAAQ,CAAE,QAAOJ,CAAE,EAAC,CAAC,CAAC;MACjDE,IAAI,EAAEpB,SAAS,CAACQ,MAAM,EAAEY,IAAI;IAChC,CAAC,EAAEC,QAAQ,CAAChB,MAAM,GACZ;MAAEgB,QAAQ,EAAEA,QAAQ,CAACE,MAAM,CAAC;IAAE,CAAC,GAC/B,IAAI,CAAC;EACf;EACA,OAAOrB,eAAe,CAACK,QAAQ,EAAEG,WAAW,EAAE,IAAIc,UAAU,CAAC,CAACb,YAAY,EAAEE,KAAK,CAACY,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAElB,QAAQ,CAACmB,gBAAgB,CAAC,wBAAwB,EAAE,CAAC7B,YAAY,CAAC;IAAEmB;EAAK,CAAC,EAAEP,OAAO,CAAC,CAAC,CAAC,CAAC;AAC3L;AACA;AACA,OAAO,SAASkB,kBAAkBA,CAACpB,QAAQ,EAAE;EAAEC,MAAM;EAAEoB;AAAQ,CAAC,EAAEC,OAAO,EAAE;EACvE,MAAMC,MAAM,GAAG,CAAC,CAAC;EACjB,MAAMC,QAAQ,GAAGH,OAAO,CAACI,MAAM,CAAC7B,eAAe,CAAC;EAChD,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEJ,KAAK,GAAGiB,QAAQ,CAAChB,MAAM,EAAEG,CAAC,GAAGJ,KAAK,EAAEI,CAAC,EAAE,EAAE;IACrD,MAAM;MAAEd,KAAK;MAAES,KAAK;MAAEM;IAAK,CAAC,GAAGY,QAAQ,CAACb,CAAC,CAAC;IAC1C,MAAMR,WAAW,GAAGZ,eAAe,CAACqB,IAAI,CAAC;IACzC,MAAMR,YAAY,GAAGkB,OAAO,IAAI,EAAE,GAAGhB,KAAK,CAACY,QAAQ,CAAC,CAAC,GAAGP,CAAC;IACzDtB,UAAU,CAACkC,MAAM,EAAEpB,WAAW,EAAE,MAAMX,YAAY,CAACS,MAAM,EAAEJ,KAAK,CAACmB,MAAM,CAAC,CAAC,EAAEtB,iBAAiB,EAAGQ,OAAO,IAAKH,kBAAkB,CAACC,QAAQ,EAAEC,MAAM,EAAEC,OAAO,EAAEC,WAAW,EAAEC,YAAY,CAAC,CAAC,CAAC;EACzL;EACA,OAAOmB,MAAM;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}