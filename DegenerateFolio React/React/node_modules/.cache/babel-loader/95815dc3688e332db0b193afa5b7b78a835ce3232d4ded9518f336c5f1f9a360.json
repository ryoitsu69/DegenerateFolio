{"ast":null,"code":"import { identity, isU8a, u8aConcatStrict } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8aVec, typeToConstructor } from '../utils/index.js';\nimport { decodeVec } from './Vec.js';\n/**\n * @name VecFixed\n * @description\n * This manages codec arrays of a fixed length\n */\nexport class VecFixed extends AbstractArray {\n  __internal__Type;\n  constructor(registry, Type, length, value = [], {\n    definition,\n    setDefinition = identity\n  } = {}) {\n    super(registry, length);\n    this.__internal__Type = definition || setDefinition(typeToConstructor(registry, Type));\n    this.initialU8aLength = (isU8a(value) ? decodeU8aVec(registry, this, value, 0, this.__internal__Type) : decodeVec(registry, this, value, 0, this.__internal__Type))[1];\n  }\n  static with(Type, length) {\n    let definition;\n    // eslint-disable-next-line no-return-assign\n    const setDefinition = d => definition = d;\n    return class extends VecFixed {\n      constructor(registry, value) {\n        super(registry, Type, length, value, {\n          definition,\n          setDefinition\n        });\n      }\n    };\n  }\n  /**\n   * @description The type for the items\n   */\n  get Type() {\n    return new this.__internal__Type(this.registry).toRawType();\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    let total = 0;\n    for (let i = 0, count = this.length; i < count; i++) {\n      total += this[i].encodedLength;\n    }\n    return total;\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return {\n      inner: this.inspectInner()\n    };\n  }\n  toU8a() {\n    // we override, we don't add the length prefix for ourselves, and at the same time we\n    // ignore isBare on entries, since they should be properly encoded at all times\n    const encoded = this.toU8aInner();\n    return encoded.length ? u8aConcatStrict(encoded) : new Uint8Array([]);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return `[${this.Type};${this.length}]`;\n  }\n}","map":{"version":3,"names":["identity","isU8a","u8aConcatStrict","AbstractArray","decodeU8aVec","typeToConstructor","decodeVec","VecFixed","__internal__Type","constructor","registry","Type","length","value","definition","setDefinition","initialU8aLength","with","d","toRawType","encodedLength","total","i","count","inspect","inner","inspectInner","toU8a","encoded","toU8aInner","Uint8Array"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/base/VecFixed.js"],"sourcesContent":["import { identity, isU8a, u8aConcatStrict } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8aVec, typeToConstructor } from '../utils/index.js';\nimport { decodeVec } from './Vec.js';\n/**\n * @name VecFixed\n * @description\n * This manages codec arrays of a fixed length\n */\nexport class VecFixed extends AbstractArray {\n    __internal__Type;\n    constructor(registry, Type, length, value = [], { definition, setDefinition = identity } = {}) {\n        super(registry, length);\n        this.__internal__Type = definition || setDefinition(typeToConstructor(registry, Type));\n        this.initialU8aLength = (isU8a(value)\n            ? decodeU8aVec(registry, this, value, 0, this.__internal__Type)\n            : decodeVec(registry, this, value, 0, this.__internal__Type))[1];\n    }\n    static with(Type, length) {\n        let definition;\n        // eslint-disable-next-line no-return-assign\n        const setDefinition = (d) => (definition = d);\n        return class extends VecFixed {\n            constructor(registry, value) {\n                super(registry, Type, length, value, { definition, setDefinition });\n            }\n        };\n    }\n    /**\n     * @description The type for the items\n     */\n    get Type() {\n        return new this.__internal__Type(this.registry).toRawType();\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        let total = 0;\n        for (let i = 0, count = this.length; i < count; i++) {\n            total += this[i].encodedLength;\n        }\n        return total;\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            inner: this.inspectInner()\n        };\n    }\n    toU8a() {\n        // we override, we don't add the length prefix for ourselves, and at the same time we\n        // ignore isBare on entries, since they should be properly encoded at all times\n        const encoded = this.toU8aInner();\n        return encoded.length\n            ? u8aConcatStrict(encoded)\n            : new Uint8Array([]);\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `[${this.Type};${this.length}]`;\n    }\n}\n"],"mappings":"AAAA,SAASA,QAAQ,EAAEC,KAAK,EAAEC,eAAe,QAAQ,gBAAgB;AACjE,SAASC,aAAa,QAAQ,sBAAsB;AACpD,SAASC,YAAY,EAAEC,iBAAiB,QAAQ,mBAAmB;AACnE,SAASC,SAAS,QAAQ,UAAU;AACpC;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,QAAQ,SAASJ,aAAa,CAAC;EACxCK,gBAAgB;EAChBC,WAAWA,CAACC,QAAQ,EAAEC,IAAI,EAAEC,MAAM,EAAEC,KAAK,GAAG,EAAE,EAAE;IAAEC,UAAU;IAAEC,aAAa,GAAGf;EAAS,CAAC,GAAG,CAAC,CAAC,EAAE;IAC3F,KAAK,CAACU,QAAQ,EAAEE,MAAM,CAAC;IACvB,IAAI,CAACJ,gBAAgB,GAAGM,UAAU,IAAIC,aAAa,CAACV,iBAAiB,CAACK,QAAQ,EAAEC,IAAI,CAAC,CAAC;IACtF,IAAI,CAACK,gBAAgB,GAAG,CAACf,KAAK,CAACY,KAAK,CAAC,GAC/BT,YAAY,CAACM,QAAQ,EAAE,IAAI,EAAEG,KAAK,EAAE,CAAC,EAAE,IAAI,CAACL,gBAAgB,CAAC,GAC7DF,SAAS,CAACI,QAAQ,EAAE,IAAI,EAAEG,KAAK,EAAE,CAAC,EAAE,IAAI,CAACL,gBAAgB,CAAC,EAAE,CAAC,CAAC;EACxE;EACA,OAAOS,IAAIA,CAACN,IAAI,EAAEC,MAAM,EAAE;IACtB,IAAIE,UAAU;IACd;IACA,MAAMC,aAAa,GAAIG,CAAC,IAAMJ,UAAU,GAAGI,CAAE;IAC7C,OAAO,cAAcX,QAAQ,CAAC;MAC1BE,WAAWA,CAACC,QAAQ,EAAEG,KAAK,EAAE;QACzB,KAAK,CAACH,QAAQ,EAAEC,IAAI,EAAEC,MAAM,EAAEC,KAAK,EAAE;UAAEC,UAAU;UAAEC;QAAc,CAAC,CAAC;MACvE;IACJ,CAAC;EACL;EACA;AACJ;AACA;EACI,IAAIJ,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,IAAI,CAACH,gBAAgB,CAAC,IAAI,CAACE,QAAQ,CAAC,CAACS,SAAS,CAAC,CAAC;EAC/D;EACA;AACJ;AACA;EACI,IAAIC,aAAaA,CAAA,EAAG;IAChB,IAAIC,KAAK,GAAG,CAAC;IACb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,KAAK,GAAG,IAAI,CAACX,MAAM,EAAEU,CAAC,GAAGC,KAAK,EAAED,CAAC,EAAE,EAAE;MACjDD,KAAK,IAAI,IAAI,CAACC,CAAC,CAAC,CAACF,aAAa;IAClC;IACA,OAAOC,KAAK;EAChB;EACA;AACJ;AACA;EACIG,OAAOA,CAAA,EAAG;IACN,OAAO;MACHC,KAAK,EAAE,IAAI,CAACC,YAAY,CAAC;IAC7B,CAAC;EACL;EACAC,KAAKA,CAAA,EAAG;IACJ;IACA;IACA,MAAMC,OAAO,GAAG,IAAI,CAACC,UAAU,CAAC,CAAC;IACjC,OAAOD,OAAO,CAAChB,MAAM,GACfV,eAAe,CAAC0B,OAAO,CAAC,GACxB,IAAIE,UAAU,CAAC,EAAE,CAAC;EAC5B;EACA;AACJ;AACA;EACIX,SAASA,CAAA,EAAG;IACR,OAAQ,IAAG,IAAI,CAACR,IAAK,IAAG,IAAI,CAACC,MAAO,GAAE;EAC1C;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}