{"ast":null,"code":"import { Struct } from '@polkadot/types-codec';\nimport { isU8a, isUndefined, objectProperties, objectSpread, stringify, u8aToHex } from '@polkadot/util';\nimport { EMPTY_U8A, IMMORTAL_ERA } from '../constants.js';\nimport { GenericExtrinsicPayloadV4 } from './ExtrinsicPayload.js';\nconst FAKE_SIGNATURE = new Uint8Array(256).fill(1);\nfunction toAddress(registry, address) {\n  return registry.createTypeUnsafe('Address', [isU8a(address) ? u8aToHex(address) : address]);\n}\n/**\n * @name GenericExtrinsicSignatureV4\n * @description\n * A container for the [[Signature]] associated with a specific [[Extrinsic]]\n */\nexport class GenericExtrinsicSignatureV4 extends Struct {\n  __internal__signKeys;\n  constructor(registry, value, {\n    isSigned\n  } = {}) {\n    const signTypes = registry.getSignedExtensionTypes();\n    super(registry, objectSpread(\n    // eslint-disable-next-line sort-keys\n    {\n      signer: 'Address',\n      signature: 'ExtrinsicSignature'\n    }, signTypes), GenericExtrinsicSignatureV4.decodeExtrinsicSignature(value, isSigned));\n    this.__internal__signKeys = Object.keys(signTypes);\n    objectProperties(this, this.__internal__signKeys, k => this.get(k));\n  }\n  /** @internal */\n  static decodeExtrinsicSignature(value, isSigned = false) {\n    if (!value) {\n      return EMPTY_U8A;\n    } else if (value instanceof GenericExtrinsicSignatureV4) {\n      return value;\n    }\n    return isSigned ? value : EMPTY_U8A;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    return this.isSigned ? super.encodedLength : 0;\n  }\n  /**\n   * @description `true` if the signature is valid\n   */\n  get isSigned() {\n    return !this.signature.isEmpty;\n  }\n  /**\n   * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to\n   */\n  get era() {\n    return this.getT('era');\n  }\n  /**\n   * @description The [[Index]] for the signature\n   */\n  get nonce() {\n    return this.getT('nonce');\n  }\n  /**\n   * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]\n   */\n  get signature() {\n    // the second case here is when we don't have an enum signature, treat as raw\n    return this.multiSignature.value || this.multiSignature;\n  }\n  /**\n   * @description The raw [[ExtrinsicSignature]]\n   */\n  get multiSignature() {\n    return this.getT('signature');\n  }\n  /**\n   * @description The [[Address]] that signed\n   */\n  get signer() {\n    return this.getT('signer');\n  }\n  /**\n   * @description The [[Balance]] tip\n   */\n  get tip() {\n    return this.getT('tip');\n  }\n  /**\n   * @description The [[u32]] or [[MultiLocation]] assetId\n   */\n  get assetId() {\n    return this.getT('assetId');\n  }\n  _injectSignature(signer, signature, payload) {\n    // use the fields exposed to guide the getters\n    for (let i = 0, count = this.__internal__signKeys.length; i < count; i++) {\n      const k = this.__internal__signKeys[i];\n      const v = payload.get(k);\n      if (!isUndefined(v)) {\n        this.set(k, v);\n      }\n    }\n    // additional fields (exposed in struct itself)\n    this.set('signer', signer);\n    this.set('signature', signature);\n    return this;\n  }\n  /**\n   * @description Adds a raw signature\n   */\n  addSignature(signer, signature, payload) {\n    return this._injectSignature(toAddress(this.registry, signer), this.registry.createTypeUnsafe('ExtrinsicSignature', [signature]), new GenericExtrinsicPayloadV4(this.registry, payload));\n  }\n  /**\n   * @description Creates a payload from the supplied options\n   */\n  createPayload(method, options) {\n    const {\n      era,\n      runtimeVersion: {\n        specVersion,\n        transactionVersion\n      }\n    } = options;\n    return new GenericExtrinsicPayloadV4(this.registry, objectSpread({}, options, {\n      era: era || IMMORTAL_ERA,\n      method: method.toHex(),\n      specVersion,\n      transactionVersion\n    }));\n  }\n  /**\n   * @description Generate a payload and applies the signature from a keypair\n   */\n  sign(method, account, options) {\n    if (!account?.addressRaw) {\n      throw new Error(`Expected a valid keypair for signing, found ${stringify(account)}`);\n    }\n    const payload = this.createPayload(method, options);\n    return this._injectSignature(toAddress(this.registry, account.addressRaw), this.registry.createTypeUnsafe('ExtrinsicSignature', [payload.sign(account)]), payload);\n  }\n  /**\n   * @description Generate a payload and applies a fake signature\n   */\n  signFake(method, address, options) {\n    if (!address) {\n      throw new Error(`Expected a valid address for signing, found ${stringify(address)}`);\n    }\n    const payload = this.createPayload(method, options);\n    return this._injectSignature(toAddress(this.registry, address), this.registry.createTypeUnsafe('ExtrinsicSignature', [FAKE_SIGNATURE]), payload);\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    return this.isSigned ? super.toU8a(isBare) : EMPTY_U8A;\n  }\n}","map":{"version":3,"names":["Struct","isU8a","isUndefined","objectProperties","objectSpread","stringify","u8aToHex","EMPTY_U8A","IMMORTAL_ERA","GenericExtrinsicPayloadV4","FAKE_SIGNATURE","Uint8Array","fill","toAddress","registry","address","createTypeUnsafe","GenericExtrinsicSignatureV4","__internal__signKeys","constructor","value","isSigned","signTypes","getSignedExtensionTypes","signer","signature","decodeExtrinsicSignature","Object","keys","k","get","encodedLength","isEmpty","era","getT","nonce","multiSignature","tip","assetId","_injectSignature","payload","i","count","length","v","set","addSignature","createPayload","method","options","runtimeVersion","specVersion","transactionVersion","toHex","sign","account","addressRaw","Error","signFake","toU8a","isBare"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/extrinsic/v4/ExtrinsicSignature.js"],"sourcesContent":["import { Struct } from '@polkadot/types-codec';\nimport { isU8a, isUndefined, objectProperties, objectSpread, stringify, u8aToHex } from '@polkadot/util';\nimport { EMPTY_U8A, IMMORTAL_ERA } from '../constants.js';\nimport { GenericExtrinsicPayloadV4 } from './ExtrinsicPayload.js';\nconst FAKE_SIGNATURE = new Uint8Array(256).fill(1);\nfunction toAddress(registry, address) {\n    return registry.createTypeUnsafe('Address', [isU8a(address) ? u8aToHex(address) : address]);\n}\n/**\n * @name GenericExtrinsicSignatureV4\n * @description\n * A container for the [[Signature]] associated with a specific [[Extrinsic]]\n */\nexport class GenericExtrinsicSignatureV4 extends Struct {\n    __internal__signKeys;\n    constructor(registry, value, { isSigned } = {}) {\n        const signTypes = registry.getSignedExtensionTypes();\n        super(registry, objectSpread(\n        // eslint-disable-next-line sort-keys\n        { signer: 'Address', signature: 'ExtrinsicSignature' }, signTypes), GenericExtrinsicSignatureV4.decodeExtrinsicSignature(value, isSigned));\n        this.__internal__signKeys = Object.keys(signTypes);\n        objectProperties(this, this.__internal__signKeys, (k) => this.get(k));\n    }\n    /** @internal */\n    static decodeExtrinsicSignature(value, isSigned = false) {\n        if (!value) {\n            return EMPTY_U8A;\n        }\n        else if (value instanceof GenericExtrinsicSignatureV4) {\n            return value;\n        }\n        return isSigned\n            ? value\n            : EMPTY_U8A;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return this.isSigned\n            ? super.encodedLength\n            : 0;\n    }\n    /**\n     * @description `true` if the signature is valid\n     */\n    get isSigned() {\n        return !this.signature.isEmpty;\n    }\n    /**\n     * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to\n     */\n    get era() {\n        return this.getT('era');\n    }\n    /**\n     * @description The [[Index]] for the signature\n     */\n    get nonce() {\n        return this.getT('nonce');\n    }\n    /**\n     * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]\n     */\n    get signature() {\n        // the second case here is when we don't have an enum signature, treat as raw\n        return (this.multiSignature.value || this.multiSignature);\n    }\n    /**\n     * @description The raw [[ExtrinsicSignature]]\n     */\n    get multiSignature() {\n        return this.getT('signature');\n    }\n    /**\n     * @description The [[Address]] that signed\n     */\n    get signer() {\n        return this.getT('signer');\n    }\n    /**\n     * @description The [[Balance]] tip\n     */\n    get tip() {\n        return this.getT('tip');\n    }\n    /**\n     * @description The [[u32]] or [[MultiLocation]] assetId\n     */\n    get assetId() {\n        return this.getT('assetId');\n    }\n    _injectSignature(signer, signature, payload) {\n        // use the fields exposed to guide the getters\n        for (let i = 0, count = this.__internal__signKeys.length; i < count; i++) {\n            const k = this.__internal__signKeys[i];\n            const v = payload.get(k);\n            if (!isUndefined(v)) {\n                this.set(k, v);\n            }\n        }\n        // additional fields (exposed in struct itself)\n        this.set('signer', signer);\n        this.set('signature', signature);\n        return this;\n    }\n    /**\n     * @description Adds a raw signature\n     */\n    addSignature(signer, signature, payload) {\n        return this._injectSignature(toAddress(this.registry, signer), this.registry.createTypeUnsafe('ExtrinsicSignature', [signature]), new GenericExtrinsicPayloadV4(this.registry, payload));\n    }\n    /**\n     * @description Creates a payload from the supplied options\n     */\n    createPayload(method, options) {\n        const { era, runtimeVersion: { specVersion, transactionVersion } } = options;\n        return new GenericExtrinsicPayloadV4(this.registry, objectSpread({}, options, {\n            era: era || IMMORTAL_ERA,\n            method: method.toHex(),\n            specVersion,\n            transactionVersion\n        }));\n    }\n    /**\n     * @description Generate a payload and applies the signature from a keypair\n     */\n    sign(method, account, options) {\n        if (!account?.addressRaw) {\n            throw new Error(`Expected a valid keypair for signing, found ${stringify(account)}`);\n        }\n        const payload = this.createPayload(method, options);\n        return this._injectSignature(toAddress(this.registry, account.addressRaw), this.registry.createTypeUnsafe('ExtrinsicSignature', [payload.sign(account)]), payload);\n    }\n    /**\n     * @description Generate a payload and applies a fake signature\n     */\n    signFake(method, address, options) {\n        if (!address) {\n            throw new Error(`Expected a valid address for signing, found ${stringify(address)}`);\n        }\n        const payload = this.createPayload(method, options);\n        return this._injectSignature(toAddress(this.registry, address), this.registry.createTypeUnsafe('ExtrinsicSignature', [FAKE_SIGNATURE]), payload);\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        return this.isSigned\n            ? super.toU8a(isBare)\n            : EMPTY_U8A;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}