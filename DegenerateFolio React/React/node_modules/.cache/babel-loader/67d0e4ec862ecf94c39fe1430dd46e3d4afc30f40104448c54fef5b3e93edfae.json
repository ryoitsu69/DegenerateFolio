{"ast":null,"code":"\"use strict\";\n\nfunction getGeometryBounds(geometry, attributeId, bounds) {\n  const attribute = geometry.getAttribute(attributeId);\n  if (!attribute) {\n    bounds.minX = 0;\n    bounds.minY = 0;\n    bounds.maxX = 0;\n    bounds.maxY = 0;\n    return bounds;\n  }\n  const data = attribute.buffer.data;\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  const byteSize = data.BYTES_PER_ELEMENT;\n  const offset = (attribute.offset || 0) / byteSize;\n  const stride = (attribute.stride || 2 * 4) / byteSize;\n  for (let i = offset; i < data.length; i += stride) {\n    const x = data[i];\n    const y = data[i + 1];\n    if (x > maxX) maxX = x;\n    if (y > maxY) maxY = y;\n    if (x < minX) minX = x;\n    if (y < minY) minY = y;\n  }\n  bounds.minX = minX;\n  bounds.minY = minY;\n  bounds.maxX = maxX;\n  bounds.maxY = maxY;\n  return bounds;\n}\nexport { getGeometryBounds };","map":{"version":3,"names":["getGeometryBounds","geometry","attributeId","bounds","attribute","getAttribute","minX","minY","maxX","maxY","data","buffer","Infinity","byteSize","BYTES_PER_ELEMENT","offset","stride","i","length","x","y"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getGeometryBounds.ts"],"sourcesContent":["import type { Bounds } from '../../../../../scene/container/bounds/Bounds';\nimport type { Geometry } from '../Geometry';\n\n/**\n * Gets the 2D bounds of a geometry, based on a specific attribute.\n * @param geometry - Geometry to to measure\n * @param attributeId - AttributeId that contains the x,y data\n * @param bounds - Bounds to store the result in\n * @returns the bounds\n */\nexport function getGeometryBounds(geometry: Geometry, attributeId: string, bounds: Bounds): Bounds\n{\n    const attribute = geometry.getAttribute(attributeId);\n\n    if (!attribute)\n    {\n        bounds.minX = 0;\n        bounds.minY = 0;\n        bounds.maxX = 0;\n        bounds.maxY = 0;\n\n        return bounds;\n    }\n\n    const data = attribute.buffer.data as Float32Array;\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    const byteSize = data.BYTES_PER_ELEMENT;\n\n    // stride and offset MAY have not been calculated yet.. so go with assumed defaults\n    const offset = (attribute.offset || 0) / byteSize;\n    const stride = (attribute.stride || (2 * 4)) / byteSize;\n\n    for (let i = offset; i < data.length; i += stride)\n    {\n        const x = data[i];\n        const y = data[i + 1];\n\n        if (x > maxX)maxX = x;\n        if (y > maxY)maxY = y;\n        if (x < minX)minX = x;\n        if (y < minY)minY = y;\n    }\n\n    bounds.minX = minX;\n    bounds.minY = minY;\n    bounds.maxX = maxX;\n    bounds.maxY = maxY;\n\n    return bounds;\n}\n"],"mappings":";;AAUgB,SAAAA,kBAAkBC,QAAoB,EAAAC,WAAA,EAAqBC,MAC3E;EACU,MAAAC,SAAA,GAAYH,QAAS,CAAAI,YAAA,CAAaH,WAAW;EAEnD,IAAI,CAACE,SACL;IACID,MAAA,CAAOG,IAAO;IACdH,MAAA,CAAOI,IAAO;IACdJ,MAAA,CAAOK,IAAO;IACdL,MAAA,CAAOM,IAAO;IAEP,OAAAN,MAAA;EAAA;EAGL,MAAAO,IAAA,GAAON,SAAA,CAAUO,MAAO,CAAAD,IAAA;EAE9B,IAAIJ,IAAO,GAAAM,QAAA;EACX,IAAIL,IAAO,GAAAK,QAAA;EACX,IAAIJ,IAAO,IAAAI,QAAA;EACX,IAAIH,IAAO,IAAAG,QAAA;EAEX,MAAMC,QAAA,GAAWH,IAAK,CAAAI,iBAAA;EAGhB,MAAAC,MAAA,IAAUX,SAAU,CAAAW,MAAA,IAAU,CAAK,IAAAF,QAAA;EACzC,MAAMG,MAAU,IAAAZ,SAAA,CAAUY,MAAW,QAAI,CAAM,IAAAH,QAAA;EAE/C,SAASI,CAAA,GAAIF,MAAQ,EAAAE,CAAA,GAAIP,IAAK,CAAAQ,MAAA,EAAQD,CAAA,IAAKD,MAC3C;IACU,MAAAG,CAAA,GAAIT,IAAA,CAAKO,CAAC;IACV,MAAAG,CAAA,GAAIV,IAAK,CAAAO,CAAA,GAAI,CAAC;IAEpB,IAAIE,CAAI,GAAAX,IAAA,EAAYA,IAAA,GAAAW,CAAA;IACpB,IAAIC,CAAI,GAAAX,IAAA,EAAYA,IAAA,GAAAW,CAAA;IACpB,IAAID,CAAI,GAAAb,IAAA,EAAYA,IAAA,GAAAa,CAAA;IACpB,IAAIC,CAAI,GAAAb,IAAA,EAAYA,IAAA,GAAAa,CAAA;EAAA;EAGxBjB,MAAA,CAAOG,IAAO,GAAAA,IAAA;EACdH,MAAA,CAAOI,IAAO,GAAAA,IAAA;EACdJ,MAAA,CAAOK,IAAO,GAAAA,IAAA;EACdL,MAAA,CAAOM,IAAO,GAAAA,IAAA;EAEP,OAAAN,MAAA;AACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}