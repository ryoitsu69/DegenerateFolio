{"ast":null,"code":"import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { generateShaderSyncCode } from './GenerateShaderSyncCode.mjs';\nimport { generateProgram } from './program/generateProgram.mjs';\n\"use strict\";\nconst defaultSyncData = {\n  textureCount: 0,\n  blockIndex: 0\n};\nclass GlShaderSystem {\n  constructor(renderer) {\n    /**\n     * @internal\n     * @private\n     */\n    this._activeProgram = null;\n    this._programDataHash = /* @__PURE__ */Object.create(null);\n    this._nextIndex = 0;\n    this._boundUniformsIdsToIndexHash = /* @__PURE__ */Object.create(null);\n    this._boundIndexToUniformsHash = /* @__PURE__ */Object.create(null);\n    this._shaderSyncFunctions = /* @__PURE__ */Object.create(null);\n    this._renderer = renderer;\n  }\n  contextChange(gl) {\n    this._gl = gl;\n    this._maxBindings = gl.MAX_UNIFORM_BUFFER_BINDINGS ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;\n    this._programDataHash = /* @__PURE__ */Object.create(null);\n    this._boundUniformsIdsToIndexHash = /* @__PURE__ */Object.create(null);\n    this._boundIndexToUniformsHash = /* @__PURE__ */Object.create(null);\n    this._activeProgram = null;\n  }\n  /**\n   * Changes the current shader to the one given in parameter.\n   * @param shader - the new shader\n   * @param skipSync - false if the shader should automatically sync its uniforms.\n   * @returns the glProgram that belongs to the shader.\n   */\n  bind(shader, skipSync) {\n    this._setProgram(shader.glProgram);\n    if (skipSync) return;\n    defaultSyncData.textureCount = 0;\n    defaultSyncData.blockIndex = 0;\n    let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];\n    if (!syncFunction) {\n      syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);\n    }\n    syncFunction(this._renderer, shader, defaultSyncData);\n  }\n  /**\n   * Updates the uniform group.\n   * @param uniformGroup - the uniform group to update\n   */\n  updateUniformGroup(uniformGroup) {\n    this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);\n  }\n  /**\n   * Binds a uniform block to the shader.\n   * @param uniformGroup - the uniform group to bind\n   * @param name - the name of the uniform block\n   * @param index - the index of the uniform block\n   */\n  bindUniformBlock(uniformGroup, name, index = 0) {\n    const bufferSystem = this._renderer.buffer;\n    const programData = this._getProgramData(this._activeProgram);\n    const isBufferResource = uniformGroup._bufferResource;\n    if (isBufferResource) {\n      this._renderer.ubo.updateUniformGroup(uniformGroup);\n    }\n    bufferSystem.updateBuffer(uniformGroup.buffer);\n    let boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid];\n    if (boundIndex === void 0) {\n      const nextIndex = this._nextIndex++ % this._maxBindings;\n      const currentBoundUniformGroup = this._boundIndexToUniformsHash[nextIndex];\n      if (currentBoundUniformGroup) {\n        this._boundUniformsIdsToIndexHash[currentBoundUniformGroup.uid] = void 0;\n      }\n      boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid] = nextIndex;\n      this._boundIndexToUniformsHash[nextIndex] = uniformGroup;\n      if (isBufferResource) {\n        bufferSystem.bindBufferRange(uniformGroup.buffer, nextIndex, uniformGroup.offset);\n      } else {\n        bufferSystem.bindBufferBase(uniformGroup.buffer, nextIndex);\n      }\n    }\n    const gl = this._gl;\n    const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;\n    if (programData.uniformBlockBindings[index] === boundIndex) return;\n    programData.uniformBlockBindings[index] = boundIndex;\n    gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundIndex);\n  }\n  _setProgram(program) {\n    if (this._activeProgram === program) return;\n    this._activeProgram = program;\n    const programData = this._getProgramData(program);\n    this._gl.useProgram(programData.program);\n  }\n  /**\n   * @param program - the program to get the data for\n   * @internal\n   * @private\n   */\n  _getProgramData(program) {\n    return this._programDataHash[program._key] || this._createProgramData(program);\n  }\n  _createProgramData(program) {\n    const key = program._key;\n    this._programDataHash[key] = generateProgram(this._gl, program);\n    return this._programDataHash[key];\n  }\n  destroy() {\n    for (const key of Object.keys(this._programDataHash)) {\n      const programData = this._programDataHash[key];\n      programData.destroy();\n      this._programDataHash[key] = null;\n    }\n    this._programDataHash = null;\n    this._boundUniformsIdsToIndexHash = null;\n  }\n  /**\n   * Creates a function that can be executed that will sync the shader as efficiently as possible.\n   * Overridden by the unsafe eval package if you don't want eval used in your project.\n   * @param shader - the shader to generate the sync function for\n   * @param shaderSystem - the shader system to use\n   * @returns - the generated sync function\n   * @ignore\n   */\n  _generateShaderSync(shader, shaderSystem) {\n    return generateShaderSyncCode(shader, shaderSystem);\n  }\n}\n/** @ignore */\nGlShaderSystem.extension = {\n  type: [ExtensionType.WebGLSystem],\n  name: \"shader\"\n};\nexport { GlShaderSystem };","map":{"version":3,"names":["defaultSyncData","textureCount","blockIndex","GlShaderSystem","constructor","renderer","_activeProgram","_programDataHash","Object","create","_nextIndex","_boundUniformsIdsToIndexHash","_boundIndexToUniformsHash","_shaderSyncFunctions","_renderer","contextChange","gl","_gl","_maxBindings","MAX_UNIFORM_BUFFER_BINDINGS","getParameter","bind","shader","skipSync","_setProgram","glProgram","syncFunction","_key","_generateShaderSync","updateUniformGroup","uniformGroup","bindUniformBlock","name","index","bufferSystem","buffer","programData","_getProgramData","isBufferResource","_bufferResource","ubo","updateBuffer","boundIndex","uid","nextIndex","currentBoundUniformGroup","bindBufferRange","offset","bindBufferBase","uniformBlockIndex","_uniformBlockData","uniformBlockBindings","uniformBlockBinding","program","useProgram","_createProgramData","key","generateProgram","destroy","keys","shaderSystem","generateShaderSyncCode","extension","type","ExtensionType","WebGLSystem"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gl/shader/GlShaderSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { generateShaderSyncCode } from './GenerateShaderSyncCode';\nimport { generateProgram } from './program/generateProgram';\n\nimport type { BufferResource } from '../../shared/buffer/BufferResource';\nimport type { Shader } from '../../shared/shader/Shader';\nimport type { UniformGroup } from '../../shared/shader/UniformGroup';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GlProgram } from './GlProgram';\nimport type { GlProgramData } from './GlProgramData';\n\nexport interface ShaderSyncData\n{\n    textureCount: number;\n    blockIndex: number;\n}\n\nexport type ShaderSyncFunction = (renderer: WebGLRenderer, shader: Shader, syncData: ShaderSyncData) => void;\n\n// default sync data so we don't create a new one each time!\nconst defaultSyncData: ShaderSyncData = {\n    textureCount: 0,\n    blockIndex: 0,\n};\n\n/**\n * System plugin to the renderer to manage the shaders for WebGL.\n * @memberof rendering\n */\nexport class GlShaderSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'shader',\n    } as const;\n\n    /**\n     * @internal\n     * @private\n     */\n    public _activeProgram: GlProgram = null;\n\n    private _programDataHash: Record<string, GlProgramData> = Object.create(null);\n    private readonly _renderer: WebGLRenderer;\n    public _gl: WebGL2RenderingContext;\n    private _maxBindings: number;\n    private _nextIndex = 0;\n    private _boundUniformsIdsToIndexHash: Record<number, number> = Object.create(null);\n    private _boundIndexToUniformsHash: Record<number, UniformGroup | BufferResource> = Object.create(null);\n    private _shaderSyncFunctions: Record<string, ShaderSyncFunction> = Object.create(null);\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this._gl = gl;\n\n        this._maxBindings = gl.MAX_UNIFORM_BUFFER_BINDINGS ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;\n\n        this._programDataHash = Object.create(null);\n        this._boundUniformsIdsToIndexHash = Object.create(null);\n        this._boundIndexToUniformsHash = Object.create(null);\n        this._activeProgram = null;\n    }\n\n    /**\n     * Changes the current shader to the one given in parameter.\n     * @param shader - the new shader\n     * @param skipSync - false if the shader should automatically sync its uniforms.\n     * @returns the glProgram that belongs to the shader.\n     */\n    public bind(shader: Shader, skipSync?: boolean): void\n    {\n        this._setProgram(shader.glProgram);\n\n        if (skipSync) return;\n\n        defaultSyncData.textureCount = 0;\n        defaultSyncData.blockIndex = 0;\n\n        let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];\n\n        if (!syncFunction)\n        {\n            syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);\n        }\n\n        syncFunction(this._renderer, shader, defaultSyncData);\n    }\n\n    /**\n     * Updates the uniform group.\n     * @param uniformGroup - the uniform group to update\n     */\n    public updateUniformGroup(uniformGroup: UniformGroup): void\n    {\n        this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);\n    }\n\n    /**\n     * Binds a uniform block to the shader.\n     * @param uniformGroup - the uniform group to bind\n     * @param name - the name of the uniform block\n     * @param index - the index of the uniform block\n     */\n    public bindUniformBlock(uniformGroup: UniformGroup | BufferResource, name: string, index = 0): void\n    {\n        const bufferSystem = this._renderer.buffer;\n        const programData = this._getProgramData(this._activeProgram);\n\n        const isBufferResource = (uniformGroup as BufferResource)._bufferResource;\n\n        if (isBufferResource)\n        {\n            this._renderer.ubo.updateUniformGroup(uniformGroup as UniformGroup);\n        }\n\n        bufferSystem.updateBuffer(uniformGroup.buffer);\n\n        let boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid];\n\n        // check if it is already bound..\n        if (boundIndex === undefined)\n        {\n            const nextIndex = this._nextIndex++ % this._maxBindings;\n\n            const currentBoundUniformGroup = this._boundIndexToUniformsHash[nextIndex];\n\n            if (currentBoundUniformGroup)\n            {\n                this._boundUniformsIdsToIndexHash[currentBoundUniformGroup.uid] = undefined;\n            }\n\n            // find a free slot..\n            boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid] = nextIndex;\n            this._boundIndexToUniformsHash[nextIndex] = uniformGroup;\n\n            if (isBufferResource)\n            {\n                bufferSystem.bindBufferRange(uniformGroup.buffer, nextIndex, (uniformGroup as BufferResource).offset);\n            }\n            else\n            {\n                bufferSystem.bindBufferBase(uniformGroup.buffer, nextIndex);\n            }\n        }\n\n        const gl = this._gl;\n\n        const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;\n\n        if (programData.uniformBlockBindings[index] === boundIndex) return;\n        programData.uniformBlockBindings[index] = boundIndex;\n\n        gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundIndex);\n    }\n\n    private _setProgram(program: GlProgram)\n    {\n        if (this._activeProgram === program) return;\n\n        this._activeProgram = program;\n\n        const programData = this._getProgramData(program);\n\n        this._gl.useProgram(programData.program);\n    }\n\n    /**\n     * @param program - the program to get the data for\n     * @internal\n     * @private\n     */\n    public _getProgramData(program: GlProgram): GlProgramData\n    {\n        return this._programDataHash[program._key] || this._createProgramData(program);\n    }\n\n    private _createProgramData(program: GlProgram): GlProgramData\n    {\n        const key = program._key;\n\n        this._programDataHash[key] = generateProgram(this._gl, program);\n\n        return this._programDataHash[key];\n    }\n\n    public destroy(): void\n    {\n        for (const key of Object.keys(this._programDataHash))\n        {\n            const programData = this._programDataHash[key];\n\n            programData.destroy();\n            this._programDataHash[key] = null;\n        }\n\n        this._programDataHash = null;\n        this._boundUniformsIdsToIndexHash = null;\n    }\n\n    /**\n     * Creates a function that can be executed that will sync the shader as efficiently as possible.\n     * Overridden by the unsafe eval package if you don't want eval used in your project.\n     * @param shader - the shader to generate the sync function for\n     * @param shaderSystem - the shader system to use\n     * @returns - the generated sync function\n     * @ignore\n     */\n    public _generateShaderSync(shader: Shader, shaderSystem: GlShaderSystem): ShaderSyncFunction\n    {\n        return generateShaderSyncCode(shader, shaderSystem);\n    }\n}\n"],"mappings":";;;;AAqBA,MAAMA,eAAkC;EACpCC,YAAc;EACdC,UAAY;AAChB;AAMO,MAAMC,cACb;EAwBIC,YAAYC,QACZ;IAZA;AAAA;AAAA;AAAA;IAAA,KAAOC,cAA4B;IAE3B,KAAAC,gBAAA,kBAAyDC,MAAA,CAAAC,MAAA,CAAO,IAAI;IAI5E,KAAQC,UAAa;IACb,KAAAC,4BAAA,kBAA8DH,MAAA,CAAAC,MAAA,CAAO,IAAI;IACzE,KAAAG,yBAAA,kBAAkFJ,MAAA,CAAAC,MAAA,CAAO,IAAI;IAC7F,KAAAI,oBAAA,kBAAkEL,MAAA,CAAAC,MAAA,CAAO,IAAI;IAIjF,KAAKK,SAAY,GAAAT,QAAA;EAAA;EAGXU,cAAcC,EACxB;IACI,KAAKC,GAAM,GAAAD,EAAA;IAEX,KAAKE,YAAA,GAAeF,EAAG,CAAAG,2BAAA,GAA8BH,EAAA,CAAGI,YAAa,CAAAJ,EAAA,CAAGG,2BAA2B,CAAI;IAElG,KAAAZ,gBAAA,kBAA0BC,MAAA,CAAAC,MAAA,CAAO,IAAI;IACrC,KAAAE,4BAAA,kBAAsCH,MAAA,CAAAC,MAAA,CAAO,IAAI;IACjD,KAAAG,yBAAA,kBAAmCJ,MAAA,CAAAC,MAAA,CAAO,IAAI;IACnD,KAAKH,cAAiB;EAAA;EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;EAQOe,KAAKC,MAAA,EAAgBC,QAC5B;IACS,KAAAC,WAAA,CAAYF,MAAA,CAAOG,SAAS;IAE7B,IAAAF,QAAA,EAAU;IAEdvB,eAAA,CAAgBC,YAAe;IAC/BD,eAAA,CAAgBE,UAAa;IAE7B,IAAIwB,YAAe,QAAKb,oBAAqB,CAAAS,MAAA,CAAOG,SAAA,CAAUE,IAAI;IAElE,IAAI,CAACD,YACL;MACmBA,YAAA,QAAKb,oBAAA,CAAqBS,MAAO,CAAAG,SAAA,CAAUE,IAAI,CAAI,QAAKC,mBAAoB,CAAAN,MAAA,EAAQ,IAAI;IAAA;IAG9FI,YAAA,MAAKZ,SAAW,EAAAQ,MAAA,EAAQtB,eAAe;EAAA;EACxD;AAAA;AAAA;AAAA;EAMO6B,mBAAmBC,YAC1B;IACI,KAAKhB,SAAA,CAAUgB,YAAa,CAAAD,kBAAA,CAAmBC,YAAc,OAAKxB,cAAA,EAAgBN,eAAe;EAAA;EACrG;AAAA;AAAA;AAAA;AAAA;AAAA;EAQO+B,gBAAiBA,CAAAD,YAAA,EAA6CE,IAAc,EAAAC,KAAA,GAAQ,CAC3F;IACU,MAAAC,YAAA,GAAe,KAAKpB,SAAU,CAAAqB,MAAA;IACpC,MAAMC,WAAc,QAAKC,eAAgB,MAAK/B,cAAc;IAE5D,MAAMgC,gBAAA,GAAoBR,YAAgC,CAAAS,eAAA;IAE1D,IAAID,gBACJ;MACS,KAAAxB,SAAA,CAAU0B,GAAI,CAAAX,kBAAA,CAAmBC,YAA4B;IAAA;IAGzDI,YAAA,CAAAO,YAAA,CAAaX,YAAA,CAAaK,MAAM;IAE7C,IAAIO,UAAa,QAAK/B,4BAA6B,CAAAmB,YAAA,CAAaa,GAAG;IAGnE,IAAID,UAAA,KAAe,KACnB;MACU,MAAAE,SAAA,GAAY,IAAK,CAAAlC,UAAA,KAAe,IAAK,CAAAQ,YAAA;MAErC,MAAA2B,wBAAA,GAA2B,IAAK,CAAAjC,yBAAA,CAA0BgC,SAAS;MAEzE,IAAIC,wBACJ;QACS,KAAAlC,4BAAA,CAA6BkC,wBAAyB,CAAAF,GAAG,CAAI;MAAA;MAItED,UAAA,GAAa,IAAK,CAAA/B,4BAAA,CAA6BmB,YAAa,CAAAa,GAAG,CAAI,GAAAC,SAAA;MAC9D,KAAAhC,yBAAA,CAA0BgC,SAAS,CAAI,GAAAd,YAAA;MAE5C,IAAIQ,gBACJ;QACIJ,YAAA,CAAaY,eAAgB,CAAAhB,YAAA,CAAaK,MAAQ,EAAAS,SAAA,EAAYd,YAAA,CAAgCiB,MAAM;MAAA,CAGxG;QACiBb,YAAA,CAAAc,cAAA,CAAelB,YAAa,CAAAK,MAAA,EAAQS,SAAS;MAAA;IAC9D;IAGJ,MAAM5B,EAAA,GAAK,IAAK,CAAAC,GAAA;IAEhB,MAAMgC,iBAAoB,QAAK3C,cAAe,CAAA4C,iBAAA,CAAkBlB,IAAI,CAAE,CAAAC,KAAA;IAElE,IAAAG,WAAA,CAAYe,oBAAqB,CAAAlB,KAAK,CAAM,KAAAS,UAAA,EAAY;IAChDN,WAAA,CAAAe,oBAAA,CAAqBlB,KAAK,CAAI,GAAAS,UAAA;IAE1C1B,EAAA,CAAGoC,mBAAoB,CAAAhB,WAAA,CAAYiB,OAAS,EAAAJ,iBAAA,EAAmBP,UAAU;EAAA;EAGrElB,YAAY6B,OACpB;IACI,IAAI,KAAK/C,cAAmB,KAAA+C,OAAA,EAAS;IAErC,KAAK/C,cAAiB,GAAA+C,OAAA;IAEhB,MAAAjB,WAAA,GAAc,IAAK,CAAAC,eAAA,CAAgBgB,OAAO;IAE3C,KAAApC,GAAA,CAAIqC,UAAW,CAAAlB,WAAA,CAAYiB,OAAO;EAAA;EAC3C;AAAA;AAAA;AAAA;AAAA;EAOOhB,gBAAgBgB,OACvB;IACI,OAAO,KAAK9C,gBAAiB,CAAA8C,OAAA,CAAQ1B,IAAI,CAAK,SAAK4B,kBAAA,CAAmBF,OAAO;EAAA;EAGzEE,mBAAmBF,OAC3B;IACI,MAAMG,GAAA,GAAMH,OAAQ,CAAA1B,IAAA;IAEpB,KAAKpB,gBAAA,CAAiBiD,GAAG,IAAIC,eAAgB,MAAKxC,GAAA,EAAKoC,OAAO;IAEvD,YAAK9C,gBAAA,CAAiBiD,GAAG;EAAA;EAG7BE,OACPA,CAAA;IACI,WAAWF,GAAO,IAAAhD,MAAA,CAAOmD,IAAK,MAAKpD,gBAAgB,CACnD;MACU,MAAA6B,WAAA,GAAc,IAAK,CAAA7B,gBAAA,CAAiBiD,GAAG;MAE7CpB,WAAA,CAAYsB,OAAQ;MACf,KAAAnD,gBAAA,CAAiBiD,GAAG,CAAI;IAAA;IAGjC,KAAKjD,gBAAmB;IACxB,KAAKI,4BAA+B;EAAA;EACxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAUOiB,oBAAoBN,MAAA,EAAgBsC,YAC3C;IACW,OAAAC,sBAAA,CAAuBvC,MAAA,EAAQsC,YAAY;EAAA;AAE1D;AAAA;AA9LazD,cAAA,CAGK2D,SAAY;EACtBC,IAAM,GACFC,aAAc,CAAAC,WAAA,CAClB;EACAjC,IAAM;AACV","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}