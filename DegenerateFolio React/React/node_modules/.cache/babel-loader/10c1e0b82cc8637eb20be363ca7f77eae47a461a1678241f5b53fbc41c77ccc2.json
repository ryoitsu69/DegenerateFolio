{"ast":null,"code":"import { compactAddLength, compactFromU8aLim, compactToU8a, hexToU8a, isHex, isString, isU8a, stringToU8a, u8aToHex, u8aToString } from '@polkadot/util';\nimport { Raw } from './Raw.js';\nconst MAX_LENGTH = 128 * 1024;\n/** @internal */\nfunction decodeText(value) {\n  if (isU8a(value)) {\n    if (!value.length) {\n      return ['', 0];\n    }\n    // for Raw, the internal buffer does not have an internal length\n    // (the same applies in e.g. Bytes, where length is added at encoding-time)\n    if (value instanceof Raw) {\n      return [u8aToString(value), 0];\n    }\n    const [offset, length] = compactFromU8aLim(value);\n    const total = offset + length;\n    if (length > MAX_LENGTH) {\n      throw new Error(`Text: length ${length.toString()} exceeds ${MAX_LENGTH}`);\n    } else if (total > value.length) {\n      throw new Error(`Text: required length less than remainder, expected at least ${total}, found ${value.length}`);\n    }\n    return [u8aToString(value.subarray(offset, total)), total];\n  } else if (isHex(value)) {\n    return [u8aToString(hexToU8a(value)), 0];\n  }\n  return [value ? value.toString() : '', 0];\n}\n/**\n * @name Text\n * @description\n * This is a string wrapper, along with the length. It is used both for strings as well\n * as items such as documentation. It simply extends the standard JS `String` built-in\n * object, inheriting all methods exposed from `String`.\n * @noInheritDoc\n */\nexport class Text extends String {\n  registry;\n  createdAtHash;\n  initialU8aLength;\n  isStorageFallback;\n  __internal__override = null;\n  constructor(registry, value) {\n    const [str, decodedLength] = decodeText(value);\n    super(str);\n    this.registry = registry;\n    this.initialU8aLength = decodedLength;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    return this.toU8a().length;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n  get isEmpty() {\n    return this.length === 0;\n  }\n  /**\n   * @description The length of the value\n   */\n  get length() {\n    // only included here since we ignore inherited docs\n    return super.length;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return isString(other) ? this.toString() === other.toString() : false;\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    const value = stringToU8a(super.toString());\n    return {\n      outer: value.length ? [compactToU8a(value.length), value] : [compactToU8a(value.length)]\n    };\n  }\n  /**\n   * @description Set an override value for this\n   */\n  setOverride(override) {\n    this.__internal__override = override;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex() {\n    // like with Vec<u8>, when we are encoding to hex, we don't actually add\n    // the length prefix (it is already implied by the actual string length)\n    return u8aToHex(this.toU8a(true));\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman() {\n    return this.toJSON();\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    return this.toString();\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive() {\n    return this.toJSON();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'Text';\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return this.__internal__override || super.toString();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    // NOTE Here we use the super toString (we are not taking overrides into account,\n    // rather encoding the original value the string was constructed with)\n    const encoded = stringToU8a(super.toString());\n    return isBare ? encoded : compactAddLength(encoded);\n  }\n}","map":{"version":3,"names":["compactAddLength","compactFromU8aLim","compactToU8a","hexToU8a","isHex","isString","isU8a","stringToU8a","u8aToHex","u8aToString","Raw","MAX_LENGTH","decodeText","value","length","offset","total","Error","toString","subarray","Text","String","registry","createdAtHash","initialU8aLength","isStorageFallback","__internal__override","constructor","str","decodedLength","encodedLength","toU8a","hash","isEmpty","eq","other","inspect","outer","setOverride","override","toHex","toHuman","toJSON","toPrimitive","toRawType","isBare","encoded"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/native/Text.js"],"sourcesContent":["import { compactAddLength, compactFromU8aLim, compactToU8a, hexToU8a, isHex, isString, isU8a, stringToU8a, u8aToHex, u8aToString } from '@polkadot/util';\nimport { Raw } from './Raw.js';\nconst MAX_LENGTH = 128 * 1024;\n/** @internal */\nfunction decodeText(value) {\n    if (isU8a(value)) {\n        if (!value.length) {\n            return ['', 0];\n        }\n        // for Raw, the internal buffer does not have an internal length\n        // (the same applies in e.g. Bytes, where length is added at encoding-time)\n        if (value instanceof Raw) {\n            return [u8aToString(value), 0];\n        }\n        const [offset, length] = compactFromU8aLim(value);\n        const total = offset + length;\n        if (length > MAX_LENGTH) {\n            throw new Error(`Text: length ${length.toString()} exceeds ${MAX_LENGTH}`);\n        }\n        else if (total > value.length) {\n            throw new Error(`Text: required length less than remainder, expected at least ${total}, found ${value.length}`);\n        }\n        return [u8aToString(value.subarray(offset, total)), total];\n    }\n    else if (isHex(value)) {\n        return [u8aToString(hexToU8a(value)), 0];\n    }\n    return [value ? value.toString() : '', 0];\n}\n/**\n * @name Text\n * @description\n * This is a string wrapper, along with the length. It is used both for strings as well\n * as items such as documentation. It simply extends the standard JS `String` built-in\n * object, inheriting all methods exposed from `String`.\n * @noInheritDoc\n */\nexport class Text extends String {\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    __internal__override = null;\n    constructor(registry, value) {\n        const [str, decodedLength] = decodeText(value);\n        super(str);\n        this.registry = registry;\n        this.initialU8aLength = decodedLength;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return this.toU8a().length;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        return this.length === 0;\n    }\n    /**\n     * @description The length of the value\n     */\n    get length() {\n        // only included here since we ignore inherited docs\n        return super.length;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return isString(other)\n            ? this.toString() === other.toString()\n            : false;\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        const value = stringToU8a(super.toString());\n        return {\n            outer: value.length\n                ? [compactToU8a(value.length), value]\n                : [compactToU8a(value.length)]\n        };\n    }\n    /**\n     * @description Set an override value for this\n     */\n    setOverride(override) {\n        this.__internal__override = override;\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        // like with Vec<u8>, when we are encoding to hex, we don't actually add\n        // the length prefix (it is already implied by the actual string length)\n        return u8aToHex(this.toU8a(true));\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman() {\n        return this.toJSON();\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive() {\n        return this.toJSON();\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'Text';\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return this.__internal__override || super.toString();\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        // NOTE Here we use the super toString (we are not taking overrides into account,\n        // rather encoding the original value the string was constructed with)\n        const encoded = stringToU8a(super.toString());\n        return isBare\n            ? encoded\n            : compactAddLength(encoded);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}