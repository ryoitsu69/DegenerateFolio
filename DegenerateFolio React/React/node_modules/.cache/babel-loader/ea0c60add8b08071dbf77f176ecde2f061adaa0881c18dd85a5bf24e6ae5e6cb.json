{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Secp256k1 = void 0;\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst elliptic_1 = __importDefault(require(\"elliptic\"));\nconst secp256k1signature_1 = require(\"./secp256k1signature\");\nconst secp256k1 = new elliptic_1.default.ec(\"secp256k1\");\nconst secp256k1N = new bn_js_1.default(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\", \"hex\");\nclass Secp256k1 {\n  /**\n   * Takes a 32 byte private key and returns a privkey/pubkey pair.\n   *\n   * The resulting pubkey is uncompressed. For the use in Cosmos it should\n   * be compressed first using `Secp256k1.compressPubkey`.\n   */\n  static async makeKeypair(privkey) {\n    if (privkey.length !== 32) {\n      // is this check missing in secp256k1.validatePrivateKey?\n      // https://github.com/bitjson/bitcoin-ts/issues/4\n      throw new Error(\"input data is not a valid secp256k1 private key\");\n    }\n    const keypair = secp256k1.keyFromPrivate(privkey);\n    if (keypair.validate().result !== true) {\n      throw new Error(\"input data is not a valid secp256k1 private key\");\n    }\n    // range test that is not part of the elliptic implementation\n    const privkeyAsBigInteger = new bn_js_1.default(privkey);\n    if (privkeyAsBigInteger.gte(secp256k1N)) {\n      // not strictly smaller than N\n      throw new Error(\"input data is not a valid secp256k1 private key\");\n    }\n    const out = {\n      privkey: (0, encoding_1.fromHex)(keypair.getPrivate(\"hex\")),\n      // encodes uncompressed as\n      // - 1-byte prefix \"04\"\n      // - 32-byte x coordinate\n      // - 32-byte y coordinate\n      pubkey: Uint8Array.from(keypair.getPublic(\"array\"))\n    };\n    return out;\n  }\n  /**\n   * Creates a signature that is\n   * - deterministic (RFC 6979)\n   * - lowS signature\n   * - DER encoded\n   */\n  static async createSignature(messageHash, privkey) {\n    if (messageHash.length === 0) {\n      throw new Error(\"Message hash must not be empty\");\n    }\n    if (messageHash.length > 32) {\n      throw new Error(\"Message hash length must not exceed 32 bytes\");\n    }\n    const keypair = secp256k1.keyFromPrivate(privkey);\n    // the `canonical` option ensures creation of lowS signature representations\n    const {\n      r,\n      s,\n      recoveryParam\n    } = keypair.sign(messageHash, {\n      canonical: true\n    });\n    if (typeof recoveryParam !== \"number\") throw new Error(\"Recovery param missing\");\n    return new secp256k1signature_1.ExtendedSecp256k1Signature(Uint8Array.from(r.toArray()), Uint8Array.from(s.toArray()), recoveryParam);\n  }\n  static async verifySignature(signature, messageHash, pubkey) {\n    if (messageHash.length === 0) {\n      throw new Error(\"Message hash must not be empty\");\n    }\n    if (messageHash.length > 32) {\n      throw new Error(\"Message hash length must not exceed 32 bytes\");\n    }\n    const keypair = secp256k1.keyFromPublic(pubkey);\n    // From https://github.com/indutny/elliptic:\n    //\n    //     Sign the message's hash (input must be an array, or a hex-string)\n    //\n    //     Signature MUST be either:\n    //     1) DER-encoded signature as hex-string; or\n    //     2) DER-encoded signature as buffer; or\n    //     3) object with two hex-string properties (r and s); or\n    //     4) object with two buffer properties (r and s)\n    //\n    // Uint8Array is not a Buffer, but elliptic seems to be happy with the interface\n    // common to both types. Uint8Array is not an array of ints but the interface is\n    // similar\n    try {\n      return keypair.verify(messageHash, signature.toDer());\n    } catch (error) {\n      return false;\n    }\n  }\n  static recoverPubkey(signature, messageHash) {\n    const signatureForElliptic = {\n      r: (0, encoding_1.toHex)(signature.r()),\n      s: (0, encoding_1.toHex)(signature.s())\n    };\n    const point = secp256k1.recoverPubKey(messageHash, signatureForElliptic, signature.recovery);\n    const keypair = secp256k1.keyFromPublic(point);\n    return (0, encoding_1.fromHex)(keypair.getPublic(false, \"hex\"));\n  }\n  /**\n   * Takes a compressed or uncompressed pubkey and return a compressed one.\n   *\n   * This function is idempotent.\n   */\n  static compressPubkey(pubkey) {\n    switch (pubkey.length) {\n      case 33:\n        return pubkey;\n      case 65:\n        return Uint8Array.from(secp256k1.keyFromPublic(pubkey).getPublic(true, \"array\"));\n      default:\n        throw new Error(\"Invalid pubkey length\");\n    }\n  }\n  /**\n   * Takes a compressed or uncompressed pubkey and returns an uncompressed one.\n   *\n   * This function is idempotent.\n   */\n  static uncompressPubkey(pubkey) {\n    switch (pubkey.length) {\n      case 33:\n        return Uint8Array.from(secp256k1.keyFromPublic(pubkey).getPublic(false, \"array\"));\n      case 65:\n        return pubkey;\n      default:\n        throw new Error(\"Invalid pubkey length\");\n    }\n  }\n  static trimRecoveryByte(signature) {\n    switch (signature.length) {\n      case 64:\n        return signature;\n      case 65:\n        return signature.slice(0, 64);\n      default:\n        throw new Error(\"Invalid signature length\");\n    }\n  }\n}\nexports.Secp256k1 = Secp256k1;","map":{"version":3,"names":["encoding_1","require","bn_js_1","__importDefault","elliptic_1","secp256k1signature_1","secp256k1","default","ec","secp256k1N","Secp256k1","makeKeypair","privkey","length","Error","keypair","keyFromPrivate","validate","result","privkeyAsBigInteger","gte","out","fromHex","getPrivate","pubkey","Uint8Array","from","getPublic","createSignature","messageHash","r","s","recoveryParam","sign","canonical","ExtendedSecp256k1Signature","toArray","verifySignature","signature","keyFromPublic","verify","toDer","error","recoverPubkey","signatureForElliptic","toHex","point","recoverPubKey","recovery","compressPubkey","uncompressPubkey","trimRecoveryByte","slice","exports"],"sources":["../src/secp256k1.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}