{"ast":null,"code":"import { settings, Texture, Rectangle, utils, Color } from \"@pixi/core\";\nimport { Sprite } from \"@pixi/sprite\";\nimport { TEXT_GRADIENT } from \"./const.mjs\";\nimport { TextMetrics } from \"./TextMetrics.mjs\";\nimport { TextStyle } from \"./TextStyle.mjs\";\nconst defaultDestroyOptions = {\n    texture: !0,\n    children: !1,\n    baseTexture: !0\n  },\n  _Text = class _Text2 extends Sprite {\n    /**\n     * @param text - The string that you would like the text to display\n     * @param style - The style parameters\n     * @param canvas - The canvas element for drawing text\n     */\n    constructor(text, style, canvas) {\n      let ownCanvas = !1;\n      canvas || (canvas = settings.ADAPTER.createCanvas(), ownCanvas = !0), canvas.width = 3, canvas.height = 3;\n      const texture = Texture.from(canvas);\n      texture.orig = new Rectangle(), texture.trim = new Rectangle(), super(texture), this._ownCanvas = ownCanvas, this.canvas = canvas, this.context = canvas.getContext(\"2d\", {\n        // required for trimming to work without warnings\n        willReadFrequently: !0\n      }), this._resolution = _Text2.defaultResolution ?? settings.RESOLUTION, this._autoResolution = _Text2.defaultAutoResolution, this._text = null, this._style = null, this._styleListener = null, this._font = \"\", this.text = text, this.style = style, this.localStyleID = -1;\n    }\n    /**\n     * @see PIXI.TextMetrics.experimentalLetterSpacing\n     * @deprecated since 7.1.0\n     */\n    static get experimentalLetterSpacing() {\n      return TextMetrics.experimentalLetterSpacing;\n    }\n    static set experimentalLetterSpacing(value) {\n      utils.deprecation(\"7.1.0\", \"Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing\"), TextMetrics.experimentalLetterSpacing = value;\n    }\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.\n     */\n    updateText(respectDirty) {\n      const style = this._style;\n      if (this.localStyleID !== style.styleID && (this.dirty = !0, this.localStyleID = style.styleID), !this.dirty && respectDirty) return;\n      this._font = this._style.toFontString();\n      const context = this.context,\n        measured = TextMetrics.measureText(this._text || \" \", this._style, this._style.wordWrap, this.canvas),\n        width = measured.width,\n        height = measured.height,\n        lines = measured.lines,\n        lineHeight = measured.lineHeight,\n        lineWidths = measured.lineWidths,\n        maxLineWidth = measured.maxLineWidth,\n        fontProperties = measured.fontProperties;\n      this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution), context.scale(this._resolution, this._resolution), context.clearRect(0, 0, this.canvas.width, this.canvas.height), context.font = this._font, context.lineWidth = style.strokeThickness, context.textBaseline = style.textBaseline, context.lineJoin = style.lineJoin, context.miterLimit = style.miterLimit;\n      let linePositionX, linePositionY;\n      const passesCount = style.dropShadow ? 2 : 1;\n      for (let i = 0; i < passesCount; ++i) {\n        const isShadowPass = style.dropShadow && i === 0,\n          dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0,\n          dsOffsetShadow = dsOffsetText * this._resolution;\n        if (isShadowPass) {\n          context.fillStyle = \"black\", context.strokeStyle = \"black\";\n          const dropShadowColor = style.dropShadowColor,\n            dropShadowBlur = style.dropShadowBlur * this._resolution,\n            dropShadowDistance = style.dropShadowDistance * this._resolution;\n          context.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString(), context.shadowBlur = dropShadowBlur, context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance, context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;\n        } else context.fillStyle = this._generateFillStyle(style, lines, measured), context.strokeStyle = style.stroke, context.shadowColor = \"black\", context.shadowBlur = 0, context.shadowOffsetX = 0, context.shadowOffsetY = 0;\n        let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n        lineHeight - fontProperties.fontSize < 0 && (linePositionYShift = 0);\n        for (let i2 = 0; i2 < lines.length; i2++) linePositionX = style.strokeThickness / 2, linePositionY = style.strokeThickness / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift, style.align === \"right\" ? linePositionX += maxLineWidth - lineWidths[i2] : style.align === \"center\" && (linePositionX += (maxLineWidth - lineWidths[i2]) / 2), style.stroke && style.strokeThickness && this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, !0), style.fill && this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);\n      }\n      this.updateTexture();\n    }\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    drawLetterSpacing(text, x, y, isStroke = !1) {\n      const letterSpacing = this._style.letterSpacing;\n      let useExperimentalLetterSpacing = !1;\n      if (TextMetrics.experimentalLetterSpacingSupported && (TextMetrics.experimentalLetterSpacing ? (this.context.letterSpacing = `${letterSpacing}px`, this.context.textLetterSpacing = `${letterSpacing}px`, useExperimentalLetterSpacing = !0) : (this.context.letterSpacing = \"0px\", this.context.textLetterSpacing = \"0px\")), letterSpacing === 0 || useExperimentalLetterSpacing) {\n        isStroke ? this.context.strokeText(text, x, y) : this.context.fillText(text, x, y);\n        return;\n      }\n      let currentPosition = x;\n      const stringArray = TextMetrics.graphemeSegmenter(text);\n      let previousWidth = this.context.measureText(text).width,\n        currentWidth = 0;\n      for (let i = 0; i < stringArray.length; ++i) {\n        const currentChar = stringArray[i];\n        isStroke ? this.context.strokeText(currentChar, currentPosition, y) : this.context.fillText(currentChar, currentPosition, y);\n        let textStr = \"\";\n        for (let j = i + 1; j < stringArray.length; ++j) textStr += stringArray[j];\n        currentWidth = this.context.measureText(textStr).width, currentPosition += previousWidth - currentWidth + letterSpacing, previousWidth = currentWidth;\n      }\n    }\n    /** Updates texture size based on canvas size. */\n    updateTexture() {\n      const canvas = this.canvas;\n      if (this._style.trim) {\n        const trimmed = utils.trimCanvas(canvas);\n        trimmed.data && (canvas.width = trimmed.width, canvas.height = trimmed.height, this.context.putImageData(trimmed.data, 0, 0));\n      }\n      const texture = this._texture,\n        style = this._style,\n        padding = style.trim ? 0 : style.padding,\n        baseTexture = texture.baseTexture;\n      texture.trim.width = texture._frame.width = canvas.width / this._resolution, texture.trim.height = texture._frame.height = canvas.height / this._resolution, texture.trim.x = -padding, texture.trim.y = -padding, texture.orig.width = texture._frame.width - padding * 2, texture.orig.height = texture._frame.height - padding * 2, this._onTextureUpdate(), baseTexture.setRealSize(canvas.width, canvas.height, this._resolution), texture.updateUvs(), this.dirty = !1;\n    }\n    /**\n     * Renders the object using the WebGL renderer\n     * @param renderer - The renderer\n     */\n    _render(renderer) {\n      this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0), this.updateText(!0), super._render(renderer);\n    }\n    /** Updates the transform on all children of this container for rendering. */\n    updateTransform() {\n      this.updateText(!0), super.updateTransform();\n    }\n    getBounds(skipUpdate, rect) {\n      return this.updateText(!0), this._textureID === -1 && (skipUpdate = !1), super.getBounds(skipUpdate, rect);\n    }\n    /**\n     * Gets the local bounds of the text object.\n     * @param rect - The output rectangle.\n     * @returns The bounds.\n     */\n    getLocalBounds(rect) {\n      return this.updateText(!0), super.getLocalBounds.call(this, rect);\n    }\n    /** Calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account. */\n    _calculateBounds() {\n      this.calculateVertices(), this._bounds.addQuad(this.vertexData);\n    }\n    /**\n     * Generates the fill style. Can automatically generate a gradient based on the fill style being an array\n     * @param style - The style.\n     * @param lines - The lines of text.\n     * @param metrics\n     * @returns The fill style\n     */\n    _generateFillStyle(style, lines, metrics) {\n      const fillStyle = style.fill;\n      if (Array.isArray(fillStyle)) {\n        if (fillStyle.length === 1) return fillStyle[0];\n      } else return fillStyle;\n      let gradient;\n      const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0,\n        padding = style.padding || 0,\n        width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2,\n        height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2,\n        fill = fillStyle.slice(),\n        fillGradientStops = style.fillGradientStops.slice();\n      if (!fillGradientStops.length) {\n        const lengthPlus1 = fill.length + 1;\n        for (let i = 1; i < lengthPlus1; ++i) fillGradientStops.push(i / lengthPlus1);\n      }\n      if (fill.unshift(fillStyle[0]), fillGradientStops.unshift(0), fill.push(fillStyle[fillStyle.length - 1]), fillGradientStops.push(1), style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n        gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);\n        const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;\n        for (let i = 0; i < lines.length; i++) {\n          const lastLineBottom = metrics.lineHeight * (i - 1) + textHeight,\n            thisLineTop = metrics.lineHeight * i;\n          let thisLineGradientStart = thisLineTop;\n          i > 0 && lastLineBottom > thisLineTop && (thisLineGradientStart = (thisLineTop + lastLineBottom) / 2);\n          const thisLineBottom = thisLineTop + textHeight,\n            nextLineTop = metrics.lineHeight * (i + 1);\n          let thisLineGradientEnd = thisLineBottom;\n          i + 1 < lines.length && nextLineTop < thisLineBottom && (thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2);\n          const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;\n          for (let j = 0; j < fill.length; j++) {\n            let lineStop = 0;\n            typeof fillGradientStops[j] == \"number\" ? lineStop = fillGradientStops[j] : lineStop = j / fill.length;\n            let globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));\n            globalStop = Number(globalStop.toFixed(5)), gradient.addColorStop(globalStop, fill[j]);\n          }\n        }\n      } else {\n        gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);\n        const totalIterations = fill.length + 1;\n        let currentIteration = 1;\n        for (let i = 0; i < fill.length; i++) {\n          let stop;\n          typeof fillGradientStops[i] == \"number\" ? stop = fillGradientStops[i] : stop = currentIteration / totalIterations, gradient.addColorStop(stop, fill[i]), currentIteration++;\n        }\n      }\n      return gradient;\n    }\n    /**\n     * Destroys this text object.\n     *\n     * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as\n     * the majority of the time the texture will not be shared with any other Sprites.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their\n     *  destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well\n     */\n    destroy(options) {\n      typeof options == \"boolean\" && (options = {\n        children: options\n      }), options = Object.assign({}, defaultDestroyOptions, options), super.destroy(options), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;\n    }\n    /** The width of the Text, setting this will actually modify the scale to achieve the value set. */\n    get width() {\n      return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n    set width(value) {\n      this.updateText(!0);\n      const s = utils.sign(this.scale.x) || 1;\n      this.scale.x = s * value / this._texture.orig.width, this._width = value;\n    }\n    /** The height of the Text, setting this will actually modify the scale to achieve the value set. */\n    get height() {\n      return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n    set height(value) {\n      this.updateText(!0);\n      const s = utils.sign(this.scale.y) || 1;\n      this.scale.y = s * value / this._texture.orig.height, this._height = value;\n    }\n    /**\n     * Set the style of the text.\n     *\n     * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n     *\n     * If setting the `style` can also be partial {@link PIXI.ITextStyle}.\n     */\n    get style() {\n      return this._style;\n    }\n    set style(style) {\n      style = style || {}, style instanceof TextStyle ? this._style = style : this._style = new TextStyle(style), this.localStyleID = -1, this.dirty = !0;\n    }\n    /** Set the copy for the text object. To split a line you can use '\\n'. */\n    get text() {\n      return this._text;\n    }\n    set text(text) {\n      text = String(text ?? \"\"), this._text !== text && (this._text = text, this.dirty = !0);\n    }\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default 1\n     */\n    get resolution() {\n      return this._resolution;\n    }\n    set resolution(value) {\n      this._autoResolution = !1, this._resolution !== value && (this._resolution = value, this.dirty = !0);\n    }\n  };\n_Text.defaultAutoResolution = !0;\nlet Text = _Text;\nexport { Text };","map":{"version":3,"names":["defaultDestroyOptions","texture","children","baseTexture","_Text","_Text2","Sprite","constructor","text","style","canvas","ownCanvas","settings","ADAPTER","createCanvas","width","height","Texture","from","orig","Rectangle","trim","_ownCanvas","context","getContext","willReadFrequently","_resolution","defaultResolution","RESOLUTION","_autoResolution","defaultAutoResolution","_text","_style","_styleListener","_font","localStyleID","experimentalLetterSpacing","TextMetrics","value","utils","deprecation","updateText","respectDirty","styleID","dirty","toFontString","measured","measureText","wordWrap","lines","lineHeight","lineWidths","maxLineWidth","fontProperties","Math","ceil","max","padding","scale","clearRect","font","lineWidth","strokeThickness","textBaseline","lineJoin","miterLimit","linePositionX","linePositionY","passesCount","dropShadow","i","isShadowPass","dsOffsetText","dsOffsetShadow","fillStyle","strokeStyle","dropShadowColor","dropShadowBlur","dropShadowDistance","shadowColor","Color","shared","setValue","setAlpha","dropShadowAlpha","toRgbaString","shadowBlur","shadowOffsetX","cos","dropShadowAngle","shadowOffsetY","sin","_generateFillStyle","stroke","linePositionYShift","fontSize","i2","length","ascent","align","drawLetterSpacing","fill","updateTexture","x","y","isStroke","letterSpacing","useExperimentalLetterSpacing","experimentalLetterSpacingSupported","textLetterSpacing","strokeText","fillText","currentPosition","stringArray","graphemeSegmenter","previousWidth","currentWidth","currentChar","textStr","j","trimmed","trimCanvas","data","putImageData","_texture","_frame","_onTextureUpdate","setRealSize","updateUvs","_render","renderer","resolution","updateTransform","getBounds","skipUpdate","rect","_textureID","getLocalBounds","call","_calculateBounds","calculateVertices","_bounds","addQuad","vertexData","metrics","Array","isArray","gradient","dropShadowCorrection","slice","fillGradientStops","lengthPlus1","push","unshift","fillGradientType","TEXT_GRADIENT","LINEAR_VERTICAL","createLinearGradient","textHeight","lastLineBottom","thisLineTop","thisLineGradientStart","thisLineBottom","nextLineTop","thisLineGradientEnd","gradStopLineHeight","lineStop","globalStop","min","Number","toFixed","addColorStop","totalIterations","currentIteration","stop","destroy","options","Object","assign","abs","s","sign","_width","_height","TextStyle","String","Text"],"sources":["/home/ryoitsu/node_modules/@pixi/text/src/Text.ts"],"sourcesContent":["/* eslint max-depth: [2, 8] */\nimport { Color, Rectangle, settings, Texture, utils } from '@pixi/core';\nimport { Sprite } from '@pixi/sprite';\nimport { TEXT_GRADIENT } from './const';\nimport { TextMetrics } from './TextMetrics';\nimport { TextStyle } from './TextStyle';\n\nimport type { ICanvas, ICanvasRenderingContext2D, Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { ITextStyle } from './TextStyle';\n\nconst defaultDestroyOptions: IDestroyOptions = {\n    texture: true,\n    children: false,\n    baseTexture: true,\n};\n\n/**\n * A Text Object will create a line or multiple lines of text.\n *\n * The text is created using the [Canvas API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API).\n *\n * The primary advantage of this class over BitmapText is that you have great control over the style of the text,\n * which you can change at runtime.\n *\n * The primary disadvantages is that each piece of text has it's own texture, which can use more memory.\n * When text changes, this texture has to be re-generated and re-uploaded to the GPU, taking up time.\n *\n * To split a line you can use '\\n' in your text string, or, on the `style` object,\n * change its `wordWrap` property to true and and give the `wordWrapWidth` property a value.\n *\n * A Text can be created directly from a string and a style object,\n * which can be generated [here](https://pixijs.io/pixi-text-style).\n * @example\n * import { Text } from 'pixi.js';\n *\n * const text = new Text('This is a PixiJS text', {\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * @memberof PIXI\n */\nexport class Text extends Sprite\n{\n    /**\n     * Override whether or not the resolution of the text is automatically adjusted to match the resolution of the renderer.\n     * Setting this to false can allow you to get crisper text at lower render resolutions.\n     * @example\n     * // renderer has a resolution of 1\n     * const app = new Application();\n     *\n     * Text.defaultResolution = 2;\n     * Text.defaultAutoResolution = false;\n     * // text has a resolution of 2\n     * const text = new Text('This is a PixiJS text');\n     */\n    public static defaultAutoResolution = true;\n\n    /**\n     * If {@link PIXI.Text.defaultAutoResolution} is false, this will be the default resolution of the text.\n     * If not set it will default to {@link PIXI.settings.RESOLUTION}.\n     * @example\n     * Text.defaultResolution = 2;\n     * Text.defaultAutoResolution = false;\n     *\n     * // text has a resolution of 2\n     * const text = new Text('This is a PixiJS text');\n     */\n    public static defaultResolution: number;\n\n    /**\n     * @see PIXI.TextMetrics.experimentalLetterSpacing\n     * @deprecated since 7.1.0\n     */\n    public static get experimentalLetterSpacing()\n    {\n        return TextMetrics.experimentalLetterSpacing;\n    }\n    public static set experimentalLetterSpacing(value)\n    {\n        if (process.env.DEBUG)\n        {\n            utils.deprecation('7.1.0',\n                'Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing');\n        }\n\n        TextMetrics.experimentalLetterSpacing = value;\n    }\n\n    /** The canvas element that everything is drawn to. */\n    public canvas: ICanvas;\n    /** The canvas 2d context that everything is drawn with. */\n    public context: ICanvasRenderingContext2D;\n    public localStyleID: number;\n    public dirty: boolean;\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default PIXI.settings.RESOLUTION\n     */\n    _resolution: number;\n    _autoResolution: boolean;\n\n    /**\n     * Private tracker for the current text.\n     * @private\n     */\n    protected _text: string;\n\n    /**\n     * Private tracker for the current font.\n     * @private\n     */\n    protected _font: string;\n\n    /**\n     * Private tracker for the current style.\n     * @private\n     */\n    protected _style: TextStyle;\n\n    /**\n     * Private listener to track style changes.\n     * @private\n     */\n    protected _styleListener: () => void;\n\n    /**\n     * Keep track if this Text object created it's own canvas\n     * element (`true`) or uses the constructor argument (`false`).\n     * Used to workaround a GC issues with Safari < 13 when\n     * destroying Text. See `destroy` for more info.\n     */\n    private _ownCanvas: boolean;\n\n    /**\n     * @param text - The string that you would like the text to display\n     * @param style - The style parameters\n     * @param canvas - The canvas element for drawing text\n     */\n    constructor(text?: string | number, style?: Partial<ITextStyle> | TextStyle, canvas?: ICanvas)\n    {\n        let ownCanvas = false;\n\n        if (!canvas)\n        {\n            canvas = settings.ADAPTER.createCanvas();\n            ownCanvas = true;\n        }\n\n        canvas.width = 3;\n        canvas.height = 3;\n\n        const texture = Texture.from(canvas);\n\n        texture.orig = new Rectangle();\n        texture.trim = new Rectangle();\n\n        super(texture);\n\n        this._ownCanvas = ownCanvas;\n        this.canvas = canvas;\n        this.context = canvas.getContext('2d', {\n            // required for trimming to work without warnings\n            willReadFrequently: true,\n        });\n\n        this._resolution = Text.defaultResolution ?? settings.RESOLUTION;\n        this._autoResolution = Text.defaultAutoResolution;\n        this._text = null;\n        this._style = null;\n        this._styleListener = null;\n        this._font = '';\n\n        this.text = text;\n        this.style = style;\n\n        this.localStyleID = -1;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.\n     */\n    public updateText(respectDirty: boolean): void\n    {\n        const style = this._style;\n\n        // check if style has changed..\n        if (this.localStyleID !== style.styleID)\n        {\n            this.dirty = true;\n            this.localStyleID = style.styleID;\n        }\n\n        if (!this.dirty && respectDirty)\n        {\n            return;\n        }\n\n        this._font = this._style.toFontString();\n\n        const context = this.context;\n        const measured = TextMetrics.measureText(this._text || ' ', this._style, this._style.wordWrap, this.canvas);\n        const width = measured.width;\n        const height = measured.height;\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        this.canvas.width = Math.ceil(Math.ceil((Math.max(1, width) + (style.padding * 2))) * this._resolution);\n        this.canvas.height = Math.ceil(Math.ceil((Math.max(1, height) + (style.padding * 2))) * this._resolution);\n\n        context.scale(this._resolution, this._resolution);\n\n        context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n        context.font = this._font;\n        context.lineWidth = style.strokeThickness;\n        context.textBaseline = style.textBaseline;\n        context.lineJoin = style.lineJoin;\n        context.miterLimit = style.miterLimit;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * this._resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const dropShadowColor = style.dropShadowColor;\n                const dropShadowBlur = style.dropShadowBlur * this._resolution;\n                const dropShadowDistance = style.dropShadowDistance * this._resolution;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(style.dropShadowAlpha)\n                    .toRgbaString();\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(style.dropShadowAngle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                // set canvas text styles\n                context.fillStyle = this._generateFillStyle(style, lines, measured);\n                // TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as\n                //       the setter converts to string. See this thread for more details:\n                //       https://github.com/microsoft/TypeScript/issues/2521\n                context.strokeStyle = style.stroke as string;\n\n                context.shadowColor = 'black';\n                context.shadowBlur = 0;\n                context.shadowOffsetX = 0;\n                context.shadowOffsetY = 0;\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = style.strokeThickness / 2;\n                linePositionY = ((style.strokeThickness / 2) + (i * lineHeight)) + fontProperties.ascent\n                    + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style.stroke && style.strokeThickness)\n                {\n                    this.drawLetterSpacing(\n                        lines[i],\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style.fill)\n                {\n                    this.drawLetterSpacing(\n                        lines[i],\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n\n        this.updateTexture();\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private drawLetterSpacing(text: string, x: number, y: number, isStroke = false): void\n    {\n        const style = this._style;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (TextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (TextMetrics.experimentalLetterSpacing)\n            {\n                this.context.letterSpacing = `${letterSpacing}px`;\n                this.context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                this.context.letterSpacing = '0px';\n                this.context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                this.context.strokeText(text, x, y);\n            }\n            else\n            {\n                this.context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = TextMetrics.graphemeSegmenter(text);\n        let previousWidth = this.context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                this.context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                this.context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = this.context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    /** Updates texture size based on canvas size. */\n    private updateTexture(): void\n    {\n        const canvas = this.canvas;\n\n        if (this._style.trim)\n        {\n            const trimmed = utils.trimCanvas(canvas);\n\n            if (trimmed.data)\n            {\n                canvas.width = trimmed.width;\n                canvas.height = trimmed.height;\n                this.context.putImageData(trimmed.data, 0, 0);\n            }\n        }\n\n        const texture = this._texture;\n        const style = this._style;\n        const padding = style.trim ? 0 : style.padding;\n        const baseTexture = texture.baseTexture;\n\n        texture.trim.width = texture._frame.width = canvas.width / this._resolution;\n        texture.trim.height = texture._frame.height = canvas.height / this._resolution;\n        texture.trim.x = -padding;\n        texture.trim.y = -padding;\n\n        texture.orig.width = texture._frame.width - (padding * 2);\n        texture.orig.height = texture._frame.height - (padding * 2);\n\n        // call sprite onTextureUpdate to update scale if _width or _height were set\n        this._onTextureUpdate();\n\n        baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);\n\n        texture.updateUvs();\n\n        this.dirty = false;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     * @param renderer - The renderer\n     */\n    protected _render(renderer: Renderer): void\n    {\n        if (this._autoResolution && this._resolution !== renderer.resolution)\n        {\n            this._resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        super._render(renderer);\n    }\n\n    /** Updates the transform on all children of this container for rendering. */\n    public updateTransform(): void\n    {\n        this.updateText(true);\n\n        super.updateTransform();\n    }\n\n    public getBounds(skipUpdate?: boolean, rect?: Rectangle): Rectangle\n    {\n        this.updateText(true);\n\n        if (this._textureID === -1)\n        {\n            // texture was updated: recalculate transforms\n            skipUpdate = false;\n        }\n\n        return super.getBounds(skipUpdate, rect);\n    }\n\n    /**\n     * Gets the local bounds of the text object.\n     * @param rect - The output rectangle.\n     * @returns The bounds.\n     */\n    public getLocalBounds(rect?: Rectangle): Rectangle\n    {\n        this.updateText(true);\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /** Calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account. */\n    protected _calculateBounds(): void\n    {\n        this.calculateVertices();\n        // if we have already done this on THIS frame.\n        this._bounds.addQuad(this.vertexData);\n    }\n\n    /**\n     * Generates the fill style. Can automatically generate a gradient based on the fill style being an array\n     * @param style - The style.\n     * @param lines - The lines of text.\n     * @param metrics\n     * @returns The fill style\n     */\n    private _generateFillStyle(\n        style: TextStyle, lines: string[], metrics: TextMetrics\n    ): string | CanvasGradient | CanvasPattern\n    {\n        // TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as\n        //       the setter converts to string. See this thread for more details:\n        //       https://github.com/microsoft/TypeScript/issues/2521\n        const fillStyle: string | string[] | CanvasGradient | CanvasPattern = style.fill as any;\n\n        if (!Array.isArray(fillStyle))\n        {\n            return fillStyle;\n        }\n        else if (fillStyle.length === 1)\n        {\n            return fillStyle[0];\n        }\n\n        // the gradient will be evenly spaced out according to how large the array is.\n        // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75\n        let gradient: string[] | CanvasGradient;\n\n        // a dropshadow will enlarge the canvas and result in the gradient being\n        // generated with the incorrect dimensions\n        const dropShadowCorrection = (style.dropShadow) ? style.dropShadowDistance : 0;\n\n        // should also take padding into account, padding can offset the gradient\n        const padding = style.padding || 0;\n\n        const width = (this.canvas.width / this._resolution) - dropShadowCorrection - (padding * 2);\n        const height = (this.canvas.height / this._resolution) - dropShadowCorrection - (padding * 2);\n\n        // make a copy of the style settings, so we can manipulate them later\n        const fill = fillStyle.slice();\n        const fillGradientStops = style.fillGradientStops.slice();\n\n        // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75\n        if (!fillGradientStops.length)\n        {\n            const lengthPlus1 = fill.length + 1;\n\n            for (let i = 1; i < lengthPlus1; ++i)\n            {\n                fillGradientStops.push(i / lengthPlus1);\n            }\n        }\n\n        // stop the bleeding of the last gradient on the line above to the top gradient of the this line\n        // by hard defining the first gradient colour at point 0, and last gradient colour at point 1\n        fill.unshift(fillStyle[0]);\n        fillGradientStops.unshift(0);\n\n        fill.push(fillStyle[fillStyle.length - 1]);\n        fillGradientStops.push(1);\n\n        if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL)\n        {\n            // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas\n            gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);\n\n            // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect\n            // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875\n\n            // Actual height of the text itself, not counting spacing for lineHeight/leading/dropShadow etc\n            const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;\n\n            for (let i = 0; i < lines.length; i++)\n            {\n                const lastLineBottom = (metrics.lineHeight * (i - 1)) + textHeight;\n                const thisLineTop = metrics.lineHeight * i;\n                let thisLineGradientStart = thisLineTop;\n\n                // Handle case where last & this line overlap\n                if (i > 0 && lastLineBottom > thisLineTop)\n                {\n                    thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;\n                }\n\n                const thisLineBottom = thisLineTop + textHeight;\n                const nextLineTop = metrics.lineHeight * (i + 1);\n                let thisLineGradientEnd = thisLineBottom;\n\n                // Handle case where this & next line overlap\n                if (i + 1 < lines.length && nextLineTop < thisLineBottom)\n                {\n                    thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;\n                }\n\n                // textHeight, but as a 0-1 size in global gradient stop space\n                const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;\n\n                for (let j = 0; j < fill.length; j++)\n                {\n                    // 0-1 stop point for the current line, multiplied to global space afterwards\n                    let lineStop = 0;\n\n                    if (typeof fillGradientStops[j] === 'number')\n                    {\n                        lineStop = fillGradientStops[j];\n                    }\n                    else\n                    {\n                        lineStop = j / fill.length;\n                    }\n\n                    let globalStop = Math.min(1, Math.max(0,\n                        (thisLineGradientStart / height) + (lineStop * gradStopLineHeight)));\n\n                    // There's potential for floating point precision issues at the seams between gradient repeats.\n                    globalStop = Number(globalStop.toFixed(5));\n                    gradient.addColorStop(globalStop, fill[j]);\n                }\n            }\n        }\n        else\n        {\n            // start the gradient at the center left of the canvas, and end at the center right of the canvas\n            gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);\n\n            // can just evenly space out the gradients in this case, as multiple lines makes no difference\n            // to an even left to right gradient\n            const totalIterations = fill.length + 1;\n            let currentIteration = 1;\n\n            for (let i = 0; i < fill.length; i++)\n            {\n                let stop: number;\n\n                if (typeof fillGradientStops[i] === 'number')\n                {\n                    stop = fillGradientStops[i];\n                }\n                else\n                {\n                    stop = currentIteration / totalIterations;\n                }\n                gradient.addColorStop(stop, fill[i]);\n                currentIteration++;\n            }\n        }\n\n        return gradient;\n    }\n\n    /**\n     * Destroys this text object.\n     *\n     * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as\n     * the majority of the time the texture will not be shared with any other Sprites.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their\n     *  destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well\n     */\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        if (typeof options === 'boolean')\n        {\n            options = { children: options };\n        }\n\n        options = Object.assign({}, defaultDestroyOptions, options);\n\n        super.destroy(options);\n\n        // set canvas width and height to 0 to workaround memory leak in Safari < 13\n        // https://stackoverflow.com/questions/52532614/total-canvas-memory-use-exceeds-the-maximum-limit-safari-12\n        if (this._ownCanvas)\n        {\n            this.canvas.height = this.canvas.width = 0;\n        }\n\n        // make sure to reset the context and canvas.. dont want this hanging around in memory!\n        this.context = null;\n        this.canvas = null;\n\n        this._style = null;\n    }\n\n    /** The width of the Text, setting this will actually modify the scale to achieve the value set. */\n    get width(): number\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    set width(value: number)\n    {\n        this.updateText(true);\n\n        const s = utils.sign(this.scale.x) || 1;\n\n        this.scale.x = s * value / this._texture.orig.width;\n        this._width = value;\n    }\n\n    /** The height of the Text, setting this will actually modify the scale to achieve the value set. */\n    get height(): number\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    set height(value: number)\n    {\n        this.updateText(true);\n\n        const s = utils.sign(this.scale.y) || 1;\n\n        this.scale.y = s * value / this._texture.orig.height;\n        this._height = value;\n    }\n\n    /**\n     * Set the style of the text.\n     *\n     * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n     *\n     * If setting the `style` can also be partial {@link PIXI.ITextStyle}.\n     */\n    get style(): TextStyle\n    {\n        return this._style;\n    }\n\n    set style(style: TextStyle | Partial<ITextStyle>)\n    {\n        style = style || {};\n\n        if (style instanceof TextStyle)\n        {\n            this._style = style;\n        }\n        else\n        {\n            this._style = new TextStyle(style);\n        }\n\n        this.localStyleID = -1;\n        this.dirty = true;\n    }\n\n    /** Set the copy for the text object. To split a line you can use '\\n'. */\n    get text(): string\n    {\n        return this._text;\n    }\n\n    set text(text: string | number)\n    {\n        text = String(text === null || text === undefined ? '' : text);\n\n        if (this._text === text)\n        {\n            return;\n        }\n        this._text = text;\n        this.dirty = true;\n    }\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default 1\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this._autoResolution = false;\n\n        if (this._resolution === value)\n        {\n            return;\n        }\n\n        this._resolution = value;\n        this.dirty = true;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}