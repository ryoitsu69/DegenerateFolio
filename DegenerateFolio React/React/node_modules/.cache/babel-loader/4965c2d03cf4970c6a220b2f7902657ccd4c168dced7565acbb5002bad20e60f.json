{"ast":null,"code":"import { u8aToHex } from '@polkadot/util';\n/** @internal */\nfunction formatFailure(registry, fn, _result, _ref, u8a, i, count, Type, key) {\n  let {\n    message\n  } = _ref;\n  let type = '';\n  try {\n    type = \": \".concat(new Type(registry).toRawType());\n  } catch {\n    // ignore\n  }\n  // This is extra debugging info (we most-probably want this in in some way, shape or form,\n  // but at this point not quite sure how to include and format it (it can be quite massive)\n  // console.error(JSON.stringify(result, null, 2));\n  return \"\".concat(fn, \": failed at \").concat(u8aToHex(u8a.subarray(0, 16)), \"\\u2026\").concat(key ? \" on \".concat(key) : '', \" (index \").concat(i + 1, \"/\").concat(count, \")\").concat(type, \":: \").concat(message);\n}\n/**\n * @internal\n *\n * Given an u8a, and an array of Type constructors, decode the u8a against the\n * types, and return an array of decoded values.\n *\n * @param u8a - The u8a to decode.\n * @param result - The result array (will be returned with values pushed)\n * @param types - The array of CodecClass to decode the U8a against.\n */\nexport function decodeU8a(registry, result, u8a, _ref2) {\n  let [Types, keys] = _ref2;\n  const count = result.length;\n  let offset = 0;\n  let i = 0;\n  try {\n    while (i < count) {\n      const value = new Types[i](registry, u8a.subarray(offset));\n      offset += value.initialU8aLength || value.encodedLength;\n      result[i] = value;\n      i++;\n    }\n  } catch (error) {\n    throw new Error(formatFailure(registry, 'decodeU8a', result, error, u8a.subarray(offset), i, count, Types[i], keys[i]));\n  }\n  return [result, offset];\n}\n/**\n * @internal\n *\n * Split from decodeU8a since this is specialized to zip returns ... while we duplicate, this\n * is all on the hot-path, so it is not great, however there is (some) method behind the madness\n */\nexport function decodeU8aStruct(registry, result, u8a, _ref3) {\n  let [Types, keys] = _ref3;\n  const count = result.length;\n  let offset = 0;\n  let i = 0;\n  try {\n    while (i < count) {\n      const value = new Types[i](registry, u8a.subarray(offset));\n      offset += value.initialU8aLength || value.encodedLength;\n      result[i] = [keys[i], value];\n      i++;\n    }\n  } catch (error) {\n    throw new Error(formatFailure(registry, 'decodeU8aStruct', result, error, u8a.subarray(offset), i, count, Types[i], keys[i]));\n  }\n  return [result, offset];\n}\n/**\n * @internal\n *\n * Split from decodeU8a since this is specialized to 1 instance ... while we duplicate, this\n * is all on the hot-path, so it is not great, however there is (some) method behind the madness\n */\nexport function decodeU8aVec(registry, result, u8a, startAt, Type) {\n  const count = result.length;\n  let offset = startAt;\n  let i = 0;\n  try {\n    while (i < count) {\n      const value = new Type(registry, u8a.subarray(offset));\n      offset += value.initialU8aLength || value.encodedLength;\n      result[i] = value;\n      i++;\n    }\n  } catch (error) {\n    throw new Error(formatFailure(registry, 'decodeU8aVec', result, error, u8a.subarray(offset), i, count, Type));\n  }\n  return [offset, offset - startAt];\n}","map":{"version":3,"names":["u8aToHex","formatFailure","registry","fn","_result","_ref","u8a","i","count","Type","key","message","type","concat","toRawType","subarray","decodeU8a","result","_ref2","Types","keys","length","offset","value","initialU8aLength","encodedLength","error","Error","decodeU8aStruct","_ref3","decodeU8aVec","startAt"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/utils/decodeU8a.js"],"sourcesContent":["import { u8aToHex } from '@polkadot/util';\n/** @internal */\nfunction formatFailure(registry, fn, _result, { message }, u8a, i, count, Type, key) {\n    let type = '';\n    try {\n        type = `: ${new Type(registry).toRawType()}`;\n    }\n    catch {\n        // ignore\n    }\n    // This is extra debugging info (we most-probably want this in in some way, shape or form,\n    // but at this point not quite sure how to include and format it (it can be quite massive)\n    // console.error(JSON.stringify(result, null, 2));\n    return `${fn}: failed at ${u8aToHex(u8a.subarray(0, 16))}â€¦${key ? ` on ${key}` : ''} (index ${i + 1}/${count})${type}:: ${message}`;\n}\n/**\n * @internal\n *\n * Given an u8a, and an array of Type constructors, decode the u8a against the\n * types, and return an array of decoded values.\n *\n * @param u8a - The u8a to decode.\n * @param result - The result array (will be returned with values pushed)\n * @param types - The array of CodecClass to decode the U8a against.\n */\nexport function decodeU8a(registry, result, u8a, [Types, keys]) {\n    const count = result.length;\n    let offset = 0;\n    let i = 0;\n    try {\n        while (i < count) {\n            const value = new Types[i](registry, u8a.subarray(offset));\n            offset += value.initialU8aLength || value.encodedLength;\n            result[i] = value;\n            i++;\n        }\n    }\n    catch (error) {\n        throw new Error(formatFailure(registry, 'decodeU8a', result, error, u8a.subarray(offset), i, count, Types[i], keys[i]));\n    }\n    return [result, offset];\n}\n/**\n * @internal\n *\n * Split from decodeU8a since this is specialized to zip returns ... while we duplicate, this\n * is all on the hot-path, so it is not great, however there is (some) method behind the madness\n */\nexport function decodeU8aStruct(registry, result, u8a, [Types, keys]) {\n    const count = result.length;\n    let offset = 0;\n    let i = 0;\n    try {\n        while (i < count) {\n            const value = new Types[i](registry, u8a.subarray(offset));\n            offset += value.initialU8aLength || value.encodedLength;\n            result[i] = [keys[i], value];\n            i++;\n        }\n    }\n    catch (error) {\n        throw new Error(formatFailure(registry, 'decodeU8aStruct', result, error, u8a.subarray(offset), i, count, Types[i], keys[i]));\n    }\n    return [result, offset];\n}\n/**\n * @internal\n *\n * Split from decodeU8a since this is specialized to 1 instance ... while we duplicate, this\n * is all on the hot-path, so it is not great, however there is (some) method behind the madness\n */\nexport function decodeU8aVec(registry, result, u8a, startAt, Type) {\n    const count = result.length;\n    let offset = startAt;\n    let i = 0;\n    try {\n        while (i < count) {\n            const value = new Type(registry, u8a.subarray(offset));\n            offset += value.initialU8aLength || value.encodedLength;\n            result[i] = value;\n            i++;\n        }\n    }\n    catch (error) {\n        throw new Error(formatFailure(registry, 'decodeU8aVec', result, error, u8a.subarray(offset), i, count, Type));\n    }\n    return [offset, offset - startAt];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}