{"ast":null,"code":"import { compactFromU8aLim, identity, isHex, isU8a, logger, stringify, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8aVec, typeToConstructor } from '../utils/index.js';\nconst MAX_LENGTH = 64 * 1024;\nconst l = logger('Vec');\nfunction decodeVecLength(value) {\n  if (Array.isArray(value)) {\n    return [value, value.length, 0];\n  } else if (isU8a(value) || isHex(value)) {\n    const u8a = u8aToU8a(value);\n    const [startAt, length] = compactFromU8aLim(u8a);\n    if (length > MAX_LENGTH) {\n      throw new Error(`Vec length ${length.toString()} exceeds ${MAX_LENGTH}`);\n    }\n    return [u8a, length, startAt];\n  } else if (!value) {\n    return [null, 0, 0];\n  }\n  throw new Error(`Expected array/hex input to Vec<*> decoding, found ${typeof value}: ${stringify(value)}`);\n}\nexport function decodeVec(registry, result, value, startAt, Type) {\n  if (Array.isArray(value)) {\n    const count = result.length;\n    for (let i = 0; i < count; i++) {\n      // 26/08/2022 this is actually a false positive - after recent eslint upgdates\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const entry = value[i];\n      try {\n        result[i] = entry instanceof Type ? entry : new Type(registry, entry);\n      } catch (error) {\n        l.error(`Unable to decode on index ${i}`, error.message);\n        throw error;\n      }\n    }\n    return [0, 0];\n  } else if (!value) {\n    return [0, 0];\n  }\n  // we don't need more checks, we already limited it via the length decoding\n  return decodeU8aVec(registry, result, u8aToU8a(value), startAt, Type);\n}\n/**\n * @name Vec\n * @description\n * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows\n * construction with the passed `Type` in the constructor. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n */\nexport class Vec extends AbstractArray {\n  __internal__Type;\n  constructor(registry, Type, value = [], {\n    definition,\n    setDefinition = identity\n  } = {}) {\n    const [decodeFrom, length, startAt] = decodeVecLength(value);\n    super(registry, length);\n    this.__internal__Type = definition || setDefinition(typeToConstructor(registry, Type));\n    this.initialU8aLength = (isU8a(decodeFrom) ? decodeU8aVec(registry, this, decodeFrom, startAt, this.__internal__Type) : decodeVec(registry, this, decodeFrom, startAt, this.__internal__Type))[0];\n  }\n  static with(Type) {\n    let definition;\n    // eslint-disable-next-line no-return-assign\n    const setDefinition = d => definition = d;\n    return class extends Vec {\n      constructor(registry, value) {\n        super(registry, Type, value, {\n          definition,\n          setDefinition\n        });\n      }\n    };\n  }\n  /**\n   * @description The type for the items\n   */\n  get Type() {\n    return this.__internal__Type.name;\n  }\n  /**\n   * @description Finds the index of the value in the array\n   */\n  indexOf(other) {\n    // convert type first, this removes overhead from the eq\n    const check = other instanceof this.__internal__Type ? other : new this.__internal__Type(this.registry, other);\n    for (let i = 0, count = this.length; i < count; i++) {\n      if (check.eq(this[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return `Vec<${this.registry.getClassName(this.__internal__Type) || new this.__internal__Type(this.registry).toRawType()}>`;\n  }\n}","map":{"version":3,"names":["compactFromU8aLim","identity","isHex","isU8a","logger","stringify","u8aToU8a","AbstractArray","decodeU8aVec","typeToConstructor","MAX_LENGTH","l","decodeVecLength","value","Array","isArray","length","u8a","startAt","Error","toString","decodeVec","registry","result","Type","count","i","entry","error","message","Vec","__internal__Type","constructor","definition","setDefinition","decodeFrom","initialU8aLength","with","d","name","indexOf","other","check","eq","toRawType","getClassName"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/base/Vec.js"],"sourcesContent":["import { compactFromU8aLim, identity, isHex, isU8a, logger, stringify, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8aVec, typeToConstructor } from '../utils/index.js';\nconst MAX_LENGTH = 64 * 1024;\nconst l = logger('Vec');\nfunction decodeVecLength(value) {\n    if (Array.isArray(value)) {\n        return [value, value.length, 0];\n    }\n    else if (isU8a(value) || isHex(value)) {\n        const u8a = u8aToU8a(value);\n        const [startAt, length] = compactFromU8aLim(u8a);\n        if (length > MAX_LENGTH) {\n            throw new Error(`Vec length ${length.toString()} exceeds ${MAX_LENGTH}`);\n        }\n        return [u8a, length, startAt];\n    }\n    else if (!value) {\n        return [null, 0, 0];\n    }\n    throw new Error(`Expected array/hex input to Vec<*> decoding, found ${typeof value}: ${stringify(value)}`);\n}\nexport function decodeVec(registry, result, value, startAt, Type) {\n    if (Array.isArray(value)) {\n        const count = result.length;\n        for (let i = 0; i < count; i++) {\n            // 26/08/2022 this is actually a false positive - after recent eslint upgdates\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const entry = value[i];\n            try {\n                result[i] = entry instanceof Type\n                    ? entry\n                    : new Type(registry, entry);\n            }\n            catch (error) {\n                l.error(`Unable to decode on index ${i}`, error.message);\n                throw error;\n            }\n        }\n        return [0, 0];\n    }\n    else if (!value) {\n        return [0, 0];\n    }\n    // we don't need more checks, we already limited it via the length decoding\n    return decodeU8aVec(registry, result, u8aToU8a(value), startAt, Type);\n}\n/**\n * @name Vec\n * @description\n * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows\n * construction with the passed `Type` in the constructor. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n */\nexport class Vec extends AbstractArray {\n    __internal__Type;\n    constructor(registry, Type, value = [], { definition, setDefinition = identity } = {}) {\n        const [decodeFrom, length, startAt] = decodeVecLength(value);\n        super(registry, length);\n        this.__internal__Type = definition || setDefinition(typeToConstructor(registry, Type));\n        this.initialU8aLength = (isU8a(decodeFrom)\n            ? decodeU8aVec(registry, this, decodeFrom, startAt, this.__internal__Type)\n            : decodeVec(registry, this, decodeFrom, startAt, this.__internal__Type))[0];\n    }\n    static with(Type) {\n        let definition;\n        // eslint-disable-next-line no-return-assign\n        const setDefinition = (d) => (definition = d);\n        return class extends Vec {\n            constructor(registry, value) {\n                super(registry, Type, value, { definition, setDefinition });\n            }\n        };\n    }\n    /**\n     * @description The type for the items\n     */\n    get Type() {\n        return this.__internal__Type.name;\n    }\n    /**\n     * @description Finds the index of the value in the array\n     */\n    indexOf(other) {\n        // convert type first, this removes overhead from the eq\n        const check = other instanceof this.__internal__Type\n            ? other\n            : new this.__internal__Type(this.registry, other);\n        for (let i = 0, count = this.length; i < count; i++) {\n            if (check.eq(this[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `Vec<${this.registry.getClassName(this.__internal__Type) || new this.__internal__Type(this.registry).toRawType()}>`;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}