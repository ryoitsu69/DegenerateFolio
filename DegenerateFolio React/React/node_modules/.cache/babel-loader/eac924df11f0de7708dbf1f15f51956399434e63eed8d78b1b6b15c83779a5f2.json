{"ast":null,"code":"import { Color, ObservablePoint, settings, Point, Texture, utils, BLEND_MODES, Program } from \"@pixi/core\";\nimport { Container } from \"@pixi/display\";\nimport { MeshGeometry, MeshMaterial, Mesh } from \"@pixi/mesh\";\nimport { BitmapFont } from \"./BitmapFont.mjs\";\nimport msdfFrag from \"./shader/msdf.frag.mjs\";\nimport msdfVert from \"./shader/msdf.vert.mjs\";\nimport \"./utils/index.mjs\";\nimport { splitTextToCharacters } from \"./utils/splitTextToCharacters.mjs\";\nimport { extractCharCode } from \"./utils/extractCharCode.mjs\";\nconst pageMeshDataDefaultPageMeshData = [],\n  pageMeshDataMSDFPageMeshData = [],\n  charRenderDataPool = [],\n  _BitmapText = class _BitmapText2 extends Container {\n    /**\n     * @param text - A string that you would like the text to display.\n     * @param style - The style parameters.\n     * @param {string} style.fontName - The installed BitmapFont name.\n     * @param {number} [style.fontSize] - The size of the font in pixels, e.g. 24. If undefined,\n     *.     this will default to the BitmapFont size.\n     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center', 'right' or 'justify'),\n     *      does not affect single line text.\n     * @param {PIXI.ColorSource} [style.tint=0xFFFFFF] - The tint color.\n     * @param {number} [style.letterSpacing=0] - The amount of spacing between letters.\n     * @param {number} [style.maxWidth=0] - The max width of the text before line wrapping.\n     */\n    constructor(text, style = {}) {\n      super();\n      const {\n        align,\n        tint,\n        maxWidth,\n        letterSpacing,\n        fontName,\n        fontSize\n      } = Object.assign({}, _BitmapText2.styleDefaults, style);\n      if (!BitmapFont.available[fontName]) throw new Error(`Missing BitmapFont \"${fontName}\"`);\n      this._activePagesMeshData = [], this._textWidth = 0, this._textHeight = 0, this._align = align, this._tintColor = new Color(tint), this._font = void 0, this._fontName = fontName, this._fontSize = fontSize, this.text = text, this._maxWidth = maxWidth, this._maxLineHeight = 0, this._letterSpacing = letterSpacing, this._anchor = new ObservablePoint(() => {\n        this.dirty = !0;\n      }, this, 0, 0), this._roundPixels = settings.ROUND_PIXELS, this.dirty = !0, this._resolution = settings.RESOLUTION, this._autoResolution = !0, this._textureCache = {};\n    }\n    /** Renders text and updates it when needed. This should only be called if the BitmapFont is regenerated. */\n    updateText() {\n      const data = BitmapFont.available[this._fontName],\n        fontSize = this.fontSize,\n        scale = fontSize / data.size,\n        pos = new Point(),\n        chars = [],\n        lineWidths = [],\n        lineSpaces = [],\n        text = this._text.replace(/(?:\\r\\n|\\r)/g, `\n`) || \" \",\n        charsInput = splitTextToCharacters(text),\n        maxWidth = this._maxWidth * data.size / fontSize,\n        pageMeshDataPool = data.distanceFieldType === \"none\" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n      let prevCharCode = null,\n        lastLineWidth = 0,\n        maxLineWidth = 0,\n        line = 0,\n        lastBreakPos = -1,\n        lastBreakWidth = 0,\n        spacesRemoved = 0,\n        maxLineHeight = 0,\n        spaceCount = 0;\n      for (let i = 0; i < charsInput.length; i++) {\n        const char = charsInput[i],\n          charCode = extractCharCode(char);\n        if (/(?:\\s)/.test(char) && (lastBreakPos = i, lastBreakWidth = lastLineWidth, spaceCount++), char === \"\\r\" || char === `\n`) {\n          lineWidths.push(lastLineWidth), lineSpaces.push(-1), maxLineWidth = Math.max(maxLineWidth, lastLineWidth), ++line, ++spacesRemoved, pos.x = 0, pos.y += data.lineHeight, prevCharCode = null, spaceCount = 0;\n          continue;\n        }\n        const charData = data.chars[charCode];\n        if (!charData) continue;\n        prevCharCode && charData.kerning[prevCharCode] && (pos.x += charData.kerning[prevCharCode]);\n        const charRenderData = charRenderDataPool.pop() || {\n          texture: Texture.EMPTY,\n          line: 0,\n          charCode: 0,\n          prevSpaces: 0,\n          position: new Point()\n        };\n        charRenderData.texture = charData.texture, charRenderData.line = line, charRenderData.charCode = charCode, charRenderData.position.x = Math.round(pos.x + charData.xOffset + this._letterSpacing / 2), charRenderData.position.y = Math.round(pos.y + charData.yOffset), charRenderData.prevSpaces = spaceCount, chars.push(charRenderData), lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width), pos.x += charData.xAdvance + this._letterSpacing, maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height), prevCharCode = charCode, lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth && (++spacesRemoved, utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos), i = lastBreakPos, lastBreakPos = -1, lineWidths.push(lastBreakWidth), lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0), maxLineWidth = Math.max(maxLineWidth, lastBreakWidth), line++, pos.x = 0, pos.y += data.lineHeight, prevCharCode = null, spaceCount = 0);\n      }\n      const lastChar = charsInput[charsInput.length - 1];\n      lastChar !== \"\\r\" && lastChar !== `\n` && (/(?:\\s)/.test(lastChar) && (lastLineWidth = lastBreakWidth), lineWidths.push(lastLineWidth), maxLineWidth = Math.max(maxLineWidth, lastLineWidth), lineSpaces.push(-1));\n      const lineAlignOffsets = [];\n      for (let i = 0; i <= line; i++) {\n        let alignOffset = 0;\n        this._align === \"right\" ? alignOffset = maxLineWidth - lineWidths[i] : this._align === \"center\" ? alignOffset = (maxLineWidth - lineWidths[i]) / 2 : this._align === \"justify\" && (alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i]), lineAlignOffsets.push(alignOffset);\n      }\n      const lenChars = chars.length,\n        pagesMeshData = {},\n        newPagesMeshData = [],\n        activePagesMeshData = this._activePagesMeshData;\n      pageMeshDataPool.push(...activePagesMeshData);\n      for (let i = 0; i < lenChars; i++) {\n        const texture = chars[i].texture,\n          baseTextureUid = texture.baseTexture.uid;\n        if (!pagesMeshData[baseTextureUid]) {\n          let pageMeshData = pageMeshDataPool.pop();\n          if (!pageMeshData) {\n            const geometry = new MeshGeometry();\n            let material, meshBlendMode;\n            data.distanceFieldType === \"none\" ? (material = new MeshMaterial(Texture.EMPTY), meshBlendMode = BLEND_MODES.NORMAL) : (material = new MeshMaterial(Texture.EMPTY, {\n              program: Program.from(msdfVert, msdfFrag),\n              uniforms: {\n                uFWidth: 0\n              }\n            }), meshBlendMode = BLEND_MODES.NORMAL_NPM);\n            const mesh = new Mesh(geometry, material);\n            mesh.blendMode = meshBlendMode, pageMeshData = {\n              index: 0,\n              indexCount: 0,\n              vertexCount: 0,\n              uvsCount: 0,\n              total: 0,\n              mesh,\n              vertices: null,\n              uvs: null,\n              indices: null\n            };\n          }\n          pageMeshData.index = 0, pageMeshData.indexCount = 0, pageMeshData.vertexCount = 0, pageMeshData.uvsCount = 0, pageMeshData.total = 0;\n          const {\n            _textureCache\n          } = this;\n          _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture), pageMeshData.mesh.texture = _textureCache[baseTextureUid], pageMeshData.mesh.tint = this._tintColor.value, newPagesMeshData.push(pageMeshData), pagesMeshData[baseTextureUid] = pageMeshData;\n        }\n        pagesMeshData[baseTextureUid].total++;\n      }\n      for (let i = 0; i < activePagesMeshData.length; i++) newPagesMeshData.includes(activePagesMeshData[i]) || this.removeChild(activePagesMeshData[i].mesh);\n      for (let i = 0; i < newPagesMeshData.length; i++) newPagesMeshData[i].mesh.parent !== this && this.addChild(newPagesMeshData[i].mesh);\n      this._activePagesMeshData = newPagesMeshData;\n      for (const i in pagesMeshData) {\n        const pageMeshData = pagesMeshData[i],\n          total = pageMeshData.total;\n        if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) pageMeshData.vertices = new Float32Array(4 * 2 * total), pageMeshData.uvs = new Float32Array(4 * 2 * total), pageMeshData.indices = new Uint16Array(6 * total);else {\n          const total2 = pageMeshData.total,\n            vertices = pageMeshData.vertices;\n          for (let i2 = total2 * 4 * 2; i2 < vertices.length; i2++) vertices[i2] = 0;\n        }\n        pageMeshData.mesh.size = 6 * total;\n      }\n      for (let i = 0; i < lenChars; i++) {\n        const char = chars[i];\n        let offset = char.position.x + lineAlignOffsets[char.line] * (this._align === \"justify\" ? char.prevSpaces : 1);\n        this._roundPixels && (offset = Math.round(offset));\n        const xPos = offset * scale,\n          yPos = char.position.y * scale,\n          texture = char.texture,\n          pageMesh = pagesMeshData[texture.baseTexture.uid],\n          textureFrame = texture.frame,\n          textureUvs = texture._uvs,\n          index = pageMesh.index++;\n        pageMesh.indices[index * 6 + 0] = 0 + index * 4, pageMesh.indices[index * 6 + 1] = 1 + index * 4, pageMesh.indices[index * 6 + 2] = 2 + index * 4, pageMesh.indices[index * 6 + 3] = 0 + index * 4, pageMesh.indices[index * 6 + 4] = 2 + index * 4, pageMesh.indices[index * 6 + 5] = 3 + index * 4, pageMesh.vertices[index * 8 + 0] = xPos, pageMesh.vertices[index * 8 + 1] = yPos, pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale, pageMesh.vertices[index * 8 + 3] = yPos, pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale, pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale, pageMesh.vertices[index * 8 + 6] = xPos, pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale, pageMesh.uvs[index * 8 + 0] = textureUvs.x0, pageMesh.uvs[index * 8 + 1] = textureUvs.y0, pageMesh.uvs[index * 8 + 2] = textureUvs.x1, pageMesh.uvs[index * 8 + 3] = textureUvs.y1, pageMesh.uvs[index * 8 + 4] = textureUvs.x2, pageMesh.uvs[index * 8 + 5] = textureUvs.y2, pageMesh.uvs[index * 8 + 6] = textureUvs.x3, pageMesh.uvs[index * 8 + 7] = textureUvs.y3;\n      }\n      this._textWidth = maxLineWidth * scale, this._textHeight = (pos.y + data.lineHeight) * scale;\n      for (const i in pagesMeshData) {\n        const pageMeshData = pagesMeshData[i];\n        if (this.anchor.x !== 0 || this.anchor.y !== 0) {\n          let vertexCount = 0;\n          const anchorOffsetX = this._textWidth * this.anchor.x,\n            anchorOffsetY = this._textHeight * this.anchor.y;\n          for (let i2 = 0; i2 < pageMeshData.total; i2++) pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY, pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY, pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY, pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n        }\n        this._maxLineHeight = maxLineHeight * scale;\n        const vertexBuffer = pageMeshData.mesh.geometry.getBuffer(\"aVertexPosition\"),\n          textureBuffer = pageMeshData.mesh.geometry.getBuffer(\"aTextureCoord\"),\n          indexBuffer = pageMeshData.mesh.geometry.getIndex();\n        vertexBuffer.data = pageMeshData.vertices, textureBuffer.data = pageMeshData.uvs, indexBuffer.data = pageMeshData.indices, vertexBuffer.update(), textureBuffer.update(), indexBuffer.update();\n      }\n      for (let i = 0; i < chars.length; i++) charRenderDataPool.push(chars[i]);\n      this._font = data, this.dirty = !1;\n    }\n    updateTransform() {\n      this.validate(), this.containerUpdateTransform();\n    }\n    _render(renderer) {\n      this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0);\n      const {\n        distanceFieldRange,\n        distanceFieldType,\n        size\n      } = BitmapFont.available[this._fontName];\n      if (distanceFieldType !== \"none\") {\n        const {\n            a,\n            b,\n            c,\n            d\n          } = this.worldTransform,\n          dx = Math.sqrt(a * a + b * b),\n          dy = Math.sqrt(c * c + d * d),\n          worldScale = (Math.abs(dx) + Math.abs(dy)) / 2,\n          fontScale = this.fontSize / size,\n          resolution = renderer._view.resolution;\n        for (const mesh of this._activePagesMeshData) mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;\n      }\n      super._render(renderer);\n    }\n    /**\n     * Validates text before calling parent's getLocalBounds\n     * @returns - The rectangular bounding area\n     */\n    getLocalBounds() {\n      return this.validate(), super.getLocalBounds();\n    }\n    /**\n     * Updates text when needed\n     * @private\n     */\n    validate() {\n      const font = BitmapFont.available[this._fontName];\n      if (!font) throw new Error(`Missing BitmapFont \"${this._fontName}\"`);\n      this._font !== font && (this.dirty = !0), this.dirty && this.updateText();\n    }\n    /**\n     * The tint of the BitmapText object.\n     * @default 0xffffff\n     */\n    get tint() {\n      return this._tintColor.value;\n    }\n    set tint(value) {\n      if (this.tint !== value) {\n        this._tintColor.setValue(value);\n        for (let i = 0; i < this._activePagesMeshData.length; i++) this._activePagesMeshData[i].mesh.tint = value;\n      }\n    }\n    /**\n     * The alignment of the BitmapText object.\n     * @member {string}\n     * @default 'left'\n     */\n    get align() {\n      return this._align;\n    }\n    set align(value) {\n      this._align !== value && (this._align = value, this.dirty = !0);\n    }\n    /** The name of the BitmapFont. */\n    get fontName() {\n      return this._fontName;\n    }\n    set fontName(value) {\n      if (!BitmapFont.available[value]) throw new Error(`Missing BitmapFont \"${value}\"`);\n      this._fontName !== value && (this._fontName = value, this.dirty = !0);\n    }\n    /** The size of the font to display. */\n    get fontSize() {\n      return this._fontSize ?? BitmapFont.available[this._fontName].size;\n    }\n    set fontSize(value) {\n      this._fontSize !== value && (this._fontSize = value, this.dirty = !0);\n    }\n    /**\n     * The anchor sets the origin point of the text.\n     *\n     * The default is `(0,0)`, this means the text's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n     */\n    get anchor() {\n      return this._anchor;\n    }\n    set anchor(value) {\n      typeof value == \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n    /** The text of the BitmapText object. */\n    get text() {\n      return this._text;\n    }\n    set text(text) {\n      text = String(text ?? \"\"), this._text !== text && (this._text = text, this.dirty = !0);\n    }\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting the value to 0.\n     */\n    get maxWidth() {\n      return this._maxWidth;\n    }\n    set maxWidth(value) {\n      this._maxWidth !== value && (this._maxWidth = value, this.dirty = !0);\n    }\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * i.e. when trying to vertically align.\n     * @readonly\n     */\n    get maxLineHeight() {\n      return this.validate(), this._maxLineHeight;\n    }\n    /**\n     * The width of the overall text, different from fontSize,\n     * which is defined in the style object.\n     * @readonly\n     */\n    get textWidth() {\n      return this.validate(), this._textWidth;\n    }\n    /** Additional space between characters. */\n    get letterSpacing() {\n      return this._letterSpacing;\n    }\n    set letterSpacing(value) {\n      this._letterSpacing !== value && (this._letterSpacing = value, this.dirty = !0);\n    }\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n     * @default PIXI.settings.ROUND_PIXELS\n     */\n    get roundPixels() {\n      return this._roundPixels;\n    }\n    set roundPixels(value) {\n      value !== this._roundPixels && (this._roundPixels = value, this.dirty = !0);\n    }\n    /**\n     * The height of the overall text, different from fontSize,\n     * which is defined in the style object.\n     * @readonly\n     */\n    get textHeight() {\n      return this.validate(), this._textHeight;\n    }\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default 1\n     */\n    get resolution() {\n      return this._resolution;\n    }\n    set resolution(value) {\n      this._autoResolution = !1, this._resolution !== value && (this._resolution = value, this.dirty = !0);\n    }\n    destroy(options) {\n      const {\n          _textureCache\n        } = this,\n        pageMeshDataPool = BitmapFont.available[this._fontName].distanceFieldType === \"none\" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n      pageMeshDataPool.push(...this._activePagesMeshData);\n      for (const pageMeshData of this._activePagesMeshData) this.removeChild(pageMeshData.mesh);\n      this._activePagesMeshData = [], pageMeshDataPool.filter(page => _textureCache[page.mesh.texture.baseTexture.uid]).forEach(page => {\n        page.mesh.texture = Texture.EMPTY;\n      });\n      for (const id in _textureCache) _textureCache[id].destroy(), delete _textureCache[id];\n      this._font = null, this._tintColor = null, this._textureCache = null, super.destroy(options);\n    }\n  };\n_BitmapText.styleDefaults = {\n  align: \"left\",\n  tint: 16777215,\n  maxWidth: 0,\n  letterSpacing: 0\n};\nlet BitmapText = _BitmapText;\nexport { BitmapText };","map":{"version":3,"names":["pageMeshDataDefaultPageMeshData","pageMeshDataMSDFPageMeshData","charRenderDataPool","_BitmapText","_BitmapText2","Container","constructor","text","style","align","tint","maxWidth","letterSpacing","fontName","fontSize","Object","assign","styleDefaults","BitmapFont","available","Error","_activePagesMeshData","_textWidth","_textHeight","_align","_tintColor","Color","_font","_fontName","_fontSize","_maxWidth","_maxLineHeight","_letterSpacing","_anchor","ObservablePoint","dirty","_roundPixels","settings","ROUND_PIXELS","_resolution","RESOLUTION","_autoResolution","_textureCache","updateText","data","scale","size","pos","Point","chars","lineWidths","lineSpaces","_text","replace","charsInput","splitTextToCharacters","pageMeshDataPool","distanceFieldType","prevCharCode","lastLineWidth","maxLineWidth","line","lastBreakPos","lastBreakWidth","spacesRemoved","maxLineHeight","spaceCount","i","length","char","charCode","extractCharCode","test","push","Math","max","x","y","lineHeight","charData","kerning","charRenderData","pop","texture","Texture","EMPTY","prevSpaces","position","round","xOffset","yOffset","xAdvance","orig","width","height","utils","removeItems","lastChar","lineAlignOffsets","alignOffset","lenChars","pagesMeshData","newPagesMeshData","activePagesMeshData","baseTextureUid","baseTexture","uid","pageMeshData","geometry","MeshGeometry","material","meshBlendMode","MeshMaterial","BLEND_MODES","NORMAL","program","Program","from","msdfVert","msdfFrag","uniforms","uFWidth","NORMAL_NPM","mesh","Mesh","blendMode","index","indexCount","vertexCount","uvsCount","total","vertices","uvs","indices","value","includes","removeChild","parent","addChild","BATCHABLE_SIZE","Float32Array","Uint16Array","total2","i2","offset","xPos","yPos","pageMesh","textureFrame","frame","textureUvs","_uvs","x0","y0","x1","y1","x2","y2","x3","y3","anchor","anchorOffsetX","anchorOffsetY","vertexBuffer","getBuffer","textureBuffer","indexBuffer","getIndex","update","updateTransform","validate","containerUpdateTransform","_render","renderer","resolution","distanceFieldRange","a","b","c","d","worldTransform","dx","sqrt","dy","worldScale","abs","fontScale","_view","shader","getLocalBounds","font","setValue","set","copyFrom","String","textWidth","roundPixels","textHeight","destroy","options","filter","page","forEach","id","BitmapText"],"sources":["/home/ryoitsu/node_modules/@pixi/text-bitmap/src/BitmapText.ts"],"sourcesContent":["import { BLEND_MODES, Color, ObservablePoint, Point, Program, settings, Texture, utils } from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { Mesh, MeshGeometry, MeshMaterial } from '@pixi/mesh';\nimport { BitmapFont } from './BitmapFont';\nimport msdfFrag from './shader/msdf.frag';\nimport msdfVert from './shader/msdf.vert';\nimport { extractCharCode, splitTextToCharacters } from './utils';\n\nimport type { ColorSource, Rectangle, Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { TextStyleAlign } from '@pixi/text';\nimport type { IBitmapTextStyle } from './BitmapTextStyle';\n\ninterface PageMeshData\n{\n    index: number;\n    indexCount: number;\n    vertexCount: number;\n    uvsCount: number;\n    total: number;\n    mesh: Mesh;\n    vertices?: Float32Array;\n    uvs?: Float32Array;\n    indices?: Uint16Array;\n}\ninterface CharRenderData\n{\n    texture: Texture;\n    line: number;\n    charCode: number;\n    position: Point;\n    prevSpaces: number;\n}\n\n// If we ever need more than two pools, please make a Dict or something better.\nconst pageMeshDataDefaultPageMeshData: PageMeshData[] = [];\nconst pageMeshDataMSDFPageMeshData: PageMeshData[] = [];\nconst charRenderDataPool: CharRenderData[] = [];\n\n/**\n * A BitmapText object will create a line or multiple lines of text using bitmap font.\n *\n * The primary advantage of this class over Text is that all of your textures are pre-generated and loading,\n * meaning that rendering is fast, and changing text has no performance implications.\n *\n * Supporting character sets other than latin, such as CJK languages, may be impractical due to the number of characters.\n *\n * To split a line you can use '\\n', '\\r' or '\\r\\n' in your string.\n *\n * PixiJS can auto-generate fonts on-the-fly using BitmapFont or use fnt files provided by:\n * http://www.angelcode.com/products/bmfont/ for Windows or\n * http://www.bmglyph.com/ for Mac.\n *\n * You can also use SDF, MSDF and MTSDF BitmapFonts for vector-like scaling appearance provided by:\n * https://github.com/soimy/msdf-bmfont-xml for SDF and MSDF fnt files or\n * https://github.com/Chlumsky/msdf-atlas-gen for SDF, MSDF and MTSDF json files\n *\n * A BitmapText can only be created when the font is loaded.\n * @example\n * import { BitmapText } from 'pixi.js';\n *\n * // in this case the font is in a file called 'desyrel.fnt'\n * const bitmapText = new BitmapText('text using a fancy font!', {\n *     fontName: 'Desyrel',\n *     fontSize: 35,\n *     align: 'right',\n * });\n * @memberof PIXI\n */\nexport class BitmapText extends Container\n{\n    public static styleDefaults: Partial<IBitmapTextStyle> = {\n        align: 'left',\n        tint: 0xFFFFFF,\n        maxWidth: 0,\n        letterSpacing: 0,\n    };\n\n    /** Set to `true` if the BitmapText needs to be redrawn. */\n    public dirty: boolean;\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default PIXI.settings.RESOLUTION\n     */\n    _resolution: number;\n    _autoResolution: boolean;\n\n    /**\n     * Private tracker for the width of the overall text.\n     * @private\n     */\n    protected _textWidth: number;\n\n    /**\n     * Private tracker for the height of the overall text.\n     * @private\n     */\n    protected _textHeight: number;\n\n    /**\n     * Private tracker for the current text.\n     * @private\n     */\n    protected _text: string;\n\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting value to 0\n     * @private\n     */\n    protected _maxWidth: number;\n\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * ie: when trying to vertically align. (Internally used)\n     * @private\n     */\n    protected _maxLineHeight: number;\n\n    /**\n     * Letter spacing. This is useful for setting the space between characters.\n     * @private\n     */\n    protected _letterSpacing: number;\n\n    /**\n     * Text anchor.\n     * @readonly\n     * @private\n     */\n    protected _anchor: ObservablePoint;\n\n    /**\n     * Private tracker for the current font.\n     * @private\n     */\n    protected _font?: BitmapFont;\n\n    /**\n     * Private tracker for the current font name.\n     * @private\n     */\n    protected _fontName: string;\n\n    /**\n     * Private tracker for the current font size.\n     * @private\n     */\n    protected _fontSize?: number;\n\n    /**\n     * Private tracker for the current text align.\n     * @type {string}\n     * @private\n     */\n    protected _align: TextStyleAlign;\n\n    /** Collection of page mesh data. */\n    protected _activePagesMeshData: PageMeshData[];\n\n    /**\n     * Private tracker for the current tint.\n     * @private\n     */\n    protected _tintColor: Color;\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering.\n     * @default PIXI.settings.ROUND_PIXELS\n     */\n    protected _roundPixels: boolean;\n\n    /** Cached char texture is destroyed when BitmapText is destroyed. */\n    private _textureCache: Record<number, Texture>;\n\n    /**\n     * @param text - A string that you would like the text to display.\n     * @param style - The style parameters.\n     * @param {string} style.fontName - The installed BitmapFont name.\n     * @param {number} [style.fontSize] - The size of the font in pixels, e.g. 24. If undefined,\n     *.     this will default to the BitmapFont size.\n     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center', 'right' or 'justify'),\n     *      does not affect single line text.\n     * @param {PIXI.ColorSource} [style.tint=0xFFFFFF] - The tint color.\n     * @param {number} [style.letterSpacing=0] - The amount of spacing between letters.\n     * @param {number} [style.maxWidth=0] - The max width of the text before line wrapping.\n     */\n    constructor(text: string, style: Partial<IBitmapTextStyle> = {})\n    {\n        super();\n\n        // Apply the defaults\n        const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign(\n            {}, BitmapText.styleDefaults, style);\n\n        if (!BitmapFont.available[fontName])\n        {\n            throw new Error(`Missing BitmapFont \"${fontName}\"`);\n        }\n\n        this._activePagesMeshData = [];\n        this._textWidth = 0;\n        this._textHeight = 0;\n        this._align = align;\n        this._tintColor = new Color(tint);\n        this._font = undefined;\n        this._fontName = fontName;\n        this._fontSize = fontSize;\n        this.text = text;\n        this._maxWidth = maxWidth;\n        this._maxLineHeight = 0;\n        this._letterSpacing = letterSpacing;\n        this._anchor = new ObservablePoint((): void => { this.dirty = true; }, this, 0, 0);\n        this._roundPixels = settings.ROUND_PIXELS;\n        this.dirty = true;\n        this._resolution = settings.RESOLUTION;\n        this._autoResolution = true;\n        this._textureCache = {};\n    }\n\n    /** Renders text and updates it when needed. This should only be called if the BitmapFont is regenerated. */\n    public updateText(): void\n    {\n        const data = BitmapFont.available[this._fontName];\n        const fontSize = this.fontSize;\n        const scale = fontSize / data.size;\n        const pos = new Point();\n        const chars: CharRenderData[] = [];\n        const lineWidths = [];\n        const lineSpaces = [];\n        const text = this._text.replace(/(?:\\r\\n|\\r)/g, '\\n') || ' ';\n        const charsInput = splitTextToCharacters(text);\n        const maxWidth = this._maxWidth * data.size / fontSize;\n        const pageMeshDataPool = data.distanceFieldType === 'none'\n            ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n\n        let prevCharCode = null;\n        let lastLineWidth = 0;\n        let maxLineWidth = 0;\n        let line = 0;\n        let lastBreakPos = -1;\n        let lastBreakWidth = 0;\n        let spacesRemoved = 0;\n        let maxLineHeight = 0;\n        let spaceCount = 0;\n\n        for (let i = 0; i < charsInput.length; i++)\n        {\n            const char = charsInput[i];\n            const charCode = extractCharCode(char);\n\n            if ((/(?:\\s)/).test(char))\n            {\n                lastBreakPos = i;\n                lastBreakWidth = lastLineWidth;\n                spaceCount++;\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                lineWidths.push(lastLineWidth);\n                lineSpaces.push(-1);\n                maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n                ++line;\n                ++spacesRemoved;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n                spaceCount = 0;\n                continue;\n            }\n\n            const charData = data.chars[charCode];\n\n            if (!charData)\n            {\n                continue;\n            }\n\n            if (prevCharCode && charData.kerning[prevCharCode])\n            {\n                pos.x += charData.kerning[prevCharCode];\n            }\n\n            const charRenderData: CharRenderData = charRenderDataPool.pop() || {\n                texture: Texture.EMPTY,\n                line: 0,\n                charCode: 0,\n                prevSpaces: 0,\n                position: new Point(),\n            };\n\n            charRenderData.texture = charData.texture;\n            charRenderData.line = line;\n            charRenderData.charCode = charCode;\n            charRenderData.position.x = Math.round(pos.x + charData.xOffset + (this._letterSpacing / 2));\n            charRenderData.position.y = Math.round(pos.y + charData.yOffset);\n            charRenderData.prevSpaces = spaceCount;\n\n            chars.push(charRenderData);\n\n            lastLineWidth = charRenderData.position.x\n                + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);\n            pos.x += charData.xAdvance + this._letterSpacing;\n            maxLineHeight = Math.max(maxLineHeight, (charData.yOffset + charData.texture.height));\n            prevCharCode = charCode;\n\n            if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth)\n            {\n                ++spacesRemoved;\n                utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);\n                i = lastBreakPos;\n                lastBreakPos = -1;\n\n                lineWidths.push(lastBreakWidth);\n                lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);\n                maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);\n                line++;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n                spaceCount = 0;\n            }\n        }\n\n        const lastChar = charsInput[charsInput.length - 1];\n\n        if (lastChar !== '\\r' && lastChar !== '\\n')\n        {\n            if ((/(?:\\s)/).test(lastChar))\n            {\n                lastLineWidth = lastBreakWidth;\n            }\n\n            lineWidths.push(lastLineWidth);\n            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n            lineSpaces.push(-1);\n        }\n\n        const lineAlignOffsets = [];\n\n        for (let i = 0; i <= line; i++)\n        {\n            let alignOffset = 0;\n\n            if (this._align === 'right')\n            {\n                alignOffset = maxLineWidth - lineWidths[i];\n            }\n            else if (this._align === 'center')\n            {\n                alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n            }\n            else if (this._align === 'justify')\n            {\n                alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];\n            }\n\n            lineAlignOffsets.push(alignOffset);\n        }\n\n        const lenChars = chars.length;\n\n        const pagesMeshData: Record<number, PageMeshData> = {};\n\n        const newPagesMeshData: PageMeshData[] = [];\n\n        const activePagesMeshData = this._activePagesMeshData;\n\n        pageMeshDataPool.push(...activePagesMeshData);\n\n        for (let i = 0; i < lenChars; i++)\n        {\n            const texture = chars[i].texture;\n            const baseTextureUid = texture.baseTexture.uid;\n\n            if (!pagesMeshData[baseTextureUid])\n            {\n                let pageMeshData = pageMeshDataPool.pop();\n\n                if (!pageMeshData)\n                {\n                    const geometry = new MeshGeometry();\n                    let material: MeshMaterial;\n                    let meshBlendMode: BLEND_MODES;\n\n                    if (data.distanceFieldType === 'none')\n                    {\n                        material = new MeshMaterial(Texture.EMPTY);\n                        meshBlendMode = BLEND_MODES.NORMAL;\n                    }\n                    else\n                    {\n                        material = new MeshMaterial(Texture.EMPTY,\n                            { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });\n                        meshBlendMode = BLEND_MODES.NORMAL_NPM;\n                    }\n\n                    const mesh = new Mesh(geometry, material);\n\n                    mesh.blendMode = meshBlendMode;\n\n                    pageMeshData = {\n                        index: 0,\n                        indexCount: 0,\n                        vertexCount: 0,\n                        uvsCount: 0,\n                        total: 0,\n                        mesh,\n                        vertices: null,\n                        uvs: null,\n                        indices: null,\n                    };\n                }\n\n                // reset data..\n                pageMeshData.index = 0;\n                pageMeshData.indexCount = 0;\n                pageMeshData.vertexCount = 0;\n                pageMeshData.uvsCount = 0;\n                pageMeshData.total = 0;\n\n                // TODO need to get page texture here somehow..\n                const { _textureCache } = this;\n\n                _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);\n                pageMeshData.mesh.texture = _textureCache[baseTextureUid];\n\n                pageMeshData.mesh.tint = this._tintColor.value;\n\n                newPagesMeshData.push(pageMeshData);\n\n                pagesMeshData[baseTextureUid] = pageMeshData;\n            }\n\n            pagesMeshData[baseTextureUid].total++;\n        }\n\n        // lets find any previously active pageMeshDatas that are no longer required for\n        // the updated text (if any), removed and return them to the pool.\n        for (let i = 0; i < activePagesMeshData.length; i++)\n        {\n            if (!newPagesMeshData.includes(activePagesMeshData[i]))\n            {\n                this.removeChild(activePagesMeshData[i].mesh);\n            }\n        }\n\n        // next lets add any new meshes, that have not yet been added to this BitmapText\n        // we only add if its not already a child of this BitmapObject\n        for (let i = 0; i < newPagesMeshData.length; i++)\n        {\n            if (newPagesMeshData[i].mesh.parent !== this)\n            {\n                this.addChild(newPagesMeshData[i].mesh);\n            }\n        }\n\n        // active page mesh datas are set to be the new pages added.\n        this._activePagesMeshData = newPagesMeshData;\n\n        for (const i in pagesMeshData)\n        {\n            const pageMeshData = pagesMeshData[i];\n            const total = pageMeshData.total;\n\n            // lets only allocate new buffers if we can fit the new text in the current ones..\n            // unless that is, we will be batching. Currently batching dose not respect the size property of mesh\n            if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2)\n            {\n                pageMeshData.vertices = new Float32Array(4 * 2 * total);\n                pageMeshData.uvs = new Float32Array(4 * 2 * total);\n                pageMeshData.indices = new Uint16Array(6 * total);\n            }\n            else\n            {\n                const total = pageMeshData.total;\n                const vertices = pageMeshData.vertices;\n\n                // Clear the garbage at the end of the vertices buffer. This will prevent the bounds miscalculation.\n                for (let i = total * 4 * 2; i < vertices.length; i++)\n                {\n                    vertices[i] = 0;\n                }\n            }\n\n            // as a buffer maybe bigger than the current word, we set the size of the meshMaterial\n            // to match the number of letters needed\n            pageMeshData.mesh.size = 6 * total;\n        }\n\n        for (let i = 0; i < lenChars; i++)\n        {\n            const char = chars[i];\n            let offset = char.position.x + (lineAlignOffsets[char.line] * (this._align === 'justify' ? char.prevSpaces : 1));\n\n            if (this._roundPixels)\n            {\n                offset = Math.round(offset);\n            }\n\n            const xPos = offset * scale;\n            const yPos = char.position.y * scale;\n            const texture = char.texture;\n\n            const pageMesh = pagesMeshData[texture.baseTexture.uid];\n\n            const textureFrame = texture.frame;\n            const textureUvs = texture._uvs;\n\n            const index = pageMesh.index++;\n\n            pageMesh.indices[(index * 6) + 0] = 0 + (index * 4);\n            pageMesh.indices[(index * 6) + 1] = 1 + (index * 4);\n            pageMesh.indices[(index * 6) + 2] = 2 + (index * 4);\n            pageMesh.indices[(index * 6) + 3] = 0 + (index * 4);\n            pageMesh.indices[(index * 6) + 4] = 2 + (index * 4);\n            pageMesh.indices[(index * 6) + 5] = 3 + (index * 4);\n\n            pageMesh.vertices[(index * 8) + 0] = xPos;\n            pageMesh.vertices[(index * 8) + 1] = yPos;\n\n            pageMesh.vertices[(index * 8) + 2] = xPos + (textureFrame.width * scale);\n            pageMesh.vertices[(index * 8) + 3] = yPos;\n\n            pageMesh.vertices[(index * 8) + 4] = xPos + (textureFrame.width * scale);\n            pageMesh.vertices[(index * 8) + 5] = yPos + (textureFrame.height * scale);\n\n            pageMesh.vertices[(index * 8) + 6] = xPos;\n            pageMesh.vertices[(index * 8) + 7] = yPos + (textureFrame.height * scale);\n\n            pageMesh.uvs[(index * 8) + 0] = textureUvs.x0;\n            pageMesh.uvs[(index * 8) + 1] = textureUvs.y0;\n\n            pageMesh.uvs[(index * 8) + 2] = textureUvs.x1;\n            pageMesh.uvs[(index * 8) + 3] = textureUvs.y1;\n\n            pageMesh.uvs[(index * 8) + 4] = textureUvs.x2;\n            pageMesh.uvs[(index * 8) + 5] = textureUvs.y2;\n\n            pageMesh.uvs[(index * 8) + 6] = textureUvs.x3;\n            pageMesh.uvs[(index * 8) + 7] = textureUvs.y3;\n        }\n\n        this._textWidth = maxLineWidth * scale;\n        this._textHeight = (pos.y + data.lineHeight) * scale;\n\n        for (const i in pagesMeshData)\n        {\n            const pageMeshData = pagesMeshData[i];\n\n            // apply anchor\n            if (this.anchor.x !== 0 || this.anchor.y !== 0)\n            {\n                let vertexCount = 0;\n\n                const anchorOffsetX = this._textWidth * this.anchor.x;\n                const anchorOffsetY = this._textHeight * this.anchor.y;\n\n                for (let i = 0; i < pageMeshData.total; i++)\n                {\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n                }\n            }\n\n            this._maxLineHeight = maxLineHeight * scale;\n\n            const vertexBuffer = pageMeshData.mesh.geometry.getBuffer('aVertexPosition');\n            const textureBuffer = pageMeshData.mesh.geometry.getBuffer('aTextureCoord');\n            const indexBuffer = pageMeshData.mesh.geometry.getIndex();\n\n            vertexBuffer.data = pageMeshData.vertices;\n            textureBuffer.data = pageMeshData.uvs;\n            indexBuffer.data = pageMeshData.indices;\n\n            vertexBuffer.update();\n            textureBuffer.update();\n            indexBuffer.update();\n        }\n\n        for (let i = 0; i < chars.length; i++)\n        {\n            charRenderDataPool.push(chars[i]);\n        }\n\n        this._font = data;\n        this.dirty = false;\n    }\n\n    updateTransform(): void\n    {\n        this.validate();\n        this.containerUpdateTransform();\n    }\n\n    _render(renderer: Renderer): void\n    {\n        if (this._autoResolution && this._resolution !== renderer.resolution)\n        {\n            this._resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        // Update the uniform\n        const { distanceFieldRange, distanceFieldType, size } = BitmapFont.available[this._fontName];\n\n        if (distanceFieldType !== 'none')\n        {\n            // Inject the shader code with the correct value\n            const { a, b, c, d } = this.worldTransform;\n\n            const dx = Math.sqrt((a * a) + (b * b));\n            const dy = Math.sqrt((c * c) + (d * d));\n            const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n            const fontScale = this.fontSize / size;\n\n            const resolution = renderer._view.resolution;\n\n            for (const mesh of this._activePagesMeshData)\n            {\n                mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;\n            }\n        }\n\n        super._render(renderer);\n    }\n\n    /**\n     * Validates text before calling parent's getLocalBounds\n     * @returns - The rectangular bounding area\n     */\n    public getLocalBounds(): Rectangle\n    {\n        this.validate();\n\n        return super.getLocalBounds();\n    }\n\n    /**\n     * Updates text when needed\n     * @private\n     */\n    protected validate(): void\n    {\n        const font = BitmapFont.available[this._fontName];\n\n        if (!font)\n        {\n            throw new Error(`Missing BitmapFont \"${this._fontName}\"`);\n        }\n        if (this._font !== font)\n        {\n            this.dirty = true;\n        }\n\n        if (this.dirty)\n        {\n            this.updateText();\n        }\n    }\n\n    /**\n     * The tint of the BitmapText object.\n     * @default 0xffffff\n     */\n    public get tint(): ColorSource\n    {\n        return this._tintColor.value;\n    }\n\n    public set tint(value: ColorSource)\n    {\n        if (this.tint === value) return;\n\n        this._tintColor.setValue(value);\n\n        for (let i = 0; i < this._activePagesMeshData.length; i++)\n        {\n            this._activePagesMeshData[i].mesh.tint = value;\n        }\n    }\n\n    /**\n     * The alignment of the BitmapText object.\n     * @member {string}\n     * @default 'left'\n     */\n    public get align(): TextStyleAlign\n    {\n        return this._align;\n    }\n\n    public set align(value: TextStyleAlign)\n    {\n        if (this._align !== value)\n        {\n            this._align = value;\n            this.dirty = true;\n        }\n    }\n\n    /** The name of the BitmapFont. */\n    public get fontName(): string\n    {\n        return this._fontName;\n    }\n\n    public set fontName(value: string)\n    {\n        if (!BitmapFont.available[value])\n        {\n            throw new Error(`Missing BitmapFont \"${value}\"`);\n        }\n\n        if (this._fontName !== value)\n        {\n            this._fontName = value;\n            this.dirty = true;\n        }\n    }\n\n    /** The size of the font to display. */\n    public get fontSize(): number\n    {\n        return this._fontSize ?? BitmapFont.available[this._fontName].size;\n    }\n\n    public set fontSize(value: number | undefined)\n    {\n        if (this._fontSize !== value)\n        {\n            this._fontSize = value;\n            this.dirty = true;\n        }\n    }\n\n    /**\n     * The anchor sets the origin point of the text.\n     *\n     * The default is `(0,0)`, this means the text's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n     */\n    public get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    public set anchor(value: ObservablePoint)\n    {\n        if (typeof value === 'number')\n        {\n            this._anchor.set(value);\n        }\n        else\n        {\n            this._anchor.copyFrom(value);\n        }\n    }\n\n    /** The text of the BitmapText object. */\n    public get text(): string\n    {\n        return this._text;\n    }\n\n    public set text(text: string)\n    {\n        text = String(text === null || text === undefined ? '' : text);\n\n        if (this._text === text)\n        {\n            return;\n        }\n        this._text = text;\n        this.dirty = true;\n    }\n\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting the value to 0.\n     */\n    public get maxWidth(): number\n    {\n        return this._maxWidth;\n    }\n\n    public set maxWidth(value: number)\n    {\n        if (this._maxWidth === value)\n        {\n            return;\n        }\n        this._maxWidth = value;\n        this.dirty = true;\n    }\n\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * i.e. when trying to vertically align.\n     * @readonly\n     */\n    public get maxLineHeight(): number\n    {\n        this.validate();\n\n        return this._maxLineHeight;\n    }\n\n    /**\n     * The width of the overall text, different from fontSize,\n     * which is defined in the style object.\n     * @readonly\n     */\n    public get textWidth(): number\n    {\n        this.validate();\n\n        return this._textWidth;\n    }\n\n    /** Additional space between characters. */\n    public get letterSpacing(): number\n    {\n        return this._letterSpacing;\n    }\n\n    public set letterSpacing(value: number)\n    {\n        if (this._letterSpacing !== value)\n        {\n            this._letterSpacing = value;\n            this.dirty = true;\n        }\n    }\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n     * @default PIXI.settings.ROUND_PIXELS\n     */\n    public get roundPixels(): boolean\n    {\n        return this._roundPixels;\n    }\n\n    public set roundPixels(value: boolean)\n    {\n        if (value !== this._roundPixels)\n        {\n            this._roundPixels = value;\n            this.dirty = true;\n        }\n    }\n\n    /**\n     * The height of the overall text, different from fontSize,\n     * which is defined in the style object.\n     * @readonly\n     */\n    public get textHeight(): number\n    {\n        this.validate();\n\n        return this._textHeight;\n    }\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default 1\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this._autoResolution = false;\n\n        if (this._resolution === value)\n        {\n            return;\n        }\n\n        this._resolution = value;\n        this.dirty = true;\n    }\n\n    destroy(options?: boolean | IDestroyOptions): void\n    {\n        const { _textureCache } = this;\n        const data = BitmapFont.available[this._fontName];\n        const pageMeshDataPool = data.distanceFieldType === 'none'\n            ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n\n        pageMeshDataPool.push(...this._activePagesMeshData);\n        for (const pageMeshData of this._activePagesMeshData)\n        {\n            this.removeChild(pageMeshData.mesh);\n        }\n        this._activePagesMeshData = [];\n\n        // Release references to any cached textures in page pool\n        pageMeshDataPool\n            .filter((page) => _textureCache[page.mesh.texture.baseTexture.uid])\n            .forEach((page) =>\n            {\n                page.mesh.texture = Texture.EMPTY;\n            });\n\n        for (const id in _textureCache)\n        {\n            const texture = _textureCache[id];\n\n            texture.destroy();\n            delete _textureCache[id];\n        }\n\n        this._font = null;\n        this._tintColor = null;\n        this._textureCache = null;\n\n        super.destroy(options);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}