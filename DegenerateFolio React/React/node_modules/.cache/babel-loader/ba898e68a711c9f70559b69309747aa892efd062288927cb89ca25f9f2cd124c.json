{"ast":null,"code":"import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { firstMemo, memo } from '../util/index.js';\nfunction rewardDestinationCompat(rewardDestination) {\n  // We ensure the type is an Option by checking if isSome is a boolean. When isSome doesn't exist it will always return undefined.\n  return typeof rewardDestination.isSome === 'boolean' ? rewardDestination.unwrapOr(null) : rewardDestination;\n}\nfunction parseDetails(stashId, controllerIdOpt, nominatorsOpt, rewardDestinationOpts, validatorPrefs, exposure, stakingLedgerOpt) {\n  return {\n    accountId: stashId,\n    controllerId: controllerIdOpt?.unwrapOr(null) || null,\n    exposure,\n    nominators: nominatorsOpt.isSome ? nominatorsOpt.unwrap().targets : [],\n    rewardDestination: rewardDestinationCompat(rewardDestinationOpts),\n    stakingLedger: stakingLedgerOpt.unwrapOrDefault(),\n    stashId,\n    validatorPrefs\n  };\n}\nfunction getLedgers(api, optIds, {\n  withLedger = false\n}) {\n  const ids = optIds.filter(o => withLedger && !!o && o.isSome).map(o => o.unwrap());\n  const emptyLed = api.registry.createType('Option<StakingLedger>');\n  return (ids.length ? combineLatest(ids.map(s => api.query.staking.ledger(s))) : of([])).pipe(map(optLedgers => {\n    let offset = -1;\n    return optIds.map(o => o && o.isSome ? optLedgers[++offset] || emptyLed : emptyLed);\n  }));\n}\nfunction getStashInfo(api, stashIds, activeEra, {\n  withController,\n  withDestination,\n  withExposure,\n  withLedger,\n  withNominations,\n  withPrefs\n}) {\n  const emptyNoms = api.registry.createType('Option<Nominations>');\n  const emptyRewa = api.registry.createType('RewardDestination');\n  const emptyExpo = api.registry.createType('Exposure');\n  const emptyPrefs = api.registry.createType('ValidatorPrefs');\n  return combineLatest([withController || withLedger ? combineLatest(stashIds.map(s => api.query.staking.bonded(s))) : of(stashIds.map(() => null)), withNominations ? combineLatest(stashIds.map(s => api.query.staking.nominators(s))) : of(stashIds.map(() => emptyNoms)), withDestination ? combineLatest(stashIds.map(s => api.query.staking.payee(s))) : of(stashIds.map(() => emptyRewa)), withPrefs ? combineLatest(stashIds.map(s => api.query.staking.validators(s))) : of(stashIds.map(() => emptyPrefs)), withExposure ? combineLatest(stashIds.map(s => api.query.staking.erasStakers(activeEra, s))) : of(stashIds.map(() => emptyExpo))]);\n}\nfunction getBatch(api, activeEra, stashIds, flags) {\n  return getStashInfo(api, stashIds, activeEra, flags).pipe(switchMap(([controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure]) => getLedgers(api, controllerIdOpt, flags).pipe(map(stakingLedgerOpts => stashIds.map((stashId, index) => parseDetails(stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index]))))));\n}\n/**\n * @description From a stash, retrieve the controllerId and all relevant details\n */\nexport const query = /*#__PURE__*/firstMemo((api, accountId, flags) => api.derive.staking.queryMulti([accountId], flags));\nexport function queryMulti(instanceId, api) {\n  return memo(instanceId, (accountIds, flags) => api.derive.session.indexes().pipe(switchMap(({\n    activeEra\n  }) => {\n    const stashIds = accountIds.map(a => api.registry.createType('AccountId', a));\n    return stashIds.length ? getBatch(api, activeEra, stashIds, flags) : of([]);\n  })));\n}","map":{"version":3,"names":["combineLatest","map","of","switchMap","firstMemo","memo","rewardDestinationCompat","rewardDestination","isSome","unwrapOr","parseDetails","stashId","controllerIdOpt","nominatorsOpt","rewardDestinationOpts","validatorPrefs","exposure","stakingLedgerOpt","accountId","controllerId","nominators","unwrap","targets","stakingLedger","unwrapOrDefault","getLedgers","api","optIds","withLedger","ids","filter","o","emptyLed","registry","createType","length","s","query","staking","ledger","pipe","optLedgers","offset","getStashInfo","stashIds","activeEra","withController","withDestination","withExposure","withNominations","withPrefs","emptyNoms","emptyRewa","emptyExpo","emptyPrefs","bonded","payee","validators","erasStakers","getBatch","flags","stakingLedgerOpts","index","derive","queryMulti","instanceId","accountIds","session","indexes","a"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api-derive/staking/query.js"],"sourcesContent":["import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { firstMemo, memo } from '../util/index.js';\nfunction rewardDestinationCompat(rewardDestination) {\n    // We ensure the type is an Option by checking if isSome is a boolean. When isSome doesn't exist it will always return undefined.\n    return typeof rewardDestination.isSome === 'boolean'\n        ? rewardDestination.unwrapOr(null)\n        : rewardDestination;\n}\nfunction parseDetails(stashId, controllerIdOpt, nominatorsOpt, rewardDestinationOpts, validatorPrefs, exposure, stakingLedgerOpt) {\n    return {\n        accountId: stashId,\n        controllerId: controllerIdOpt?.unwrapOr(null) || null,\n        exposure,\n        nominators: nominatorsOpt.isSome\n            ? nominatorsOpt.unwrap().targets\n            : [],\n        rewardDestination: rewardDestinationCompat(rewardDestinationOpts),\n        stakingLedger: stakingLedgerOpt.unwrapOrDefault(),\n        stashId,\n        validatorPrefs\n    };\n}\nfunction getLedgers(api, optIds, { withLedger = false }) {\n    const ids = optIds\n        .filter((o) => withLedger && !!o && o.isSome)\n        .map((o) => o.unwrap());\n    const emptyLed = api.registry.createType('Option<StakingLedger>');\n    return (ids.length\n        ? combineLatest(ids.map((s) => api.query.staking.ledger(s)))\n        : of([])).pipe(map((optLedgers) => {\n        let offset = -1;\n        return optIds.map((o) => o && o.isSome\n            ? optLedgers[++offset] || emptyLed\n            : emptyLed);\n    }));\n}\nfunction getStashInfo(api, stashIds, activeEra, { withController, withDestination, withExposure, withLedger, withNominations, withPrefs }) {\n    const emptyNoms = api.registry.createType('Option<Nominations>');\n    const emptyRewa = api.registry.createType('RewardDestination');\n    const emptyExpo = api.registry.createType('Exposure');\n    const emptyPrefs = api.registry.createType('ValidatorPrefs');\n    return combineLatest([\n        withController || withLedger\n            ? combineLatest(stashIds.map((s) => api.query.staking.bonded(s)))\n            : of(stashIds.map(() => null)),\n        withNominations\n            ? combineLatest(stashIds.map((s) => api.query.staking.nominators(s)))\n            : of(stashIds.map(() => emptyNoms)),\n        withDestination\n            ? combineLatest(stashIds.map((s) => api.query.staking.payee(s)))\n            : of(stashIds.map(() => emptyRewa)),\n        withPrefs\n            ? combineLatest(stashIds.map((s) => api.query.staking.validators(s)))\n            : of(stashIds.map(() => emptyPrefs)),\n        withExposure\n            ? combineLatest(stashIds.map((s) => api.query.staking.erasStakers(activeEra, s)))\n            : of(stashIds.map(() => emptyExpo))\n    ]);\n}\nfunction getBatch(api, activeEra, stashIds, flags) {\n    return getStashInfo(api, stashIds, activeEra, flags).pipe(switchMap(([controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure]) => getLedgers(api, controllerIdOpt, flags).pipe(map((stakingLedgerOpts) => stashIds.map((stashId, index) => parseDetails(stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index]))))));\n}\n/**\n * @description From a stash, retrieve the controllerId and all relevant details\n */\nexport const query = /*#__PURE__*/ firstMemo((api, accountId, flags) => api.derive.staking.queryMulti([accountId], flags));\nexport function queryMulti(instanceId, api) {\n    return memo(instanceId, (accountIds, flags) => api.derive.session.indexes().pipe(switchMap(({ activeEra }) => {\n        const stashIds = accountIds.map((a) => api.registry.createType('AccountId', a));\n        return stashIds.length\n            ? getBatch(api, activeEra, stashIds, flags)\n            : of([]);\n    })));\n}\n"],"mappings":"AAAA,SAASA,aAAa,EAAEC,GAAG,EAAEC,EAAE,EAAEC,SAAS,QAAQ,MAAM;AACxD,SAASC,SAAS,EAAEC,IAAI,QAAQ,kBAAkB;AAClD,SAASC,uBAAuBA,CAACC,iBAAiB,EAAE;EAChD;EACA,OAAO,OAAOA,iBAAiB,CAACC,MAAM,KAAK,SAAS,GAC9CD,iBAAiB,CAACE,QAAQ,CAAC,IAAI,CAAC,GAChCF,iBAAiB;AAC3B;AACA,SAASG,YAAYA,CAACC,OAAO,EAAEC,eAAe,EAAEC,aAAa,EAAEC,qBAAqB,EAAEC,cAAc,EAAEC,QAAQ,EAAEC,gBAAgB,EAAE;EAC9H,OAAO;IACHC,SAAS,EAAEP,OAAO;IAClBQ,YAAY,EAAEP,eAAe,EAAEH,QAAQ,CAAC,IAAI,CAAC,IAAI,IAAI;IACrDO,QAAQ;IACRI,UAAU,EAAEP,aAAa,CAACL,MAAM,GAC1BK,aAAa,CAACQ,MAAM,CAAC,CAAC,CAACC,OAAO,GAC9B,EAAE;IACRf,iBAAiB,EAAED,uBAAuB,CAACQ,qBAAqB,CAAC;IACjES,aAAa,EAAEN,gBAAgB,CAACO,eAAe,CAAC,CAAC;IACjDb,OAAO;IACPI;EACJ,CAAC;AACL;AACA,SAASU,UAAUA,CAACC,GAAG,EAAEC,MAAM,EAAE;EAAEC,UAAU,GAAG;AAAM,CAAC,EAAE;EACrD,MAAMC,GAAG,GAAGF,MAAM,CACbG,MAAM,CAAEC,CAAC,IAAKH,UAAU,IAAI,CAAC,CAACG,CAAC,IAAIA,CAAC,CAACvB,MAAM,CAAC,CAC5CP,GAAG,CAAE8B,CAAC,IAAKA,CAAC,CAACV,MAAM,CAAC,CAAC,CAAC;EAC3B,MAAMW,QAAQ,GAAGN,GAAG,CAACO,QAAQ,CAACC,UAAU,CAAC,uBAAuB,CAAC;EACjE,OAAO,CAACL,GAAG,CAACM,MAAM,GACZnC,aAAa,CAAC6B,GAAG,CAAC5B,GAAG,CAAEmC,CAAC,IAAKV,GAAG,CAACW,KAAK,CAACC,OAAO,CAACC,MAAM,CAACH,CAAC,CAAC,CAAC,CAAC,GAC1DlC,EAAE,CAAC,EAAE,CAAC,EAAEsC,IAAI,CAACvC,GAAG,CAAEwC,UAAU,IAAK;IACnC,IAAIC,MAAM,GAAG,CAAC,CAAC;IACf,OAAOf,MAAM,CAAC1B,GAAG,CAAE8B,CAAC,IAAKA,CAAC,IAAIA,CAAC,CAACvB,MAAM,GAChCiC,UAAU,CAAC,EAAEC,MAAM,CAAC,IAAIV,QAAQ,GAChCA,QAAQ,CAAC;EACnB,CAAC,CAAC,CAAC;AACP;AACA,SAASW,YAAYA,CAACjB,GAAG,EAAEkB,QAAQ,EAAEC,SAAS,EAAE;EAAEC,cAAc;EAAEC,eAAe;EAAEC,YAAY;EAAEpB,UAAU;EAAEqB,eAAe;EAAEC;AAAU,CAAC,EAAE;EACvI,MAAMC,SAAS,GAAGzB,GAAG,CAACO,QAAQ,CAACC,UAAU,CAAC,qBAAqB,CAAC;EAChE,MAAMkB,SAAS,GAAG1B,GAAG,CAACO,QAAQ,CAACC,UAAU,CAAC,mBAAmB,CAAC;EAC9D,MAAMmB,SAAS,GAAG3B,GAAG,CAACO,QAAQ,CAACC,UAAU,CAAC,UAAU,CAAC;EACrD,MAAMoB,UAAU,GAAG5B,GAAG,CAACO,QAAQ,CAACC,UAAU,CAAC,gBAAgB,CAAC;EAC5D,OAAOlC,aAAa,CAAC,CACjB8C,cAAc,IAAIlB,UAAU,GACtB5B,aAAa,CAAC4C,QAAQ,CAAC3C,GAAG,CAAEmC,CAAC,IAAKV,GAAG,CAACW,KAAK,CAACC,OAAO,CAACiB,MAAM,CAACnB,CAAC,CAAC,CAAC,CAAC,GAC/DlC,EAAE,CAAC0C,QAAQ,CAAC3C,GAAG,CAAC,MAAM,IAAI,CAAC,CAAC,EAClCgD,eAAe,GACTjD,aAAa,CAAC4C,QAAQ,CAAC3C,GAAG,CAAEmC,CAAC,IAAKV,GAAG,CAACW,KAAK,CAACC,OAAO,CAAClB,UAAU,CAACgB,CAAC,CAAC,CAAC,CAAC,GACnElC,EAAE,CAAC0C,QAAQ,CAAC3C,GAAG,CAAC,MAAMkD,SAAS,CAAC,CAAC,EACvCJ,eAAe,GACT/C,aAAa,CAAC4C,QAAQ,CAAC3C,GAAG,CAAEmC,CAAC,IAAKV,GAAG,CAACW,KAAK,CAACC,OAAO,CAACkB,KAAK,CAACpB,CAAC,CAAC,CAAC,CAAC,GAC9DlC,EAAE,CAAC0C,QAAQ,CAAC3C,GAAG,CAAC,MAAMmD,SAAS,CAAC,CAAC,EACvCF,SAAS,GACHlD,aAAa,CAAC4C,QAAQ,CAAC3C,GAAG,CAAEmC,CAAC,IAAKV,GAAG,CAACW,KAAK,CAACC,OAAO,CAACmB,UAAU,CAACrB,CAAC,CAAC,CAAC,CAAC,GACnElC,EAAE,CAAC0C,QAAQ,CAAC3C,GAAG,CAAC,MAAMqD,UAAU,CAAC,CAAC,EACxCN,YAAY,GACNhD,aAAa,CAAC4C,QAAQ,CAAC3C,GAAG,CAAEmC,CAAC,IAAKV,GAAG,CAACW,KAAK,CAACC,OAAO,CAACoB,WAAW,CAACb,SAAS,EAAET,CAAC,CAAC,CAAC,CAAC,GAC/ElC,EAAE,CAAC0C,QAAQ,CAAC3C,GAAG,CAAC,MAAMoD,SAAS,CAAC,CAAC,CAC1C,CAAC;AACN;AACA,SAASM,QAAQA,CAACjC,GAAG,EAAEmB,SAAS,EAAED,QAAQ,EAAEgB,KAAK,EAAE;EAC/C,OAAOjB,YAAY,CAACjB,GAAG,EAAEkB,QAAQ,EAAEC,SAAS,EAAEe,KAAK,CAAC,CAACpB,IAAI,CAACrC,SAAS,CAAC,CAAC,CAACS,eAAe,EAAEC,aAAa,EAAEN,iBAAiB,EAAEQ,cAAc,EAAEC,QAAQ,CAAC,KAAKS,UAAU,CAACC,GAAG,EAAEd,eAAe,EAAEgD,KAAK,CAAC,CAACpB,IAAI,CAACvC,GAAG,CAAE4D,iBAAiB,IAAKjB,QAAQ,CAAC3C,GAAG,CAAC,CAACU,OAAO,EAAEmD,KAAK,KAAKpD,YAAY,CAACC,OAAO,EAAEC,eAAe,CAACkD,KAAK,CAAC,EAAEjD,aAAa,CAACiD,KAAK,CAAC,EAAEvD,iBAAiB,CAACuD,KAAK,CAAC,EAAE/C,cAAc,CAAC+C,KAAK,CAAC,EAAE9C,QAAQ,CAAC8C,KAAK,CAAC,EAAED,iBAAiB,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxa;AACA;AACA;AACA;AACA,OAAO,MAAMzB,KAAK,GAAG,aAAcjC,SAAS,CAAC,CAACsB,GAAG,EAAER,SAAS,EAAE0C,KAAK,KAAKlC,GAAG,CAACqC,MAAM,CAACzB,OAAO,CAAC0B,UAAU,CAAC,CAAC9C,SAAS,CAAC,EAAE0C,KAAK,CAAC,CAAC;AAC1H,OAAO,SAASI,UAAUA,CAACC,UAAU,EAAEvC,GAAG,EAAE;EACxC,OAAOrB,IAAI,CAAC4D,UAAU,EAAE,CAACC,UAAU,EAAEN,KAAK,KAAKlC,GAAG,CAACqC,MAAM,CAACI,OAAO,CAACC,OAAO,CAAC,CAAC,CAAC5B,IAAI,CAACrC,SAAS,CAAC,CAAC;IAAE0C;EAAU,CAAC,KAAK;IAC1G,MAAMD,QAAQ,GAAGsB,UAAU,CAACjE,GAAG,CAAEoE,CAAC,IAAK3C,GAAG,CAACO,QAAQ,CAACC,UAAU,CAAC,WAAW,EAAEmC,CAAC,CAAC,CAAC;IAC/E,OAAOzB,QAAQ,CAACT,MAAM,GAChBwB,QAAQ,CAACjC,GAAG,EAAEmB,SAAS,EAAED,QAAQ,EAAEgB,KAAK,CAAC,GACzC1D,EAAE,CAAC,EAAE,CAAC;EAChB,CAAC,CAAC,CAAC,CAAC;AACR","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}