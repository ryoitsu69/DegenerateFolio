{"ast":null,"code":"import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { GraphicsContext } from '../../../../scene/graphics/shared/GraphicsContext.mjs';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl.mjs';\nimport { checkDataUrl } from '../../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../../utils/checkExtension.mjs';\nimport { LoaderParserPriority } from '../LoaderParser.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\n\"use strict\";\nconst validSVGExtension = \".svg\";\nconst validSVGMIME = \"image/svg+xml\";\nconst loadSvg = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low\n  },\n  name: \"loadSVG\",\n  config: {\n    crossOrigin: \"anonymous\",\n    parseAsGraphicsContext: false\n  },\n  test(url) {\n    return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n  },\n  async load(url, asset, loader) {\n    if (asset.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext) {\n      return loadAsGraphics(url);\n    }\n    return loadAsTexture(url, asset, loader, this.config.crossOrigin);\n  },\n  unload(asset) {\n    asset.destroy(true);\n  }\n};\nasync function loadAsTexture(url, asset, loader, crossOrigin) {\n  const response = await DOMAdapter.get().fetch(url);\n  const blob = await response.blob();\n  const blobUrl = URL.createObjectURL(blob);\n  const image = new Image();\n  image.src = blobUrl;\n  image.crossOrigin = crossOrigin;\n  await image.decode();\n  URL.revokeObjectURL(blobUrl);\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  const resolution = asset.data?.resolution || getResolutionOfUrl(url);\n  const width = asset.data?.width ?? image.width;\n  const height = asset.data?.height ?? image.height;\n  canvas.width = width * resolution;\n  canvas.height = height * resolution;\n  context.drawImage(image, 0, 0, width * resolution, height * resolution);\n  const {\n    parseAsGraphicsContext: _p,\n    ...rest\n  } = asset.data;\n  const base = new ImageSource({\n    resource: canvas,\n    alphaMode: \"premultiply-alpha-on-upload\",\n    resolution,\n    ...rest\n  });\n  return createTexture(base, loader, url);\n}\nasync function loadAsGraphics(url) {\n  const response = await DOMAdapter.get().fetch(url);\n  const svgSource = await response.text();\n  const context = new GraphicsContext();\n  context.svg(svgSource);\n  return context;\n}\nexport { loadSvg };","map":{"version":3,"names":["validSVGExtension","validSVGMIME","loadSvg","extension","type","ExtensionType","LoadParser","priority","LoaderParserPriority","Low","name","config","crossOrigin","parseAsGraphicsContext","test","url","checkDataUrl","checkExtension","load","asset","loader","data","loadAsGraphics","loadAsTexture","unload","destroy","response","DOMAdapter","get","fetch","blob","blobUrl","URL","createObjectURL","image","Image","src","decode","revokeObjectURL","canvas","document","createElement","context","getContext","resolution","getResolutionOfUrl","width","height","drawImage","_p","rest","base","ImageSource","resource","alphaMode","createTexture","svgSource","text","GraphicsContext","svg"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/assets/loader/parsers/textures/loadSVG.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { GraphicsContext } from '../../../../scene/graphics/shared/GraphicsContext';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { type LoaderParser, LoaderParserPriority } from '../LoaderParser';\nimport { createTexture } from './utils/createTexture';\n\nimport type { TextureSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\n\n/**\n * Configuration for the [loadSVG]{@link assets.loadSVG} plugin.\n * @see assets.loadSVG\n * @memberof assets\n */\nexport interface LoadSVGConfig\n{\n    /**\n     * The crossOrigin value to use for loading the SVG as an image.\n     * @default 'anonymous'\n     */\n    crossOrigin: HTMLImageElement['crossOrigin'];\n    /**\n     * When set to `true`, loading and decoding images will happen with `new Image()`,\n     * @default false\n     */\n    parseAsGraphicsContext: boolean;\n}\n\n/**\n * Regular expression for SVG XML document.\n * @example &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!-- image/svg --&gt;&lt;svg\n * @readonly\n */\nconst validSVGExtension = '.svg';\nconst validSVGMIME = 'image/svg+xml';\n\n/**\n * A simple loader plugin for loading json data\n * @memberof assets\n */\nexport const loadSvg = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    name: 'loadSVG',\n\n    config: {\n        crossOrigin: 'anonymous',\n        parseAsGraphicsContext: false,\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n    },\n\n    async load(\n        url: string,\n        asset: ResolvedAsset<TextureSourceOptions & LoadSVGConfig>,\n        loader: Loader\n    ): Promise<Texture | GraphicsContext>\n    {\n        if (asset.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext)\n        {\n            return loadAsGraphics(url);\n        }\n\n        return loadAsTexture(url, asset, loader, this.config.crossOrigin);\n    },\n\n    unload(asset: Texture | GraphicsContext): void\n    {\n        asset.destroy(true);\n    }\n\n} as LoaderParser<Texture | GraphicsContext, TextureSourceOptions, LoadSVGConfig>;\n\nasync function loadAsTexture(\n    url: string,\n    asset: ResolvedAsset<TextureSourceOptions & LoadSVGConfig>,\n    loader: Loader,\n    crossOrigin: HTMLImageElement['crossOrigin']\n): Promise<Texture>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const blobUrl = URL.createObjectURL(blob);\n\n    const image = new Image();\n\n    image.src = blobUrl;\n    image.crossOrigin = crossOrigin;\n    await image.decode();\n\n    URL.revokeObjectURL(blobUrl);\n\n    // convert to canvas...\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n\n    const resolution = asset.data?.resolution || getResolutionOfUrl(url);\n\n    const width = asset.data?.width ?? image.width;\n    const height = asset.data?.height ?? image.height;\n\n    canvas.width = width * resolution;\n    canvas.height = height * resolution;\n\n    context.drawImage(image, 0, 0, width * resolution, height * resolution);\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { parseAsGraphicsContext: _p, ...rest } = asset.data;\n    const base = new ImageSource({\n        resource: canvas,\n        alphaMode: 'premultiply-alpha-on-upload',\n        resolution,\n        ...rest,\n    });\n\n    return createTexture(base, loader, url);\n}\n\nasync function loadAsGraphics(url: string): Promise<GraphicsContext>\n{\n    const response = await DOMAdapter.get().fetch(url);\n    const svgSource = await response.text();\n\n    const context = new GraphicsContext();\n\n    context.svg(svgSource);\n\n    return context;\n}\n"],"mappings":";;;;;;;;;;AAuCA,MAAMA,iBAAoB;AAC1B,MAAMC,YAAe;AAMd,MAAMC,OAAU;EACnBC,SAAW;IACPC,IAAA,EAAMC,aAAc,CAAAC,UAAA;IACpBC,QAAA,EAAUC,oBAAqB,CAAAC;EAAA,CACnC;EAEAC,IAAM;EAENC,MAAQ;IACJC,WAAa;IACbC,sBAAwB;EAAA,CAC5B;EAEAC,KAAKC,GACL;IACI,OAAOC,YAAA,CAAaD,GAAK,EAAAd,YAAY,CAAK,IAAAgB,cAAA,CAAeF,GAAA,EAAKf,iBAAiB;EAAA,CACnF;EAEA,MAAMkB,KACFH,GACA,EAAAI,KAAA,EACAC,MAEJ;IACI,IAAID,KAAM,CAAAE,IAAA,CAAKR,sBAA0B,SAAKF,MAAA,CAAOE,sBACrD;MACI,OAAOS,cAAA,CAAeP,GAAG;IAAA;IAG7B,OAAOQ,aAAA,CAAcR,GAAK,EAAAI,KAAA,EAAOC,MAAQ,OAAKT,MAAA,CAAOC,WAAW;EAAA,CACpE;EAEAY,OAAOL,KACP;IACIA,KAAA,CAAMM,OAAA,CAAQ,IAAI;EAAA;AAG1B;AAEA,eAAeF,aACXA,CAAAR,GAAA,EACAI,KACA,EAAAC,MAAA,EACAR,WAEJ;EACI,MAAMc,QAAA,GAAW,MAAMC,UAAA,CAAWC,GAAI,GAAEC,KAAA,CAAMd,GAAG;EAE3C,MAAAe,IAAA,GAAO,MAAMJ,QAAA,CAASI,IAAK;EAE3B,MAAAC,OAAA,GAAUC,GAAI,CAAAC,eAAA,CAAgBH,IAAI;EAElC,MAAAI,KAAA,GAAQ,IAAIC,KAAM;EAExBD,KAAA,CAAME,GAAM,GAAAL,OAAA;EACZG,KAAA,CAAMtB,WAAc,GAAAA,WAAA;EACpB,MAAMsB,KAAA,CAAMG,MAAO;EAEnBL,GAAA,CAAIM,eAAA,CAAgBP,OAAO;EAGrB,MAAAQ,MAAA,GAASC,QAAS,CAAAC,aAAA,CAAc,QAAQ;EACxC,MAAAC,OAAA,GAAUH,MAAO,CAAAI,UAAA,CAAW,IAAI;EAEtC,MAAMC,UAAa,GAAAzB,KAAA,CAAME,IAAM,EAAAuB,UAAA,IAAcC,kBAAA,CAAmB9B,GAAG;EAEnE,MAAM+B,KAAQ,GAAA3B,KAAA,CAAME,IAAM,EAAAyB,KAAA,IAASZ,KAAM,CAAAY,KAAA;EACzC,MAAMC,MAAS,GAAA5B,KAAA,CAAME,IAAM,EAAA0B,MAAA,IAAUb,KAAM,CAAAa,MAAA;EAE3CR,MAAA,CAAOO,KAAA,GAAQA,KAAQ,GAAAF,UAAA;EACvBL,MAAA,CAAOQ,MAAA,GAASA,MAAS,GAAAH,UAAA;EAEzBF,OAAA,CAAQM,SAAA,CAAUd,KAAO,KAAG,GAAGY,KAAQ,GAAAF,UAAA,EAAYG,MAAA,GAASH,UAAU;EAGtE,MAAM;IAAE/B,sBAAwB,EAAAoC,EAAA;IAAI,GAAGC;EAAA,IAAS/B,KAAM,CAAAE,IAAA;EAChD,MAAA8B,IAAA,GAAO,IAAIC,WAAY;IACzBC,QAAU,EAAAd,MAAA;IACVe,SAAW;IACXV,UAAA;IACA,GAAGM;EAAA,CACN;EAEM,OAAAK,aAAA,CAAcJ,IAAM,EAAA/B,MAAA,EAAQL,GAAG;AAC1C;AAEA,eAAeO,eAAeP,GAC9B;EACI,MAAMW,QAAA,GAAW,MAAMC,UAAA,CAAWC,GAAI,GAAEC,KAAA,CAAMd,GAAG;EAC3C,MAAAyC,SAAA,GAAY,MAAM9B,QAAA,CAAS+B,IAAK;EAEhC,MAAAf,OAAA,GAAU,IAAIgB,eAAgB;EAEpChB,OAAA,CAAQiB,GAAA,CAAIH,SAAS;EAEd,OAAAd,OAAA;AACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}