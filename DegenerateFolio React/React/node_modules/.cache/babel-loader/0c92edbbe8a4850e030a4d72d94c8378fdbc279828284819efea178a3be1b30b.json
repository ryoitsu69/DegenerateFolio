{"ast":null,"code":"import { isUndefined } from '@polkadot/util';\nfunction sig(_ref, _ref2, args) {\n  let {\n    lookup\n  } = _ref;\n  let {\n    method,\n    section\n  } = _ref2;\n  return \"\".concat(section, \".\").concat(method, \"(\").concat(args.map(a => lookup.getTypeDef(a).type).join(', '), \")\");\n}\nexport function extractStorageArgs(registry, creator, _args) {\n  const args = _args.filter(a => !isUndefined(a));\n  if (creator.meta.type.isPlain) {\n    if (args.length !== 0) {\n      throw new Error(\"\".concat(sig(registry, creator, []), \" does not take any arguments, \").concat(args.length, \" found\"));\n    }\n  } else {\n    const {\n      hashers,\n      key\n    } = creator.meta.type.asMap;\n    const keys = hashers.length === 1 ? [key] : registry.lookup.getSiType(key).def.asTuple.map(t => t);\n    if (args.length !== keys.length) {\n      throw new Error(\"\".concat(sig(registry, creator, keys), \" is a map, requiring \").concat(keys.length, \" arguments, \").concat(args.length, \" found\"));\n    }\n  }\n  // pass as tuple\n  return [creator, args];\n}","map":{"version":3,"names":["isUndefined","sig","_ref","_ref2","args","lookup","method","section","concat","map","a","getTypeDef","type","join","extractStorageArgs","registry","creator","_args","filter","meta","isPlain","length","Error","hashers","key","asMap","keys","getSiType","def","asTuple","t"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api/util/validate.js"],"sourcesContent":["import { isUndefined } from '@polkadot/util';\nfunction sig({ lookup }, { method, section }, args) {\n    return `${section}.${method}(${args.map((a) => lookup.getTypeDef(a).type).join(', ')})`;\n}\nexport function extractStorageArgs(registry, creator, _args) {\n    const args = _args.filter((a) => !isUndefined(a));\n    if (creator.meta.type.isPlain) {\n        if (args.length !== 0) {\n            throw new Error(`${sig(registry, creator, [])} does not take any arguments, ${args.length} found`);\n        }\n    }\n    else {\n        const { hashers, key } = creator.meta.type.asMap;\n        const keys = hashers.length === 1\n            ? [key]\n            : registry.lookup.getSiType(key).def.asTuple.map((t) => t);\n        if (args.length !== keys.length) {\n            throw new Error(`${sig(registry, creator, keys)} is a map, requiring ${keys.length} arguments, ${args.length} found`);\n        }\n    }\n    // pass as tuple\n    return [creator, args];\n}\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,gBAAgB;AAC5C,SAASC,GAAGA,CAAAC,IAAA,EAAAC,KAAA,EAAkCC,IAAI,EAAE;EAAA,IAAvC;IAAEC;EAAO,CAAC,GAAAH,IAAA;EAAA,IAAE;IAAEI,MAAM;IAAEC;EAAQ,CAAC,GAAAJ,KAAA;EACxC,UAAAK,MAAA,CAAUD,OAAO,OAAAC,MAAA,CAAIF,MAAM,OAAAE,MAAA,CAAIJ,IAAI,CAACK,GAAG,CAAEC,CAAC,IAAKL,MAAM,CAACM,UAAU,CAACD,CAAC,CAAC,CAACE,IAAI,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;AACxF;AACA,OAAO,SAASC,kBAAkBA,CAACC,QAAQ,EAAEC,OAAO,EAAEC,KAAK,EAAE;EACzD,MAAMb,IAAI,GAAGa,KAAK,CAACC,MAAM,CAAER,CAAC,IAAK,CAACV,WAAW,CAACU,CAAC,CAAC,CAAC;EACjD,IAAIM,OAAO,CAACG,IAAI,CAACP,IAAI,CAACQ,OAAO,EAAE;IAC3B,IAAIhB,IAAI,CAACiB,MAAM,KAAK,CAAC,EAAE;MACnB,MAAM,IAAIC,KAAK,IAAAd,MAAA,CAAIP,GAAG,CAACc,QAAQ,EAAEC,OAAO,EAAE,EAAE,CAAC,oCAAAR,MAAA,CAAiCJ,IAAI,CAACiB,MAAM,WAAQ,CAAC;IACtG;EACJ,CAAC,MACI;IACD,MAAM;MAAEE,OAAO;MAAEC;IAAI,CAAC,GAAGR,OAAO,CAACG,IAAI,CAACP,IAAI,CAACa,KAAK;IAChD,MAAMC,IAAI,GAAGH,OAAO,CAACF,MAAM,KAAK,CAAC,GAC3B,CAACG,GAAG,CAAC,GACLT,QAAQ,CAACV,MAAM,CAACsB,SAAS,CAACH,GAAG,CAAC,CAACI,GAAG,CAACC,OAAO,CAACpB,GAAG,CAAEqB,CAAC,IAAKA,CAAC,CAAC;IAC9D,IAAI1B,IAAI,CAACiB,MAAM,KAAKK,IAAI,CAACL,MAAM,EAAE;MAC7B,MAAM,IAAIC,KAAK,IAAAd,MAAA,CAAIP,GAAG,CAACc,QAAQ,EAAEC,OAAO,EAAEU,IAAI,CAAC,2BAAAlB,MAAA,CAAwBkB,IAAI,CAACL,MAAM,kBAAAb,MAAA,CAAeJ,IAAI,CAACiB,MAAM,WAAQ,CAAC;IACzH;EACJ;EACA;EACA,OAAO,CAACL,OAAO,EAAEZ,IAAI,CAAC;AAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}