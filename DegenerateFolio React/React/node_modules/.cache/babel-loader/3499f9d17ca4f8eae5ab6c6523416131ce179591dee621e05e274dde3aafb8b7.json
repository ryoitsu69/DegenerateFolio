{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Registry = exports.isTxBodyEncodeObject = exports.isPbjsGeneratedType = exports.isTsProtoGeneratedType = exports.isTelescopeGeneratedType = void 0;\nconst tx_1 = require(\"cosmjs-types/cosmos/bank/v1beta1/tx\");\nconst coin_1 = require(\"cosmjs-types/cosmos/base/v1beta1/coin\");\nconst tx_2 = require(\"cosmjs-types/cosmos/tx/v1beta1/tx\");\nconst any_1 = require(\"cosmjs-types/google/protobuf/any\");\nfunction isTelescopeGeneratedType(type) {\n  const casted = type;\n  return typeof casted.fromPartial === \"function\" && typeof casted.typeUrl == \"string\";\n}\nexports.isTelescopeGeneratedType = isTelescopeGeneratedType;\nfunction isTsProtoGeneratedType(type) {\n  return typeof type.fromPartial === \"function\";\n}\nexports.isTsProtoGeneratedType = isTsProtoGeneratedType;\nfunction isPbjsGeneratedType(type) {\n  return !isTsProtoGeneratedType(type);\n}\nexports.isPbjsGeneratedType = isPbjsGeneratedType;\nconst defaultTypeUrls = {\n  cosmosCoin: \"/cosmos.base.v1beta1.Coin\",\n  cosmosMsgSend: \"/cosmos.bank.v1beta1.MsgSend\",\n  cosmosTxBody: \"/cosmos.tx.v1beta1.TxBody\",\n  googleAny: \"/google.protobuf.Any\"\n};\nfunction isTxBodyEncodeObject(encodeObject) {\n  return encodeObject.typeUrl === \"/cosmos.tx.v1beta1.TxBody\";\n}\nexports.isTxBodyEncodeObject = isTxBodyEncodeObject;\nclass Registry {\n  /**\n   * Creates a new Registry for mapping protobuf type identifiers/type URLs to\n   * actual implementations. Those implementations are typically generated with ts-proto\n   * but we also support protobuf.js as a type generator.\n   *\n   * If there is no parameter given, a `new Registry()` adds the types `Coin` and `MsgSend`\n   * for historic reasons. Those can be overriden by customTypes.\n   *\n   * There are currently two methods for adding new types:\n   * 1. Passing types to the constructor.\n   * 2. Using the `register()` method\n   */\n  constructor(customTypes) {\n    const {\n      cosmosCoin,\n      cosmosMsgSend\n    } = defaultTypeUrls;\n    this.types = customTypes ? new Map([...customTypes]) : new Map([[cosmosCoin, coin_1.Coin], [cosmosMsgSend, tx_1.MsgSend]]);\n  }\n  register(typeUrl, type) {\n    this.types.set(typeUrl, type);\n  }\n  /**\n   * Looks up a type that was previously added to the registry.\n   *\n   * The generator information (ts-proto or pbjs) gets lost along the way.\n   * If you need to work with the result type in TypeScript, you can use:\n   *\n   * ```\n   * import { assert } from \"@cosmjs/utils\";\n   *\n   * const Coin = registry.lookupType(\"/cosmos.base.v1beta1.Coin\");\n   * assert(Coin); // Ensures not unset\n   * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect\n   *\n   * // Coin is typed TsProtoGeneratedType now.\n   * ```\n   */\n  lookupType(typeUrl) {\n    return this.types.get(typeUrl);\n  }\n  lookupTypeWithError(typeUrl) {\n    const type = this.lookupType(typeUrl);\n    if (!type) {\n      throw new Error(`Unregistered type url: ${typeUrl}`);\n    }\n    return type;\n  }\n  /**\n   * Takes a typeUrl/value pair and encodes the value to protobuf if\n   * the given type was previously registered.\n   *\n   * If the value has to be wrapped in an Any, this needs to be done\n   * manually after this call. Or use `encodeAsAny` instead.\n   */\n  encode(encodeObject) {\n    const {\n      value,\n      typeUrl\n    } = encodeObject;\n    if (isTxBodyEncodeObject(encodeObject)) {\n      return this.encodeTxBody(value);\n    }\n    const type = this.lookupTypeWithError(typeUrl);\n    const instance = isTelescopeGeneratedType(type) || isTsProtoGeneratedType(type) ? type.fromPartial(value) : type.create(value);\n    return type.encode(instance).finish();\n  }\n  /**\n   * Takes a typeUrl/value pair and encodes the value to an Any if\n   * the given type was previously registered.\n   */\n  encodeAsAny(encodeObject) {\n    const binaryValue = this.encode(encodeObject);\n    return any_1.Any.fromPartial({\n      typeUrl: encodeObject.typeUrl,\n      value: binaryValue\n    });\n  }\n  encodeTxBody(txBodyFields) {\n    const wrappedMessages = txBodyFields.messages.map(message => this.encodeAsAny(message));\n    const txBody = tx_2.TxBody.fromPartial({\n      ...txBodyFields,\n      timeoutHeight: BigInt(txBodyFields.timeoutHeight?.toString() ?? \"0\"),\n      messages: wrappedMessages\n    });\n    return tx_2.TxBody.encode(txBody).finish();\n  }\n  decode({\n    typeUrl,\n    value\n  }) {\n    if (typeUrl === defaultTypeUrls.cosmosTxBody) {\n      return this.decodeTxBody(value);\n    }\n    const type = this.lookupTypeWithError(typeUrl);\n    const decoded = type.decode(value);\n    Object.entries(decoded).forEach(([key, val]) => {\n      if (typeof Buffer !== \"undefined\" && typeof Buffer.isBuffer !== \"undefined\" && Buffer.isBuffer(val)) {\n        decoded[key] = Uint8Array.from(val);\n      }\n    });\n    return decoded;\n  }\n  decodeTxBody(txBody) {\n    const decodedTxBody = tx_2.TxBody.decode(txBody);\n    return {\n      ...decodedTxBody,\n      messages: decodedTxBody.messages.map(({\n        typeUrl: typeUrl,\n        value\n      }) => {\n        if (!typeUrl) {\n          throw new Error(\"Missing type_url in Any\");\n        }\n        if (!value) {\n          throw new Error(\"Missing value in Any\");\n        }\n        return this.decode({\n          typeUrl,\n          value\n        });\n      })\n    };\n  }\n}\nexports.Registry = Registry;","map":{"version":3,"names":["tx_1","require","coin_1","tx_2","any_1","isTelescopeGeneratedType","type","casted","fromPartial","typeUrl","exports","isTsProtoGeneratedType","isPbjsGeneratedType","defaultTypeUrls","cosmosCoin","cosmosMsgSend","cosmosTxBody","googleAny","isTxBodyEncodeObject","encodeObject","Registry","constructor","customTypes","types","Map","Coin","MsgSend","register","set","lookupType","get","lookupTypeWithError","Error","encode","value","encodeTxBody","instance","create","finish","encodeAsAny","binaryValue","Any","txBodyFields","wrappedMessages","messages","map","message","txBody","TxBody","timeoutHeight","BigInt","toString","decode","decodeTxBody","decoded","Object","entries","forEach","key","val","Buffer","isBuffer","Uint8Array","from","decodedTxBody"],"sources":["../src/registry.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}