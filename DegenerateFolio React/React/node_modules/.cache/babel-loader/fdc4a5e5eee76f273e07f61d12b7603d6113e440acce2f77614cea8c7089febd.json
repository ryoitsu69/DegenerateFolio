{"ast":null,"code":"import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { BN_BILLION, BN_ZERO, objectSpread } from '@polkadot/util';\nimport { firstMemo, memo } from '../util/index.js';\nfunction extractCompatRewards(ledger) {\n  return ledger ? ledger.legacyClaimedRewards || ledger.claimedRewards : [];\n}\nfunction parseRewards(api, stashId, _ref, exposures) {\n  let [erasPoints, erasPrefs, erasRewards] = _ref;\n  return exposures.map(_ref2 => {\n    let {\n      era,\n      isEmpty,\n      isValidator,\n      nominating,\n      validators: eraValidators\n    } = _ref2;\n    const {\n      eraPoints,\n      validators: allValPoints\n    } = erasPoints.find(p => p.era.eq(era)) || {\n      eraPoints: BN_ZERO,\n      validators: {}\n    };\n    const {\n      eraReward\n    } = erasRewards.find(r => r.era.eq(era)) || {\n      eraReward: api.registry.createType('Balance')\n    };\n    const {\n      validators: allValPrefs\n    } = erasPrefs.find(p => p.era.eq(era)) || {\n      validators: {}\n    };\n    const validators = {};\n    const stakerId = stashId.toString();\n    Object.entries(eraValidators).forEach(_ref3 => {\n      var _allValPrefs$validato, _exposure$total, _exposure$pageTotal;\n      let [validatorId, exposure] = _ref3;\n      const valPoints = allValPoints[validatorId] || BN_ZERO;\n      const valComm = ((_allValPrefs$validato = allValPrefs[validatorId]) === null || _allValPrefs$validato === void 0 ? void 0 : _allValPrefs$validato.commission.unwrap()) || BN_ZERO;\n      const expTotal = exposure.total ? (_exposure$total = exposure.total) === null || _exposure$total === void 0 ? void 0 : _exposure$total.unwrap() : exposure.pageTotal ? (_exposure$pageTotal = exposure.pageTotal) === null || _exposure$pageTotal === void 0 ? void 0 : _exposure$pageTotal.unwrap() : BN_ZERO;\n      let avail = BN_ZERO;\n      let value;\n      if (!(expTotal.isZero() || valPoints.isZero() || eraPoints.isZero())) {\n        avail = eraReward.mul(valPoints).div(eraPoints);\n        const valCut = valComm.mul(avail).div(BN_BILLION);\n        let staked;\n        if (validatorId === stakerId) {\n          if (exposure.own) {\n            staked = exposure.own.unwrap();\n          } else {\n            const expAccount = exposure.others.find(_ref4 => {\n              let {\n                who\n              } = _ref4;\n              return who.eq(validatorId);\n            });\n            staked = expAccount ? expAccount.value.unwrap() : BN_ZERO;\n          }\n        } else {\n          const stakerExp = exposure.others.find(_ref5 => {\n            let {\n              who\n            } = _ref5;\n            return who.eq(stakerId);\n          });\n          staked = stakerExp ? stakerExp.value.unwrap() : BN_ZERO;\n        }\n        value = avail.sub(valCut).imul(staked).div(expTotal).iadd(validatorId === stakerId ? valCut : BN_ZERO);\n      }\n      validators[validatorId] = {\n        total: api.registry.createType('Balance', avail),\n        value: api.registry.createType('Balance', value)\n      };\n    });\n    return {\n      era,\n      eraReward,\n      isEmpty,\n      isValidator,\n      nominating,\n      validators\n    };\n  });\n}\nfunction allUniqValidators(rewards) {\n  return rewards.reduce((_ref6, rewards) => {\n    let [all, perStash] = _ref6;\n    const uniq = [];\n    perStash.push(uniq);\n    rewards.forEach(_ref7 => {\n      let {\n        validators\n      } = _ref7;\n      return Object.keys(validators).forEach(validatorId => {\n        if (!uniq.includes(validatorId)) {\n          uniq.push(validatorId);\n          if (!all.includes(validatorId)) {\n            all.push(validatorId);\n          }\n        }\n      });\n    });\n    return [all, perStash];\n  }, [[], []]);\n}\nfunction removeClaimed(validators, queryValidators, reward) {\n  const rm = [];\n  Object.keys(reward.validators).forEach(validatorId => {\n    const index = validators.indexOf(validatorId);\n    if (index !== -1) {\n      const valLedger = queryValidators[index].stakingLedger;\n      if (extractCompatRewards(valLedger).some(e => reward.era.eq(e))) {\n        rm.push(validatorId);\n      }\n    }\n  });\n  rm.forEach(validatorId => {\n    delete reward.validators[validatorId];\n  });\n}\nfunction filterRewards(eras, valInfo, _ref8) {\n  let {\n    rewards,\n    stakingLedger\n  } = _ref8;\n  const filter = eras.filter(e => !extractCompatRewards(stakingLedger).some(s => s.eq(e)));\n  const validators = valInfo.map(_ref9 => {\n    let [v] = _ref9;\n    return v;\n  });\n  const queryValidators = valInfo.map(_ref10 => {\n    let [, q] = _ref10;\n    return q;\n  });\n  return rewards.filter(_ref11 => {\n    let {\n      isEmpty\n    } = _ref11;\n    return !isEmpty;\n  }).filter(reward => {\n    if (!filter.some(e => reward.era.eq(e))) {\n      return false;\n    }\n    removeClaimed(validators, queryValidators, reward);\n    return true;\n  }).filter(_ref12 => {\n    let {\n      validators\n    } = _ref12;\n    return Object.keys(validators).length !== 0;\n  }).map(reward => objectSpread({}, reward, {\n    nominators: reward.nominating.filter(n => reward.validators[n.validatorId])\n  }));\n}\nexport function _stakerRewardsEras(instanceId, api) {\n  return memo(instanceId, function (eras) {\n    let withActive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return combineLatest([api.derive.staking._erasPoints(eras, withActive), api.derive.staking._erasPrefs(eras, withActive), api.derive.staking._erasRewards(eras, withActive)]);\n  });\n}\nexport function _stakerRewards(instanceId, api) {\n  return memo(instanceId, function (accountIds, eras) {\n    let withActive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return combineLatest([api.derive.staking.queryMulti(accountIds, {\n      withLedger: true\n    }), api.derive.staking._stakerExposures(accountIds, eras, withActive), api.derive.staking._stakerRewardsEras(eras, withActive)]).pipe(switchMap(_ref13 => {\n      let [queries, exposures, erasResult] = _ref13;\n      const allRewards = queries.map((_ref14, index) => {\n        let {\n          stakingLedger,\n          stashId\n        } = _ref14;\n        return !stashId || !stakingLedger ? [] : parseRewards(api, stashId, erasResult, exposures[index]);\n      });\n      if (withActive) {\n        return of(allRewards);\n      }\n      const [allValidators, stashValidators] = allUniqValidators(allRewards);\n      return api.derive.staking.queryMulti(allValidators, {\n        withLedger: true\n      }).pipe(map(queriedVals => queries.map((_ref15, index) => {\n        let {\n          stakingLedger\n        } = _ref15;\n        return filterRewards(eras, stashValidators[index].map(validatorId => [validatorId, queriedVals.find(q => q.accountId.eq(validatorId))]).filter(v => !!v[1]), {\n          rewards: allRewards[index],\n          stakingLedger\n        });\n      })));\n    }));\n  });\n}\nexport const stakerRewards = /*#__PURE__*/firstMemo((api, accountId, withActive) => api.derive.staking.erasHistoric(withActive).pipe(switchMap(eras => api.derive.staking._stakerRewards([accountId], eras, withActive))));\nexport function stakerRewardsMultiEras(instanceId, api) {\n  return memo(instanceId, (accountIds, eras) => accountIds.length && eras.length ? api.derive.staking._stakerRewards(accountIds, eras, false) : of([]));\n}\nexport function stakerRewardsMulti(instanceId, api) {\n  return memo(instanceId, function (accountIds) {\n    let withActive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return api.derive.staking.erasHistoric(withActive).pipe(switchMap(eras => api.derive.staking.stakerRewardsMultiEras(accountIds, eras)));\n  });\n}","map":{"version":3,"names":["combineLatest","map","of","switchMap","BN_BILLION","BN_ZERO","objectSpread","firstMemo","memo","extractCompatRewards","ledger","legacyClaimedRewards","claimedRewards","parseRewards","api","stashId","_ref","exposures","erasPoints","erasPrefs","erasRewards","_ref2","era","isEmpty","isValidator","nominating","validators","eraValidators","eraPoints","allValPoints","find","p","eq","eraReward","r","registry","createType","allValPrefs","stakerId","toString","Object","entries","forEach","_ref3","_allValPrefs$validato","_exposure$total","_exposure$pageTotal","validatorId","exposure","valPoints","valComm","commission","unwrap","expTotal","total","pageTotal","avail","value","isZero","mul","div","valCut","staked","own","expAccount","others","_ref4","who","stakerExp","_ref5","sub","imul","iadd","allUniqValidators","rewards","reduce","_ref6","all","perStash","uniq","push","_ref7","keys","includes","removeClaimed","queryValidators","reward","rm","index","indexOf","valLedger","stakingLedger","some","e","filterRewards","eras","valInfo","_ref8","filter","s","_ref9","v","_ref10","q","_ref11","_ref12","length","nominators","n","_stakerRewardsEras","instanceId","withActive","arguments","undefined","derive","staking","_erasPoints","_erasPrefs","_erasRewards","_stakerRewards","accountIds","queryMulti","withLedger","_stakerExposures","pipe","_ref13","queries","erasResult","allRewards","_ref14","allValidators","stashValidators","queriedVals","_ref15","accountId","stakerRewards","erasHistoric","stakerRewardsMultiEras","stakerRewardsMulti"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api-derive/staking/stakerRewards.js"],"sourcesContent":["import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { BN_BILLION, BN_ZERO, objectSpread } from '@polkadot/util';\nimport { firstMemo, memo } from '../util/index.js';\nfunction extractCompatRewards(ledger) {\n    return ledger\n        ? (ledger.legacyClaimedRewards ||\n            ledger.claimedRewards)\n        : [];\n}\nfunction parseRewards(api, stashId, [erasPoints, erasPrefs, erasRewards], exposures) {\n    return exposures.map(({ era, isEmpty, isValidator, nominating, validators: eraValidators }) => {\n        const { eraPoints, validators: allValPoints } = erasPoints.find((p) => p.era.eq(era)) || { eraPoints: BN_ZERO, validators: {} };\n        const { eraReward } = erasRewards.find((r) => r.era.eq(era)) || { eraReward: api.registry.createType('Balance') };\n        const { validators: allValPrefs } = erasPrefs.find((p) => p.era.eq(era)) || { validators: {} };\n        const validators = {};\n        const stakerId = stashId.toString();\n        Object.entries(eraValidators).forEach(([validatorId, exposure]) => {\n            const valPoints = allValPoints[validatorId] || BN_ZERO;\n            const valComm = allValPrefs[validatorId]?.commission.unwrap() || BN_ZERO;\n            const expTotal = exposure.total\n                ? exposure.total?.unwrap()\n                : exposure.pageTotal\n                    ? exposure.pageTotal?.unwrap()\n                    : BN_ZERO;\n            let avail = BN_ZERO;\n            let value;\n            if (!(expTotal.isZero() || valPoints.isZero() || eraPoints.isZero())) {\n                avail = eraReward.mul(valPoints).div(eraPoints);\n                const valCut = valComm.mul(avail).div(BN_BILLION);\n                let staked;\n                if (validatorId === stakerId) {\n                    if (exposure.own) {\n                        staked = exposure.own.unwrap();\n                    }\n                    else {\n                        const expAccount = exposure.others.find(({ who }) => who.eq(validatorId));\n                        staked = expAccount\n                            ? expAccount.value.unwrap()\n                            : BN_ZERO;\n                    }\n                }\n                else {\n                    const stakerExp = exposure.others.find(({ who }) => who.eq(stakerId));\n                    staked = stakerExp\n                        ? stakerExp.value.unwrap()\n                        : BN_ZERO;\n                }\n                value = avail.sub(valCut).imul(staked).div(expTotal).iadd(validatorId === stakerId ? valCut : BN_ZERO);\n            }\n            validators[validatorId] = {\n                total: api.registry.createType('Balance', avail),\n                value: api.registry.createType('Balance', value)\n            };\n        });\n        return {\n            era,\n            eraReward,\n            isEmpty,\n            isValidator,\n            nominating,\n            validators\n        };\n    });\n}\nfunction allUniqValidators(rewards) {\n    return rewards.reduce(([all, perStash], rewards) => {\n        const uniq = [];\n        perStash.push(uniq);\n        rewards.forEach(({ validators }) => Object.keys(validators).forEach((validatorId) => {\n            if (!uniq.includes(validatorId)) {\n                uniq.push(validatorId);\n                if (!all.includes(validatorId)) {\n                    all.push(validatorId);\n                }\n            }\n        }));\n        return [all, perStash];\n    }, [[], []]);\n}\nfunction removeClaimed(validators, queryValidators, reward) {\n    const rm = [];\n    Object.keys(reward.validators).forEach((validatorId) => {\n        const index = validators.indexOf(validatorId);\n        if (index !== -1) {\n            const valLedger = queryValidators[index].stakingLedger;\n            if (extractCompatRewards(valLedger).some((e) => reward.era.eq(e))) {\n                rm.push(validatorId);\n            }\n        }\n    });\n    rm.forEach((validatorId) => {\n        delete reward.validators[validatorId];\n    });\n}\nfunction filterRewards(eras, valInfo, { rewards, stakingLedger }) {\n    const filter = eras.filter((e) => !extractCompatRewards(stakingLedger).some((s) => s.eq(e)));\n    const validators = valInfo.map(([v]) => v);\n    const queryValidators = valInfo.map(([, q]) => q);\n    return rewards\n        .filter(({ isEmpty }) => !isEmpty)\n        .filter((reward) => {\n        if (!filter.some((e) => reward.era.eq(e))) {\n            return false;\n        }\n        removeClaimed(validators, queryValidators, reward);\n        return true;\n    })\n        .filter(({ validators }) => Object.keys(validators).length !== 0)\n        .map((reward) => objectSpread({}, reward, {\n        nominators: reward.nominating.filter((n) => reward.validators[n.validatorId])\n    }));\n}\nexport function _stakerRewardsEras(instanceId, api) {\n    return memo(instanceId, (eras, withActive = false) => combineLatest([\n        api.derive.staking._erasPoints(eras, withActive),\n        api.derive.staking._erasPrefs(eras, withActive),\n        api.derive.staking._erasRewards(eras, withActive)\n    ]));\n}\nexport function _stakerRewards(instanceId, api) {\n    return memo(instanceId, (accountIds, eras, withActive = false) => combineLatest([\n        api.derive.staking.queryMulti(accountIds, { withLedger: true }),\n        api.derive.staking._stakerExposures(accountIds, eras, withActive),\n        api.derive.staking._stakerRewardsEras(eras, withActive)\n    ]).pipe(switchMap(([queries, exposures, erasResult]) => {\n        const allRewards = queries.map(({ stakingLedger, stashId }, index) => (!stashId || !stakingLedger)\n            ? []\n            : parseRewards(api, stashId, erasResult, exposures[index]));\n        if (withActive) {\n            return of(allRewards);\n        }\n        const [allValidators, stashValidators] = allUniqValidators(allRewards);\n        return api.derive.staking.queryMulti(allValidators, { withLedger: true }).pipe(map((queriedVals) => queries.map(({ stakingLedger }, index) => filterRewards(eras, stashValidators[index]\n            .map((validatorId) => [\n            validatorId,\n            queriedVals.find((q) => q.accountId.eq(validatorId))\n        ])\n            .filter((v) => !!v[1]), {\n            rewards: allRewards[index],\n            stakingLedger\n        }))));\n    })));\n}\nexport const stakerRewards = /*#__PURE__*/ firstMemo((api, accountId, withActive) => api.derive.staking.erasHistoric(withActive).pipe(switchMap((eras) => api.derive.staking._stakerRewards([accountId], eras, withActive))));\nexport function stakerRewardsMultiEras(instanceId, api) {\n    return memo(instanceId, (accountIds, eras) => accountIds.length && eras.length\n        ? api.derive.staking._stakerRewards(accountIds, eras, false)\n        : of([]));\n}\nexport function stakerRewardsMulti(instanceId, api) {\n    return memo(instanceId, (accountIds, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe(switchMap((eras) => api.derive.staking.stakerRewardsMultiEras(accountIds, eras))));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}