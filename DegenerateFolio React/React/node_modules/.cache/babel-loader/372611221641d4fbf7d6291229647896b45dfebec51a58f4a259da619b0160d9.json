{"ast":null,"code":"import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../../rendering/renderers/shared/state/State.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { color32BitToUniform } from '../gpu/colorToUniform.mjs';\nimport { BatchableGraphics } from './BatchableGraphics.mjs';\n\"use strict\";\nclass GraphicsPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    // batchable graphics list, used to render batches\n    this._graphicsBatchesHash = /* @__PURE__ */Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(graphics) {\n    const context = graphics.context;\n    const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(graphics, instructionSet) {\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (graphics._didGraphicsUpdate) {\n      graphics._didGraphicsUpdate = false;\n      this._rebuild(graphics);\n    }\n    if (gpuContext.isBatchable) {\n      this._addToBatcher(graphics, instructionSet);\n    } else {\n      this.renderer.renderPipes.batch.break(instructionSet);\n      instructionSet.add(graphics);\n    }\n  }\n  updateRenderable(graphics) {\n    const batches = this._graphicsBatchesHash[graphics.uid];\n    if (batches) {\n      for (let i = 0; i < batches.length; i++) {\n        const batch = batches[i];\n        batch.batcher.updateElement(batch);\n      }\n    }\n  }\n  destroyRenderable(graphics) {\n    if (this._graphicsBatchesHash[graphics.uid]) {\n      this._removeBatchForRenderable(graphics.uid);\n    }\n  }\n  execute(graphics) {\n    if (!graphics.isRenderable) return;\n    const renderer = this.renderer;\n    const context = graphics.context;\n    const contextSystem = renderer.graphicsContext;\n    if (!contextSystem.getGpuContext(context).batches.length) {\n      return;\n    }\n    const shader = context.customShader || this._adaptor.shader;\n    this.state.blendMode = graphics.groupBlendMode;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = graphics.groupTransform;\n    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n    color32BitToUniform(graphics.groupColorAlpha, localUniforms.uColor, 0);\n    this._adaptor.execute(this, graphics);\n  }\n  _rebuild(graphics) {\n    const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (wasBatched) {\n      this._removeBatchForRenderable(graphics.uid);\n    }\n    if (gpuContext.isBatchable) {\n      this._initBatchesForRenderable(graphics);\n    }\n    graphics.batched = gpuContext.isBatchable;\n  }\n  _addToBatcher(graphics, instructionSet) {\n    const batchPipe = this.renderer.renderPipes.batch;\n    const batches = this._getBatchesForRenderable(graphics);\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batchPipe.addToBatch(batch, instructionSet);\n    }\n  }\n  _getBatchesForRenderable(graphics) {\n    return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n  }\n  _initBatchesForRenderable(graphics) {\n    const context = graphics.context;\n    const gpuContext = this.renderer.graphicsContext.getGpuContext(context);\n    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n    const batches = gpuContext.batches.map(batch => {\n      const batchClone = BigPool.get(BatchableGraphics);\n      batch.copyTo(batchClone);\n      batchClone.renderable = graphics;\n      batchClone.roundPixels = roundPixels;\n      return batchClone;\n    });\n    this._graphicsBatchesHash[graphics.uid] = batches;\n    graphics.on(\"destroyed\", () => {\n      this.destroyRenderable(graphics);\n    });\n    return batches;\n  }\n  _removeBatchForRenderable(graphicsUid) {\n    this._graphicsBatchesHash[graphicsUid].forEach(batch => {\n      BigPool.return(batch);\n    });\n    this._graphicsBatchesHash[graphicsUid] = null;\n  }\n  destroy() {\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.state = null;\n    for (const i in this._graphicsBatchesHash) {\n      this._removeBatchForRenderable(i);\n    }\n    this._graphicsBatchesHash = null;\n  }\n}\n/** @ignore */\nGraphicsPipe.extension = {\n  type: [ExtensionType.WebGLPipes, ExtensionType.WebGPUPipes, ExtensionType.CanvasPipes],\n  name: \"graphics\"\n};\nexport { GraphicsPipe };","map":{"version":3,"names":["GraphicsPipe","constructor","renderer","adaptor","state","State","for2d","_graphicsBatchesHash","Object","create","_adaptor","init","validateRenderable","graphics","context","wasBatched","uid","gpuContext","graphicsContext","updateGpuContext","isBatchable","addRenderable","instructionSet","_didGraphicsUpdate","_rebuild","_addToBatcher","renderPipes","batch","break","add","updateRenderable","batches","i","length","batcher","updateElement","destroyRenderable","_removeBatchForRenderable","execute","isRenderable","contextSystem","getGpuContext","shader","customShader","blendMode","groupBlendMode","localUniforms","resources","uniforms","uTransformMatrix","groupTransform","uRound","_roundPixels","color32BitToUniform","groupColorAlpha","uColor","_initBatchesForRenderable","batched","batchPipe","_getBatchesForRenderable","addToBatch","roundPixels","map","batchClone","BigPool","get","BatchableGraphics","copyTo","renderable","on","graphicsUid","forEach","return","destroy","extension","type","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","name"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/graphics/shared/GraphicsPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext, GraphicsContextSystem } from './GraphicsContextSystem';\n\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    init(): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\nexport interface GraphicsSystem\n{\n    graphicsContext: GraphicsContextSystem;\n    renderPipes: {\n        batch: BatchPipe\n    }\n    _roundPixels: 0 | 1;\n}\n\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: GraphicsSystem;\n    public state: State = State.for2d();\n\n    // batchable graphics list, used to render batches\n    private _graphicsBatchesHash: Record<number, BatchableGraphics[]> = Object.create(null);\n    private _adaptor: GraphicsAdaptor;\n\n    constructor(renderer: GraphicsSystem, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n\n        this._adaptor = adaptor;\n        this._adaptor.init();\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n\n        const context = graphics.context;\n\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n\n        if (graphics._didGraphicsUpdate)\n        {\n            graphics._didGraphicsUpdate = false;\n\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const batches = this._graphicsBatchesHash[graphics.uid];\n\n        if (batches)\n        {\n            for (let i = 0; i < batches.length; i++)\n            {\n                const batch = batches[i];\n\n                batch.batcher.updateElement(batch);\n            }\n        }\n    }\n\n    public destroyRenderable(graphics: Graphics)\n    {\n        if (this._graphicsBatchesHash[graphics.uid])\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // TODO POOL the old batches!\n\n        if (wasBatched)\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._initBatchesForRenderable(graphics);\n        }\n\n        graphics.batched = gpuContext.isBatchable;\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getBatchesForRenderable(graphics);\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n    }\n\n    private _initBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        const batches = gpuContext.batches.map((batch) =>\n        {\n            // TODO pool this!!\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n\n        this._graphicsBatchesHash[graphics.uid] = batches;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        graphics.on('destroyed', () =>\n        {\n            this.destroyRenderable(graphics);\n        });\n\n        return batches;\n    }\n\n    private _removeBatchForRenderable(graphicsUid: number)\n    {\n        this._graphicsBatchesHash[graphicsUid].forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this._graphicsBatchesHash[graphicsUid] = null;\n    }\n\n    public destroy()\n    {\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n\n        for (const i in this._graphicsBatchesHash)\n        {\n            this._removeBatchForRenderable(i as unknown as number);\n        }\n\n        this._graphicsBatchesHash = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}