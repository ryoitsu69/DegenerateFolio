{"ast":null,"code":"import { u8aIsWrapped, u8aToU8a, u8aUnwrapBytes, u8aWrapBytes } from '@polkadot/util';\nimport { decodeAddress } from '../address/decode.js';\nimport { ed25519Verify } from '../ed25519/verify.js';\nimport { secp256k1Verify } from '../secp256k1/verify.js';\nimport { sr25519Verify } from '../sr25519/verify.js';\nconst secp256k1VerifyHasher = hashType => (message, signature, publicKey) => secp256k1Verify(message, signature, publicKey, hashType);\nconst VERIFIERS_ECDSA = [['ecdsa', secp256k1VerifyHasher('blake2')], ['ethereum', secp256k1VerifyHasher('keccak')]];\nconst VERIFIERS = [['ed25519', ed25519Verify], ['sr25519', sr25519Verify], ...VERIFIERS_ECDSA];\nconst CRYPTO_TYPES = ['ed25519', 'sr25519', 'ecdsa'];\nfunction verifyDetect(result, _ref) {\n  let {\n    message,\n    publicKey,\n    signature\n  } = _ref;\n  let verifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : VERIFIERS;\n  result.isValid = verifiers.some(_ref2 => {\n    let [crypto, verify] = _ref2;\n    try {\n      if (verify(message, signature, publicKey)) {\n        result.crypto = crypto;\n        return true;\n      }\n    } catch {\n      // do nothing, result.isValid still set to false\n    }\n    return false;\n  });\n  return result;\n}\nfunction verifyMultisig(result, _ref3) {\n  let {\n    message,\n    publicKey,\n    signature\n  } = _ref3;\n  if (![0, 1, 2].includes(signature[0])) {\n    throw new Error(\"Unknown crypto type, expected signature prefix [0..2], found \".concat(signature[0]));\n  }\n  const type = CRYPTO_TYPES[signature[0]] || 'none';\n  result.crypto = type;\n  try {\n    result.isValid = {\n      ecdsa: () => verifyDetect(result, {\n        message,\n        publicKey,\n        signature: signature.subarray(1)\n      }, VERIFIERS_ECDSA).isValid,\n      ed25519: () => ed25519Verify(message, signature.subarray(1), publicKey),\n      none: () => {\n        throw Error('no verify for `none` crypto type');\n      },\n      sr25519: () => sr25519Verify(message, signature.subarray(1), publicKey)\n    }[type]();\n  } catch {\n    // ignore, result.isValid still set to false\n  }\n  return result;\n}\nfunction getVerifyFn(signature) {\n  return [0, 1, 2].includes(signature[0]) && [65, 66].includes(signature.length) ? verifyMultisig : verifyDetect;\n}\nexport function signatureVerify(message, signature, addressOrPublicKey) {\n  const signatureU8a = u8aToU8a(signature);\n  if (![64, 65, 66].includes(signatureU8a.length)) {\n    throw new Error(\"Invalid signature length, expected [64..66] bytes, found \".concat(signatureU8a.length));\n  }\n  const publicKey = decodeAddress(addressOrPublicKey);\n  const input = {\n    message: u8aToU8a(message),\n    publicKey,\n    signature: signatureU8a\n  };\n  const result = {\n    crypto: 'none',\n    isValid: false,\n    isWrapped: u8aIsWrapped(input.message, true),\n    publicKey\n  };\n  const isWrappedBytes = u8aIsWrapped(input.message, false);\n  const verifyFn = getVerifyFn(signatureU8a);\n  verifyFn(result, input);\n  if (result.crypto !== 'none' || result.isWrapped && !isWrappedBytes) {\n    return result;\n  }\n  input.message = isWrappedBytes ? u8aUnwrapBytes(input.message) : u8aWrapBytes(input.message);\n  return verifyFn(result, input);\n}","map":{"version":3,"names":["u8aIsWrapped","u8aToU8a","u8aUnwrapBytes","u8aWrapBytes","decodeAddress","ed25519Verify","secp256k1Verify","sr25519Verify","secp256k1VerifyHasher","hashType","message","signature","publicKey","VERIFIERS_ECDSA","VERIFIERS","CRYPTO_TYPES","verifyDetect","result","_ref","verifiers","arguments","length","undefined","isValid","some","_ref2","crypto","verify","verifyMultisig","_ref3","includes","Error","concat","type","ecdsa","subarray","ed25519","none","sr25519","getVerifyFn","signatureVerify","addressOrPublicKey","signatureU8a","input","isWrapped","isWrappedBytes","verifyFn"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util-crypto/signature/verify.js"],"sourcesContent":["import { u8aIsWrapped, u8aToU8a, u8aUnwrapBytes, u8aWrapBytes } from '@polkadot/util';\nimport { decodeAddress } from '../address/decode.js';\nimport { ed25519Verify } from '../ed25519/verify.js';\nimport { secp256k1Verify } from '../secp256k1/verify.js';\nimport { sr25519Verify } from '../sr25519/verify.js';\nconst secp256k1VerifyHasher = (hashType) => (message, signature, publicKey) => secp256k1Verify(message, signature, publicKey, hashType);\nconst VERIFIERS_ECDSA = [\n    ['ecdsa', secp256k1VerifyHasher('blake2')],\n    ['ethereum', secp256k1VerifyHasher('keccak')]\n];\nconst VERIFIERS = [\n    ['ed25519', ed25519Verify],\n    ['sr25519', sr25519Verify],\n    ...VERIFIERS_ECDSA\n];\nconst CRYPTO_TYPES = ['ed25519', 'sr25519', 'ecdsa'];\nfunction verifyDetect(result, { message, publicKey, signature }, verifiers = VERIFIERS) {\n    result.isValid = verifiers.some(([crypto, verify]) => {\n        try {\n            if (verify(message, signature, publicKey)) {\n                result.crypto = crypto;\n                return true;\n            }\n        }\n        catch {\n            // do nothing, result.isValid still set to false\n        }\n        return false;\n    });\n    return result;\n}\nfunction verifyMultisig(result, { message, publicKey, signature }) {\n    if (![0, 1, 2].includes(signature[0])) {\n        throw new Error(`Unknown crypto type, expected signature prefix [0..2], found ${signature[0]}`);\n    }\n    const type = CRYPTO_TYPES[signature[0]] || 'none';\n    result.crypto = type;\n    try {\n        result.isValid = {\n            ecdsa: () => verifyDetect(result, { message, publicKey, signature: signature.subarray(1) }, VERIFIERS_ECDSA).isValid,\n            ed25519: () => ed25519Verify(message, signature.subarray(1), publicKey),\n            none: () => {\n                throw Error('no verify for `none` crypto type');\n            },\n            sr25519: () => sr25519Verify(message, signature.subarray(1), publicKey)\n        }[type]();\n    }\n    catch {\n        // ignore, result.isValid still set to false\n    }\n    return result;\n}\nfunction getVerifyFn(signature) {\n    return [0, 1, 2].includes(signature[0]) && [65, 66].includes(signature.length)\n        ? verifyMultisig\n        : verifyDetect;\n}\nexport function signatureVerify(message, signature, addressOrPublicKey) {\n    const signatureU8a = u8aToU8a(signature);\n    if (![64, 65, 66].includes(signatureU8a.length)) {\n        throw new Error(`Invalid signature length, expected [64..66] bytes, found ${signatureU8a.length}`);\n    }\n    const publicKey = decodeAddress(addressOrPublicKey);\n    const input = { message: u8aToU8a(message), publicKey, signature: signatureU8a };\n    const result = { crypto: 'none', isValid: false, isWrapped: u8aIsWrapped(input.message, true), publicKey };\n    const isWrappedBytes = u8aIsWrapped(input.message, false);\n    const verifyFn = getVerifyFn(signatureU8a);\n    verifyFn(result, input);\n    if (result.crypto !== 'none' || (result.isWrapped && !isWrappedBytes)) {\n        return result;\n    }\n    input.message = isWrappedBytes\n        ? u8aUnwrapBytes(input.message)\n        : u8aWrapBytes(input.message);\n    return verifyFn(result, input);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}