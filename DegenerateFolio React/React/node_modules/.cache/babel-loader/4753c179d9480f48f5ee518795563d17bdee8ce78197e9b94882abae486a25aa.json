{"ast":null,"code":"import { BufferResource } from '../../../shared/buffer/BufferResource.mjs';\nimport { UniformGroup } from '../../../shared/shader/UniformGroup.mjs';\nimport { uniformParsers } from '../../../shared/shader/utils/uniformParsers.mjs';\nimport { UNIFORM_TO_SINGLE_SETTERS, UNIFORM_TO_ARRAY_SETTERS } from './generateUniformsSyncTypes.mjs';\n\"use strict\";\nfunction generateUniformsSync(group, uniformData) {\n  const funcFragments = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n        var name = null;\n    `];\n  for (const i in group.uniforms) {\n    if (!uniformData[i]) {\n      if (group.uniforms[i] instanceof UniformGroup) {\n        if (group.uniforms[i].ubo) {\n          funcFragments.push(`\n                        renderer.shader.bindUniformBlock(uv.${i}, \"${i}\");\n                    `);\n        } else {\n          funcFragments.push(`\n                        renderer.shader.updateUniformGroup(uv.${i});\n                    `);\n        }\n      } else if (group.uniforms[i] instanceof BufferResource) {\n        funcFragments.push(`\n                        renderer.shader.bindBufferResource(uv.${i}, \"${i}\");\n                    `);\n      }\n      continue;\n    }\n    const uniform = group.uniformStructures[i];\n    let parsed = false;\n    for (let j = 0; j < uniformParsers.length; j++) {\n      const parser = uniformParsers[j];\n      if (uniform.type === parser.type && parser.test(uniform)) {\n        funcFragments.push(`name = \"${i}\";`, uniformParsers[j].uniform);\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;\n      const template = templateType[uniform.type].replace(\"location\", `ud[\"${i}\"].location`);\n      funcFragments.push(`\n            cu = ud[\"${i}\"];\n            cv = cu.value;\n            v = uv[\"${i}\"];\n            ${template};`);\n    }\n  }\n  return new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", funcFragments.join(\"\\n\"));\n}\nexport { generateUniformsSync };","map":{"version":3,"names":["generateUniformsSync","group","uniformData","funcFragments","i","uniforms","UniformGroup","ubo","push","BufferResource","uniform","uniformStructures","parsed","j","uniformParsers","length","parser","type","test","templateType","size","UNIFORM_TO_SINGLE_SETTERS","UNIFORM_TO_ARRAY_SETTERS","template","replace","Function","join"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/generateUniformsSync.ts"],"sourcesContent":["// cu = Cached value's uniform data field\n// cv = Cached value\n// v = value to upload\n// ud = uniformData\n// uv = uniformValue\n\nimport { BufferResource } from '../../../shared/buffer/BufferResource';\nimport { UniformGroup } from '../../../shared/shader/UniformGroup';\nimport { uniformParsers } from '../../../shared/shader/utils/uniformParsers';\nimport { UNIFORM_TO_ARRAY_SETTERS, UNIFORM_TO_SINGLE_SETTERS } from './generateUniformsSyncTypes';\n\nimport type { UniformsSyncCallback } from '../../../shared/shader/types';\n\nexport function generateUniformsSync(group: UniformGroup, uniformData: Record<string, any>): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n        var name = null;\n    `];\n\n    for (const i in group.uniforms)\n    {\n        if (!uniformData[i])\n        {\n            if (group.uniforms[i] instanceof UniformGroup)\n            {\n                if ((group.uniforms[i] as UniformGroup).ubo)\n                {\n                    funcFragments.push(`\n                        renderer.shader.bindUniformBlock(uv.${i}, \"${i}\");\n                    `);\n                }\n                else\n                {\n                    funcFragments.push(`\n                        renderer.shader.updateUniformGroup(uv.${i});\n                    `);\n                }\n            }\n            else if (group.uniforms[i] instanceof BufferResource)\n            {\n                funcFragments.push(`\n                        renderer.shader.bindBufferResource(uv.${i}, \"${i}\");\n                    `);\n            }\n\n            continue;\n        }\n\n        const uniform = group.uniformStructures[i];\n\n        let parsed = false;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const parser = uniformParsers[j];\n\n            if (uniform.type === parser.type && parser.test(uniform))\n            {\n                funcFragments.push(`name = \"${i}\";`, uniformParsers[j].uniform);\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;\n\n            const template = templateType[uniform.type].replace('location', `ud[\"${i}\"].location`);\n\n            funcFragments.push(`\n            cu = ud[\"${i}\"];\n            cv = cu.value;\n            v = uv[\"${i}\"];\n            ${template};`);\n        }\n    }\n\n    /*\n     * the introduction of syncData is to solve an issue where textures in uniform groups are not set correctly\n     * the texture count was always starting from 0 in each group. This needs to increment each time a texture is used\n     * no matter which group is being used\n     *\n     */\n    // eslint-disable-next-line no-new-func\n    return new Function('ud', 'uv', 'renderer', 'syncData', funcFragments.join('\\n')) as UniformsSyncCallback;\n}\n"],"mappings":";;;;;AAagB,SAAAA,qBAAqBC,KAAA,EAAqBC,WAC1D;EACI,MAAMC,aAAA,GAAgB,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAOtB;EAEU,WAAAC,CAAA,IAAKH,KAAA,CAAMI,QACtB;IACQ,KAACH,WAAY,CAAAE,CAAC,CAClB;MACI,IAAIH,KAAM,CAAAI,QAAA,CAASD,CAAC,aAAaE,YACjC;QACI,IAAKL,KAAM,CAAAI,QAAA,CAASD,CAAC,EAAmBG,GACxC;UACIJ,aAAA,CAAcK,IAAK;AAAA,8DACuBJ,CAAC,MAAMA,CAAC;AAAA,qBACjD;QAAA,CAGL;UACID,aAAA,CAAcK,IAAK;AAAA,gEACyBJ,CAAC;AAAA,qBAC5C;QAAA;MACL,CAEK,UAAAH,KAAA,CAAMI,QAAS,CAAAD,CAAC,aAAaK,cACtC;QACIN,aAAA,CAAcK,IAAK;AAAA,gEAC6BJ,CAAC,MAAMA,CAAC;AAAA,qBACnD;MAAA;MAGT;IAAA;IAGE,MAAAM,OAAA,GAAUT,KAAM,CAAAU,iBAAA,CAAkBP,CAAC;IAEzC,IAAIQ,MAAS;IAEb,SAASC,CAAI,MAAGA,CAAI,GAAAC,cAAA,CAAeC,MAAA,EAAQF,CAC3C;MACU,MAAAG,MAAA,GAASF,cAAA,CAAeD,CAAC;MAE/B,IAAIH,OAAA,CAAQO,IAAS,KAAAD,MAAA,CAAOC,IAAA,IAAQD,MAAO,CAAAE,IAAA,CAAKR,OAAO,CACvD;QACIP,aAAA,CAAcK,IAAA,CAAgB,WAAAJ,CAAC,MAAMU,cAAe,CAAAD,CAAC,EAAEH,OAAO;QACrDE,MAAA;QAET;MAAA;IACJ;IAGJ,IAAI,CAACA,MACL;MACI,MAAMO,YAAe,GAAAT,OAAA,CAAQU,IAAS,SAAIC,yBAA4B,GAAAC,wBAAA;MAEhE,MAAAC,QAAA,GAAWJ,YAAA,CAAaT,OAAQ,CAAAO,IAAI,EAAEO,OAAQ,aAAmB,OAAApB,CAAc;MAErFD,aAAA,CAAcK,IAAK;AAAA,uBACRJ,CAAC;AAAA;AAAA,sBAEFA,CAAC;AAAA,cACTmB,QAAW;IAAA;EACjB;EAUG,WAAIE,QAAA,CAAS,IAAM,QAAM,YAAY,UAAY,EAAAtB,aAAA,CAAcuB,IAAK,KAAI,CAAC;AACpF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}