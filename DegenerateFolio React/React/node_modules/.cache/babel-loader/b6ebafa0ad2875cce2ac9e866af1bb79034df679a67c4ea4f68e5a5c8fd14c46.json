{"ast":null,"code":"import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet.mjs';\n\"use strict\";\nclass RenderGroup {\n  constructor(root) {\n    this.renderPipeId = \"renderGroup\";\n    this.root = null;\n    this.canBundle = false;\n    this.renderGroupParent = null;\n    this.renderGroupChildren = [];\n    this.worldTransform = new Matrix();\n    this.worldColorAlpha = 4294967295;\n    this.worldColor = 16777215;\n    this.worldAlpha = 1;\n    // these updates are transform changes..\n    this.childrenToUpdate = /* @__PURE__ */Object.create(null);\n    this.updateTick = 0;\n    // these update are renderable changes..\n    this.childrenRenderablesToUpdate = {\n      list: [],\n      index: 0\n    };\n    // other\n    this.structureDidChange = true;\n    this.instructionSet = new InstructionSet();\n    this._onRenderContainers = [];\n    this.root = root;\n    if (root._onRender) this.addOnRender(root);\n    root.didChange = true;\n    const children = root.children;\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  get localTransform() {\n    return this.root.localTransform;\n  }\n  addRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.renderGroupParent) {\n      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n    }\n    renderGroupChild.renderGroupParent = this;\n    this.renderGroupChildren.push(renderGroupChild);\n  }\n  _removeRenderGroupChild(renderGroupChild) {\n    const index = this.renderGroupChildren.indexOf(renderGroupChild);\n    if (index > -1) {\n      this.renderGroupChildren.splice(index, 1);\n    }\n    renderGroupChild.renderGroupParent = null;\n  }\n  addChild(child) {\n    this.structureDidChange = true;\n    child.parentRenderGroup = this;\n    child.updateTick = -1;\n    if (child.parent === this.root) {\n      child.relativeRenderGroupDepth = 1;\n    } else {\n      child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n    }\n    child.didChange = true;\n    this.onChildUpdate(child);\n    if (child.renderGroup) {\n      this.addRenderGroupChild(child.renderGroup);\n      return;\n    }\n    if (child._onRender) this.addOnRender(child);\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  removeChild(child) {\n    this.structureDidChange = true;\n    if (child._onRender) {\n      if (!child.renderGroup) {\n        this.removeOnRender(child);\n      }\n    }\n    child.parentRenderGroup = null;\n    if (child.renderGroup) {\n      this._removeRenderGroupChild(child.renderGroup);\n      return;\n    }\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  removeChildren(children) {\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  onChildUpdate(child) {\n    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n        index: 0,\n        list: []\n      };\n    }\n    childrenToUpdate.list[childrenToUpdate.index++] = child;\n  }\n  // SHOULD THIS BE HERE?\n  updateRenderable(container) {\n    if (container.globalDisplayStatus < 7) return;\n    container.didViewUpdate = false;\n    this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);\n  }\n  onChildViewUpdate(child) {\n    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n  }\n  get isRenderable() {\n    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n  }\n  /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined 'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */\n  addOnRender(container) {\n    this._onRenderContainers.push(container);\n  }\n  removeOnRender(container) {\n    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n  }\n  runOnRender() {\n    for (let i = 0; i < this._onRenderContainers.length; i++) {\n      this._onRenderContainers[i]._onRender();\n    }\n  }\n  getChildren(out = []) {\n    const children = this.root.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n  _getChildren(container, out = []) {\n    out.push(container);\n    if (container.renderGroup) return out;\n    const children = container.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n}\nexport { RenderGroup };","map":{"version":3,"names":["RenderGroup","constructor","root","renderPipeId","canBundle","renderGroupParent","renderGroupChildren","worldTransform","Matrix","worldColorAlpha","worldColor","worldAlpha","childrenToUpdate","Object","create","updateTick","childrenRenderablesToUpdate","list","index","structureDidChange","instructionSet","InstructionSet","_onRenderContainers","_onRender","addOnRender","didChange","children","i","length","addChild","localTransform","addRenderGroupChild","renderGroupChild","_removeRenderGroupChild","push","indexOf","splice","child","parentRenderGroup","parent","relativeRenderGroupDepth","onChildUpdate","renderGroup","removeChild","removeOnRender","removeChildren","updateRenderable","container","globalDisplayStatus","didViewUpdate","renderPipes","onChildViewUpdate","isRenderable","localDisplayStatus","runOnRender","getChildren","out","_getChildren"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/container/RenderGroup.ts"],"sourcesContent":["import { Matrix } from '../../maths/matrix/Matrix';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\n\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { Container } from './Container';\n\n/**\n * The render group is the base class for all render groups\n * It is used to render a group of containers together\n * @memberof rendering\n */\nexport class RenderGroup implements Instruction\n{\n    public renderPipeId = 'renderGroup';\n    public root: Container = null;\n\n    public canBundle = false;\n\n    public renderGroupParent: RenderGroup = null;\n    public renderGroupChildren: RenderGroup[] = [];\n\n    public worldTransform: Matrix = new Matrix();\n    public worldColorAlpha = 0xffffffff;\n    public worldColor = 0xffffff;\n    public worldAlpha = 1;\n\n    // these updates are transform changes..\n    public readonly childrenToUpdate: Record<number, { list: Container[]; index: number; }> = Object.create(null);\n    public updateTick = 0;\n\n    // these update are renderable changes..\n    public readonly childrenRenderablesToUpdate: { list: Container[]; index: number; } = { list: [], index: 0 };\n\n    // other\n    public structureDidChange = true;\n\n    public instructionSet: InstructionSet = new InstructionSet();\n\n    private readonly _onRenderContainers: Container[] = [];\n\n    constructor(root: Container)\n    {\n        this.root = root;\n\n        if (root._onRender) this.addOnRender(root);\n\n        root.didChange = true;\n\n        const children = root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.addChild(children[i]);\n        }\n    }\n\n    get localTransform()\n    {\n        return this.root.localTransform;\n    }\n\n    public addRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        if (renderGroupChild.renderGroupParent)\n        {\n            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n        }\n\n        renderGroupChild.renderGroupParent = this;\n\n        this.renderGroupChildren.push(renderGroupChild);\n    }\n\n    private _removeRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        const index = this.renderGroupChildren.indexOf(renderGroupChild);\n\n        if (index > -1)\n        {\n            this.renderGroupChildren.splice(index, 1);\n        }\n\n        renderGroupChild.renderGroupParent = null;\n    }\n\n    public addChild(child: Container)\n    {\n        this.structureDidChange = true;\n\n        child.parentRenderGroup = this;\n\n        child.updateTick = -1;\n\n        if (child.parent === this.root)\n        {\n            child.relativeRenderGroupDepth = 1;\n        }\n        else\n        {\n            child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n        }\n\n        child.didChange = true;\n        this.onChildUpdate(child);\n\n        if (child.renderGroup)\n        {\n            this.addRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        if (child._onRender) this.addOnRender(child);\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.addChild(children[i]);\n        }\n    }\n\n    public removeChild(child: Container)\n    {\n        // remove all the children...\n        this.structureDidChange = true;\n\n        if (child._onRender)\n        {\n            // Remove the child to the onRender list under the following conditions:\n            // 1. If the child is not a render group.\n            // 2. If the child is a render group root of this render group - which it can't be removed from in this case.\n            if (!child.renderGroup)\n            {\n                this.removeOnRender(child);\n            }\n        }\n\n        child.parentRenderGroup = null;\n\n        if (child.renderGroup)\n        {\n            this._removeRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public removeChildren(children: Container[])\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public onChildUpdate(child: Container)\n    {\n        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n\n        if (!childrenToUpdate)\n        {\n            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n                index: 0,\n                list: [],\n            };\n        }\n\n        childrenToUpdate.list[childrenToUpdate.index++] = child;\n    }\n\n    // SHOULD THIS BE HERE?\n    public updateRenderable(container: Container)\n    {\n        // only update if its visible!\n        if (container.globalDisplayStatus < 0b111) return;\n\n        container.didViewUpdate = false;\n        // actually updates the renderable..\n        this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);\n    }\n\n    public onChildViewUpdate(child: Container)\n    {\n        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n    }\n\n    get isRenderable(): boolean\n    {\n        return (this.root.localDisplayStatus === 0b111 && this.worldAlpha > 0);\n    }\n\n    /**\n     * adding a container to the onRender list will make sure the user function\n     * passed in to the user defined 'onRender` callBack\n     * @param container - the container to add to the onRender list\n     */\n    public addOnRender(container: Container)\n    {\n        this._onRenderContainers.push(container);\n    }\n\n    public removeOnRender(container: Container)\n    {\n        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n    }\n\n    public runOnRender()\n    {\n        for (let i = 0; i < this._onRenderContainers.length; i++)\n        {\n            this._onRenderContainers[i]._onRender();\n        }\n    }\n\n    public getChildren(out: Container[] = []): Container[]\n    {\n        const children = this.root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n\n    private _getChildren(container: Container, out: Container[] = []): Container[]\n    {\n        out.push(container);\n\n        if (container.renderGroup) return out;\n\n        const children = container.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}