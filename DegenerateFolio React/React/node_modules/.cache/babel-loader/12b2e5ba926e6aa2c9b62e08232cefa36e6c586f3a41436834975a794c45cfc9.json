{"ast":null,"code":"import { sanitize, Struct } from '@polkadot/types-codec';\nimport { getTypeDef, TypeDefInfo, withTypeString } from '@polkadot/types-create';\nimport { assertUnreachable, isNumber, isString, logger, objectSpread, stringCamelCase, stringify, stringPascalCase } from '@polkadot/util';\nconst l = logger('PortableRegistry');\nconst TYPE_UNWRAP = {\n  toNumber: () => -1\n};\nconst PRIMITIVE_ALIAS = {\n  Char: 'u32',\n  // Rust char is 4-bytes\n  Str: 'Text'\n};\nconst PATHS_ALIAS = splitNamespace([\n// full matching on exact names...\n// these are well-known types with additional encoding\n'sp_core::crypto::AccountId32', 'sp_runtime::generic::era::Era', 'sp_runtime::multiaddress::MultiAddress',\n// ethereum overrides (Frontier, Moonbeam, Polkadot claims)\n'fp_account::AccountId20', 'account::AccountId20', 'polkadot_runtime_common::claims::EthereumAddress',\n// weights 2 is a structure, however for 1.5. with a single field it\n// should be flatenned (can appear in Compact<Weight> extrinsics)\n'frame_support::weights::weight_v2::Weight', 'sp_weights::weight_v2::Weight',\n// wildcard matching in place...\n// these have a specific encoding or logic, use a wildcard for {pallet, darwinia}_democracy\n'*_democracy::vote::Vote', '*_conviction_voting::vote::Vote', '*_identity::types::Data',\n// these are opaque Vec<u8> wrappers\n'sp_core::OpaqueMetadata', 'sp_core::OpaquePeerId', 'sp_core::offchain::OpaqueMultiaddr',\n// shorten some well-known types\n'primitive_types::*', 'sp_arithmetic::per_things::*',\n// runtime\n'*_runtime::RuntimeCall', '*_runtime::RuntimeEvent',\n// ink!\n'ink::env::types::*', 'ink::primitives::types::*', 'ink_env::types::*', 'ink_primitives::types::*',\n// noir\n'np_runtime::accountname::AccountName', 'np_runtime::universaladdress::UniversalAddress']);\nconst PATHS_SET = splitNamespace(['pallet_identity::types::BitFlags']);\nconst BITVEC_NS_LSB = ['bitvec::order::Lsb0', 'BitOrderLsb0'];\nconst BITVEC_NS_MSB = ['bitvec::order::Msb0', 'BitOrderMsb0'];\nconst BITVEC_NS = [...BITVEC_NS_LSB, ...BITVEC_NS_MSB];\nconst WRAPPERS = ['BoundedBTreeMap', 'BoundedBTreeSet', 'BoundedVec', 'Box', 'BTreeMap', 'BTreeSet', 'Cow', 'Option', 'Range', 'RangeInclusive', 'Result', 'WeakBoundedVec', 'WrapperKeepOpaque', 'WrapperOpaque'];\nconst RESERVED = [\n// JS reserved words\n'entries', 'keys', 'new', 'size',\n// exposed by all Codec objects\n'hash', 'registry'];\nconst PATH_RM_INDEX_1 = ['generic', 'misc', 'pallet', 'traits', 'types'];\n/** @internal Converts a Text[] into string[] (used as part of definitions) */\nfunction sanitizeDocs(docs) {\n  const count = docs.length;\n  const result = new Array(count);\n  for (let i = 0; i < count; i++) {\n    result[i] = docs[i].toString();\n  }\n  return result;\n}\n/** @internal Split a namespace with :: into individual parts */\nfunction splitNamespace(values) {\n  const count = values.length;\n  const result = new Array(count);\n  for (let i = 0; i < count; i++) {\n    result[i] = values[i].split('::');\n  }\n  return result;\n}\n/** @internal Match a namespace based on parts (alongside wildcards) */\nfunction matchParts(first, second) {\n  return first.length === second.length && first.every((a, index) => {\n    const b = second[index].toString();\n    if (a === '*' || a === b) {\n      return true;\n    }\n    if (a.includes('*') && a.includes('_') && b.includes('_')) {\n      let suba = a.split('_');\n      let subb = b.split('_');\n      // match initial *'s to multiples if we have a match for the other\n      if (suba[0] === '*') {\n        const indexOf = subb.indexOf(suba[1]);\n        if (indexOf !== -1) {\n          suba = suba.slice(1);\n          subb = subb.slice(indexOf);\n        }\n      }\n      // check for * matches at the end, adjust accordingly\n      if (suba.length === 2 && suba[1] === '*' && suba[0] === subb[0]) {\n        return true;\n      }\n      return matchParts(suba, subb);\n    }\n    return false;\n  });\n}\n/** @internal check if the path matches the PATHS_ALIAS (with wildcards) */\nfunction getAliasPath({\n  def,\n  path\n}) {\n  // specific logic for weights - we override when non-complex struct\n  // (as applied in Weight 1.5 where we also have `Compact<{ refTime: u64 }>)\n  if (['frame_support::weights::weight_v2::Weight', 'sp_weights::weight_v2::Weight'].includes(path.join('::'))) {\n    return !def.isComposite || def.asComposite.fields.length === 1 ? 'WeightV1' : null;\n  }\n  // TODO We need to handle ink! Balance in some way\n  return path.length && PATHS_ALIAS.some(a => matchParts(a, path)) ? path[path.length - 1].toString() : null;\n}\n/** @internal Converts a type name into a JS-API compatible name */\nfunction extractNameFlat(portable, lookupIndex, params, path, isInternal = false) {\n  const count = path.length;\n  // if we have no path or determined as a wrapper, we just skip it\n  if (count === 0 || WRAPPERS.includes(path[count - 1].toString())) {\n    return null;\n  }\n  const camels = new Array(count);\n  const lowers = new Array(count);\n  // initially just create arrays of the camelCase and lowercase path\n  // parts - we will check these to extract the final values. While\n  // we have 2 loops here, we also don't do the same operation twice\n  for (let i = 0; i < count; i++) {\n    const c = stringPascalCase(isInternal ? path[i].replace('pallet_', '') : path[i]);\n    const l = c.toLowerCase();\n    camels[i] = c;\n    lowers[i] = l;\n  }\n  let name = '';\n  for (let i = 0; i < count; i++) {\n    const l = lowers[i];\n    // Remove ::{generic, misc, pallet, traits, types}::\n    if (i !== 1 || !PATH_RM_INDEX_1.includes(l)) {\n      // sp_runtime::generic::digest::Digest -> sp_runtime::generic::Digest\n      // sp_runtime::multiaddress::MultiAddress -> sp_runtime::MultiAddress\n      if (l !== lowers[i + 1]) {\n        name += camels[i];\n      }\n    }\n  }\n  // do magic for RawOrigin lookup, e.g. pallet_collective::RawOrigin\n  if (camels[1] === 'RawOrigin' && count === 2 && params.length === 2 && params[1].type.isSome) {\n    const instanceType = portable[params[1].type.unwrap().toNumber()];\n    if (instanceType.type.path.length === 2) {\n      name = `${name}${instanceType.type.path[1].toString()}`;\n    }\n  }\n  return {\n    lookupIndex,\n    name,\n    params\n  };\n}\n/** @internal Alias for extractNameFlat with PortableType as a last parameter */\nfunction extractName(portable, lookupIndex, {\n  type: {\n    params,\n    path\n  }\n}) {\n  return extractNameFlat(portable, lookupIndex, params, path);\n}\n/** @internal Check for dupes from a specific index onwards */\nfunction nextDupeMatches(name, startAt, names) {\n  const result = [names[startAt]];\n  for (let i = startAt + 1, count = names.length; i < count; i++) {\n    const v = names[i];\n    if (v.name === name) {\n      result.push(v);\n    }\n  }\n  return result;\n}\n/** @internal Checks to see if a type is a full duplicate (with all params matching) */\nfunction rewriteDupes(input, rewrite) {\n  const count = input.length;\n  for (let i = 0; i < count; i++) {\n    const a = input[i];\n    for (let j = i + 1; j < count; j++) {\n      const b = input[j];\n      // if the indexes are not the same and the names match, we have a dupe\n      if (a.lookupIndex !== b.lookupIndex && a.name === b.name) {\n        return false;\n      }\n    }\n  }\n  // add all the adjusted values to the rewite map\n  for (let i = 0; i < count; i++) {\n    const p = input[i];\n    rewrite[p.lookupIndex] = p.name;\n  }\n  return true;\n}\n/** @internal Find duplicates and adjust the names based on parameters */\nfunction removeDupeNames(lookup, portable, names) {\n  const rewrite = {};\n  return names.map((original, startAt) => {\n    const {\n      lookupIndex,\n      name,\n      params\n    } = original;\n    if (!name) {\n      // the name is empty (this is not expected, but have a failsafe)\n      return null;\n    } else if (rewrite[lookupIndex]) {\n      // we have already rewritten this one, we can skip it\n      return original;\n    }\n    // those where the name is matching starting from this index\n    const allSame = nextDupeMatches(name, startAt, names);\n    // we only have one, so all ok\n    if (allSame.length === 1) {\n      return original;\n    }\n    // are there param differences between matching names\n    const anyDiff = allSame.some(o => params.length !== o.params.length || params.some((p, index) => !p.name.eq(o.params[index].name) || p.type.unwrapOr(TYPE_UNWRAP).toNumber() !== o.params[index].type.unwrapOr(TYPE_UNWRAP).toNumber()));\n    // everything matches, we can combine these\n    if (!anyDiff) {\n      return original;\n    }\n    // TODO We probably want to attach all the indexes with differences,\n    // not just the first\n    // find the first parameter that yields differences\n    const paramIdx = params.findIndex(({\n      type\n    }, index) => allSame.every(({\n      params\n    }, aIndex) => params[index].type.isSome && (aIndex === 0 || !params[index].type.eq(type))));\n    // No param found that is different\n    if (paramIdx === -1) {\n      return original;\n    }\n    // see if using the param type helps\n    const sameCount = allSame.length;\n    const adjusted = new Array(sameCount);\n    // loop through all, specifically checking that index where the\n    // first param yields differences\n    for (let i = 0; i < sameCount; i++) {\n      const {\n        lookupIndex,\n        name,\n        params\n      } = allSame[i];\n      const {\n        def,\n        path\n      } = lookup.getSiType(params[paramIdx].type.unwrap());\n      // if it is not a primitive and it doesn't have a path, we really cannot\n      // do anything at this point\n      if (!def.isPrimitive && !path.length) {\n        return null;\n      }\n      adjusted[i] = {\n        lookupIndex,\n        name: def.isPrimitive ? `${name}${def.asPrimitive.toString()}` : `${name}${path[path.length - 1].toString()}`\n      };\n    }\n    // check to see if the adjusted names have no issues\n    if (rewriteDupes(adjusted, rewrite)) {\n      return original;\n    }\n    // TODO This is duplicated from the section just above...\n    // ... we certainly need a better solution here\n    //\n    // Last-ditch effort to use the full type path - ugly\n    // loop through all, specifically checking that index where the\n    // first param yields differences\n    for (let i = 0; i < sameCount; i++) {\n      const {\n        lookupIndex,\n        name,\n        params\n      } = allSame[i];\n      const {\n        def,\n        path\n      } = lookup.getSiType(params[paramIdx].type.unwrap());\n      const flat = extractNameFlat(portable, lookupIndex, params, path, true);\n      if (def.isPrimitive || !flat) {\n        return null;\n      }\n      adjusted[i] = {\n        lookupIndex,\n        name: `${name}${flat.name}`\n      };\n    }\n    // check to see if the adjusted names have no issues\n    if (rewriteDupes(adjusted, rewrite)) {\n      return original;\n    }\n    return null;\n  }).filter(n => !!n).map(({\n    lookupIndex,\n    name,\n    params\n  }) => ({\n    lookupIndex,\n    name: rewrite[lookupIndex] || name,\n    params\n  }));\n}\n/** @internal Detect on-chain types (AccountId/Signature) as set as the default */\nfunction registerTypes(lookup, lookups, names, params) {\n  // Register the types we extracted\n  lookup.registry.register(lookups);\n  // Try and extract the AccountId/Address/Signature type from UncheckedExtrinsic\n  if (params.SpRuntimeUncheckedExtrinsic) {\n    // Address, Call, Signature, Extra\n    const [addrParam,, sigParam] = params.SpRuntimeUncheckedExtrinsic;\n    const siAddress = lookup.getSiType(addrParam.type.unwrap());\n    const siSignature = lookup.getSiType(sigParam.type.unwrap());\n    const nsSignature = siSignature.path.join('::');\n    let nsAccountId = siAddress.path.join('::');\n    const isMultiAddress = nsAccountId === 'sp_runtime::multiaddress::MultiAddress';\n    // With multiaddress, we check the first type param again\n    if (isMultiAddress) {\n      // AccountId, AccountIndex\n      const [idParam] = siAddress.params;\n      nsAccountId = lookup.getSiType(idParam.type.unwrap()).path.join('::');\n    }\n    lookup.registry.register({\n      // known: account::AccountId20, fp_account::AccountId20, primitive_types::H160\n      AccountId: nsAccountId.endsWith('::AccountId20') || nsAccountId.endsWith('::H160') ? 'AccountId20' : 'AccountId32',\n      Address: isMultiAddress ? 'MultiAddress' : 'AccountId',\n      ExtrinsicSignature: ['sp_runtime::MultiSignature'].includes(nsSignature) ? 'MultiSignature' : names[sigParam.type.unwrap().toNumber()] || 'MultiSignature'\n    });\n  }\n}\n/**\n * @internal Extracts aliases based on what we know the runtime config looks like in a\n * Substrate chain. Specifically we want to have access to the Call and Event params\n **/\nfunction extractAliases(params, isContract) {\n  const hasParams = Object.keys(params).some(k => !k.startsWith('Pallet'));\n  const alias = {};\n  if (params.SpRuntimeUncheckedExtrinsic) {\n    // Address, Call, Signature, Extra\n    const [, {\n      type\n    }] = params.SpRuntimeUncheckedExtrinsic;\n    alias[type.unwrap().toNumber()] = 'Call';\n  } else if (hasParams && !isContract) {\n    l.warn('Unable to determine runtime Call type, cannot inspect sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic');\n  }\n  if (params.FrameSystemEventRecord) {\n    // Event, Topic\n    const [{\n      type\n    }] = params.FrameSystemEventRecord;\n    alias[type.unwrap().toNumber()] = 'Event';\n  } else if (hasParams && !isContract) {\n    l.warn('Unable to determine runtime Event type, cannot inspect frame_system::EventRecord');\n  }\n  return alias;\n}\n/** @internal Extracts all the intreresting type information for this registry */\nfunction extractTypeInfo(lookup, portable) {\n  const nameInfo = [];\n  const types = {};\n  for (let i = 0, count = portable.length; i < count; i++) {\n    const type = portable[i];\n    const lookupIndex = type.id.toNumber();\n    const extracted = extractName(portable, lookupIndex, portable[i]);\n    if (extracted) {\n      nameInfo.push(extracted);\n    }\n    types[lookupIndex] = type;\n  }\n  const lookups = {};\n  const names = {};\n  const params = {};\n  const dedup = removeDupeNames(lookup, portable, nameInfo);\n  for (let i = 0, count = dedup.length; i < count; i++) {\n    const {\n      lookupIndex,\n      name,\n      params: p\n    } = dedup[i];\n    names[lookupIndex] = name;\n    lookups[name] = lookup.registry.createLookupType(lookupIndex);\n    params[name] = p;\n  }\n  return {\n    lookups,\n    names,\n    params,\n    types\n  };\n}\nexport class PortableRegistry extends Struct {\n  __internal__alias;\n  __internal__lookups;\n  __internal__names;\n  __internal__params;\n  __internal__typeDefs = {};\n  __internal__types;\n  constructor(registry, value, isContract) {\n    // const timeStart = performance.now()\n    super(registry, {\n      types: 'Vec<PortableType>'\n    }, value);\n    const {\n      lookups,\n      names,\n      params,\n      types\n    } = extractTypeInfo(this, this.types);\n    this.__internal__alias = extractAliases(params, isContract);\n    this.__internal__lookups = lookups;\n    this.__internal__names = names;\n    this.__internal__params = params;\n    this.__internal__types = types;\n    // console.log('PortableRegistry', `${(performance.now() - timeStart).toFixed(2)}ms`)\n  }\n  /**\n   * @description Returns all the available type names for this chain\n   **/\n  get names() {\n    return Object.values(this.__internal__names).sort();\n  }\n  /**\n   * @description Returns all the available parameterized types for this chain\n   **/\n  get paramTypes() {\n    return this.__internal__params;\n  }\n  /**\n   * @description The types of the registry\n   */\n  get types() {\n    return this.getT('types');\n  }\n  /**\n   * @description Register all available types into the registry (generally for internal usage)\n   */\n  register() {\n    registerTypes(this, this.__internal__lookups, this.__internal__names, this.__internal__params);\n  }\n  /**\n   * @description Returns the name for a specific lookup\n   */\n  getName(lookupId) {\n    return this.__internal__names[this.__internal__getLookupId(lookupId)];\n  }\n  /**\n   * @description Finds a specific type in the registry\n   */\n  getSiType(lookupId) {\n    // NOTE catch-22 - this may already be used as part of the constructor, so\n    // ensure that we have actually initialized it correctly\n    const found = (this.__internal__types || this.types)[this.__internal__getLookupId(lookupId)];\n    if (!found) {\n      throw new Error(`PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);\n    }\n    return found.type;\n  }\n  /**\n   * @description Lookup the type definition for the index\n   */\n  getTypeDef(lookupId) {\n    const lookupIndex = this.__internal__getLookupId(lookupId);\n    if (!this.__internal__typeDefs[lookupIndex]) {\n      const lookupName = this.__internal__names[lookupIndex];\n      const empty = {\n        info: TypeDefInfo.DoNotConstruct,\n        lookupIndex,\n        lookupName,\n        type: this.registry.createLookupType(lookupIndex)\n      };\n      // Set named items since we will get into circular lookups along the way\n      if (lookupName) {\n        this.__internal__typeDefs[lookupIndex] = empty;\n      }\n      const extracted = this.__internal__extract(this.getSiType(lookupId), lookupIndex);\n      // For non-named items, we only set this right at the end\n      if (!lookupName) {\n        this.__internal__typeDefs[lookupIndex] = empty;\n      }\n      Object.keys(extracted).forEach(k => {\n        if (k !== 'lookupName' || extracted[k]) {\n          // these are safe since we are looking through the keys as set\n          this.__internal__typeDefs[lookupIndex][k] = extracted[k];\n        }\n      });\n      // don't set lookupName on lower-level, we want to always direct to the type\n      if (extracted.info === TypeDefInfo.Plain) {\n        this.__internal__typeDefs[lookupIndex].lookupNameRoot = this.__internal__typeDefs[lookupIndex].lookupName;\n        delete this.__internal__typeDefs[lookupIndex].lookupName;\n      }\n    }\n    return this.__internal__typeDefs[lookupIndex];\n  }\n  /**\n   * @description For a specific field, perform adjustments to not have built-in conflicts\n   */\n  sanitizeField(name) {\n    let nameField = null;\n    let nameOrig = null;\n    if (name.isSome) {\n      nameField = stringCamelCase(name.unwrap());\n      if (nameField.includes('#')) {\n        nameOrig = nameField;\n        nameField = nameOrig.replace(/#/g, '_');\n      } else if (RESERVED.includes(nameField)) {\n        nameOrig = nameField;\n        nameField = `${nameField}_`;\n      }\n    }\n    return [nameField, nameOrig];\n  }\n  /** @internal Creates a TypeDef based on an internal lookupId */\n  __internal__createSiDef(lookupId) {\n    const typeDef = this.getTypeDef(lookupId);\n    const lookupIndex = lookupId.toNumber();\n    // Setup for a lookup on complex types\n    return [TypeDefInfo.DoNotConstruct, TypeDefInfo.Enum, TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName ? {\n      docs: typeDef.docs,\n      info: TypeDefInfo.Si,\n      lookupIndex,\n      lookupName: this.__internal__names[lookupIndex],\n      type: this.registry.createLookupType(lookupId)\n    } : typeDef;\n  }\n  /** @internal Converts a lookupId input to the actual lookup index */\n  __internal__getLookupId(lookupId) {\n    if (isString(lookupId)) {\n      if (!this.registry.isLookupType(lookupId)) {\n        throw new Error(`PortableRegistry: Expected a lookup string type, found ${lookupId}`);\n      }\n      return parseInt(lookupId.replace('Lookup', ''), 10);\n    } else if (isNumber(lookupId)) {\n      return lookupId;\n    }\n    return lookupId.toNumber();\n  }\n  /** @internal Converts a type into a TypeDef for Codec usage */\n  __internal__extract(type, lookupIndex) {\n    const namespace = type.path.join('::');\n    let typeDef;\n    const aliasType = this.__internal__alias[lookupIndex] || getAliasPath(type);\n    try {\n      if (aliasType) {\n        typeDef = this.__internal__extractAliasPath(lookupIndex, aliasType);\n      } else {\n        switch (type.def.type) {\n          case 'Array':\n            typeDef = this.__internal__extractArray(lookupIndex, type.def.asArray);\n            break;\n          case 'BitSequence':\n            typeDef = this.__internal__extractBitSequence(lookupIndex, type.def.asBitSequence);\n            break;\n          case 'Compact':\n            typeDef = this.__internal__extractCompact(lookupIndex, type.def.asCompact);\n            break;\n          case 'Composite':\n            typeDef = this.__internal__extractComposite(lookupIndex, type, type.def.asComposite);\n            break;\n          case 'HistoricMetaCompat':\n            typeDef = this.__internal__extractHistoric(lookupIndex, type.def.asHistoricMetaCompat);\n            break;\n          case 'Primitive':\n            typeDef = this.__internal__extractPrimitive(lookupIndex, type);\n            break;\n          case 'Sequence':\n            typeDef = this.__internal__extractSequence(lookupIndex, type.def.asSequence);\n            break;\n          case 'Tuple':\n            typeDef = this.__internal__extractTuple(lookupIndex, type.def.asTuple);\n            break;\n          case 'Variant':\n            typeDef = this.__internal__extractVariant(lookupIndex, type, type.def.asVariant);\n            break;\n          default:\n            assertUnreachable(type.def.type);\n        }\n      }\n    } catch (error) {\n      throw new Error(`PortableRegistry: ${lookupIndex}${namespace ? ` (${namespace})` : ''}: Error extracting ${stringify(type)}: ${error.message}`);\n    }\n    return objectSpread({\n      docs: sanitizeDocs(type.docs),\n      namespace\n    }, typeDef);\n  }\n  /** @internal Extracts a ScaleInfo Array into TypeDef.VecFixed */\n  __internal__extractArray(_, {\n    len,\n    type\n  }) {\n    const length = len.toNumber();\n    if (length > 2048) {\n      throw new Error('Only support for [Type; <length>], where length <= 2048');\n    }\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.VecFixed,\n      length,\n      sub: this.__internal__createSiDef(type)\n    });\n  }\n  /** @internal Extracts a ScaleInfo BitSequence into TypeDef.Plain */\n  __internal__extractBitSequence(_, {\n    bitOrderType,\n    bitStoreType\n  }) {\n    // With the v3 of scale-info this swapped around, but obviously the decoder cannot determine\n    // the order. With that in-mind, we apply a detection for LSb0/Msb and set accordingly\n    const a = this.__internal__createSiDef(bitOrderType);\n    const b = this.__internal__createSiDef(bitStoreType);\n    const [bitOrder, bitStore] = BITVEC_NS.includes(a.namespace || '') ? [a, b] : [b, a];\n    if (!bitOrder.namespace || !BITVEC_NS.includes(bitOrder.namespace)) {\n      throw new Error(`Unexpected bitOrder found as ${bitOrder.namespace || '<unknown>'}`);\n    } else if (bitStore.info !== TypeDefInfo.Plain || bitStore.type !== 'u8') {\n      throw new Error(`Only u8 bitStore is currently supported, found ${bitStore.type}`);\n    }\n    const isLsb = BITVEC_NS_LSB.includes(bitOrder.namespace);\n    if (!isLsb) {\n      // TODO To remove this limitation, we need to pass an extra info flag\n      // through to the TypeDef (Here we could potentially re-use something\n      // like index (???) to indicate and ensure we use it to pass to the\n      // BitVec constructor - which does handle this type)\n      //\n      // See https://github.com/polkadot-js/api/issues/5588\n      // throw new Error(`Only LSB BitVec is currently supported, found ${bitOrder.namespace}`);\n    }\n    return {\n      info: TypeDefInfo.Plain,\n      type: 'BitVec'\n    };\n  }\n  /** @internal Extracts a ScaleInfo Compact into TypeDef.Compact */\n  __internal__extractCompact(_, {\n    type\n  }) {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Compact,\n      sub: this.__internal__createSiDef(type)\n    });\n  }\n  /** @internal Extracts a ScaleInfo Composite into TypeDef.{BTree*, Range*, Wrapper*} */\n  __internal__extractComposite(lookupIndex, {\n    params,\n    path\n  }, {\n    fields\n  }) {\n    if (path.length) {\n      const pathFirst = path[0].toString();\n      const pathLast = path[path.length - 1].toString();\n      if (path.length === 1 && pathFirst === 'BTreeMap') {\n        if (params.length !== 2) {\n          throw new Error(`BTreeMap requires 2 parameters, found ${params.length}`);\n        }\n        return withTypeString(this.registry, {\n          info: TypeDefInfo.BTreeMap,\n          sub: params.map(({\n            type\n          }) => this.__internal__createSiDef(type.unwrap()))\n        });\n      } else if (path.length === 1 && pathFirst === 'BTreeSet') {\n        if (params.length !== 1) {\n          throw new Error(`BTreeSet requires 1 parameter, found ${params.length}`);\n        }\n        return withTypeString(this.registry, {\n          info: TypeDefInfo.BTreeSet,\n          sub: this.__internal__createSiDef(params[0].type.unwrap())\n        });\n      } else if (['Range', 'RangeInclusive'].includes(pathFirst)) {\n        if (params.length !== 1) {\n          throw new Error(`Range requires 1 parameter, found ${params.length}`);\n        }\n        return withTypeString(this.registry, {\n          info: pathFirst === 'Range' ? TypeDefInfo.Range : TypeDefInfo.RangeInclusive,\n          sub: this.__internal__createSiDef(params[0].type.unwrap()),\n          type: pathFirst\n        });\n      } else if (['WrapperKeepOpaque', 'WrapperOpaque'].includes(pathLast)) {\n        if (params.length !== 1) {\n          throw new Error(`WrapperOpaque requires 1 parameter, found ${params.length}`);\n        }\n        return withTypeString(this.registry, {\n          info: pathLast === 'WrapperKeepOpaque' ? TypeDefInfo.WrapperKeepOpaque : TypeDefInfo.WrapperOpaque,\n          sub: this.__internal__createSiDef(params[0].type.unwrap()),\n          type: pathLast\n        });\n      }\n    }\n    return PATHS_SET.some(p => matchParts(p, path)) ? this.__internal__extractCompositeSet(lookupIndex, params, fields) : this.__internal__extractFields(lookupIndex, fields);\n  }\n  /** @internal Extracts a ScaleInfo CompositeSet into TypeDef.Set */\n  __internal__extractCompositeSet(_, params, fields) {\n    if (params.length !== 1 || fields.length !== 1) {\n      throw new Error('Set handling expects param/field as single entries');\n    }\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Set,\n      length: this.registry.createTypeUnsafe(this.registry.createLookupType(fields[0].type), []).bitLength(),\n      sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(({\n        index,\n        name\n      }) => ({\n        // This will be an issue > 2^53 - 1 ... don't have those (yet)\n        index: index.toNumber(),\n        info: TypeDefInfo.Plain,\n        name: name.toString(),\n        type: 'Null'\n      }))\n    });\n  }\n  /** @internal Extracts ScaleInfo enum/struct fields into TypeDef.{Struct, Tuple} */\n  __internal__extractFields(lookupIndex, fields) {\n    let isStruct = true;\n    let isTuple = true;\n    const count = fields.length;\n    for (let f = 0; f < count; f++) {\n      const {\n        name\n      } = fields[f];\n      isStruct = isStruct && name.isSome;\n      isTuple = isTuple && name.isNone;\n    }\n    if (!isTuple && !isStruct) {\n      throw new Error('Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)');\n    }\n    if (count === 0) {\n      return {\n        info: TypeDefInfo.Null,\n        type: 'Null'\n      };\n    } else if (isTuple && count === 1) {\n      const typeDef = this.__internal__createSiDef(fields[0].type);\n      return objectSpread({}, typeDef, lookupIndex === -1 ? null : {\n        lookupIndex,\n        lookupName: this.__internal__names[lookupIndex],\n        lookupNameRoot: typeDef.lookupName\n      }, fields[0].typeName.isSome ? {\n        typeName: sanitize(fields[0].typeName.unwrap())\n      } : null);\n    }\n    const [sub, alias] = this.__internal__extractFieldsAlias(fields);\n    return withTypeString(this.registry, objectSpread({\n      info: isTuple // Tuple check first\n      ? TypeDefInfo.Tuple : TypeDefInfo.Struct,\n      sub\n    }, alias.size ? {\n      alias\n    } : null, lookupIndex === -1 ? null : {\n      lookupIndex,\n      lookupName: this.__internal__names[lookupIndex]\n    }));\n  }\n  /** @internal Apply field aliassed (with no JS conflicts) */\n  __internal__extractFieldsAlias(fields) {\n    const alias = new Map();\n    const count = fields.length;\n    const sub = new Array(count);\n    for (let i = 0; i < count; i++) {\n      const {\n        docs,\n        name,\n        type,\n        typeName\n      } = fields[i];\n      const typeDef = this.__internal__createSiDef(type);\n      if (name.isNone) {\n        sub[i] = typeDef;\n      } else {\n        const [nameField, nameOrig] = this.sanitizeField(name);\n        if (nameField && nameOrig) {\n          alias.set(nameField, nameOrig);\n        }\n        sub[i] = objectSpread({\n          docs: sanitizeDocs(docs),\n          name: nameField\n        }, typeDef, typeName.isSome ? {\n          typeName: sanitize(typeName.unwrap())\n        } : null);\n      }\n    }\n    return [sub, alias];\n  }\n  /** @internal Extracts an internal Historic (pre V14) type  */\n  __internal__extractHistoric(_, type) {\n    return objectSpread({\n      displayName: type.toString(),\n      isFromSi: true\n    }, getTypeDef(type));\n  }\n  /** @internal Extracts a ScaleInfo Primitive into TypeDef.Plain */\n  __internal__extractPrimitive(_, type) {\n    const typeStr = type.def.asPrimitive.type.toString();\n    return {\n      info: TypeDefInfo.Plain,\n      type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()\n    };\n  }\n  /** @internal Applies an alias path onto the TypeDef */\n  __internal__extractAliasPath(_, type) {\n    return {\n      info: TypeDefInfo.Plain,\n      type\n    };\n  }\n  /** @internal Extracts a ScaleInfo Sequence into TypeDef.Vec (with Bytes shortcut) */\n  __internal__extractSequence(lookupIndex, {\n    type\n  }) {\n    const sub = this.__internal__createSiDef(type);\n    if (sub.type === 'u8') {\n      return {\n        info: TypeDefInfo.Plain,\n        type: 'Bytes'\n      };\n    }\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Vec,\n      lookupIndex,\n      lookupName: this.__internal__names[lookupIndex],\n      sub\n    });\n  }\n  /** @internal Extracts a ScaleInfo Tuple into TypeDef.Tuple */\n  __internal__extractTuple(lookupIndex, ids) {\n    if (ids.length === 0) {\n      return {\n        info: TypeDefInfo.Null,\n        type: 'Null'\n      };\n    } else if (ids.length === 1) {\n      return this.getTypeDef(ids[0]);\n    }\n    const sub = ids.map(t => this.__internal__createSiDef(t));\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Tuple,\n      lookupIndex,\n      lookupName: this.__internal__names[lookupIndex],\n      sub\n    });\n  }\n  /** @internal Extracts a ScaleInfo Variant into TypeDef.{Option, Result, Enum} */\n  __internal__extractVariant(lookupIndex, {\n    params,\n    path\n  }, {\n    variants\n  }) {\n    if (path.length) {\n      const specialVariant = path[0].toString();\n      if (specialVariant === 'Option') {\n        if (params.length !== 1) {\n          throw new Error(`Option requires 1 parameter, found ${params.length}`);\n        }\n        // NOTE This is opt-in (unhandled), not by default\n        // if (sub.type === 'bool') {\n        //   return withTypeString(this.registry, {\n        //     info: TypeDefInfo.Plain,\n        //     type: 'OptionBool'\n        //   });\n        // }\n        return withTypeString(this.registry, {\n          info: TypeDefInfo.Option,\n          sub: this.__internal__createSiDef(params[0].type.unwrap())\n        });\n      } else if (specialVariant === 'Result') {\n        if (params.length !== 2) {\n          throw new Error(`Result requires 2 parameters, found ${params.length}`);\n        }\n        return withTypeString(this.registry, {\n          info: TypeDefInfo.Result,\n          sub: params.map(({\n            type\n          }, index) => objectSpread({\n            name: ['Ok', 'Error'][index]\n          }, this.__internal__createSiDef(type.unwrap())))\n        });\n      }\n    }\n    if (variants.length === 0) {\n      return {\n        info: TypeDefInfo.Null,\n        type: 'Null'\n      };\n    }\n    return this.__internal__extractVariantEnum(lookupIndex, variants);\n  }\n  /** @internal Extracts a ScaleInfo Variant into TypeDef.Enum */\n  __internal__extractVariantEnum(lookupIndex, variants) {\n    const sub = [];\n    // we may get entries out of order, arrange them first before creating with gaps filled\n    // NOTE: Since we mutate, use a copy of the array as an input\n    variants.slice().sort((a, b) => a.index.cmp(b.index)).forEach(({\n      fields,\n      index: bnIndex,\n      name\n    }) => {\n      const index = bnIndex.toNumber();\n      while (sub.length !== index) {\n        sub.push({\n          index: sub.length,\n          info: TypeDefInfo.Null,\n          name: `__Unused${sub.length}`,\n          type: 'Null'\n        });\n      }\n      sub.push(objectSpread(this.__internal__extractFields(-1, fields), {\n        index,\n        name: name.toString()\n      }));\n    });\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Enum,\n      lookupIndex,\n      lookupName: this.__internal__names[lookupIndex],\n      sub\n    });\n  }\n}","map":{"version":3,"names":["sanitize","Struct","getTypeDef","TypeDefInfo","withTypeString","assertUnreachable","isNumber","isString","logger","objectSpread","stringCamelCase","stringify","stringPascalCase","l","TYPE_UNWRAP","toNumber","PRIMITIVE_ALIAS","Char","Str","PATHS_ALIAS","splitNamespace","PATHS_SET","BITVEC_NS_LSB","BITVEC_NS_MSB","BITVEC_NS","WRAPPERS","RESERVED","PATH_RM_INDEX_1","sanitizeDocs","docs","count","length","result","Array","i","toString","values","split","matchParts","first","second","every","a","index","b","includes","suba","subb","indexOf","slice","getAliasPath","def","path","join","isComposite","asComposite","fields","some","extractNameFlat","portable","lookupIndex","params","isInternal","camels","lowers","c","replace","toLowerCase","name","type","isSome","instanceType","unwrap","extractName","nextDupeMatches","startAt","names","v","push","rewriteDupes","input","rewrite","j","p","removeDupeNames","lookup","map","original","allSame","anyDiff","o","eq","unwrapOr","paramIdx","findIndex","aIndex","sameCount","adjusted","getSiType","isPrimitive","asPrimitive","flat","filter","n","registerTypes","lookups","registry","register","SpRuntimeUncheckedExtrinsic","addrParam","sigParam","siAddress","siSignature","nsSignature","nsAccountId","isMultiAddress","idParam","AccountId","endsWith","Address","ExtrinsicSignature","extractAliases","isContract","hasParams","Object","keys","k","startsWith","alias","warn","FrameSystemEventRecord","extractTypeInfo","nameInfo","types","id","extracted","dedup","createLookupType","PortableRegistry","__internal__alias","__internal__lookups","__internal__names","__internal__params","__internal__typeDefs","__internal__types","constructor","value","sort","paramTypes","getT","getName","lookupId","__internal__getLookupId","found","Error","lookupName","empty","info","DoNotConstruct","__internal__extract","forEach","Plain","lookupNameRoot","sanitizeField","nameField","nameOrig","__internal__createSiDef","typeDef","Enum","Si","isLookupType","parseInt","namespace","aliasType","__internal__extractAliasPath","__internal__extractArray","asArray","__internal__extractBitSequence","asBitSequence","__internal__extractCompact","asCompact","__internal__extractComposite","__internal__extractHistoric","asHistoricMetaCompat","__internal__extractPrimitive","__internal__extractSequence","asSequence","__internal__extractTuple","asTuple","__internal__extractVariant","asVariant","error","message","_","len","VecFixed","sub","bitOrderType","bitStoreType","bitOrder","bitStore","isLsb","Compact","pathFirst","pathLast","BTreeMap","BTreeSet","Range","RangeInclusive","WrapperKeepOpaque","WrapperOpaque","__internal__extractCompositeSet","__internal__extractFields","Set","createTypeUnsafe","bitLength","variants","isStruct","isTuple","f","isNone","Null","typeName","__internal__extractFieldsAlias","Tuple","size","Map","set","displayName","isFromSi","typeStr","Vec","ids","t","specialVariant","Option","Result","__internal__extractVariantEnum","cmp","bnIndex"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/metadata/PortableRegistry/PortableRegistry.js"],"sourcesContent":["import { sanitize, Struct } from '@polkadot/types-codec';\nimport { getTypeDef, TypeDefInfo, withTypeString } from '@polkadot/types-create';\nimport { assertUnreachable, isNumber, isString, logger, objectSpread, stringCamelCase, stringify, stringPascalCase } from '@polkadot/util';\nconst l = logger('PortableRegistry');\nconst TYPE_UNWRAP = { toNumber: () => -1 };\nconst PRIMITIVE_ALIAS = {\n    Char: 'u32', // Rust char is 4-bytes\n    Str: 'Text'\n};\nconst PATHS_ALIAS = splitNamespace([\n    // full matching on exact names...\n    // these are well-known types with additional encoding\n    'sp_core::crypto::AccountId32',\n    'sp_runtime::generic::era::Era',\n    'sp_runtime::multiaddress::MultiAddress',\n    // ethereum overrides (Frontier, Moonbeam, Polkadot claims)\n    'fp_account::AccountId20',\n    'account::AccountId20',\n    'polkadot_runtime_common::claims::EthereumAddress',\n    // weights 2 is a structure, however for 1.5. with a single field it\n    // should be flatenned (can appear in Compact<Weight> extrinsics)\n    'frame_support::weights::weight_v2::Weight',\n    'sp_weights::weight_v2::Weight',\n    // wildcard matching in place...\n    // these have a specific encoding or logic, use a wildcard for {pallet, darwinia}_democracy\n    '*_democracy::vote::Vote',\n    '*_conviction_voting::vote::Vote',\n    '*_identity::types::Data',\n    // these are opaque Vec<u8> wrappers\n    'sp_core::OpaqueMetadata',\n    'sp_core::OpaquePeerId',\n    'sp_core::offchain::OpaqueMultiaddr',\n    // shorten some well-known types\n    'primitive_types::*',\n    'sp_arithmetic::per_things::*',\n    // runtime\n    '*_runtime::RuntimeCall',\n    '*_runtime::RuntimeEvent',\n    // ink!\n    'ink::env::types::*',\n    'ink::primitives::types::*',\n    'ink_env::types::*',\n    'ink_primitives::types::*',\n    // noir\n    'np_runtime::accountname::AccountName',\n    'np_runtime::universaladdress::UniversalAddress'\n]);\nconst PATHS_SET = splitNamespace([\n    'pallet_identity::types::BitFlags'\n]);\nconst BITVEC_NS_LSB = ['bitvec::order::Lsb0', 'BitOrderLsb0'];\nconst BITVEC_NS_MSB = ['bitvec::order::Msb0', 'BitOrderMsb0'];\nconst BITVEC_NS = [...BITVEC_NS_LSB, ...BITVEC_NS_MSB];\nconst WRAPPERS = ['BoundedBTreeMap', 'BoundedBTreeSet', 'BoundedVec', 'Box', 'BTreeMap', 'BTreeSet', 'Cow', 'Option', 'Range', 'RangeInclusive', 'Result', 'WeakBoundedVec', 'WrapperKeepOpaque', 'WrapperOpaque'];\nconst RESERVED = [\n    // JS reserved words\n    'entries', 'keys', 'new', 'size',\n    // exposed by all Codec objects\n    'hash', 'registry'\n];\nconst PATH_RM_INDEX_1 = ['generic', 'misc', 'pallet', 'traits', 'types'];\n/** @internal Converts a Text[] into string[] (used as part of definitions) */\nfunction sanitizeDocs(docs) {\n    const count = docs.length;\n    const result = new Array(count);\n    for (let i = 0; i < count; i++) {\n        result[i] = docs[i].toString();\n    }\n    return result;\n}\n/** @internal Split a namespace with :: into individual parts */\nfunction splitNamespace(values) {\n    const count = values.length;\n    const result = new Array(count);\n    for (let i = 0; i < count; i++) {\n        result[i] = values[i].split('::');\n    }\n    return result;\n}\n/** @internal Match a namespace based on parts (alongside wildcards) */\nfunction matchParts(first, second) {\n    return first.length === second.length && first.every((a, index) => {\n        const b = second[index].toString();\n        if ((a === '*') || (a === b)) {\n            return true;\n        }\n        if (a.includes('*') && a.includes('_') && b.includes('_')) {\n            let suba = a.split('_');\n            let subb = b.split('_');\n            // match initial *'s to multiples if we have a match for the other\n            if (suba[0] === '*') {\n                const indexOf = subb.indexOf(suba[1]);\n                if (indexOf !== -1) {\n                    suba = suba.slice(1);\n                    subb = subb.slice(indexOf);\n                }\n            }\n            // check for * matches at the end, adjust accordingly\n            if ((suba.length === 2) && (suba[1] === '*') && (suba[0] === subb[0])) {\n                return true;\n            }\n            return matchParts(suba, subb);\n        }\n        return false;\n    });\n}\n/** @internal check if the path matches the PATHS_ALIAS (with wildcards) */\nfunction getAliasPath({ def, path }) {\n    // specific logic for weights - we override when non-complex struct\n    // (as applied in Weight 1.5 where we also have `Compact<{ refTime: u64 }>)\n    if (['frame_support::weights::weight_v2::Weight', 'sp_weights::weight_v2::Weight'].includes(path.join('::'))) {\n        return !def.isComposite || def.asComposite.fields.length === 1\n            ? 'WeightV1'\n            : null;\n    }\n    // TODO We need to handle ink! Balance in some way\n    return path.length && PATHS_ALIAS.some((a) => matchParts(a, path))\n        ? path[path.length - 1].toString()\n        : null;\n}\n/** @internal Converts a type name into a JS-API compatible name */\nfunction extractNameFlat(portable, lookupIndex, params, path, isInternal = false) {\n    const count = path.length;\n    // if we have no path or determined as a wrapper, we just skip it\n    if (count === 0 || WRAPPERS.includes(path[count - 1].toString())) {\n        return null;\n    }\n    const camels = new Array(count);\n    const lowers = new Array(count);\n    // initially just create arrays of the camelCase and lowercase path\n    // parts - we will check these to extract the final values. While\n    // we have 2 loops here, we also don't do the same operation twice\n    for (let i = 0; i < count; i++) {\n        const c = stringPascalCase(isInternal\n            ? path[i].replace('pallet_', '')\n            : path[i]);\n        const l = c.toLowerCase();\n        camels[i] = c;\n        lowers[i] = l;\n    }\n    let name = '';\n    for (let i = 0; i < count; i++) {\n        const l = lowers[i];\n        // Remove ::{generic, misc, pallet, traits, types}::\n        if (i !== 1 || !PATH_RM_INDEX_1.includes(l)) {\n            // sp_runtime::generic::digest::Digest -> sp_runtime::generic::Digest\n            // sp_runtime::multiaddress::MultiAddress -> sp_runtime::MultiAddress\n            if (l !== lowers[i + 1]) {\n                name += camels[i];\n            }\n        }\n    }\n    // do magic for RawOrigin lookup, e.g. pallet_collective::RawOrigin\n    if (camels[1] === 'RawOrigin' && count === 2 && params.length === 2 && params[1].type.isSome) {\n        const instanceType = portable[params[1].type.unwrap().toNumber()];\n        if (instanceType.type.path.length === 2) {\n            name = `${name}${instanceType.type.path[1].toString()}`;\n        }\n    }\n    return { lookupIndex, name, params };\n}\n/** @internal Alias for extractNameFlat with PortableType as a last parameter */\nfunction extractName(portable, lookupIndex, { type: { params, path } }) {\n    return extractNameFlat(portable, lookupIndex, params, path);\n}\n/** @internal Check for dupes from a specific index onwards */\nfunction nextDupeMatches(name, startAt, names) {\n    const result = [names[startAt]];\n    for (let i = startAt + 1, count = names.length; i < count; i++) {\n        const v = names[i];\n        if (v.name === name) {\n            result.push(v);\n        }\n    }\n    return result;\n}\n/** @internal Checks to see if a type is a full duplicate (with all params matching) */\nfunction rewriteDupes(input, rewrite) {\n    const count = input.length;\n    for (let i = 0; i < count; i++) {\n        const a = input[i];\n        for (let j = i + 1; j < count; j++) {\n            const b = input[j];\n            // if the indexes are not the same and the names match, we have a dupe\n            if (a.lookupIndex !== b.lookupIndex && a.name === b.name) {\n                return false;\n            }\n        }\n    }\n    // add all the adjusted values to the rewite map\n    for (let i = 0; i < count; i++) {\n        const p = input[i];\n        rewrite[p.lookupIndex] = p.name;\n    }\n    return true;\n}\n/** @internal Find duplicates and adjust the names based on parameters */\nfunction removeDupeNames(lookup, portable, names) {\n    const rewrite = {};\n    return names\n        .map((original, startAt) => {\n        const { lookupIndex, name, params } = original;\n        if (!name) {\n            // the name is empty (this is not expected, but have a failsafe)\n            return null;\n        }\n        else if (rewrite[lookupIndex]) {\n            // we have already rewritten this one, we can skip it\n            return original;\n        }\n        // those where the name is matching starting from this index\n        const allSame = nextDupeMatches(name, startAt, names);\n        // we only have one, so all ok\n        if (allSame.length === 1) {\n            return original;\n        }\n        // are there param differences between matching names\n        const anyDiff = allSame.some((o) => params.length !== o.params.length ||\n            params.some((p, index) => !p.name.eq(o.params[index].name) ||\n                p.type.unwrapOr(TYPE_UNWRAP).toNumber() !== o.params[index].type.unwrapOr(TYPE_UNWRAP).toNumber()));\n        // everything matches, we can combine these\n        if (!anyDiff) {\n            return original;\n        }\n        // TODO We probably want to attach all the indexes with differences,\n        // not just the first\n        // find the first parameter that yields differences\n        const paramIdx = params.findIndex(({ type }, index) => allSame.every(({ params }, aIndex) => params[index].type.isSome && (aIndex === 0 ||\n            !params[index].type.eq(type))));\n        // No param found that is different\n        if (paramIdx === -1) {\n            return original;\n        }\n        // see if using the param type helps\n        const sameCount = allSame.length;\n        const adjusted = new Array(sameCount);\n        // loop through all, specifically checking that index where the\n        // first param yields differences\n        for (let i = 0; i < sameCount; i++) {\n            const { lookupIndex, name, params } = allSame[i];\n            const { def, path } = lookup.getSiType(params[paramIdx].type.unwrap());\n            // if it is not a primitive and it doesn't have a path, we really cannot\n            // do anything at this point\n            if (!def.isPrimitive && !path.length) {\n                return null;\n            }\n            adjusted[i] = {\n                lookupIndex,\n                name: def.isPrimitive\n                    ? `${name}${def.asPrimitive.toString()}`\n                    : `${name}${path[path.length - 1].toString()}`\n            };\n        }\n        // check to see if the adjusted names have no issues\n        if (rewriteDupes(adjusted, rewrite)) {\n            return original;\n        }\n        // TODO This is duplicated from the section just above...\n        // ... we certainly need a better solution here\n        //\n        // Last-ditch effort to use the full type path - ugly\n        // loop through all, specifically checking that index where the\n        // first param yields differences\n        for (let i = 0; i < sameCount; i++) {\n            const { lookupIndex, name, params } = allSame[i];\n            const { def, path } = lookup.getSiType(params[paramIdx].type.unwrap());\n            const flat = extractNameFlat(portable, lookupIndex, params, path, true);\n            if (def.isPrimitive || !flat) {\n                return null;\n            }\n            adjusted[i] = {\n                lookupIndex,\n                name: `${name}${flat.name}`\n            };\n        }\n        // check to see if the adjusted names have no issues\n        if (rewriteDupes(adjusted, rewrite)) {\n            return original;\n        }\n        return null;\n    })\n        .filter((n) => !!n)\n        .map(({ lookupIndex, name, params }) => ({\n        lookupIndex,\n        name: rewrite[lookupIndex] || name,\n        params\n    }));\n}\n/** @internal Detect on-chain types (AccountId/Signature) as set as the default */\nfunction registerTypes(lookup, lookups, names, params) {\n    // Register the types we extracted\n    lookup.registry.register(lookups);\n    // Try and extract the AccountId/Address/Signature type from UncheckedExtrinsic\n    if (params.SpRuntimeUncheckedExtrinsic) {\n        // Address, Call, Signature, Extra\n        const [addrParam, , sigParam] = params.SpRuntimeUncheckedExtrinsic;\n        const siAddress = lookup.getSiType(addrParam.type.unwrap());\n        const siSignature = lookup.getSiType(sigParam.type.unwrap());\n        const nsSignature = siSignature.path.join('::');\n        let nsAccountId = siAddress.path.join('::');\n        const isMultiAddress = nsAccountId === 'sp_runtime::multiaddress::MultiAddress';\n        // With multiaddress, we check the first type param again\n        if (isMultiAddress) {\n            // AccountId, AccountIndex\n            const [idParam] = siAddress.params;\n            nsAccountId = lookup.getSiType(idParam.type.unwrap()).path.join('::');\n        }\n        lookup.registry.register({\n            // known: account::AccountId20, fp_account::AccountId20, primitive_types::H160\n            AccountId: nsAccountId.endsWith('::AccountId20') || nsAccountId.endsWith('::H160')\n                ? 'AccountId20'\n                : 'AccountId32',\n            Address: isMultiAddress\n                ? 'MultiAddress'\n                : 'AccountId',\n            ExtrinsicSignature: ['sp_runtime::MultiSignature'].includes(nsSignature)\n                ? 'MultiSignature'\n                : names[sigParam.type.unwrap().toNumber()] || 'MultiSignature'\n        });\n    }\n}\n/**\n * @internal Extracts aliases based on what we know the runtime config looks like in a\n * Substrate chain. Specifically we want to have access to the Call and Event params\n **/\nfunction extractAliases(params, isContract) {\n    const hasParams = Object.keys(params).some((k) => !k.startsWith('Pallet'));\n    const alias = {};\n    if (params.SpRuntimeUncheckedExtrinsic) {\n        // Address, Call, Signature, Extra\n        const [, { type }] = params.SpRuntimeUncheckedExtrinsic;\n        alias[type.unwrap().toNumber()] = 'Call';\n    }\n    else if (hasParams && !isContract) {\n        l.warn('Unable to determine runtime Call type, cannot inspect sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic');\n    }\n    if (params.FrameSystemEventRecord) {\n        // Event, Topic\n        const [{ type }] = params.FrameSystemEventRecord;\n        alias[type.unwrap().toNumber()] = 'Event';\n    }\n    else if (hasParams && !isContract) {\n        l.warn('Unable to determine runtime Event type, cannot inspect frame_system::EventRecord');\n    }\n    return alias;\n}\n/** @internal Extracts all the intreresting type information for this registry */\nfunction extractTypeInfo(lookup, portable) {\n    const nameInfo = [];\n    const types = {};\n    for (let i = 0, count = portable.length; i < count; i++) {\n        const type = portable[i];\n        const lookupIndex = type.id.toNumber();\n        const extracted = extractName(portable, lookupIndex, portable[i]);\n        if (extracted) {\n            nameInfo.push(extracted);\n        }\n        types[lookupIndex] = type;\n    }\n    const lookups = {};\n    const names = {};\n    const params = {};\n    const dedup = removeDupeNames(lookup, portable, nameInfo);\n    for (let i = 0, count = dedup.length; i < count; i++) {\n        const { lookupIndex, name, params: p } = dedup[i];\n        names[lookupIndex] = name;\n        lookups[name] = lookup.registry.createLookupType(lookupIndex);\n        params[name] = p;\n    }\n    return { lookups, names, params, types };\n}\nexport class PortableRegistry extends Struct {\n    __internal__alias;\n    __internal__lookups;\n    __internal__names;\n    __internal__params;\n    __internal__typeDefs = {};\n    __internal__types;\n    constructor(registry, value, isContract) {\n        // const timeStart = performance.now()\n        super(registry, {\n            types: 'Vec<PortableType>'\n        }, value);\n        const { lookups, names, params, types } = extractTypeInfo(this, this.types);\n        this.__internal__alias = extractAliases(params, isContract);\n        this.__internal__lookups = lookups;\n        this.__internal__names = names;\n        this.__internal__params = params;\n        this.__internal__types = types;\n        // console.log('PortableRegistry', `${(performance.now() - timeStart).toFixed(2)}ms`)\n    }\n    /**\n     * @description Returns all the available type names for this chain\n     **/\n    get names() {\n        return Object.values(this.__internal__names).sort();\n    }\n    /**\n     * @description Returns all the available parameterized types for this chain\n     **/\n    get paramTypes() {\n        return this.__internal__params;\n    }\n    /**\n     * @description The types of the registry\n     */\n    get types() {\n        return this.getT('types');\n    }\n    /**\n     * @description Register all available types into the registry (generally for internal usage)\n     */\n    register() {\n        registerTypes(this, this.__internal__lookups, this.__internal__names, this.__internal__params);\n    }\n    /**\n     * @description Returns the name for a specific lookup\n     */\n    getName(lookupId) {\n        return this.__internal__names[this.__internal__getLookupId(lookupId)];\n    }\n    /**\n     * @description Finds a specific type in the registry\n     */\n    getSiType(lookupId) {\n        // NOTE catch-22 - this may already be used as part of the constructor, so\n        // ensure that we have actually initialized it correctly\n        const found = (this.__internal__types || this.types)[this.__internal__getLookupId(lookupId)];\n        if (!found) {\n            throw new Error(`PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);\n        }\n        return found.type;\n    }\n    /**\n     * @description Lookup the type definition for the index\n     */\n    getTypeDef(lookupId) {\n        const lookupIndex = this.__internal__getLookupId(lookupId);\n        if (!this.__internal__typeDefs[lookupIndex]) {\n            const lookupName = this.__internal__names[lookupIndex];\n            const empty = {\n                info: TypeDefInfo.DoNotConstruct,\n                lookupIndex,\n                lookupName,\n                type: this.registry.createLookupType(lookupIndex)\n            };\n            // Set named items since we will get into circular lookups along the way\n            if (lookupName) {\n                this.__internal__typeDefs[lookupIndex] = empty;\n            }\n            const extracted = this.__internal__extract(this.getSiType(lookupId), lookupIndex);\n            // For non-named items, we only set this right at the end\n            if (!lookupName) {\n                this.__internal__typeDefs[lookupIndex] = empty;\n            }\n            Object.keys(extracted).forEach((k) => {\n                if (k !== 'lookupName' || extracted[k]) {\n                    // these are safe since we are looking through the keys as set\n                    this.__internal__typeDefs[lookupIndex][k] = extracted[k];\n                }\n            });\n            // don't set lookupName on lower-level, we want to always direct to the type\n            if (extracted.info === TypeDefInfo.Plain) {\n                this.__internal__typeDefs[lookupIndex].lookupNameRoot = this.__internal__typeDefs[lookupIndex].lookupName;\n                delete this.__internal__typeDefs[lookupIndex].lookupName;\n            }\n        }\n        return this.__internal__typeDefs[lookupIndex];\n    }\n    /**\n     * @description For a specific field, perform adjustments to not have built-in conflicts\n     */\n    sanitizeField(name) {\n        let nameField = null;\n        let nameOrig = null;\n        if (name.isSome) {\n            nameField = stringCamelCase(name.unwrap());\n            if (nameField.includes('#')) {\n                nameOrig = nameField;\n                nameField = nameOrig.replace(/#/g, '_');\n            }\n            else if (RESERVED.includes(nameField)) {\n                nameOrig = nameField;\n                nameField = `${nameField}_`;\n            }\n        }\n        return [nameField, nameOrig];\n    }\n    /** @internal Creates a TypeDef based on an internal lookupId */\n    __internal__createSiDef(lookupId) {\n        const typeDef = this.getTypeDef(lookupId);\n        const lookupIndex = lookupId.toNumber();\n        // Setup for a lookup on complex types\n        return [TypeDefInfo.DoNotConstruct, TypeDefInfo.Enum, TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName\n            ? {\n                docs: typeDef.docs,\n                info: TypeDefInfo.Si,\n                lookupIndex,\n                lookupName: this.__internal__names[lookupIndex],\n                type: this.registry.createLookupType(lookupId)\n            }\n            : typeDef;\n    }\n    /** @internal Converts a lookupId input to the actual lookup index */\n    __internal__getLookupId(lookupId) {\n        if (isString(lookupId)) {\n            if (!this.registry.isLookupType(lookupId)) {\n                throw new Error(`PortableRegistry: Expected a lookup string type, found ${lookupId}`);\n            }\n            return parseInt(lookupId.replace('Lookup', ''), 10);\n        }\n        else if (isNumber(lookupId)) {\n            return lookupId;\n        }\n        return lookupId.toNumber();\n    }\n    /** @internal Converts a type into a TypeDef for Codec usage */\n    __internal__extract(type, lookupIndex) {\n        const namespace = type.path.join('::');\n        let typeDef;\n        const aliasType = this.__internal__alias[lookupIndex] || getAliasPath(type);\n        try {\n            if (aliasType) {\n                typeDef = this.__internal__extractAliasPath(lookupIndex, aliasType);\n            }\n            else {\n                switch (type.def.type) {\n                    case 'Array':\n                        typeDef = this.__internal__extractArray(lookupIndex, type.def.asArray);\n                        break;\n                    case 'BitSequence':\n                        typeDef = this.__internal__extractBitSequence(lookupIndex, type.def.asBitSequence);\n                        break;\n                    case 'Compact':\n                        typeDef = this.__internal__extractCompact(lookupIndex, type.def.asCompact);\n                        break;\n                    case 'Composite':\n                        typeDef = this.__internal__extractComposite(lookupIndex, type, type.def.asComposite);\n                        break;\n                    case 'HistoricMetaCompat':\n                        typeDef = this.__internal__extractHistoric(lookupIndex, type.def.asHistoricMetaCompat);\n                        break;\n                    case 'Primitive':\n                        typeDef = this.__internal__extractPrimitive(lookupIndex, type);\n                        break;\n                    case 'Sequence':\n                        typeDef = this.__internal__extractSequence(lookupIndex, type.def.asSequence);\n                        break;\n                    case 'Tuple':\n                        typeDef = this.__internal__extractTuple(lookupIndex, type.def.asTuple);\n                        break;\n                    case 'Variant':\n                        typeDef = this.__internal__extractVariant(lookupIndex, type, type.def.asVariant);\n                        break;\n                    default: assertUnreachable(type.def.type);\n                }\n            }\n        }\n        catch (error) {\n            throw new Error(`PortableRegistry: ${lookupIndex}${namespace ? ` (${namespace})` : ''}: Error extracting ${stringify(type)}: ${error.message}`);\n        }\n        return objectSpread({\n            docs: sanitizeDocs(type.docs),\n            namespace\n        }, typeDef);\n    }\n    /** @internal Extracts a ScaleInfo Array into TypeDef.VecFixed */\n    __internal__extractArray(_, { len, type }) {\n        const length = len.toNumber();\n        if (length > 2048) {\n            throw new Error('Only support for [Type; <length>], where length <= 2048');\n        }\n        return withTypeString(this.registry, {\n            info: TypeDefInfo.VecFixed,\n            length,\n            sub: this.__internal__createSiDef(type)\n        });\n    }\n    /** @internal Extracts a ScaleInfo BitSequence into TypeDef.Plain */\n    __internal__extractBitSequence(_, { bitOrderType, bitStoreType }) {\n        // With the v3 of scale-info this swapped around, but obviously the decoder cannot determine\n        // the order. With that in-mind, we apply a detection for LSb0/Msb and set accordingly\n        const a = this.__internal__createSiDef(bitOrderType);\n        const b = this.__internal__createSiDef(bitStoreType);\n        const [bitOrder, bitStore] = BITVEC_NS.includes(a.namespace || '')\n            ? [a, b]\n            : [b, a];\n        if (!bitOrder.namespace || !BITVEC_NS.includes(bitOrder.namespace)) {\n            throw new Error(`Unexpected bitOrder found as ${bitOrder.namespace || '<unknown>'}`);\n        }\n        else if (bitStore.info !== TypeDefInfo.Plain || bitStore.type !== 'u8') {\n            throw new Error(`Only u8 bitStore is currently supported, found ${bitStore.type}`);\n        }\n        const isLsb = BITVEC_NS_LSB.includes(bitOrder.namespace);\n        if (!isLsb) {\n            // TODO To remove this limitation, we need to pass an extra info flag\n            // through to the TypeDef (Here we could potentially re-use something\n            // like index (???) to indicate and ensure we use it to pass to the\n            // BitVec constructor - which does handle this type)\n            //\n            // See https://github.com/polkadot-js/api/issues/5588\n            // throw new Error(`Only LSB BitVec is currently supported, found ${bitOrder.namespace}`);\n        }\n        return {\n            info: TypeDefInfo.Plain,\n            type: 'BitVec'\n        };\n    }\n    /** @internal Extracts a ScaleInfo Compact into TypeDef.Compact */\n    __internal__extractCompact(_, { type }) {\n        return withTypeString(this.registry, {\n            info: TypeDefInfo.Compact,\n            sub: this.__internal__createSiDef(type)\n        });\n    }\n    /** @internal Extracts a ScaleInfo Composite into TypeDef.{BTree*, Range*, Wrapper*} */\n    __internal__extractComposite(lookupIndex, { params, path }, { fields }) {\n        if (path.length) {\n            const pathFirst = path[0].toString();\n            const pathLast = path[path.length - 1].toString();\n            if (path.length === 1 && pathFirst === 'BTreeMap') {\n                if (params.length !== 2) {\n                    throw new Error(`BTreeMap requires 2 parameters, found ${params.length}`);\n                }\n                return withTypeString(this.registry, {\n                    info: TypeDefInfo.BTreeMap,\n                    sub: params.map(({ type }) => this.__internal__createSiDef(type.unwrap()))\n                });\n            }\n            else if (path.length === 1 && pathFirst === 'BTreeSet') {\n                if (params.length !== 1) {\n                    throw new Error(`BTreeSet requires 1 parameter, found ${params.length}`);\n                }\n                return withTypeString(this.registry, {\n                    info: TypeDefInfo.BTreeSet,\n                    sub: this.__internal__createSiDef(params[0].type.unwrap())\n                });\n            }\n            else if (['Range', 'RangeInclusive'].includes(pathFirst)) {\n                if (params.length !== 1) {\n                    throw new Error(`Range requires 1 parameter, found ${params.length}`);\n                }\n                return withTypeString(this.registry, {\n                    info: pathFirst === 'Range'\n                        ? TypeDefInfo.Range\n                        : TypeDefInfo.RangeInclusive,\n                    sub: this.__internal__createSiDef(params[0].type.unwrap()),\n                    type: pathFirst\n                });\n            }\n            else if (['WrapperKeepOpaque', 'WrapperOpaque'].includes(pathLast)) {\n                if (params.length !== 1) {\n                    throw new Error(`WrapperOpaque requires 1 parameter, found ${params.length}`);\n                }\n                return withTypeString(this.registry, {\n                    info: pathLast === 'WrapperKeepOpaque'\n                        ? TypeDefInfo.WrapperKeepOpaque\n                        : TypeDefInfo.WrapperOpaque,\n                    sub: this.__internal__createSiDef(params[0].type.unwrap()),\n                    type: pathLast\n                });\n            }\n        }\n        return PATHS_SET.some((p) => matchParts(p, path))\n            ? this.__internal__extractCompositeSet(lookupIndex, params, fields)\n            : this.__internal__extractFields(lookupIndex, fields);\n    }\n    /** @internal Extracts a ScaleInfo CompositeSet into TypeDef.Set */\n    __internal__extractCompositeSet(_, params, fields) {\n        if (params.length !== 1 || fields.length !== 1) {\n            throw new Error('Set handling expects param/field as single entries');\n        }\n        return withTypeString(this.registry, {\n            info: TypeDefInfo.Set,\n            length: this.registry.createTypeUnsafe(this.registry.createLookupType(fields[0].type), []).bitLength(),\n            sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(({ index, name }) => ({\n                // This will be an issue > 2^53 - 1 ... don't have those (yet)\n                index: index.toNumber(),\n                info: TypeDefInfo.Plain,\n                name: name.toString(),\n                type: 'Null'\n            }))\n        });\n    }\n    /** @internal Extracts ScaleInfo enum/struct fields into TypeDef.{Struct, Tuple} */\n    __internal__extractFields(lookupIndex, fields) {\n        let isStruct = true;\n        let isTuple = true;\n        const count = fields.length;\n        for (let f = 0; f < count; f++) {\n            const { name } = fields[f];\n            isStruct = isStruct && name.isSome;\n            isTuple = isTuple && name.isNone;\n        }\n        if (!isTuple && !isStruct) {\n            throw new Error('Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)');\n        }\n        if (count === 0) {\n            return {\n                info: TypeDefInfo.Null,\n                type: 'Null'\n            };\n        }\n        else if (isTuple && count === 1) {\n            const typeDef = this.__internal__createSiDef(fields[0].type);\n            return objectSpread({}, typeDef, lookupIndex === -1\n                ? null\n                : {\n                    lookupIndex,\n                    lookupName: this.__internal__names[lookupIndex],\n                    lookupNameRoot: typeDef.lookupName\n                }, fields[0].typeName.isSome\n                ? { typeName: sanitize(fields[0].typeName.unwrap()) }\n                : null);\n        }\n        const [sub, alias] = this.__internal__extractFieldsAlias(fields);\n        return withTypeString(this.registry, objectSpread({\n            info: isTuple // Tuple check first\n                ? TypeDefInfo.Tuple\n                : TypeDefInfo.Struct,\n            sub\n        }, alias.size\n            ? { alias }\n            : null, lookupIndex === -1\n            ? null\n            : {\n                lookupIndex,\n                lookupName: this.__internal__names[lookupIndex]\n            }));\n    }\n    /** @internal Apply field aliassed (with no JS conflicts) */\n    __internal__extractFieldsAlias(fields) {\n        const alias = new Map();\n        const count = fields.length;\n        const sub = new Array(count);\n        for (let i = 0; i < count; i++) {\n            const { docs, name, type, typeName } = fields[i];\n            const typeDef = this.__internal__createSiDef(type);\n            if (name.isNone) {\n                sub[i] = typeDef;\n            }\n            else {\n                const [nameField, nameOrig] = this.sanitizeField(name);\n                if (nameField && nameOrig) {\n                    alias.set(nameField, nameOrig);\n                }\n                sub[i] = objectSpread({\n                    docs: sanitizeDocs(docs),\n                    name: nameField\n                }, typeDef, typeName.isSome\n                    ? { typeName: sanitize(typeName.unwrap()) }\n                    : null);\n            }\n        }\n        return [sub, alias];\n    }\n    /** @internal Extracts an internal Historic (pre V14) type  */\n    __internal__extractHistoric(_, type) {\n        return objectSpread({\n            displayName: type.toString(),\n            isFromSi: true\n        }, getTypeDef(type));\n    }\n    /** @internal Extracts a ScaleInfo Primitive into TypeDef.Plain */\n    __internal__extractPrimitive(_, type) {\n        const typeStr = type.def.asPrimitive.type.toString();\n        return {\n            info: TypeDefInfo.Plain,\n            type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()\n        };\n    }\n    /** @internal Applies an alias path onto the TypeDef */\n    __internal__extractAliasPath(_, type) {\n        return {\n            info: TypeDefInfo.Plain,\n            type\n        };\n    }\n    /** @internal Extracts a ScaleInfo Sequence into TypeDef.Vec (with Bytes shortcut) */\n    __internal__extractSequence(lookupIndex, { type }) {\n        const sub = this.__internal__createSiDef(type);\n        if (sub.type === 'u8') {\n            return {\n                info: TypeDefInfo.Plain,\n                type: 'Bytes'\n            };\n        }\n        return withTypeString(this.registry, {\n            info: TypeDefInfo.Vec,\n            lookupIndex,\n            lookupName: this.__internal__names[lookupIndex],\n            sub\n        });\n    }\n    /** @internal Extracts a ScaleInfo Tuple into TypeDef.Tuple */\n    __internal__extractTuple(lookupIndex, ids) {\n        if (ids.length === 0) {\n            return {\n                info: TypeDefInfo.Null,\n                type: 'Null'\n            };\n        }\n        else if (ids.length === 1) {\n            return this.getTypeDef(ids[0]);\n        }\n        const sub = ids.map((t) => this.__internal__createSiDef(t));\n        return withTypeString(this.registry, {\n            info: TypeDefInfo.Tuple,\n            lookupIndex,\n            lookupName: this.__internal__names[lookupIndex],\n            sub\n        });\n    }\n    /** @internal Extracts a ScaleInfo Variant into TypeDef.{Option, Result, Enum} */\n    __internal__extractVariant(lookupIndex, { params, path }, { variants }) {\n        if (path.length) {\n            const specialVariant = path[0].toString();\n            if (specialVariant === 'Option') {\n                if (params.length !== 1) {\n                    throw new Error(`Option requires 1 parameter, found ${params.length}`);\n                }\n                // NOTE This is opt-in (unhandled), not by default\n                // if (sub.type === 'bool') {\n                //   return withTypeString(this.registry, {\n                //     info: TypeDefInfo.Plain,\n                //     type: 'OptionBool'\n                //   });\n                // }\n                return withTypeString(this.registry, {\n                    info: TypeDefInfo.Option,\n                    sub: this.__internal__createSiDef(params[0].type.unwrap())\n                });\n            }\n            else if (specialVariant === 'Result') {\n                if (params.length !== 2) {\n                    throw new Error(`Result requires 2 parameters, found ${params.length}`);\n                }\n                return withTypeString(this.registry, {\n                    info: TypeDefInfo.Result,\n                    sub: params.map(({ type }, index) => objectSpread({\n                        name: ['Ok', 'Error'][index]\n                    }, this.__internal__createSiDef(type.unwrap())))\n                });\n            }\n        }\n        if (variants.length === 0) {\n            return {\n                info: TypeDefInfo.Null,\n                type: 'Null'\n            };\n        }\n        return this.__internal__extractVariantEnum(lookupIndex, variants);\n    }\n    /** @internal Extracts a ScaleInfo Variant into TypeDef.Enum */\n    __internal__extractVariantEnum(lookupIndex, variants) {\n        const sub = [];\n        // we may get entries out of order, arrange them first before creating with gaps filled\n        // NOTE: Since we mutate, use a copy of the array as an input\n        variants\n            .slice()\n            .sort((a, b) => a.index.cmp(b.index))\n            .forEach(({ fields, index: bnIndex, name }) => {\n            const index = bnIndex.toNumber();\n            while (sub.length !== index) {\n                sub.push({\n                    index: sub.length,\n                    info: TypeDefInfo.Null,\n                    name: `__Unused${sub.length}`,\n                    type: 'Null'\n                });\n            }\n            sub.push(objectSpread(this.__internal__extractFields(-1, fields), {\n                index,\n                name: name.toString()\n            }));\n        });\n        return withTypeString(this.registry, {\n            info: TypeDefInfo.Enum,\n            lookupIndex,\n            lookupName: this.__internal__names[lookupIndex],\n            sub\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}