{"ast":null,"code":"import { bnToU8a, stringToU8a, u8aConcat } from '@polkadot/util';\nimport { BN_BE_32_OPTS } from '../../bn.js';\nimport { hmacShaAsU8a } from '../../hmac/index.js';\nimport { secp256k1PairFromSeed, secp256k1PrivateKeyTweakAdd } from '../../secp256k1/index.js';\nimport { HARDENED, hdValidatePath } from '../validatePath.js';\nconst MASTER_SECRET = stringToU8a('Bitcoin seed');\nfunction createCoded(secretKey, chainCode) {\n  return {\n    chainCode,\n    publicKey: secp256k1PairFromSeed(secretKey).publicKey,\n    secretKey\n  };\n}\nfunction deriveChild(hd, index) {\n  const indexBuffer = bnToU8a(index, BN_BE_32_OPTS);\n  const data = index >= HARDENED ? u8aConcat(new Uint8Array(1), hd.secretKey, indexBuffer) : u8aConcat(hd.publicKey, indexBuffer);\n  try {\n    const I = hmacShaAsU8a(hd.chainCode, data, 512);\n    return createCoded(secp256k1PrivateKeyTweakAdd(hd.secretKey, I.slice(0, 32)), I.slice(32));\n  } catch {\n    // In case parse256(IL) >= n or ki == 0, proceed with the next value for i\n    return deriveChild(hd, index + 1);\n  }\n}\nexport function hdEthereum(seed) {\n  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  const I = hmacShaAsU8a(MASTER_SECRET, seed, 512);\n  let hd = createCoded(I.slice(0, 32), I.slice(32));\n  if (!path || path === 'm' || path === 'M' || path === \"m'\" || path === \"M'\") {\n    return hd;\n  }\n  if (!hdValidatePath(path)) {\n    throw new Error('Invalid derivation path');\n  }\n  const parts = path.split('/').slice(1);\n  for (const p of parts) {\n    hd = deriveChild(hd, parseInt(p, 10) + (p.length > 1 && p.endsWith(\"'\") ? HARDENED : 0));\n  }\n  return hd;\n}","map":{"version":3,"names":["bnToU8a","stringToU8a","u8aConcat","BN_BE_32_OPTS","hmacShaAsU8a","secp256k1PairFromSeed","secp256k1PrivateKeyTweakAdd","HARDENED","hdValidatePath","MASTER_SECRET","createCoded","secretKey","chainCode","publicKey","deriveChild","hd","index","indexBuffer","data","Uint8Array","I","slice","hdEthereum","seed","path","arguments","length","undefined","Error","parts","split","p","parseInt","endsWith"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util-crypto/hd/ethereum/index.js"],"sourcesContent":["import { bnToU8a, stringToU8a, u8aConcat } from '@polkadot/util';\nimport { BN_BE_32_OPTS } from '../../bn.js';\nimport { hmacShaAsU8a } from '../../hmac/index.js';\nimport { secp256k1PairFromSeed, secp256k1PrivateKeyTweakAdd } from '../../secp256k1/index.js';\nimport { HARDENED, hdValidatePath } from '../validatePath.js';\nconst MASTER_SECRET = stringToU8a('Bitcoin seed');\nfunction createCoded(secretKey, chainCode) {\n    return {\n        chainCode,\n        publicKey: secp256k1PairFromSeed(secretKey).publicKey,\n        secretKey\n    };\n}\nfunction deriveChild(hd, index) {\n    const indexBuffer = bnToU8a(index, BN_BE_32_OPTS);\n    const data = index >= HARDENED\n        ? u8aConcat(new Uint8Array(1), hd.secretKey, indexBuffer)\n        : u8aConcat(hd.publicKey, indexBuffer);\n    try {\n        const I = hmacShaAsU8a(hd.chainCode, data, 512);\n        return createCoded(secp256k1PrivateKeyTweakAdd(hd.secretKey, I.slice(0, 32)), I.slice(32));\n    }\n    catch {\n        // In case parse256(IL) >= n or ki == 0, proceed with the next value for i\n        return deriveChild(hd, index + 1);\n    }\n}\nexport function hdEthereum(seed, path = '') {\n    const I = hmacShaAsU8a(MASTER_SECRET, seed, 512);\n    let hd = createCoded(I.slice(0, 32), I.slice(32));\n    if (!path || path === 'm' || path === 'M' || path === \"m'\" || path === \"M'\") {\n        return hd;\n    }\n    if (!hdValidatePath(path)) {\n        throw new Error('Invalid derivation path');\n    }\n    const parts = path.split('/').slice(1);\n    for (const p of parts) {\n        hd = deriveChild(hd, parseInt(p, 10) + ((p.length > 1) && p.endsWith(\"'\")\n            ? HARDENED\n            : 0));\n    }\n    return hd;\n}\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,WAAW,EAAEC,SAAS,QAAQ,gBAAgB;AAChE,SAASC,aAAa,QAAQ,aAAa;AAC3C,SAASC,YAAY,QAAQ,qBAAqB;AAClD,SAASC,qBAAqB,EAAEC,2BAA2B,QAAQ,0BAA0B;AAC7F,SAASC,QAAQ,EAAEC,cAAc,QAAQ,oBAAoB;AAC7D,MAAMC,aAAa,GAAGR,WAAW,CAAC,cAAc,CAAC;AACjD,SAASS,WAAWA,CAACC,SAAS,EAAEC,SAAS,EAAE;EACvC,OAAO;IACHA,SAAS;IACTC,SAAS,EAAER,qBAAqB,CAACM,SAAS,CAAC,CAACE,SAAS;IACrDF;EACJ,CAAC;AACL;AACA,SAASG,WAAWA,CAACC,EAAE,EAAEC,KAAK,EAAE;EAC5B,MAAMC,WAAW,GAAGjB,OAAO,CAACgB,KAAK,EAAEb,aAAa,CAAC;EACjD,MAAMe,IAAI,GAAGF,KAAK,IAAIT,QAAQ,GACxBL,SAAS,CAAC,IAAIiB,UAAU,CAAC,CAAC,CAAC,EAAEJ,EAAE,CAACJ,SAAS,EAAEM,WAAW,CAAC,GACvDf,SAAS,CAACa,EAAE,CAACF,SAAS,EAAEI,WAAW,CAAC;EAC1C,IAAI;IACA,MAAMG,CAAC,GAAGhB,YAAY,CAACW,EAAE,CAACH,SAAS,EAAEM,IAAI,EAAE,GAAG,CAAC;IAC/C,OAAOR,WAAW,CAACJ,2BAA2B,CAACS,EAAE,CAACJ,SAAS,EAAES,CAAC,CAACC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAED,CAAC,CAACC,KAAK,CAAC,EAAE,CAAC,CAAC;EAC9F,CAAC,CACD,MAAM;IACF;IACA,OAAOP,WAAW,CAACC,EAAE,EAAEC,KAAK,GAAG,CAAC,CAAC;EACrC;AACJ;AACA,OAAO,SAASM,UAAUA,CAACC,IAAI,EAAa;EAAA,IAAXC,IAAI,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;EACtC,MAAML,CAAC,GAAGhB,YAAY,CAACK,aAAa,EAAEc,IAAI,EAAE,GAAG,CAAC;EAChD,IAAIR,EAAE,GAAGL,WAAW,CAACU,CAAC,CAACC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,EAAED,CAAC,CAACC,KAAK,CAAC,EAAE,CAAC,CAAC;EACjD,IAAI,CAACG,IAAI,IAAIA,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,IAAI,EAAE;IACzE,OAAOT,EAAE;EACb;EACA,IAAI,CAACP,cAAc,CAACgB,IAAI,CAAC,EAAE;IACvB,MAAM,IAAII,KAAK,CAAC,yBAAyB,CAAC;EAC9C;EACA,MAAMC,KAAK,GAAGL,IAAI,CAACM,KAAK,CAAC,GAAG,CAAC,CAACT,KAAK,CAAC,CAAC,CAAC;EACtC,KAAK,MAAMU,CAAC,IAAIF,KAAK,EAAE;IACnBd,EAAE,GAAGD,WAAW,CAACC,EAAE,EAAEiB,QAAQ,CAACD,CAAC,EAAE,EAAE,CAAC,IAAKA,CAAC,CAACL,MAAM,GAAG,CAAC,IAAKK,CAAC,CAACE,QAAQ,CAAC,GAAG,CAAC,GACnE1B,QAAQ,GACR,CAAC,CAAC,CAAC;EACb;EACA,OAAOQ,EAAE;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}