{"ast":null,"code":"import { Option, Struct } from '@polkadot/types-codec';\nimport { objectProperty, objectSpread, u8aToHex } from '@polkadot/util';\nconst knownTypes = {\n  address: 'Address',\n  blockHash: 'Hash',\n  blockNumber: 'BlockNumber',\n  era: 'ExtrinsicEra',\n  genesisHash: 'Hash',\n  method: 'Call',\n  nonce: 'Compact<Index>',\n  runtimeVersion: 'RuntimeVersion',\n  signedExtensions: 'Vec<Text>',\n  tip: 'Compact<Balance>',\n  version: 'u8'\n};\n/**\n * @name GenericSignerPayload\n * @description\n * A generic signer payload that can be used for serialization between API and signer\n */\nexport class GenericSignerPayload extends Struct {\n  __internal__extraTypes;\n  constructor(registry, value) {\n    const extensionTypes = objectSpread({}, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra());\n    super(registry, objectSpread({}, extensionTypes, knownTypes), value);\n    this.__internal__extraTypes = {};\n    const getter = key => this.get(key);\n    // add all extras that are not in the base types\n    for (const [key, type] of Object.entries(extensionTypes)) {\n      if (!knownTypes[key]) {\n        this.__internal__extraTypes[key] = type;\n      }\n      objectProperty(this, key, getter);\n    }\n  }\n  get address() {\n    return this.getT('address');\n  }\n  get blockHash() {\n    return this.getT('blockHash');\n  }\n  get blockNumber() {\n    return this.getT('blockNumber');\n  }\n  get era() {\n    return this.getT('era');\n  }\n  get genesisHash() {\n    return this.getT('genesisHash');\n  }\n  get method() {\n    return this.getT('method');\n  }\n  get nonce() {\n    return this.getT('nonce');\n  }\n  get runtimeVersion() {\n    return this.getT('runtimeVersion');\n  }\n  get signedExtensions() {\n    return this.getT('signedExtensions');\n  }\n  get tip() {\n    return this.getT('tip');\n  }\n  get assetId() {\n    return this.getT('assetId');\n  }\n  get version() {\n    return this.getT('version');\n  }\n  /**\n   * @description Creates an representation of the structure as an ISignerPayload JSON\n   */\n  toPayload() {\n    const result = {};\n    const keys = Object.keys(this.__internal__extraTypes);\n    // add any explicit overrides we may have\n    for (let i = 0, count = keys.length; i < count; i++) {\n      const key = keys[i];\n      const value = this.getT(key);\n      // Don't include Option.isNone\n      if (!(value instanceof Option) || value.isSome) {\n        // NOTE In the spread below we convert (mostly) to Hex to align\n        // with the typings. In the case of \"unknown\" fields, we use the\n        // primitive toJSON conversion (which is serializable). Technically\n        // we can include isNone in here as well (\"null\" is allowed), however\n        // for empty fields we just skip it completely (historical compat)\n        result[key] = value.toJSON();\n      }\n    }\n    return objectSpread(result, {\n      // the known defaults as managed explicitly and has different\n      // formatting in cases, e.g. we mostly expose a hex format here\n      address: this.address.toString(),\n      blockHash: this.blockHash.toHex(),\n      blockNumber: this.blockNumber.toHex(),\n      era: this.era.toHex(),\n      genesisHash: this.genesisHash.toHex(),\n      method: this.method.toHex(),\n      nonce: this.nonce.toHex(),\n      signedExtensions: this.signedExtensions.map(e => e.toString()),\n      specVersion: this.runtimeVersion.specVersion.toHex(),\n      tip: this.tip.toHex(),\n      transactionVersion: this.runtimeVersion.transactionVersion.toHex(),\n      version: this.version.toNumber()\n    });\n  }\n  /**\n   * @description Creates a representation of the payload in raw Exrinsic form\n   */\n  toRaw() {\n    const payload = this.toPayload();\n    const data = u8aToHex(this.registry.createTypeUnsafe('ExtrinsicPayload', [payload, {\n      version: payload.version\n    }])\n    // NOTE Explicitly pass the bare flag so the method is encoded un-prefixed (non-decodable, for signing only)\n    .toU8a({\n      method: true\n    }));\n    return {\n      address: payload.address,\n      data,\n      type: 'payload'\n    };\n  }\n}","map":{"version":3,"names":["Option","Struct","objectProperty","objectSpread","u8aToHex","knownTypes","address","blockHash","blockNumber","era","genesisHash","method","nonce","runtimeVersion","signedExtensions","tip","version","GenericSignerPayload","__internal__extraTypes","constructor","registry","value","extensionTypes","getSignedExtensionTypes","getSignedExtensionExtra","getter","key","get","type","Object","entries","getT","assetId","toPayload","result","keys","i","count","length","isSome","toJSON","toString","toHex","map","e","specVersion","transactionVersion","toNumber","toRaw","payload","data","createTypeUnsafe","toU8a"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/extrinsic/SignerPayload.js"],"sourcesContent":["import { Option, Struct } from '@polkadot/types-codec';\nimport { objectProperty, objectSpread, u8aToHex } from '@polkadot/util';\nconst knownTypes = {\n    address: 'Address',\n    blockHash: 'Hash',\n    blockNumber: 'BlockNumber',\n    era: 'ExtrinsicEra',\n    genesisHash: 'Hash',\n    method: 'Call',\n    nonce: 'Compact<Index>',\n    runtimeVersion: 'RuntimeVersion',\n    signedExtensions: 'Vec<Text>',\n    tip: 'Compact<Balance>',\n    version: 'u8'\n};\n/**\n * @name GenericSignerPayload\n * @description\n * A generic signer payload that can be used for serialization between API and signer\n */\nexport class GenericSignerPayload extends Struct {\n    __internal__extraTypes;\n    constructor(registry, value) {\n        const extensionTypes = objectSpread({}, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra());\n        super(registry, objectSpread({}, extensionTypes, knownTypes), value);\n        this.__internal__extraTypes = {};\n        const getter = (key) => this.get(key);\n        // add all extras that are not in the base types\n        for (const [key, type] of Object.entries(extensionTypes)) {\n            if (!knownTypes[key]) {\n                this.__internal__extraTypes[key] = type;\n            }\n            objectProperty(this, key, getter);\n        }\n    }\n    get address() {\n        return this.getT('address');\n    }\n    get blockHash() {\n        return this.getT('blockHash');\n    }\n    get blockNumber() {\n        return this.getT('blockNumber');\n    }\n    get era() {\n        return this.getT('era');\n    }\n    get genesisHash() {\n        return this.getT('genesisHash');\n    }\n    get method() {\n        return this.getT('method');\n    }\n    get nonce() {\n        return this.getT('nonce');\n    }\n    get runtimeVersion() {\n        return this.getT('runtimeVersion');\n    }\n    get signedExtensions() {\n        return this.getT('signedExtensions');\n    }\n    get tip() {\n        return this.getT('tip');\n    }\n    get assetId() {\n        return this.getT('assetId');\n    }\n    get version() {\n        return this.getT('version');\n    }\n    /**\n     * @description Creates an representation of the structure as an ISignerPayload JSON\n     */\n    toPayload() {\n        const result = {};\n        const keys = Object.keys(this.__internal__extraTypes);\n        // add any explicit overrides we may have\n        for (let i = 0, count = keys.length; i < count; i++) {\n            const key = keys[i];\n            const value = this.getT(key);\n            // Don't include Option.isNone\n            if (!(value instanceof Option) || value.isSome) {\n                // NOTE In the spread below we convert (mostly) to Hex to align\n                // with the typings. In the case of \"unknown\" fields, we use the\n                // primitive toJSON conversion (which is serializable). Technically\n                // we can include isNone in here as well (\"null\" is allowed), however\n                // for empty fields we just skip it completely (historical compat)\n                result[key] = value.toJSON();\n            }\n        }\n        return objectSpread(result, {\n            // the known defaults as managed explicitly and has different\n            // formatting in cases, e.g. we mostly expose a hex format here\n            address: this.address.toString(),\n            blockHash: this.blockHash.toHex(),\n            blockNumber: this.blockNumber.toHex(),\n            era: this.era.toHex(),\n            genesisHash: this.genesisHash.toHex(),\n            method: this.method.toHex(),\n            nonce: this.nonce.toHex(),\n            signedExtensions: this.signedExtensions.map((e) => e.toString()),\n            specVersion: this.runtimeVersion.specVersion.toHex(),\n            tip: this.tip.toHex(),\n            transactionVersion: this.runtimeVersion.transactionVersion.toHex(),\n            version: this.version.toNumber()\n        });\n    }\n    /**\n     * @description Creates a representation of the payload in raw Exrinsic form\n     */\n    toRaw() {\n        const payload = this.toPayload();\n        const data = u8aToHex(this.registry\n            .createTypeUnsafe('ExtrinsicPayload', [payload, { version: payload.version }])\n            // NOTE Explicitly pass the bare flag so the method is encoded un-prefixed (non-decodable, for signing only)\n            .toU8a({ method: true }));\n        return {\n            address: payload.address,\n            data,\n            type: 'payload'\n        };\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}