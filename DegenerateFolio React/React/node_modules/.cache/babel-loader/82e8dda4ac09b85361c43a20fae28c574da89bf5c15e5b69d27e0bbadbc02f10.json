{"ast":null,"code":"var _jsxFileName = \"/home/ryoitsu/Documents/test/react-todo-app/src/index.js\";\nimport ShadertoyReact from \"shadertoy-react\";\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './css/index.css';\nimport TodoApp from './components/todo.jsx';\nimport reportWebVitals from './reportWebVitals';\nimport vertex from './shaders/mosaic/mosaic.vert';\nimport fragment from './shaders/mosaic/mosaic.frag';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nconst fragmentShader = `\n // \"Fractal Cartoon\" - former \"DE edge detection\" by Kali\n\n // There are no lights and no AO, only color by normals and dark edges.\n\n // update: Nyan Cat cameo, thanks to code from mu6k: https://www.shadertoy.com/view/4dXGWH\n\n\n //#define SHOWONLYEDGES\n #define NYAN\n #define WAVES\n #define BORDER\n\n #define RAY_STEPS 150\n\n #define BRIGHTNESS 1.2\n #define GAMMA 1.4\n #define SATURATION .65\n\n\n #define detail .001\n #define t iTime*.5\n\n\n const vec3 origin=vec3(-1.,.7,0.);\n float det=0.0;\n\n\n // 2D rotation function\n mat2 rot(float a) {\n     return mat2(cos(a),sin(a),-sin(a),cos(a));\n }\n\n // \"Amazing Surface\" fractal\n vec4 formula(vec4 p) {\n     p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n     p.y-=.25;\n     p.xy*=rot(radians(35.));\n     p=p*2./clamp(dot(p.xyz,p.xyz),.2,1.);\n     return p;\n }\n\n // Distance function\n float de(vec3 pos) {\n     #ifdef WAVES\n     pos.y+=sin(pos.z-t*6.)*.15; //waves!\n     #endif\n     float hid=0.;\n     vec3 tpos=pos;\n     tpos.z=abs(3.-mod(tpos.z,6.));\n     vec4 p=vec4(tpos,1.);\n     for (int i=0; i<4; i++) {p=formula(p);}\n     float fr=(length(max(vec2(0.),p.yz-1.5))-1.)/p.w;\n     float ro=max(abs(pos.x+1.)-.3,pos.y-.35);\n     ro=max(ro,-max(abs(pos.x+1.)-.1,pos.y-.5));\n     pos.z=abs(.25-mod(pos.z,.5));\n     ro=max(ro,-max(abs(pos.z)-.2,pos.y-.3));\n     ro=max(ro,-max(abs(pos.z)-.01,-pos.y+.32));\n     float d=min(fr,ro);\n     return d;\n }\n\n\n // Camera path\n vec3 path(float ti) {\n     ti*=1.5;\n     vec3  p=vec3(sin(ti),(1.-sin(ti*2.))*.5,-ti*5.)*.5;\n     return p;\n }\n\n // Calc normals, and here is edge detection, set to variable \"edge\"\n\n float edge=0.;\n vec3 normal(vec3 p) {\n     vec3 e = vec3(0.0,det*5.,0.0);\n\n     float d1=de(p-e.yxx),d2=de(p+e.yxx);\n     float d3=de(p-e.xyx),d4=de(p+e.xyx);\n     float d5=de(p-e.xxy),d6=de(p+e.xxy);\n     float d=de(p);\n     edge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5));//edge finder\n     edge=min(1.,pow(edge,.55)*15.);\n     return normalize(vec3(d1-d2,d3-d4,d5-d6));\n }\n\n\n // Used Nyan Cat code by mu6k, with some mods\n\n vec4 rainbow(vec2 p)\n {\n     float q = max(p.x,-0.1);\n     float s = sin(p.x*7.0+t*70.0)*0.08;\n     p.y+=s;\n     p.y*=1.1;\n\n     vec4 c;\n     if (p.x>0.0) c=vec4(0,0,0,0); else\n         if (0.0/6.0<p.y&&p.y<1.0/6.0) c= vec4(255,43,14,255)/255.0; else\n             if (1.0/6.0<p.y&&p.y<2.0/6.0) c= vec4(255,168,6,255)/255.0; else\n                 if (2.0/6.0<p.y&&p.y<3.0/6.0) c= vec4(255,244,0,255)/255.0; else\n                     if (3.0/6.0<p.y&&p.y<4.0/6.0) c= vec4(51,234,5,255)/255.0; else\n                         if (4.0/6.0<p.y&&p.y<5.0/6.0) c= vec4(8,163,255,255)/255.0; else\n                             if (5.0/6.0<p.y&&p.y<6.0/6.0) c= vec4(122,85,255,255)/255.0; else\n                                 if (abs(p.y)-.05<0.0001) c=vec4(0.,0.,0.,1.); else\n                                     if (abs(p.y-1.)-.05<0.0001) c=vec4(0.,0.,0.,1.); else\n                                         c=vec4(0,0,0,0);\n     c.a*=.8-min(.8,abs(p.x*.08));\n     c.xyz=mix(c.xyz,vec3(length(c.xyz)),.15);\n     return c;\n }\n\n vec4 nyan(vec2 p)\n {\n     vec2 uv = p*vec2(0.4,1.0);\n     float ns=3.0;\n     float nt = iTime*ns; nt-=mod(nt,240.0/256.0/6.0); nt = mod(nt,240.0/256.0);\n     float ny = mod(iTime*ns,1.0); ny-=mod(ny,0.75); ny*=-0.05;\n     vec4 color = texture(iChannel1,vec2(uv.x/3.0+210.0/256.0-nt+0.05,.5-uv.y-ny));\n     if (uv.x<-0.3) color.a = 0.0;\n     if (uv.x>0.2) color.a=0.0;\n     return color;\n }\n\n\n // Raymarching and 2D graphics\n\n vec3 raymarch(in vec3 from, in vec3 dir)\n\n {\n     edge=0.;\n     vec3 p, norm;\n     float d=100.;\n     float totdist=0.;\n     for (int i=0; i<RAY_STEPS; i++) {\n         if (d>det && totdist<25.0) {\n             p=from+totdist*dir;\n             d=de(p);\n             det=detail*exp(.13*totdist);\n             totdist+=d;\n         }\n     }\n     vec3 col=vec3(0.);\n     p-=(det-d)*dir;\n     norm=normal(p);\n     #ifdef SHOWONLYEDGES\n     col=1.-vec3(edge); // show wireframe version\n     #else\n     col=(1.-abs(norm))*max(0.,1.-edge*.8); // set normal as color with dark edges\n     #endif\n     totdist=clamp(totdist,0.,26.);\n     dir.y-=.02;\n     float sunsize=7.-max(0.,texture(iChannel0,vec2(.6,.2)).x)*5.; // responsive sun size\n     float an=atan(dir.x,dir.y)+iTime*1.5; // angle for drawing and rotating sun\n     float s=pow(clamp(1.0-length(dir.xy)*sunsize-abs(.2-mod(an,.4)),0.,1.),.1); // sun\n     float sb=pow(clamp(1.0-length(dir.xy)*(sunsize-.2)-abs(.2-mod(an,.4)),0.,1.),.1); // sun border\n     float sg=pow(clamp(1.0-length(dir.xy)*(sunsize-4.5)-.5*abs(.2-mod(an,.4)),0.,1.),3.); // sun rays\n     float y=mix(.45,1.2,pow(smoothstep(0.,1.,.75-dir.y),2.))*(1.-sb*.5); // gradient sky\n\n     // set up background with sky and sun\n     vec3 backg=vec3(0.5,0.,1.)*((1.-s)*(1.-sg)*y+(1.-sb)*sg*vec3(1.,.8,0.15)*3.);\n     backg+=vec3(1.,.9,.1)*s;\n     backg=max(backg,sg*vec3(1.,.9,.5));\n\n     col=mix(vec3(1.,.9,.3),col,exp(-.004*totdist*totdist));// distant fading to sun color\n     if (totdist>25.) col=backg; // hit background\n     col=pow(col,vec3(GAMMA))*BRIGHTNESS;\n     col=mix(vec3(length(col)),col,SATURATION);\n     #ifdef SHOWONLYEDGES\n     col=1.-vec3(length(col));\n     #else\n     col*=vec3(1.,.9,.85);\n     #ifdef NYAN\n     dir.yx*=rot(dir.x);\n     vec2 ncatpos=(dir.xy+vec2(-3.+mod(-t,6.),-.27));\n     vec4 ncat=nyan(ncatpos*5.);\n     vec4 rain=rainbow(ncatpos*10.+vec2(.8,.5));\n     if (totdist>8.) col=mix(col,max(vec3(.2),rain.xyz),rain.a*.9);\n     if (totdist>8.) col=mix(col,max(vec3(.2),ncat.xyz),ncat.a*.9);\n     #endif\n     #endif\n     return col;\n }\n\n // get camera position\n vec3 move(inout vec3 dir) {\n     vec3 go=path(t);\n     vec3 adv=path(t+.7);\n     float hd=de(adv);\n     vec3 advec=normalize(adv-go);\n     float an=adv.x-go.x; an*=min(1.,abs(adv.z-go.z))*sign(adv.z-go.z)*.7;\n     dir.xy*=mat2(cos(an),sin(an),-sin(an),cos(an));\n     an=advec.y*1.7;\n     dir.yz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n     an=atan(advec.x,advec.z);\n     dir.xz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n     return go;\n }\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n     vec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n     vec2 oriuv=uv;\n     uv.y*=iResolution.y/iResolution.x;\n     vec2 mouse=(iMouse.xy/iResolution.xy-.5)*3.;\n     if (iMouse.z<1.) mouse=vec2(0.,-0.05);\n     float fov=.9-max(0.,.7-iTime*.3);\n     vec3 dir=normalize(vec3(uv*fov,1.));\n     dir.yz*=rot(mouse.y);\n     dir.xz*=rot(mouse.x);\n     vec3 from=origin+move(dir);\n     vec3 color=raymarch(from,dir);\n     #ifdef BORDER\n     color=mix(vec3(0.),color,pow(max(0.,.95-length(oriuv*oriuv*oriuv*vec2(1.05,1.1))),.3));\n     #endif\n     fragColor = vec4(color,1.);\n }\n `;\nroot.render( /*#__PURE__*/_jsxDEV(_Fragment, {\n  children: [/*#__PURE__*/_jsxDEV(ShadertoyReact, {\n    fs: fragmentShader\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 231,\n    columnNumber: 5\n  }, this), /*#__PURE__*/_jsxDEV(TodoApp, {}, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 232,\n    columnNumber: 1\n  }, this), /*#__PURE__*/_jsxDEV(\"footer\", {\n    children: \"\\xA92024 Ultra Degenerate Labs, No Rights Reserved\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 233,\n    columnNumber: 1\n  }, this)]\n}, void 0, true));\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();","map":{"version":3,"names":["ShadertoyReact","React","ReactDOM","TodoApp","reportWebVitals","vertex","fragment","jsxDEV","_jsxDEV","Fragment","_Fragment","root","createRoot","document","getElementById","fragmentShader","render","children","fs","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/src/index.js"],"sourcesContent":["import ShadertoyReact from \"shadertoy-react\";\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './css/index.css';\nimport TodoApp from './components/todo.jsx';\nimport reportWebVitals from './reportWebVitals';\nimport vertex from './shaders/mosaic/mosaic.vert';\nimport fragment from './shaders/mosaic/mosaic.frag';\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n\n const fragmentShader = `\n // \"Fractal Cartoon\" - former \"DE edge detection\" by Kali\n\n // There are no lights and no AO, only color by normals and dark edges.\n\n // update: Nyan Cat cameo, thanks to code from mu6k: https://www.shadertoy.com/view/4dXGWH\n\n\n //#define SHOWONLYEDGES\n #define NYAN\n #define WAVES\n #define BORDER\n\n #define RAY_STEPS 150\n\n #define BRIGHTNESS 1.2\n #define GAMMA 1.4\n #define SATURATION .65\n\n\n #define detail .001\n #define t iTime*.5\n\n\n const vec3 origin=vec3(-1.,.7,0.);\n float det=0.0;\n\n\n // 2D rotation function\n mat2 rot(float a) {\n     return mat2(cos(a),sin(a),-sin(a),cos(a));\n }\n\n // \"Amazing Surface\" fractal\n vec4 formula(vec4 p) {\n     p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n     p.y-=.25;\n     p.xy*=rot(radians(35.));\n     p=p*2./clamp(dot(p.xyz,p.xyz),.2,1.);\n     return p;\n }\n\n // Distance function\n float de(vec3 pos) {\n     #ifdef WAVES\n     pos.y+=sin(pos.z-t*6.)*.15; //waves!\n     #endif\n     float hid=0.;\n     vec3 tpos=pos;\n     tpos.z=abs(3.-mod(tpos.z,6.));\n     vec4 p=vec4(tpos,1.);\n     for (int i=0; i<4; i++) {p=formula(p);}\n     float fr=(length(max(vec2(0.),p.yz-1.5))-1.)/p.w;\n     float ro=max(abs(pos.x+1.)-.3,pos.y-.35);\n     ro=max(ro,-max(abs(pos.x+1.)-.1,pos.y-.5));\n     pos.z=abs(.25-mod(pos.z,.5));\n     ro=max(ro,-max(abs(pos.z)-.2,pos.y-.3));\n     ro=max(ro,-max(abs(pos.z)-.01,-pos.y+.32));\n     float d=min(fr,ro);\n     return d;\n }\n\n\n // Camera path\n vec3 path(float ti) {\n     ti*=1.5;\n     vec3  p=vec3(sin(ti),(1.-sin(ti*2.))*.5,-ti*5.)*.5;\n     return p;\n }\n\n // Calc normals, and here is edge detection, set to variable \"edge\"\n\n float edge=0.;\n vec3 normal(vec3 p) {\n     vec3 e = vec3(0.0,det*5.,0.0);\n\n     float d1=de(p-e.yxx),d2=de(p+e.yxx);\n     float d3=de(p-e.xyx),d4=de(p+e.xyx);\n     float d5=de(p-e.xxy),d6=de(p+e.xxy);\n     float d=de(p);\n     edge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5));//edge finder\n     edge=min(1.,pow(edge,.55)*15.);\n     return normalize(vec3(d1-d2,d3-d4,d5-d6));\n }\n\n\n // Used Nyan Cat code by mu6k, with some mods\n\n vec4 rainbow(vec2 p)\n {\n     float q = max(p.x,-0.1);\n     float s = sin(p.x*7.0+t*70.0)*0.08;\n     p.y+=s;\n     p.y*=1.1;\n\n     vec4 c;\n     if (p.x>0.0) c=vec4(0,0,0,0); else\n         if (0.0/6.0<p.y&&p.y<1.0/6.0) c= vec4(255,43,14,255)/255.0; else\n             if (1.0/6.0<p.y&&p.y<2.0/6.0) c= vec4(255,168,6,255)/255.0; else\n                 if (2.0/6.0<p.y&&p.y<3.0/6.0) c= vec4(255,244,0,255)/255.0; else\n                     if (3.0/6.0<p.y&&p.y<4.0/6.0) c= vec4(51,234,5,255)/255.0; else\n                         if (4.0/6.0<p.y&&p.y<5.0/6.0) c= vec4(8,163,255,255)/255.0; else\n                             if (5.0/6.0<p.y&&p.y<6.0/6.0) c= vec4(122,85,255,255)/255.0; else\n                                 if (abs(p.y)-.05<0.0001) c=vec4(0.,0.,0.,1.); else\n                                     if (abs(p.y-1.)-.05<0.0001) c=vec4(0.,0.,0.,1.); else\n                                         c=vec4(0,0,0,0);\n     c.a*=.8-min(.8,abs(p.x*.08));\n     c.xyz=mix(c.xyz,vec3(length(c.xyz)),.15);\n     return c;\n }\n\n vec4 nyan(vec2 p)\n {\n     vec2 uv = p*vec2(0.4,1.0);\n     float ns=3.0;\n     float nt = iTime*ns; nt-=mod(nt,240.0/256.0/6.0); nt = mod(nt,240.0/256.0);\n     float ny = mod(iTime*ns,1.0); ny-=mod(ny,0.75); ny*=-0.05;\n     vec4 color = texture(iChannel1,vec2(uv.x/3.0+210.0/256.0-nt+0.05,.5-uv.y-ny));\n     if (uv.x<-0.3) color.a = 0.0;\n     if (uv.x>0.2) color.a=0.0;\n     return color;\n }\n\n\n // Raymarching and 2D graphics\n\n vec3 raymarch(in vec3 from, in vec3 dir)\n\n {\n     edge=0.;\n     vec3 p, norm;\n     float d=100.;\n     float totdist=0.;\n     for (int i=0; i<RAY_STEPS; i++) {\n         if (d>det && totdist<25.0) {\n             p=from+totdist*dir;\n             d=de(p);\n             det=detail*exp(.13*totdist);\n             totdist+=d;\n         }\n     }\n     vec3 col=vec3(0.);\n     p-=(det-d)*dir;\n     norm=normal(p);\n     #ifdef SHOWONLYEDGES\n     col=1.-vec3(edge); // show wireframe version\n     #else\n     col=(1.-abs(norm))*max(0.,1.-edge*.8); // set normal as color with dark edges\n     #endif\n     totdist=clamp(totdist,0.,26.);\n     dir.y-=.02;\n     float sunsize=7.-max(0.,texture(iChannel0,vec2(.6,.2)).x)*5.; // responsive sun size\n     float an=atan(dir.x,dir.y)+iTime*1.5; // angle for drawing and rotating sun\n     float s=pow(clamp(1.0-length(dir.xy)*sunsize-abs(.2-mod(an,.4)),0.,1.),.1); // sun\n     float sb=pow(clamp(1.0-length(dir.xy)*(sunsize-.2)-abs(.2-mod(an,.4)),0.,1.),.1); // sun border\n     float sg=pow(clamp(1.0-length(dir.xy)*(sunsize-4.5)-.5*abs(.2-mod(an,.4)),0.,1.),3.); // sun rays\n     float y=mix(.45,1.2,pow(smoothstep(0.,1.,.75-dir.y),2.))*(1.-sb*.5); // gradient sky\n\n     // set up background with sky and sun\n     vec3 backg=vec3(0.5,0.,1.)*((1.-s)*(1.-sg)*y+(1.-sb)*sg*vec3(1.,.8,0.15)*3.);\n     backg+=vec3(1.,.9,.1)*s;\n     backg=max(backg,sg*vec3(1.,.9,.5));\n\n     col=mix(vec3(1.,.9,.3),col,exp(-.004*totdist*totdist));// distant fading to sun color\n     if (totdist>25.) col=backg; // hit background\n     col=pow(col,vec3(GAMMA))*BRIGHTNESS;\n     col=mix(vec3(length(col)),col,SATURATION);\n     #ifdef SHOWONLYEDGES\n     col=1.-vec3(length(col));\n     #else\n     col*=vec3(1.,.9,.85);\n     #ifdef NYAN\n     dir.yx*=rot(dir.x);\n     vec2 ncatpos=(dir.xy+vec2(-3.+mod(-t,6.),-.27));\n     vec4 ncat=nyan(ncatpos*5.);\n     vec4 rain=rainbow(ncatpos*10.+vec2(.8,.5));\n     if (totdist>8.) col=mix(col,max(vec3(.2),rain.xyz),rain.a*.9);\n     if (totdist>8.) col=mix(col,max(vec3(.2),ncat.xyz),ncat.a*.9);\n     #endif\n     #endif\n     return col;\n }\n\n // get camera position\n vec3 move(inout vec3 dir) {\n     vec3 go=path(t);\n     vec3 adv=path(t+.7);\n     float hd=de(adv);\n     vec3 advec=normalize(adv-go);\n     float an=adv.x-go.x; an*=min(1.,abs(adv.z-go.z))*sign(adv.z-go.z)*.7;\n     dir.xy*=mat2(cos(an),sin(an),-sin(an),cos(an));\n     an=advec.y*1.7;\n     dir.yz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n     an=atan(advec.x,advec.z);\n     dir.xz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n     return go;\n }\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n     vec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n     vec2 oriuv=uv;\n     uv.y*=iResolution.y/iResolution.x;\n     vec2 mouse=(iMouse.xy/iResolution.xy-.5)*3.;\n     if (iMouse.z<1.) mouse=vec2(0.,-0.05);\n     float fov=.9-max(0.,.7-iTime*.3);\n     vec3 dir=normalize(vec3(uv*fov,1.));\n     dir.yz*=rot(mouse.y);\n     dir.xz*=rot(mouse.x);\n     vec3 from=origin+move(dir);\n     vec3 color=raymarch(from,dir);\n     #ifdef BORDER\n     color=mix(vec3(0.),color,pow(max(0.,.95-length(oriuv*oriuv*oriuv*vec2(1.05,1.1))),.3));\n     #endif\n     fragColor = vec4(color,1.);\n }\n `;\n\nroot.render(\n    <>\n    <ShadertoyReact fs={fragmentShader} />\n<TodoApp />\n<footer>Â©2024 Ultra Degenerate Labs, No Rights Reserved</footer>\n</>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"mappings":";AAAA,OAAOA,cAAc,MAAM,iBAAiB;AAC5C,OAAOC,KAAK,MAAM,OAAO;AACzB,OAAOC,QAAQ,MAAM,kBAAkB;AACvC,OAAO,iBAAiB;AACxB,OAAOC,OAAO,MAAM,uBAAuB;AAC3C,OAAOC,eAAe,MAAM,mBAAmB;AAC/C,OAAOC,MAAM,MAAM,8BAA8B;AACjD,OAAOC,QAAQ,MAAM,8BAA8B;AAAC,SAAAC,MAAA,IAAAC,OAAA,EAAAC,QAAA,IAAAC,SAAA;AACpD,MAAMC,IAAI,GAAGT,QAAQ,CAACU,UAAU,CAACC,QAAQ,CAACC,cAAc,CAAC,MAAM,CAAC,CAAC;AAEhE,MAAMC,cAAc,GAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AAEFJ,IAAI,CAACK,MAAM,eACPR,OAAA,CAAAE,SAAA;EAAAO,QAAA,gBACAT,OAAA,CAACR,cAAc;IAACkB,EAAE,EAAEH;EAAe;IAAAI,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAE,CAAC,eAC1Cd,OAAA,CAACL,OAAO;IAAAgB,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAE,CAAC,eACXd,OAAA;IAAAS,QAAA,EAAQ;EAA+C;IAAAE,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAQ,CAAC;AAAA,eAC9D,CACF,CAAC;;AAED;AACA;AACA;AACAlB,eAAe,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}