{"ast":null,"code":"import { TARGETS } from \"@pixi/constants\";\nimport { AbstractMultiResource } from \"./AbstractMultiResource.mjs\";\nconst _CubeResource = class _CubeResource2 extends AbstractMultiResource {\n  /**\n   * @param {Array<string|PIXI.Resource>} [source] - Collection of URLs or resources\n   *        to use as the sides of the cube.\n   * @param options - ImageResource options\n   * @param {number} [options.width] - Width of resource\n   * @param {number} [options.height] - Height of resource\n   * @param {number} [options.autoLoad=true] - Whether to auto-load resources\n   * @param {number} [options.linkBaseTexture=true] - In case BaseTextures are supplied,\n   *   whether to copy them or use\n   */\n  constructor(source, options) {\n    const {\n      width,\n      height,\n      autoLoad,\n      linkBaseTexture\n    } = options || {};\n    if (source && source.length !== _CubeResource2.SIDES) throw new Error(`Invalid length. Got ${source.length}, expected 6`);\n    super(6, {\n      width,\n      height\n    });\n    for (let i = 0; i < _CubeResource2.SIDES; i++) this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;\n    this.linkBaseTexture = linkBaseTexture !== !1, source && this.initFromArray(source, options), autoLoad !== !1 && this.load();\n  }\n  /**\n   * Add binding.\n   * @param baseTexture - parent base texture\n   */\n  bind(baseTexture) {\n    super.bind(baseTexture), baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;\n  }\n  addBaseTextureAt(baseTexture, index, linkBaseTexture) {\n    if (linkBaseTexture === void 0 && (linkBaseTexture = this.linkBaseTexture), !this.items[index]) throw new Error(`Index ${index} is out of bounds`);\n    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {\n      if (baseTexture.resource) this.addResourceAt(baseTexture.resource, index);else throw new Error(\"CubeResource does not support copying of renderTexture.\");\n    } else baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index, baseTexture.parentTextureArray = this.baseTexture, this.items[index] = baseTexture;\n    return baseTexture.valid && !this.valid && this.resize(baseTexture.realWidth, baseTexture.realHeight), this.items[index] = baseTexture, this;\n  }\n  /**\n   * Upload the resource\n   * @param renderer\n   * @param _baseTexture\n   * @param glTexture\n   * @returns {boolean} true is success\n   */\n  upload(renderer, _baseTexture, glTexture) {\n    const dirty = this.itemDirtyIds;\n    for (let i = 0; i < _CubeResource2.SIDES; i++) {\n      const side = this.items[i];\n      (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) && (side.valid && side.resource ? (side.resource.upload(renderer, side, glTexture), dirty[i] = side.dirtyId) : dirty[i] < -1 && (renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null), dirty[i] = -1));\n    }\n    return !0;\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @returns {boolean} `true` if source is an array of 6 elements\n   */\n  static test(source) {\n    return Array.isArray(source) && source.length === _CubeResource2.SIDES;\n  }\n};\n_CubeResource.SIDES = 6;\nlet CubeResource = _CubeResource;\nexport { CubeResource };","map":{"version":3,"names":["_CubeResource","_CubeResource2","AbstractMultiResource","constructor","source","options","width","height","autoLoad","linkBaseTexture","length","SIDES","Error","i","items","target","TARGETS","TEXTURE_CUBE_MAP_POSITIVE_X","initFromArray","load","bind","baseTexture","TEXTURE_CUBE_MAP","addBaseTextureAt","index","parentTextureArray","Object","keys","_glTextures","resource","addResourceAt","valid","resize","realWidth","realHeight","upload","renderer","_baseTexture","glTexture","dirty","itemDirtyIds","side","dirtyId","gl","texImage2D","internalFormat","format","type","test","Array","isArray","CubeResource"],"sources":["/home/ryoitsu/node_modules/@pixi/core/src/textures/resources/CubeResource.ts"],"sourcesContent":["import { TARGETS } from '@pixi/constants';\nimport { AbstractMultiResource } from './AbstractMultiResource';\n\nimport type { ISize } from '@pixi/math';\nimport type { ArrayFixed } from '@pixi/utils';\nimport type { Renderer } from '../../Renderer';\nimport type { BaseTexture } from '../BaseTexture';\nimport type { GLTexture } from '../GLTexture';\nimport type { Resource } from './Resource';\n\n/**\n * Constructor options for CubeResource.\n * @memberof PIXI\n */\nexport interface ICubeResourceOptions extends ISize\n{\n    /** Whether to auto-load resources */\n    autoLoad?: boolean;\n\n    /** In case BaseTextures are supplied, whether to copy them or use. */\n    linkBaseTexture?: boolean;\n}\n\n/**\n * Resource for a CubeTexture which contains six resources.\n * @memberof PIXI\n */\nexport class CubeResource extends AbstractMultiResource\n{\n    items: ArrayFixed<BaseTexture, 6>;\n\n    /**\n     * In case BaseTextures are supplied, whether to use same resource or bind baseTexture itself.\n     * @protected\n     */\n    linkBaseTexture: boolean;\n\n    /**\n     * @param {Array<string|PIXI.Resource>} [source] - Collection of URLs or resources\n     *        to use as the sides of the cube.\n     * @param options - ImageResource options\n     * @param {number} [options.width] - Width of resource\n     * @param {number} [options.height] - Height of resource\n     * @param {number} [options.autoLoad=true] - Whether to auto-load resources\n     * @param {number} [options.linkBaseTexture=true] - In case BaseTextures are supplied,\n     *   whether to copy them or use\n     */\n    constructor(source?: ArrayFixed<string | Resource, 6>, options?: ICubeResourceOptions)\n    {\n        const { width, height, autoLoad, linkBaseTexture } = options || {};\n\n        if (source && source.length !== CubeResource.SIDES)\n        {\n            throw new Error(`Invalid length. Got ${source.length}, expected 6`);\n        }\n\n        super(6, { width, height });\n\n        for (let i = 0; i < CubeResource.SIDES; i++)\n        {\n            this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;\n        }\n\n        this.linkBaseTexture = linkBaseTexture !== false;\n\n        if (source)\n        {\n            this.initFromArray(source, options);\n        }\n\n        if (autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    /**\n     * Add binding.\n     * @param baseTexture - parent base texture\n     */\n    bind(baseTexture: BaseTexture): void\n    {\n        super.bind(baseTexture);\n\n        baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;\n    }\n\n    addBaseTextureAt(baseTexture: BaseTexture, index: number, linkBaseTexture?: boolean): this\n    {\n        if (linkBaseTexture === undefined)\n        {\n            linkBaseTexture = this.linkBaseTexture;\n        }\n\n        if (!this.items[index])\n        {\n            throw new Error(`Index ${index} is out of bounds`);\n        }\n\n        if (!this.linkBaseTexture\n            || baseTexture.parentTextureArray\n            || Object.keys(baseTexture._glTextures).length > 0)\n        {\n            // copy mode\n            if (baseTexture.resource)\n            {\n                this.addResourceAt(baseTexture.resource, index);\n            }\n            else\n            {\n                throw new Error(`CubeResource does not support copying of renderTexture.`);\n            }\n        }\n        else\n        {\n            // link mode, the difficult one!\n            baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index;\n            baseTexture.parentTextureArray = this.baseTexture;\n\n            this.items[index] = baseTexture;\n        }\n\n        if (baseTexture.valid && !this.valid)\n        {\n            this.resize(baseTexture.realWidth, baseTexture.realHeight);\n        }\n\n        this.items[index] = baseTexture;\n\n        return this;\n    }\n\n    /**\n     * Upload the resource\n     * @param renderer\n     * @param _baseTexture\n     * @param glTexture\n     * @returns {boolean} true is success\n     */\n    upload(renderer: Renderer, _baseTexture: BaseTexture, glTexture: GLTexture): boolean\n    {\n        const dirty = this.itemDirtyIds;\n\n        for (let i = 0; i < CubeResource.SIDES; i++)\n        {\n            const side = this.items[i];\n\n            if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId)\n            {\n                if (side.valid && side.resource)\n                {\n                    side.resource.upload(renderer, side, glTexture);\n                    dirty[i] = side.dirtyId;\n                }\n                else if (dirty[i] < -1)\n                {\n                    // either item is not valid yet, either its a renderTexture\n                    // allocate the memory\n                    renderer.gl.texImage2D(side.target, 0,\n                        glTexture.internalFormat,\n                        _baseTexture.realWidth,\n                        _baseTexture.realHeight,\n                        0,\n                        _baseTexture.format,\n                        glTexture.type,\n                        null);\n                    dirty[i] = -1;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /** Number of texture sides to store for CubeResources. */\n    static SIDES = 6;\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @returns {boolean} `true` if source is an array of 6 elements\n     */\n    static test(source: unknown): source is ArrayFixed<string | Resource, 6>\n    {\n        return Array.isArray(source) && source.length === CubeResource.SIDES;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}