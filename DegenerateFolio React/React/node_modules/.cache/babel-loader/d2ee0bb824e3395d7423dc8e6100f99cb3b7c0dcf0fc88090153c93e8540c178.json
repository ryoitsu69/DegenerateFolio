{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;\nconst stream_1 = require(\"@cosmjs/stream\");\nconst xstream_1 = require(\"xstream\");\nconst streamingsocket_1 = require(\"./streamingsocket\");\nvar ConnectionStatus;\n(function (ConnectionStatus) {\n  ConnectionStatus[ConnectionStatus[\"Unconnected\"] = 0] = \"Unconnected\";\n  ConnectionStatus[ConnectionStatus[\"Connecting\"] = 1] = \"Connecting\";\n  ConnectionStatus[ConnectionStatus[\"Connected\"] = 2] = \"Connected\";\n  ConnectionStatus[ConnectionStatus[\"Disconnected\"] = 3] = \"Disconnected\";\n})(ConnectionStatus = exports.ConnectionStatus || (exports.ConnectionStatus = {}));\n/**\n * A wrapper around StreamingSocket that can queue requests.\n */\nclass QueueingStreamingSocket {\n  constructor(url, timeout = 10000, reconnectedHandler) {\n    this.queue = [];\n    this.isProcessingQueue = false;\n    this.url = url;\n    this.timeout = timeout;\n    this.reconnectedHandler = reconnectedHandler;\n    const eventProducer = {\n      start: listener => this.eventProducerListener = listener,\n      stop: () => this.eventProducerListener = undefined\n    };\n    this.events = xstream_1.Stream.create(eventProducer);\n    this.connectionStatusProducer = new stream_1.DefaultValueProducer(ConnectionStatus.Unconnected);\n    this.connectionStatus = new stream_1.ValueAndUpdates(this.connectionStatusProducer);\n    this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);\n    this.socket.events.subscribe({\n      next: event => {\n        if (!this.eventProducerListener) throw new Error(\"No event producer listener set\");\n        this.eventProducerListener.next(event);\n      },\n      error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected)\n    });\n  }\n  connect() {\n    this.connectionStatusProducer.update(ConnectionStatus.Connecting);\n    this.socket.connected.then(async () => {\n      this.connectionStatusProducer.update(ConnectionStatus.Connected);\n      return this.processQueue();\n    }, () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected));\n    this.socket.connect();\n  }\n  disconnect() {\n    this.connectionStatusProducer.update(ConnectionStatus.Disconnected);\n    this.socket.disconnect();\n  }\n  reconnect() {\n    this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);\n    this.socket.events.subscribe({\n      next: event => {\n        if (!this.eventProducerListener) throw new Error(\"No event producer listener set\");\n        this.eventProducerListener.next(event);\n      },\n      error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected)\n    });\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.socket.connected.then(() => {\n      if (this.reconnectedHandler) {\n        this.reconnectedHandler();\n      }\n    });\n    this.connect();\n  }\n  getQueueLength() {\n    return this.queue.length;\n  }\n  queueRequest(request) {\n    this.queue.push(request);\n    // We donâ€™t need to wait for the queue to be processed.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.processQueue();\n  }\n  async processQueue() {\n    if (this.isProcessingQueue || this.connectionStatus.value !== ConnectionStatus.Connected) {\n      return;\n    }\n    this.isProcessingQueue = true;\n    let request;\n    while (request = this.queue.shift()) {\n      try {\n        await this.socket.send(request);\n        this.isProcessingQueue = false;\n      } catch (error) {\n        // Probably the connection is down; will try again automatically when reconnected.\n        this.queue.unshift(request);\n        this.isProcessingQueue = false;\n        return;\n      }\n    }\n  }\n}\nexports.QueueingStreamingSocket = QueueingStreamingSocket;","map":{"version":3,"names":["stream_1","require","xstream_1","streamingsocket_1","ConnectionStatus","exports","QueueingStreamingSocket","constructor","url","timeout","reconnectedHandler","queue","isProcessingQueue","eventProducer","start","listener","eventProducerListener","stop","undefined","events","Stream","create","connectionStatusProducer","DefaultValueProducer","Unconnected","connectionStatus","ValueAndUpdates","socket","StreamingSocket","subscribe","next","event","Error","error","update","Disconnected","connect","Connecting","connected","then","Connected","processQueue","disconnect","reconnect","getQueueLength","length","queueRequest","request","push","value","shift","send","unshift"],"sources":["../src/queueingstreamingsocket.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}