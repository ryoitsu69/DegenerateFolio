{"ast":null,"code":"import { Color } from '../../../../color/Color.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds.mjs';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { RenderTexture } from '../texture/RenderTexture.mjs';\n\"use strict\";\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor = [0, 0, 0, 0];\nclass GenerateTextureSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * A Useful function that returns a texture of the display object that can then be used to create sprites\n   * This can be quite useful if your container is complicated and needs to be reused multiple times.\n   * @param {GenerateTextureOptions | Container} options - Generate texture options.\n   * @param {Container} [options.container] - If not given, the renderer's resolution is used.\n   * @param {Rectangle} options.region - The region of the container, that shall be rendered,\n   * @param {number} [options.resolution] - The resolution of the texture being generated.\n   *        if no region is specified, defaults to the local bounds of the container.\n   * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.\n   * @returns a shiny new texture of the container passed in\n   */\n  generateTexture(options) {\n    if (options instanceof Container) {\n      options = {\n        target: options,\n        frame: void 0,\n        textureSourceOptions: {},\n        resolution: void 0\n      };\n    }\n    const resolution = options.resolution || this._renderer.resolution;\n    const antialias = options.antialias || this._renderer.view.antialias;\n    const container = options.target;\n    let clearColor = options.clearColor;\n    if (clearColor) {\n      const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n      clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n    } else {\n      clearColor = noColor;\n    }\n    const region = options.frame?.copyTo(tempRect) || getLocalBounds(container, tempBounds).rectangle;\n    region.width = Math.max(region.width, 1 / resolution) | 0;\n    region.height = Math.max(region.height, 1 / resolution) | 0;\n    const target = RenderTexture.create({\n      ...options.textureSourceOptions,\n      width: region.width,\n      height: region.height,\n      resolution,\n      antialias\n    });\n    const transform = Matrix.shared.translate(-region.x, -region.y);\n    this._renderer.render({\n      container,\n      transform,\n      target,\n      clearColor\n    });\n    return target;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGenerateTextureSystem.extension = {\n  type: [ExtensionType.WebGLSystem, ExtensionType.WebGPUSystem],\n  name: \"textureGenerator\"\n};\nexport { GenerateTextureSystem };","map":{"version":3,"names":["tempRect","Rectangle","tempBounds","Bounds","noColor","GenerateTextureSystem","constructor","renderer","_renderer","generateTexture","options","Container","target","frame","textureSourceOptions","resolution","antialias","view","container","clearColor","isRGBAArray","Array","isArray","length","Color","shared","setValue","toArray","region","copyTo","getLocalBounds","rectangle","width","Math","max","height","RenderTexture","create","transform","Matrix","translate","x","y","render","destroy","extension","type","ExtensionType","WebGLSystem","WebGPUSystem","name"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/shared/extract/GenerateTextureSystem.ts"],"sourcesContent":["import { Color, type ColorSource } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds';\nimport { Container } from '../../../../scene/container/Container';\nimport { RenderTexture } from '../texture/RenderTexture';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { TextureSourceOptions } from '../texture/sources/TextureSource';\nimport type { Texture } from '../texture/Texture';\n\nexport type GenerateTextureSourceOptions = Omit<TextureSourceOptions, 'resource' | 'width' | 'height' | 'resolution'>;\n\n/**\n * Options for generating a texture from a container.\n * @memberof rendering\n */\nexport type GenerateTextureOptions =\n{\n    /** The container to generate the texture from */\n    target: Container;\n    /**\n     * The region of the container, that shall be rendered,\n     * if no region is specified, defaults to the local bounds of the container.\n     */\n    frame?: Rectangle;\n    /** The resolution of the texture being generated. */\n    resolution?: number;\n    /** The color used to clear the texture. */\n    clearColor?: ColorSource;\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    antialias?: boolean;\n    /** The options passed to the texture source. */\n    textureSourceOptions?: GenerateTextureSourceOptions,\n};\n\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor: ColorSource = [0, 0, 0, 0];\n\n/**\n * System that manages the generation of textures from the renderer\n *\n *\n * Do not instantiate these plugins directly. It is available from the `renderer.textureGenerator` property.\n * @memberof rendering\n */\nexport class GenerateTextureSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGenerator',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * A Useful function that returns a texture of the display object that can then be used to create sprites\n     * This can be quite useful if your container is complicated and needs to be reused multiple times.\n     * @param {GenerateTextureOptions | Container} options - Generate texture options.\n     * @param {Container} [options.container] - If not given, the renderer's resolution is used.\n     * @param {Rectangle} options.region - The region of the container, that shall be rendered,\n     * @param {number} [options.resolution] - The resolution of the texture being generated.\n     *        if no region is specified, defaults to the local bounds of the container.\n     * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.\n     * @returns a shiny new texture of the container passed in\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): Texture\n    {\n        if (options instanceof Container)\n        {\n            options = {\n                target: options,\n                frame: undefined,\n                textureSourceOptions: {},\n                resolution: undefined,\n            };\n        }\n\n        const resolution = options.resolution || this._renderer.resolution;\n        const antialias = options.antialias || this._renderer.view.antialias;\n\n        const container = options.target;\n\n        let clearColor = options.clearColor;\n\n        if (clearColor)\n        {\n            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n\n            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n        }\n        else\n        {\n            clearColor = noColor;\n        }\n\n        const region = options.frame?.copyTo(tempRect)\n            || getLocalBounds(container, tempBounds).rectangle;\n\n        region.width = Math.max(region.width, 1 / resolution) | 0;\n        region.height = Math.max(region.height, 1 / resolution) | 0;\n\n        const target = RenderTexture.create({\n            ...options.textureSourceOptions,\n            width: region.width,\n            height: region.height,\n            resolution,\n            antialias,\n        });\n\n        const transform = Matrix.shared.translate(-region.x, -region.y);\n\n        this._renderer.render({\n            container,\n            transform,\n            target,\n            clearColor,\n        });\n\n        return target;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n    }\n}\n"],"mappings":";;;;;;;;;AAuCA,MAAMA,QAAA,GAAW,IAAIC,SAAU;AAC/B,MAAMC,UAAA,GAAa,IAAIC,MAAO;AAC9B,MAAMC,OAAuB,IAAC,CAAG,KAAG,GAAG,CAAC;AASjC,MAAMC,qBACb;EAYIC,YAAYC,QACZ;IACI,KAAKC,SAAY,GAAAD,QAAA;EAAA;EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAaOE,gBAAgBC,OACvB;IACI,IAAIA,OAAA,YAAmBC,SACvB;MACcD,OAAA;QACNE,MAAQ,EAAAF,OAAA;QACRG,KAAO;QACPC,oBAAA,EAAsB,EAAC;QACvBC,UAAY;MAAA,CAChB;IAAA;IAGJ,MAAMA,UAAa,GAAAL,OAAA,CAAQK,UAAc,SAAKP,SAAU,CAAAO,UAAA;IACxD,MAAMC,SAAY,GAAAN,OAAA,CAAQM,SAAa,SAAKR,SAAA,CAAUS,IAAK,CAAAD,SAAA;IAE3D,MAAME,SAAA,GAAYR,OAAQ,CAAAE,MAAA;IAE1B,IAAIO,UAAA,GAAaT,OAAQ,CAAAS,UAAA;IAEzB,IAAIA,UACJ;MACI,MAAMC,WAAA,GAAcC,KAAM,CAAAC,OAAA,CAAQH,UAAU,KAAKA,UAAA,CAAWI,MAAW;MAEvEJ,UAAA,GAAaC,WAAA,GAAcD,UAAa,GAAAK,KAAA,CAAMC,MAAA,CAAOC,QAAS,CAAAP,UAAU,EAAEQ,OAAQ;IAAA,CAGtF;MACiBR,UAAA,GAAAf,OAAA;IAAA;IAGX,MAAAwB,MAAA,GAASlB,OAAA,CAAQG,KAAO,EAAAgB,MAAA,CAAO7B,QAAQ,CACtC,IAAA8B,cAAA,CAAeZ,SAAW,EAAAhB,UAAU,CAAE,CAAA6B,SAAA;IAE7CH,MAAA,CAAOI,KAAA,GAAQC,IAAK,CAAAC,GAAA,CAAIN,MAAA,CAAOI,KAAO,MAAIjB,UAAU,CAAI;IACxDa,MAAA,CAAOO,MAAA,GAASF,IAAK,CAAAC,GAAA,CAAIN,MAAA,CAAOO,MAAQ,MAAIpB,UAAU,CAAI;IAEpD,MAAAH,MAAA,GAASwB,aAAA,CAAcC,MAAO;MAChC,GAAG3B,OAAQ,CAAAI,oBAAA;MACXkB,KAAA,EAAOJ,MAAO,CAAAI,KAAA;MACdG,MAAA,EAAQP,MAAO,CAAAO,MAAA;MACfpB,UAAA;MACAC;IAAA,CACH;IAEK,MAAAsB,SAAA,GAAYC,MAAA,CAAOd,MAAO,CAAAe,SAAA,CAAU,CAACZ,MAAO,CAAAa,CAAA,EAAG,CAACb,MAAA,CAAOc,CAAC;IAE9D,KAAKlC,SAAA,CAAUmC,MAAO;MAClBzB,SAAA;MACAoB,SAAA;MACA1B,MAAA;MACAO;IAAA,CACH;IAEM,OAAAP,MAAA;EAAA;EAGJgC,OACPA,CAAA;IACK,KAAKpC,SAAqB;EAAA;AAEnC;AAAA;AAzFaH,qBAAA,CAGKwC,SAAY;EACtBC,IAAM,GACFC,aAAc,CAAAC,WAAA,EACdD,aAAc,CAAAE,YAAA,CAClB;EACAC,IAAM;AACV","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}