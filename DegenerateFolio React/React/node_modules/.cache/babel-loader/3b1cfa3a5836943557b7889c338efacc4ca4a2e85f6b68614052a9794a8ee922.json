{"ast":null,"code":"import { compactToU8a, u8aConcatStrict, u8aToHex } from '@polkadot/util';\nimport { compareArray } from '../utils/compareArray.js';\n/**\n * @name AbstractArray\n * @description\n * This manages codec arrays. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n * @noInheritDoc\n */\nexport class AbstractArray extends Array {\n  registry;\n  createdAtHash;\n  initialU8aLength;\n  isStorageFallback;\n  /**\n   * @description This ensures that operators such as clice, filter, map, etc. return\n   * new Array instances (without this we need to apply overrides)\n   */\n  static get [Symbol.species]() {\n    return Array;\n  }\n  constructor(registry, length) {\n    super(length);\n    this.registry = registry;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    // We need to loop through all entries since they may have a variable length themselves,\n    // e.g. when a Vec or Compact is contained withing, it has a variable length based on data\n    const count = this.length;\n    let total = compactToU8a(count).length;\n    for (let i = 0; i < count; i++) {\n      total += this[i].encodedLength;\n    }\n    return total;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n  get isEmpty() {\n    return this.length === 0;\n  }\n  /**\n   * @description The length of the value\n   */\n  get length() {\n    // only included here since we ignore inherited docs\n    return super.length;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return compareArray(this, other);\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return {\n      inner: this.inspectInner(),\n      outer: [compactToU8a(this.length)]\n    };\n  }\n  /**\n   * @internal\n   * @description Internal per-item inspection of internal values\n   */\n  inspectInner() {\n    const count = this.length;\n    const inner = new Array(count);\n    for (let i = 0; i < count; i++) {\n      inner[i] = this[i].inspect();\n    }\n    return inner;\n  }\n  /**\n   * @description Converts the Object to an standard JavaScript Array\n   */\n  toArray() {\n    return Array.from(this);\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExtended, disableAscii) {\n    const count = this.length;\n    const result = new Array(count);\n    for (let i = 0; i < count; i++) {\n      result[i] = this[i] && this[i].toHuman(isExtended, disableAscii);\n    }\n    return result;\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    const count = this.length;\n    const result = new Array(count);\n    for (let i = 0; i < count; i++) {\n      // We actually log inside the U8a decoding and use JSON.stringify(...), which\n      // means that the Vec may be partially populated (same applies to toHuman, same check)\n      result[i] = this[i] && this[i].toJSON();\n    }\n    return result;\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive(disableAscii) {\n    const count = this.length;\n    const result = new Array(count);\n    for (let i = 0; i < count; i++) {\n      result[i] = this[i] && this[i].toPrimitive(disableAscii);\n    }\n    return result;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    const count = this.length;\n    const result = new Array(count);\n    for (let i = 0; i < count; i++) {\n      result[i] = this[i].toString();\n    }\n    return `[${result.join(', ')}]`;\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    const encoded = this.toU8aInner();\n    return isBare ? u8aConcatStrict(encoded) : u8aConcatStrict([compactToU8a(this.length), ...encoded]);\n  }\n  /**\n   * @internal\n   * @description Internal per-item SCALE encoding of contained values\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8aInner(isBare) {\n    const count = this.length;\n    const encoded = new Array(count);\n    for (let i = 0; i < count; i++) {\n      encoded[i] = this[i].toU8a(isBare);\n    }\n    return encoded;\n  }\n}","map":{"version":3,"names":["compactToU8a","u8aConcatStrict","u8aToHex","compareArray","AbstractArray","Array","registry","createdAtHash","initialU8aLength","isStorageFallback","Symbol","species","constructor","length","encodedLength","count","total","i","hash","toU8a","isEmpty","eq","other","inspect","inner","inspectInner","outer","toArray","from","toHex","toHuman","isExtended","disableAscii","result","toJSON","toPrimitive","toString","join","isBare","encoded","toU8aInner"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/abstract/Array.js"],"sourcesContent":["import { compactToU8a, u8aConcatStrict, u8aToHex } from '@polkadot/util';\nimport { compareArray } from '../utils/compareArray.js';\n/**\n * @name AbstractArray\n * @description\n * This manages codec arrays. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n * @noInheritDoc\n */\nexport class AbstractArray extends Array {\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    /**\n     * @description This ensures that operators such as clice, filter, map, etc. return\n     * new Array instances (without this we need to apply overrides)\n     */\n    static get [Symbol.species]() {\n        return Array;\n    }\n    constructor(registry, length) {\n        super(length);\n        this.registry = registry;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        // We need to loop through all entries since they may have a variable length themselves,\n        // e.g. when a Vec or Compact is contained withing, it has a variable length based on data\n        const count = this.length;\n        let total = compactToU8a(count).length;\n        for (let i = 0; i < count; i++) {\n            total += this[i].encodedLength;\n        }\n        return total;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        return this.length === 0;\n    }\n    /**\n     * @description The length of the value\n     */\n    get length() {\n        // only included here since we ignore inherited docs\n        return super.length;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return compareArray(this, other);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            inner: this.inspectInner(),\n            outer: [compactToU8a(this.length)]\n        };\n    }\n    /**\n     * @internal\n     * @description Internal per-item inspection of internal values\n     */\n    inspectInner() {\n        const count = this.length;\n        const inner = new Array(count);\n        for (let i = 0; i < count; i++) {\n            inner[i] = this[i].inspect();\n        }\n        return inner;\n    }\n    /**\n     * @description Converts the Object to an standard JavaScript Array\n     */\n    toArray() {\n        return Array.from(this);\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExtended, disableAscii) {\n        const count = this.length;\n        const result = new Array(count);\n        for (let i = 0; i < count; i++) {\n            result[i] = this[i] && this[i].toHuman(isExtended, disableAscii);\n        }\n        return result;\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        const count = this.length;\n        const result = new Array(count);\n        for (let i = 0; i < count; i++) {\n            // We actually log inside the U8a decoding and use JSON.stringify(...), which\n            // means that the Vec may be partially populated (same applies to toHuman, same check)\n            result[i] = this[i] && this[i].toJSON();\n        }\n        return result;\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive(disableAscii) {\n        const count = this.length;\n        const result = new Array(count);\n        for (let i = 0; i < count; i++) {\n            result[i] = this[i] && this[i].toPrimitive(disableAscii);\n        }\n        return result;\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        const count = this.length;\n        const result = new Array(count);\n        for (let i = 0; i < count; i++) {\n            result[i] = this[i].toString();\n        }\n        return `[${result.join(', ')}]`;\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        const encoded = this.toU8aInner();\n        return isBare\n            ? u8aConcatStrict(encoded)\n            : u8aConcatStrict([compactToU8a(this.length), ...encoded]);\n    }\n    /**\n     * @internal\n     * @description Internal per-item SCALE encoding of contained values\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8aInner(isBare) {\n        const count = this.length;\n        const encoded = new Array(count);\n        for (let i = 0; i < count; i++) {\n            encoded[i] = this[i].toU8a(isBare);\n        }\n        return encoded;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}