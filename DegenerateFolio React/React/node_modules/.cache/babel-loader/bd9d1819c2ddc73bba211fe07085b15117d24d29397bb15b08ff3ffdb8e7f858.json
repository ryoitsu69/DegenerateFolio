{"ast":null,"code":"import { u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { keccakAsU8a } from '../keccak/index.js';\nimport { secp256k1Expand } from '../secp256k1/index.js';\nfunction getH160(u8a) {\n  if ([33, 65].includes(u8a.length)) {\n    u8a = keccakAsU8a(secp256k1Expand(u8a));\n  }\n  return u8a.slice(-20);\n}\nexport function ethereumEncode(addressOrPublic) {\n  if (!addressOrPublic) {\n    return '0x';\n  }\n  const u8aAddress = u8aToU8a(addressOrPublic);\n  if (![20, 32, 33, 65].includes(u8aAddress.length)) {\n    throw new Error(\"Invalid address or publicKey provided, received \".concat(u8aAddress.length, \" bytes input\"));\n  }\n  const address = u8aToHex(getH160(u8aAddress), -1, false);\n  const hash = u8aToHex(keccakAsU8a(address), -1, false);\n  let result = '';\n  for (let i = 0; i < 40; i++) {\n    result = \"\".concat(result).concat(parseInt(hash[i], 16) > 7 ? address[i].toUpperCase() : address[i]);\n  }\n  return \"0x\".concat(result);\n}","map":{"version":3,"names":["u8aToHex","u8aToU8a","keccakAsU8a","secp256k1Expand","getH160","u8a","includes","length","slice","ethereumEncode","addressOrPublic","u8aAddress","Error","concat","address","hash","result","i","parseInt","toUpperCase"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util-crypto/ethereum/encode.js"],"sourcesContent":["import { u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { keccakAsU8a } from '../keccak/index.js';\nimport { secp256k1Expand } from '../secp256k1/index.js';\nfunction getH160(u8a) {\n    if ([33, 65].includes(u8a.length)) {\n        u8a = keccakAsU8a(secp256k1Expand(u8a));\n    }\n    return u8a.slice(-20);\n}\nexport function ethereumEncode(addressOrPublic) {\n    if (!addressOrPublic) {\n        return '0x';\n    }\n    const u8aAddress = u8aToU8a(addressOrPublic);\n    if (![20, 32, 33, 65].includes(u8aAddress.length)) {\n        throw new Error(`Invalid address or publicKey provided, received ${u8aAddress.length} bytes input`);\n    }\n    const address = u8aToHex(getH160(u8aAddress), -1, false);\n    const hash = u8aToHex(keccakAsU8a(address), -1, false);\n    let result = '';\n    for (let i = 0; i < 40; i++) {\n        result = `${result}${parseInt(hash[i], 16) > 7 ? address[i].toUpperCase() : address[i]}`;\n    }\n    return `0x${result}`;\n}\n"],"mappings":"AAAA,SAASA,QAAQ,EAAEC,QAAQ,QAAQ,gBAAgB;AACnD,SAASC,WAAW,QAAQ,oBAAoB;AAChD,SAASC,eAAe,QAAQ,uBAAuB;AACvD,SAASC,OAAOA,CAACC,GAAG,EAAE;EAClB,IAAI,CAAC,EAAE,EAAE,EAAE,CAAC,CAACC,QAAQ,CAACD,GAAG,CAACE,MAAM,CAAC,EAAE;IAC/BF,GAAG,GAAGH,WAAW,CAACC,eAAe,CAACE,GAAG,CAAC,CAAC;EAC3C;EACA,OAAOA,GAAG,CAACG,KAAK,CAAC,CAAC,EAAE,CAAC;AACzB;AACA,OAAO,SAASC,cAAcA,CAACC,eAAe,EAAE;EAC5C,IAAI,CAACA,eAAe,EAAE;IAClB,OAAO,IAAI;EACf;EACA,MAAMC,UAAU,GAAGV,QAAQ,CAACS,eAAe,CAAC;EAC5C,IAAI,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAACJ,QAAQ,CAACK,UAAU,CAACJ,MAAM,CAAC,EAAE;IAC/C,MAAM,IAAIK,KAAK,oDAAAC,MAAA,CAAoDF,UAAU,CAACJ,MAAM,iBAAc,CAAC;EACvG;EACA,MAAMO,OAAO,GAAGd,QAAQ,CAACI,OAAO,CAACO,UAAU,CAAC,EAAE,CAAC,CAAC,EAAE,KAAK,CAAC;EACxD,MAAMI,IAAI,GAAGf,QAAQ,CAACE,WAAW,CAACY,OAAO,CAAC,EAAE,CAAC,CAAC,EAAE,KAAK,CAAC;EACtD,IAAIE,MAAM,GAAG,EAAE;EACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;IACzBD,MAAM,MAAAH,MAAA,CAAMG,MAAM,EAAAH,MAAA,CAAGK,QAAQ,CAACH,IAAI,CAACE,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,GAAGH,OAAO,CAACG,CAAC,CAAC,CAACE,WAAW,CAAC,CAAC,GAAGL,OAAO,CAACG,CAAC,CAAC,CAAE;EAC5F;EACA,YAAAJ,MAAA,CAAYG,MAAM;AACtB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}