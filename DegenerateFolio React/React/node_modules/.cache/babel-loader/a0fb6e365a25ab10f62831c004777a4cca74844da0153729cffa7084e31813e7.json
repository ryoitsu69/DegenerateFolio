{"ast":null,"code":"\"use strict\";\n\nconst WGSL_TO_STD40_SIZE = {\n  f32: 4,\n  \"vec2<f32>\": 8,\n  \"vec3<f32>\": 12,\n  \"vec4<f32>\": 16,\n  \"mat2x2<f32>\": 16 * 2,\n  \"mat3x3<f32>\": 16 * 3,\n  \"mat4x4<f32>\": 16 * 4\n  // TODO - not essential for now but support these in the future\n  // int:      4,\n  // ivec2:    8,\n  // ivec3:    12,\n  // ivec4:    16,\n  // uint:     4,\n  // uvec2:    8,\n  // uvec3:    12,\n  // uvec4:    16,\n  // bool:     4,\n  // bvec2:    8,\n  // bvec3:    12,\n  // bvec4:    16,\n  // mat2:     16 * 2,\n  // mat3:     16 * 3,\n  // mat4:     16 * 4,\n};\nfunction createUboElementsSTD40(uniformData) {\n  const uboElements = uniformData.map(data => ({\n    data,\n    offset: 0,\n    size: 0\n  }));\n  let size = 0;\n  let chunkSize = 0;\n  let offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    size = WGSL_TO_STD40_SIZE[uboElement.data.type];\n    if (!size) {\n      throw new Error(`Unknown type ${uboElement.data.type}`);\n    }\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, 16) * uboElement.data.size;\n    }\n    uboElement.size = size;\n    if (chunkSize % size !== 0 && chunkSize < 16) {\n      const lineUpValue = chunkSize % size % 16;\n      chunkSize += lineUpValue;\n      offset += lineUpValue;\n    }\n    if (chunkSize + size > 16) {\n      offset = Math.ceil(offset / 16) * 16;\n      uboElement.offset = offset;\n      offset += size;\n      chunkSize = size;\n    } else {\n      uboElement.offset = offset;\n      chunkSize += size;\n      offset += size;\n    }\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return {\n    uboElements,\n    size: offset\n  };\n}\nexport { WGSL_TO_STD40_SIZE, createUboElementsSTD40 };","map":{"version":3,"names":["WGSL_TO_STD40_SIZE","f32","createUboElementsSTD40","uniformData","uboElements","map","data","offset","size","chunkSize","i","length","uboElement","type","Error","Math","max","lineUpValue","ceil"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/createUboElementsSTD40.ts"],"sourcesContent":["import type { UboElement, UboLayout, UniformData } from '../../../shared/shader/types';\n\nexport const WGSL_TO_STD40_SIZE: Record<string, number> = {\n    f32: 4,\n    'vec2<f32>': 8,\n    'vec3<f32>': 12,\n    'vec4<f32>': 16,\n\n    'mat2x2<f32>': 16 * 2,\n    'mat3x3<f32>': 16 * 3,\n    'mat4x4<f32>': 16 * 4,\n\n    // TODO - not essential for now but support these in the future\n    // int:      4,\n    // ivec2:    8,\n    // ivec3:    12,\n    // ivec4:    16,\n\n    // uint:     4,\n    // uvec2:    8,\n    // uvec3:    12,\n    // uvec4:    16,\n\n    // bool:     4,\n    // bvec2:    8,\n    // bvec3:    12,\n    // bvec4:    16,\n\n    // mat2:     16 * 2,\n    // mat3:     16 * 3,\n    // mat4:     16 * 4,\n};\n\nexport function createUboElementsSTD40(uniformData: UniformData[]): UboLayout\n{\n    const uboElements: UboElement[] = uniformData.map((data: UniformData) =>\n        ({\n            data,\n            offset: 0,\n            size: 0,\n        }));\n\n    let size = 0;\n    let chunkSize = 0;\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        size = WGSL_TO_STD40_SIZE[uboElement.data.type];\n\n        if (!size)\n        {\n            throw new Error(`Unknown type ${uboElement.data.type}`);\n        }\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, 16) * uboElement.data.size;\n        }\n\n        uboElement.size = size;\n\n        // add some size offset..\n        // must align to the nearest 16 bytes or internally nearest round size\n        if (chunkSize % size !== 0 && chunkSize < 16)\n        {\n            // diff required to line up..\n            const lineUpValue = (chunkSize % size) % 16;\n\n            chunkSize += lineUpValue;\n            offset += lineUpValue;\n        }\n\n        if ((chunkSize + size) > 16)\n        {\n            offset = Math.ceil(offset / 16) * 16;\n            uboElement.offset = offset;\n            offset += size;\n            chunkSize = size;\n        }\n        else\n        {\n            uboElement.offset = offset;\n            chunkSize += size;\n            offset += size;\n        }\n    }\n\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\n"],"mappings":";;AAEO,MAAMA,kBAA6C;EACtDC,GAAK;EACL,WAAa;EACb,WAAa;EACb,WAAa;EAEb,eAAe,EAAK;EACpB,eAAe,EAAK;EACpB,eAAe,EAAK;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;AAqBxB;AAEO,SAASC,uBAAuBC,WACvC;EACI,MAAMC,WAA4B,GAAAD,WAAA,CAAYE,GAAI,CAACC,IAC9C;IACGA,IAAA;IACAC,MAAQ;IACRC,IAAM;EAAA,CACR;EAEN,IAAIA,IAAO;EACX,IAAIC,SAAY;EAChB,IAAIF,MAAS;EAEb,SAASG,CAAI,MAAGA,CAAI,GAAAN,WAAA,CAAYO,MAAA,EAAQD,CACxC;IACU,MAAAE,UAAA,GAAaR,WAAA,CAAYM,CAAC;IAEzBF,IAAA,GAAAR,kBAAA,CAAmBY,UAAW,CAAAN,IAAA,CAAKO,IAAI;IAE9C,IAAI,CAACL,IACL;MACI,MAAM,IAAIM,KAAM,iBAAgBF,UAAW,CAAAN,IAAA,CAAKO,IAAM;IAAA;IAGtD,IAAAD,UAAA,CAAWN,IAAK,CAAAE,IAAA,GAAO,CAC3B;MACIA,IAAA,GAAOO,IAAA,CAAKC,GAAI,CAAAR,IAAA,EAAM,EAAE,IAAII,UAAA,CAAWN,IAAK,CAAAE,IAAA;IAAA;IAGhDI,UAAA,CAAWJ,IAAO,GAAAA,IAAA;IAIlB,IAAIC,SAAY,GAAAD,IAAA,KAAS,CAAK,IAAAC,SAAA,GAAY,EAC1C;MAEU,MAAAQ,WAAA,GAAeR,SAAA,GAAYD,IAAQ;MAE5BC,SAAA,IAAAQ,WAAA;MACHV,MAAA,IAAAU,WAAA;IAAA;IAGT,IAAAR,SAAA,GAAYD,IAAA,GAAQ,EACzB;MACID,MAAA,GAASQ,IAAK,CAAAG,IAAA,CAAKX,MAAS,KAAE,CAAI;MAClCK,UAAA,CAAWL,MAAS,GAAAA,MAAA;MACVA,MAAA,IAAAC,IAAA;MACEC,SAAA,GAAAD,IAAA;IAAA,CAGhB;MACII,UAAA,CAAWL,MAAS,GAAAA,MAAA;MACPE,SAAA,IAAAD,IAAA;MACHD,MAAA,IAAAC,IAAA;IAAA;EACd;EAGJD,MAAA,GAASQ,IAAK,CAAAG,IAAA,CAAKX,MAAS,KAAE,CAAI;EAE3B;IAAEH,WAAa;IAAAI,IAAA,EAAMD;EAAO;AACvC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}