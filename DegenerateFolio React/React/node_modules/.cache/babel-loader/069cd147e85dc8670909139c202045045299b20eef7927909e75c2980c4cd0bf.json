{"ast":null,"code":"var _jsxFileName = \"/home/ryoitsu/Documents/test/react-todo-app/src/index.js\";\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport ShadertoyReact from \"shadertoy-react\";\nimport './css/index.css';\nimport TodoApp from './components/todo.jsx';\nimport reportWebVitals from './reportWebVitals';\nimport vertex from './shaders/mosaic/mosaic.vert';\nimport fragment from './shaders/mosaic/mosaic.frag';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nconst fragmentShader = `\n /*\n  *\n  * Raymarched Hexagonal Truchet\n  * ----------------------------\n  *\n  * Raymarching a hexagonal Truchet pattern. The Truchet pattern itself is pretty easy to produce.\n  * This particular production method is based off of one of Fabrice Neyret's finely tuned examples,\n  * which in turn was based on something Mattz did a while back. Both examples are below.\n  *\n  * Technically, there isn't a lot to it. The hardest part was producing the Truchet pattern in a\n  * reasonably quick way, but most of that was already done for me. Therefore, since I had nothing new\n  * to add, I prettied it up a bit... and by that I mean, I made it really shiny. Probably too shiny.\n  * It kind of hurts my eyes. :)\n  *\n  * The weird, abstract, dragon disco style wasn't intentional. I'm briefly passing through parts of\n  * Asia next week, so that may have mildy influenced my style choices. Hopefully, it meets\n  * 834144373's approval. :)\n  *\n  *\n  * Based on:\n  *\n  * hexagonal truchet ( 352 ) - FabriceNeyret2\n  * https://www.shadertoy.com/view/Xdt3D8\n  *\n  * ... which, in turn, was based on:\n  * hexagonal tiling - mattz\n  * https://www.shadertoy.com/view/4d2GzV\n  *\n  */\n\n\n // Using a 2D Hexagonal Truchet pattern as the source of the height map. This is based on Fabrice's\n // example which in turn was based on one by Mattz. I tailored it to suit my needs - and hopefully,\n // sped it up a bit, but it wouldn't shock me if I'd slowed it down instead. :)\n //\n // The process is pretty simple: Break space up into hexagons and color them according to the distance\n // from the center, then randomly flip some about the X-axis. The pattern you're left with isn't that\n // visually appealing. However, once you wrap or fold the values over, you get some nice symmetrical\n // patterns.\n //\n // Just to complicate things slightly, I'm performing the final value folding steps outside of this\n // function in order to color things in sections... It's not that important.\n float heightMap(in vec2 p) {\n\n     p *= 3.;\n\n     // Hexagonal coordinates.\n     vec2 h = vec2(p.x + p.y*.57735, p.y*1.1547);\n\n     // Closest hexagon center.\n     vec2 f = fract(h); h -= f;\n     float c = fract((h.x + h.y)/3.);\n     h =  c<.666 ?   c<.333 ?  h  :  h + 1.  :  h  + step(f.yx, f);\n\n     p -= vec2(h.x - h.y*.5, h.y*.8660254);\n\n     // Rotate (flip, in this case) random hexagons. Otherwise, you'd have a bunch of circles only.\n     // Note that \"h\" is unique to each hexagon, so we can use it as the random ID.\n     c = fract(cos(dot(h, vec2(41, 289)))*43758.5453); // Reusing \"c.\"\n     p -= p*step(c, .5)*2.; // Equivalent to: if (c<.5) p *= -1.;\n\n     // Minimum squared distance to neighbors. Taking the square root after comparing, for speed.\n     // Three partitions need to be checked due to the flipping process.\n     p -= vec2(-1, 0);\n     c = dot(p, p); // Reusing \"c\" again.\n     p -= vec2(1.5, .8660254);\n     c = min(c, dot(p, p));\n     p -= vec2(0, -1.73205);\n     c = min(c, dot(p, p));\n\n     return sqrt(c);\n\n     // Wrapping the values - or folding the values over (abs(c-.5)*2., cos(c*6.283*1.), etc) - to produce\n     // the nicely lined-up, wavy patterns. I\"m perfoming this step in the \"map\" function. It has to do\n     // with coloring and so forth.\n     //c = sqrt(c);\n     //c = cos(c*6.283*1.) + cos(c*6.283*2.);\n     //return (clamp(c*.6+.5, 0., 1.));\n\n }\n\n // Raymarching an XY-plane - raised a little by the hexagonal Truchet heightmap. Pretty standard.\n float map(vec3 p){\n\n\n     float c = heightMap(p.xy); // Height map.\n     // Wrapping, or folding the height map values over, to produce the nicely lined-up, wavy patterns.\n     c = cos(c*6.283*1.) + cos(c*6.283*2.);\n     c = (clamp(c*.6+.5, 0., 1.));\n\n\n     // Back plane, placed at vec3(0., 0., 1.), with plane normal vec3(0., 0., -1).\n     // Adding some height to the plane from the heightmap. Not much else to it.\n     return 1. - p.z - c*.025;\n\n\n }\n\n // The normal function with some edge detection and curvature rolled into it. Sometimes, it's possible to\n // get away with six taps, but we need a bit of epsilon value variance here, so there's an extra six.\n vec3 getNormal(vec3 p, inout float edge, inout float crv) {\n\n     vec2 e = vec2(.01, 0); // Larger epsilon for greater sample spread, thus thicker edges.\n\n     // Take some distance function measurements from either side of the hit point on all three axes.\n     float d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n     float d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n     float d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n     float d = map(p)*2.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n\n     // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n     // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n     // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface\n     // curves that register a discernible difference.\n     edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n     //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n\n     // Once you have an edge value, it needs to normalized, and smoothed if possible. How you\n     // do that is up to you. This is what I came up with for now, but I might tweak it later.\n     edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\n     // We may as well use the six measurements to obtain a rough curvature value while we're at it.\n     crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .6, 0., 1.);\n\n     // Redoing the calculations for the normal with a more precise epsilon value.\n     e = vec2(.0025, 0);\n     d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n     d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n     d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\n\n     // Return the normal.\n     // Standard, normalized gradient mearsurement.\n     return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n }\n\n\n\n // I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n // Anyway, I like this one. I'm assuming it's based on IQ's original.\n float calculateAO(in vec3 p, in vec3 n)\n {\n     float sca = 2., occ = 0.;\n     for(float i=0.; i<5.; i++){\n\n         float hr = .01 + i*.5/4.;\n         float dd = map(n * hr + p);\n         occ += (hr - dd)*sca;\n         sca *= 0.7;\n     }\n     return clamp(1.0 - occ, 0., 1.);\n }\n\n\n /*\n  / */ Surface bump function. Cheap, but with decent visual impact.\n  float bumpSurf3D( in vec3 p){\n\n      float c = heightMap((p.xy + p.z*.025)*6.);\n      c = cos(c*6.283*3.);\n      //c = sqrt(clamp(c+.5, 0., 1.));\n      c = (c*.5 + .5);\n\n      return c;\n\n  }\n\n  // Standard function-based bump mapping function.\n  vec3 dbF(in vec3 p, in vec3 nor, float bumpfactor){\n\n      const vec2 e = vec2(0.001, 0);\n      float ref = bumpSurf3D(p);\n      vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                        bumpSurf3D(p - e.yxy),\n                        bumpSurf3D(p - e.yyx) )-ref)/e.x;\n\n                        grad -= nor*dot(nor, grad);\n\n                        return normalize( nor + grad*bumpfactor );\n\n  }\n  */\n\n // Compact, self-contained version of IQ's 3D value noise function.\n float n3D(vec3 p){\n\n     const vec3 s = vec3(7, 157, 113);\n     vec3 ip = floor(p); p -= ip;\n     vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n     p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n     h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n     h.xy = mix(h.xz, h.yw, p.y);\n     return mix(h.x, h.y, p.z); // Range: [0, 1].\n }\n\n // Simple environment mapping. Pass the reflected vector in and create some\n // colored noise with it. The normal is redundant here, but it can be used\n // to pass into a 3D texture mapping function to produce some interesting\n // environmental reflections.\n vec3 envMap(vec3 rd, vec3 sn){\n\n     vec3 sRd = rd; // Save rd, just for some mixing at the end.\n\n     // Add a time component, scale, then pass into the noise function.\n     rd.xy -= iTime*.25;\n     rd *= 3.;\n\n     float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n     c = smoothstep(0.4, 1., c); // Darken and add contast for more of a spotlight look.\n\n     vec3 col = vec3(c, c*c, c*c*c*c); // Simple, warm coloring.\n     //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)); // More color.\n\n     // Mix in some more red to tone it down and return.\n     return mix(col, col.yzx, sRd*.25+.25);\n\n }\n\n // vec2 to vec2 hash.\n vec2 hash22(vec2 p) {\n\n     // Faster, but doesn't disperse things quite as nicely as other combinations. :)\n     float n = sin(dot(p, vec2(41, 289)));\n     return fract(vec2(262144, 32768)*n)*.75 + .25;\n\n     // Animated.\n     //p = fract(vec2(262144, 32768)*n);\n     //return sin( p*6.2831853 + iTime )*.35 + .65;\n\n }\n\n // 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n // up those if-statements. Since there's less writing, it should go faster. That's how\n // it works, right? :)\n //\n float Voronoi(in vec2 p){\n\n     vec2 g = floor(p), o; p -= g;\n\n     vec3 d = vec3(1); // 1.4, etc. \"d.z\" holds the distance comparison value.\n\n     for(int y = -1; y <= 1; y++){\n         for(int x = -1; x <= 1; x++){\n\n             o = vec2(x, y);\n             o += hash22(g + o) - p;\n\n             d.z = dot(o, o);\n             // More distance metrics.\n             //o = abs(o);\n             //d.z = max(o.x*.8666 + o.y*.5, o.y);//\n             //d.z = max(o.x, o.y);\n             //d.z = (o.x*.7 + o.y*.7);\n\n             d.y = max(d.x, min(d.y, d.z));\n             d.x = min(d.x, d.z);\n\n         }\n     }\n\n     return max(d.y/1.2 - d.x*1., 0.)/1.2;\n     //return d.y - d.x; // return 1.-d.x; // etc.\n\n }\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n     // Unit directional ray - Coyote's observation.\n     vec3 rd = normalize(vec3(2.*fragCoord - iResolution.xy, iResolution.y));\n\n     float tm = iTime/2.;\n     // Rotate the XY-plane back and forth. Note that sine and cosine are kind of rolled into one.\n     vec2 a = sin(vec2(1.570796, 0) + sin(tm/4.)*.3); // Fabrice's observation.\n     rd.xy = mat2(a, -a.y, a.x)*rd.xy;\n\n\n     // Ray origin. Moving in the X-direction to the right.\n     vec3 ro = vec3(tm, cos(tm/4.), 0.);\n\n\n     // Light position, hovering around behind the camera.\n     vec3 lp = ro + vec3(cos(tm/2.)*.5, sin(tm/2.)*.5, -.5);\n\n     // Standard raymarching segment. Because of the straight forward setup, not many iterations are necessary.\n     float d, t=0.;\n     for(int j=0;j<32;j++){\n\n         d = map(ro + rd*t); // distance to the function.\n         t += d*.7; // Total distance from the camera to the surface.\n\n         // The plane \"is\" the far plane, so no far=plane break is needed.\n         if(d<0.001) break;\n\n     }\n\n     // Edge and curve value. Passed into, and set, during the normal calculation.\n     float edge, crv;\n\n     // Surface postion, surface normal and light direction.\n     vec3 sp = ro + rd*t;\n     vec3 sn = getNormal(sp, edge, crv);\n     vec3 ld = lp - sp;\n\n\n\n     // Coloring and texturing the surface.\n     //\n     // Height map.\n     float c = heightMap(sp.xy);\n\n     // Folding, or wrapping, the values above to produce the snake-like pattern that lines up with the randomly\n     // flipped hex cells produced by the height map.\n     vec3 fold = cos(vec3(1, 2, 4)*c*6.283);\n\n     // Using the height map value, then wrapping it, to produce a finer grain Truchet pattern for the overlay.\n     float c2 = heightMap((sp.xy + sp.z*.025)*6.);\n     c2 = cos(c2*6.283*3.);\n     c2 = (clamp(c2+.5, 0., 1.));\n\n\n     // Function based bump mapping. I prefer none in this example, but it's there if you want it.\n     //if(temp.x>0. || temp.y>0.) sn = dbF(sp, sn, .001);\n\n     // Surface color value.\n     vec3 oC = vec3(1);\n\n     if(fold.x>0.) oC = vec3(1, .05, .1)*c2; // Reddish pink with finer grained Truchet overlay.\n\n     if(fold.x<0.05 && (fold.y)<0.) oC = vec3(1, .7, .45)*(c2*.25 + .75); // Lighter lined borders.\n     else if(fold.x<0.) oC = vec3(1, .8, .4)*c2; // Gold, with overlay.\n\n     //oC *= n3D(sp*128.)*.35 + .65; // Extra fine grained noisy texturing.\n\n\n     // Sending some greenish particle pulses through the snake-like patterns. With all the shininess going\n     // on, this effect is a little on the subtle side.\n     float p1 = 1.0 - smoothstep(0., .1, fold.x*.5+.5); // Restrict to the snake-like path.\n     // Other path.\n     //float p2 = 1.0 - smoothstep(0., .1, cos(heightMap(sp.xy + 1. + iTime/4.)*6.283)*.5+.5);\n     float p2 = 1.0 - smoothstep(0., .1, Voronoi(sp.xy*4. + vec2(tm, cos(tm/4.))));\n     p1 = (p2 + .25)*p1; // Overlap the paths.\n     oC += oC.yxz*p1*p1; // Gives a kind of electron effect. Works better with just Voronoi, but it'll do.\n\n\n\n\n     float lDist = max(length(ld), 0.001); // Light distance.\n     float atten = 1./(1. + lDist*.125); // Light attenuation.\n\n     ld /= lDist; // Normalizing the light direction vector.\n\n     float diff = max(dot(ld, sn), 0.); // Diffuse.\n     float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 16.); // Specular.\n     float fre = pow(clamp(dot(sn, rd) + 1., .0, 1.), 3.); // Fresnel, for some mild glow.\n\n     // Shading. Note, there are no actual shadows. The camera is front on, so the following\n     // two functions are enough to give a shadowy appearance.\n     crv = crv*.9 + .1; // Curvature value, to darken the crevices.\n     float ao = calculateAO(sp, sn); // Ambient occlusion, for self shadowing.\n\n\n\n     // Combining the terms above to light the texel.\n     vec3 col = oC*(diff + .5) + vec3(1., .7, .4)*spec*2. + vec3(.4, .7, 1)*fre;\n\n     col += (oC*.5+.5)*envMap(reflect(rd, sn), sn)*6.; // Fake environment mapping.\n\n\n     // Edges.\n     col *= 1. - edge*.85; // Darker edges.\n\n     // Applying the shades.\n     col *= (atten*crv*ao);\n\n\n     // Rough gamma correction, then present to the screen.\n     fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n }\n `;\nroot.render( /*#__PURE__*/_jsxDEV(_Fragment, {\n  children: [/*#__PURE__*/_jsxDEV(ShadertoyReact, {\n    fs: fragmentShader\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 395,\n    columnNumber: 1\n  }, this), /*#__PURE__*/_jsxDEV(TodoApp, {}, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 396,\n    columnNumber: 1\n  }, this), /*#__PURE__*/_jsxDEV(\"footer\", {\n    children: \"\\xA92024 Ultra Degenerate Labs, No Rights Reserved\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 397,\n    columnNumber: 1\n  }, this)]\n}, void 0, true));\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();","map":{"version":3,"names":["React","ReactDOM","ShadertoyReact","TodoApp","reportWebVitals","vertex","fragment","jsxDEV","_jsxDEV","Fragment","_Fragment","root","createRoot","document","getElementById","fragmentShader","render","children","fs","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/src/index.js"],"sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport ShadertoyReact from \"shadertoy-react\";\nimport './css/index.css';\nimport TodoApp from './components/todo.jsx';\nimport reportWebVitals from './reportWebVitals';\nimport vertex from './shaders/mosaic/mosaic.vert';\nimport fragment from './shaders/mosaic/mosaic.frag';\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n\n const fragmentShader = `\n /*\n  *\n  * Raymarched Hexagonal Truchet\n  * ----------------------------\n  *\n  * Raymarching a hexagonal Truchet pattern. The Truchet pattern itself is pretty easy to produce.\n  * This particular production method is based off of one of Fabrice Neyret's finely tuned examples,\n  * which in turn was based on something Mattz did a while back. Both examples are below.\n  *\n  * Technically, there isn't a lot to it. The hardest part was producing the Truchet pattern in a\n  * reasonably quick way, but most of that was already done for me. Therefore, since I had nothing new\n  * to add, I prettied it up a bit... and by that I mean, I made it really shiny. Probably too shiny.\n  * It kind of hurts my eyes. :)\n  *\n  * The weird, abstract, dragon disco style wasn't intentional. I'm briefly passing through parts of\n  * Asia next week, so that may have mildy influenced my style choices. Hopefully, it meets\n  * 834144373's approval. :)\n  *\n  *\n  * Based on:\n  *\n  * hexagonal truchet ( 352 ) - FabriceNeyret2\n  * https://www.shadertoy.com/view/Xdt3D8\n  *\n  * ... which, in turn, was based on:\n  * hexagonal tiling - mattz\n  * https://www.shadertoy.com/view/4d2GzV\n  *\n  */\n\n\n // Using a 2D Hexagonal Truchet pattern as the source of the height map. This is based on Fabrice's\n // example which in turn was based on one by Mattz. I tailored it to suit my needs - and hopefully,\n // sped it up a bit, but it wouldn't shock me if I'd slowed it down instead. :)\n //\n // The process is pretty simple: Break space up into hexagons and color them according to the distance\n // from the center, then randomly flip some about the X-axis. The pattern you're left with isn't that\n // visually appealing. However, once you wrap or fold the values over, you get some nice symmetrical\n // patterns.\n //\n // Just to complicate things slightly, I'm performing the final value folding steps outside of this\n // function in order to color things in sections... It's not that important.\n float heightMap(in vec2 p) {\n\n     p *= 3.;\n\n     // Hexagonal coordinates.\n     vec2 h = vec2(p.x + p.y*.57735, p.y*1.1547);\n\n     // Closest hexagon center.\n     vec2 f = fract(h); h -= f;\n     float c = fract((h.x + h.y)/3.);\n     h =  c<.666 ?   c<.333 ?  h  :  h + 1.  :  h  + step(f.yx, f);\n\n     p -= vec2(h.x - h.y*.5, h.y*.8660254);\n\n     // Rotate (flip, in this case) random hexagons. Otherwise, you'd have a bunch of circles only.\n     // Note that \"h\" is unique to each hexagon, so we can use it as the random ID.\n     c = fract(cos(dot(h, vec2(41, 289)))*43758.5453); // Reusing \"c.\"\n     p -= p*step(c, .5)*2.; // Equivalent to: if (c<.5) p *= -1.;\n\n     // Minimum squared distance to neighbors. Taking the square root after comparing, for speed.\n     // Three partitions need to be checked due to the flipping process.\n     p -= vec2(-1, 0);\n     c = dot(p, p); // Reusing \"c\" again.\n     p -= vec2(1.5, .8660254);\n     c = min(c, dot(p, p));\n     p -= vec2(0, -1.73205);\n     c = min(c, dot(p, p));\n\n     return sqrt(c);\n\n     // Wrapping the values - or folding the values over (abs(c-.5)*2., cos(c*6.283*1.), etc) - to produce\n     // the nicely lined-up, wavy patterns. I\"m perfoming this step in the \"map\" function. It has to do\n     // with coloring and so forth.\n     //c = sqrt(c);\n     //c = cos(c*6.283*1.) + cos(c*6.283*2.);\n     //return (clamp(c*.6+.5, 0., 1.));\n\n }\n\n // Raymarching an XY-plane - raised a little by the hexagonal Truchet heightmap. Pretty standard.\n float map(vec3 p){\n\n\n     float c = heightMap(p.xy); // Height map.\n     // Wrapping, or folding the height map values over, to produce the nicely lined-up, wavy patterns.\n     c = cos(c*6.283*1.) + cos(c*6.283*2.);\n     c = (clamp(c*.6+.5, 0., 1.));\n\n\n     // Back plane, placed at vec3(0., 0., 1.), with plane normal vec3(0., 0., -1).\n     // Adding some height to the plane from the heightmap. Not much else to it.\n     return 1. - p.z - c*.025;\n\n\n }\n\n // The normal function with some edge detection and curvature rolled into it. Sometimes, it's possible to\n // get away with six taps, but we need a bit of epsilon value variance here, so there's an extra six.\n vec3 getNormal(vec3 p, inout float edge, inout float crv) {\n\n     vec2 e = vec2(.01, 0); // Larger epsilon for greater sample spread, thus thicker edges.\n\n     // Take some distance function measurements from either side of the hit point on all three axes.\n     float d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n     float d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n     float d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n     float d = map(p)*2.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n\n     // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n     // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n     // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface\n     // curves that register a discernible difference.\n     edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n     //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n\n     // Once you have an edge value, it needs to normalized, and smoothed if possible. How you\n     // do that is up to you. This is what I came up with for now, but I might tweak it later.\n     edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\n     // We may as well use the six measurements to obtain a rough curvature value while we're at it.\n     crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .6, 0., 1.);\n\n     // Redoing the calculations for the normal with a more precise epsilon value.\n     e = vec2(.0025, 0);\n     d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n     d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n     d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\n\n     // Return the normal.\n     // Standard, normalized gradient mearsurement.\n     return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n }\n\n\n\n // I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n // Anyway, I like this one. I'm assuming it's based on IQ's original.\n float calculateAO(in vec3 p, in vec3 n)\n {\n     float sca = 2., occ = 0.;\n     for(float i=0.; i<5.; i++){\n\n         float hr = .01 + i*.5/4.;\n         float dd = map(n * hr + p);\n         occ += (hr - dd)*sca;\n         sca *= 0.7;\n     }\n     return clamp(1.0 - occ, 0., 1.);\n }\n\n\n /*\n  / */ Surface bump function. Cheap, but with decent visual impact.\n  float bumpSurf3D( in vec3 p){\n\n      float c = heightMap((p.xy + p.z*.025)*6.);\n      c = cos(c*6.283*3.);\n      //c = sqrt(clamp(c+.5, 0., 1.));\n      c = (c*.5 + .5);\n\n      return c;\n\n  }\n\n  // Standard function-based bump mapping function.\n  vec3 dbF(in vec3 p, in vec3 nor, float bumpfactor){\n\n      const vec2 e = vec2(0.001, 0);\n      float ref = bumpSurf3D(p);\n      vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                        bumpSurf3D(p - e.yxy),\n                        bumpSurf3D(p - e.yyx) )-ref)/e.x;\n\n                        grad -= nor*dot(nor, grad);\n\n                        return normalize( nor + grad*bumpfactor );\n\n  }\n  */\n\n // Compact, self-contained version of IQ's 3D value noise function.\n float n3D(vec3 p){\n\n     const vec3 s = vec3(7, 157, 113);\n     vec3 ip = floor(p); p -= ip;\n     vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n     p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n     h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n     h.xy = mix(h.xz, h.yw, p.y);\n     return mix(h.x, h.y, p.z); // Range: [0, 1].\n }\n\n // Simple environment mapping. Pass the reflected vector in and create some\n // colored noise with it. The normal is redundant here, but it can be used\n // to pass into a 3D texture mapping function to produce some interesting\n // environmental reflections.\n vec3 envMap(vec3 rd, vec3 sn){\n\n     vec3 sRd = rd; // Save rd, just for some mixing at the end.\n\n     // Add a time component, scale, then pass into the noise function.\n     rd.xy -= iTime*.25;\n     rd *= 3.;\n\n     float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n     c = smoothstep(0.4, 1., c); // Darken and add contast for more of a spotlight look.\n\n     vec3 col = vec3(c, c*c, c*c*c*c); // Simple, warm coloring.\n     //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)); // More color.\n\n     // Mix in some more red to tone it down and return.\n     return mix(col, col.yzx, sRd*.25+.25);\n\n }\n\n // vec2 to vec2 hash.\n vec2 hash22(vec2 p) {\n\n     // Faster, but doesn't disperse things quite as nicely as other combinations. :)\n     float n = sin(dot(p, vec2(41, 289)));\n     return fract(vec2(262144, 32768)*n)*.75 + .25;\n\n     // Animated.\n     //p = fract(vec2(262144, 32768)*n);\n     //return sin( p*6.2831853 + iTime )*.35 + .65;\n\n }\n\n // 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n // up those if-statements. Since there's less writing, it should go faster. That's how\n // it works, right? :)\n //\n float Voronoi(in vec2 p){\n\n     vec2 g = floor(p), o; p -= g;\n\n     vec3 d = vec3(1); // 1.4, etc. \"d.z\" holds the distance comparison value.\n\n     for(int y = -1; y <= 1; y++){\n         for(int x = -1; x <= 1; x++){\n\n             o = vec2(x, y);\n             o += hash22(g + o) - p;\n\n             d.z = dot(o, o);\n             // More distance metrics.\n             //o = abs(o);\n             //d.z = max(o.x*.8666 + o.y*.5, o.y);//\n             //d.z = max(o.x, o.y);\n             //d.z = (o.x*.7 + o.y*.7);\n\n             d.y = max(d.x, min(d.y, d.z));\n             d.x = min(d.x, d.z);\n\n         }\n     }\n\n     return max(d.y/1.2 - d.x*1., 0.)/1.2;\n     //return d.y - d.x; // return 1.-d.x; // etc.\n\n }\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n     // Unit directional ray - Coyote's observation.\n     vec3 rd = normalize(vec3(2.*fragCoord - iResolution.xy, iResolution.y));\n\n     float tm = iTime/2.;\n     // Rotate the XY-plane back and forth. Note that sine and cosine are kind of rolled into one.\n     vec2 a = sin(vec2(1.570796, 0) + sin(tm/4.)*.3); // Fabrice's observation.\n     rd.xy = mat2(a, -a.y, a.x)*rd.xy;\n\n\n     // Ray origin. Moving in the X-direction to the right.\n     vec3 ro = vec3(tm, cos(tm/4.), 0.);\n\n\n     // Light position, hovering around behind the camera.\n     vec3 lp = ro + vec3(cos(tm/2.)*.5, sin(tm/2.)*.5, -.5);\n\n     // Standard raymarching segment. Because of the straight forward setup, not many iterations are necessary.\n     float d, t=0.;\n     for(int j=0;j<32;j++){\n\n         d = map(ro + rd*t); // distance to the function.\n         t += d*.7; // Total distance from the camera to the surface.\n\n         // The plane \"is\" the far plane, so no far=plane break is needed.\n         if(d<0.001) break;\n\n     }\n\n     // Edge and curve value. Passed into, and set, during the normal calculation.\n     float edge, crv;\n\n     // Surface postion, surface normal and light direction.\n     vec3 sp = ro + rd*t;\n     vec3 sn = getNormal(sp, edge, crv);\n     vec3 ld = lp - sp;\n\n\n\n     // Coloring and texturing the surface.\n     //\n     // Height map.\n     float c = heightMap(sp.xy);\n\n     // Folding, or wrapping, the values above to produce the snake-like pattern that lines up with the randomly\n     // flipped hex cells produced by the height map.\n     vec3 fold = cos(vec3(1, 2, 4)*c*6.283);\n\n     // Using the height map value, then wrapping it, to produce a finer grain Truchet pattern for the overlay.\n     float c2 = heightMap((sp.xy + sp.z*.025)*6.);\n     c2 = cos(c2*6.283*3.);\n     c2 = (clamp(c2+.5, 0., 1.));\n\n\n     // Function based bump mapping. I prefer none in this example, but it's there if you want it.\n     //if(temp.x>0. || temp.y>0.) sn = dbF(sp, sn, .001);\n\n     // Surface color value.\n     vec3 oC = vec3(1);\n\n     if(fold.x>0.) oC = vec3(1, .05, .1)*c2; // Reddish pink with finer grained Truchet overlay.\n\n     if(fold.x<0.05 && (fold.y)<0.) oC = vec3(1, .7, .45)*(c2*.25 + .75); // Lighter lined borders.\n     else if(fold.x<0.) oC = vec3(1, .8, .4)*c2; // Gold, with overlay.\n\n     //oC *= n3D(sp*128.)*.35 + .65; // Extra fine grained noisy texturing.\n\n\n     // Sending some greenish particle pulses through the snake-like patterns. With all the shininess going\n     // on, this effect is a little on the subtle side.\n     float p1 = 1.0 - smoothstep(0., .1, fold.x*.5+.5); // Restrict to the snake-like path.\n     // Other path.\n     //float p2 = 1.0 - smoothstep(0., .1, cos(heightMap(sp.xy + 1. + iTime/4.)*6.283)*.5+.5);\n     float p2 = 1.0 - smoothstep(0., .1, Voronoi(sp.xy*4. + vec2(tm, cos(tm/4.))));\n     p1 = (p2 + .25)*p1; // Overlap the paths.\n     oC += oC.yxz*p1*p1; // Gives a kind of electron effect. Works better with just Voronoi, but it'll do.\n\n\n\n\n     float lDist = max(length(ld), 0.001); // Light distance.\n     float atten = 1./(1. + lDist*.125); // Light attenuation.\n\n     ld /= lDist; // Normalizing the light direction vector.\n\n     float diff = max(dot(ld, sn), 0.); // Diffuse.\n     float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 16.); // Specular.\n     float fre = pow(clamp(dot(sn, rd) + 1., .0, 1.), 3.); // Fresnel, for some mild glow.\n\n     // Shading. Note, there are no actual shadows. The camera is front on, so the following\n     // two functions are enough to give a shadowy appearance.\n     crv = crv*.9 + .1; // Curvature value, to darken the crevices.\n     float ao = calculateAO(sp, sn); // Ambient occlusion, for self shadowing.\n\n\n\n     // Combining the terms above to light the texel.\n     vec3 col = oC*(diff + .5) + vec3(1., .7, .4)*spec*2. + vec3(.4, .7, 1)*fre;\n\n     col += (oC*.5+.5)*envMap(reflect(rd, sn), sn)*6.; // Fake environment mapping.\n\n\n     // Edges.\n     col *= 1. - edge*.85; // Darker edges.\n\n     // Applying the shades.\n     col *= (atten*crv*ao);\n\n\n     // Rough gamma correction, then present to the screen.\n     fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n }\n `;\n\nroot.render(\n    <>\n<ShadertoyReact fs={fragmentShader} />\n<TodoApp />\n<footer>©2024 Ultra Degenerate Labs, No Rights Reserved</footer>\n</>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"mappings":";AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAOC,QAAQ,MAAM,kBAAkB;AACvC,OAAOC,cAAc,MAAM,iBAAiB;AAC5C,OAAO,iBAAiB;AACxB,OAAOC,OAAO,MAAM,uBAAuB;AAC3C,OAAOC,eAAe,MAAM,mBAAmB;AAC/C,OAAOC,MAAM,MAAM,8BAA8B;AACjD,OAAOC,QAAQ,MAAM,8BAA8B;AAAC,SAAAC,MAAA,IAAAC,OAAA,EAAAC,QAAA,IAAAC,SAAA;AACpD,MAAMC,IAAI,GAAGV,QAAQ,CAACW,UAAU,CAACC,QAAQ,CAACC,cAAc,CAAC,MAAM,CAAC,CAAC;AAEhE,MAAMC,cAAc,GAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AAEFJ,IAAI,CAACK,MAAM,eACPR,OAAA,CAAAE,SAAA;EAAAO,QAAA,gBACJT,OAAA,CAACN,cAAc;IAACgB,EAAE,EAAEH;EAAe;IAAAI,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAE,CAAC,eACtCd,OAAA,CAACL,OAAO;IAAAgB,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAE,CAAC,eACXd,OAAA;IAAAS,QAAA,EAAQ;EAA+C;IAAAE,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAQ,CAAC;AAAA,eAC9D,CACF,CAAC;;AAED;AACA;AACA;AACAlB,eAAe,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}