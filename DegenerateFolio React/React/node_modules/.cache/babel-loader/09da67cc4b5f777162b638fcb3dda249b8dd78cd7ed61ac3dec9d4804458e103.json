{"ast":null,"code":"import { BN, bnToBn, bnToHex, bnToU8a, isString, isU8a, u8aToBn } from '@polkadot/util';\nconst BITLENGTH = 64;\nconst U8A_OPTS = {\n  bitLength: BITLENGTH,\n  isLe: true\n};\nfunction decodeDate(value) {\n  if (isU8a(value)) {\n    value = u8aToBn(value.subarray(0, BITLENGTH / 8));\n  } else if (value instanceof Date) {\n    return value;\n  } else if (isString(value)) {\n    value = new BN(value.toString(), 10, 'le');\n  }\n  return new Date(bnToBn(value).toNumber() * 1000);\n}\n/**\n * @name Date\n * @description\n * A wrapper around seconds/timestamps. Internally the representation only has\n * second precicion (aligning with Rust), so any numbers passed an/out are always\n * per-second. For any encoding/decoding the 1000 multiplier would be applied to\n * get it in line with JavaScript formats. It extends the base JS `Date` object\n * and has all the methods available that are applicable to any `Date`\n * @noInheritDoc\n */\nexport class CodecDate extends Date {\n  registry;\n  createdAtHash;\n  initialU8aLength = BITLENGTH / 8;\n  isStorageFallback;\n  constructor(registry, value = 0) {\n    super(decodeDate(value));\n    this.registry = registry;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    return BITLENGTH / 8;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n  get isEmpty() {\n    return this.getTime() === 0;\n  }\n  /**\n   * @description Returns the number of bits in the value\n   */\n  bitLength() {\n    return BITLENGTH;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return decodeDate(other).getTime() === this.getTime();\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return {\n      outer: [this.toU8a()]\n    };\n  }\n  /**\n   * @description Returns a BigInt representation of the number\n   */\n  toBigInt() {\n    return BigInt(this.toNumber());\n  }\n  /**\n   * @description Returns the BN representation of the timestamp\n   */\n  toBn() {\n    return new BN(this.toNumber());\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex(isLe = false) {\n    return bnToHex(this.toBn(), {\n      bitLength: BITLENGTH,\n      isLe,\n      isNegative: false\n    });\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman() {\n    return this.toISOString();\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    // FIXME Return type should be number, but conflicts with Date.toJSON()\n    // which returns string\n    return this.toNumber();\n  }\n  /**\n   * @description Returns the number representation for the timestamp\n   */\n  toNumber() {\n    return Math.ceil(this.getTime() / 1000);\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive() {\n    return this.toNumber();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'Moment';\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    // only included here since we do not inherit docs\n    return super.toString();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   */\n  toU8a(_isBare) {\n    return bnToU8a(this.toNumber(), U8A_OPTS);\n  }\n}","map":{"version":3,"names":["BN","bnToBn","bnToHex","bnToU8a","isString","isU8a","u8aToBn","BITLENGTH","U8A_OPTS","bitLength","isLe","decodeDate","value","subarray","Date","toString","toNumber","CodecDate","registry","createdAtHash","initialU8aLength","isStorageFallback","constructor","encodedLength","hash","toU8a","isEmpty","getTime","eq","other","inspect","outer","toBigInt","BigInt","toBn","toHex","isNegative","toHuman","toISOString","toJSON","Math","ceil","toPrimitive","toRawType","_isBare"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/native/Date.js"],"sourcesContent":["import { BN, bnToBn, bnToHex, bnToU8a, isString, isU8a, u8aToBn } from '@polkadot/util';\nconst BITLENGTH = 64;\nconst U8A_OPTS = { bitLength: BITLENGTH, isLe: true };\nfunction decodeDate(value) {\n    if (isU8a(value)) {\n        value = u8aToBn(value.subarray(0, BITLENGTH / 8));\n    }\n    else if (value instanceof Date) {\n        return value;\n    }\n    else if (isString(value)) {\n        value = new BN(value.toString(), 10, 'le');\n    }\n    return new Date(bnToBn(value).toNumber() * 1000);\n}\n/**\n * @name Date\n * @description\n * A wrapper around seconds/timestamps. Internally the representation only has\n * second precicion (aligning with Rust), so any numbers passed an/out are always\n * per-second. For any encoding/decoding the 1000 multiplier would be applied to\n * get it in line with JavaScript formats. It extends the base JS `Date` object\n * and has all the methods available that are applicable to any `Date`\n * @noInheritDoc\n */\nexport class CodecDate extends Date {\n    registry;\n    createdAtHash;\n    initialU8aLength = BITLENGTH / 8;\n    isStorageFallback;\n    constructor(registry, value = 0) {\n        super(decodeDate(value));\n        this.registry = registry;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return BITLENGTH / 8;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        return this.getTime() === 0;\n    }\n    /**\n     * @description Returns the number of bits in the value\n     */\n    bitLength() {\n        return BITLENGTH;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return decodeDate(other).getTime() === this.getTime();\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            outer: [this.toU8a()]\n        };\n    }\n    /**\n     * @description Returns a BigInt representation of the number\n     */\n    toBigInt() {\n        return BigInt(this.toNumber());\n    }\n    /**\n     * @description Returns the BN representation of the timestamp\n     */\n    toBn() {\n        return new BN(this.toNumber());\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex(isLe = false) {\n        return bnToHex(this.toBn(), {\n            bitLength: BITLENGTH,\n            isLe,\n            isNegative: false\n        });\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman() {\n        return this.toISOString();\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        // FIXME Return type should be number, but conflicts with Date.toJSON()\n        // which returns string\n        return this.toNumber();\n    }\n    /**\n     * @description Returns the number representation for the timestamp\n     */\n    toNumber() {\n        return Math.ceil(this.getTime() / 1000);\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive() {\n        return this.toNumber();\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'Moment';\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        // only included here since we do not inherit docs\n        return super.toString();\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     */\n    toU8a(_isBare) {\n        return bnToU8a(this.toNumber(), U8A_OPTS);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}