{"ast":null,"code":"import { AbstractBase } from '@polkadot/types-codec';\nimport { compactAddLength, compactFromU8a, compactToU8a, isHex, isU8a, objectProperty, objectSpread, u8aConcat, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { EXTRINSIC_VERSION as LATEST_EXTRINSIC_VERSION } from './v4/Extrinsic.js';\nimport { BIT_SIGNED, BIT_UNSIGNED, DEFAULT_VERSION, UNMASK_VERSION } from './constants.js';\nconst VERSIONS = ['ExtrinsicUnknown',\n// v0 is unknown\n'ExtrinsicUnknown', 'ExtrinsicUnknown', 'ExtrinsicUnknown', 'ExtrinsicV4'];\nexport { LATEST_EXTRINSIC_VERSION };\n/** @internal */\nfunction newFromValue(registry, value, version) {\n  if (value instanceof GenericExtrinsic) {\n    return value.unwrap();\n  }\n  const isSigned = (version & BIT_SIGNED) === BIT_SIGNED;\n  const type = VERSIONS[version & UNMASK_VERSION] || VERSIONS[0];\n  // we cast here since the VERSION definition is incredibly broad - we don't have a\n  // slice for \"only add extrinsic types\", and more string definitions become unwieldy\n  return registry.createTypeUnsafe(type, [value, {\n    isSigned,\n    version\n  }]);\n}\n/** @internal */\nfunction decodeExtrinsic(registry, value, version = DEFAULT_VERSION) {\n  if (isU8a(value) || Array.isArray(value) || isHex(value)) {\n    return decodeU8a(registry, u8aToU8a(value), version);\n  } else if (value instanceof registry.createClassUnsafe('Call')) {\n    return newFromValue(registry, {\n      method: value\n    }, version);\n  }\n  return newFromValue(registry, value, version);\n}\n/** @internal */\nfunction decodeU8a(registry, value, version) {\n  if (!value.length) {\n    return newFromValue(registry, new Uint8Array(), version);\n  }\n  const [offset, length] = compactFromU8a(value);\n  const total = offset + length.toNumber();\n  if (total > value.length) {\n    throw new Error(`Extrinsic: length less than remainder, expected at least ${total}, found ${value.length}`);\n  }\n  const data = value.subarray(offset, total);\n  return newFromValue(registry, data.subarray(1), data[0]);\n}\nclass ExtrinsicBase extends AbstractBase {\n  constructor(registry, value, initialU8aLength) {\n    super(registry, value, initialU8aLength);\n    const signKeys = Object.keys(registry.getSignedExtensionTypes());\n    const getter = key => this.inner.signature[key];\n    // This is on the abstract class, ensuring that hasOwnProperty operates\n    // correctly, i.e. it needs to be on the base class exposing it\n    for (let i = 0, count = signKeys.length; i < count; i++) {\n      objectProperty(this, signKeys[i], getter);\n    }\n  }\n  /**\n   * @description The arguments passed to for the call, exposes args so it is compatible with [[Call]]\n   */\n  get args() {\n    return this.method.args;\n  }\n  /**\n   * @description The argument definitions, compatible with [[Call]]\n   */\n  get argsDef() {\n    return this.method.argsDef;\n  }\n  /**\n   * @description The actual `[sectionIndex, methodIndex]` as used in the Call\n   */\n  get callIndex() {\n    return this.method.callIndex;\n  }\n  /**\n   * @description The actual data for the Call\n   */\n  get data() {\n    return this.method.data;\n  }\n  /**\n   * @description The era for this extrinsic\n   */\n  get era() {\n    return this.inner.signature.era;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    return this.toU8a().length;\n  }\n  /**\n   * @description `true` id the extrinsic is signed\n   */\n  get isSigned() {\n    return this.inner.signature.isSigned;\n  }\n  /**\n   * @description The length of the actual data, excluding prefix\n   */\n  get length() {\n    return this.toU8a(true).length;\n  }\n  /**\n   * @description The [[FunctionMetadataLatest]] that describes the extrinsic\n   */\n  get meta() {\n    return this.method.meta;\n  }\n  /**\n   * @description The [[Call]] this extrinsic wraps\n   */\n  get method() {\n    return this.inner.method;\n  }\n  /**\n   * @description The nonce for this extrinsic\n   */\n  get nonce() {\n    return this.inner.signature.nonce;\n  }\n  /**\n   * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]\n   */\n  get signature() {\n    return this.inner.signature.signature;\n  }\n  /**\n   * @description The [[Address]] that signed\n   */\n  get signer() {\n    return this.inner.signature.signer;\n  }\n  /**\n   * @description Forwards compat\n   */\n  get tip() {\n    return this.inner.signature.tip;\n  }\n  /**\n   * @description Forward compat\n   */\n  get assetId() {\n    return this.inner.signature.assetId;\n  }\n  /**\n   * @description Returns the raw transaction version (not flagged with signing information)\n  */\n  get type() {\n    return this.inner.version;\n  }\n  get inner() {\n    return this.unwrap();\n  }\n  /**\n   * @description Returns the encoded version flag\n  */\n  get version() {\n    return this.type | (this.isSigned ? BIT_SIGNED : BIT_UNSIGNED);\n  }\n  /**\n   * @description Checks if the source matches this in type\n   */\n  is(other) {\n    return this.method.is(other);\n  }\n  unwrap() {\n    return super.unwrap();\n  }\n}\n/**\n * @name GenericExtrinsic\n * @description\n * Representation of an Extrinsic in the system. It contains the actual call,\n * (optional) signature and encodes with an actual length prefix\n *\n * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.\n *\n * Can be:\n * - signed, to create a transaction\n * - left as is, to create an inherent\n */\nexport class GenericExtrinsic extends ExtrinsicBase {\n  __internal__hashCache;\n  static LATEST_EXTRINSIC_VERSION = LATEST_EXTRINSIC_VERSION;\n  constructor(registry, value, {\n    version\n  } = {}) {\n    super(registry, decodeExtrinsic(registry, value, version));\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    if (!this.__internal__hashCache) {\n      this.__internal__hashCache = super.hash;\n    }\n    return this.__internal__hashCache;\n  }\n  /**\n   * @description Injects an already-generated signature into the extrinsic\n   */\n  addSignature(signer, signature, payload) {\n    this.inner.addSignature(signer, signature, payload);\n    this.__internal__hashCache = undefined;\n    return this;\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    const encoded = u8aConcat(...this.toU8aInner());\n    return {\n      inner: this.isSigned ? this.inner.inspect().inner : this.inner.method.inspect().inner,\n      outer: [compactToU8a(encoded.length), new Uint8Array([this.version])]\n    };\n  }\n  /**\n   * @description Sign the extrinsic with a specific keypair\n   */\n  sign(account, options) {\n    this.inner.sign(account, options);\n    this.__internal__hashCache = undefined;\n    return this;\n  }\n  /**\n   * @describe Adds a fake signature to the extrinsic\n   */\n  signFake(signer, options) {\n    this.inner.signFake(signer, options);\n    this.__internal__hashCache = undefined;\n    return this;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex(isBare) {\n    return u8aToHex(this.toU8a(isBare));\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExpanded, disableAscii) {\n    return objectSpread({}, {\n      isSigned: this.isSigned,\n      method: this.method.toHuman(isExpanded, disableAscii)\n    }, this.isSigned ? {\n      assetId: this.assetId.toHuman(isExpanded, disableAscii),\n      era: this.era.toHuman(isExpanded, disableAscii),\n      nonce: this.nonce.toHuman(isExpanded, disableAscii),\n      signature: this.signature.toHex(),\n      signer: this.signer.toHuman(isExpanded, disableAscii),\n      tip: this.tip.toHuman(isExpanded, disableAscii)\n    } : null);\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'Extrinsic';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value is not length-prefixed\n   */\n  toU8a(isBare) {\n    const encoded = u8aConcat(...this.toU8aInner());\n    return isBare ? encoded : compactAddLength(encoded);\n  }\n  toU8aInner() {\n    // we do not apply bare to the internal values, rather this only determines out length addition,\n    // where we strip all lengths this creates an extrinsic that cannot be decoded\n    return [new Uint8Array([this.version]), this.inner.toU8a()];\n  }\n}","map":{"version":3,"names":["AbstractBase","compactAddLength","compactFromU8a","compactToU8a","isHex","isU8a","objectProperty","objectSpread","u8aConcat","u8aToHex","u8aToU8a","EXTRINSIC_VERSION","LATEST_EXTRINSIC_VERSION","BIT_SIGNED","BIT_UNSIGNED","DEFAULT_VERSION","UNMASK_VERSION","VERSIONS","newFromValue","registry","value","version","GenericExtrinsic","unwrap","isSigned","type","createTypeUnsafe","decodeExtrinsic","Array","isArray","decodeU8a","createClassUnsafe","method","length","Uint8Array","offset","total","toNumber","Error","data","subarray","ExtrinsicBase","constructor","initialU8aLength","signKeys","Object","keys","getSignedExtensionTypes","getter","key","inner","signature","i","count","args","argsDef","callIndex","era","encodedLength","toU8a","meta","nonce","signer","tip","assetId","is","other","__internal__hashCache","hash","addSignature","payload","undefined","inspect","encoded","toU8aInner","outer","sign","account","options","signFake","toHex","isBare","toHuman","isExpanded","disableAscii","toJSON","toRawType"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/extrinsic/Extrinsic.js"],"sourcesContent":["import { AbstractBase } from '@polkadot/types-codec';\nimport { compactAddLength, compactFromU8a, compactToU8a, isHex, isU8a, objectProperty, objectSpread, u8aConcat, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { EXTRINSIC_VERSION as LATEST_EXTRINSIC_VERSION } from './v4/Extrinsic.js';\nimport { BIT_SIGNED, BIT_UNSIGNED, DEFAULT_VERSION, UNMASK_VERSION } from './constants.js';\nconst VERSIONS = [\n    'ExtrinsicUnknown', // v0 is unknown\n    'ExtrinsicUnknown',\n    'ExtrinsicUnknown',\n    'ExtrinsicUnknown',\n    'ExtrinsicV4'\n];\nexport { LATEST_EXTRINSIC_VERSION };\n/** @internal */\nfunction newFromValue(registry, value, version) {\n    if (value instanceof GenericExtrinsic) {\n        return value.unwrap();\n    }\n    const isSigned = (version & BIT_SIGNED) === BIT_SIGNED;\n    const type = VERSIONS[version & UNMASK_VERSION] || VERSIONS[0];\n    // we cast here since the VERSION definition is incredibly broad - we don't have a\n    // slice for \"only add extrinsic types\", and more string definitions become unwieldy\n    return registry.createTypeUnsafe(type, [value, { isSigned, version }]);\n}\n/** @internal */\nfunction decodeExtrinsic(registry, value, version = DEFAULT_VERSION) {\n    if (isU8a(value) || Array.isArray(value) || isHex(value)) {\n        return decodeU8a(registry, u8aToU8a(value), version);\n    }\n    else if (value instanceof registry.createClassUnsafe('Call')) {\n        return newFromValue(registry, { method: value }, version);\n    }\n    return newFromValue(registry, value, version);\n}\n/** @internal */\nfunction decodeU8a(registry, value, version) {\n    if (!value.length) {\n        return newFromValue(registry, new Uint8Array(), version);\n    }\n    const [offset, length] = compactFromU8a(value);\n    const total = offset + length.toNumber();\n    if (total > value.length) {\n        throw new Error(`Extrinsic: length less than remainder, expected at least ${total}, found ${value.length}`);\n    }\n    const data = value.subarray(offset, total);\n    return newFromValue(registry, data.subarray(1), data[0]);\n}\nclass ExtrinsicBase extends AbstractBase {\n    constructor(registry, value, initialU8aLength) {\n        super(registry, value, initialU8aLength);\n        const signKeys = Object.keys(registry.getSignedExtensionTypes());\n        const getter = (key) => this.inner.signature[key];\n        // This is on the abstract class, ensuring that hasOwnProperty operates\n        // correctly, i.e. it needs to be on the base class exposing it\n        for (let i = 0, count = signKeys.length; i < count; i++) {\n            objectProperty(this, signKeys[i], getter);\n        }\n    }\n    /**\n     * @description The arguments passed to for the call, exposes args so it is compatible with [[Call]]\n     */\n    get args() {\n        return this.method.args;\n    }\n    /**\n     * @description The argument definitions, compatible with [[Call]]\n     */\n    get argsDef() {\n        return this.method.argsDef;\n    }\n    /**\n     * @description The actual `[sectionIndex, methodIndex]` as used in the Call\n     */\n    get callIndex() {\n        return this.method.callIndex;\n    }\n    /**\n     * @description The actual data for the Call\n     */\n    get data() {\n        return this.method.data;\n    }\n    /**\n     * @description The era for this extrinsic\n     */\n    get era() {\n        return this.inner.signature.era;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return this.toU8a().length;\n    }\n    /**\n     * @description `true` id the extrinsic is signed\n     */\n    get isSigned() {\n        return this.inner.signature.isSigned;\n    }\n    /**\n     * @description The length of the actual data, excluding prefix\n     */\n    get length() {\n        return this.toU8a(true).length;\n    }\n    /**\n     * @description The [[FunctionMetadataLatest]] that describes the extrinsic\n     */\n    get meta() {\n        return this.method.meta;\n    }\n    /**\n     * @description The [[Call]] this extrinsic wraps\n     */\n    get method() {\n        return this.inner.method;\n    }\n    /**\n     * @description The nonce for this extrinsic\n     */\n    get nonce() {\n        return this.inner.signature.nonce;\n    }\n    /**\n     * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]\n     */\n    get signature() {\n        return this.inner.signature.signature;\n    }\n    /**\n     * @description The [[Address]] that signed\n     */\n    get signer() {\n        return this.inner.signature.signer;\n    }\n    /**\n     * @description Forwards compat\n     */\n    get tip() {\n        return this.inner.signature.tip;\n    }\n    /**\n     * @description Forward compat\n     */\n    get assetId() {\n        return this.inner.signature.assetId;\n    }\n    /**\n     * @description Returns the raw transaction version (not flagged with signing information)\n    */\n    get type() {\n        return this.inner.version;\n    }\n    get inner() {\n        return this.unwrap();\n    }\n    /**\n     * @description Returns the encoded version flag\n    */\n    get version() {\n        return this.type | (this.isSigned ? BIT_SIGNED : BIT_UNSIGNED);\n    }\n    /**\n     * @description Checks if the source matches this in type\n     */\n    is(other) {\n        return this.method.is(other);\n    }\n    unwrap() {\n        return super.unwrap();\n    }\n}\n/**\n * @name GenericExtrinsic\n * @description\n * Representation of an Extrinsic in the system. It contains the actual call,\n * (optional) signature and encodes with an actual length prefix\n *\n * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.\n *\n * Can be:\n * - signed, to create a transaction\n * - left as is, to create an inherent\n */\nexport class GenericExtrinsic extends ExtrinsicBase {\n    __internal__hashCache;\n    static LATEST_EXTRINSIC_VERSION = LATEST_EXTRINSIC_VERSION;\n    constructor(registry, value, { version } = {}) {\n        super(registry, decodeExtrinsic(registry, value, version));\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        if (!this.__internal__hashCache) {\n            this.__internal__hashCache = super.hash;\n        }\n        return this.__internal__hashCache;\n    }\n    /**\n     * @description Injects an already-generated signature into the extrinsic\n     */\n    addSignature(signer, signature, payload) {\n        this.inner.addSignature(signer, signature, payload);\n        this.__internal__hashCache = undefined;\n        return this;\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        const encoded = u8aConcat(...this.toU8aInner());\n        return {\n            inner: this.isSigned\n                ? this.inner.inspect().inner\n                : this.inner.method.inspect().inner,\n            outer: [compactToU8a(encoded.length), new Uint8Array([this.version])]\n        };\n    }\n    /**\n     * @description Sign the extrinsic with a specific keypair\n     */\n    sign(account, options) {\n        this.inner.sign(account, options);\n        this.__internal__hashCache = undefined;\n        return this;\n    }\n    /**\n     * @describe Adds a fake signature to the extrinsic\n     */\n    signFake(signer, options) {\n        this.inner.signFake(signer, options);\n        this.__internal__hashCache = undefined;\n        return this;\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex(isBare) {\n        return u8aToHex(this.toU8a(isBare));\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExpanded, disableAscii) {\n        return objectSpread({}, {\n            isSigned: this.isSigned,\n            method: this.method.toHuman(isExpanded, disableAscii)\n        }, this.isSigned\n            ? {\n                assetId: this.assetId.toHuman(isExpanded, disableAscii),\n                era: this.era.toHuman(isExpanded, disableAscii),\n                nonce: this.nonce.toHuman(isExpanded, disableAscii),\n                signature: this.signature.toHex(),\n                signer: this.signer.toHuman(isExpanded, disableAscii),\n                tip: this.tip.toHuman(isExpanded, disableAscii)\n            }\n            : null);\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return this.toHex();\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'Extrinsic';\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value is not length-prefixed\n     */\n    toU8a(isBare) {\n        const encoded = u8aConcat(...this.toU8aInner());\n        return isBare\n            ? encoded\n            : compactAddLength(encoded);\n    }\n    toU8aInner() {\n        // we do not apply bare to the internal values, rather this only determines out length addition,\n        // where we strip all lengths this creates an extrinsic that cannot be decoded\n        return [\n            new Uint8Array([this.version]),\n            this.inner.toU8a()\n        ];\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}