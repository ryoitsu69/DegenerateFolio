{"ast":null,"code":"import { CanvasTextMetrics } from '../../text/canvas/CanvasTextMetrics.mjs';\nimport { HTMLTextRenderData } from '../HTMLTextRenderData.mjs';\n\"use strict\";\nlet tempHTMLTextRenderData;\nfunction measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {\n  htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n  const {\n    domElement,\n    styleElement,\n    svgRoot\n  } = htmlTextRenderData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n  domElement.setAttribute(\"style\", \"transform-origin: top left; display: inline-block\");\n  if (fontStyleCSS) {\n    styleElement.textContent = fontStyleCSS;\n  }\n  document.body.appendChild(svgRoot);\n  const contentBounds = domElement.getBoundingClientRect();\n  svgRoot.remove();\n  const descenderPadding = CanvasTextMetrics.measureFont(style.fontStyle).descent;\n  return {\n    width: contentBounds.width,\n    height: contentBounds.height + descenderPadding\n  };\n}\nexport { measureHtmlText };","map":{"version":3,"names":["tempHTMLTextRenderData","measureHtmlText","text","style","fontStyleCSS","htmlTextRenderData","HTMLTextRenderData","domElement","styleElement","svgRoot","innerHTML","cssStyle","setAttribute","textContent","document","body","appendChild","contentBounds","getBoundingClientRect","remove","descenderPadding","CanvasTextMetrics","measureFont","fontStyle","descent","width","height"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/text-html/utils/measureHtmlText.ts"],"sourcesContent":["import { CanvasTextMetrics } from '../../text/canvas/CanvasTextMetrics';\nimport { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    const descenderPadding = CanvasTextMetrics.measureFont(style.fontStyle).descent;\n\n    return {\n        width: contentBounds.width,\n        height: contentBounds.height + descenderPadding,\n    };\n}\n"],"mappings":";;;AAMA,IAAIA,sBAAA;AAWG,SAASC,eACZA,CAAAC,IAAA,EACAC,KACA,EAAAC,YAAA,EACAC,kBAEJ;EACIA,kBAAA,GAAqBA,kBAAsB,IAAAL,sBAAA,KAA2BA,sBAAyB,OAAIM,kBAAmB;EAEtH,MAAM;IAAEC,UAAA;IAAYC,YAAc;IAAAC;EAAA,CAAY,GAAAJ,kBAAA;EAE9CE,UAAA,CAAWG,SAAY,aAAUP,KAAM,CAAAQ,QAAQ,gBAAgBT,IAAI;EAExDK,UAAA,CAAAK,YAAA,CAAa,SAAS,mDAAmD;EAEpF,IAAIR,YACJ;IACII,YAAA,CAAaK,WAAc,GAAAT,YAAA;EAAA;EAItBU,QAAA,CAAAC,IAAA,CAAKC,WAAA,CAAYP,OAAO;EAE3B,MAAAQ,aAAA,GAAgBV,UAAA,CAAWW,qBAAsB;EAEvDT,OAAA,CAAQU,MAAO;EAEf,MAAMC,gBAAmB,GAAAC,iBAAA,CAAkBC,WAAY,CAAAnB,KAAA,CAAMoB,SAAS,CAAE,CAAAC,OAAA;EAEjE;IACHC,KAAA,EAAOR,aAAc,CAAAQ,KAAA;IACrBC,MAAA,EAAQT,aAAA,CAAcS,MAAS,GAAAN;EAAA,CACnC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}