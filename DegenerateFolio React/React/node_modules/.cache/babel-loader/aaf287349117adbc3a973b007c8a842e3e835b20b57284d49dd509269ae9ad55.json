{"ast":null,"code":"import { ExtensionType, extensions } from \"@pixi/extensions\";\nimport { Matrix, Rectangle } from \"@pixi/math\";\nimport { settings } from \"@pixi/settings\";\nimport { AbstractMaskSystem } from \"./AbstractMaskSystem.mjs\";\nconst tempMatrix = new Matrix(),\n  rectPool = [],\n  _ScissorSystem = class _ScissorSystem2 extends AbstractMaskSystem {\n    /**\n     * @param {PIXI.Renderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer) {\n      super(renderer), this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;\n    }\n    getStackLength() {\n      const maskData = this.maskStack[this.maskStack.length - 1];\n      return maskData ? maskData._scissorCounter : 0;\n    }\n    /**\n     * evaluates _boundsTransformed, _scissorRect for MaskData\n     * @param maskData\n     */\n    calcScissorRect(maskData) {\n      if (maskData._scissorRectLocal) return;\n      const prevData = maskData._scissorRect,\n        {\n          maskObject\n        } = maskData,\n        {\n          renderer\n        } = this,\n        renderTextureSystem = renderer.renderTexture,\n        rect = maskObject.getBounds(!0, rectPool.pop() ?? new Rectangle());\n      this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform), prevData && rect.fit(prevData), maskData._scissorRectLocal = rect;\n    }\n    static isMatrixRotated(matrix) {\n      if (!matrix) return !1;\n      const {\n        a,\n        b,\n        c,\n        d\n      } = matrix;\n      return (Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4);\n    }\n    /**\n     * Test, whether the object can be scissor mask with current renderer projection.\n     * Calls \"calcScissorRect()\" if its true.\n     * @param maskData - mask data\n     * @returns whether Whether the object can be scissor mask\n     */\n    testScissor(maskData) {\n      const {\n        maskObject\n      } = maskData;\n      if (!maskObject.isFastRect || !maskObject.isFastRect() || _ScissorSystem2.isMatrixRotated(maskObject.worldTransform) || _ScissorSystem2.isMatrixRotated(this.renderer.projection.transform)) return !1;\n      this.calcScissorRect(maskData);\n      const rect = maskData._scissorRectLocal;\n      return rect.width > 0 && rect.height > 0;\n    }\n    roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n      _ScissorSystem2.isMatrixRotated(transform) || (transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity(), transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y), this.renderer.filter.transformAABB(transform, frame), frame.fit(bindingDestinationFrame), frame.x = Math.round(frame.x * resolution), frame.y = Math.round(frame.y * resolution), frame.width = Math.round(frame.width * resolution), frame.height = Math.round(frame.height * resolution));\n    }\n    /**\n     * Applies the Mask and adds it to the current stencil stack.\n     * @author alvin\n     * @param maskData - The mask data.\n     */\n    push(maskData) {\n      maskData._scissorRectLocal || this.calcScissorRect(maskData);\n      const {\n        gl\n      } = this.renderer;\n      maskData._scissorRect || gl.enable(gl.SCISSOR_TEST), maskData._scissorCounter++, maskData._scissorRect = maskData._scissorRectLocal, this._useCurrent();\n    }\n    /**\n     * This should be called after a mask is popped off the mask stack. It will rebind the scissor box to be latest with the\n     * last mask in the stack.\n     *\n     * This can also be called when you directly modify the scissor box and want to restore PixiJS state.\n     * @param maskData - The mask data.\n     */\n    pop(maskData) {\n      const {\n        gl\n      } = this.renderer;\n      maskData && rectPool.push(maskData._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : gl.disable(gl.SCISSOR_TEST);\n    }\n    /**\n     * Setup renderer to use the current scissor data.\n     * @private\n     */\n    _useCurrent() {\n      const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;\n      let y;\n      this.renderer.renderTexture.current ? y = rect.y : y = this.renderer.height - rect.height - rect.y, this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);\n    }\n  };\n_ScissorSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"scissor\"\n};\nlet ScissorSystem = _ScissorSystem;\nextensions.add(ScissorSystem);\nexport { ScissorSystem };","map":{"version":3,"names":["tempMatrix","Matrix","rectPool","_ScissorSystem","_ScissorSystem2","AbstractMaskSystem","constructor","renderer","glConst","settings","ADAPTER","getWebGLRenderingContext","SCISSOR_TEST","getStackLength","maskData","maskStack","length","_scissorCounter","calcScissorRect","_scissorRectLocal","prevData","_scissorRect","maskObject","renderTextureSystem","renderTexture","rect","getBounds","pop","Rectangle","roundFrameToPixels","current","resolution","sourceFrame","destinationFrame","projection","transform","fit","isMatrixRotated","matrix","a","b","c","d","Math","abs","testScissor","isFastRect","worldTransform","width","height","frame","bindingSourceFrame","bindingDestinationFrame","copyFrom","identity","translate","x","y","scale","filter","transformAABB","round","push","gl","enable","_useCurrent","disable","scissor","extension","type","ExtensionType","RendererSystem","name","ScissorSystem","extensions","add"],"sources":["/home/ryoitsu/node_modules/@pixi/core/src/mask/ScissorSystem.ts"],"sourcesContent":["import { extensions, ExtensionType } from '@pixi/extensions';\nimport { Matrix, Rectangle } from '@pixi/math';\nimport { settings } from '@pixi/settings';\nimport { AbstractMaskSystem } from './AbstractMaskSystem';\n\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { Renderer } from '../Renderer';\nimport type { MaskData } from './MaskData';\n\nconst tempMatrix = new Matrix();\nconst rectPool: Rectangle[] = [];\n\n/**\n * System plugin to the renderer to manage scissor masking.\n *\n * Scissor masking discards pixels outside of a rectangle called the scissor box. The scissor box is in the framebuffer\n * viewport's space; however, the mask's rectangle is projected from world-space to viewport space automatically\n * by this system.\n * @memberof PIXI\n */\nexport class ScissorSystem extends AbstractMaskSystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'scissor',\n    };\n\n    /**\n     * @param {PIXI.Renderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;\n    }\n\n    getStackLength(): number\n    {\n        const maskData = this.maskStack[this.maskStack.length - 1];\n\n        if (maskData)\n        {\n            return maskData._scissorCounter;\n        }\n\n        return 0;\n    }\n\n    /**\n     * evaluates _boundsTransformed, _scissorRect for MaskData\n     * @param maskData\n     */\n    calcScissorRect(maskData: MaskData): void\n    {\n        if (maskData._scissorRectLocal)\n        {\n            return;\n        }\n\n        const prevData = maskData._scissorRect;\n        const { maskObject } = maskData;\n        const { renderer } = this;\n        const renderTextureSystem = renderer.renderTexture;\n        const rect = maskObject.getBounds(true, rectPool.pop() ?? new Rectangle());\n\n        this.roundFrameToPixels(rect,\n            renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,\n            renderTextureSystem.sourceFrame,\n            renderTextureSystem.destinationFrame,\n            renderer.projection.transform);\n\n        if (prevData)\n        {\n            rect.fit(prevData);\n        }\n        maskData._scissorRectLocal = rect;\n    }\n\n    private static isMatrixRotated(matrix: Matrix)\n    {\n        if (!matrix)\n        {\n            return false;\n        }\n        const { a, b, c, d } = matrix;\n\n        // Skip if skew/rotation present in matrix, except for multiple of 90° rotation. If rotation\n        // is a multiple of 90°, then either pair of (b,c) or (a,d) will be (0,0).\n        return ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4)\n            && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4));\n    }\n\n    /**\n     * Test, whether the object can be scissor mask with current renderer projection.\n     * Calls \"calcScissorRect()\" if its true.\n     * @param maskData - mask data\n     * @returns whether Whether the object can be scissor mask\n     */\n    public testScissor(maskData: MaskData): boolean\n    {\n        const { maskObject } = maskData;\n\n        if (!maskObject.isFastRect || !maskObject.isFastRect())\n        {\n            return false;\n        }\n        if (ScissorSystem.isMatrixRotated(maskObject.worldTransform))\n        {\n            return false;\n        }\n        if (ScissorSystem.isMatrixRotated(this.renderer.projection.transform))\n        {\n            return false;\n        }\n\n        this.calcScissorRect(maskData);\n\n        const rect = maskData._scissorRectLocal;\n\n        return rect.width > 0 && rect.height > 0;\n    }\n\n    private roundFrameToPixels(\n        frame: Rectangle,\n        resolution: number,\n        bindingSourceFrame: Rectangle,\n        bindingDestinationFrame: Rectangle,\n        transform?: Matrix,\n    )\n    {\n        if (ScissorSystem.isMatrixRotated(transform))\n        {\n            return;\n        }\n\n        transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();\n\n        // Get forward transform from world space to screen space\n        transform\n            .translate(-bindingSourceFrame.x, -bindingSourceFrame.y)\n            .scale(\n                bindingDestinationFrame.width / bindingSourceFrame.width,\n                bindingDestinationFrame.height / bindingSourceFrame.height)\n            .translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n\n        // Convert frame to screen space\n        (this.renderer.filter as any).transformAABB(transform, frame);\n\n        frame.fit(bindingDestinationFrame);\n        frame.x = Math.round(frame.x * resolution);\n        frame.y = Math.round(frame.y * resolution);\n        frame.width = Math.round(frame.width * resolution);\n        frame.height = Math.round(frame.height * resolution);\n    }\n\n    /**\n     * Applies the Mask and adds it to the current stencil stack.\n     * @author alvin\n     * @param maskData - The mask data.\n     */\n    push(maskData: MaskData): void\n    {\n        if (!maskData._scissorRectLocal)\n        {\n            this.calcScissorRect(maskData);\n        }\n\n        const { gl } = this.renderer;\n\n        if (!maskData._scissorRect)\n        {\n            gl.enable(gl.SCISSOR_TEST);\n        }\n\n        maskData._scissorCounter++;\n        maskData._scissorRect = maskData._scissorRectLocal;\n        this._useCurrent();\n    }\n\n    /**\n     * This should be called after a mask is popped off the mask stack. It will rebind the scissor box to be latest with the\n     * last mask in the stack.\n     *\n     * This can also be called when you directly modify the scissor box and want to restore PixiJS state.\n     * @param maskData - The mask data.\n     */\n    pop(maskData?: MaskData): void\n    {\n        const { gl } = this.renderer;\n\n        if (maskData)\n        {\n            rectPool.push(maskData._scissorRectLocal);\n        }\n\n        if (this.getStackLength() > 0)\n        {\n            this._useCurrent();\n        }\n        else\n        {\n            gl.disable(gl.SCISSOR_TEST);\n        }\n    }\n\n    /**\n     * Setup renderer to use the current scissor data.\n     * @private\n     */\n    _useCurrent(): void\n    {\n        const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;\n        let y: number;\n\n        if (this.renderer.renderTexture.current)\n        {\n            y = rect.y;\n        }\n        else\n        {\n            // flipY. In future we'll have it over renderTextures as an option\n            y = this.renderer.height - rect.height - rect.y;\n        }\n\n        this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);\n    }\n}\n\nextensions.add(ScissorSystem);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}