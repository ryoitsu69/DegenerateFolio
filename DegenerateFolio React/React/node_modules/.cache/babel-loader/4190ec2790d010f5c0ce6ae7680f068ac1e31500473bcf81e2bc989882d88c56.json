{"ast":null,"code":"import { sanitize } from '@polkadot/types-codec';\nimport { isNumber, isString, objectSpread, stringify } from '@polkadot/util';\nimport { TypeDefInfo } from '../types/index.js';\nimport { typeSplit } from './typeSplit.js';\nconst KNOWN_INTERNALS = ['_alias', '_fallback'];\nfunction getTypeString(typeOrObj) {\n  return isString(typeOrObj) ? typeOrObj.toString() : stringify(typeOrObj);\n}\nfunction isRustEnum(details) {\n  const values = Object.values(details);\n  if (values.some(v => isNumber(v))) {\n    if (!values.every(v => isNumber(v) && v >= 0 && v <= 255)) {\n      throw new Error('Invalid number-indexed enum definition');\n    }\n    return false;\n  }\n  return true;\n}\nfunction _decodeEnum(value, details, count, fallbackType) {\n  value.info = TypeDefInfo.Enum;\n  value.fallbackType = fallbackType;\n  // not as pretty, but remain compatible with oo7 for both struct and Array types\n  if (Array.isArray(details)) {\n    value.sub = details.map((name, index) => ({\n      index,\n      info: TypeDefInfo.Plain,\n      name,\n      type: 'Null'\n    }));\n  } else if (isRustEnum(details)) {\n    value.sub = Object.entries(details).map(([name, typeOrObj], index) => objectSpread({}, getTypeDef(getTypeString(typeOrObj || 'Null'), {\n      name\n    }, count), {\n      index\n    }));\n  } else {\n    value.sub = Object.entries(details).map(([name, index]) => ({\n      index,\n      info: TypeDefInfo.Plain,\n      name,\n      type: 'Null'\n    }));\n  }\n  return value;\n}\nfunction _decodeSet(value, details, fallbackType) {\n  value.info = TypeDefInfo.Set;\n  value.fallbackType = fallbackType;\n  value.length = details._bitLength;\n  value.sub = Object.entries(details).filter(([name]) => !name.startsWith('_')).map(([name, index]) => ({\n    index,\n    info: TypeDefInfo.Plain,\n    name,\n    type: 'Null'\n  }));\n  return value;\n}\nfunction _decodeStruct(value, type, _, count) {\n  const parsed = JSON.parse(type);\n  const keys = Object.keys(parsed);\n  if (parsed._enum) {\n    return _decodeEnum(value, parsed._enum, count, parsed._fallback);\n  } else if (parsed._set) {\n    return _decodeSet(value, parsed._set, parsed._fallback);\n  }\n  value.alias = parsed._alias ? new Map(Object.entries(parsed._alias)) : undefined;\n  value.fallbackType = parsed._fallback;\n  value.sub = keys.filter(name => !KNOWN_INTERNALS.includes(name)).map(name => getTypeDef(getTypeString(parsed[name]), {\n    name\n  }, count));\n  return value;\n}\nfunction _decodeFixedVec(value, type, _, count) {\n  const max = type.length - 1;\n  let index = -1;\n  let inner = 0;\n  for (let i = 1; i < max && index === -1; i++) {\n    switch (type[i]) {\n      case ';':\n        {\n          if (inner === 0) {\n            index = i;\n          }\n          break;\n        }\n      case '[':\n      case '(':\n      case '<':\n        inner++;\n        break;\n      case ']':\n      case ')':\n      case '>':\n        inner--;\n        break;\n    }\n  }\n  if (index === -1) {\n    throw new Error(`${type}: Unable to extract location of ';'`);\n  }\n  const vecType = type.substring(1, index);\n  const [strLength, displayName] = type.substring(index + 1, max).split(';');\n  const length = parseInt(strLength.trim(), 10);\n  if (length > 2048) {\n    throw new Error(`${type}: Only support for [Type; <length>], where length <= 2048`);\n  }\n  value.displayName = displayName;\n  value.length = length;\n  value.sub = getTypeDef(vecType, {}, count);\n  return value;\n}\nfunction _decodeTuple(value, _, subType, count) {\n  value.sub = subType.length === 0 ? [] : typeSplit(subType).map(inner => getTypeDef(inner, {}, count));\n  return value;\n}\nfunction _decodeAnyInt(value, type, _, clazz) {\n  const [strLength, displayName] = type.substring(clazz.length + 1, type.length - 1).split(',');\n  const length = parseInt(strLength.trim(), 10);\n  if (length > 8192 || length % 8) {\n    throw new Error(`${type}: Only support for ${clazz}<bitLength>, where length <= 8192 and a power of 8, found ${length}`);\n  }\n  value.displayName = displayName;\n  value.length = length;\n  return value;\n}\nfunction _decodeInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'Int');\n}\nfunction _decodeUInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'UInt');\n}\nfunction _decodeDoNotConstruct(value, type, _) {\n  const NAME_LENGTH = 'DoNotConstruct'.length;\n  value.displayName = type.substring(NAME_LENGTH + 1, type.length - 1);\n  return value;\n}\nfunction hasWrapper(type, [start, end]) {\n  return type.startsWith(start) && type.slice(-1 * end.length) === end;\n}\nconst nestedExtraction = [['[', ']', TypeDefInfo.VecFixed, _decodeFixedVec], ['{', '}', TypeDefInfo.Struct, _decodeStruct], ['(', ')', TypeDefInfo.Tuple, _decodeTuple],\n// the inner for these are the same as tuple, multiple values\n['BTreeMap<', '>', TypeDefInfo.BTreeMap, _decodeTuple], ['HashMap<', '>', TypeDefInfo.HashMap, _decodeTuple], ['Int<', '>', TypeDefInfo.Int, _decodeInt], ['Result<', '>', TypeDefInfo.Result, _decodeTuple], ['UInt<', '>', TypeDefInfo.UInt, _decodeUInt], ['DoNotConstruct<', '>', TypeDefInfo.DoNotConstruct, _decodeDoNotConstruct]];\nconst wrappedExtraction = [['BTreeSet<', '>', TypeDefInfo.BTreeSet], ['Compact<', '>', TypeDefInfo.Compact], ['Linkage<', '>', TypeDefInfo.Linkage], ['Opaque<', '>', TypeDefInfo.WrapperOpaque], ['Option<', '>', TypeDefInfo.Option], ['Range<', '>', TypeDefInfo.Range], ['RangeInclusive<', '>', TypeDefInfo.RangeInclusive], ['Vec<', '>', TypeDefInfo.Vec], ['WrapperKeepOpaque<', '>', TypeDefInfo.WrapperKeepOpaque], ['WrapperOpaque<', '>', TypeDefInfo.WrapperOpaque]];\nfunction extractSubType(type, [start, end]) {\n  return type.substring(start.length, type.length - end.length);\n}\nexport function getTypeDef(_type, {\n  displayName,\n  name\n} = {}, count = 0) {\n  // create the type via Type, allowing types to be sanitized\n  const type = sanitize(_type);\n  const value = {\n    displayName,\n    info: TypeDefInfo.Plain,\n    name,\n    type\n  };\n  if (++count > 64) {\n    throw new Error('getTypeDef: Maximum nested limit reached');\n  }\n  const nested = nestedExtraction.find(nested => hasWrapper(type, nested));\n  if (nested) {\n    value.info = nested[2];\n    return nested[3](value, type, extractSubType(type, nested), count);\n  }\n  const wrapped = wrappedExtraction.find(wrapped => hasWrapper(type, wrapped));\n  if (wrapped) {\n    value.info = wrapped[2];\n    value.sub = getTypeDef(extractSubType(type, wrapped), {}, count);\n  }\n  return value;\n}","map":{"version":3,"names":["sanitize","isNumber","isString","objectSpread","stringify","TypeDefInfo","typeSplit","KNOWN_INTERNALS","getTypeString","typeOrObj","toString","isRustEnum","details","values","Object","some","v","every","Error","_decodeEnum","value","count","fallbackType","info","Enum","Array","isArray","sub","map","name","index","Plain","type","entries","getTypeDef","_decodeSet","Set","length","_bitLength","filter","startsWith","_decodeStruct","_","parsed","JSON","parse","keys","_enum","_fallback","_set","alias","_alias","Map","undefined","includes","_decodeFixedVec","max","inner","i","vecType","substring","strLength","displayName","split","parseInt","trim","_decodeTuple","subType","_decodeAnyInt","clazz","_decodeInt","_decodeUInt","_decodeDoNotConstruct","NAME_LENGTH","hasWrapper","start","end","slice","nestedExtraction","VecFixed","Struct","Tuple","BTreeMap","HashMap","Int","Result","UInt","DoNotConstruct","wrappedExtraction","BTreeSet","Compact","Linkage","WrapperOpaque","Option","Range","RangeInclusive","Vec","WrapperKeepOpaque","extractSubType","_type","nested","find","wrapped"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-create/util/getTypeDef.js"],"sourcesContent":["import { sanitize } from '@polkadot/types-codec';\nimport { isNumber, isString, objectSpread, stringify } from '@polkadot/util';\nimport { TypeDefInfo } from '../types/index.js';\nimport { typeSplit } from './typeSplit.js';\nconst KNOWN_INTERNALS = ['_alias', '_fallback'];\nfunction getTypeString(typeOrObj) {\n    return isString(typeOrObj)\n        ? typeOrObj.toString()\n        : stringify(typeOrObj);\n}\nfunction isRustEnum(details) {\n    const values = Object.values(details);\n    if (values.some((v) => isNumber(v))) {\n        if (!values.every((v) => isNumber(v) && v >= 0 && v <= 255)) {\n            throw new Error('Invalid number-indexed enum definition');\n        }\n        return false;\n    }\n    return true;\n}\nfunction _decodeEnum(value, details, count, fallbackType) {\n    value.info = TypeDefInfo.Enum;\n    value.fallbackType = fallbackType;\n    // not as pretty, but remain compatible with oo7 for both struct and Array types\n    if (Array.isArray(details)) {\n        value.sub = details.map((name, index) => ({\n            index,\n            info: TypeDefInfo.Plain,\n            name,\n            type: 'Null'\n        }));\n    }\n    else if (isRustEnum(details)) {\n        value.sub = Object.entries(details).map(([name, typeOrObj], index) => objectSpread({}, getTypeDef(getTypeString(typeOrObj || 'Null'), { name }, count), { index }));\n    }\n    else {\n        value.sub = Object.entries(details).map(([name, index]) => ({\n            index,\n            info: TypeDefInfo.Plain,\n            name,\n            type: 'Null'\n        }));\n    }\n    return value;\n}\nfunction _decodeSet(value, details, fallbackType) {\n    value.info = TypeDefInfo.Set;\n    value.fallbackType = fallbackType;\n    value.length = details._bitLength;\n    value.sub = Object\n        .entries(details)\n        .filter(([name]) => !name.startsWith('_'))\n        .map(([name, index]) => ({\n        index,\n        info: TypeDefInfo.Plain,\n        name,\n        type: 'Null'\n    }));\n    return value;\n}\nfunction _decodeStruct(value, type, _, count) {\n    const parsed = JSON.parse(type);\n    const keys = Object.keys(parsed);\n    if (parsed._enum) {\n        return _decodeEnum(value, parsed._enum, count, parsed._fallback);\n    }\n    else if (parsed._set) {\n        return _decodeSet(value, parsed._set, parsed._fallback);\n    }\n    value.alias = parsed._alias\n        ? new Map(Object.entries(parsed._alias))\n        : undefined;\n    value.fallbackType = parsed._fallback;\n    value.sub = keys\n        .filter((name) => !KNOWN_INTERNALS.includes(name))\n        .map((name) => getTypeDef(getTypeString(parsed[name]), { name }, count));\n    return value;\n}\nfunction _decodeFixedVec(value, type, _, count) {\n    const max = type.length - 1;\n    let index = -1;\n    let inner = 0;\n    for (let i = 1; (i < max) && (index === -1); i++) {\n        switch (type[i]) {\n            case ';': {\n                if (inner === 0) {\n                    index = i;\n                }\n                break;\n            }\n            case '[':\n            case '(':\n            case '<':\n                inner++;\n                break;\n            case ']':\n            case ')':\n            case '>':\n                inner--;\n                break;\n        }\n    }\n    if (index === -1) {\n        throw new Error(`${type}: Unable to extract location of ';'`);\n    }\n    const vecType = type.substring(1, index);\n    const [strLength, displayName] = type.substring(index + 1, max).split(';');\n    const length = parseInt(strLength.trim(), 10);\n    if (length > 2048) {\n        throw new Error(`${type}: Only support for [Type; <length>], where length <= 2048`);\n    }\n    value.displayName = displayName;\n    value.length = length;\n    value.sub = getTypeDef(vecType, {}, count);\n    return value;\n}\nfunction _decodeTuple(value, _, subType, count) {\n    value.sub = subType.length === 0\n        ? []\n        : typeSplit(subType).map((inner) => getTypeDef(inner, {}, count));\n    return value;\n}\nfunction _decodeAnyInt(value, type, _, clazz) {\n    const [strLength, displayName] = type.substring(clazz.length + 1, type.length - 1).split(',');\n    const length = parseInt(strLength.trim(), 10);\n    if ((length > 8192) || (length % 8)) {\n        throw new Error(`${type}: Only support for ${clazz}<bitLength>, where length <= 8192 and a power of 8, found ${length}`);\n    }\n    value.displayName = displayName;\n    value.length = length;\n    return value;\n}\nfunction _decodeInt(value, type, subType) {\n    return _decodeAnyInt(value, type, subType, 'Int');\n}\nfunction _decodeUInt(value, type, subType) {\n    return _decodeAnyInt(value, type, subType, 'UInt');\n}\nfunction _decodeDoNotConstruct(value, type, _) {\n    const NAME_LENGTH = 'DoNotConstruct'.length;\n    value.displayName = type.substring(NAME_LENGTH + 1, type.length - 1);\n    return value;\n}\nfunction hasWrapper(type, [start, end]) {\n    return (type.startsWith(start)) && (type.slice(-1 * end.length) === end);\n}\nconst nestedExtraction = [\n    ['[', ']', TypeDefInfo.VecFixed, _decodeFixedVec],\n    ['{', '}', TypeDefInfo.Struct, _decodeStruct],\n    ['(', ')', TypeDefInfo.Tuple, _decodeTuple],\n    // the inner for these are the same as tuple, multiple values\n    ['BTreeMap<', '>', TypeDefInfo.BTreeMap, _decodeTuple],\n    ['HashMap<', '>', TypeDefInfo.HashMap, _decodeTuple],\n    ['Int<', '>', TypeDefInfo.Int, _decodeInt],\n    ['Result<', '>', TypeDefInfo.Result, _decodeTuple],\n    ['UInt<', '>', TypeDefInfo.UInt, _decodeUInt],\n    ['DoNotConstruct<', '>', TypeDefInfo.DoNotConstruct, _decodeDoNotConstruct]\n];\nconst wrappedExtraction = [\n    ['BTreeSet<', '>', TypeDefInfo.BTreeSet],\n    ['Compact<', '>', TypeDefInfo.Compact],\n    ['Linkage<', '>', TypeDefInfo.Linkage],\n    ['Opaque<', '>', TypeDefInfo.WrapperOpaque],\n    ['Option<', '>', TypeDefInfo.Option],\n    ['Range<', '>', TypeDefInfo.Range],\n    ['RangeInclusive<', '>', TypeDefInfo.RangeInclusive],\n    ['Vec<', '>', TypeDefInfo.Vec],\n    ['WrapperKeepOpaque<', '>', TypeDefInfo.WrapperKeepOpaque],\n    ['WrapperOpaque<', '>', TypeDefInfo.WrapperOpaque]\n];\nfunction extractSubType(type, [start, end]) {\n    return type.substring(start.length, type.length - end.length);\n}\nexport function getTypeDef(_type, { displayName, name } = {}, count = 0) {\n    // create the type via Type, allowing types to be sanitized\n    const type = sanitize(_type);\n    const value = { displayName, info: TypeDefInfo.Plain, name, type };\n    if (++count > 64) {\n        throw new Error('getTypeDef: Maximum nested limit reached');\n    }\n    const nested = nestedExtraction.find((nested) => hasWrapper(type, nested));\n    if (nested) {\n        value.info = nested[2];\n        return nested[3](value, type, extractSubType(type, nested), count);\n    }\n    const wrapped = wrappedExtraction.find((wrapped) => hasWrapper(type, wrapped));\n    if (wrapped) {\n        value.info = wrapped[2];\n        value.sub = getTypeDef(extractSubType(type, wrapped), {}, count);\n    }\n    return value;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}