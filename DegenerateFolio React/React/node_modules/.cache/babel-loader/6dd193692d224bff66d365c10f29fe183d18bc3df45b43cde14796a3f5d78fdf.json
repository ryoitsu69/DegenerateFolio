{"ast":null,"code":"import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { BufferUsage } from '../../shared/buffer/const.mjs';\nimport { BUFFER_TYPE } from './const.mjs';\nimport { GlBuffer } from './GlBuffer.mjs';\n\"use strict\";\nclass GlBufferSystem {\n  /**\n   * @param {Renderer} renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this._gpuBuffers = /* @__PURE__ */Object.create(null);\n    /** Cache keeping track of the base bound buffer bases */\n    this._boundBufferBases = /* @__PURE__ */Object.create(null);\n    this._renderer = renderer;\n  }\n  /**\n   * @ignore\n   */\n  destroy() {\n    this._renderer = null;\n    this._gl = null;\n    this._gpuBuffers = null;\n    this._boundBufferBases = null;\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    this._gpuBuffers = /* @__PURE__ */Object.create(null);\n    this._gl = this._renderer.gl;\n  }\n  getGlBuffer(buffer) {\n    return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);\n  }\n  /**\n   * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n   * @param buffer - the buffer to bind to the renderer\n   */\n  bind(buffer) {\n    const {\n      _gl: gl\n    } = this;\n    const glBuffer = this.getGlBuffer(buffer);\n    gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n  }\n  /**\n   * Binds an uniform buffer to at the given index.\n   *\n   * A cache is used so a buffer will not be bound again if already bound.\n   * @param buffer - the buffer to bind\n   * @param index - the base index to bind it to.\n   */\n  bindBufferBase(buffer, index) {\n    const {\n      _gl: gl\n    } = this;\n    if (this._boundBufferBases[index] !== buffer) {\n      const glBuffer = this.getGlBuffer(buffer);\n      this._boundBufferBases[index] = buffer;\n      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n    }\n  }\n  /**\n   * Binds a buffer whilst also binding its range.\n   * This will make the buffer start from the offset supplied rather than 0 when it is read.\n   * @param buffer - the buffer to bind\n   * @param index - the base index to bind at, defaults to 0\n   * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n   */\n  bindBufferRange(buffer, index, offset) {\n    const {\n      _gl: gl\n    } = this;\n    offset = offset || 0;\n    const glBuffer = this.getGlBuffer(buffer);\n    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);\n  }\n  /**\n   * Will ensure the data in the buffer is uploaded to the GPU.\n   * @param {Buffer} buffer - the buffer to update\n   */\n  updateBuffer(buffer) {\n    const {\n      _gl: gl\n    } = this;\n    const glBuffer = this.getGlBuffer(buffer);\n    if (buffer._updateID === glBuffer.updateID) {\n      return glBuffer;\n    }\n    glBuffer.updateID = buffer._updateID;\n    gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n    const data = buffer.data;\n    if (glBuffer.byteLength >= buffer.data.byteLength) {\n      gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);\n    } else {\n      const drawType = buffer.descriptor.usage & BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n      glBuffer.byteLength = data.byteLength;\n      gl.bufferData(glBuffer.type, data, drawType);\n    }\n    return glBuffer;\n  }\n  /** dispose all WebGL resources of all managed buffers */\n  destroyAll() {\n    const gl = this._gl;\n    for (const id in this._gpuBuffers) {\n      gl.deleteBuffer(this._gpuBuffers[id].buffer);\n    }\n    this._gpuBuffers = /* @__PURE__ */Object.create(null);\n  }\n  /**\n   * Disposes buffer\n   * @param {Buffer} buffer - buffer with data\n   * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n   */\n  onBufferDestroy(buffer, contextLost) {\n    const glBuffer = this._gpuBuffers[buffer.uid];\n    const gl = this._gl;\n    if (!contextLost) {\n      gl.deleteBuffer(glBuffer.buffer);\n    }\n    this._gpuBuffers[buffer.uid] = null;\n  }\n  /**\n   * creates and attaches a GLBuffer object tied to the current context.\n   * @param buffer\n   * @protected\n   */\n  createGLBuffer(buffer) {\n    const {\n      _gl: gl\n    } = this;\n    let type = BUFFER_TYPE.ARRAY_BUFFER;\n    if (buffer.descriptor.usage & BufferUsage.INDEX) {\n      type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n    } else if (buffer.descriptor.usage & BufferUsage.UNIFORM) {\n      type = BUFFER_TYPE.UNIFORM_BUFFER;\n    }\n    const glBuffer = new GlBuffer(gl.createBuffer(), type);\n    this._gpuBuffers[buffer.uid] = glBuffer;\n    buffer.on(\"destroy\", this.onBufferDestroy, this);\n    return glBuffer;\n  }\n}\n/** @ignore */\nGlBufferSystem.extension = {\n  type: [ExtensionType.WebGLSystem],\n  name: \"buffer\"\n};\nexport { GlBufferSystem };","map":{"version":3,"names":["GlBufferSystem","constructor","renderer","_gpuBuffers","Object","create","_boundBufferBases","_renderer","destroy","_gl","contextChange","gl","getGlBuffer","buffer","uid","createGLBuffer","bind","glBuffer","bindBuffer","type","bindBufferBase","index","UNIFORM_BUFFER","bindBufferRange","offset","updateBuffer","_updateID","updateID","data","byteLength","bufferSubData","_updateSize","BYTES_PER_ELEMENT","drawType","descriptor","usage","BufferUsage","STATIC","STATIC_DRAW","DYNAMIC_DRAW","bufferData","destroyAll","id","deleteBuffer","onBufferDestroy","contextLost","BUFFER_TYPE","ARRAY_BUFFER","INDEX","ELEMENT_ARRAY_BUFFER","UNIFORM","GlBuffer","createBuffer","on","extension","ExtensionType","WebGLSystem","name"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gl/buffer/GlBufferSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { BufferUsage } from '../../shared/buffer/const';\nimport { BUFFER_TYPE } from './const';\nimport { GlBuffer } from './GlBuffer';\n\nimport type { Buffer } from '../../shared/buffer/Buffer';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * System plugin to the renderer to manage buffers.\n *\n * WebGL uses Buffers as a way to store objects to the GPU.\n * This system makes working with them a lot easier.\n *\n * Buffers are used in three main places in WebGL\n * - geometry information\n * - Uniform information (via uniform buffer objects - a WebGL 2 only feature)\n * - Transform feedback information. (WebGL 2 only feature)\n *\n * This system will handle the binding of buffers to the GPU as well as uploading\n * them. With this system, you never need to work directly with GPU buffers, but instead work with\n * the Buffer class.\n * @class\n * @memberof rendering\n */\nexport class GlBufferSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'buffer',\n    } as const;\n\n    private _gl: GlRenderingContext;\n    private _gpuBuffers: {[key: number]: GlBuffer} = Object.create(null);\n\n    /** Cache keeping track of the base bound buffer bases */\n    private readonly _boundBufferBases: {[key: number]: Buffer} = Object.create(null);\n\n    private _renderer: WebGLRenderer;\n\n    /**\n     * @param {Renderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * @ignore\n     */\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._gl = null;\n        this._gpuBuffers = null;\n        (this._boundBufferBases as null) = null;\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        this._gpuBuffers = Object.create(null);\n        this._gl = this._renderer.gl;\n    }\n\n    public getGlBuffer(buffer: Buffer): GlBuffer\n    {\n        return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);\n    }\n\n    /**\n     * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n     * @param buffer - the buffer to bind to the renderer\n     */\n    public bind(buffer: Buffer): void\n    {\n        const { _gl: gl } = this;\n\n        const glBuffer = this.getGlBuffer(buffer);\n\n        gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n    }\n\n    /**\n     * Binds an uniform buffer to at the given index.\n     *\n     * A cache is used so a buffer will not be bound again if already bound.\n     * @param buffer - the buffer to bind\n     * @param index - the base index to bind it to.\n     */\n    public bindBufferBase(buffer: Buffer, index: number): void\n    {\n        const { _gl: gl } = this;\n\n        if (this._boundBufferBases[index] !== buffer)\n        {\n            const glBuffer = this.getGlBuffer(buffer);\n\n            this._boundBufferBases[index] = buffer;\n\n            gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n        }\n    }\n\n    /**\n     * Binds a buffer whilst also binding its range.\n     * This will make the buffer start from the offset supplied rather than 0 when it is read.\n     * @param buffer - the buffer to bind\n     * @param index - the base index to bind at, defaults to 0\n     * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n     */\n    public bindBufferRange(buffer: Buffer, index?: number, offset?: number): void\n    {\n        const { _gl: gl } = this;\n\n        offset = offset || 0;\n\n        const glBuffer = this.getGlBuffer(buffer);\n\n        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);\n    }\n\n    /**\n     * Will ensure the data in the buffer is uploaded to the GPU.\n     * @param {Buffer} buffer - the buffer to update\n     */\n    public updateBuffer(buffer: Buffer): GlBuffer\n    {\n        const { _gl: gl } = this;\n\n        const glBuffer = this.getGlBuffer(buffer);\n\n        if (buffer._updateID === glBuffer.updateID)\n        {\n            return glBuffer;\n        }\n\n        glBuffer.updateID = buffer._updateID;\n\n        gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n\n        const data = buffer.data;\n\n        if (glBuffer.byteLength >= buffer.data.byteLength)\n        {\n            // assuming our buffers are aligned to 4 bits...\n            // offset is always zero for now!\n            gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);\n        }\n        else\n        {\n            const drawType = (buffer.descriptor.usage & BufferUsage.STATIC) ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n\n            glBuffer.byteLength = data.byteLength;\n\n            // assuming our buffers are aligned to 4 bits...\n            gl.bufferData(glBuffer.type, data, drawType);\n        }\n\n        return glBuffer;\n    }\n\n    /** dispose all WebGL resources of all managed buffers */\n    public destroyAll(): void\n    {\n        const gl = this._gl;\n\n        for (const id in this._gpuBuffers)\n        {\n            gl.deleteBuffer(this._gpuBuffers[id].buffer);\n        }\n\n        this._gpuBuffers = Object.create(null);\n    }\n\n    /**\n     * Disposes buffer\n     * @param {Buffer} buffer - buffer with data\n     * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    protected onBufferDestroy(buffer: Buffer, contextLost?: boolean): void\n    {\n        const glBuffer = this._gpuBuffers[buffer.uid];\n\n        const gl = this._gl;\n\n        if (!contextLost)\n        {\n            gl.deleteBuffer(glBuffer.buffer);\n        }\n\n        this._gpuBuffers[buffer.uid] = null;\n    }\n\n    /**\n     * creates and attaches a GLBuffer object tied to the current context.\n     * @param buffer\n     * @protected\n     */\n    protected createGLBuffer(buffer: Buffer): GlBuffer\n    {\n        const { _gl: gl } = this;\n\n        let type = BUFFER_TYPE.ARRAY_BUFFER;\n\n        if ((buffer.descriptor.usage & BufferUsage.INDEX))\n        {\n            type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n        }\n        else if ((buffer.descriptor.usage & BufferUsage.UNIFORM))\n        {\n            type = BUFFER_TYPE.UNIFORM_BUFFER;\n        }\n\n        const glBuffer = new GlBuffer(gl.createBuffer(), type);\n\n        this._gpuBuffers[buffer.uid] = glBuffer;\n\n        buffer.on('destroy', this.onBufferDestroy, this);\n\n        return glBuffer;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}