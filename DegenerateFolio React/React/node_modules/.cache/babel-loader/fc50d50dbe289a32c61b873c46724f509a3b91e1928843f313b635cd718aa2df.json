{"ast":null,"code":"\"use strict\";\n\nclass GpuMipmapGenerator {\n  constructor(device) {\n    this.device = device;\n    this.sampler = device.createSampler({\n      minFilter: \"linear\"\n    });\n    this.pipelines = {};\n  }\n  _getMipmapPipeline(format) {\n    let pipeline = this.pipelines[format];\n    if (!pipeline) {\n      if (!this.mipmapShaderModule) {\n        this.mipmapShaderModule = this.device.createShaderModule({\n          code: ( /* wgsl */\n          `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `)\n        });\n      }\n      pipeline = this.device.createRenderPipeline({\n        layout: \"auto\",\n        vertex: {\n          module: this.mipmapShaderModule,\n          entryPoint: \"vertexMain\"\n        },\n        fragment: {\n          module: this.mipmapShaderModule,\n          entryPoint: \"fragmentMain\",\n          targets: [{\n            format\n          }]\n        }\n      });\n      this.pipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  /**\n   * Generates mipmaps for the given GPUTexture from the data in level 0.\n   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n   * @returns {module:External.GPUTexture} - The originally passed texture\n   */\n  generateMipmap(texture) {\n    const pipeline = this._getMipmapPipeline(texture.format);\n    if (texture.dimension === \"3d\" || texture.dimension === \"1d\") {\n      throw new Error(\"Generating mipmaps for non-2d textures is currently unsupported!\");\n    }\n    let mipTexture = texture;\n    const arrayLayerCount = texture.depthOrArrayLayers || 1;\n    const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n    if (!renderToSource) {\n      const mipTextureDescriptor = {\n        size: {\n          width: Math.ceil(texture.width / 2),\n          height: Math.ceil(texture.height / 2),\n          depthOrArrayLayers: arrayLayerCount\n        },\n        format: texture.format,\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: texture.mipLevelCount - 1\n      };\n      mipTexture = this.device.createTexture(mipTextureDescriptor);\n    }\n    const commandEncoder = this.device.createCommandEncoder({});\n    const bindGroupLayout = pipeline.getBindGroupLayout(0);\n    for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {\n      let srcView = texture.createView({\n        baseMipLevel: 0,\n        mipLevelCount: 1,\n        dimension: \"2d\",\n        baseArrayLayer: arrayLayer,\n        arrayLayerCount: 1\n      });\n      let dstMipLevel = renderToSource ? 1 : 0;\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        const dstView = mipTexture.createView({\n          baseMipLevel: dstMipLevel++,\n          mipLevelCount: 1,\n          dimension: \"2d\",\n          baseArrayLayer: arrayLayer,\n          arrayLayerCount: 1\n        });\n        const passEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [{\n            view: dstView,\n            storeOp: \"store\",\n            loadOp: \"clear\",\n            clearValue: {\n              r: 0,\n              g: 0,\n              b: 0,\n              a: 0\n            }\n          }]\n        });\n        const bindGroup = this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: [{\n            binding: 0,\n            resource: this.sampler\n          }, {\n            binding: 1,\n            resource: srcView\n          }]\n        });\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setBindGroup(0, bindGroup);\n        passEncoder.draw(3, 1, 0, 0);\n        passEncoder.end();\n        srcView = dstView;\n      }\n    }\n    if (!renderToSource) {\n      const mipLevelSize = {\n        width: Math.ceil(texture.width / 2),\n        height: Math.ceil(texture.height / 2),\n        depthOrArrayLayers: arrayLayerCount\n      };\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        commandEncoder.copyTextureToTexture({\n          texture: mipTexture,\n          mipLevel: i - 1\n        }, {\n          texture,\n          mipLevel: i\n        }, mipLevelSize);\n        mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n        mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n      }\n    }\n    this.device.queue.submit([commandEncoder.finish()]);\n    if (!renderToSource) {\n      mipTexture.destroy();\n    }\n    return texture;\n  }\n}\nexport { GpuMipmapGenerator };","map":{"version":3,"names":["GpuMipmapGenerator","constructor","device","sampler","createSampler","minFilter","pipelines","_getMipmapPipeline","format","pipeline","mipmapShaderModule","createShaderModule","code","createRenderPipeline","layout","vertex","module","entryPoint","fragment","targets","generateMipmap","texture","dimension","Error","mipTexture","arrayLayerCount","depthOrArrayLayers","renderToSource","usage","GPUTextureUsage","RENDER_ATTACHMENT","mipTextureDescriptor","size","width","Math","ceil","height","TEXTURE_BINDING","COPY_SRC","mipLevelCount","createTexture","commandEncoder","createCommandEncoder","bindGroupLayout","getBindGroupLayout","arrayLayer","srcView","createView","baseMipLevel","baseArrayLayer","dstMipLevel","i","dstView","passEncoder","beginRenderPass","colorAttachments","view","storeOp","loadOp","clearValue","r","g","b","a","bindGroup","createBindGroup","entries","binding","resource","setPipeline","setBindGroup","draw","end","mipLevelSize","copyTextureToTexture","mipLevel","queue","submit","finish","destroy"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.ts"],"sourcesContent":["/**\n * A class which generates mipmaps for a GPUTexture.\n * Thanks to @toji for the original implementation\n * https://github.com/toji/web-texture-tool/blob/main/src/webgpu-mipmap-generator.js\n * @memberof rendering\n * @ignore\n */\nexport class GpuMipmapGenerator\n{\n    public device: GPUDevice;\n    public sampler: GPUSampler;\n    public pipelines: Record<string, GPURenderPipeline>;\n\n    public mipmapShaderModule: any;\n\n    constructor(device: GPUDevice)\n    {\n        this.device = device;\n        this.sampler = device.createSampler({ minFilter: 'linear' });\n        // We'll need a new pipeline for every texture format used.\n        this.pipelines = {};\n    }\n\n    private _getMipmapPipeline(format: GPUTextureFormat)\n    {\n        let pipeline = this.pipelines[format];\n\n        if (!pipeline)\n        {\n            // Shader modules is shared between all pipelines, so only create once.\n            if (!this.mipmapShaderModule)\n            {\n                this.mipmapShaderModule = this.device.createShaderModule({\n                    code: /* wgsl */ `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `,\n                });\n            }\n\n            pipeline = this.device.createRenderPipeline({\n                layout: 'auto',\n                vertex: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'vertexMain',\n                },\n                fragment: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'fragmentMain',\n                    targets: [{ format }],\n                }\n            });\n\n            this.pipelines[format] = pipeline;\n        }\n\n        return pipeline;\n    }\n\n    /**\n     * Generates mipmaps for the given GPUTexture from the data in level 0.\n     * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n     * @returns {module:External.GPUTexture} - The originally passed texture\n     */\n    public generateMipmap(texture: GPUTexture)\n    {\n        const pipeline = this._getMipmapPipeline(texture.format);\n\n        if (texture.dimension === '3d' || texture.dimension === '1d')\n        {\n            throw new Error('Generating mipmaps for non-2d textures is currently unsupported!');\n        }\n\n        let mipTexture = texture;\n        const arrayLayerCount = texture.depthOrArrayLayers || 1; // Only valid for 2D textures.\n\n        // If the texture was created with RENDER_ATTACHMENT usage we can render directly between mip levels.\n        const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n\n        if (!renderToSource)\n        {\n            // Otherwise we have to use a separate texture to render into. It can be one mip level smaller than the source\n            // texture, since we already have the top level.\n            const mipTextureDescriptor = {\n                size: {\n                    width: Math.ceil(texture.width / 2),\n                    height: Math.ceil(texture.height / 2),\n                    depthOrArrayLayers: arrayLayerCount,\n                },\n                format: texture.format,\n                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n                mipLevelCount: texture.mipLevelCount - 1,\n            };\n\n            mipTexture = this.device.createTexture(mipTextureDescriptor);\n        }\n\n        const commandEncoder = this.device.createCommandEncoder({});\n        // TODO: Consider making this static.\n        const bindGroupLayout = pipeline.getBindGroupLayout(0);\n\n        for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer)\n        {\n            let srcView = texture.createView({\n                baseMipLevel: 0,\n                mipLevelCount: 1,\n                dimension: '2d',\n                baseArrayLayer: arrayLayer,\n                arrayLayerCount: 1,\n            });\n\n            let dstMipLevel = renderToSource ? 1 : 0;\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                const dstView = mipTexture.createView({\n                    baseMipLevel: dstMipLevel++,\n                    mipLevelCount: 1,\n                    dimension: '2d',\n                    baseArrayLayer: arrayLayer,\n                    arrayLayerCount: 1,\n                });\n\n                const passEncoder = commandEncoder.beginRenderPass({\n                    colorAttachments: [{\n                        view: dstView,\n                        storeOp: 'store',\n                        loadOp: 'clear',\n                        clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                    }],\n                });\n\n                const bindGroup = this.device.createBindGroup({\n                    layout: bindGroupLayout,\n                    entries: [{\n                        binding: 0,\n                        resource: this.sampler,\n                    }, {\n                        binding: 1,\n                        resource: srcView,\n                    }],\n                });\n\n                passEncoder.setPipeline(pipeline);\n                passEncoder.setBindGroup(0, bindGroup);\n                passEncoder.draw(3, 1, 0, 0);\n\n                passEncoder.end();\n\n                srcView = dstView;\n            }\n        }\n\n        // If we didn't render to the source texture, finish by copying the mip results from the temporary mipmap texture\n        // to the source.\n        if (!renderToSource)\n        {\n            const mipLevelSize = {\n                width: Math.ceil(texture.width / 2),\n                height: Math.ceil(texture.height / 2),\n                depthOrArrayLayers: arrayLayerCount,\n            };\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                commandEncoder.copyTextureToTexture({\n                    texture: mipTexture,\n                    mipLevel: i - 1,\n                }, {\n                    texture,\n                    mipLevel: i,\n                }, mipLevelSize);\n\n                mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n                mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n            }\n        }\n\n        this.device.queue.submit([commandEncoder.finish()]);\n\n        if (!renderToSource)\n        {\n            mipTexture.destroy();\n        }\n\n        return texture;\n    }\n}\n"],"mappings":";;AAOO,MAAMA,kBACb;EAOIC,YAAYC,MACZ;IACI,KAAKA,MAAS,GAAAA,MAAA;IACd,KAAKC,OAAA,GAAUD,MAAO,CAAAE,aAAA,CAAc;MAAEC,SAAA,EAAW;IAAA,CAAU;IAE3D,KAAKC,SAAA,GAAY,EAAC;EAAA;EAGdC,mBAAmBC,MAC3B;IACQ,IAAAC,QAAA,GAAW,IAAK,CAAAH,SAAA,CAAUE,MAAM;IAEpC,IAAI,CAACC,QACL;MAEQ,KAAC,KAAKC,kBACV;QACS,KAAAA,kBAAA,GAAqB,IAAK,CAAAR,MAAA,CAAOS,kBAAmB;UACrDC,IAAA;UAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;QAAA,CAyBpB;MAAA;MAGMH,QAAA,QAAKP,MAAA,CAAOW,oBAAqB;QACxCC,MAAQ;QACRC,MAAQ;UACJC,MAAA,EAAQ,IAAK,CAAAN,kBAAA;UACbO,UAAY;QAAA,CAChB;QACAC,QAAU;UACNF,MAAA,EAAQ,IAAK,CAAAN,kBAAA;UACbO,UAAY;UACZE,OAAS,GAAC;YAAEX;UAAA,CAAQ;QAAA;MACxB,CACH;MAEI,KAAAF,SAAA,CAAUE,MAAM,CAAI,GAAAC,QAAA;IAAA;IAGtB,OAAAA,QAAA;EAAA;EACX;AAAA;AAAA;AAAA;AAAA;EAOOW,eAAeC,OACtB;IACI,MAAMZ,QAAW,QAAKF,kBAAmB,CAAAc,OAAA,CAAQb,MAAM;IAEvD,IAAIa,OAAQ,CAAAC,SAAA,KAAc,IAAQ,IAAAD,OAAA,CAAQC,SAAA,KAAc,IACxD;MACU,UAAIC,KAAA,CAAM,kEAAkE;IAAA;IAGtF,IAAIC,UAAa,GAAAH,OAAA;IACX,MAAAI,eAAA,GAAkBJ,OAAA,CAAQK,kBAAsB;IAGhD,MAAAC,cAAA,GAAiBN,OAAQ,CAAAO,KAAA,GAAQC,eAAgB,CAAAC,iBAAA;IAEvD,IAAI,CAACH,cACL;MAGI,MAAMI,oBAAuB;QACzBC,IAAM;UACFC,KAAO,EAAAC,IAAA,CAAKC,IAAK,CAAAd,OAAA,CAAQY,KAAA,GAAQ,CAAC;UAClCG,MAAQ,EAAAF,IAAA,CAAKC,IAAK,CAAAd,OAAA,CAAQe,MAAA,GAAS,CAAC;UACpCV,kBAAoB,EAAAD;QAAA,CACxB;QACAjB,MAAA,EAAQa,OAAQ,CAAAb,MAAA;QAChBoB,KAAO,EAAAC,eAAA,CAAgBQ,eAAkB,GAAAR,eAAA,CAAgBS,QAAA,GAAWT,eAAgB,CAAAC,iBAAA;QACpFS,aAAA,EAAelB,OAAA,CAAQkB,aAAgB;MAAA,CAC3C;MAEaf,UAAA,QAAKtB,MAAO,CAAAsC,aAAA,CAAcT,oBAAoB;IAAA;IAG/D,MAAMU,cAAiB,QAAKvC,MAAO,CAAAwC,oBAAA,CAAqB,EAAE;IAEpD,MAAAC,eAAA,GAAkBlC,QAAS,CAAAmC,kBAAA,CAAmB,CAAC;IAErD,SAASC,UAAa,MAAGA,UAAa,GAAApB,eAAA,EAAiB,EAAEoB,UACzD;MACQ,IAAAC,OAAA,GAAUzB,OAAA,CAAQ0B,UAAW;QAC7BC,YAAc;QACdT,aAAe;QACfjB,SAAW;QACX2B,cAAgB,EAAAJ,UAAA;QAChBpB,eAAiB;MAAA,CACpB;MAEG,IAAAyB,WAAA,GAAcvB,cAAA,GAAiB,CAAI;MAEvC,SAASwB,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAI9B,OAAQ,CAAAkB,aAAA,EAAe,EAAEY,CAC7C;QACU,MAAAC,OAAA,GAAU5B,UAAA,CAAWuB,UAAW;UAClCC,YAAc,EAAAE,WAAA;UACdX,aAAe;UACfjB,SAAW;UACX2B,cAAgB,EAAAJ,UAAA;UAChBpB,eAAiB;QAAA,CACpB;QAEK,MAAA4B,WAAA,GAAcZ,cAAA,CAAea,eAAgB;UAC/CC,gBAAA,EAAkB,CAAC;YACfC,IAAM,EAAAJ,OAAA;YACNK,OAAS;YACTC,MAAQ;YACRC,UAAA,EAAY;cAAEC,CAAG;cAAGC,CAAA,EAAG,CAAG;cAAAC,CAAA,EAAG,CAAG;cAAAC,CAAA,EAAG;YAAE;UAAA,CACxC;QAAA,CACJ;QAEK,MAAAC,SAAA,GAAY,IAAK,CAAA9D,MAAA,CAAO+D,eAAgB;UAC1CnD,MAAQ,EAAA6B,eAAA;UACRuB,OAAA,EAAS,CAAC;YACNC,OAAS;YACTC,QAAA,EAAU,IAAK,CAAAjE;UAAA,CAChB;YACCgE,OAAS;YACTC,QAAU,EAAAtB;UAAA,CACb;QAAA,CACJ;QAEDO,WAAA,CAAYgB,WAAA,CAAY5D,QAAQ;QACpB4C,WAAA,CAAAiB,YAAA,CAAa,GAAGN,SAAS;QACrCX,WAAA,CAAYkB,IAAK,IAAG,CAAG,KAAG,CAAC;QAE3BlB,WAAA,CAAYmB,GAAI;QAEN1B,OAAA,GAAAM,OAAA;MAAA;IACd;IAKJ,IAAI,CAACzB,cACL;MACI,MAAM8C,YAAe;QACjBxC,KAAO,EAAAC,IAAA,CAAKC,IAAK,CAAAd,OAAA,CAAQY,KAAA,GAAQ,CAAC;QAClCG,MAAQ,EAAAF,IAAA,CAAKC,IAAK,CAAAd,OAAA,CAAQe,MAAA,GAAS,CAAC;QACpCV,kBAAoB,EAAAD;MAAA,CACxB;MAEA,SAAS0B,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAI9B,OAAQ,CAAAkB,aAAA,EAAe,EAAEY,CAC7C;QACIV,cAAA,CAAeiC,oBAAqB;UAChCrD,OAAS,EAAAG,UAAA;UACTmD,QAAA,EAAUxB,CAAI;QAAA,CACf;UACC9B,OAAA;UACAsD,QAAU,EAAAxB;QAAA,GACXsB,YAAY;QAEfA,YAAA,CAAaxC,KAAQ,GAAAC,IAAA,CAAKC,IAAK,CAAAsC,YAAA,CAAaxC,KAAA,GAAQ,CAAC;QACrDwC,YAAA,CAAarC,MAAS,GAAAF,IAAA,CAAKC,IAAK,CAAAsC,YAAA,CAAarC,MAAA,GAAS,CAAC;MAAA;IAC3D;IAGJ,KAAKlC,MAAA,CAAO0E,KAAM,CAAAC,MAAA,CAAO,CAACpC,cAAe,CAAAqC,MAAA,EAAQ,CAAC;IAElD,IAAI,CAACnD,cACL;MACIH,UAAA,CAAWuD,OAAQ;IAAA;IAGhB,OAAA1D,OAAA;EAAA;AAEf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}