{"ast":null,"code":"\"use strict\";\n\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isNumber = exports.isInt = exports.isUInt = exports.bigintPower = exports.isBigInt = void 0;\nconst utils_js_1 = require(\"../utils.js\");\nconst string_js_1 = require(\"./string.js\");\n/**\n * Checks if a given value is a valid big int\n */\nconst isBigInt = value => typeof value === 'bigint';\nexports.isBigInt = isBigInt;\n// Note: this could be simplified using ** operator, but babel does not handle it well\n// \tyou can find more at: https://github.com/babel/babel/issues/13109 and https://github.com/web3/web3.js/issues/6187\n/** @internal */\nconst bigintPower = (base, expo) => {\n  let res = base;\n  for (let index = 1; index < expo; index += 1) {\n    res *= base;\n  }\n  return res;\n};\nexports.bigintPower = bigintPower;\nconst isUInt = function (value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    abiType: 'uint'\n  };\n  if (!['number', 'string', 'bigint'].includes(typeof value) || typeof value === 'string' && value.length === 0) {\n    return false;\n  }\n  let size;\n  if (options === null || options === void 0 ? void 0 : options.abiType) {\n    const {\n      baseTypeSize\n    } = (0, utils_js_1.parseBaseType)(options.abiType);\n    if (baseTypeSize) {\n      size = baseTypeSize;\n    }\n  } else if (options.bitSize) {\n    size = options.bitSize;\n  }\n  const maxSize = (0, exports.bigintPower)(BigInt(2), BigInt(size !== null && size !== void 0 ? size : 256)) - BigInt(1);\n  try {\n    const valueToCheck = typeof value === 'string' && (0, string_js_1.isHexStrict)(value) ? BigInt((0, utils_js_1.hexToNumber)(value)) : BigInt(value);\n    return valueToCheck >= 0 && valueToCheck <= maxSize;\n  } catch (error) {\n    // Some invalid number value given which can not be converted via BigInt\n    return false;\n  }\n};\nexports.isUInt = isUInt;\nconst isInt = function (value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    abiType: 'int'\n  };\n  if (!['number', 'string', 'bigint'].includes(typeof value)) {\n    return false;\n  }\n  if (typeof value === 'number' && value > Number.MAX_SAFE_INTEGER) {\n    return false;\n  }\n  let size;\n  if (options === null || options === void 0 ? void 0 : options.abiType) {\n    const {\n      baseTypeSize,\n      baseType\n    } = (0, utils_js_1.parseBaseType)(options.abiType);\n    if (baseType !== 'int') {\n      return false;\n    }\n    if (baseTypeSize) {\n      size = baseTypeSize;\n    }\n  } else if (options.bitSize) {\n    size = options.bitSize;\n  }\n  const maxSize = (0, exports.bigintPower)(BigInt(2), BigInt((size !== null && size !== void 0 ? size : 256) - 1));\n  const minSize = BigInt(-1) * (0, exports.bigintPower)(BigInt(2), BigInt((size !== null && size !== void 0 ? size : 256) - 1));\n  try {\n    const valueToCheck = typeof value === 'string' && (0, string_js_1.isHexStrict)(value) ? BigInt((0, utils_js_1.hexToNumber)(value)) : BigInt(value);\n    return valueToCheck >= minSize && valueToCheck <= maxSize;\n  } catch (error) {\n    // Some invalid number value given which can not be converted via BigInt\n    return false;\n  }\n};\nexports.isInt = isInt;\nconst isNumber = value => {\n  if ((0, exports.isInt)(value)) {\n    return true;\n  }\n  // It would be a decimal number\n  if (typeof value === 'string' && /[0-9.]/.test(value) && value.indexOf('.') === value.lastIndexOf('.')) {\n    return true;\n  }\n  if (typeof value === 'number') {\n    return true;\n  }\n  return false;\n};\nexports.isNumber = isNumber;","map":{"version":3,"names":["utils_js_1","require","string_js_1","isBigInt","value","exports","bigintPower","base","expo","res","index","isUInt","options","arguments","length","undefined","abiType","includes","size","baseTypeSize","parseBaseType","bitSize","maxSize","BigInt","valueToCheck","isHexStrict","hexToNumber","error","isInt","Number","MAX_SAFE_INTEGER","baseType","minSize","isNumber","test","indexOf","lastIndexOf"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/web3-validator/src/validation/numbers.ts"],"sourcesContent":["ï»¿/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { ValidInputTypes } from '../types.js';\nimport { parseBaseType, hexToNumber } from '../utils.js';\nimport { isHexStrict } from './string.js';\n\n/**\n * Checks if a given value is a valid big int\n */\nexport const isBigInt = (value: ValidInputTypes): boolean => typeof value === 'bigint';\n\n// Note: this could be simplified using ** operator, but babel does not handle it well\n// \tyou can find more at: https://github.com/babel/babel/issues/13109 and https://github.com/web3/web3.js/issues/6187\n/** @internal */\nexport const bigintPower = (base: bigint, expo: bigint) => {\n\tlet res = base;\n\tfor (let index = 1; index < expo; index += 1) {\n\t\tres *= base;\n\t}\n\treturn res;\n};\n\nexport const isUInt = (\n\tvalue: ValidInputTypes,\n\toptions: { abiType: string; bitSize?: never } | { bitSize: number; abiType?: never } = {\n\t\tabiType: 'uint',\n\t},\n) => {\n\tif (\n\t\t!['number', 'string', 'bigint'].includes(typeof value) ||\n\t\t(typeof value === 'string' && value.length === 0)\n\t) {\n\t\treturn false;\n\t}\n\n\tlet size!: number;\n\n\tif (options?.abiType) {\n\t\tconst { baseTypeSize } = parseBaseType(options.abiType);\n\n\t\tif (baseTypeSize) {\n\t\t\tsize = baseTypeSize;\n\t\t}\n\t} else if (options.bitSize) {\n\t\tsize = options.bitSize;\n\t}\n\n\tconst maxSize = bigintPower(BigInt(2), BigInt(size ?? 256)) - BigInt(1);\n\n\ttry {\n\t\tconst valueToCheck =\n\t\t\ttypeof value === 'string' && isHexStrict(value)\n\t\t\t\t? BigInt(hexToNumber(value))\n\t\t\t\t: BigInt(value as number);\n\n\t\treturn valueToCheck >= 0 && valueToCheck <= maxSize;\n\t} catch (error) {\n\t\t// Some invalid number value given which can not be converted via BigInt\n\t\treturn false;\n\t}\n};\n\nexport const isInt = (\n\tvalue: ValidInputTypes,\n\toptions: { abiType: string; bitSize?: never } | { bitSize: number; abiType?: never } = {\n\t\tabiType: 'int',\n\t},\n) => {\n\tif (!['number', 'string', 'bigint'].includes(typeof value)) {\n\t\treturn false;\n\t}\n\n\tif (typeof value === 'number' && value > Number.MAX_SAFE_INTEGER) {\n\t\treturn false;\n\t}\n\n\tlet size!: number;\n\n\tif (options?.abiType) {\n\t\tconst { baseTypeSize, baseType } = parseBaseType(options.abiType);\n\n\t\tif (baseType !== 'int') {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (baseTypeSize) {\n\t\t\tsize = baseTypeSize;\n\t\t}\n\t} else if (options.bitSize) {\n\t\tsize = options.bitSize;\n\t}\n\n\tconst maxSize = bigintPower(BigInt(2), BigInt((size ?? 256) - 1));\n\tconst minSize = BigInt(-1) * bigintPower(BigInt(2), BigInt((size ?? 256) - 1));\n\n\ttry {\n\t\tconst valueToCheck =\n\t\t\ttypeof value === 'string' && isHexStrict(value)\n\t\t\t\t? BigInt(hexToNumber(value))\n\t\t\t\t: BigInt(value as number);\n\n\t\treturn valueToCheck >= minSize && valueToCheck <= maxSize;\n\t} catch (error) {\n\t\t// Some invalid number value given which can not be converted via BigInt\n\t\treturn false;\n\t}\n};\n\nexport const isNumber = (value: ValidInputTypes) => {\n\tif (isInt(value)) {\n\t\treturn true;\n\t}\n\n\t// It would be a decimal number\n\tif (\n\t\ttypeof value === 'string' &&\n\t\t/[0-9.]/.test(value) &&\n\t\tvalue.indexOf('.') === value.lastIndexOf('.')\n\t) {\n\t\treturn true;\n\t}\n\n\tif (typeof value === 'number') {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}