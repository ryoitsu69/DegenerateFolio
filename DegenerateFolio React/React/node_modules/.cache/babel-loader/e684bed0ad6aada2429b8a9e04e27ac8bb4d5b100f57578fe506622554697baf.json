{"ast":null,"code":"import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { getSupportedCompressedTextureFormats } from '../../rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.mjs';\nimport { isWebGLSupported } from '../../utils/browser/isWebGLSupported.mjs';\nimport { isWebGPUSupported } from '../../utils/browser/isWebGPUSupported.mjs';\nimport { validFormats } from './resolveCompressedTextureUrl.mjs';\n\"use strict\";\nlet compressedTextureExtensions;\nconst detectCompressed = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 2\n  },\n  test: async () => {\n    if (await isWebGPUSupported()) return true;\n    if (isWebGLSupported()) return true;\n    return false;\n  },\n  add: async formats => {\n    const supportedCompressedTextureFormats = await getSupportedCompressedTextureFormats();\n    compressedTextureExtensions = extractExtensionsForCompressedTextureFormats(supportedCompressedTextureFormats);\n    return [...compressedTextureExtensions, ...formats];\n  },\n  remove: async formats => {\n    if (compressedTextureExtensions) {\n      return formats.filter(f => !(f in compressedTextureExtensions));\n    }\n    return formats;\n  }\n};\nfunction extractExtensionsForCompressedTextureFormats(formats) {\n  const extensions = [\"basis\"];\n  const dupeMap = {};\n  formats.forEach(format => {\n    const extension = format.split(\"-\")[0];\n    if (extension && !dupeMap[extension]) {\n      dupeMap[extension] = true;\n      extensions.push(extension);\n    }\n  });\n  extensions.sort((a, b) => {\n    const aIndex = validFormats.indexOf(a);\n    const bIndex = validFormats.indexOf(b);\n    if (aIndex === -1) {\n      return 1;\n    }\n    if (bIndex === -1) {\n      return -1;\n    }\n    return aIndex - bIndex;\n  });\n  return extensions;\n}\nexport { detectCompressed };","map":{"version":3,"names":["compressedTextureExtensions","detectCompressed","extension","type","ExtensionType","DetectionParser","priority","test","isWebGPUSupported","isWebGLSupported","add","formats","supportedCompressedTextureFormats","getSupportedCompressedTextureFormats","extractExtensionsForCompressedTextureFormats","remove","filter","f","extensions","dupeMap","forEach","format","split","push","sort","a","b","aIndex","validFormats","indexOf","bIndex"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/compressed-textures/shared/detectCompressed.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\n// eslint-disable-next-line max-len\nimport { getSupportedCompressedTextureFormats } from '../../rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats';\nimport { isWebGLSupported } from '../../utils/browser/isWebGLSupported';\nimport { isWebGPUSupported } from '../../utils/browser/isWebGPUSupported';\nimport { validFormats } from './resolveCompressedTextureUrl';\n\nimport type { FormatDetectionParser } from '../../assets/detections/types';\nimport type { TEXTURE_FORMATS } from '../../rendering/renderers/shared/texture/const';\n\nlet compressedTextureExtensions: string[];\n\nexport const detectCompressed = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 2,\n    },\n    test: async (): Promise<boolean> =>\n    {\n        if (await isWebGPUSupported()) return true;\n        if (isWebGLSupported()) return true;\n\n        return false;\n    },\n    add: async (formats: string[]): Promise<string[]> =>\n    {\n        const supportedCompressedTextureFormats = await getSupportedCompressedTextureFormats();\n\n        compressedTextureExtensions = extractExtensionsForCompressedTextureFormats(supportedCompressedTextureFormats);\n\n        return [...compressedTextureExtensions, ...formats];\n    },\n    remove: async (formats: string[]): Promise<string[]> =>\n    {\n        if (compressedTextureExtensions)\n        {\n            return formats.filter((f) => !(f in compressedTextureExtensions));\n        }\n\n        return formats;\n    },\n} as FormatDetectionParser;\n\nfunction extractExtensionsForCompressedTextureFormats(formats: TEXTURE_FORMATS[]): string[]\n{\n    const extensions: string[] = ['basis'];\n\n    const dupeMap: Record<string, boolean> = {};\n\n    formats.forEach((format) =>\n    {\n        const extension = format.split('-')[0];\n\n        if (extension && !dupeMap[extension])\n        {\n            dupeMap[extension] = true;\n            extensions.push(extension);\n        }\n    });\n\n    // sort extensions by priority\n    extensions.sort((a, b) =>\n    {\n        const aIndex = validFormats.indexOf(a);\n        const bIndex = validFormats.indexOf(b);\n\n        if (aIndex === -1)\n        {\n            return 1;\n        }\n        if (bIndex === -1)\n        {\n            return -1;\n        }\n\n        return aIndex - bIndex;\n    });\n\n    return extensions;\n}\n"],"mappings":";;;;;;AAUA,IAAIA,2BAAA;AAEG,MAAMC,gBAAmB;EAC5BC,SAAW;IACPC,IAAA,EAAMC,aAAc,CAAAC,eAAA;IACpBC,QAAU;EAAA,CACd;EACAC,IAAA,EAAM,MAAAA,CAAA,KACN;IACI,IAAI,MAAMC,iBAAkB,IAAU;IACtC,IAAIC,gBAAiB,IAAU;IAExB;EAAA,CACX;EACAC,GAAA,EAAK,MAAOC,OACZ;IACU,MAAAC,iCAAA,GAAoC,MAAMC,oCAAqC;IAErFb,2BAAA,GAA8Bc,4CAAA,CAA6CF,iCAAiC;IAE5G,OAAO,CAAC,GAAGZ,2BAA6B,KAAGW,OAAO;EAAA,CACtD;EACAI,MAAA,EAAQ,MAAOJ,OACf;IACI,IAAIX,2BACJ;MACI,OAAOW,OAAA,CAAQK,MAAO,CAACC,CAAM,MAAEA,CAAA,IAAKjB,2BAA4B;IAAA;IAG7D,OAAAW,OAAA;EAAA;AAEf;AAEA,SAASG,6CAA6CH,OACtD;EACU,MAAAO,UAAA,GAAuB,CAAC,OAAO;EAErC,MAAMC,OAAA,GAAmC,EAAC;EAElCR,OAAA,CAAAS,OAAA,CAASC,MACjB;IACI,MAAMnB,SAAY,GAAAmB,MAAA,CAAOC,KAAM,IAAG,EAAE,CAAC;IAErC,IAAIpB,SAAa,KAACiB,OAAQ,CAAAjB,SAAS,CACnC;MACIiB,OAAA,CAAQjB,SAAS,CAAI;MACrBgB,UAAA,CAAWK,IAAA,CAAKrB,SAAS;IAAA;EAC7B,CACH;EAGUgB,UAAA,CAAAM,IAAA,CAAK,CAACC,CAAA,EAAGC,CACpB;IACU,MAAAC,MAAA,GAASC,YAAa,CAAAC,OAAA,CAAQJ,CAAC;IAC/B,MAAAK,MAAA,GAASF,YAAa,CAAAC,OAAA,CAAQH,CAAC;IAErC,IAAIC,MAAA,KAAW,CACf;MACW;IAAA;IAEX,IAAIG,MAAA,KAAW,CACf;MACW;IAAA;IAGX,OAAOH,MAAS,GAAAG,MAAA;EAAA,CACnB;EAEM,OAAAZ,UAAA;AACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}