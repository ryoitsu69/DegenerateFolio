{"ast":null,"code":"import { buildUvs, buildSimpleUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs.mjs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices.mjs';\nimport { MeshGeometry } from '../../../mesh/shared/MeshGeometry.mjs';\nimport { buildCircle } from '../buildCommands/buildCircle.mjs';\nimport { buildPolygon } from '../buildCommands/buildPolygon.mjs';\nimport { buildRectangle } from '../buildCommands/buildRectangle.mjs';\nimport { buildTriangle } from '../buildCommands/buildTriangle.mjs';\nimport { GraphicsPath } from '../path/GraphicsPath.mjs';\n\"use strict\";\nconst buildMap = {\n  rectangle: buildRectangle,\n  polygon: buildPolygon,\n  triangle: buildTriangle,\n  circle: buildCircle,\n  ellipse: buildCircle,\n  roundedRectangle: buildCircle\n};\nfunction buildGeometryFromPath(options) {\n  if (options instanceof GraphicsPath) {\n    options = {\n      path: options,\n      textureMatrix: null,\n      out: null\n    };\n  }\n  const vertices = [];\n  const uvs = [];\n  const indices = [];\n  const shapePath = options.path.shapePath;\n  const textureMatrix = options.textureMatrix;\n  shapePath.shapePrimitives.forEach(({\n    shape,\n    transform: matrix\n  }) => {\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    const points = [];\n    const build = buildMap[shape.type];\n    build.build(shape, points);\n    if (matrix) {\n      transformVertices(points, matrix);\n    }\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n    const uvsOffset = uvs.length / 2;\n    if (textureMatrix) {\n      if (matrix) {\n        textureMatrix.append(matrix.clone().invert());\n      }\n      buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n    } else {\n      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n    }\n  });\n  const out = options.out;\n  if (out) {\n    out.positions = new Float32Array(vertices);\n    out.uvs = new Float32Array(uvs);\n    out.indices = new Uint32Array(indices);\n    return out;\n  }\n  const geometry = new MeshGeometry({\n    positions: new Float32Array(vertices),\n    uvs: new Float32Array(uvs),\n    indices: new Uint32Array(indices)\n  });\n  return geometry;\n}\nexport { buildGeometryFromPath };","map":{"version":3,"names":["buildMap","rectangle","buildRectangle","polygon","buildPolygon","triangle","buildTriangle","circle","buildCircle","ellipse","roundedRectangle","buildGeometryFromPath","options","GraphicsPath","path","textureMatrix","out","vertices","uvs","indices","shapePath","shapePrimitives","forEach","shape","transform","matrix","indexOffset","length","vertOffset","points","build","type","transformVertices","triangulate","uvsOffset","append","clone","invert","buildUvs","buildSimpleUvs","positions","Float32Array","Uint32Array","geometry","MeshGeometry"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/graphics/shared/utils/buildGeometryFromPath.ts"],"sourcesContent":["import { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { MeshGeometry } from '../../../mesh/shared/MeshGeometry';\nimport { buildCircle } from '../buildCommands/buildCircle';\nimport { buildPolygon } from '../buildCommands/buildPolygon';\nimport { buildRectangle } from '../buildCommands/buildRectangle';\nimport { buildTriangle } from '../buildCommands/buildTriangle';\nimport { GraphicsPath } from '../path/GraphicsPath';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { ShapeBuildCommand } from '../buildCommands/ShapeBuildCommand';\n\nconst buildMap: Record<string, ShapeBuildCommand> = {\n    rectangle: buildRectangle,\n    polygon: buildPolygon,\n    triangle: buildTriangle,\n    circle: buildCircle,\n    ellipse: buildCircle,\n    roundedRectangle: buildCircle,\n};\n\nexport interface GeometryPathOptions\n{\n    /** the path to build the geometry from */\n    path: GraphicsPath\n    /** a `Matrix` that can be used to modify the the texture UVs of the the path being built */\n    textureMatrix?: Matrix\n    /** an optional `MeshGeometry` to write too instead of creating a new one*/\n    out?: MeshGeometry\n}\n\n/**\n * When building a mesh, it helps to leverage the simple API we have in `GraphicsPath` as it can often be easier to\n * to define the geometry in a more human readable way. This function takes a `GraphicsPath` and returns a `MeshGeometry`.\n * @example\n * ```ts\n *\n * const path = new GraphicsPath()\n *    .drawRect(0, 0, 100, 100)\n *\n * const geometry:MeshGeometry = buildGeometryFromPath(path);\n *\n * const mesh = new Mesh({geometry});\n *\n * ```\n * You can also pass in a Matrix to transform the uvs as by defualt you may want to control how they are set up.\n * @param options - either a `GraphicsPath` or `GeometryPathOptions`\n * @returns a new `MeshGeometry` instance build from the path\n */\nexport function buildGeometryFromPath(options: GraphicsPath | GeometryPathOptions): MeshGeometry\n{\n    if (options instanceof GraphicsPath)\n    {\n        options = {\n            path: options,\n            textureMatrix: null,\n            out: null,\n        };\n    }\n\n    const vertices: number[] = [];\n    const uvs: number[] = [];\n    const indices: number[] = [];\n\n    // build path collection of polygons and shapes points..\n    const shapePath = options.path.shapePath;\n    const textureMatrix = options.textureMatrix;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }) =>\n    {\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n\n        const points: number[] = [];\n\n        const build = buildMap[shape.type];\n\n        build.build(shape, points);\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n        const uvsOffset = uvs.length / 2;\n\n        if (textureMatrix)\n        {\n            // todo can prolly do this before calculating uvs..\n            if (matrix)\n            {\n                textureMatrix.append(matrix.clone().invert());\n            }\n\n            buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n    });\n\n    const out = options.out;\n\n    if (out)\n    {\n        out.positions = new Float32Array(vertices);\n        out.uvs = new Float32Array(uvs);\n        out.indices = new Uint32Array(indices);\n\n        return out;\n    }\n\n    const geometry = new MeshGeometry({\n        positions: new Float32Array(vertices),\n        uvs: new Float32Array(uvs),\n        indices: new Uint32Array(indices),\n    });\n\n    return geometry;\n}\n"],"mappings":";;;;;;;;;AAYA,MAAMA,QAA8C;EAChDC,SAAW,EAAAC,cAAA;EACXC,OAAS,EAAAC,YAAA;EACTC,QAAU,EAAAC,aAAA;EACVC,MAAQ,EAAAC,WAAA;EACRC,OAAS,EAAAD,WAAA;EACTE,gBAAkB,EAAAF;AACtB;AA8BO,SAASG,sBAAsBC,OACtC;EACI,IAAIA,OAAA,YAAmBC,YACvB;IACcD,OAAA;MACNE,IAAM,EAAAF,OAAA;MACNG,aAAe;MACfC,GAAK;IAAA,CACT;EAAA;EAGJ,MAAMC,QAAA,GAAqB,EAAC;EAC5B,MAAMC,GAAA,GAAgB,EAAC;EACvB,MAAMC,OAAA,GAAoB,EAAC;EAGrB,MAAAC,SAAA,GAAYR,OAAA,CAAQE,IAAK,CAAAM,SAAA;EAC/B,MAAML,aAAA,GAAgBH,OAAQ,CAAAG,aAAA;EAE9BK,SAAA,CAAUC,eAAA,CAAgBC,OAAQ,EAAC;IAAEC,KAAO;IAAAC,SAAA,EAAWC;EAAA,CACvD;IACI,MAAMC,WAAA,GAAcP,OAAQ,CAAAQ,MAAA;IACtB,MAAAC,UAAA,GAAaX,QAAA,CAASU,MAAS;IAErC,MAAME,MAAA,GAAmB,EAAC;IAEpB,MAAAC,KAAA,GAAQ9B,QAAS,CAAAuB,KAAA,CAAMQ,IAAI;IAE3BD,KAAA,CAAAA,KAAA,CAAMP,KAAA,EAAOM,MAAM;IAEzB,IAAIJ,MACJ;MACIO,iBAAA,CAAkBH,MAAA,EAAQJ,MAAM;IAAA;IAGpCK,KAAA,CAAMG,WAAA,CAAYJ,MAAQ,EAAAZ,QAAA,EAAU,CAAG,EAAAW,UAAA,EAAYT,OAAA,EAASO,WAAW;IAEjE,MAAAQ,SAAA,GAAYhB,GAAA,CAAIS,MAAS;IAE/B,IAAIZ,aACJ;MAEI,IAAIU,MACJ;QACIV,aAAA,CAAcoB,MAAO,CAAAV,MAAA,CAAOW,KAAM,GAAEC,MAAA,EAAQ;MAAA;MAGvCC,QAAA,CAAArB,QAAA,EAAU,CAAG,EAAAW,UAAA,EAAYV,GAAK,EAAAgB,SAAA,EAAW,GAAIjB,QAAS,CAAAU,MAAA,GAAS,CAAK,GAAAC,UAAA,EAAYb,aAAa;IAAA,CAG1G;MACIwB,cAAA,CAAerB,GAAA,EAAKgB,SAAW,KAAIjB,QAAS,CAAAU,MAAA,GAAS,IAAKC,UAAU;IAAA;EACxE,CACH;EAED,MAAMZ,GAAA,GAAMJ,OAAQ,CAAAI,GAAA;EAEpB,IAAIA,GACJ;IACQA,GAAA,CAAAwB,SAAA,GAAY,IAAIC,YAAA,CAAaxB,QAAQ;IACrCD,GAAA,CAAAE,GAAA,GAAM,IAAIuB,YAAA,CAAavB,GAAG;IAC1BF,GAAA,CAAAG,OAAA,GAAU,IAAIuB,WAAA,CAAYvB,OAAO;IAE9B,OAAAH,GAAA;EAAA;EAGL,MAAA2B,QAAA,GAAW,IAAIC,YAAa;IAC9BJ,SAAA,EAAW,IAAIC,YAAA,CAAaxB,QAAQ;IACpCC,GAAA,EAAK,IAAIuB,YAAA,CAAavB,GAAG;IACzBC,OAAA,EAAS,IAAIuB,WAAA,CAAYvB,OAAO;EAAA,CACnC;EAEM,OAAAwB,QAAA;AACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}