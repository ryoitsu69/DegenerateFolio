{"ast":null,"code":"\"use strict\";\n\nfunction roundedShapeArc(g, points, radius) {\n  const vecFrom = (p, pp) => {\n    const x = pp.x - p.x;\n    const y = pp.y - p.y;\n    const len = Math.sqrt(x * x + y * y);\n    const nx = x / len;\n    const ny = y / len;\n    return {\n      len,\n      nx,\n      ny\n    };\n  };\n  const sharpCorner = (i, p) => {\n    if (i === 0) {\n      g.moveTo(p.x, p.y);\n    } else {\n      g.lineTo(p.x, p.y);\n    }\n  };\n  let p1 = points[points.length - 1];\n  for (let i = 0; i < points.length; i++) {\n    const p2 = points[i % points.length];\n    const pRadius = p2.radius ?? radius;\n    if (pRadius <= 0) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    const p3 = points[(i + 1) % points.length];\n    const v1 = vecFrom(p2, p1);\n    const v2 = vecFrom(p2, p3);\n    if (v1.len < 1e-4 || v2.len < 1e-4) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n    let radDirection = 1;\n    let drawDirection = false;\n    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n      if (angle < 0) {\n        angle = Math.PI + angle;\n      } else {\n        angle = Math.PI - angle;\n        radDirection = -1;\n        drawDirection = true;\n      }\n    } else if (angle > 0) {\n      radDirection = -1;\n      drawDirection = true;\n    }\n    const halfAngle = angle / 2;\n    let cRadius;\n    let lenOut = Math.abs(Math.cos(halfAngle) * pRadius / Math.sin(halfAngle));\n    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n      lenOut = Math.min(v1.len / 2, v2.len / 2);\n      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    } else {\n      cRadius = pRadius;\n    }\n    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n    if (i === 0) {\n      g.moveTo(cX + Math.cos(startAngle) * cRadius, cY + Math.sin(startAngle) * cRadius);\n    }\n    g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n    p1 = p2;\n  }\n}\nfunction roundedShapeQuadraticCurve(g, points, radius, smoothness) {\n  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n  const pointLerp = (p1, p2, t) => ({\n    x: p1.x + (p2.x - p1.x) * t,\n    y: p1.y + (p2.y - p1.y) * t\n  });\n  const numPoints = points.length;\n  for (let i = 0; i < numPoints; i++) {\n    const thisPoint = points[(i + 1) % numPoints];\n    const pRadius = thisPoint.radius ?? radius;\n    if (pRadius <= 0) {\n      if (i === 0) {\n        g.moveTo(thisPoint.x, thisPoint.y);\n      } else {\n        g.lineTo(thisPoint.x, thisPoint.y);\n      }\n      continue;\n    }\n    const lastPoint = points[i];\n    const nextPoint = points[(i + 2) % numPoints];\n    const lastEdgeLength = distance(lastPoint, thisPoint);\n    let start;\n    if (lastEdgeLength < 1e-4) {\n      start = thisPoint;\n    } else {\n      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n      start = pointLerp(thisPoint, lastPoint, lastOffsetDistance / lastEdgeLength);\n    }\n    const nextEdgeLength = distance(nextPoint, thisPoint);\n    let end;\n    if (nextEdgeLength < 1e-4) {\n      end = thisPoint;\n    } else {\n      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n      end = pointLerp(thisPoint, nextPoint, nextOffsetDistance / nextEdgeLength);\n    }\n    if (i === 0) {\n      g.moveTo(start.x, start.y);\n    } else {\n      g.lineTo(start.x, start.y);\n    }\n    g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n  }\n}\nexport { roundedShapeArc, roundedShapeQuadraticCurve };","map":{"version":3,"names":["roundedShapeArc","g","points","radius","vecFrom","p","pp","x","y","len","Math","sqrt","nx","ny","sharpCorner","i","moveTo","lineTo","p1","length","p2","pRadius","p3","v1","v2","angle","asin","radDirection","drawDirection","PI","halfAngle","cRadius","lenOut","abs","cos","sin","min","cX","cY","startAngle","atan2","endAngle","arc","roundedShapeQuadraticCurve","smoothness","distance","pointLerp","t","numPoints","thisPoint","lastPoint","nextPoint","lastEdgeLength","start","lastOffsetDistance","nextEdgeLength","end","nextOffsetDistance","quadraticCurveTo"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/graphics/shared/path/roundShape.ts"],"sourcesContent":["import type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePath } from './ShapePath';\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/44856925#44856925\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeArc(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number\n): void\n{\n    const vecFrom = (p: PointData, pp: PointData) =>\n    {\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt((x * x) + (y * y));\n        const nx = x / len;\n        const ny = y / len;\n\n        return { len, nx, ny };\n    };\n\n    const sharpCorner = (i: number, p: PointData) =>\n    {\n        if (i === 0)\n        {\n            g.moveTo(p.x, p.y);\n        }\n        else\n        {\n            g.lineTo(p.x, p.y);\n        }\n    };\n\n    let p1 = points[points.length - 1];\n\n    for (let i = 0; i < points.length; i++)\n    {\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n\n        if (v1.len < 1e-4 || v2.len < 1e-4)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        let angle = Math.asin((v1.nx * v2.ny) - (v1.ny * v2.nx));\n        let radDirection = 1;\n        let drawDirection = false;\n\n        if ((v1.nx * v2.nx) - (v1.ny * -v2.ny) < 0)\n        {\n            if (angle < 0)\n            {\n                angle = Math.PI + angle;\n            }\n            else\n            {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        else if (angle > 0)\n        {\n            radDirection = -1;\n            drawDirection = true;\n        }\n\n        const halfAngle = angle / 2;\n\n        let cRadius: number;\n        let lenOut = Math.abs(\n            (Math.cos(halfAngle) * pRadius) / Math.sin(halfAngle)\n        );\n\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2))\n        {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        }\n        else\n        {\n            cRadius = pRadius;\n        }\n\n        const cX = p2.x + (v2.nx * lenOut) + (-v2.ny * cRadius * radDirection);\n        const cY = p2.y + (v2.ny * lenOut) + (v2.nx * cRadius * radDirection);\n        const startAngle = Math.atan2(v1.ny, v1.nx) + ((Math.PI / 2) * radDirection);\n        const endAngle = Math.atan2(v2.ny, v2.nx) - ((Math.PI / 2) * radDirection);\n\n        if (i === 0)\n        {\n            g.moveTo(\n                cX + (Math.cos(startAngle) * cRadius),\n                cY + (Math.sin(startAngle) * cRadius)\n            );\n        }\n\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n\n        p1 = p2;\n    }\n}\n\nexport type RoundedPoint = PointData & { radius?: number };\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/56214413#56214413\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeQuadraticCurve(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number,\n    smoothness?: number,\n): void\n{\n    const distance = (p1: PointData, p2: PointData) =>\n        Math.sqrt(((p1.x - p2.x) ** 2) + ((p1.y - p2.y) ** 2));\n\n    const pointLerp = (p1: PointData, p2: PointData, t: number) => ({\n        x: p1.x + ((p2.x - p1.x) * t),\n        y: p1.y + ((p2.y - p1.y) * t),\n    });\n\n    const numPoints = points.length;\n\n    for (let i = 0; i < numPoints; i++)\n    {\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            if (i === 0)\n            {\n                g.moveTo(thisPoint.x, thisPoint.y);\n            }\n            else\n            {\n                g.lineTo(thisPoint.x, thisPoint.y);\n            }\n\n            continue;\n        }\n\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n\n        if (lastEdgeLength < 1e-4)\n        {\n            start = thisPoint;\n        }\n        else\n        {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n\n            start = pointLerp(\n                thisPoint,\n                lastPoint,\n                lastOffsetDistance / lastEdgeLength\n            );\n        }\n\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n\n        if (nextEdgeLength < 1e-4)\n        {\n            end = thisPoint;\n        }\n        else\n        {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n\n            end = pointLerp(\n                thisPoint,\n                nextPoint,\n                nextOffsetDistance / nextEdgeLength\n            );\n        }\n\n        if (i === 0)\n        {\n            g.moveTo(start.x, start.y);\n        }\n        else\n        {\n            g.lineTo(start.x, start.y);\n        }\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}