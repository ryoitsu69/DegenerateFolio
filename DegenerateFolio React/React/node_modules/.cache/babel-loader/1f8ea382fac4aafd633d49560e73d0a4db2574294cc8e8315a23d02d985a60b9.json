{"ast":null,"code":"import { wrapModeToGlAddress, scaleModeToGlFilter, mipmapScaleModeToGlFilter, compareModeToGlCompare } from './pixiToGlMaps.mjs';\n\"use strict\";\nfunction applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam, forceClamp, firstCreation) {\n  const castParam = firstParam;\n  if (!firstCreation || style.addressModeU !== \"repeat\" || style.addressModeV !== \"repeat\" || style.addressModeW !== \"repeat\") {\n    const wrapModeS = wrapModeToGlAddress[forceClamp ? \"clamp-to-edge\" : style.addressModeU];\n    const wrapModeT = wrapModeToGlAddress[forceClamp ? \"clamp-to-edge\" : style.addressModeV];\n    const wrapModeR = wrapModeToGlAddress[forceClamp ? \"clamp-to-edge\" : style.addressModeW];\n    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);\n    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);\n    if (gl.TEXTURE_WRAP_R) gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);\n  }\n  if (!firstCreation || style.magFilter !== \"linear\") {\n    gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);\n  }\n  if (mipmaps) {\n    if (!firstCreation || style.mipmapFilter !== \"linear\") {\n      const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];\n      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);\n    }\n  } else {\n    gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);\n  }\n  if (anisotropicExt && style.maxAnisotropy > 1) {\n    const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n    gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n  }\n  if (style.compare) {\n    gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);\n  }\n}\nexport { applyStyleParams };","map":{"version":3,"names":["applyStyleParams","style","gl","mipmaps","anisotropicExt","glFunctionName","firstParam","forceClamp","firstCreation","castParam","addressModeU","addressModeV","addressModeW","wrapModeS","wrapModeToGlAddress","wrapModeT","wrapModeR","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TEXTURE_WRAP_R","magFilter","TEXTURE_MAG_FILTER","scaleModeToGlFilter","mipmapFilter","glFilterMode","mipmapScaleModeToGlFilter","minFilter","TEXTURE_MIN_FILTER","maxAnisotropy","level","Math","min","getParameter","MAX_TEXTURE_MAX_ANISOTROPY_EXT","TEXTURE_MAX_ANISOTROPY_EXT","compare","TEXTURE_COMPARE_FUNC","compareModeToGlCompare"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/applyStyleParams.ts"],"sourcesContent":["import {\n    compareModeToGlCompare,\n    mipmapScaleModeToGlFilter,\n    scaleModeToGlFilter,\n    wrapModeToGlAddress\n} from './pixiToGlMaps';\n\nimport type { TextureStyle } from '../../../shared/texture/TextureStyle';\n\nexport function applyStyleParams(\n    style: TextureStyle,\n    gl: WebGL2RenderingContext,\n    mipmaps: boolean,\n    // eslint-disable-next-line camelcase\n    anisotropicExt: EXT_texture_filter_anisotropic,\n    glFunctionName: 'samplerParameteri' | 'texParameteri',\n    firstParam: 3553 | WebGLSampler,\n    forceClamp: boolean,\n    /** if true we can skip setting certain values if the values is the same as the default gl values */\n    firstCreation: boolean\n)\n{\n    const castParam = firstParam as 3553;\n\n    if (!firstCreation\n        || style.addressModeU !== 'repeat'\n        || style.addressModeV !== 'repeat'\n        || style.addressModeW !== 'repeat'\n    )\n    {\n        // 1. set the wrapping mode\n        const wrapModeS = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeU];\n        const wrapModeT = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeV];\n        const wrapModeR = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeW];\n\n        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);\n        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);\n\n        // does not exist in webGL1\n        if (gl.TEXTURE_WRAP_R) gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);\n    }\n\n    if (!firstCreation || style.magFilter !== 'linear')\n    {\n        // 2. set the filtering mode\n        gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);\n    }\n\n    // assuming the currently bound texture is the one we want to set the filter for\n    // the only smelly part of this code, WebGPU is much better here :P\n    if (mipmaps)\n    {\n        if (!firstCreation || style.mipmapFilter !== 'linear')\n        {\n            const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];\n\n            gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);\n        }\n    }\n\n    else\n    {\n        gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);\n    }\n\n    // 3. set the anisotropy\n    if (anisotropicExt && style.maxAnisotropy > 1)\n    {\n        const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n\n        gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n    }\n\n    // 4. set the compare mode\n    if (style.compare)\n    {\n        gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);\n    }\n}\n"],"mappings":";;AASgB,SAAAA,iBACZC,KAAA,EACAC,EACA,EAAAC,OAAA,EAEAC,cAAA,EACAC,cACA,EAAAC,UAAA,EACAC,UAAA,EAEAC,aAEJ;EACI,MAAMC,SAAY,GAAAH,UAAA;EAEd,KAACE,aACE,IAAAP,KAAA,CAAMS,YAAiB,iBACvBT,KAAA,CAAMU,YAAiB,iBACvBV,KAAM,CAAAW,YAAA,KAAiB,QAE9B;IAEI,MAAMC,SAAY,GAAAC,mBAAA,CAAoBP,UAAa,qBAAkBN,KAAA,CAAMS,YAAY;IACvF,MAAMK,SAAY,GAAAD,mBAAA,CAAoBP,UAAa,qBAAkBN,KAAA,CAAMU,YAAY;IACvF,MAAMK,SAAY,GAAAF,mBAAA,CAAoBP,UAAa,qBAAkBN,KAAA,CAAMW,YAAY;IAEvFV,EAAA,CAAGG,cAAc,EAAEI,SAAW,EAAAP,EAAA,CAAGe,cAAA,EAAgBJ,SAAS;IAC1DX,EAAA,CAAGG,cAAc,EAAEI,SAAW,EAAAP,EAAA,CAAGgB,cAAA,EAAgBH,SAAS;IAG1D,IAAIb,EAAG,CAAAiB,cAAA,EAAgBjB,EAAA,CAAGG,cAAc,EAAEI,SAAW,EAAAP,EAAA,CAAGiB,cAAA,EAAgBH,SAAS;EAAA;EAGrF,IAAI,CAACR,aAAA,IAAiBP,KAAM,CAAAmB,SAAA,KAAc,QAC1C;IAEOlB,EAAA,CAAAG,cAAc,EAAEI,SAAW,EAAAP,EAAA,CAAGmB,kBAAA,EAAoBC,mBAAoB,CAAArB,KAAA,CAAMmB,SAAS,CAAC;EAAA;EAK7F,IAAIjB,OACJ;IACI,IAAI,CAACK,aAAA,IAAiBP,KAAM,CAAAsB,YAAA,KAAiB,QAC7C;MACI,MAAMC,YAAA,GAAeC,yBAA0B,CAAAxB,KAAA,CAAMyB,SAAS,EAAEzB,KAAA,CAAMsB,YAAY;MAElFrB,EAAA,CAAGG,cAAc,EAAEI,SAAW,EAAAP,EAAA,CAAGyB,kBAAA,EAAoBH,YAAY;IAAA;EACrE,CAIJ;IACOtB,EAAA,CAAAG,cAAc,EAAEI,SAAW,EAAAP,EAAA,CAAGyB,kBAAA,EAAoBL,mBAAoB,CAAArB,KAAA,CAAMyB,SAAS,CAAC;EAAA;EAIzF,IAAAtB,cAAA,IAAkBH,KAAM,CAAA2B,aAAA,GAAgB,CAC5C;IACU,MAAAC,KAAA,GAAQC,IAAA,CAAKC,GAAI,CAAA9B,KAAA,CAAM2B,aAAA,EAAe1B,EAAG,CAAA8B,YAAA,CAAa5B,cAAe,CAAA6B,8BAA8B,CAAC;IAE1G/B,EAAA,CAAGG,cAAc,EAAEI,SAAW,EAAAL,cAAA,CAAe8B,0BAAA,EAA4BL,KAAK;EAAA;EAIlF,IAAI5B,KAAA,CAAMkC,OACV;IACOjC,EAAA,CAAAG,cAAc,EAAEI,SAAW,EAAAP,EAAA,CAAGkC,oBAAA,EAAsBC,sBAAuB,CAAApC,KAAA,CAAMkC,OAAO,CAAC;EAAA;AAEpG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}