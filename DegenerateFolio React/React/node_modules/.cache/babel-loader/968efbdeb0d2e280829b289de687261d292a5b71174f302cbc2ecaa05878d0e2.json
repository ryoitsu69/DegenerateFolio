{"ast":null,"code":"import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Bounds } from '../bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../bounds/getGlobalBounds.mjs';\nimport { getLocalBounds } from '../bounds/getLocalBounds.mjs';\nimport { checkChildrenDidChange } from '../utils/checkChildrenDidChange.mjs';\n\"use strict\";\nconst tempMatrix = new Matrix();\nconst measureMixin = {\n  _localBoundsCacheId: -1,\n  _localBoundsCacheData: null,\n  _setWidth(value, localWidth) {\n    const sign = Math.sign(this.scale.x) || 1;\n    if (localWidth !== 0) {\n      this.scale.x = value / localWidth * sign;\n    } else {\n      this.scale.x = sign;\n    }\n  },\n  _setHeight(value, localHeight) {\n    const sign = Math.sign(this.scale.y) || 1;\n    if (localHeight !== 0) {\n      this.scale.y = value / localHeight * sign;\n    } else {\n      this.scale.y = sign;\n    }\n  },\n  /**\n   * Retrieves the local bounds of the container as a Bounds object.\n   * @returns - The bounding area.\n   * @memberof scene.Container#\n   */\n  getLocalBounds() {\n    if (!this._localBoundsCacheData) {\n      this._localBoundsCacheData = {\n        data: [],\n        index: 1,\n        didChange: false,\n        localBounds: new Bounds()\n      };\n    }\n    const localBoundsCacheData = this._localBoundsCacheData;\n    localBoundsCacheData.index = 1;\n    localBoundsCacheData.didChange = false;\n    if (localBoundsCacheData.data[0] !== this._didChangeId >> 12) {\n      localBoundsCacheData.didChange = true;\n      localBoundsCacheData.data[0] = this._didChangeId >> 12;\n    }\n    checkChildrenDidChange(this, localBoundsCacheData);\n    if (localBoundsCacheData.didChange) {\n      getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix);\n    }\n    return localBoundsCacheData.localBounds;\n  },\n  /**\n   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost.\n   * @param bounds - Optional bounds to store the result of the bounds calculation.\n   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n   * @memberof scene.Container#\n   */\n  getBounds(skipUpdate, bounds) {\n    return getGlobalBounds(this, skipUpdate, bounds || new Bounds());\n  }\n};\nexport { measureMixin };","map":{"version":3,"names":["tempMatrix","Matrix","measureMixin","_localBoundsCacheId","_localBoundsCacheData","_setWidth","value","localWidth","sign","Math","scale","x","_setHeight","localHeight","y","getLocalBounds","data","index","didChange","localBounds","Bounds","localBoundsCacheData","_didChangeId","checkChildrenDidChange","getBounds","skipUpdate","bounds","getGlobalBounds"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/container/container-mixins/measureMixin.ts"],"sourcesContent":["import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Bounds } from '../bounds/Bounds';\nimport { getGlobalBounds } from '../bounds/getGlobalBounds';\nimport { getLocalBounds } from '../bounds/getLocalBounds';\nimport { checkChildrenDidChange } from '../utils/checkChildrenDidChange';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { Container } from '../Container';\n\nexport type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport interface MeasureMixinConstructor\n{\n    width?: number;\n    height?: number;\n}\nexport interface MeasureMixin extends Required<MeasureMixinConstructor>\n{\n    getSize(out?: Size): Size;\n    setSize(width: number, height?: number): void;\n    setSize(value: Optional<Size, 'height'>): void;\n    getLocalBounds(bounds?: Bounds): Bounds;\n    getBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds;\n    _localBoundsCacheData: LocalBoundsCacheData;\n    _localBoundsCacheId: number;\n    _setWidth(width: number, localWidth: number): void;\n    _setHeight(height: number, localHeight: number): void;\n}\n\ninterface LocalBoundsCacheData\n{\n    data: number[];\n    index: number;\n    didChange: boolean;\n    localBounds: Bounds;\n}\n\nconst tempMatrix = new Matrix();\n\nexport const measureMixin: Partial<Container> = {\n\n    _localBoundsCacheId: -1,\n    _localBoundsCacheData: null,\n\n    _setWidth(value: number, localWidth: number)\n    {\n        const sign = Math.sign(this.scale.x) || 1;\n\n        if (localWidth !== 0)\n        {\n            this.scale.x = (value / localWidth) * sign;\n        }\n        else\n        {\n            this.scale.x = sign;\n        }\n    },\n\n    _setHeight(value: number, localHeight: number)\n    {\n        const sign = Math.sign(this.scale.y) || 1;\n\n        if (localHeight !== 0)\n        {\n            this.scale.y = (value / localHeight) * sign;\n        }\n        else\n        {\n            this.scale.y = sign;\n        }\n    },\n\n    /**\n     * Retrieves the local bounds of the container as a Bounds object.\n     * @returns - The bounding area.\n     * @memberof scene.Container#\n     */\n    getLocalBounds(): Bounds\n    {\n        if (!this._localBoundsCacheData)\n        {\n            this._localBoundsCacheData = {\n                data: [],\n                index: 1,\n                didChange: false,\n                localBounds: new Bounds()\n            };\n        }\n\n        const localBoundsCacheData = this._localBoundsCacheData;\n\n        localBoundsCacheData.index = 1;\n        localBoundsCacheData.didChange = false;\n\n        if (localBoundsCacheData.data[0] !== this._didChangeId >> 12)\n        {\n            localBoundsCacheData.didChange = true;\n            localBoundsCacheData.data[0] = this._didChangeId >> 12;\n        }\n\n        checkChildrenDidChange(this, localBoundsCacheData);\n\n        if (localBoundsCacheData.didChange)\n        {\n            getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix);\n        }\n\n        return localBoundsCacheData.localBounds;\n    },\n\n    /**\n     * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n     * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost.\n     * @param bounds - Optional bounds to store the result of the bounds calculation.\n     * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n     * @memberof scene.Container#\n     */\n    getBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds\n    {\n        return getGlobalBounds(this, skipUpdate, bounds || new Bounds());\n    },\n} as Container;\n"],"mappings":";;;;;;AAqCA,MAAMA,UAAA,GAAa,IAAIC,MAAO;AAEvB,MAAMC,YAAmC;EAE5CC,mBAAqB;EACrBC,qBAAuB;EAEvBC,UAAUC,KAAA,EAAeC,UACzB;IACI,MAAMC,IAAA,GAAOC,IAAK,CAAAD,IAAA,CAAK,IAAK,CAAAE,KAAA,CAAMC,CAAC,CAAK;IAExC,IAAIJ,UAAA,KAAe,CACnB;MACS,KAAAG,KAAA,CAAMC,CAAK,GAAAL,KAAA,GAAQC,UAAc,GAAAC,IAAA;IAAA,CAG1C;MACI,KAAKE,KAAA,CAAMC,CAAI,GAAAH,IAAA;IAAA;EACnB,CACJ;EAEAI,WAAWN,KAAA,EAAeO,WAC1B;IACI,MAAML,IAAA,GAAOC,IAAK,CAAAD,IAAA,CAAK,IAAK,CAAAE,KAAA,CAAMI,CAAC,CAAK;IAExC,IAAID,WAAA,KAAgB,CACpB;MACS,KAAAH,KAAA,CAAMI,CAAK,GAAAR,KAAA,GAAQO,WAAe,GAAAL,IAAA;IAAA,CAG3C;MACI,KAAKE,KAAA,CAAMI,CAAI,GAAAN,IAAA;IAAA;EACnB,CACJ;EAAA;AAAA;AAAA;AAAA;AAAA;EAOAO,cACAA,CAAA;IACQ,KAAC,KAAKX,qBACV;MACI,KAAKA,qBAAwB;QACzBY,IAAA,EAAM,EAAC;QACPC,KAAO;QACPC,SAAW;QACXC,WAAA,EAAa,IAAIC,MAAO;MAAA,CAC5B;IAAA;IAGJ,MAAMC,oBAAA,GAAuB,IAAK,CAAAjB,qBAAA;IAElCiB,oBAAA,CAAqBJ,KAAQ;IAC7BI,oBAAA,CAAqBH,SAAY;IAEjC,IAAIG,oBAAA,CAAqBL,IAAK,EAAC,CAAM,UAAKM,YAAA,IAAgB,EAC1D;MACID,oBAAA,CAAqBH,SAAY;MACjCG,oBAAA,CAAqBL,IAAK,EAAC,CAAI,QAAKM,YAAgB;IAAA;IAGxDC,sBAAA,CAAuB,MAAMF,oBAAoB;IAEjD,IAAIA,oBAAA,CAAqBH,SACzB;MACmBH,cAAA,OAAMM,oBAAqB,CAAAF,WAAA,EAAanB,UAAU;IAAA;IAGrE,OAAOqB,oBAAqB,CAAAF,WAAA;EAAA,CAChC;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAWAK,UAAUC,UAAA,EAAsBC,MAChC;IACI,OAAOC,eAAA,CAAgB,IAAM,EAAAF,UAAA,EAAYC,MAAU,QAAIN,MAAA,EAAQ;EAAA;AAEvE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}