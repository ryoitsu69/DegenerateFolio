{"ast":null,"code":"\"use strict\";\n\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ensureIfUint8Array = exports.hexToUint8Array = exports.uint8ArrayToHexString = exports.padLeft = exports.numberToHex = exports.hexToNumber = exports.codePointToInt = exports.transformJsonDataToAbiFormat = exports.fetchArrayElement = exports.ethAbiToJsonSchema = exports.abiSchemaToJsonSchema = exports.parseBaseType = void 0;\nconst web3_errors_1 = require(\"web3-errors\");\nconst constants_js_1 = require(\"./constants.js\");\nconst abi_js_1 = require(\"./validation/abi.js\");\nconst string_js_1 = require(\"./validation/string.js\");\nconst errors_js_1 = require(\"./errors.js\");\nconst extraTypes = ['hex', 'number', 'blockNumber', 'blockNumberOrTag', 'filter', 'bloom'];\nconst parseBaseType = type => {\n  // Remove all empty spaces to avoid any parsing issue.\n  let strippedType = type.replace(/ /, '');\n  let baseTypeSize;\n  let isArray = false;\n  let arraySizes = [];\n  if (type.includes('[')) {\n    // Extract the array type\n    strippedType = strippedType.slice(0, strippedType.indexOf('['));\n    // Extract array indexes\n    arraySizes = [...type.matchAll(/(?:\\[(\\d*)\\])/g)].map(match => parseInt(match[1], 10)).map(size => Number.isNaN(size) ? -1 : size);\n    isArray = arraySizes.length > 0;\n  }\n  if (constants_js_1.VALID_ETH_BASE_TYPES.includes(strippedType)) {\n    return {\n      baseType: strippedType,\n      isArray,\n      baseTypeSize,\n      arraySizes\n    };\n  }\n  if (strippedType.startsWith('int')) {\n    baseTypeSize = parseInt(strippedType.substring(3), 10);\n    strippedType = 'int';\n  } else if (strippedType.startsWith('uint')) {\n    baseTypeSize = parseInt(type.substring(4), 10);\n    strippedType = 'uint';\n  } else if (strippedType.startsWith('bytes')) {\n    baseTypeSize = parseInt(strippedType.substring(5), 10);\n    strippedType = 'bytes';\n  } else {\n    return {\n      baseType: undefined,\n      isArray: false,\n      baseTypeSize: undefined,\n      arraySizes\n    };\n  }\n  return {\n    baseType: strippedType,\n    isArray,\n    baseTypeSize,\n    arraySizes\n  };\n};\nexports.parseBaseType = parseBaseType;\nconst convertEthType = function (type) {\n  let parentSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const typePropertyPresent = Object.keys(parentSchema).includes('type');\n  if (typePropertyPresent) {\n    throw new errors_js_1.Web3ValidatorError([{\n      keyword: 'eth',\n      message: 'Either \"eth\" or \"type\" can be presented in schema',\n      params: {\n        eth: type\n      },\n      instancePath: '',\n      schemaPath: ''\n    }]);\n  }\n  const {\n    baseType,\n    baseTypeSize\n  } = (0, exports.parseBaseType)(type);\n  if (!baseType && !extraTypes.includes(type)) {\n    throw new errors_js_1.Web3ValidatorError([{\n      keyword: 'eth',\n      message: \"Eth data type \\\"\".concat(type, \"\\\" is not valid\"),\n      params: {\n        eth: type\n      },\n      instancePath: '',\n      schemaPath: ''\n    }]);\n  }\n  if (baseType) {\n    if (baseType === 'tuple') {\n      throw new Error('\"tuple\" type is not implemented directly.');\n    }\n    return {\n      format: \"\".concat(baseType).concat(baseTypeSize !== null && baseTypeSize !== void 0 ? baseTypeSize : ''),\n      required: true\n    };\n  }\n  if (type) {\n    return {\n      format: type,\n      required: true\n    };\n  }\n  return {};\n};\nconst abiSchemaToJsonSchema = function (abis) {\n  let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/0';\n  const schema = {\n    type: 'array',\n    items: [],\n    maxItems: abis.length,\n    minItems: abis.length\n  };\n  for (const [index, abi] of abis.entries()) {\n    // eslint-disable-next-line no-nested-ternary\n    let abiType;\n    let abiName;\n    let abiComponents = [];\n    // If it's a complete Abi Parameter\n    // e.g. {name: 'a', type: 'uint'}\n    if ((0, abi_js_1.isAbiParameterSchema)(abi)) {\n      abiType = abi.type;\n      abiName = abi.name;\n      abiComponents = abi.components;\n      // If its short form string value e.g. ['uint']\n    } else if (typeof abi === 'string') {\n      abiType = abi;\n      abiName = \"\".concat(level, \"/\").concat(index);\n      // If it's provided in short form of tuple e.g. [['uint', 'string']]\n    } else if (Array.isArray(abi)) {\n      // If its custom tuple e.g. ['tuple[2]', ['uint', 'string']]\n      if (abi[0] && typeof abi[0] === 'string' && abi[0].startsWith('tuple') && !Array.isArray(abi[0]) && abi[1] && Array.isArray(abi[1])) {\n        // eslint-disable-next-line prefer-destructuring\n        abiType = abi[0];\n        abiName = \"\".concat(level, \"/\").concat(index);\n        abiComponents = abi[1];\n      } else {\n        abiType = 'tuple';\n        abiName = \"\".concat(level, \"/\").concat(index);\n        abiComponents = abi;\n      }\n    }\n    const {\n      baseType,\n      isArray,\n      arraySizes\n    } = (0, exports.parseBaseType)(abiType);\n    let childSchema;\n    let lastSchema = schema;\n    for (let i = arraySizes.length - 1; i > 0; i -= 1) {\n      childSchema = {\n        type: 'array',\n        $id: abiName,\n        items: [],\n        maxItems: arraySizes[i],\n        minItems: arraySizes[i]\n      };\n      if (arraySizes[i] < 0) {\n        delete childSchema.maxItems;\n        delete childSchema.minItems;\n      }\n      // lastSchema.items is a Schema, concat with 'childSchema'\n      if (!Array.isArray(lastSchema.items)) {\n        lastSchema.items = [lastSchema.items, childSchema];\n      } // lastSchema.items is an empty Scheme array, set it to 'childSchema'\n      else if (lastSchema.items.length === 0) {\n        lastSchema.items = [childSchema];\n      } // lastSchema.items is a non-empty Scheme array, append 'childSchema'\n      else {\n        lastSchema.items.push(childSchema);\n      }\n      lastSchema = childSchema;\n    }\n    if (baseType === 'tuple' && !isArray) {\n      const nestedTuple = (0, exports.abiSchemaToJsonSchema)(abiComponents, abiName);\n      nestedTuple.$id = abiName;\n      lastSchema.items.push(nestedTuple);\n    } else if (baseType === 'tuple' && isArray) {\n      const arraySize = arraySizes[0];\n      const item = Object.assign({\n        type: 'array',\n        $id: abiName,\n        items: (0, exports.abiSchemaToJsonSchema)(abiComponents, abiName)\n      }, arraySize >= 0 && {\n        minItems: arraySize,\n        maxItems: arraySize\n      });\n      lastSchema.items.push(item);\n    } else if (isArray) {\n      const arraySize = arraySizes[0];\n      const item = Object.assign({\n        type: 'array',\n        $id: abiName,\n        items: convertEthType(abiType)\n      }, arraySize >= 0 && {\n        minItems: arraySize,\n        maxItems: arraySize\n      });\n      lastSchema.items.push(item);\n    } else if (Array.isArray(lastSchema.items)) {\n      // Array of non-tuple items\n      lastSchema.items.push(Object.assign({\n        $id: abiName\n      }, convertEthType(abiType)));\n    } else {\n      // Nested object\n      lastSchema.items.push(Object.assign({\n        $id: abiName\n      }, convertEthType(abiType)));\n    }\n    lastSchema = schema;\n  }\n  return schema;\n};\nexports.abiSchemaToJsonSchema = abiSchemaToJsonSchema;\nconst ethAbiToJsonSchema = abis => (0, exports.abiSchemaToJsonSchema)(abis);\nexports.ethAbiToJsonSchema = ethAbiToJsonSchema;\nconst fetchArrayElement = (data, level) => {\n  if (level === 1) {\n    return data;\n  }\n  return (0, exports.fetchArrayElement)(data[0], level - 1);\n};\nexports.fetchArrayElement = fetchArrayElement;\nconst transformJsonDataToAbiFormat = (abis, data, transformedData) => {\n  const newData = [];\n  for (const [index, abi] of abis.entries()) {\n    // eslint-disable-next-line no-nested-ternary\n    let abiType;\n    let abiName;\n    let abiComponents = [];\n    // If it's a complete Abi Parameter\n    // e.g. {name: 'a', type: 'uint'}\n    if ((0, abi_js_1.isAbiParameterSchema)(abi)) {\n      abiType = abi.type;\n      abiName = abi.name;\n      abiComponents = abi.components;\n      // If its short form string value e.g. ['uint']\n    } else if (typeof abi === 'string') {\n      abiType = abi;\n      // If it's provided in short form of tuple e.g. [['uint', 'string']]\n    } else if (Array.isArray(abi)) {\n      // If its custom tuple e.g. ['tuple[2]', ['uint', 'string']]\n      if (abi[1] && Array.isArray(abi[1])) {\n        abiType = abi[0];\n        abiComponents = abi[1];\n      } else {\n        abiType = 'tuple';\n        abiComponents = abi;\n      }\n    }\n    const {\n      baseType,\n      isArray,\n      arraySizes\n    } = (0, exports.parseBaseType)(abiType);\n    const dataItem = Array.isArray(data) ? data[index] : data[abiName];\n    if (baseType === 'tuple' && !isArray) {\n      newData.push((0, exports.transformJsonDataToAbiFormat)(abiComponents, dataItem, transformedData));\n    } else if (baseType === 'tuple' && isArray) {\n      const tupleData = [];\n      for (const tupleItem of dataItem) {\n        // Nested array\n        if (arraySizes.length > 1) {\n          const nestedItems = (0, exports.fetchArrayElement)(tupleItem, arraySizes.length - 1);\n          const nestedData = [];\n          for (const nestedItem of nestedItems) {\n            nestedData.push((0, exports.transformJsonDataToAbiFormat)(abiComponents, nestedItem, transformedData));\n          }\n          tupleData.push(nestedData);\n        } else {\n          tupleData.push((0, exports.transformJsonDataToAbiFormat)(abiComponents, tupleItem, transformedData));\n        }\n      }\n      newData.push(tupleData);\n    } else {\n      newData.push(dataItem);\n    }\n  }\n  // Have to reassign before pushing to transformedData\n  // eslint-disable-next-line no-param-reassign\n  transformedData = transformedData !== null && transformedData !== void 0 ? transformedData : [];\n  transformedData.push(...newData);\n  return transformedData;\n};\nexports.transformJsonDataToAbiFormat = transformJsonDataToAbiFormat;\n/**\n * Code points to int\n */\nconst codePointToInt = codePoint => {\n  if (codePoint >= 48 && codePoint <= 57) {\n    /* ['0'..'9'] -> [0..9] */\n    return codePoint - 48;\n  }\n  if (codePoint >= 65 && codePoint <= 70) {\n    /* ['A'..'F'] -> [10..15] */\n    return codePoint - 55;\n  }\n  if (codePoint >= 97 && codePoint <= 102) {\n    /* ['a'..'f'] -> [10..15] */\n    return codePoint - 87;\n  }\n  throw new Error(\"Invalid code point: \".concat(codePoint));\n};\nexports.codePointToInt = codePointToInt;\n/**\n * Converts value to it's number representation\n */\nconst hexToNumber = value => {\n  if (!(0, string_js_1.isHexStrict)(value)) {\n    throw new Error('Invalid hex string');\n  }\n  const [negative, hexValue] = value.startsWith('-') ? [true, value.slice(1)] : [false, value];\n  const num = BigInt(hexValue);\n  if (num > Number.MAX_SAFE_INTEGER) {\n    return negative ? -num : num;\n  }\n  if (num < Number.MIN_SAFE_INTEGER) {\n    return num;\n  }\n  return negative ? -1 * Number(num) : Number(num);\n};\nexports.hexToNumber = hexToNumber;\n/**\n * Converts value to it's hex representation\n */\nconst numberToHex = value => {\n  if ((typeof value === 'number' || typeof value === 'bigint') && value < 0) {\n    return \"-0x\".concat(value.toString(16).slice(1));\n  }\n  if ((typeof value === 'number' || typeof value === 'bigint') && value >= 0) {\n    return \"0x\".concat(value.toString(16));\n  }\n  if (typeof value === 'string' && (0, string_js_1.isHexStrict)(value)) {\n    const [negative, hex] = value.startsWith('-') ? [true, value.slice(1)] : [false, value];\n    const hexValue = hex.split(/^(-)?0(x|X)/).slice(-1)[0];\n    return \"\".concat(negative ? '-' : '', \"0x\").concat(hexValue.replace(/^0+/, '').toLowerCase());\n  }\n  if (typeof value === 'string' && !(0, string_js_1.isHexStrict)(value)) {\n    return (0, exports.numberToHex)(BigInt(value));\n  }\n  throw new web3_errors_1.InvalidNumberError(value);\n};\nexports.numberToHex = numberToHex;\n/**\n * Adds a padding on the left of a string, if value is a integer or bigInt will be converted to a hex string.\n */\nconst padLeft = function (value, characterAmount) {\n  let sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '0';\n  if (typeof value === 'string' && !(0, string_js_1.isHexStrict)(value)) {\n    return value.padStart(characterAmount, sign);\n  }\n  const hex = typeof value === 'string' && (0, string_js_1.isHexStrict)(value) ? value : (0, exports.numberToHex)(value);\n  const [prefix, hexValue] = hex.startsWith('-') ? ['-0x', hex.slice(3)] : ['0x', hex.slice(2)];\n  return \"\".concat(prefix).concat(hexValue.padStart(characterAmount, sign));\n};\nexports.padLeft = padLeft;\nfunction uint8ArrayToHexString(uint8Array) {\n  let hexString = '0x';\n  for (const e of uint8Array) {\n    const hex = e.toString(16);\n    hexString += hex.length === 1 ? \"0\".concat(hex) : hex;\n  }\n  return hexString;\n}\nexports.uint8ArrayToHexString = uint8ArrayToHexString;\n// for optimized technique for hex to bytes conversion\nconst charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102\n};\nfunction charCodeToBase16(char) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine) return char - charCodeMap.zero;\n  if (char >= charCodeMap.A && char <= charCodeMap.F) return char - (charCodeMap.A - 10);\n  if (char >= charCodeMap.a && char <= charCodeMap.f) return char - (charCodeMap.a - 10);\n  return undefined;\n}\nfunction hexToUint8Array(hex) {\n  let offset = 0;\n  if (hex.startsWith('0') && (hex[1] === 'x' || hex[1] === 'X')) {\n    offset = 2;\n  }\n  if (hex.length % 2 !== 0) {\n    throw new web3_errors_1.InvalidBytesError(\"hex string has odd length: \".concat(hex));\n  }\n  const length = (hex.length - offset) / 2;\n  const bytes = new Uint8Array(length);\n  for (let index = 0, j = offset; index < length; index += 1) {\n    // eslint-disable-next-line no-plusplus\n    const nibbleLeft = charCodeToBase16(hex.charCodeAt(j++));\n    // eslint-disable-next-line no-plusplus\n    const nibbleRight = charCodeToBase16(hex.charCodeAt(j++));\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new web3_errors_1.InvalidBytesError(\"Invalid byte sequence (\\\"\".concat(hex[j - 2]).concat(hex[j - 1], \"\\\" in \\\"\").concat(hex, \"\\\").\"));\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight;\n  }\n  return bytes;\n}\nexports.hexToUint8Array = hexToUint8Array;\n// @TODO: Remove this function and its usages once all sub dependencies uses version 1.3.3 or above of @noble/hashes\nfunction ensureIfUint8Array(data) {\n  var _a;\n  if (!(data instanceof Uint8Array) && ((_a = data === null || data === void 0 ? void 0 : data.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'Uint8Array') {\n    return Uint8Array.from(data);\n  }\n  return data;\n}\nexports.ensureIfUint8Array = ensureIfUint8Array;","map":{"version":3,"names":["web3_errors_1","require","constants_js_1","abi_js_1","string_js_1","errors_js_1","extraTypes","parseBaseType","type","strippedType","replace","baseTypeSize","isArray","arraySizes","includes","slice","indexOf","matchAll","map","match","parseInt","size","Number","isNaN","length","VALID_ETH_BASE_TYPES","baseType","startsWith","substring","undefined","exports","convertEthType","parentSchema","arguments","typePropertyPresent","Object","keys","Web3ValidatorError","keyword","message","params","eth","instancePath","schemaPath","concat","Error","format","required","abiSchemaToJsonSchema","abis","level","schema","items","maxItems","minItems","index","abi","entries","abiType","abiName","abiComponents","isAbiParameterSchema","name","components","Array","childSchema","lastSchema","i","$id","push","nestedTuple","arraySize","item","assign","ethAbiToJsonSchema","fetchArrayElement","data","transformJsonDataToAbiFormat","transformedData","newData","dataItem","tupleData","tupleItem","nestedItems","nestedData","nestedItem","codePointToInt","codePoint","hexToNumber","value","isHexStrict","negative","hexValue","num","BigInt","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","numberToHex","toString","hex","split","toLowerCase","InvalidNumberError","padLeft","characterAmount","sign","padStart","prefix","uint8ArrayToHexString","uint8Array","hexString","e","charCodeMap","zero","nine","A","F","a","f","charCodeToBase16","char","hexToUint8Array","offset","InvalidBytesError","bytes","Uint8Array","j","nibbleLeft","charCodeAt","nibbleRight","ensureIfUint8Array","_a","constructor","from"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/web3-validator/src/utils.ts"],"sourcesContent":["﻿/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { InvalidBytesError, InvalidNumberError } from 'web3-errors';\nimport { VALID_ETH_BASE_TYPES } from './constants.js';\nimport {\n\tFullValidationSchema,\n\tJsonSchema,\n\tShortValidationSchema,\n\tValidationSchemaInput,\n\tValidInputTypes,\n} from './types.js';\nimport { isAbiParameterSchema } from './validation/abi.js';\nimport { isHexStrict } from './validation/string.js';\nimport { Web3ValidatorError } from './errors.js';\n\nconst extraTypes = ['hex', 'number', 'blockNumber', 'blockNumberOrTag', 'filter', 'bloom'];\n\nexport const parseBaseType = <T = typeof VALID_ETH_BASE_TYPES[number]>(\n\ttype: string,\n): {\n\tbaseType?: T;\n\tbaseTypeSize: number | undefined;\n\tarraySizes: number[];\n\tisArray: boolean;\n} => {\n\t// Remove all empty spaces to avoid any parsing issue.\n\tlet strippedType = type.replace(/ /, '');\n\tlet baseTypeSize: number | undefined;\n\tlet isArray = false;\n\tlet arraySizes: number[] = [];\n\n\tif (type.includes('[')) {\n\t\t// Extract the array type\n\t\tstrippedType = strippedType.slice(0, strippedType.indexOf('['));\n\t\t// Extract array indexes\n\t\tarraySizes = [...type.matchAll(/(?:\\[(\\d*)\\])/g)]\n\t\t\t.map(match => parseInt(match[1], 10))\n\t\t\t.map(size => (Number.isNaN(size) ? -1 : size));\n\n\t\tisArray = arraySizes.length > 0;\n\t}\n\n\tif (VALID_ETH_BASE_TYPES.includes(strippedType)) {\n\t\treturn { baseType: strippedType as unknown as T, isArray, baseTypeSize, arraySizes };\n\t}\n\n\tif (strippedType.startsWith('int')) {\n\t\tbaseTypeSize = parseInt(strippedType.substring(3), 10);\n\t\tstrippedType = 'int';\n\t} else if (strippedType.startsWith('uint')) {\n\t\tbaseTypeSize = parseInt(type.substring(4), 10);\n\t\tstrippedType = 'uint';\n\t} else if (strippedType.startsWith('bytes')) {\n\t\tbaseTypeSize = parseInt(strippedType.substring(5), 10);\n\t\tstrippedType = 'bytes';\n\t} else {\n\t\treturn { baseType: undefined, isArray: false, baseTypeSize: undefined, arraySizes };\n\t}\n\n\treturn { baseType: strippedType as unknown as T, isArray, baseTypeSize, arraySizes };\n};\n\nconst convertEthType = (\n\ttype: string,\n\tparentSchema: JsonSchema = {},\n): { format?: string; required?: boolean } => {\n\tconst typePropertyPresent = Object.keys(parentSchema).includes('type');\n\n\tif (typePropertyPresent) {\n\t\tthrow new Web3ValidatorError([\n\t\t\t{\n\t\t\t\tkeyword: 'eth',\n\t\t\t\tmessage: 'Either \"eth\" or \"type\" can be presented in schema',\n\t\t\t\tparams: { eth: type },\n\t\t\t\tinstancePath: '',\n\t\t\t\tschemaPath: '',\n\t\t\t},\n\t\t]);\n\t}\n\n\tconst { baseType, baseTypeSize } = parseBaseType(type);\n\n\tif (!baseType && !extraTypes.includes(type)) {\n\t\tthrow new Web3ValidatorError([\n\t\t\t{\n\t\t\t\tkeyword: 'eth',\n\t\t\t\tmessage: `Eth data type \"${type}\" is not valid`,\n\t\t\t\tparams: { eth: type },\n\t\t\t\tinstancePath: '',\n\t\t\t\tschemaPath: '',\n\t\t\t},\n\t\t]);\n\t}\n\n\tif (baseType) {\n\t\tif (baseType === 'tuple') {\n\t\t\tthrow new Error('\"tuple\" type is not implemented directly.');\n\t\t}\n\t\treturn { format: `${baseType}${baseTypeSize ?? ''}`, required: true };\n\t}\n\tif (type) {\n\t\treturn { format: type, required: true };\n\t}\n\n\treturn {};\n};\n\nexport const abiSchemaToJsonSchema = (\n\tabis: ShortValidationSchema | FullValidationSchema,\n\tlevel = '/0',\n) => {\n\tconst schema: JsonSchema = {\n\t\ttype: 'array',\n\t\titems: [],\n\t\tmaxItems: abis.length,\n\t\tminItems: abis.length,\n\t};\n\n\tfor (const [index, abi] of abis.entries()) {\n\t\t// eslint-disable-next-line no-nested-ternary\n\t\tlet abiType!: string;\n\t\tlet abiName!: string;\n\t\tlet abiComponents: ShortValidationSchema | FullValidationSchema | undefined = [];\n\n\t\t// If it's a complete Abi Parameter\n\t\t// e.g. {name: 'a', type: 'uint'}\n\t\tif (isAbiParameterSchema(abi)) {\n\t\t\tabiType = abi.type;\n\t\t\tabiName = abi.name;\n\t\t\tabiComponents = abi.components as FullValidationSchema;\n\t\t\t// If its short form string value e.g. ['uint']\n\t\t} else if (typeof abi === 'string') {\n\t\t\tabiType = abi;\n\t\t\tabiName = `${level}/${index}`;\n\n\t\t\t// If it's provided in short form of tuple e.g. [['uint', 'string']]\n\t\t} else if (Array.isArray(abi)) {\n\t\t\t// If its custom tuple e.g. ['tuple[2]', ['uint', 'string']]\n\t\t\tif (\n\t\t\t\tabi[0] &&\n\t\t\t\ttypeof abi[0] === 'string' &&\n\t\t\t\tabi[0].startsWith('tuple') &&\n\t\t\t\t!Array.isArray(abi[0]) &&\n\t\t\t\tabi[1] &&\n\t\t\t\tArray.isArray(abi[1])\n\t\t\t) {\n\t\t\t\t// eslint-disable-next-line prefer-destructuring\n\t\t\t\tabiType = abi[0];\n\t\t\t\tabiName = `${level}/${index}`;\n\t\t\t\tabiComponents = abi[1] as ReadonlyArray<ShortValidationSchema>;\n\t\t\t} else {\n\t\t\t\tabiType = 'tuple';\n\t\t\t\tabiName = `${level}/${index}`;\n\t\t\t\tabiComponents = abi;\n\t\t\t}\n\t\t}\n\n\t\tconst { baseType, isArray, arraySizes } = parseBaseType(abiType);\n\n\t\tlet childSchema: JsonSchema;\n\t\tlet lastSchema = schema;\n\t\tfor (let i = arraySizes.length - 1; i > 0; i -= 1) {\n\t\t\tchildSchema = {\n\t\t\t\ttype: 'array',\n\t\t\t\t$id: abiName,\n\t\t\t\titems: [],\n\t\t\t\tmaxItems: arraySizes[i],\n\t\t\t\tminItems: arraySizes[i],\n\t\t\t};\n\n\t\t\tif (arraySizes[i] < 0) {\n\t\t\t\tdelete childSchema.maxItems;\n\t\t\t\tdelete childSchema.minItems;\n\t\t\t}\n\n\t\t\t// lastSchema.items is a Schema, concat with 'childSchema'\n\t\t\tif (!Array.isArray(lastSchema.items)) {\n\t\t\t\tlastSchema.items = [lastSchema.items as JsonSchema, childSchema];\n\t\t\t} // lastSchema.items is an empty Scheme array, set it to 'childSchema'\n\t\t\telse if (lastSchema.items.length === 0) {\n\t\t\t\tlastSchema.items = [childSchema];\n\t\t\t} // lastSchema.items is a non-empty Scheme array, append 'childSchema'\n\t\t\telse {\n\t\t\t\tlastSchema.items.push(childSchema);\n\t\t\t}\n\t\t\tlastSchema = childSchema;\n\t\t}\n\n\t\tif (baseType === 'tuple' && !isArray) {\n\t\t\tconst nestedTuple = abiSchemaToJsonSchema(abiComponents, abiName);\n\t\t\tnestedTuple.$id = abiName;\n\t\t\t(lastSchema.items as JsonSchema[]).push(nestedTuple);\n\t\t} else if (baseType === 'tuple' && isArray) {\n            const arraySize = arraySizes[0];\n            const item: JsonSchema = {\n                type: 'array',\n                $id: abiName,\n                items: abiSchemaToJsonSchema(abiComponents, abiName),\n                ...(arraySize >= 0 && { minItems: arraySize, maxItems: arraySize }),\n            };\n\n            (lastSchema.items as JsonSchema[]).push(item);\n\t\t} else if (isArray) {\n\t\t    const arraySize = arraySizes[0];\n            const item: JsonSchema = {\n                type: 'array',\n                $id: abiName,\n                items: convertEthType(abiType),\n                ...(arraySize >= 0 && { minItems: arraySize, maxItems: arraySize }),\n            };\n\n            (lastSchema.items as JsonSchema[]).push(item);\n\t\t} else if (Array.isArray(lastSchema.items)) {\n\t\t\t// Array of non-tuple items\n\t\t\tlastSchema.items.push({ $id: abiName, ...convertEthType(abiType) });\n\t\t} else {\n\t\t\t// Nested object\n\t\t\t(lastSchema.items as JsonSchema[]).push({\n\t\t\t\t$id: abiName,\n\t\t\t\t...convertEthType(abiType),\n\t\t\t});\n\t\t}\n\t\tlastSchema = schema;\n\t}\n\n\treturn schema;\n};\n\nexport const ethAbiToJsonSchema = (abis: ValidationSchemaInput) => abiSchemaToJsonSchema(abis);\n\nexport const fetchArrayElement = (data: Array<unknown>, level: number): unknown => {\n\tif (level === 1) {\n\t\treturn data;\n\t}\n\n\treturn fetchArrayElement(data[0] as Array<unknown>, level - 1);\n};\n\nexport const transformJsonDataToAbiFormat = (\n\tabis: FullValidationSchema,\n\tdata: ReadonlyArray<unknown> | Record<string, unknown>,\n\ttransformedData?: Array<unknown>,\n): Array<unknown> => {\n\tconst newData: Array<unknown> = [];\n\n\tfor (const [index, abi] of abis.entries()) {\n\t\t// eslint-disable-next-line no-nested-ternary\n\t\tlet abiType!: string;\n\t\tlet abiName!: string;\n\t\tlet abiComponents: ShortValidationSchema | FullValidationSchema | undefined = [];\n\n\t\t// If it's a complete Abi Parameter\n\t\t// e.g. {name: 'a', type: 'uint'}\n\t\tif (isAbiParameterSchema(abi)) {\n\t\t\tabiType = abi.type;\n\t\t\tabiName = abi.name;\n\t\t\tabiComponents = abi.components as FullValidationSchema;\n\t\t\t// If its short form string value e.g. ['uint']\n\t\t} else if (typeof abi === 'string') {\n\t\t\tabiType = abi;\n\n\t\t\t// If it's provided in short form of tuple e.g. [['uint', 'string']]\n\t\t} else if (Array.isArray(abi)) {\n\t\t\t// If its custom tuple e.g. ['tuple[2]', ['uint', 'string']]\n\t\t\tif (abi[1] && Array.isArray(abi[1])) {\n\t\t\t\tabiType = abi[0] as string;\n\t\t\t\tabiComponents = abi[1] as ReadonlyArray<ShortValidationSchema>;\n\t\t\t} else {\n\t\t\t\tabiType = 'tuple';\n\t\t\t\tabiComponents = abi;\n\t\t\t}\n\t\t}\n\n\t\tconst { baseType, isArray, arraySizes } = parseBaseType(abiType);\n\t\tconst dataItem = Array.isArray(data)\n\t\t\t? (data as Array<unknown>)[index]\n\t\t\t: (data as Record<string, unknown>)[abiName];\n\n\t\tif (baseType === 'tuple' && !isArray) {\n\t\t\tnewData.push(\n\t\t\t\ttransformJsonDataToAbiFormat(\n\t\t\t\t\tabiComponents as FullValidationSchema,\n\t\t\t\t\tdataItem as Array<unknown>,\n\t\t\t\t\ttransformedData,\n\t\t\t\t),\n\t\t\t);\n\t\t} else if (baseType === 'tuple' && isArray) {\n\t\t\tconst tupleData = [];\n\t\t\tfor (const tupleItem of dataItem as Array<unknown>) {\n\t\t\t\t// Nested array\n\t\t\t\tif (arraySizes.length > 1) {\n\t\t\t\t\tconst nestedItems = fetchArrayElement(\n\t\t\t\t\t\ttupleItem as Array<unknown>,\n\t\t\t\t\t\tarraySizes.length - 1,\n\t\t\t\t\t);\n\t\t\t\t\tconst nestedData = [];\n\n\t\t\t\t\tfor (const nestedItem of nestedItems as Array<unknown>) {\n\t\t\t\t\t\tnestedData.push(\n\t\t\t\t\t\t\ttransformJsonDataToAbiFormat(\n\t\t\t\t\t\t\t\tabiComponents as FullValidationSchema,\n\t\t\t\t\t\t\t\tnestedItem as Array<unknown>,\n\t\t\t\t\t\t\t\ttransformedData,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\ttupleData.push(nestedData);\n\t\t\t\t} else {\n\t\t\t\t\ttupleData.push(\n\t\t\t\t\t\ttransformJsonDataToAbiFormat(\n\t\t\t\t\t\t\tabiComponents as FullValidationSchema,\n\t\t\t\t\t\t\ttupleItem as Array<unknown>,\n\t\t\t\t\t\t\ttransformedData,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewData.push(tupleData);\n\t\t} else {\n\t\t\tnewData.push(dataItem);\n\t\t}\n\t}\n\n\t// Have to reassign before pushing to transformedData\n\t// eslint-disable-next-line no-param-reassign\n\ttransformedData = transformedData ?? [];\n\ttransformedData.push(...newData);\n\n\treturn transformedData;\n};\n\n/**\n * Code points to int\n */\n\nexport const codePointToInt = (codePoint: number): number => {\n\tif (codePoint >= 48 && codePoint <= 57) {\n\t\t/* ['0'..'9'] -> [0..9] */\n\t\treturn codePoint - 48;\n\t}\n\n\tif (codePoint >= 65 && codePoint <= 70) {\n\t\t/* ['A'..'F'] -> [10..15] */\n\t\treturn codePoint - 55;\n\t}\n\n\tif (codePoint >= 97 && codePoint <= 102) {\n\t\t/* ['a'..'f'] -> [10..15] */\n\t\treturn codePoint - 87;\n\t}\n\n\tthrow new Error(`Invalid code point: ${codePoint}`);\n};\n\n/**\n * Converts value to it's number representation\n */\nexport const hexToNumber = (value: string): bigint | number => {\n\tif (!isHexStrict(value)) {\n\t\tthrow new Error('Invalid hex string');\n\t}\n\n\tconst [negative, hexValue] = value.startsWith('-') ? [true, value.slice(1)] : [false, value];\n\tconst num = BigInt(hexValue);\n\n\tif (num > Number.MAX_SAFE_INTEGER) {\n\t\treturn negative ? -num : num;\n\t}\n\n\tif (num < Number.MIN_SAFE_INTEGER) {\n\t\treturn num;\n\t}\n\n\treturn negative ? -1 * Number(num) : Number(num);\n};\n\n/**\n * Converts value to it's hex representation\n */\nexport const numberToHex = (value: ValidInputTypes): string => {\n\tif ((typeof value === 'number' || typeof value === 'bigint') && value < 0) {\n\t\treturn `-0x${value.toString(16).slice(1)}`;\n\t}\n\n\tif ((typeof value === 'number' || typeof value === 'bigint') && value >= 0) {\n\t\treturn `0x${value.toString(16)}`;\n\t}\n\n\tif (typeof value === 'string' && isHexStrict(value)) {\n\t\tconst [negative, hex] = value.startsWith('-') ? [true, value.slice(1)] : [false, value];\n\t\tconst hexValue = hex.split(/^(-)?0(x|X)/).slice(-1)[0];\n\t\treturn `${negative ? '-' : ''}0x${hexValue.replace(/^0+/, '').toLowerCase()}`;\n\t}\n\n\tif (typeof value === 'string' && !isHexStrict(value)) {\n\t\treturn numberToHex(BigInt(value));\n\t}\n\n\tthrow new InvalidNumberError(value);\n};\n\n/**\n * Adds a padding on the left of a string, if value is a integer or bigInt will be converted to a hex string.\n */\nexport const padLeft = (value: ValidInputTypes, characterAmount: number, sign = '0'): string => {\n\tif (typeof value === 'string' && !isHexStrict(value)) {\n\t\treturn value.padStart(characterAmount, sign);\n\t}\n\n\tconst hex = typeof value === 'string' && isHexStrict(value) ? value : numberToHex(value);\n\n\tconst [prefix, hexValue] = hex.startsWith('-') ? ['-0x', hex.slice(3)] : ['0x', hex.slice(2)];\n\n\treturn `${prefix}${hexValue.padStart(characterAmount, sign)}`;\n};\n\nexport function uint8ArrayToHexString(uint8Array: Uint8Array): string {\n\tlet hexString = '0x';\n\tfor (const e of uint8Array) {\n\t\tconst hex = e.toString(16);\n\t\thexString += hex.length === 1 ? `0${hex}` : hex;\n\t}\n\treturn hexString;\n}\n\n// for optimized technique for hex to bytes conversion\nconst charCodeMap = {\n\tzero: 48,\n\tnine: 57,\n\tA: 65,\n\tF: 70,\n\ta: 97,\n\tf: 102,\n  } as const\n\n  function charCodeToBase16(char: number) {\n\tif (char >= charCodeMap.zero && char <= charCodeMap.nine)\n\t  return char - charCodeMap.zero\n\tif (char >= charCodeMap.A && char <= charCodeMap.F)\n\t  return char - (charCodeMap.A - 10)\n\tif (char >= charCodeMap.a && char <= charCodeMap.f)\n\t  return char - (charCodeMap.a - 10)\n\treturn undefined\n  }\n\nexport function hexToUint8Array(hex: string): Uint8Array {\n\tlet offset = 0;\n\tif (hex.startsWith('0') && (hex[1] === 'x' || hex[1] === 'X')) {\n\t\toffset = 2;\n\t}\n\tif (hex.length % 2 !== 0) {\n\t\tthrow new InvalidBytesError(`hex string has odd length: ${hex}`);\n\t}\n\tconst length = (hex.length - offset) / 2;\n\tconst bytes = new Uint8Array(length);\n\tfor (let index = 0, j = offset; index < length; index+=1) {\n\t  // eslint-disable-next-line no-plusplus\n\t  const nibbleLeft = charCodeToBase16(hex.charCodeAt(j++))\n\t  // eslint-disable-next-line no-plusplus\n\t  const nibbleRight = charCodeToBase16(hex.charCodeAt(j++))\n\t  if (nibbleLeft === undefined || nibbleRight === undefined) {\n\t\tthrow new InvalidBytesError(\n\t\t\t`Invalid byte sequence (\"${hex[j - 2]}${\n\t\t\t\thex[j - 1]\n\t\t\t  }\" in \"${hex}\").`,\n\t\t)\n\t  }\n\t  bytes[index] = nibbleLeft * 16 + nibbleRight\n\t}\n\treturn bytes\n}\n\n// @TODO: Remove this function and its usages once all sub dependencies uses version 1.3.3 or above of @noble/hashes\nexport function ensureIfUint8Array<T = any>(data: T) {\n\tif (\n\t\t!(data instanceof Uint8Array) &&\n\t\t(data as { constructor: { name: string } })?.constructor?.name === 'Uint8Array'\n\t) {\n\t\treturn Uint8Array.from(data as unknown as Uint8Array);\n\t}\n\treturn data;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}