{"ast":null,"code":"import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { isFunction, objectSpread } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nimport { getImageHashBounded } from './util.js';\nfunction isNewDepositors(depositors) {\n  // Detect balance...\n  return isFunction(depositors[1].mul);\n}\nfunction parse(_ref) {\n  let [proposals, images, optDepositors] = _ref;\n  return proposals.filter((_ref2, index) => {\n    var _optDepositors$index;\n    let [,, proposer] = _ref2;\n    return !!((_optDepositors$index = optDepositors[index]) !== null && _optDepositors$index !== void 0 && _optDepositors$index.isSome) && !proposer.isEmpty;\n  }).map((_ref3, proposalIndex) => {\n    let [index, hash, proposer] = _ref3;\n    const depositors = optDepositors[proposalIndex].unwrap();\n    return objectSpread({\n      image: images[proposalIndex],\n      imageHash: getImageHashBounded(hash),\n      index,\n      proposer\n    }, isNewDepositors(depositors) ? {\n      balance: depositors[1],\n      seconds: depositors[0]\n    } : {\n      balance: depositors[0],\n      seconds: depositors[1]\n    });\n  });\n}\nexport function proposals(instanceId, api) {\n  return memo(instanceId, () => {\n    var _api$query$democracy;\n    return isFunction((_api$query$democracy = api.query.democracy) === null || _api$query$democracy === void 0 ? void 0 : _api$query$democracy.publicProps) ? api.query.democracy.publicProps().pipe(switchMap(proposals => proposals.length ? combineLatest([of(proposals), api.derive.democracy.preimages(proposals.map(_ref4 => {\n      let [, hash] = _ref4;\n      return hash;\n    })), api.query.democracy.depositOf.multi(proposals.map(_ref5 => {\n      let [index] = _ref5;\n      return index;\n    }))]) : of([[], [], []])), map(parse)) : of([]);\n  });\n}","map":{"version":3,"names":["combineLatest","map","of","switchMap","isFunction","objectSpread","memo","getImageHashBounded","isNewDepositors","depositors","mul","parse","_ref","proposals","images","optDepositors","filter","_ref2","index","_optDepositors$index","proposer","isSome","isEmpty","_ref3","proposalIndex","hash","unwrap","image","imageHash","balance","seconds","instanceId","api","_api$query$democracy","query","democracy","publicProps","pipe","length","derive","preimages","_ref4","depositOf","multi","_ref5"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api-derive/democracy/proposals.js"],"sourcesContent":["import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { isFunction, objectSpread } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nimport { getImageHashBounded } from './util.js';\nfunction isNewDepositors(depositors) {\n    // Detect balance...\n    return isFunction(depositors[1].mul);\n}\nfunction parse([proposals, images, optDepositors]) {\n    return proposals\n        .filter(([, , proposer], index) => !!(optDepositors[index]?.isSome) && !proposer.isEmpty)\n        .map(([index, hash, proposer], proposalIndex) => {\n        const depositors = optDepositors[proposalIndex].unwrap();\n        return objectSpread({\n            image: images[proposalIndex],\n            imageHash: getImageHashBounded(hash),\n            index,\n            proposer\n        }, isNewDepositors(depositors)\n            ? { balance: depositors[1], seconds: depositors[0] }\n            : { balance: depositors[0], seconds: depositors[1] });\n    });\n}\nexport function proposals(instanceId, api) {\n    return memo(instanceId, () => isFunction(api.query.democracy?.publicProps)\n        ? api.query.democracy.publicProps().pipe(switchMap((proposals) => proposals.length\n            ? combineLatest([\n                of(proposals),\n                api.derive.democracy.preimages(proposals.map(([, hash]) => hash)),\n                api.query.democracy.depositOf.multi(proposals.map(([index]) => index))\n            ])\n            : of([[], [], []])), map(parse))\n        : of([]));\n}\n"],"mappings":"AAAA,SAASA,aAAa,EAAEC,GAAG,EAAEC,EAAE,EAAEC,SAAS,QAAQ,MAAM;AACxD,SAASC,UAAU,EAAEC,YAAY,QAAQ,gBAAgB;AACzD,SAASC,IAAI,QAAQ,kBAAkB;AACvC,SAASC,mBAAmB,QAAQ,WAAW;AAC/C,SAASC,eAAeA,CAACC,UAAU,EAAE;EACjC;EACA,OAAOL,UAAU,CAACK,UAAU,CAAC,CAAC,CAAC,CAACC,GAAG,CAAC;AACxC;AACA,SAASC,KAAKA,CAAAC,IAAA,EAAqC;EAAA,IAApC,CAACC,SAAS,EAAEC,MAAM,EAAEC,aAAa,CAAC,GAAAH,IAAA;EAC7C,OAAOC,SAAS,CACXG,MAAM,CAAC,CAAAC,KAAA,EAAiBC,KAAK;IAAA,IAAAC,oBAAA;IAAA,IAArB,IAAKC,QAAQ,CAAC,GAAAH,KAAA;IAAA,OAAY,CAAC,GAAAE,oBAAA,GAAEJ,aAAa,CAACG,KAAK,CAAC,cAAAC,oBAAA,eAApBA,oBAAA,CAAsBE,MAAM,CAAC,IAAI,CAACD,QAAQ,CAACE,OAAO;EAAA,EAAC,CACxFrB,GAAG,CAAC,CAAAsB,KAAA,EAA0BC,aAAa,KAAK;IAAA,IAA3C,CAACN,KAAK,EAAEO,IAAI,EAAEL,QAAQ,CAAC,GAAAG,KAAA;IAC7B,MAAMd,UAAU,GAAGM,aAAa,CAACS,aAAa,CAAC,CAACE,MAAM,CAAC,CAAC;IACxD,OAAOrB,YAAY,CAAC;MAChBsB,KAAK,EAAEb,MAAM,CAACU,aAAa,CAAC;MAC5BI,SAAS,EAAErB,mBAAmB,CAACkB,IAAI,CAAC;MACpCP,KAAK;MACLE;IACJ,CAAC,EAAEZ,eAAe,CAACC,UAAU,CAAC,GACxB;MAAEoB,OAAO,EAAEpB,UAAU,CAAC,CAAC,CAAC;MAAEqB,OAAO,EAAErB,UAAU,CAAC,CAAC;IAAE,CAAC,GAClD;MAAEoB,OAAO,EAAEpB,UAAU,CAAC,CAAC,CAAC;MAAEqB,OAAO,EAAErB,UAAU,CAAC,CAAC;IAAE,CAAC,CAAC;EAC7D,CAAC,CAAC;AACN;AACA,OAAO,SAASI,SAASA,CAACkB,UAAU,EAAEC,GAAG,EAAE;EACvC,OAAO1B,IAAI,CAACyB,UAAU,EAAE;IAAA,IAAAE,oBAAA;IAAA,OAAM7B,UAAU,EAAA6B,oBAAA,GAACD,GAAG,CAACE,KAAK,CAACC,SAAS,cAAAF,oBAAA,uBAAnBA,oBAAA,CAAqBG,WAAW,CAAC,GACpEJ,GAAG,CAACE,KAAK,CAACC,SAAS,CAACC,WAAW,CAAC,CAAC,CAACC,IAAI,CAAClC,SAAS,CAAEU,SAAS,IAAKA,SAAS,CAACyB,MAAM,GAC5EtC,aAAa,CAAC,CACZE,EAAE,CAACW,SAAS,CAAC,EACbmB,GAAG,CAACO,MAAM,CAACJ,SAAS,CAACK,SAAS,CAAC3B,SAAS,CAACZ,GAAG,CAACwC,KAAA;MAAA,IAAC,GAAGhB,IAAI,CAAC,GAAAgB,KAAA;MAAA,OAAKhB,IAAI;IAAA,EAAC,CAAC,EACjEO,GAAG,CAACE,KAAK,CAACC,SAAS,CAACO,SAAS,CAACC,KAAK,CAAC9B,SAAS,CAACZ,GAAG,CAAC2C,KAAA;MAAA,IAAC,CAAC1B,KAAK,CAAC,GAAA0B,KAAA;MAAA,OAAK1B,KAAK;IAAA,EAAC,CAAC,CACzE,CAAC,GACAhB,EAAE,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,EAAED,GAAG,CAACU,KAAK,CAAC,CAAC,GAClCT,EAAE,CAAC,EAAE,CAAC;EAAA,EAAC;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}