{"ast":null,"code":"import { extensions, ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../../filters/FilterEffect.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\"use strict\";\nconst BLEND_MODE_FILTERS = {};\nextensions.handle(ExtensionType.BlendMode, value => {\n  if (!value.name) {\n    throw new Error(\"BlendMode extension must have a name property\");\n  }\n  BLEND_MODE_FILTERS[value.name] = value.ref;\n}, value => {\n  delete BLEND_MODE_FILTERS[value.name];\n});\nclass BlendModePipe {\n  constructor(renderer) {\n    this._isAdvanced = false;\n    this._filterHash = /* @__PURE__ */Object.create(null);\n    this._renderer = renderer;\n  }\n  /**\n   * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.\n   * @param renderable - The renderable we are adding to the instruction set\n   * @param blendMode - The blend mode of the renderable\n   * @param instructionSet - The instruction set we are adding to\n   */\n  setBlendMode(renderable, blendMode, instructionSet) {\n    if (this._activeBlendMode === blendMode) {\n      if (this._isAdvanced) this._renderableList.push(renderable);\n      return;\n    }\n    this._activeBlendMode = blendMode;\n    if (this._isAdvanced) {\n      this._endAdvancedBlendMode(instructionSet);\n    }\n    this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n    if (this._isAdvanced) {\n      this._beginAdvancedBlendMode(instructionSet);\n      this._renderableList.push(renderable);\n    }\n  }\n  _beginAdvancedBlendMode(instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    const blendMode = this._activeBlendMode;\n    if (!BLEND_MODE_FILTERS[blendMode]) {\n      warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);\n      return;\n    }\n    let filterEffect = this._filterHash[blendMode];\n    if (!filterEffect) {\n      filterEffect = this._filterHash[blendMode] = new FilterEffect();\n      filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];\n    }\n    const instruction = {\n      renderPipeId: \"filter\",\n      action: \"pushFilter\",\n      renderables: [],\n      filterEffect,\n      canBundle: false\n    };\n    this._renderableList = instruction.renderables;\n    instructionSet.add(instruction);\n  }\n  _endAdvancedBlendMode(instructionSet) {\n    this._renderableList = null;\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  /**\n   * called when the instruction build process is starting this will reset internally to the default blend mode\n   * @internal\n   * @ignore\n   */\n  buildStart() {\n    this._isAdvanced = false;\n  }\n  /**\n   * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n   * active, we add the final render instructions added to the instruction set\n   * @param instructionSet - The instruction set we are adding to\n   * @internal\n   * @ignore\n   */\n  buildEnd(instructionSet) {\n    if (this._isAdvanced) {\n      this._endAdvancedBlendMode(instructionSet);\n    }\n  }\n  /**\n   * @internal\n   * @ignore\n   */\n  destroy() {\n    this._renderer = null;\n    this._renderableList = null;\n    for (const i in this._filterHash) {\n      this._filterHash[i].destroy();\n    }\n    this._filterHash = null;\n  }\n}\n/** @ignore */\nBlendModePipe.extension = {\n  type: [ExtensionType.WebGLPipes, ExtensionType.WebGPUPipes, ExtensionType.CanvasPipes],\n  name: \"blendMode\"\n};\nexport { BlendModePipe };","map":{"version":3,"names":["BLEND_MODE_FILTERS","extensions","handle","ExtensionType","BlendMode","value","name","Error","ref","BlendModePipe","constructor","renderer","_isAdvanced","_filterHash","Object","create","_renderer","setBlendMode","renderable","blendMode","instructionSet","_activeBlendMode","_renderableList","push","_endAdvancedBlendMode","_beginAdvancedBlendMode","renderPipes","batch","break","warn","filterEffect","FilterEffect","filters","instruction","renderPipeId","action","renderables","canBundle","add","buildStart","buildEnd","destroy","i","extension","type","WebGLPipes","WebGPUPipes","CanvasPipes"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/shared/blendModes/BlendModePipe.ts"],"sourcesContent":["import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { FilterEffect } from '../../../../filters/FilterEffect';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { BlendModeFilter } from '../../../../filters/blend-modes/BlendModeFilter';\nimport type { FilterInstruction } from '../../../../filters/FilterSystem';\nimport type { Renderer } from '../../types';\nimport type { Instruction } from '../instructions/Instruction';\nimport type { InstructionSet } from '../instructions/InstructionSet';\nimport type { InstructionPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { BLEND_MODES } from '../state/const';\n\ninterface AdvancedBlendInstruction extends Instruction\n{\n    renderPipeId: 'blendMode',\n    blendMode: BLEND_MODES,\n    activeBlend: Renderable[],\n}\n\n// class map\nconst BLEND_MODE_FILTERS: Partial<Record<BLEND_MODES, new () => BlendModeFilter>> = {} as const;\n\nextensions.handle(ExtensionType.BlendMode, (value) =>\n{\n    if (!value.name)\n    {\n        throw new Error('BlendMode extension must have a name property');\n    }\n    BLEND_MODE_FILTERS[value.name as BLEND_MODES] = value.ref;\n}, (value) =>\n{\n    delete BLEND_MODE_FILTERS[value.name as BLEND_MODES];\n});\n\n/**\n * This Pipe handles the blend mode switching of the renderer.\n * It will insert instructions into the {@link renderers.InstructionSet} to switch the blend mode according to the\n * blend modes of the scene graph.\n *\n * This pipe is were wwe handle Advanced blend modes. Advanced blend modes essentially wrap the renderables\n * in a filter that applies the blend mode.\n *\n * You only need to use this class if you are building your own render instruction set rather than letting PixiJS build\n * the instruction set for you by traversing the scene graph\n * @memberof rendering\n */\nexport class BlendModePipe implements InstructionPipe<AdvancedBlendInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'blendMode',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _renderableList: Renderable[];\n    private _activeBlendMode: BLEND_MODES;\n\n    private _isAdvanced = false;\n\n    private _filterHash: Partial<Record<BLEND_MODES, FilterEffect>> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.\n     * @param renderable - The renderable we are adding to the instruction set\n     * @param blendMode - The blend mode of the renderable\n     * @param instructionSet - The instruction set we are adding to\n     */\n    public setBlendMode(renderable: Renderable, blendMode: BLEND_MODES, instructionSet: InstructionSet)\n    {\n        if (this._activeBlendMode === blendMode)\n        {\n            if (this._isAdvanced) this._renderableList.push(renderable);\n\n            return;\n        }\n\n        this._activeBlendMode = blendMode;\n\n        if (this._isAdvanced)\n        {\n            this._endAdvancedBlendMode(instructionSet);\n        }\n\n        this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n\n        if (this._isAdvanced)\n        {\n            this._beginAdvancedBlendMode(instructionSet);\n\n            this._renderableList.push(renderable);\n        }\n    }\n\n    private _beginAdvancedBlendMode(instructionSet: InstructionSet)\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        const blendMode = this._activeBlendMode;\n\n        if (!BLEND_MODE_FILTERS[blendMode as keyof typeof BLEND_MODE_FILTERS])\n        {\n            // #if _DEBUG\n            warn(`Unable to assign BlendMode: '${blendMode}'. `\n            + `You may want to include: import 'pixi.js/advanced-blend-modes'`);\n            // #endif\n\n            return;\n        }\n\n        let filterEffect = this._filterHash[blendMode];\n\n        // this does need an execute?\n        if (!filterEffect)\n        {\n            filterEffect = this._filterHash[blendMode] = new FilterEffect();\n\n            filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode as keyof typeof BLEND_MODE_FILTERS]()];\n        }\n\n        const instruction: FilterInstruction = {\n            renderPipeId: 'filter',\n            action: 'pushFilter',\n            renderables: [],\n            filterEffect,\n            canBundle: false,\n        };\n\n        this._renderableList = instruction.renderables;\n        instructionSet.add(instruction);\n    }\n\n    private _endAdvancedBlendMode(instructionSet: InstructionSet)\n    {\n        this._renderableList = null;\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    /**\n     * called when the instruction build process is starting this will reset internally to the default blend mode\n     * @internal\n     * @ignore\n     */\n    public buildStart()\n    {\n        this._isAdvanced = false;\n    }\n\n    /**\n     * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n     * active, we add the final render instructions added to the instruction set\n     * @param instructionSet - The instruction set we are adding to\n     * @internal\n     * @ignore\n     */\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        if (this._isAdvanced)\n        {\n            this._endAdvancedBlendMode(instructionSet);\n        }\n    }\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public destroy()\n    {\n        this._renderer = null;\n        this._renderableList = null;\n\n        for (const i in this._filterHash)\n        {\n            this._filterHash[i as BLEND_MODES].destroy();\n        }\n\n        this._filterHash = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}