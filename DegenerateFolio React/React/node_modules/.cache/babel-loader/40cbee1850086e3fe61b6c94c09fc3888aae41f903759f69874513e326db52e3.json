{"ast":null,"code":"import { compactAddLength, isU8a, stringToU8a, u8aConcat } from '@polkadot/util';\nimport { blake2AsU8a } from '../blake2/asU8a.js';\nconst HDKD = compactAddLength(stringToU8a('Secp256k1HDKD'));\nexport function secp256k1DeriveHard(seed, chainCode) {\n  if (!isU8a(chainCode) || chainCode.length !== 32) {\n    throw new Error('Invalid chainCode passed to derive');\n  }\n  // NOTE This is specific to the Substrate HDD derivation, so always use the blake2 hasher\n  return blake2AsU8a(u8aConcat(HDKD, seed, chainCode), 256);\n}","map":{"version":3,"names":["compactAddLength","isU8a","stringToU8a","u8aConcat","blake2AsU8a","HDKD","secp256k1DeriveHard","seed","chainCode","length","Error"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util-crypto/secp256k1/deriveHard.js"],"sourcesContent":["import { compactAddLength, isU8a, stringToU8a, u8aConcat } from '@polkadot/util';\nimport { blake2AsU8a } from '../blake2/asU8a.js';\nconst HDKD = compactAddLength(stringToU8a('Secp256k1HDKD'));\nexport function secp256k1DeriveHard(seed, chainCode) {\n    if (!isU8a(chainCode) || chainCode.length !== 32) {\n        throw new Error('Invalid chainCode passed to derive');\n    }\n    // NOTE This is specific to the Substrate HDD derivation, so always use the blake2 hasher\n    return blake2AsU8a(u8aConcat(HDKD, seed, chainCode), 256);\n}\n"],"mappings":"AAAA,SAASA,gBAAgB,EAAEC,KAAK,EAAEC,WAAW,EAAEC,SAAS,QAAQ,gBAAgB;AAChF,SAASC,WAAW,QAAQ,oBAAoB;AAChD,MAAMC,IAAI,GAAGL,gBAAgB,CAACE,WAAW,CAAC,eAAe,CAAC,CAAC;AAC3D,OAAO,SAASI,mBAAmBA,CAACC,IAAI,EAAEC,SAAS,EAAE;EACjD,IAAI,CAACP,KAAK,CAACO,SAAS,CAAC,IAAIA,SAAS,CAACC,MAAM,KAAK,EAAE,EAAE;IAC9C,MAAM,IAAIC,KAAK,CAAC,oCAAoC,CAAC;EACzD;EACA;EACA,OAAON,WAAW,CAACD,SAAS,CAACE,IAAI,EAAEE,IAAI,EAAEC,SAAS,CAAC,EAAE,GAAG,CAAC;AAC7D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}