{"ast":null,"code":"import EventEmitter from 'eventemitter3';\nimport { isPow2 } from '../../../../../maths/misc/pow2.mjs';\nimport { definedProps } from '../../../../../scene/container/utils/definedProps.mjs';\nimport { uid } from '../../../../../utils/data/uid.mjs';\nimport { TextureStyle } from '../TextureStyle.mjs';\n\"use strict\";\nconst _TextureSource = class _TextureSource extends EventEmitter {\n  /**\n   * @param options - options for creating a new TextureSource\n   */\n  constructor(options = {}) {\n    super();\n    this.options = options;\n    /** unique id for this Texture source */\n    this.uid = uid(\"textureSource\");\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */\n    this._resourceType = \"textureSource\";\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */\n    this.uploadMethodId = \"unknown\";\n    // dimensions\n    this._resolution = 1;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelHeight = 1;\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    this.width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    this.height = 1;\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */\n    this.sampleCount = 1;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    this.mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    this.autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    this.format = \"rgba8unorm\";\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    this.dimension = \"2d\";\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    this.antialias = false;\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    this._touched = 0;\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    this._batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    this._textureBindLocation = -1;\n    options = {\n      ..._TextureSource.defaultOptions,\n      ...options\n    };\n    this.label = options.label ?? \"\";\n    this.resource = options.resource;\n    this.autoGarbageCollect = options.autoGarbageCollect;\n    this._resolution = options.resolution;\n    if (options.width) {\n      this.pixelWidth = options.width * this._resolution;\n    } else {\n      this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;\n    }\n    if (options.height) {\n      this.pixelHeight = options.height * this._resolution;\n    } else {\n      this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;\n    }\n    this.width = this.pixelWidth / this._resolution;\n    this.height = this.pixelHeight / this._resolution;\n    this.format = options.format;\n    this.dimension = options.dimensions;\n    this.mipLevelCount = options.mipLevelCount;\n    this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n    this.sampleCount = options.sampleCount;\n    this.antialias = options.antialias;\n    this.alphaMode = options.alphaMode;\n    this.style = new TextureStyle(definedProps(options));\n    this.destroyed = false;\n    this._refreshPOT();\n  }\n  /** returns itself */\n  get source() {\n    return this;\n  }\n  /** the style of the texture */\n  get style() {\n    return this._style;\n  }\n  set style(value) {\n    if (this.style === value) return;\n    this._style?.off(\"change\", this._onStyleChange, this);\n    this._style = value;\n    this._style?.on(\"change\", this._onStyleChange, this);\n    this._onStyleChange();\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this._style.addressMode;\n  }\n  set addressMode(value) {\n    this._style.addressMode = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get repeatMode() {\n    return this._style.addressMode;\n  }\n  set repeatMode(value) {\n    this._style.addressMode = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n  get magFilter() {\n    return this._style.magFilter;\n  }\n  set magFilter(value) {\n    this._style.magFilter = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n  get minFilter() {\n    return this._style.minFilter;\n  }\n  set minFilter(value) {\n    this._style.minFilter = value;\n  }\n  /** Specifies behavior for sampling between mipmap levels. */\n  get mipmapFilter() {\n    return this._style.mipmapFilter;\n  }\n  set mipmapFilter(value) {\n    this._style.mipmapFilter = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMinClamp() {\n    return this._style.lodMinClamp;\n  }\n  set lodMinClamp(value) {\n    this._style.lodMinClamp = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMaxClamp() {\n    return this._style.lodMaxClamp;\n  }\n  set lodMaxClamp(value) {\n    this._style.lodMaxClamp = value;\n  }\n  _onStyleChange() {\n    this.emit(\"styleChange\", this);\n  }\n  /** call this if you have modified the texture outside of the constructor */\n  update() {\n    if (this.resource) {\n      const resolution = this._resolution;\n      const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n      if (didResize) return;\n    }\n    this.emit(\"update\", this);\n  }\n  /** Destroys this texture source */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    if (this._style) {\n      this._style.destroy();\n      this._style = null;\n    }\n    this.uploadMethodId = null;\n    this.resource = null;\n    this.removeAllListeners();\n  }\n  /**\n   * This will unload the Texture source from the GPU. This will free up the GPU memory\n   * As soon as it is required fore rendering, it will be re-uploaded.\n   */\n  unload() {\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n    this.emit(\"unload\", this);\n  }\n  /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n  get resourceWidth() {\n    const {\n      resource\n    } = this;\n    return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n  }\n  /** the height of the resource. This is the REAL pure number, not accounting resolution */\n  get resourceHeight() {\n    const {\n      resource\n    } = this;\n    return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n  }\n  /**\n   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n   * but will the size of the texture when rendered.\n   *\n   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n   * density will have increased)\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(resolution) {\n    if (this._resolution === resolution) return;\n    this._resolution = resolution;\n    this.width = this.pixelWidth / resolution;\n    this.height = this.pixelHeight / resolution;\n  }\n  /**\n   * Resize the texture, this is handy if you want to use the texture as a render texture\n   * @param width - the new width of the texture\n   * @param height - the new height of the texture\n   * @param resolution - the new resolution of the texture\n   * @returns - if the texture was resized\n   */\n  resize(width, height, resolution) {\n    resolution = resolution || this._resolution;\n    width = width || this.width;\n    height = height || this.height;\n    const newPixelWidth = Math.round(width * resolution);\n    const newPixelHeight = Math.round(height * resolution);\n    this.width = newPixelWidth / resolution;\n    this.height = newPixelHeight / resolution;\n    this._resolution = resolution;\n    if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {\n      return false;\n    }\n    this._refreshPOT();\n    this.pixelWidth = newPixelWidth;\n    this.pixelHeight = newPixelHeight;\n    this.emit(\"resize\", this);\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n    return true;\n  }\n  /**\n   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n   * This is only important for RenderTexture instances, as standard Texture instances will have their\n   * mipmaps generated on upload. You should call this method after you make any change to the texture\n   *\n   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n   * We want you, the developer to specify when this action should happen.\n   *\n   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n   */\n  updateMipmaps() {\n    if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {\n      this.emit(\"updateMipmaps\", this);\n    }\n  }\n  set wrapMode(value) {\n    this._style.wrapMode = value;\n  }\n  get wrapMode() {\n    return this._style.wrapMode;\n  }\n  set scaleMode(value) {\n    this._style.scaleMode = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this._style.scaleMode;\n  }\n  /**\n   * Refresh check for isPowerOfTwo texture based on size\n   * @private\n   */\n  _refreshPOT() {\n    this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);\n  }\n  static test(_resource) {\n    throw new Error(\"Unimplemented\");\n  }\n};\n/** The default options used when creating a new TextureSource. override these to add your own defaults */\n_TextureSource.defaultOptions = {\n  resolution: 1,\n  format: \"bgra8unorm\",\n  alphaMode: \"premultiply-alpha-on-upload\",\n  dimensions: \"2d\",\n  mipLevelCount: 1,\n  autoGenerateMipmaps: false,\n  sampleCount: 1,\n  antialias: false,\n  autoGarbageCollect: false\n};\nlet TextureSource = _TextureSource;\nexport { TextureSource };","map":{"version":3,"names":["_TextureSource","EventEmitter","constructor","options","uid","_resourceType","_resourceId","uploadMethodId","_resolution","pixelWidth","pixelHeight","width","height","sampleCount","mipLevelCount","autoGenerateMipmaps","format","dimension","antialias","_touched","_batchTick","_textureBindLocation","defaultOptions","label","resource","autoGarbageCollect","resolution","resourceWidth","resourceHeight","dimensions","alphaMode","style","TextureStyle","definedProps","destroyed","_refreshPOT","source","_style","value","off","_onStyleChange","on","addressMode","repeatMode","magFilter","minFilter","mipmapFilter","lodMinClamp","lodMaxClamp","emit","update","didResize","resize","destroy","removeAllListeners","unload","naturalWidth","videoWidth","displayWidth","naturalHeight","videoHeight","displayHeight","newPixelWidth","Math","round","newPixelHeight","updateMipmaps","wrapMode","scaleMode","isPowerOfTwo","isPow2","test","_resource","Error","TextureSource"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/TextureSource.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { isPow2 } from '../../../../../maths/misc/pow2';\nimport { definedProps } from '../../../../../scene/container/utils/definedProps';\nimport { uid } from '../../../../../utils/data/uid';\nimport { TextureStyle } from '../TextureStyle';\n\nimport type { BindResource } from '../../../gpu/shader/BindResource';\nimport type { ALPHA_MODES, SCALE_MODE, TEXTURE_DIMENSIONS, TEXTURE_FORMATS, WRAP_MODE } from '../const';\nimport type { TextureStyleOptions } from '../TextureStyle';\n\n/**\n * options for creating a new TextureSource\n * @memberof rendering\n */\nexport interface TextureSourceOptions<T extends Record<string, any> = any> extends TextureStyleOptions\n{\n    /**\n     * the resource that will be upladed to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    resource?: T;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    width?: number;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    height?: number;\n    /** the resolution of the texture. */\n    resolution?: number;\n    /** the format that the texture data has */\n    format?: TEXTURE_FORMATS;\n    /**\n     * Used by internal textures\n     * @ignore\n     */\n    sampleCount?: number;\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    antialias?: boolean;\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    dimensions?: TEXTURE_DIMENSIONS;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    mipLevelCount?: number;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    autoGenerateMipmaps?: boolean;\n    /** the alpha mode of the texture */\n    alphaMode?: ALPHA_MODES;\n    /** optional label, can be used for debugging */\n    label?: string;\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    autoGarbageCollect?: boolean;\n}\n\n/**\n * A TextureSource stores the information that represents an image.\n * All textures have require TextureSource, which contains information about the source.\n * Therefore you can have many textures all using a single TextureSource (eg a sprite sheet)\n *\n * This is an class is extended depending on the source of the texture.\n * Eg if you are using an an image as your resource, then an ImageSource is used.\n * @memberof rendering\n * @typeParam T - The TextureSource's Resource type.\n */\nexport class TextureSource<T extends Record<string, any> = any> extends EventEmitter<{\n    change: BindResource;\n    update: TextureSource;\n    unload: TextureSource;\n    destroy: TextureSource;\n    resize: TextureSource;\n    styleChange: TextureSource;\n    updateMipmaps: TextureSource;\n    error: Error;\n}> implements BindResource\n{\n    /** The default options used when creating a new TextureSource. override these to add your own defaults */\n    public static defaultOptions: TextureSourceOptions = {\n        resolution: 1,\n        format: 'bgra8unorm',\n        alphaMode: 'premultiply-alpha-on-upload',\n        dimensions: '2d',\n        mipLevelCount: 1,\n        autoGenerateMipmaps: false,\n        sampleCount: 1,\n        antialias: false,\n        autoGarbageCollect: false,\n    };\n\n    /** unique id for this Texture source */\n    public readonly uid = uid('textureSource');\n    /** optional label, can be used for debugging */\n    public label: string;\n\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */\n    public readonly _resourceType = 'textureSource';\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */\n    public _resourceId = uid('resource');\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */\n    public uploadMethodId = 'unknown';\n\n    // dimensions\n    public _resolution = 1;\n\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelHeight = 1;\n\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    public width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    public height = 1;\n\n    /**\n     * the resource that will be upladed to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    public resource: T;\n\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */\n    public sampleCount = 1;\n\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    public mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    public autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    public format: TEXTURE_FORMATS = 'rgba8unorm';\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    public dimension: TEXTURE_DIMENSIONS = '2d';\n    /** the alpha mode of the texture */\n    public alphaMode: ALPHA_MODES;\n    private _style: TextureStyle;\n\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    public antialias = false;\n\n    /**\n     * Has the source been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    public _touched = 0;\n\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    public _batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    public _textureBindLocation = -1;\n\n    public isPowerOfTwo: boolean;\n\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    public autoGarbageCollect: boolean;\n\n    /**\n     * used internally to know where a texture came from. Usually assigned by the asset loader!\n     * @ignore\n     */\n    public _sourceOrigin: string;\n\n    /**\n     * @param options - options for creating a new TextureSource\n     */\n    constructor(protected readonly options: TextureSourceOptions<T> = {})\n    {\n        super();\n\n        options = { ...TextureSource.defaultOptions, ...options };\n\n        this.label = options.label ?? '';\n        this.resource = options.resource;\n        this.autoGarbageCollect = options.autoGarbageCollect;\n        this._resolution = options.resolution;\n\n        if (options.width)\n        {\n            this.pixelWidth = options.width * this._resolution;\n        }\n        else\n        {\n            this.pixelWidth = this.resource ? (this.resourceWidth ?? 1) : 1;\n        }\n\n        if (options.height)\n        {\n            this.pixelHeight = options.height * this._resolution;\n        }\n        else\n        {\n            this.pixelHeight = this.resource ? (this.resourceHeight ?? 1) : 1;\n        }\n\n        this.width = this.pixelWidth / this._resolution;\n        this.height = this.pixelHeight / this._resolution;\n\n        this.format = options.format;\n        this.dimension = options.dimensions;\n        this.mipLevelCount = options.mipLevelCount;\n        this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n        this.sampleCount = options.sampleCount;\n        this.antialias = options.antialias;\n        this.alphaMode = options.alphaMode;\n\n        this.style = new TextureStyle(definedProps(options));\n\n        this.destroyed = false;\n\n        this._refreshPOT();\n    }\n\n    /** returns itself */\n    get source(): TextureSource\n    {\n        return this;\n    }\n\n    /** the style of the texture */\n    get style(): TextureStyle\n    {\n        return this._style;\n    }\n\n    set style(value: TextureStyle)\n    {\n        if (this.style === value) return;\n\n        this._style?.off('change', this._onStyleChange, this);\n        this._style = value;\n        this._style?.on('change', this._onStyleChange, this);\n\n        this._onStyleChange();\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get repeatMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set repeatMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    get magFilter(): SCALE_MODE\n    {\n        return this._style.magFilter;\n    }\n\n    set magFilter(value: SCALE_MODE)\n    {\n        this._style.magFilter = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    get minFilter(): SCALE_MODE\n    {\n        return this._style.minFilter;\n    }\n\n    set minFilter(value: SCALE_MODE)\n    {\n        this._style.minFilter = value;\n    }\n\n    /** Specifies behavior for sampling between mipmap levels. */\n    get mipmapFilter(): SCALE_MODE\n    {\n        return this._style.mipmapFilter;\n    }\n\n    set mipmapFilter(value: SCALE_MODE)\n    {\n        this._style.mipmapFilter = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMinClamp(): number\n    {\n        return this._style.lodMinClamp;\n    }\n\n    set lodMinClamp(value: number)\n    {\n        this._style.lodMinClamp = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMaxClamp(): number\n    {\n        return this._style.lodMaxClamp;\n    }\n\n    set lodMaxClamp(value: number)\n    {\n        this._style.lodMaxClamp = value;\n    }\n\n    private _onStyleChange()\n    {\n        this.emit('styleChange', this);\n    }\n\n    /** call this if you have modified the texture outside of the constructor */\n    public update()\n    {\n        // update resource...\n        if (this.resource)\n        {\n            const resolution = this._resolution;\n\n            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n\n            // no ned to dispatch the update we resized as that will\n            // notify the texture systems anyway\n            if (didResize) return;\n        }\n\n        this.emit('update', this);\n    }\n\n    /** Destroys this texture source */\n    public destroy()\n    {\n        this.destroyed = true;\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        if (this._style)\n        {\n            this._style.destroy();\n            this._style = null;\n        }\n\n        this.uploadMethodId = null;\n        this.resource = null;\n        this.removeAllListeners();\n    }\n\n    /**\n     * This will unload the Texture source from the GPU. This will free up the GPU memory\n     * As soon as it is required fore rendering, it will be re-uploaded.\n     */\n    public unload()\n    {\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n        this.emit('unload', this);\n    }\n\n    /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n    public get resourceWidth(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n    }\n\n    /** the height of the resource. This is the REAL pure number, not accounting resolution */\n    public get resourceHeight(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n    }\n\n    /**\n     * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n     * but will the size of the texture when rendered.\n     *\n     * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n     * density will have increased)\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(resolution: number)\n    {\n        if (this._resolution === resolution) return;\n\n        this._resolution = resolution;\n\n        this.width = this.pixelWidth / resolution;\n        this.height = this.pixelHeight / resolution;\n    }\n\n    /**\n     * Resize the texture, this is handy if you want to use the texture as a render texture\n     * @param width - the new width of the texture\n     * @param height - the new height of the texture\n     * @param resolution - the new resolution of the texture\n     * @returns - if the texture was resized\n     */\n    public resize(width?: number, height?: number, resolution?: number): boolean\n    {\n        resolution = resolution || this._resolution;\n        width = width || this.width;\n        height = height || this.height;\n\n        // make sure we work with rounded pixels\n        const newPixelWidth = Math.round(width * resolution);\n        const newPixelHeight = Math.round(height * resolution);\n\n        this.width = newPixelWidth / resolution;\n        this.height = newPixelHeight / resolution;\n\n        this._resolution = resolution;\n\n        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight)\n        {\n            return false;\n        }\n\n        this._refreshPOT();\n\n        this.pixelWidth = newPixelWidth;\n        this.pixelHeight = newPixelHeight;\n\n        this.emit('resize', this);\n\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n\n        return true;\n    }\n\n    /**\n     * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n     * This is only important for RenderTexture instances, as standard Texture instances will have their\n     * mipmaps generated on upload. You should call this method after you make any change to the texture\n     *\n     * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n     * We want you, the developer to specify when this action should happen.\n     *\n     * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n     */\n    public updateMipmaps()\n    {\n        if (this.autoGenerateMipmaps && this.mipLevelCount > 1)\n        {\n            this.emit('updateMipmaps', this);\n        }\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        this._style.wrapMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this._style.wrapMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this._style.scaleMode = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this._style.scaleMode;\n    }\n\n    /**\n     * Refresh check for isPowerOfTwo texture based on size\n     * @private\n     */\n    protected _refreshPOT(): void\n    {\n        this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);\n    }\n\n    public static test(_resource: any): any\n    {\n        // this should be overridden by other sources..\n        throw new Error('Unimplemented');\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}