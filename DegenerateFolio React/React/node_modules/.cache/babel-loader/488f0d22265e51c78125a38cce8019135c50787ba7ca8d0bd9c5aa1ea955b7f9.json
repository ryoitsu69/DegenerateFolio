{"ast":null,"code":"import { Point } from '../point/Point.mjs';\n\"use strict\";\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\nclass Rectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */\n    this.type = \"rectangle\";\n    this.x = Number(x);\n    this.y = Number(y);\n    this.width = Number(width);\n    this.height = Number(height);\n  }\n  /** Returns the left edge of the rectangle. */\n  get left() {\n    return this.x;\n  }\n  /** Returns the right edge of the rectangle. */\n  get right() {\n    return this.x + this.width;\n  }\n  /** Returns the top edge of the rectangle. */\n  get top() {\n    return this.y;\n  }\n  /** Returns the bottom edge of the rectangle. */\n  get bottom() {\n    return this.y + this.height;\n  }\n  /** Determines whether the Rectangle is empty. */\n  isEmpty() {\n    return this.left === this.right || this.top === this.bottom;\n  }\n  /** A constant empty rectangle. This is a new object every time the property is accessed */\n  static get EMPTY() {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  /**\n   * Creates a clone of this Rectangle\n   * @returns a copy of the rectangle\n   */\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  /**\n   * Converts a Bounds object to a Rectangle object.\n   * @param bounds - The bounds to copy and convert to a rectangle.\n   * @returns Returns itself.\n   */\n  copyFromBounds(bounds) {\n    this.x = bounds.minX;\n    this.y = bounds.minY;\n    this.width = bounds.maxX - bounds.minX;\n    this.height = bounds.maxY - bounds.minY;\n    return this;\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x < this.x + this.width) {\n      if (y >= this.y && y < this.y + this.height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(x, y, strokeWidth) {\n    const {\n      width,\n      height\n    } = this;\n    if (width <= 0 || height <= 0) return false;\n    const _x = this.x;\n    const _y = this.y;\n    const outerLeft = _x - strokeWidth / 2;\n    const outerRight = _x + width + strokeWidth / 2;\n    const outerTop = _y - strokeWidth / 2;\n    const outerBottom = _y + height + strokeWidth / 2;\n    const innerLeft = _x + strokeWidth / 2;\n    const innerRight = _x + width - strokeWidth / 2;\n    const innerTop = _y + strokeWidth / 2;\n    const innerBottom = _y + height - strokeWidth / 2;\n    return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n  }\n  /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can't intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */\n  intersects(other, transform) {\n    if (!transform) {\n      const x02 = this.x < other.x ? other.x : this.x;\n      const x12 = this.right > other.right ? other.right : this.right;\n      if (x12 <= x02) {\n        return false;\n      }\n      const y02 = this.y < other.y ? other.y : this.y;\n      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n      return y12 > y02;\n    }\n    const x0 = this.left;\n    const x1 = this.right;\n    const y0 = this.top;\n    const y1 = this.bottom;\n    if (x1 <= x0 || y1 <= y0) {\n      return false;\n    }\n    const lt = tempPoints[0].set(other.left, other.top);\n    const lb = tempPoints[1].set(other.left, other.bottom);\n    const rt = tempPoints[2].set(other.right, other.top);\n    const rb = tempPoints[3].set(other.right, other.bottom);\n    if (rt.x <= lt.x || lb.y <= lt.y) {\n      return false;\n    }\n    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n    if (s === 0) {\n      return false;\n    }\n    transform.apply(lt, lt);\n    transform.apply(lb, lb);\n    transform.apply(rt, rt);\n    transform.apply(rb, rb);\n    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {\n      return false;\n    }\n    const nx = s * (lb.y - lt.y);\n    const ny = s * (lt.x - lb.x);\n    const n00 = nx * x0 + ny * y0;\n    const n10 = nx * x1 + ny * y0;\n    const n01 = nx * x0 + ny * y1;\n    const n11 = nx * x1 + ny * y1;\n    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {\n      return false;\n    }\n    const mx = s * (lt.y - rt.y);\n    const my = s * (rt.x - lt.x);\n    const m00 = mx * x0 + my * y0;\n    const m10 = mx * x1 + my * y0;\n    const m01 = mx * x0 + my * y1;\n    const m11 = mx * x1 + my * y1;\n    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Pads the rectangle making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   * @returns Returns itself.\n   */\n  pad(paddingX = 0, paddingY = paddingX) {\n    this.x -= paddingX;\n    this.y -= paddingY;\n    this.width += paddingX * 2;\n    this.height += paddingY * 2;\n    return this;\n  }\n  /**\n   * Fits this rectangle around the passed one.\n   * @param rectangle - The rectangle to fit.\n   * @returns Returns itself.\n   */\n  fit(rectangle) {\n    const x1 = Math.max(this.x, rectangle.x);\n    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.max(this.y, rectangle.y);\n    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = Math.max(x2 - x1, 0);\n    this.y = y1;\n    this.height = Math.max(y2 - y1, 0);\n    return this;\n  }\n  /**\n   * Enlarges rectangle that way its corners lie on grid\n   * @param resolution - resolution\n   * @param eps - precision\n   * @returns Returns itself.\n   */\n  ceil(resolution = 1, eps = 1e-3) {\n    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n    this.x = Math.floor((this.x + eps) * resolution) / resolution;\n    this.y = Math.floor((this.y + eps) * resolution) / resolution;\n    this.width = x2 - this.x;\n    this.height = y2 - this.y;\n    return this;\n  }\n  /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @param rectangle - The rectangle to include.\n   * @returns Returns itself.\n   */\n  enlarge(rectangle) {\n    const x1 = Math.min(this.x, rectangle.x);\n    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.min(this.y, rectangle.y);\n    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = x2 - x1;\n    this.y = y1;\n    this.height = y2 - y1;\n    return this;\n  }\n  /**\n   * Returns the framing rectangle of the rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle();\n    out.copyFrom(this);\n    return out;\n  }\n  toString() {\n    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n  }\n}\nexport { Rectangle };","map":{"version":3,"names":["tempPoints","Point","Rectangle","constructor","x","y","width","height","type","Number","left","right","top","bottom","isEmpty","EMPTY","clone","copyFromBounds","bounds","minX","minY","maxX","maxY","copyFrom","rectangle","copyTo","contains","strokeContains","strokeWidth","_x","_y","outerLeft","outerRight","outerTop","outerBottom","innerLeft","innerRight","innerTop","innerBottom","intersects","other","transform","x02","x12","y02","y12","x0","x1","y0","y1","lt","set","lb","rt","rb","s","Math","sign","a","d","b","c","apply","max","min","nx","ny","n00","n10","n01","n11","mx","my","m00","m10","m01","m11","pad","paddingX","paddingY","fit","x2","y2","ceil","resolution","eps","floor","enlarge","getBounds","out","toString"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/maths/shapes/Rectangle.ts"],"sourcesContent":["// import { SHAPES } from '../const';\nimport { Point } from '../point/Point';\n\nimport type { Bounds } from '../../scene/container/bounds/Bounds';\nimport type { Matrix } from '../matrix/Matrix';\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Rectangle extends PixiMixins.Rectangle { }\n\n/**\n * The `Rectangle` object is an area defined by its position, as indicated by its top-left corner\n * point (`x`, `y`) and by its `width` and its `height`.\n *\n * It also provides convenience methods to get and set the position and size of the rectangle such as\n * {@link maths.Rectangle#bottom|bottom}, {@link maths.Rectangle#right|right} and {@link maths.Rectangle#isEmpty|isEmpty}.\n * @memberof maths\n */\nexport class Rectangle implements ShapePrimitive\n{\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'rectangle';\n\n    /**\n     * The X coordinate of the upper-left corner of the rectangle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rectangle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rectangle\n     *  @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rectangle\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rectangle\n     * @param width - The overall width of the rectangle\n     * @param height - The overall height of the rectangle\n     */\n    constructor(x: string | number = 0, y: string | number = 0, width: string | number = 0, height: string | number = 0)\n    {\n        this.x = Number(x);\n        this.y = Number(y);\n        this.width = Number(width);\n        this.height = Number(height);\n    }\n\n    /** Returns the left edge of the rectangle. */\n    get left(): number\n    {\n        return this.x;\n    }\n\n    /** Returns the right edge of the rectangle. */\n    get right(): number\n    {\n        return this.x + this.width;\n    }\n\n    /** Returns the top edge of the rectangle. */\n    get top(): number\n    {\n        return this.y;\n    }\n\n    /** Returns the bottom edge of the rectangle. */\n    get bottom(): number\n    {\n        return this.y + this.height;\n    }\n\n    /** Determines whether the Rectangle is empty. */\n    public isEmpty(): boolean\n    {\n        return this.left === this.right || this.top === this.bottom;\n    }\n\n    /** A constant empty rectangle. This is a new object every time the property is accessed */\n    static get EMPTY(): Rectangle\n    {\n        return new Rectangle(0, 0, 0, 0);\n    }\n\n    /**\n     * Creates a clone of this Rectangle\n     * @returns a copy of the rectangle\n     */\n    public clone(): Rectangle\n    {\n        return new Rectangle(this.x, this.y, this.width, this.height);\n    }\n\n    /**\n     * Converts a Bounds object to a Rectangle object.\n     * @param bounds - The bounds to copy and convert to a rectangle.\n     * @returns Returns itself.\n     */\n    public copyFromBounds(bounds: Bounds): this\n    {\n        this.x = bounds.minX;\n        this.y = bounds.minY;\n        this.width = bounds.maxX - bounds.minX;\n        this.height = bounds.maxY - bounds.minY;\n\n        return this;\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @param rectangle - The rectangle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(rectangle: Rectangle): Rectangle\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @param rectangle - The rectangle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(rectangle: Rectangle): Rectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rectangle\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Rectangle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n\n        if (x >= this.x && x < this.x + this.width)\n        {\n            if (y >= this.y && y < this.y + this.height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @returns Whether the x/y coordinates are within this rectangle\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number): boolean\n    {\n        const { width, height } = this;\n\n        if (width <= 0 || height <= 0) return false;\n\n        const _x = this.x;\n        const _y = this.y;\n\n        const outerLeft = _x - (strokeWidth / 2);\n        const outerRight = _x + width + (strokeWidth / 2);\n        const outerTop = _y - (strokeWidth / 2);\n        const outerBottom = _y + height + (strokeWidth / 2);\n        const innerLeft = _x + (strokeWidth / 2);\n        const innerRight = _x + width - (strokeWidth / 2);\n        const innerTop = _y + (strokeWidth / 2);\n        const innerBottom = _y + height - (strokeWidth / 2);\n\n        return (x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom)\n        && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n    }\n    /**\n     * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n     * Returns true only if the area of the intersection is >0, this means that Rectangles\n     * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n     * (width or height equal to zero) can't intersect any other rectangle.\n     * @param {Rectangle} other - The Rectangle to intersect with `this`.\n     * @param {Matrix} transform - The transformation matrix of `other`.\n     * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n     */\n    public intersects(other: Rectangle, transform?: Matrix): boolean\n    {\n        if (!transform)\n        {\n            const x0 = this.x < other.x ? other.x : this.x;\n            const x1 = this.right > other.right ? other.right : this.right;\n\n            if (x1 <= x0)\n            {\n                return false;\n            }\n\n            const y0 = this.y < other.y ? other.y : this.y;\n            const y1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n\n            return y1 > y0;\n        }\n\n        const x0 = this.left;\n        const x1 = this.right;\n        const y0 = this.top;\n        const y1 = this.bottom;\n\n        if (x1 <= x0 || y1 <= y0)\n        {\n            return false;\n        }\n\n        const lt = tempPoints[0].set(other.left, other.top);\n        const lb = tempPoints[1].set(other.left, other.bottom);\n        const rt = tempPoints[2].set(other.right, other.top);\n        const rb = tempPoints[3].set(other.right, other.bottom);\n\n        if (rt.x <= lt.x || lb.y <= lt.y)\n        {\n            return false;\n        }\n\n        const s = Math.sign((transform.a * transform.d) - (transform.b * transform.c));\n\n        if (s === 0)\n        {\n            return false;\n        }\n\n        transform.apply(lt, lt);\n        transform.apply(lb, lb);\n        transform.apply(rt, rt);\n        transform.apply(rb, rb);\n\n        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0\n            || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1\n            || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0\n            || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1)\n        {\n            return false;\n        }\n\n        const nx = s * (lb.y - lt.y);\n        const ny = s * (lt.x - lb.x);\n        const n00 = (nx * x0) + (ny * y0);\n        const n10 = (nx * x1) + (ny * y0);\n        const n01 = (nx * x0) + (ny * y1);\n        const n11 = (nx * x1) + (ny * y1);\n\n        if (Math.max(n00, n10, n01, n11) <= (nx * lt.x) + (ny * lt.y)\n            || Math.min(n00, n10, n01, n11) >= (nx * rb.x) + (ny * rb.y))\n        {\n            return false;\n        }\n\n        const mx = s * (lt.y - rt.y);\n        const my = s * (rt.x - lt.x);\n        const m00 = (mx * x0) + (my * y0);\n        const m10 = (mx * x1) + (my * y0);\n        const m01 = (mx * x0) + (my * y1);\n        const m11 = (mx * x1) + (my * y1);\n\n        if (Math.max(m00, m10, m01, m11) <= (mx * lt.x) + (my * lt.y)\n            || Math.min(m00, m10, m01, m11) >= (mx * rb.x) + (my * rb.y))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Pads the rectangle making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     * @returns Returns itself.\n     */\n    public pad(paddingX = 0, paddingY = paddingX): this\n    {\n        this.x -= paddingX;\n        this.y -= paddingY;\n\n        this.width += paddingX * 2;\n        this.height += paddingY * 2;\n\n        return this;\n    }\n\n    /**\n     * Fits this rectangle around the passed one.\n     * @param rectangle - The rectangle to fit.\n     * @returns Returns itself.\n     */\n    public fit(rectangle: Rectangle): this\n    {\n        const x1 = Math.max(this.x, rectangle.x);\n        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.max(this.y, rectangle.y);\n        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = Math.max(x2 - x1, 0);\n        this.y = y1;\n        this.height = Math.max(y2 - y1, 0);\n\n        return this;\n    }\n\n    /**\n     * Enlarges rectangle that way its corners lie on grid\n     * @param resolution - resolution\n     * @param eps - precision\n     * @returns Returns itself.\n     */\n    public ceil(resolution = 1, eps = 0.001): this\n    {\n        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n\n        this.x = Math.floor((this.x + eps) * resolution) / resolution;\n        this.y = Math.floor((this.y + eps) * resolution) / resolution;\n\n        this.width = x2 - this.x;\n        this.height = y2 - this.y;\n\n        return this;\n    }\n\n    /**\n     * Enlarges this rectangle to include the passed rectangle.\n     * @param rectangle - The rectangle to include.\n     * @returns Returns itself.\n     */\n    public enlarge(rectangle: Rectangle): this\n    {\n        const x1 = Math.min(this.x, rectangle.x);\n        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.min(this.y, rectangle.y);\n        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = x2 - x1;\n        this.y = y1;\n        this.height = y2 - y1;\n\n        return this;\n    }\n\n    /**\n     * Returns the framing rectangle of the rectangle as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n        out.copyFrom(this);\n\n        return out;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n    }\n    // #endif\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}