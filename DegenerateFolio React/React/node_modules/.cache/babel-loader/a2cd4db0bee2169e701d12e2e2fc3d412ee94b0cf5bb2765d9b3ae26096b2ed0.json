{"ast":null,"code":"import { Matrix, ObjectRenderer, QuadUv, State, Shader, WRAP_MODES, Color, utils, ExtensionType, extensions } from \"@pixi/core\";\nimport gl2FragmentSrc from \"./sprite-tiling.frag.mjs\";\nimport gl2VertexSrc from \"./sprite-tiling.vert.mjs\";\nimport gl1FragmentSrc from \"./sprite-tiling-fallback.frag.mjs\";\nimport gl1VertexSrc from \"./sprite-tiling-fallback.vert.mjs\";\nimport fragmentSimpleSrc from \"./sprite-tiling-simple.frag.mjs\";\nconst tempMat = new Matrix();\nclass TilingSpriteRenderer extends ObjectRenderer {\n  /**\n   * constructor for renderer\n   * @param {PIXI.Renderer} renderer - The renderer this tiling awesomeness works for.\n   */\n  constructor(renderer) {\n    super(renderer), renderer.runners.contextChange.add(this), this.quad = new QuadUv(), this.state = State.for2d();\n  }\n  /** Creates shaders when context is initialized. */\n  contextChange() {\n    const renderer = this.renderer,\n      uniforms = {\n        globals: renderer.globalUniforms\n      };\n    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms), this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);\n  }\n  /**\n   * @param {PIXI.TilingSprite} ts - tilingSprite to be rendered\n   */\n  render(ts) {\n    const renderer = this.renderer,\n      quad = this.quad;\n    let vertices = quad.vertices;\n    vertices[0] = vertices[6] = ts._width * -ts.anchor.x, vertices[1] = vertices[3] = ts._height * -ts.anchor.y, vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x), vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);\n    const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0,\n      anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;\n    vertices = quad.uvs, vertices[0] = vertices[6] = -anchorX, vertices[1] = vertices[3] = -anchorY, vertices[2] = vertices[4] = 1 - anchorX, vertices[5] = vertices[7] = 1 - anchorY, quad.invalidate();\n    const tex = ts._texture,\n      baseTex = tex.baseTexture,\n      premultiplied = baseTex.alphaMode > 0,\n      lt = ts.tileTransform.localTransform,\n      uv = ts.uvMatrix;\n    let isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n    isSimple && (baseTex._glTextures[renderer.CONTEXT_UID] ? isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP : baseTex.wrapMode === WRAP_MODES.CLAMP && (baseTex.wrapMode = WRAP_MODES.REPEAT));\n    const shader = isSimple ? this.simpleShader : this.shader,\n      w = tex.width,\n      h = tex.height,\n      W = ts._width,\n      H = ts._height;\n    tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H), tempMat.invert(), isSimple ? tempMat.prepend(uv.mapCoord) : (shader.uniforms.uMapCoord = uv.mapCoord.toArray(!0), shader.uniforms.uClampFrame = uv.uClampFrame, shader.uniforms.uClampOffset = uv.uClampOffset), shader.uniforms.uTransform = tempMat.toArray(!0), shader.uniforms.uColor = Color.shared.setValue(ts.tint).premultiply(ts.worldAlpha, premultiplied).toArray(shader.uniforms.uColor), shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(!0), shader.uniforms.uSampler = tex, renderer.shader.bind(shader), renderer.geometry.bind(quad), this.state.blendMode = utils.correctBlendMode(ts.blendMode, premultiplied), renderer.state.set(this.state), renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n  }\n}\nTilingSpriteRenderer.extension = {\n  name: \"tilingSprite\",\n  type: ExtensionType.RendererPlugin\n};\nextensions.add(TilingSpriteRenderer);\nexport { TilingSpriteRenderer };","map":{"version":3,"names":["tempMat","Matrix","TilingSpriteRenderer","ObjectRenderer","constructor","renderer","runners","contextChange","add","quad","QuadUv","state","State","for2d","uniforms","globals","globalUniforms","simpleShader","Shader","from","gl1VertexSrc","fragmentSimpleSrc","shader","context","webGLVersion","gl2VertexSrc","gl2FragmentSrc","gl1FragmentSrc","render","ts","vertices","_width","anchor","x","_height","y","anchorX","uvRespectAnchor","anchorY","uvs","invalidate","tex","_texture","baseTex","baseTexture","premultiplied","alphaMode","lt","tileTransform","localTransform","uv","uvMatrix","isSimple","isPowerOfTwo","frame","width","height","_glTextures","CONTEXT_UID","wrapMode","WRAP_MODES","CLAMP","REPEAT","w","h","W","H","set","a","b","c","d","tx","ty","invert","prepend","mapCoord","uMapCoord","toArray","uClampFrame","uClampOffset","uTransform","uColor","Color","shared","setValue","tint","premultiply","worldAlpha","translationMatrix","transform","worldTransform","uSampler","bind","geometry","blendMode","utils","correctBlendMode","draw","gl","TRIANGLES","extension","name","type","ExtensionType","RendererPlugin","extensions"],"sources":["/home/ryoitsu/node_modules/@pixi/sprite-tiling/src/TilingSpriteRenderer.ts"],"sourcesContent":["import {\n    Color,\n    extensions,\n    ExtensionType,\n    Matrix,\n    ObjectRenderer,\n    QuadUv,\n    Shader,\n    State,\n    utils,\n    WRAP_MODES\n} from '@pixi/core';\nimport gl2FragmentSrc from './sprite-tiling.frag';\nimport gl2VertexSrc from './sprite-tiling.vert';\nimport gl1FragmentSrc from './sprite-tiling-fallback.frag';\nimport gl1VertexSrc from './sprite-tiling-fallback.vert';\nimport fragmentSimpleSrc from './sprite-tiling-simple.frag';\n\nimport type { ExtensionMetadata, Renderer } from '@pixi/core';\nimport type { TilingSprite } from './TilingSprite';\n\nconst tempMat = new Matrix();\n\n/**\n * WebGL renderer plugin for tiling sprites\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nexport class TilingSpriteRenderer extends ObjectRenderer\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'tilingSprite',\n        type: ExtensionType.RendererPlugin,\n    };\n\n    public shader: Shader;\n    public simpleShader: Shader;\n    public quad: QuadUv;\n    public readonly state: State;\n\n    /**\n     * constructor for renderer\n     * @param {PIXI.Renderer} renderer - The renderer this tiling awesomeness works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        // WebGL version is not available during initialization!\n        renderer.runners.contextChange.add(this);\n\n        this.quad = new QuadUv();\n\n        /**\n         * The WebGL state in which this renderer will work.\n         * @member {PIXI.State}\n         * @readonly\n         */\n        this.state = State.for2d();\n    }\n\n    /** Creates shaders when context is initialized. */\n    contextChange(): void\n    {\n        const renderer = this.renderer;\n        const uniforms = { globals: renderer.globalUniforms };\n\n        this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);\n        this.shader = renderer.context.webGLVersion > 1\n            ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms)\n            : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);\n    }\n\n    /**\n     * @param {PIXI.TilingSprite} ts - tilingSprite to be rendered\n     */\n    public render(ts: TilingSprite): void\n    {\n        const renderer = this.renderer;\n        const quad = this.quad;\n\n        let vertices = quad.vertices;\n\n        vertices[0] = vertices[6] = (ts._width) * -ts.anchor.x;\n        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n\n        vertices[2] = vertices[4] = (ts._width) * (1.0 - ts.anchor.x);\n        vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);\n\n        const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;\n        const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;\n\n        vertices = quad.uvs;\n\n        vertices[0] = vertices[6] = -anchorX;\n        vertices[1] = vertices[3] = -anchorY;\n\n        vertices[2] = vertices[4] = 1.0 - anchorX;\n        vertices[5] = vertices[7] = 1.0 - anchorY;\n\n        quad.invalidate();\n\n        const tex = ts._texture;\n        const baseTex = tex.baseTexture;\n        const premultiplied = baseTex.alphaMode > 0;\n        const lt = ts.tileTransform.localTransform;\n        const uv = ts.uvMatrix;\n        let isSimple = baseTex.isPowerOfTwo\n            && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n\n        // auto, force repeat wrapMode for big tiling textures\n        if (isSimple)\n        {\n            if (!baseTex._glTextures[renderer.CONTEXT_UID])\n            {\n                if (baseTex.wrapMode === WRAP_MODES.CLAMP)\n                {\n                    baseTex.wrapMode = WRAP_MODES.REPEAT;\n                }\n            }\n            else\n            {\n                isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;\n            }\n        }\n\n        const shader = isSimple ? this.simpleShader : this.shader;\n\n        const w = tex.width;\n        const h = tex.height;\n        const W = ts._width;\n        const H = ts._height;\n\n        tempMat.set(lt.a * w / W,\n            lt.b * w / H,\n            lt.c * h / W,\n            lt.d * h / H,\n            lt.tx / W,\n            lt.ty / H);\n\n        // that part is the same as above:\n        // tempMat.identity();\n        // tempMat.scale(tex.width, tex.height);\n        // tempMat.prepend(lt);\n        // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\n\n        tempMat.invert();\n        if (isSimple)\n        {\n            tempMat.prepend(uv.mapCoord);\n        }\n        else\n        {\n            shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n            shader.uniforms.uClampFrame = uv.uClampFrame;\n            shader.uniforms.uClampOffset = uv.uClampOffset;\n        }\n\n        shader.uniforms.uTransform = tempMat.toArray(true);\n        shader.uniforms.uColor = Color.shared\n            .setValue(ts.tint)\n            .premultiply(ts.worldAlpha, premultiplied)\n            .toArray(shader.uniforms.uColor);\n\n        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n        shader.uniforms.uSampler = tex;\n\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(quad);\n\n        this.state.blendMode = utils.correctBlendMode(ts.blendMode, premultiplied);\n        renderer.state.set(this.state);\n        renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n    }\n}\n\nextensions.add(TilingSpriteRenderer);\n"],"mappings":";;;;;;AAqBA,MAAMA,OAAA,GAAU,IAAIC,MAAA;AAQb,MAAMC,oBAAA,SAA6BC,cAAA,CAC1C;EAAA;AAAA;AAAA;AAAA;EAgBIC,YAAYC,QAAA,EACZ;IACI,MAAMA,QAAQ,GAGdA,QAAA,CAASC,OAAA,CAAQC,aAAA,CAAcC,GAAA,CAAI,IAAI,GAEvC,KAAKC,IAAA,GAAO,IAAIC,MAAA,CAAO,GAOvB,KAAKC,KAAA,GAAQC,KAAA,CAAMC,KAAA,CAAM;EAC7B;EAAA;EAGAN,cAAA,EACA;IACI,MAAMF,QAAA,GAAW,KAAKA,QAAA;MAChBS,QAAA,GAAW;QAAEC,OAAA,EAASV,QAAA,CAASW;MAAA;IAEhC,KAAAC,YAAA,GAAeC,MAAA,CAAOC,IAAA,CAAKC,YAAA,EAAcC,iBAAA,EAAmBP,QAAQ,GACzE,KAAKQ,MAAA,GAASjB,QAAA,CAASkB,OAAA,CAAQC,YAAA,GAAe,IACxCN,MAAA,CAAOC,IAAA,CAAKM,YAAA,EAAcC,cAAA,EAAgBZ,QAAQ,IAClDI,MAAA,CAAOC,IAAA,CAAKC,YAAA,EAAcO,cAAA,EAAgBb,QAAQ;EAC5D;EAAA;AAAA;AAAA;EAKOc,OAAOC,EAAA,EACd;IACI,MAAMxB,QAAA,GAAW,KAAKA,QAAA;MAChBI,IAAA,GAAO,KAAKA,IAAA;IAElB,IAAIqB,QAAA,GAAWrB,IAAA,CAAKqB,QAAA;IAEXA,QAAA,EAAC,IAAIA,QAAA,CAAS,CAAC,IAAKD,EAAA,CAAGE,MAAA,GAAU,CAACF,EAAA,CAAGG,MAAA,CAAOC,CAAA,EACrDH,QAAA,CAAS,CAAC,IAAIA,QAAA,CAAS,CAAC,IAAID,EAAA,CAAGK,OAAA,GAAU,CAACL,EAAA,CAAGG,MAAA,CAAOG,CAAA,EAEpDL,QAAA,CAAS,CAAC,IAAIA,QAAA,CAAS,CAAC,IAAKD,EAAA,CAAGE,MAAA,IAAW,IAAMF,EAAA,CAAGG,MAAA,CAAOC,CAAA,GAC3DH,QAAA,CAAS,CAAC,IAAIA,QAAA,CAAS,CAAC,IAAID,EAAA,CAAGK,OAAA,IAAW,IAAML,EAAA,CAAGG,MAAA,CAAOG,CAAA;IAE1D,MAAMC,OAAA,GAAUP,EAAA,CAAGQ,eAAA,GAAkBR,EAAA,CAAGG,MAAA,CAAOC,CAAA,GAAI;MAC7CK,OAAA,GAAUT,EAAA,CAAGQ,eAAA,GAAkBR,EAAA,CAAGG,MAAA,CAAOG,CAAA,GAAI;IAEnDL,QAAA,GAAWrB,IAAA,CAAK8B,GAAA,EAEhBT,QAAA,CAAS,CAAC,IAAIA,QAAA,CAAS,CAAC,IAAI,CAACM,OAAA,EAC7BN,QAAA,CAAS,CAAC,IAAIA,QAAA,CAAS,CAAC,IAAI,CAACQ,OAAA,EAE7BR,QAAA,CAAS,CAAC,IAAIA,QAAA,CAAS,CAAC,IAAI,IAAMM,OAAA,EAClCN,QAAA,CAAS,CAAC,IAAIA,QAAA,CAAS,CAAC,IAAI,IAAMQ,OAAA,EAElC7B,IAAA,CAAK+B,UAAA;IAEL,MAAMC,GAAA,GAAMZ,EAAA,CAAGa,QAAA;MACTC,OAAA,GAAUF,GAAA,CAAIG,WAAA;MACdC,aAAA,GAAgBF,OAAA,CAAQG,SAAA,GAAY;MACpCC,EAAA,GAAKlB,EAAA,CAAGmB,aAAA,CAAcC,cAAA;MACtBC,EAAA,GAAKrB,EAAA,CAAGsB,QAAA;IACV,IAAAC,QAAA,GAAWT,OAAA,CAAQU,YAAA,IAChBZ,GAAA,CAAIa,KAAA,CAAMC,KAAA,KAAUZ,OAAA,CAAQY,KAAA,IAASd,GAAA,CAAIa,KAAA,CAAME,MAAA,KAAWb,OAAA,CAAQa,MAAA;IAGrEJ,QAAA,KAEKT,OAAA,CAAQc,WAAA,CAAYpD,QAAA,CAASqD,WAAW,IASzCN,QAAA,GAAWT,OAAA,CAAQgB,QAAA,KAAaC,UAAA,CAAWC,KAAA,GAPvClB,OAAA,CAAQgB,QAAA,KAAaC,UAAA,CAAWC,KAAA,KAEhClB,OAAA,CAAQgB,QAAA,GAAWC,UAAA,CAAWE,MAAA;IAS1C,MAAMxC,MAAA,GAAS8B,QAAA,GAAW,KAAKnC,YAAA,GAAe,KAAKK,MAAA;MAE7CyC,CAAA,GAAItB,GAAA,CAAIc,KAAA;MACRS,CAAA,GAAIvB,GAAA,CAAIe,MAAA;MACRS,CAAA,GAAIpC,EAAA,CAAGE,MAAA;MACPmC,CAAA,GAAIrC,EAAA,CAAGK,OAAA;IAELlC,OAAA,CAAAmE,GAAA,CAAIpB,EAAA,CAAGqB,CAAA,GAAIL,CAAA,GAAIE,CAAA,EACnBlB,EAAA,CAAGsB,CAAA,GAAIN,CAAA,GAAIG,CAAA,EACXnB,EAAA,CAAGuB,CAAA,GAAIN,CAAA,GAAIC,CAAA,EACXlB,EAAA,CAAGwB,CAAA,GAAIP,CAAA,GAAIE,CAAA,EACXnB,EAAA,CAAGyB,EAAA,GAAKP,CAAA,EACRlB,EAAA,CAAG0B,EAAA,GAAKP,CAAC,GAQblE,OAAA,CAAQ0E,MAAA,IACJtB,QAAA,GAEApD,OAAA,CAAQ2E,OAAA,CAAQzB,EAAA,CAAG0B,QAAQ,KAI3BtD,MAAA,CAAOR,QAAA,CAAS+D,SAAA,GAAY3B,EAAA,CAAG0B,QAAA,CAASE,OAAA,CAAQ,EAAI,GACpDxD,MAAA,CAAOR,QAAA,CAASiE,WAAA,GAAc7B,EAAA,CAAG6B,WAAA,EACjCzD,MAAA,CAAOR,QAAA,CAASkE,YAAA,GAAe9B,EAAA,CAAG8B,YAAA,GAGtC1D,MAAA,CAAOR,QAAA,CAASmE,UAAA,GAAajF,OAAA,CAAQ8E,OAAA,CAAQ,EAAI,GACjDxD,MAAA,CAAOR,QAAA,CAASoE,MAAA,GAASC,KAAA,CAAMC,MAAA,CAC1BC,QAAA,CAASxD,EAAA,CAAGyD,IAAI,EAChBC,WAAA,CAAY1D,EAAA,CAAG2D,UAAA,EAAY3C,aAAa,EACxCiC,OAAA,CAAQxD,MAAA,CAAOR,QAAA,CAASoE,MAAM,GAEnC5D,MAAA,CAAOR,QAAA,CAAS2E,iBAAA,GAAoB5D,EAAA,CAAG6D,SAAA,CAAUC,cAAA,CAAeb,OAAA,CAAQ,EAAI,GAC5ExD,MAAA,CAAOR,QAAA,CAAS8E,QAAA,GAAWnD,GAAA,EAE3BpC,QAAA,CAASiB,MAAA,CAAOuE,IAAA,CAAKvE,MAAM,GAC3BjB,QAAA,CAASyF,QAAA,CAASD,IAAA,CAAKpF,IAAI,GAE3B,KAAKE,KAAA,CAAMoF,SAAA,GAAYC,KAAA,CAAMC,gBAAA,CAAiBpE,EAAA,CAAGkE,SAAA,EAAWlD,aAAa,GACzExC,QAAA,CAASM,KAAA,CAAMwD,GAAA,CAAI,KAAKxD,KAAK,GAC7BN,QAAA,CAASyF,QAAA,CAASI,IAAA,CAAK,KAAK7F,QAAA,CAAS8F,EAAA,CAAGC,SAAA,EAAW,GAAG,CAAC;EAC3D;AACJ;AAnJalG,oBAAA,CAGFmG,SAAA,GAA+B;EAClCC,IAAA,EAAM;EACNC,IAAA,EAAMC,aAAA,CAAcC;AACxB;AA+IJC,UAAA,CAAWlG,GAAA,CAAIN,oBAAoB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}