{"ast":null,"code":"\"use strict\";\n\nclass BindGroup {\n  /**\n   * Create a new instance eof the Bind Group.\n   * @param resources - The resources that are bound together for use by a shader.\n   */\n  constructor(resources) {\n    /** The resources that are bound together for use by a shader. */\n    this.resources = /* @__PURE__ */Object.create(null);\n    this._dirty = true;\n    let index = 0;\n    for (const i in resources) {\n      const resource = resources[i];\n      this.setResource(resource, index++);\n    }\n    this._updateKey();\n  }\n  /**\n   * Updates the key if its flagged as dirty. This is used internally to\n   * match this bind group to a WebGPU BindGroup.\n   * @internal\n   * @ignore\n   */\n  _updateKey() {\n    if (!this._dirty) return;\n    this._dirty = false;\n    const keyParts = [];\n    let index = 0;\n    for (const i in this.resources) {\n      keyParts[index++] = this.resources[i]._resourceId;\n    }\n    this._key = keyParts.join(\"|\");\n  }\n  /**\n   * Set a resource at a given index. this function will\n   * ensure that listeners will be removed from the current resource\n   * and added to the new resource.\n   * @param resource - The resource to set.\n   * @param index - The index to set the resource at.\n   */\n  setResource(resource, index) {\n    const currentResource = this.resources[index];\n    if (resource === currentResource) return;\n    if (currentResource) {\n      resource.off?.(\"change\", this.onResourceChange, this);\n    }\n    resource.on?.(\"change\", this.onResourceChange, this);\n    this.resources[index] = resource;\n    this._dirty = true;\n  }\n  /**\n   * Returns the resource at the current specified index.\n   * @param index - The index of the resource to get.\n   * @returns - The resource at the specified index.\n   */\n  getResource(index) {\n    return this.resources[index];\n  }\n  /**\n   * Used internally to 'touch' each resource, to ensure that the GC\n   * knows that all resources in this bind group are still being used.\n   * @param tick - The current tick.\n   * @internal\n   * @ignore\n   */\n  _touch(tick) {\n    const resources = this.resources;\n    for (const i in resources) {\n      resources[i]._touched = tick;\n    }\n  }\n  /** Destroys this bind group and removes all listeners. */\n  destroy() {\n    const resources = this.resources;\n    for (const i in resources) {\n      const resource = resources[i];\n      resource.off?.(\"change\", this.onResourceChange, this);\n    }\n    this.resources = null;\n  }\n  onResourceChange(resource) {\n    this._dirty = true;\n    if (resource.destroyed) {\n      const resources = this.resources;\n      for (const i in resources) {\n        if (resources[i] === resource) {\n          resources[i] = null;\n        }\n      }\n    } else {\n      this._updateKey();\n    }\n  }\n}\nexport { BindGroup };","map":{"version":3,"names":["BindGroup","constructor","resources","Object","create","_dirty","index","i","resource","setResource","_updateKey","keyParts","_resourceId","_key","join","currentResource","off","onResourceChange","on","getResource","_touch","tick","_touched","destroy","destroyed"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gpu/shader/BindGroup.ts"],"sourcesContent":["import type { BindResource } from './BindResource';\n\n/**\n * A bind group is a collection of resources that are bound together for use by a shader.\n * They are essentially a wrapper for the WebGPU BindGroup class. But with the added bonus\n * that WebGL can also work with them.\n * @see https://gpuweb.github.io/gpuweb/#dictdef-gpubindgroupdescriptor\n * @example\n * // Create a bind group with a single texture and sampler\n * const bindGroup = new BindGroup({\n *    uTexture: texture.source,\n *    uTexture: texture.style,\n * });\n *\n * Bind groups resources must implement the {@link BindResource} interface.\n * The following resources are supported:\n * - {@link TextureSource}\n * - {@link TextureStyle}\n * - {@link Buffer}\n * - {@link BufferResource}\n * - {@link UniformGroup}\n *\n * The keys in the bind group must correspond to the names of the resources in the GPU program.\n *\n * This bind group class will also watch for changes in its resources ensuring that the changes\n * are reflected in the WebGPU BindGroup.\n * @memberof rendering\n */\nexport class BindGroup\n{\n    /** The resources that are bound together for use by a shader. */\n    public resources: Record<string, BindResource> = Object.create(null);\n    /**\n     * a key used internally to match it up to a WebGPU Bindgroup\n     * @internal\n     * @ignore\n     */\n    public _key: string;\n    private _dirty = true;\n\n    /**\n     * Create a new instance eof the Bind Group.\n     * @param resources - The resources that are bound together for use by a shader.\n     */\n    constructor(resources?: Record<string, BindResource>)\n    {\n        let index = 0;\n\n        for (const i in resources)\n        {\n            const resource: BindResource = resources[i];\n\n            this.setResource(resource, index++);\n        }\n\n        this._updateKey();\n    }\n\n    /**\n     * Updates the key if its flagged as dirty. This is used internally to\n     * match this bind group to a WebGPU BindGroup.\n     * @internal\n     * @ignore\n     */\n    public _updateKey(): void\n    {\n        if (!this._dirty) return;\n\n        this._dirty = false;\n\n        const keyParts = [];\n        let index = 0;\n\n        // TODO - lets use big ints instead of strings...\n        for (const i in this.resources)\n        {\n            // TODO make this consistent...\n            keyParts[index++] = this.resources[i]._resourceId;\n        }\n\n        this._key = keyParts.join('|');\n    }\n\n    /**\n     * Set a resource at a given index. this function will\n     * ensure that listeners will be removed from the current resource\n     * and added to the new resource.\n     * @param resource - The resource to set.\n     * @param index - The index to set the resource at.\n     */\n    public setResource(resource: BindResource, index: number): void\n    {\n        const currentResource = this.resources[index];\n\n        if (resource === currentResource) return;\n\n        if (currentResource)\n        {\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        resource.on?.('change', this.onResourceChange, this);\n\n        this.resources[index] = resource;\n        this._dirty = true;\n    }\n\n    /**\n     * Returns the resource at the current specified index.\n     * @param index - The index of the resource to get.\n     * @returns - The resource at the specified index.\n     */\n    public getResource(index: number): BindResource\n    {\n        return this.resources[index];\n    }\n\n    /**\n     * Used internally to 'touch' each resource, to ensure that the GC\n     * knows that all resources in this bind group are still being used.\n     * @param tick - The current tick.\n     * @internal\n     * @ignore\n     */\n    public _touch(tick: number)\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            resources[i]._touched = tick;\n        }\n    }\n\n    /** Destroys this bind group and removes all listeners. */\n    public destroy()\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            const resource = resources[i];\n\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        this.resources = null;\n    }\n\n    protected onResourceChange(resource: BindResource)\n    {\n        this._dirty = true;\n\n        // check if a resource has been destroyed, if it has then we need to destroy this bind group\n        // using this bind group with a destroyed resource will cause the renderer to explode :)\n        if (resource.destroyed)\n        {\n            // free up the resource\n            const resources = this.resources;\n\n            for (const i in resources)\n            {\n                if (resources[i] === resource)\n                {\n                    resources[i] = null;\n                }\n            }\n        }\n        else\n        {\n            this._updateKey();\n        }\n    }\n}\n"],"mappings":";;AA4BO,MAAMA,SACb;EAAA;AAAA;AAAA;AAAA;EAeIC,YAAYC,SACZ;IAdA;IAAO,KAAAA,SAAA,kBAAiDC,MAAA,CAAAC,MAAA,CAAO,IAAI;IAOnE,KAAQC,MAAS;IAQb,IAAIC,KAAQ;IAEZ,WAAWC,CAAA,IAAKL,SAChB;MACU,MAAAM,QAAA,GAAyBN,SAAA,CAAUK,CAAC;MAErC,KAAAE,WAAA,CAAYD,QAAA,EAAUF,KAAO;IAAA;IAGtC,KAAKI,UAAW;EAAA;EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;EAQOA,UACPA,CAAA;IACI,IAAI,CAAC,IAAK,CAAAL,MAAA,EAAQ;IAElB,KAAKA,MAAS;IAEd,MAAMM,QAAA,GAAW,EAAC;IAClB,IAAIL,KAAQ;IAGD,WAAAC,CAAA,IAAK,KAAKL,SACrB;MAEIS,QAAA,CAASL,KAAO,MAAI,IAAK,CAAAJ,SAAA,CAAUK,CAAC,CAAE,CAAAK,WAAA;IAAA;IAGrC,KAAAC,IAAA,GAAOF,QAAS,CAAAG,IAAA,CAAK,GAAG;EAAA;EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASOL,YAAYD,QAAA,EAAwBF,KAC3C;IACU,MAAAS,eAAA,GAAkB,IAAK,CAAAb,SAAA,CAAUI,KAAK;IAE5C,IAAIE,QAAa,KAAAO,eAAA,EAAiB;IAElC,IAAIA,eACJ;MACIP,QAAA,CAASQ,GAAM,aAAU,IAAK,CAAAC,gBAAA,EAAkB,IAAI;IAAA;IAGxDT,QAAA,CAASU,EAAK,aAAU,IAAK,CAAAD,gBAAA,EAAkB,IAAI;IAE9C,KAAAf,SAAA,CAAUI,KAAK,CAAI,GAAAE,QAAA;IACxB,KAAKH,MAAS;EAAA;EAClB;AAAA;AAAA;AAAA;AAAA;EAOOc,YAAYb,KACnB;IACW,YAAKJ,SAAA,CAAUI,KAAK;EAAA;EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASOc,OAAOC,IACd;IACI,MAAMnB,SAAA,GAAY,IAAK,CAAAA,SAAA;IAEvB,WAAWK,CAAA,IAAKL,SAChB;MACcA,SAAA,CAAAK,CAAC,EAAEe,QAAW,GAAAD,IAAA;IAAA;EAC5B;EACJ;EAGOE,OACPA,CAAA;IACI,MAAMrB,SAAA,GAAY,IAAK,CAAAA,SAAA;IAEvB,WAAWK,CAAA,IAAKL,SAChB;MACU,MAAAM,QAAA,GAAWN,SAAA,CAAUK,CAAC;MAE5BC,QAAA,CAASQ,GAAM,aAAU,IAAK,CAAAC,gBAAA,EAAkB,IAAI;IAAA;IAGxD,KAAKf,SAAY;EAAA;EAGXe,iBAAiBT,QAC3B;IACI,KAAKH,MAAS;IAId,IAAIG,QAAA,CAASgB,SACb;MAEI,MAAMtB,SAAA,GAAY,IAAK,CAAAA,SAAA;MAEvB,WAAWK,CAAA,IAAKL,SAChB;QACQ,IAAAA,SAAA,CAAUK,CAAC,MAAMC,QACrB;UACIN,SAAA,CAAUK,CAAC,CAAI;QAAA;MACnB;IACJ,CAGJ;MACI,KAAKG,UAAW;IAAA;EACpB;AAER","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}