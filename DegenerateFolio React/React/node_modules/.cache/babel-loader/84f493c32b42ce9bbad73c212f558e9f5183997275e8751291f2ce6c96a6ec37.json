{"ast":null,"code":"import { uid } from '../../../utils/data/uid.mjs';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer.mjs';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy.mjs';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { BatchTextureArray } from './BatchTextureArray.mjs';\nimport { MAX_TEXTURES } from './const.mjs';\n\"use strict\";\nclass Batch {\n  constructor() {\n    this.renderPipeId = \"batch\";\n    this.action = \"startBatch\";\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n    // for drawing..\n    this.start = 0;\n    this.size = 0;\n    this.blendMode = \"normal\";\n    this.canBundle = true;\n  }\n  destroy() {\n    this.textures = null;\n    this.gpuBindGroup = null;\n    this.bindGroup = null;\n    this.batcher = null;\n  }\n}\nlet BATCH_TICK = 0;\nconst _Batcher = class _Batcher {\n  constructor(options = {}) {\n    this.uid = uid(\"batcher\");\n    this.dirty = true;\n    this.batchIndex = 0;\n    this.batches = [];\n    // specifics.\n    this._vertexSize = 6;\n    this._elements = [];\n    this._batchPool = [];\n    this._batchPoolIndex = 0;\n    this._textureBatchPool = [];\n    this._textureBatchPoolIndex = 0;\n    options = {\n      ..._Batcher.defaultOptions,\n      ...options\n    };\n    const {\n      vertexSize,\n      indexSize\n    } = options;\n    this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);\n    this.indexBuffer = new Uint16Array(indexSize);\n  }\n  begin() {\n    this.batchIndex = 0;\n    this.elementSize = 0;\n    this.elementStart = 0;\n    this.indexSize = 0;\n    this.attributeSize = 0;\n    this._batchPoolIndex = 0;\n    this._textureBatchPoolIndex = 0;\n    this._batchIndexStart = 0;\n    this._batchIndexSize = 0;\n    this.dirty = true;\n  }\n  add(batchableObject) {\n    this._elements[this.elementSize++] = batchableObject;\n    batchableObject.indexStart = this.indexSize;\n    batchableObject.location = this.attributeSize;\n    batchableObject.batcher = this;\n    this.indexSize += batchableObject.indexSize;\n    this.attributeSize += batchableObject.vertexSize * this._vertexSize;\n  }\n  checkAndUpdateTexture(batchableObject, texture) {\n    const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n    if (!textureId && textureId !== 0) return false;\n    batchableObject.textureId = textureId;\n    batchableObject.texture = texture;\n    return true;\n  }\n  updateElement(batchableObject) {\n    this.dirty = true;\n    batchableObject.packAttributes(this.attributeBuffer.float32View, this.attributeBuffer.uint32View, batchableObject.location, batchableObject.textureId);\n  }\n  /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */\n  break(instructionSet) {\n    const elements = this._elements;\n    let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n    textureBatch.clear();\n    if (!elements[this.elementStart]) return;\n    const firstElement = elements[this.elementStart];\n    let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n    if (this.attributeSize * 4 > this.attributeBuffer.size) {\n      this._resizeAttributeBuffer(this.attributeSize * 4);\n    }\n    if (this.indexSize > this.indexBuffer.length) {\n      this._resizeIndexBuffer(this.indexSize);\n    }\n    const f32 = this.attributeBuffer.float32View;\n    const u32 = this.attributeBuffer.uint32View;\n    const iBuffer = this.indexBuffer;\n    let size = this._batchIndexSize;\n    let start = this._batchIndexStart;\n    let action = \"startBatch\";\n    let batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n    for (let i = this.elementStart; i < this.elementSize; ++i) {\n      const element = elements[i];\n      elements[i] = null;\n      const texture = element.texture;\n      const source = texture._source;\n      const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n      const blendModeChange = blendMode !== adjustedBlendMode;\n      if (source._batchTick === BATCH_TICK && !blendModeChange) {\n        element.textureId = source._textureBindLocation;\n        size += element.indexSize;\n        element.packAttributes(f32, u32, element.location, element.textureId);\n        element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        element.batch = batch;\n        continue;\n      }\n      source._batchTick = BATCH_TICK;\n      if (textureBatch.count >= MAX_TEXTURES || blendModeChange) {\n        this._finishBatch(batch, start, size - start, textureBatch, blendMode, instructionSet, action);\n        action = \"renderBatch\";\n        start = size;\n        blendMode = adjustedBlendMode;\n        textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n        textureBatch.clear();\n        batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n        ++BATCH_TICK;\n      }\n      element.textureId = source._textureBindLocation = textureBatch.count;\n      textureBatch.ids[source.uid] = textureBatch.count;\n      textureBatch.textures[textureBatch.count++] = source;\n      element.batch = batch;\n      size += element.indexSize;\n      element.packAttributes(f32, u32, element.location, element.textureId);\n      element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n    }\n    if (textureBatch.count > 0) {\n      this._finishBatch(batch, start, size - start, textureBatch, blendMode, instructionSet, action);\n      start = size;\n      ++BATCH_TICK;\n    }\n    this.elementStart = this.elementSize;\n    this._batchIndexStart = start;\n    this._batchIndexSize = size;\n  }\n  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {\n    batch.gpuBindGroup = null;\n    batch.action = action;\n    batch.batcher = this;\n    batch.textures = textureBatch;\n    batch.blendMode = blendMode;\n    batch.start = indexStart;\n    batch.size = indexSize;\n    ++BATCH_TICK;\n    instructionSet.add(batch);\n  }\n  finish(instructionSet) {\n    this.break(instructionSet);\n  }\n  /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureAttributeBuffer(size) {\n    if (size * 4 <= this.attributeBuffer.size) return;\n    this._resizeAttributeBuffer(size * 4);\n  }\n  /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureIndexBuffer(size) {\n    if (size <= this.indexBuffer.length) return;\n    this._resizeIndexBuffer(size);\n  }\n  _resizeAttributeBuffer(size) {\n    const newSize = Math.max(size, this.attributeBuffer.size * 2);\n    const newArrayBuffer = new ViewableBuffer(newSize);\n    fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n    this.attributeBuffer = newArrayBuffer;\n  }\n  _resizeIndexBuffer(size) {\n    const indexBuffer = this.indexBuffer;\n    let newSize = Math.max(size, indexBuffer.length * 1.5);\n    newSize += newSize % 2;\n    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {\n      for (let i = 0; i < indexBuffer.length; i++) {\n        newIndexBuffer[i] = indexBuffer[i];\n      }\n    } else {\n      fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n    }\n    this.indexBuffer = newIndexBuffer;\n  }\n  destroy() {\n    for (let i = 0; i < this.batches.length; i++) {\n      this.batches[i].destroy();\n    }\n    this.batches = null;\n    for (let i = 0; i < this._elements.length; i++) {\n      this._elements[i].batch = null;\n    }\n    this._elements = null;\n    this.indexBuffer = null;\n    this.attributeBuffer.destroy();\n    this.attributeBuffer = null;\n  }\n};\n_Batcher.defaultOptions = {\n  vertexSize: 4,\n  indexSize: 6\n};\nlet Batcher = _Batcher;\nexport { Batch, Batcher };","map":{"version":3,"names":["Batch","constructor","renderPipeId","action","start","size","blendMode","canBundle","destroy","textures","gpuBindGroup","bindGroup","batcher","BATCH_TICK","_Batcher","options","uid","dirty","batchIndex","batches","_vertexSize","_elements","_batchPool","_batchPoolIndex","_textureBatchPool","_textureBatchPoolIndex","defaultOptions","vertexSize","indexSize","attributeBuffer","ViewableBuffer","indexBuffer","Uint16Array","begin","elementSize","elementStart","attributeSize","_batchIndexStart","_batchIndexSize","add","batchableObject","indexStart","location","checkAndUpdateTexture","texture","textureId","batch","ids","_source","updateElement","packAttributes","float32View","uint32View","break","instructionSet","elements","textureBatch","BatchTextureArray","clear","firstElement","getAdjustedBlendModeBlend","_resizeAttributeBuffer","length","_resizeIndexBuffer","f32","u32","iBuffer","i","element","source","adjustedBlendMode","blendModeChange","_batchTick","_textureBindLocation","packIndex","count","MAX_TEXTURES","_finishBatch","finish","ensureAttributeBuffer","ensureIndexBuffer","newSize","Math","max","newArrayBuffer","fastCopy","rawBinaryData","newIndexBuffer","Uint32Array","BYTES_PER_ELEMENT","buffer","Batcher"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/batcher/shared/Batcher.ts"],"sourcesContent":["import { uid } from '../../../utils/data/uid';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy';\nimport { type BLEND_MODES } from '../../renderers/shared/state/const';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend';\nimport { BatchTextureArray } from './BatchTextureArray';\nimport { MAX_TEXTURES } from './const';\n\nimport type { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport type { IndexBufferArray } from '../../renderers/shared/geometry/Geometry';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { Texture } from '../../renderers/shared/texture/Texture';\n\nexport type BatchAction = 'startBatch' | 'renderBatch';\n\n/**\n * A batch pool is used to store batches when they are not currently in use.\n * @memberof rendering\n */\nexport class Batch implements Instruction\n{\n    public renderPipeId = 'batch';\n    public action: BatchAction = 'startBatch';\n\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n\n    // for drawing..\n    public start = 0;\n    public size = 0;\n    public textures: BatchTextureArray;\n\n    public blendMode: BLEND_MODES = 'normal';\n\n    public canBundle = true;\n\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the GPU bind group to set when rendering this batch for WebGPU. Will be null is using WebGL.\n     */\n    public gpuBindGroup: GPUBindGroup;\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the bind group to set when rendering this batch for WebGPU. Will be null if using WebGl.\n     */\n    public bindGroup: BindGroup;\n\n    public batcher: Batcher;\n\n    public destroy()\n    {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\n\nexport interface BatchableObject\n{\n    indexStart: number;\n\n    packAttributes: (\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number,\n    ) => void;\n    packIndex: (indexBuffer: IndexBufferArray, index: number, indicesOffset: number) => void;\n\n    texture: Texture;\n    blendMode: BLEND_MODES;\n    vertexSize: number;\n    indexSize: number;\n\n    // stored for efficient updating..\n    textureId: number;\n    location: number; // location in the buffer\n    batcher: Batcher;\n    batch: Batch;\n\n    roundPixels: 0 | 1;\n}\n\nlet BATCH_TICK = 0;\n\n/**\n * The options for the batcher.\n * @ignore\n */\nexport interface BatcherOptions\n{\n    /** The size of the vertex buffer. */\n    vertexSize?: number;\n    /** The size of the index buffer. */\n    indexSize?: number;\n}\n\n/**\n * A batcher is used to batch together objects with the same texture.\n * @ignore\n */\nexport class Batcher\n{\n    public static defaultOptions: BatcherOptions = {\n        vertexSize: 4,\n        indexSize: 6,\n    };\n\n    public uid = uid('batcher');\n    public attributeBuffer: ViewableBuffer;\n    public indexBuffer: IndexBufferArray;\n\n    public attributeSize: number;\n    public indexSize: number;\n    public elementSize: number;\n    public elementStart: number;\n\n    public dirty = true;\n\n    public batchIndex = 0;\n    public batches: Batch[] = [];\n\n    // specifics.\n    private readonly _vertexSize: number = 6;\n\n    private _elements: BatchableObject[] = [];\n\n    private readonly _batchPool: Batch[] = [];\n    private _batchPoolIndex = 0;\n    private readonly _textureBatchPool: BatchTextureArray[] = [];\n    private _textureBatchPoolIndex = 0;\n    private _batchIndexStart: number;\n    private _batchIndexSize: number;\n\n    constructor(options: BatcherOptions = {})\n    {\n        options = { ...Batcher.defaultOptions, ...options };\n\n        const { vertexSize, indexSize } = options;\n\n        this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);\n\n        this.indexBuffer = new Uint16Array(indexSize);\n    }\n\n    public begin()\n    {\n        this.batchIndex = 0;\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n        this._batchPoolIndex = 0;\n        this._textureBatchPoolIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n\n        this.dirty = true;\n    }\n\n    public add(batchableObject: BatchableObject)\n    {\n        this._elements[this.elementSize++] = batchableObject;\n\n        batchableObject.indexStart = this.indexSize;\n        batchableObject.location = this.attributeSize;\n        batchableObject.batcher = this;\n\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += ((batchableObject.vertexSize) * this._vertexSize);\n    }\n\n    public checkAndUpdateTexture(batchableObject: BatchableObject, texture: Texture): boolean\n    {\n        const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n\n        // TODO could try to be a bit smarter if there are spare textures..\n        // but need to figure out how to alter the bind groups too..\n        if (!textureId && textureId !== 0) return false;\n\n        batchableObject.textureId = textureId;\n        batchableObject.texture = texture;\n\n        return true;\n    }\n\n    public updateElement(batchableObject: BatchableObject)\n    {\n        this.dirty = true;\n\n        batchableObject.packAttributes(\n            this.attributeBuffer.float32View,\n            this.attributeBuffer.uint32View,\n            batchableObject.location, batchableObject.textureId);\n    }\n\n    /**\n     * breaks the batcher. This happens when a batch gets too big,\n     * or we need to switch to a different type of rendering (a filter for example)\n     * @param instructionSet\n     */\n    public break(instructionSet: InstructionSet)\n    {\n        // ++BATCH_TICK;\n        const elements = this._elements;\n\n        let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n\n        textureBatch.clear();\n\n        // length 0??!! (we broke without ading anything)\n        if (!elements[this.elementStart]) return;\n\n        const firstElement = elements[this.elementStart];\n        let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n\n        if (this.attributeSize * 4 > this.attributeBuffer.size)\n        {\n            this._resizeAttributeBuffer(this.attributeSize * 4);\n        }\n\n        if (this.indexSize > this.indexBuffer.length)\n        {\n            this._resizeIndexBuffer(this.indexSize);\n        }\n\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const iBuffer = this.indexBuffer;\n\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n\n        let action: BatchAction = 'startBatch';\n        let batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n\n        for (let i = this.elementStart; i < this.elementSize; ++i)\n        {\n            const element = elements[i];\n\n            elements[i] = null;\n\n            const texture = element.texture;\n            const source = texture._source;\n\n            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n\n            const blendModeChange = blendMode !== adjustedBlendMode;\n\n            if (source._batchTick === BATCH_TICK && !blendModeChange)\n            {\n                element.textureId = source._textureBindLocation;\n\n                size += element.indexSize;\n                element.packAttributes(f32, u32, element.location, element.textureId);\n                element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n\n                element.batch = batch;\n\n                continue;\n            }\n\n            source._batchTick = BATCH_TICK;\n\n            if (textureBatch.count >= MAX_TEXTURES || blendModeChange)\n            {\n                this._finishBatch(\n                    batch,\n                    start,\n                    size - start,\n                    textureBatch,\n                    blendMode,\n                    instructionSet,\n                    action\n                );\n\n                action = 'renderBatch';\n                start = size;\n                // create a batch...\n                blendMode = adjustedBlendMode;\n\n                textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n                textureBatch.clear();\n\n                batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n                ++BATCH_TICK;\n            }\n\n            element.textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element.batch = batch;\n\n            size += element.indexSize;\n            element.packAttributes(f32, u32, element.location, element.textureId);\n            element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        }\n\n        if (textureBatch.count > 0)\n        {\n            this._finishBatch(\n                batch,\n                start,\n                size - start,\n                textureBatch,\n                blendMode,\n                instructionSet,\n                action\n            );\n\n            start = size;\n            ++BATCH_TICK;\n        }\n\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n\n    private _finishBatch(\n        batch: Batch,\n        indexStart: number,\n        indexSize: number,\n        textureBatch: BatchTextureArray,\n        blendMode: BLEND_MODES,\n        instructionSet: InstructionSet,\n        action: BatchAction\n    )\n    {\n        batch.gpuBindGroup = null;\n        batch.action = action;\n\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n\n        batch.start = indexStart;\n        batch.size = indexSize;\n\n        ++BATCH_TICK;\n\n        instructionSet.add(batch);\n    }\n\n    public finish(instructionSet: InstructionSet)\n    {\n        this.break(instructionSet);\n    }\n\n    /**\n     * Resizes the attribute buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureAttributeBuffer(size: number)\n    {\n        if (size * 4 <= this.attributeBuffer.size) return;\n\n        this._resizeAttributeBuffer(size * 4);\n    }\n\n    /**\n     * Resizes the index buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureIndexBuffer(size: number)\n    {\n        if (size <= this.indexBuffer.length) return;\n\n        this._resizeIndexBuffer(size);\n    }\n\n    private _resizeAttributeBuffer(size: number)\n    {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n\n        const newArrayBuffer = new ViewableBuffer(newSize);\n\n        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n\n        this.attributeBuffer = newArrayBuffer;\n    }\n\n    private _resizeIndexBuffer(size: number)\n    {\n        const indexBuffer = this.indexBuffer;\n\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n\n        newSize += newSize % 2;\n\n        // this, is technically not 100% accurate, as really we should\n        // be checking the maximum value in the buffer. This approximation\n        // does the trick though...\n\n        // make sure buffer is always an even number..\n        const newIndexBuffer = (newSize > 65535) ? new Uint32Array(newSize) : new Uint16Array(newSize);\n\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT)\n        {\n            for (let i = 0; i < indexBuffer.length; i++)\n            {\n                newIndexBuffer[i] = indexBuffer[i];\n            }\n        }\n        else\n        {\n            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n        }\n\n        this.indexBuffer = newIndexBuffer;\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            this.batches[i].destroy();\n        }\n\n        this.batches = null;\n\n        for (let i = 0; i < this._elements.length; i++)\n        {\n            this._elements[i].batch = null;\n        }\n\n        this._elements = null;\n\n        this.indexBuffer = null;\n\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}