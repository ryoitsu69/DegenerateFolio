{"ast":null,"code":"import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { isHex, u8aToString } from '@polkadot/util';\nimport { firstMemo, memo } from '../util/index.js';\nconst UNDEF_HEX = {\n  toHex: () => undefined\n};\nfunction dataAsString(data) {\n  return data.isRaw ? u8aToString(data.asRaw.toU8a(true)) : data.isNone ? undefined : data.toHex();\n}\nfunction extractOther(additional) {\n  return additional.reduce((other, _ref) => {\n    let [_key, _value] = _ref;\n    const key = dataAsString(_key);\n    const value = dataAsString(_value);\n    if (key && value) {\n      other[key] = value;\n    }\n    return other;\n  }, {});\n}\nfunction identityCompat(identityOfOpt) {\n  const identity = identityOfOpt.unwrap();\n  return Array.isArray(identity) ? identity[0] : identity;\n}\nfunction extractIdentity(identityOfOpt, superOf) {\n  if (!(identityOfOpt !== null && identityOfOpt !== void 0 && identityOfOpt.isSome)) {\n    return {\n      judgements: []\n    };\n  }\n  const {\n    info,\n    judgements\n  } = identityCompat(identityOfOpt);\n  const topDisplay = dataAsString(info.display);\n  return {\n    display: superOf && dataAsString(superOf[1]) || topDisplay,\n    displayParent: superOf && topDisplay,\n    email: dataAsString(info.email),\n    image: dataAsString(info.image),\n    judgements,\n    legal: dataAsString(info.legal),\n    other: extractOther(info.additional),\n    parent: superOf === null || superOf === void 0 ? void 0 : superOf[0],\n    pgp: info.pgpFingerprint.unwrapOr(UNDEF_HEX).toHex(),\n    riot: dataAsString(info.riot),\n    twitter: dataAsString(info.twitter),\n    web: dataAsString(info.web)\n  };\n}\nfunction getParent(api, identityOfOpt, superOfOpt) {\n  if (identityOfOpt !== null && identityOfOpt !== void 0 && identityOfOpt.isSome) {\n    // this identity has something set\n    return of([identityOfOpt, undefined]);\n  } else if (superOfOpt !== null && superOfOpt !== void 0 && superOfOpt.isSome) {\n    const superOf = superOfOpt.unwrap();\n    return combineLatest([api.derive.accounts._identity(superOf[0]).pipe(map(_ref2 => {\n      let [info] = _ref2;\n      return info;\n    })), of(superOf)]);\n  }\n  // nothing of value returned\n  return of([undefined, undefined]);\n}\nexport function _identity(instanceId, api) {\n  return memo(instanceId, accountId => {\n    var _api$query$identity;\n    return accountId && (_api$query$identity = api.query.identity) !== null && _api$query$identity !== void 0 && _api$query$identity.identityOf ? combineLatest([api.query.identity.identityOf(accountId), api.query.identity.superOf(accountId)]) : of([undefined, undefined]);\n  });\n}\n/**\n * @name identity\n * @description Returns identity info for an account\n */\nexport function identity(instanceId, api) {\n  return memo(instanceId, accountId => api.derive.accounts._identity(accountId).pipe(switchMap(_ref3 => {\n    let [identityOfOpt, superOfOpt] = _ref3;\n    return getParent(api, identityOfOpt, superOfOpt);\n  }), map(_ref4 => {\n    let [identityOfOpt, superOf] = _ref4;\n    return extractIdentity(identityOfOpt, superOf);\n  })));\n}\nexport const hasIdentity = /*#__PURE__*/firstMemo((api, accountId) => api.derive.accounts.hasIdentityMulti([accountId]));\nexport function hasIdentityMulti(instanceId, api) {\n  return memo(instanceId, accountIds => {\n    var _api$query$identity2;\n    return (_api$query$identity2 = api.query.identity) !== null && _api$query$identity2 !== void 0 && _api$query$identity2.identityOf ? combineLatest([api.query.identity.identityOf.multi(accountIds), api.query.identity.superOf.multi(accountIds)]).pipe(map(_ref5 => {\n      let [identities, supers] = _ref5;\n      return identities.map((identityOfOpt, index) => {\n        const superOfOpt = supers[index];\n        const parentId = superOfOpt && superOfOpt.isSome ? superOfOpt.unwrap()[0].toString() : undefined;\n        let display;\n        if (identityOfOpt && identityOfOpt.isSome) {\n          const value = dataAsString(identityCompat(identityOfOpt).info.display);\n          if (value && !isHex(value)) {\n            display = value;\n          }\n        }\n        return {\n          display,\n          hasIdentity: !!(display || parentId),\n          parentId\n        };\n      });\n    })) : of(accountIds.map(() => ({\n      hasIdentity: false\n    })));\n  });\n}","map":{"version":3,"names":["combineLatest","map","of","switchMap","isHex","u8aToString","firstMemo","memo","UNDEF_HEX","toHex","undefined","dataAsString","data","isRaw","asRaw","toU8a","isNone","extractOther","additional","reduce","other","_ref","_key","_value","key","value","identityCompat","identityOfOpt","identity","unwrap","Array","isArray","extractIdentity","superOf","isSome","judgements","info","topDisplay","display","displayParent","email","image","legal","parent","pgp","pgpFingerprint","unwrapOr","riot","twitter","web","getParent","api","superOfOpt","derive","accounts","_identity","pipe","_ref2","instanceId","accountId","_api$query$identity","query","identityOf","_ref3","_ref4","hasIdentity","hasIdentityMulti","accountIds","_api$query$identity2","multi","_ref5","identities","supers","index","parentId","toString"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api-derive/accounts/identity.js"],"sourcesContent":["import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { isHex, u8aToString } from '@polkadot/util';\nimport { firstMemo, memo } from '../util/index.js';\nconst UNDEF_HEX = { toHex: () => undefined };\nfunction dataAsString(data) {\n    return data.isRaw\n        ? u8aToString(data.asRaw.toU8a(true))\n        : data.isNone\n            ? undefined\n            : data.toHex();\n}\nfunction extractOther(additional) {\n    return additional.reduce((other, [_key, _value]) => {\n        const key = dataAsString(_key);\n        const value = dataAsString(_value);\n        if (key && value) {\n            other[key] = value;\n        }\n        return other;\n    }, {});\n}\nfunction identityCompat(identityOfOpt) {\n    const identity = identityOfOpt.unwrap();\n    return Array.isArray(identity)\n        ? identity[0]\n        : identity;\n}\nfunction extractIdentity(identityOfOpt, superOf) {\n    if (!identityOfOpt?.isSome) {\n        return { judgements: [] };\n    }\n    const { info, judgements } = identityCompat(identityOfOpt);\n    const topDisplay = dataAsString(info.display);\n    return {\n        display: (superOf && dataAsString(superOf[1])) || topDisplay,\n        displayParent: superOf && topDisplay,\n        email: dataAsString(info.email),\n        image: dataAsString(info.image),\n        judgements,\n        legal: dataAsString(info.legal),\n        other: extractOther(info.additional),\n        parent: superOf?.[0],\n        pgp: info.pgpFingerprint.unwrapOr(UNDEF_HEX).toHex(),\n        riot: dataAsString(info.riot),\n        twitter: dataAsString(info.twitter),\n        web: dataAsString(info.web)\n    };\n}\nfunction getParent(api, identityOfOpt, superOfOpt) {\n    if (identityOfOpt?.isSome) {\n        // this identity has something set\n        return of([identityOfOpt, undefined]);\n    }\n    else if (superOfOpt?.isSome) {\n        const superOf = superOfOpt.unwrap();\n        return combineLatest([\n            api.derive.accounts._identity(superOf[0]).pipe(map(([info]) => info)),\n            of(superOf)\n        ]);\n    }\n    // nothing of value returned\n    return of([undefined, undefined]);\n}\nexport function _identity(instanceId, api) {\n    return memo(instanceId, (accountId) => accountId && api.query.identity?.identityOf\n        ? combineLatest([\n            api.query.identity.identityOf(accountId),\n            api.query.identity.superOf(accountId)\n        ])\n        : of([undefined, undefined]));\n}\n/**\n * @name identity\n * @description Returns identity info for an account\n */\nexport function identity(instanceId, api) {\n    return memo(instanceId, (accountId) => api.derive.accounts._identity(accountId).pipe(switchMap(([identityOfOpt, superOfOpt]) => getParent(api, identityOfOpt, superOfOpt)), map(([identityOfOpt, superOf]) => extractIdentity(identityOfOpt, superOf))));\n}\nexport const hasIdentity = /*#__PURE__*/ firstMemo((api, accountId) => api.derive.accounts.hasIdentityMulti([accountId]));\nexport function hasIdentityMulti(instanceId, api) {\n    return memo(instanceId, (accountIds) => api.query.identity?.identityOf\n        ? combineLatest([\n            api.query.identity.identityOf.multi(accountIds),\n            api.query.identity.superOf.multi(accountIds)\n        ]).pipe(map(([identities, supers]) => identities.map((identityOfOpt, index) => {\n            const superOfOpt = supers[index];\n            const parentId = superOfOpt && superOfOpt.isSome\n                ? superOfOpt.unwrap()[0].toString()\n                : undefined;\n            let display;\n            if (identityOfOpt && identityOfOpt.isSome) {\n                const value = dataAsString(identityCompat(identityOfOpt).info.display);\n                if (value && !isHex(value)) {\n                    display = value;\n                }\n            }\n            return { display, hasIdentity: !!(display || parentId), parentId };\n        })))\n        : of(accountIds.map(() => ({ hasIdentity: false }))));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}