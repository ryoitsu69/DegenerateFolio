{"ast":null,"code":"import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../rendering/renderers/types.mjs';\nimport { isSafari } from '../../utils/browser/isSafari.mjs';\nimport { warn } from '../../utils/logging/warn.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource.mjs';\nimport { HTMLTextRenderData } from './HTMLTextRenderData.mjs';\nimport { HTMLTextStyle } from './HtmlTextStyle.mjs';\nimport { extractFontFamilies } from './utils/extractFontFamilies.mjs';\nimport { getFontCss } from './utils/getFontCss.mjs';\nimport { getSVGUrl } from './utils/getSVGUrl.mjs';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage.mjs';\nimport { loadSVGImage } from './utils/loadSVGImage.mjs';\nimport { measureHtmlText } from './utils/measureHtmlText.mjs';\n\"use strict\";\nclass HTMLTextSystem {\n  constructor(renderer) {\n    this._activeTextures = {};\n    this._renderer = renderer;\n    this._createCanvas = renderer.type === RendererType.WEBGPU;\n  }\n  getTexture(options) {\n    return this._buildTexturePromise(options.text, options.resolution, options.style);\n  }\n  getManagedTexture(text, resolution, style, textKey) {\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].promise;\n    }\n    const promise = this._buildTexturePromise(text, resolution, style).then(texture => {\n      this._activeTextures[textKey].texture = texture;\n      return texture;\n    });\n    this._activeTextures[textKey] = {\n      texture: null,\n      promise,\n      usageCount: 1\n    };\n    return promise;\n  }\n  async _buildTexturePromise(text, resolution, style) {\n    const htmlTextData = BigPool.get(HTMLTextRenderData);\n    const fontFamilies = extractFontFamilies(text, style);\n    const fontCSS = await getFontCss(fontFamilies, style, HTMLTextStyle.defaultTextStyle);\n    const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const image = htmlTextData.image;\n    image.width = width | 0;\n    image.height = height | 0;\n    const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n    await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n    let resource = image;\n    if (this._createCanvas) {\n      resource = getTemporaryCanvasFromImage(image, resolution);\n    }\n    const texture = getPo2TextureFromSource(resource, image.width, image.height, resolution);\n    if (this._createCanvas) {\n      this._renderer.texture.initSource(texture.source);\n    }\n    BigPool.return(htmlTextData);\n    return texture;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    if (!activeTexture) return;\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      if (activeTexture.texture) {\n        this._cleanUp(activeTexture);\n      } else {\n        activeTexture.promise.then(texture => {\n          activeTexture.texture = texture;\n          this._cleanUp(activeTexture);\n        }).catch(() => {\n          warn(\"HTMLTextSystem: Failed to clean texture\");\n        });\n      }\n      this._activeTextures[textKey] = null;\n    }\n  }\n  _cleanUp(activeTexture) {\n    TexturePool.returnTexture(activeTexture.texture);\n    activeTexture.texture.source.resource = null;\n    activeTexture.texture.source.uploadMethodId = \"unknown\";\n  }\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey].usageCount;\n  }\n  destroy() {\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nHTMLTextSystem.extension = {\n  type: [ExtensionType.WebGLSystem, ExtensionType.WebGPUSystem, ExtensionType.CanvasSystem],\n  name: \"htmlText\"\n};\nHTMLTextSystem.defaultFontOptions = {\n  fontFamily: \"Arial\",\n  fontStyle: \"normal\",\n  fontWeight: \"normal\"\n};\nexport { HTMLTextSystem };","map":{"version":3,"names":["HTMLTextSystem","constructor","renderer","_activeTextures","_renderer","_createCanvas","type","RendererType","WEBGPU","getTexture","options","_buildTexturePromise","text","resolution","style","getManagedTexture","textKey","_increaseReferenceCount","promise","then","texture","usageCount","htmlTextData","BigPool","get","HTMLTextRenderData","fontFamilies","extractFontFamilies","fontCSS","getFontCss","HTMLTextStyle","defaultTextStyle","measured","measureHtmlText","width","Math","ceil","max","padding","height","image","svgURL","getSVGUrl","loadSVGImage","isSafari","length","resource","getTemporaryCanvasFromImage","getPo2TextureFromSource","initSource","source","return","decreaseReferenceCount","activeTexture","_cleanUp","catch","warn","TexturePool","returnTexture","uploadMethodId","getReferenceCount","destroy","extension","ExtensionType","WebGLSystem","WebGPUSystem","CanvasSystem","name","defaultFontOptions","fontFamily","fontStyle","fontWeight"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/text-html/HTMLTextSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { HTMLTextStyle } from './HtmlTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLTextOptions } from './HTMLText';\nimport type { FontCSSStyleOptions } from './utils/loadFontCSS';\n\ninterface HTMLTextTexture\n{\n    texture: Texture,\n    usageCount: number,\n    promise: Promise<Texture>,\n}\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @memberof rendering\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    public static defaultFontOptions: FontCSSStyleOptions = {\n        fontFamily: 'Arial',\n        fontStyle: 'normal',\n        fontWeight: 'normal',\n    };\n\n    private _activeTextures: Record<string, HTMLTextTexture> = {};\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(\n            options.text as string,\n            options.resolution,\n            options.style as HTMLTextStyle\n        );\n    }\n\n    public getManagedTexture(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n        textKey: string\n    ): Promise<Texture>\n    {\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].promise;\n        }\n\n        const promise = this._buildTexturePromise(text, resolution, style)\n            .then((texture) =>\n            {\n                this._activeTextures[textKey].texture = texture;\n\n                return texture;\n            });\n\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise,\n            usageCount: 1,\n        };\n\n        return promise;\n    }\n\n    private async _buildTexturePromise(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n    )\n    {\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(\n            fontFamilies,\n            style,\n            HTMLTextStyle.defaultTextStyle as {fontWeight: string, fontStyle: string}\n        );\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        image.width = width | 0;\n        image.height = height | 0;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        let resource: HTMLImageElement | HTMLCanvasElement = image;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            resource = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(resource, image.width, image.height, resolution);\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        // TODO SHOULD NOT BE NEEDED\n        if (!activeTexture) return;\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            if (activeTexture.texture)\n            {\n                this._cleanUp(activeTexture);\n            }\n            else\n            {\n                // we did not resolve...\n                activeTexture.promise.then((texture) =>\n                {\n                    activeTexture.texture = texture;\n\n                    this._cleanUp(activeTexture);\n                }).catch(() =>\n                {\n                    // #if _DEBUG\n                    warn('HTMLTextSystem: Failed to clean texture');\n                    // #endif\n                });\n            }\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    private _cleanUp(activeTexture: HTMLTextTexture)\n    {\n        TexturePool.returnTexture(activeTexture.texture);\n        activeTexture.texture.source.resource = null;\n        activeTexture.texture.source.uploadMethodId = 'unknown';\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}