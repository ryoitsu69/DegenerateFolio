{"ast":null,"code":"import { u8aIsWrapped, u8aToU8a, u8aUnwrapBytes, u8aWrapBytes } from '@polkadot/util';\nimport { decodeAddress } from '../address/decode.js';\nimport { ed25519Verify } from '../ed25519/verify.js';\nimport { secp256k1Verify } from '../secp256k1/verify.js';\nimport { sr25519Verify } from '../sr25519/verify.js';\nconst secp256k1VerifyHasher = hashType => (message, signature, publicKey) => secp256k1Verify(message, signature, publicKey, hashType);\nconst VERIFIERS_ECDSA = [['ecdsa', secp256k1VerifyHasher('blake2')], ['ethereum', secp256k1VerifyHasher('keccak')]];\nconst VERIFIERS = [['ed25519', ed25519Verify], ['sr25519', sr25519Verify], ...VERIFIERS_ECDSA];\nconst CRYPTO_TYPES = ['ed25519', 'sr25519', 'ecdsa'];\nfunction verifyDetect(result, {\n  message,\n  publicKey,\n  signature\n}, verifiers = VERIFIERS) {\n  result.isValid = verifiers.some(([crypto, verify]) => {\n    try {\n      if (verify(message, signature, publicKey)) {\n        result.crypto = crypto;\n        return true;\n      }\n    } catch {\n      // do nothing, result.isValid still set to false\n    }\n    return false;\n  });\n  return result;\n}\nfunction verifyMultisig(result, {\n  message,\n  publicKey,\n  signature\n}) {\n  if (![0, 1, 2].includes(signature[0])) {\n    throw new Error(`Unknown crypto type, expected signature prefix [0..2], found ${signature[0]}`);\n  }\n  const type = CRYPTO_TYPES[signature[0]] || 'none';\n  result.crypto = type;\n  try {\n    result.isValid = {\n      ecdsa: () => verifyDetect(result, {\n        message,\n        publicKey,\n        signature: signature.subarray(1)\n      }, VERIFIERS_ECDSA).isValid,\n      ed25519: () => ed25519Verify(message, signature.subarray(1), publicKey),\n      none: () => {\n        throw Error('no verify for `none` crypto type');\n      },\n      sr25519: () => sr25519Verify(message, signature.subarray(1), publicKey)\n    }[type]();\n  } catch {\n    // ignore, result.isValid still set to false\n  }\n  return result;\n}\nfunction getVerifyFn(signature) {\n  return [0, 1, 2].includes(signature[0]) && [65, 66].includes(signature.length) ? verifyMultisig : verifyDetect;\n}\nexport function signatureVerify(message, signature, addressOrPublicKey) {\n  const signatureU8a = u8aToU8a(signature);\n  if (![64, 65, 66].includes(signatureU8a.length)) {\n    throw new Error(`Invalid signature length, expected [64..66] bytes, found ${signatureU8a.length}`);\n  }\n  const publicKey = decodeAddress(addressOrPublicKey);\n  const input = {\n    message: u8aToU8a(message),\n    publicKey,\n    signature: signatureU8a\n  };\n  const result = {\n    crypto: 'none',\n    isValid: false,\n    isWrapped: u8aIsWrapped(input.message, true),\n    publicKey\n  };\n  const isWrappedBytes = u8aIsWrapped(input.message, false);\n  const verifyFn = getVerifyFn(signatureU8a);\n  verifyFn(result, input);\n  if (result.crypto !== 'none' || result.isWrapped && !isWrappedBytes) {\n    return result;\n  }\n  input.message = isWrappedBytes ? u8aUnwrapBytes(input.message) : u8aWrapBytes(input.message);\n  return verifyFn(result, input);\n}","map":{"version":3,"names":["u8aIsWrapped","u8aToU8a","u8aUnwrapBytes","u8aWrapBytes","decodeAddress","ed25519Verify","secp256k1Verify","sr25519Verify","secp256k1VerifyHasher","hashType","message","signature","publicKey","VERIFIERS_ECDSA","VERIFIERS","CRYPTO_TYPES","verifyDetect","result","verifiers","isValid","some","crypto","verify","verifyMultisig","includes","Error","type","ecdsa","subarray","ed25519","none","sr25519","getVerifyFn","length","signatureVerify","addressOrPublicKey","signatureU8a","input","isWrapped","isWrappedBytes","verifyFn"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util-crypto/signature/verify.js"],"sourcesContent":["import { u8aIsWrapped, u8aToU8a, u8aUnwrapBytes, u8aWrapBytes } from '@polkadot/util';\nimport { decodeAddress } from '../address/decode.js';\nimport { ed25519Verify } from '../ed25519/verify.js';\nimport { secp256k1Verify } from '../secp256k1/verify.js';\nimport { sr25519Verify } from '../sr25519/verify.js';\nconst secp256k1VerifyHasher = (hashType) => (message, signature, publicKey) => secp256k1Verify(message, signature, publicKey, hashType);\nconst VERIFIERS_ECDSA = [\n    ['ecdsa', secp256k1VerifyHasher('blake2')],\n    ['ethereum', secp256k1VerifyHasher('keccak')]\n];\nconst VERIFIERS = [\n    ['ed25519', ed25519Verify],\n    ['sr25519', sr25519Verify],\n    ...VERIFIERS_ECDSA\n];\nconst CRYPTO_TYPES = ['ed25519', 'sr25519', 'ecdsa'];\nfunction verifyDetect(result, { message, publicKey, signature }, verifiers = VERIFIERS) {\n    result.isValid = verifiers.some(([crypto, verify]) => {\n        try {\n            if (verify(message, signature, publicKey)) {\n                result.crypto = crypto;\n                return true;\n            }\n        }\n        catch {\n            // do nothing, result.isValid still set to false\n        }\n        return false;\n    });\n    return result;\n}\nfunction verifyMultisig(result, { message, publicKey, signature }) {\n    if (![0, 1, 2].includes(signature[0])) {\n        throw new Error(`Unknown crypto type, expected signature prefix [0..2], found ${signature[0]}`);\n    }\n    const type = CRYPTO_TYPES[signature[0]] || 'none';\n    result.crypto = type;\n    try {\n        result.isValid = {\n            ecdsa: () => verifyDetect(result, { message, publicKey, signature: signature.subarray(1) }, VERIFIERS_ECDSA).isValid,\n            ed25519: () => ed25519Verify(message, signature.subarray(1), publicKey),\n            none: () => {\n                throw Error('no verify for `none` crypto type');\n            },\n            sr25519: () => sr25519Verify(message, signature.subarray(1), publicKey)\n        }[type]();\n    }\n    catch {\n        // ignore, result.isValid still set to false\n    }\n    return result;\n}\nfunction getVerifyFn(signature) {\n    return [0, 1, 2].includes(signature[0]) && [65, 66].includes(signature.length)\n        ? verifyMultisig\n        : verifyDetect;\n}\nexport function signatureVerify(message, signature, addressOrPublicKey) {\n    const signatureU8a = u8aToU8a(signature);\n    if (![64, 65, 66].includes(signatureU8a.length)) {\n        throw new Error(`Invalid signature length, expected [64..66] bytes, found ${signatureU8a.length}`);\n    }\n    const publicKey = decodeAddress(addressOrPublicKey);\n    const input = { message: u8aToU8a(message), publicKey, signature: signatureU8a };\n    const result = { crypto: 'none', isValid: false, isWrapped: u8aIsWrapped(input.message, true), publicKey };\n    const isWrappedBytes = u8aIsWrapped(input.message, false);\n    const verifyFn = getVerifyFn(signatureU8a);\n    verifyFn(result, input);\n    if (result.crypto !== 'none' || (result.isWrapped && !isWrappedBytes)) {\n        return result;\n    }\n    input.message = isWrappedBytes\n        ? u8aUnwrapBytes(input.message)\n        : u8aWrapBytes(input.message);\n    return verifyFn(result, input);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}