{"ast":null,"code":"import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Buffer } from '../shared/buffer/Buffer.mjs';\nimport { BufferResource } from '../shared/buffer/BufferResource.mjs';\nimport { BufferUsage } from '../shared/buffer/const.mjs';\nimport { UboBatch } from './buffer/UboBatch.mjs';\nimport { BindGroup } from './shader/BindGroup.mjs';\n\"use strict\";\nconst minUniformOffsetAlignment = 128;\nclass GpuUniformBatchPipe {\n  constructor(renderer) {\n    this._bindGroupHash = /* @__PURE__ */Object.create(null);\n    // number of buffers..\n    this._buffers = [];\n    this._bindGroups = [];\n    this._bufferResources = [];\n    this._renderer = renderer;\n    this._batchBuffer = new UboBatch({\n      minUniformOffsetAlignment\n    });\n    const totalBuffers = 256 / minUniformOffsetAlignment;\n    for (let i = 0; i < totalBuffers; i++) {\n      let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;\n      if (i === 0) usage |= BufferUsage.COPY_SRC;\n      this._buffers.push(new Buffer({\n        data: this._batchBuffer.data,\n        usage\n      }));\n    }\n  }\n  renderEnd() {\n    this._uploadBindGroups();\n    this._resetBindGroups();\n  }\n  _resetBindGroups() {\n    for (const i in this._bindGroupHash) {\n      this._bindGroupHash[i] = null;\n    }\n    this._batchBuffer.clear();\n  }\n  // just works for single bind groups for now\n  getUniformBindGroup(group, duplicate) {\n    if (!duplicate && this._bindGroupHash[group.uid]) {\n      return this._bindGroupHash[group.uid];\n    }\n    this._renderer.ubo.ensureUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addEmptyGroup(data.length);\n    this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n    this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n    return this._bindGroupHash[group.uid];\n  }\n  getUboResource(group) {\n    this._renderer.ubo.updateUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBufferResource(offset / minUniformOffsetAlignment);\n  }\n  getArrayBindGroup(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBindGroup(offset / minUniformOffsetAlignment);\n  }\n  getArrayBufferResource(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    const index = offset / minUniformOffsetAlignment;\n    return this._getBufferResource(index);\n  }\n  _getBufferResource(index) {\n    if (!this._bufferResources[index]) {\n      const buffer = this._buffers[index % 2];\n      this._bufferResources[index] = new BufferResource({\n        buffer,\n        offset: (index / 2 | 0) * 256,\n        size: minUniformOffsetAlignment\n      });\n    }\n    return this._bufferResources[index];\n  }\n  _getBindGroup(index) {\n    if (!this._bindGroups[index]) {\n      const bindGroup = new BindGroup({\n        0: this._getBufferResource(index)\n      });\n      this._bindGroups[index] = bindGroup;\n    }\n    return this._bindGroups[index];\n  }\n  _uploadBindGroups() {\n    const bufferSystem = this._renderer.buffer;\n    const firstBuffer = this._buffers[0];\n    firstBuffer.update(this._batchBuffer.byteIndex);\n    bufferSystem.updateBuffer(firstBuffer);\n    const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    for (let i = 1; i < this._buffers.length; i++) {\n      const buffer = this._buffers[i];\n      commandEncoder.copyBufferToBuffer(bufferSystem.getGPUBuffer(firstBuffer), minUniformOffsetAlignment, bufferSystem.getGPUBuffer(buffer), 0, this._batchBuffer.byteIndex);\n    }\n    this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n  }\n  destroy() {\n    for (let i = 0; i < this._bindGroups.length; i++) {\n      this._bindGroups[i].destroy();\n    }\n    this._bindGroups = null;\n    this._bindGroupHash = null;\n    for (let i = 0; i < this._buffers.length; i++) {\n      this._buffers[i].destroy();\n    }\n    this._buffers = null;\n    for (let i = 0; i < this._bufferResources.length; i++) {\n      this._bufferResources[i].destroy();\n    }\n    this._bufferResources = null;\n    this._batchBuffer.destroy();\n    this._bindGroupHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuUniformBatchPipe.extension = {\n  type: [ExtensionType.WebGPUPipes],\n  name: \"uniformBatch\"\n};\nexport { GpuUniformBatchPipe };","map":{"version":3,"names":["minUniformOffsetAlignment","GpuUniformBatchPipe","constructor","renderer","_bindGroupHash","Object","create","_buffers","_bindGroups","_bufferResources","_renderer","_batchBuffer","UboBatch","totalBuffers","i","usage","BufferUsage","UNIFORM","COPY_DST","COPY_SRC","push","Buffer","data","renderEnd","_uploadBindGroups","_resetBindGroups","clear","getUniformBindGroup","group","duplicate","uid","ubo","ensureUniformGroup","buffer","offset","addEmptyGroup","length","syncUniformGroup","_getBindGroup","getUboResource","updateUniformGroup","addGroup","_getBufferResource","getArrayBindGroup","getArrayBufferResource","index","BufferResource","size","bindGroup","BindGroup","bufferSystem","firstBuffer","update","byteIndex","updateBuffer","commandEncoder","gpu","device","createCommandEncoder","copyBufferToBuffer","getGPUBuffer","queue","submit","finish","destroy","extension","type","ExtensionType","WebGPUPipes","name"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gpu/GpuUniformBatchPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Buffer } from '../shared/buffer/Buffer';\nimport { BufferResource } from '../shared/buffer/BufferResource';\nimport { BufferUsage } from '../shared/buffer/const';\nimport { UboBatch } from './buffer/UboBatch';\nimport { BindGroup } from './shader/BindGroup';\n\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\nconst minUniformOffsetAlignment = 128;// 256 / 2;\n\n// TODO renderStart and renderFinish - perhaps just make them instructions to fit the architecture of the\n// rest of the system\nexport class GpuUniformBatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'uniformBatch',\n    } as const;\n\n    private _renderer: WebGPURenderer;\n\n    private _bindGroupHash: Record<number, BindGroup> = Object.create(null);\n    private readonly _batchBuffer: UboBatch;\n\n    // number of buffers..\n    private _buffers: Buffer[] = [];\n\n    private _bindGroups: BindGroup[] = [];\n    private _bufferResources: BufferResource[] = [];\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n\n        this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });\n\n        const totalBuffers = (256 / minUniformOffsetAlignment);\n\n        for (let i = 0; i < totalBuffers; i++)\n        {\n            let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;\n\n            if (i === 0) usage |= BufferUsage.COPY_SRC;\n\n            this._buffers.push(new Buffer({\n                data: this._batchBuffer.data,\n                usage\n            }));\n        }\n    }\n\n    public renderEnd()\n    {\n        this._uploadBindGroups();\n        this._resetBindGroups();\n    }\n\n    private _resetBindGroups()\n    {\n        for (const i in this._bindGroupHash)\n        {\n            this._bindGroupHash[i] = null;\n        }\n\n        this._batchBuffer.clear();\n    }\n\n    // just works for single bind groups for now\n    public getUniformBindGroup(group: UniformGroup<any>, duplicate: boolean): BindGroup\n    {\n        if (!duplicate && this._bindGroupHash[group.uid])\n        {\n            return this._bindGroupHash[group.uid];\n        }\n\n        this._renderer.ubo.ensureUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addEmptyGroup(data.length);\n\n        this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n\n        this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n\n        return this._bindGroupHash[group.uid];\n    }\n\n    public getUboResource(group: UniformGroup<any>): BufferResource\n    {\n        this._renderer.ubo.updateUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBufferResource(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBindGroup(data: Float32Array): BindGroup\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBindGroup(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBufferResource(data: Float32Array): BufferResource\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        const index = offset / minUniformOffsetAlignment;\n\n        return this._getBufferResource(index);\n    }\n\n    private _getBufferResource(index: number): BufferResource\n    {\n        if (!this._bufferResources[index])\n        {\n            const buffer = this._buffers[index % 2];\n\n            this._bufferResources[index] = new BufferResource({\n                buffer,\n                offset: ((index / 2) | 0) * 256,\n                size: minUniformOffsetAlignment\n            });\n        }\n\n        return this._bufferResources[index];\n    }\n\n    private _getBindGroup(index: number): BindGroup\n    {\n        if (!this._bindGroups[index])\n        {\n            // even!\n            const bindGroup = new BindGroup({\n                0: this._getBufferResource(index),\n            });\n\n            this._bindGroups[index] = bindGroup;\n        }\n\n        return this._bindGroups[index];\n    }\n\n    private _uploadBindGroups()\n    {\n        const bufferSystem = this._renderer.buffer;\n\n        const firstBuffer = this._buffers[0];\n\n        firstBuffer.update(this._batchBuffer.byteIndex);\n\n        bufferSystem.updateBuffer(firstBuffer);\n\n        const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n\n        for (let i = 1; i < this._buffers.length; i++)\n        {\n            const buffer = this._buffers[i];\n\n            commandEncoder.copyBufferToBuffer(\n                bufferSystem.getGPUBuffer(firstBuffer),\n                minUniformOffsetAlignment,\n                bufferSystem.getGPUBuffer(buffer),\n                0,\n                this._batchBuffer.byteIndex\n            );\n        }\n\n        // TODO make a system that will que up all commands in to one array?\n        this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this._bindGroups.length; i++)\n        {\n            this._bindGroups[i].destroy();\n        }\n\n        this._bindGroups = null;\n        this._bindGroupHash = null;\n\n        for (let i = 0; i < this._buffers.length; i++)\n        {\n            this._buffers[i].destroy();\n        }\n        this._buffers = null;\n\n        for (let i = 0; i < this._bufferResources.length; i++)\n        {\n            this._bufferResources[i].destroy();\n        }\n\n        this._bufferResources = null;\n\n        this._batchBuffer.destroy();\n        this._bindGroupHash = null;\n\n        this._renderer = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}