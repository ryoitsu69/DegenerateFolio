{"ast":null,"code":"import { BN } from '../bn/index.js';\nimport { u8aToBn, u8aToU8a } from '../u8a/index.js';\n/**\n * @name compactFromU8a\n * @description Retrives the offset and encoded length from a compact-prefixed value\n * @example\n * <BR>\n *\n * ```javascript\n * import { compactFromU8a } from '@polkadot/util';\n *\n * const [offset, length] = compactFromU8a(new Uint8Array([254, 255, 3, 0]));\n *\n * console.log('value offset=', offset, 'length=', length); // 4, 0xffff\n * ```\n */\nexport function compactFromU8a(input) {\n  const u8a = u8aToU8a(input);\n  // The u8a is manually converted here for 1, 2 & 4 lengths, it is 2x faster\n  // than doing an additional call to u8aToBn (as with variable length)\n  switch (u8a[0] & 0b11) {\n    case 0b00:\n      return [1, new BN(u8a[0] >>> 2)];\n    case 0b01:\n      return [2, new BN(u8a[0] + (u8a[1] << 8) >>> 2)];\n    case 0b10:\n      // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n      // 32-bit, in the case where the top-most bit is set this yields a negative value\n      return [4, new BN(u8a[0] + (u8a[1] << 8) + (u8a[2] << 16) + u8a[3] * 16777216 >>> 2)];\n    // 0b11\n    default:\n      {\n        // add 5 to shifted (4 for base length, 1 for this byte)\n        const offset = (u8a[0] >>> 2) + 5;\n        // we unroll the loop\n        switch (offset) {\n          // there still could be 4 bytes data, similar to 0b10 above (with offsets)\n          case 5:\n            // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n            // 32-bit, in the case where the top-most bit is set this yields a negative value\n            return [5, new BN(u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + u8a[4] * 16777216)];\n          case 6:\n            return [6, new BN(u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8)) * 16777216)];\n          // 6 bytes data is the maximum, 48 bits (56 would overflow)\n          case 7:\n            return [7, new BN(u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8) + (u8a[6] << 16)) * 16777216)];\n          // for anything else, use the non-unrolled version\n          default:\n            return [offset, u8aToBn(u8a.subarray(1, offset))];\n        }\n      }\n  }\n}\n/**\n * @name compactFromU8aLim\n * @description A limited version of [[compactFromU8a]], accepting only Uint8Array inputs for values <= 48 bits\n */\nexport function compactFromU8aLim(u8a) {\n  // The u8a is manually converted here for 1, 2 & 4 lengths, it is 2x faster\n  // than doing an additional call to u8aToBn (as with variable length)\n  switch (u8a[0] & 0b11) {\n    case 0b00:\n      return [1, u8a[0] >>> 2];\n    case 0b01:\n      return [2, u8a[0] + (u8a[1] << 8) >>> 2];\n    case 0b10:\n      // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n      // 32-bit, in the case where the top-most bit is set this yields a negative value\n      return [4, u8a[0] + (u8a[1] << 8) + (u8a[2] << 16) + u8a[3] * 16777216 >>> 2];\n    // 0b11\n    default:\n      {\n        // add 5 to shifted (4 for base length, 1 for this byte)\n        // we unroll the loop\n        switch ((u8a[0] >>> 2) + 5) {\n          // there still could be 4 bytes data, similar to 0b10 above (with offsets)\n          case 5:\n            return [5, u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + u8a[4] * 16777216];\n          case 6:\n            return [6, u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8)) * 16777216];\n          // 6 bytes data is the maximum, 48 bits (56 would overflow)\n          case 7:\n            return [7, u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] + (u8a[5] << 8) + (u8a[6] << 16)) * 16777216];\n          // for anything else, we are above the actual MAX_SAFE_INTEGER - bail out\n          default:\n            throw new Error('Compact input is > Number.MAX_SAFE_INTEGER');\n        }\n      }\n  }\n}","map":{"version":3,"names":["BN","u8aToBn","u8aToU8a","compactFromU8a","input","u8a","offset","subarray","compactFromU8aLim","Error"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util/compact/fromU8a.js"],"sourcesContent":["import { BN } from '../bn/index.js';\nimport { u8aToBn, u8aToU8a } from '../u8a/index.js';\n/**\n * @name compactFromU8a\n * @description Retrives the offset and encoded length from a compact-prefixed value\n * @example\n * <BR>\n *\n * ```javascript\n * import { compactFromU8a } from '@polkadot/util';\n *\n * const [offset, length] = compactFromU8a(new Uint8Array([254, 255, 3, 0]));\n *\n * console.log('value offset=', offset, 'length=', length); // 4, 0xffff\n * ```\n */\nexport function compactFromU8a(input) {\n    const u8a = u8aToU8a(input);\n    // The u8a is manually converted here for 1, 2 & 4 lengths, it is 2x faster\n    // than doing an additional call to u8aToBn (as with variable length)\n    switch (u8a[0] & 0b11) {\n        case 0b00:\n            return [1, new BN(u8a[0] >>> 2)];\n        case 0b01:\n            return [2, new BN((u8a[0] + (u8a[1] << 8)) >>> 2)];\n        case 0b10:\n            // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n            // 32-bit, in the case where the top-most bit is set this yields a negative value\n            return [4, new BN((u8a[0] + (u8a[1] << 8) + (u8a[2] << 16) + (u8a[3] * 16777216)) >>> 2)];\n        // 0b11\n        default: {\n            // add 5 to shifted (4 for base length, 1 for this byte)\n            const offset = (u8a[0] >>> 2) + 5;\n            // we unroll the loop\n            switch (offset) {\n                // there still could be 4 bytes data, similar to 0b10 above (with offsets)\n                case 5:\n                    // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n                    // 32-bit, in the case where the top-most bit is set this yields a negative value\n                    return [5, new BN(u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] * 16777216))];\n                case 6:\n                    return [6, new BN(u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + ((u8a[4] + (u8a[5] << 8)) * 16777216))];\n                // 6 bytes data is the maximum, 48 bits (56 would overflow)\n                case 7:\n                    return [7, new BN(u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + ((u8a[4] + (u8a[5] << 8) + (u8a[6] << 16)) * 16777216))];\n                // for anything else, use the non-unrolled version\n                default:\n                    return [offset, u8aToBn(u8a.subarray(1, offset))];\n            }\n        }\n    }\n}\n/**\n * @name compactFromU8aLim\n * @description A limited version of [[compactFromU8a]], accepting only Uint8Array inputs for values <= 48 bits\n */\nexport function compactFromU8aLim(u8a) {\n    // The u8a is manually converted here for 1, 2 & 4 lengths, it is 2x faster\n    // than doing an additional call to u8aToBn (as with variable length)\n    switch (u8a[0] & 0b11) {\n        case 0b00:\n            return [1, u8a[0] >>> 2];\n        case 0b01:\n            return [2, (u8a[0] + (u8a[1] << 8)) >>> 2];\n        case 0b10:\n            // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n            // 32-bit, in the case where the top-most bit is set this yields a negative value\n            return [4, (u8a[0] + (u8a[1] << 8) + (u8a[2] << 16) + (u8a[3] * 16777216)) >>> 2];\n        // 0b11\n        default: {\n            // add 5 to shifted (4 for base length, 1 for this byte)\n            // we unroll the loop\n            switch ((u8a[0] >>> 2) + 5) {\n                // there still could be 4 bytes data, similar to 0b10 above (with offsets)\n                case 5:\n                    return [5, u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + (u8a[4] * 16777216)];\n                case 6:\n                    return [6, u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + ((u8a[4] + (u8a[5] << 8)) * 16777216)];\n                // 6 bytes data is the maximum, 48 bits (56 would overflow)\n                case 7:\n                    return [7, u8a[1] + (u8a[2] << 8) + (u8a[3] << 16) + ((u8a[4] + (u8a[5] << 8) + (u8a[6] << 16)) * 16777216)];\n                // for anything else, we are above the actual MAX_SAFE_INTEGER - bail out\n                default:\n                    throw new Error('Compact input is > Number.MAX_SAFE_INTEGER');\n            }\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}