{"ast":null,"code":"import { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { Container } from '../scene/container/Container.mjs';\nimport { Graphics } from '../scene/graphics/shared/Graphics.mjs';\nimport { GraphicsContext } from '../scene/graphics/shared/GraphicsContext.mjs';\nimport { Mesh } from '../scene/mesh/shared/Mesh.mjs';\nimport { Sprite } from '../scene/sprite/Sprite.mjs';\nimport { AnimatedSprite } from '../scene/sprite-animated/AnimatedSprite.mjs';\nimport { TilingSprite } from '../scene/sprite-tiling/TilingSprite.mjs';\nimport { Text } from '../scene/text/Text.mjs';\nimport { PrepareBase } from './PrepareBase.mjs';\n\"use strict\";\nclass PrepareQueue extends PrepareBase {\n  /**\n   * Resolve the given resource type and return an item for the queue\n   * @param source\n   * @param queue\n   */\n  resolveQueueItem(source, queue) {\n    if (source instanceof Container) {\n      this.resolveContainerQueueItem(source, queue);\n    } else if (source instanceof TextureSource || source instanceof Texture) {\n      queue.push(source.source);\n    } else if (source instanceof GraphicsContext) {\n      queue.push(source);\n    }\n    return null;\n  }\n  /**\n   * Resolve the given container and return an item for the queue\n   * @param container\n   * @param queue\n   */\n  resolveContainerQueueItem(container, queue) {\n    if (container instanceof Sprite || container instanceof TilingSprite || container instanceof Mesh) {\n      queue.push(container.texture.source);\n    } else if (container instanceof Text) {\n      queue.push(container);\n    } else if (container instanceof Graphics) {\n      queue.push(container.context);\n    } else if (container instanceof AnimatedSprite) {\n      container.textures.forEach(textureOrFrame => {\n        if (textureOrFrame.source) {\n          queue.push(textureOrFrame.source);\n        } else {\n          queue.push(textureOrFrame.texture.source);\n        }\n      });\n    }\n  }\n  /**\n   * Resolve the given graphics context and return an item for the queue\n   * @param graphicsContext\n   */\n  resolveGraphicsContextQueueItem(graphicsContext) {\n    this.renderer.graphicsContext.getContextRenderData(graphicsContext);\n    const {\n      instructions\n    } = graphicsContext;\n    for (const instruction of instructions) {\n      if (instruction.action === \"texture\") {\n        const {\n          image\n        } = instruction.data;\n        return image.source;\n      } else if (instruction.action === \"fill\") {\n        const {\n          texture\n        } = instruction.data.style;\n        return texture.source;\n      }\n    }\n    return null;\n  }\n}\nexport { PrepareQueue };","map":{"version":3,"names":["PrepareQueue","PrepareBase","resolveQueueItem","source","queue","Container","resolveContainerQueueItem","TextureSource","Texture","push","GraphicsContext","container","Sprite","TilingSprite","Mesh","texture","Text","Graphics","context","AnimatedSprite","textures","forEach","textureOrFrame","resolveGraphicsContextQueueItem","graphicsContext","renderer","getContextRenderData","instructions","instruction","action","image","data","style"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/prepare/PrepareQueue.ts"],"sourcesContent":["import { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { Container } from '../scene/container/Container';\nimport { Graphics } from '../scene/graphics/shared/Graphics';\nimport { GraphicsContext } from '../scene/graphics/shared/GraphicsContext';\nimport { Mesh } from '../scene/mesh/shared/Mesh';\nimport { Sprite } from '../scene/sprite/Sprite';\nimport { AnimatedSprite } from '../scene/sprite-animated/AnimatedSprite';\nimport { TilingSprite } from '../scene/sprite-tiling/TilingSprite';\nimport { Text } from '../scene/text/Text';\nimport { PrepareBase } from './PrepareBase';\n\nimport type { FillInstruction, TextureInstruction } from '../scene/graphics/shared/GraphicsContext';\nimport type { FrameObject } from '../scene/sprite-animated/AnimatedSprite';\nimport type { PrepareQueueItem, PrepareSourceItem } from './PrepareBase';\n\n/**\n * Part of the prepare system. Responsible for uploading all the items to the GPU.\n * This class extends the base functionality and resolves given resource items ready for the queue.\n * @memberof rendering\n */\nexport abstract class PrepareQueue extends PrepareBase\n{\n    /**\n     * Resolve the given resource type and return an item for the queue\n     * @param source\n     * @param queue\n     */\n    protected resolveQueueItem(source: PrepareSourceItem, queue: PrepareQueueItem[]): void\n    {\n        if (source instanceof Container)\n        {\n            this.resolveContainerQueueItem(source, queue);\n        }\n        else if (source instanceof TextureSource || source instanceof Texture)\n        {\n            queue.push(source.source);\n        }\n        else if (source instanceof GraphicsContext)\n        {\n            queue.push(source);\n        }\n\n        // could not resolve the resource type\n        return null;\n    }\n\n    /**\n     * Resolve the given container and return an item for the queue\n     * @param container\n     * @param queue\n     */\n    protected resolveContainerQueueItem(container: Container, queue: PrepareQueueItem[]): void\n    {\n        // Note: we are just concerned with the given view.\n        // Children are handled by the recursive call of the base class\n\n        if (container instanceof Sprite || container instanceof TilingSprite || container instanceof Mesh)\n        {\n            queue.push(container.texture.source);\n        }\n        else if (container instanceof Text)\n        {\n            queue.push(container);\n        }\n        else if (container instanceof Graphics)\n        {\n            queue.push(container.context);\n        }\n        else if (container instanceof AnimatedSprite)\n        {\n            container.textures.forEach((textureOrFrame) =>\n            {\n                if ((textureOrFrame as Texture).source)\n                {\n                    queue.push((textureOrFrame as Texture).source);\n                }\n                else\n                {\n                    queue.push((textureOrFrame as FrameObject).texture.source);\n                }\n            });\n        }\n    }\n\n    /**\n     * Resolve the given graphics context and return an item for the queue\n     * @param graphicsContext\n     */\n    protected resolveGraphicsContextQueueItem(graphicsContext: GraphicsContext): PrepareQueueItem | null\n    {\n        this.renderer.graphicsContext.getContextRenderData(graphicsContext);\n\n        const { instructions } = graphicsContext;\n\n        for (const instruction of instructions)\n        {\n            if (instruction.action === 'texture')\n            {\n                const { image } = (instruction as TextureInstruction).data;\n\n                return image.source;\n            }\n            else if (instruction.action === 'fill')\n            {\n                const { texture } = (instruction as FillInstruction).data.style;\n\n                return texture.source;\n            }\n        }\n\n        return null;\n    }\n}\n"],"mappings":";;;;;;;;;;;;AAqBO,MAAeA,YAAA,SAAqBC,WAC3C;EAAA;AAAA;AAAA;AAAA;AAAA;EAMcC,iBAAiBC,MAAA,EAA2BC,KACtD;IACI,IAAID,MAAA,YAAkBE,SACtB;MACS,KAAAC,yBAAA,CAA0BH,MAAA,EAAQC,KAAK;IAAA,CAEvC,UAAAD,MAAA,YAAkBI,aAAiB,IAAAJ,MAAA,YAAkBK,OAC9D;MACUJ,KAAA,CAAAK,IAAA,CAAKN,MAAA,CAAOA,MAAM;IAAA,CAC5B,UACSA,MAAA,YAAkBO,eAC3B;MACIN,KAAA,CAAMK,IAAA,CAAKN,MAAM;IAAA;IAId;EAAA;EACX;AAAA;AAAA;AAAA;AAAA;EAOUG,0BAA0BK,SAAA,EAAsBP,KAC1D;IAII,IAAIO,SAAqB,YAAAC,MAAA,IAAUD,SAAqB,YAAAE,YAAA,IAAgBF,SAAA,YAAqBG,IAC7F;MACUV,KAAA,CAAAK,IAAA,CAAKE,SAAU,CAAAI,OAAA,CAAQZ,MAAM;IAAA,CACvC,UACSQ,SAAA,YAAqBK,IAC9B;MACIZ,KAAA,CAAMK,IAAA,CAAKE,SAAS;IAAA,CACxB,UACSA,SAAA,YAAqBM,QAC9B;MACUb,KAAA,CAAAK,IAAA,CAAKE,SAAA,CAAUO,OAAO;IAAA,CAChC,UACSP,SAAA,YAAqBQ,cAC9B;MACcR,SAAA,CAAAS,QAAA,CAASC,OAAQ,CAACC,cAC5B;QACI,IAAKA,cAAA,CAA2BnB,MAChC;UACUC,KAAA,CAAAK,IAAA,CAAMa,cAAA,CAA2BnB,MAAM;QAAA,CAGjD;UACUC,KAAA,CAAAK,IAAA,CAAMa,cAA+B,CAAAP,OAAA,CAAQZ,MAAM;QAAA;MAC7D,CACH;IAAA;EACL;EACJ;AAAA;AAAA;AAAA;EAMUoB,gCAAgCC,eAC1C;IACS,KAAAC,QAAA,CAASD,eAAgB,CAAAE,oBAAA,CAAqBF,eAAe;IAE5D;MAAEG;IAAA,CAAiB,GAAAH,eAAA;IAEzB,WAAWI,WAAA,IAAeD,YAC1B;MACQ,IAAAC,WAAA,CAAYC,MAAA,KAAW,SAC3B;QACU;UAAEC;QAAM,IAAKF,WAAmC,CAAAG,IAAA;QAEtD,OAAOD,KAAM,CAAA3B,MAAA;MAAA,CACjB,UACSyB,WAAY,CAAAC,MAAA,KAAW,MAChC;QACI,MAAM;UAAEd;QAAA,CAAa,GAAAa,WAAA,CAAgCG,IAAK,CAAAC,KAAA;QAE1D,OAAOjB,OAAQ,CAAAZ,MAAA;MAAA;IACnB;IAGG;EAAA;AAEf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}