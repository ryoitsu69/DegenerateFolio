{"ast":null,"code":"import { stringCamelCase } from '@polkadot/util';\nimport { getAliasTypes } from '../../interfaces/alias.js';\nimport { knownOrigins } from '../../interfaces/runtime/definitions.js';\nconst BOXES = [['<', '>'], ['<', ','], [',', '>'], ['(', ')'], ['(', ','], [',', ','], [',', ')']];\n/**\n * Creates a compatible type mapping\n * @internal\n **/\nfunction compatType(specs, _type) {\n  const type = _type.toString();\n  const index = specs.findIndex(({\n    def\n  }) => def.HistoricMetaCompat === type);\n  if (index !== -1) {\n    return index;\n  }\n  return specs.push({\n    def: {\n      HistoricMetaCompat: type\n    }\n  }) - 1;\n}\nfunction compatTypes(specs, ...types) {\n  for (let i = 0, count = types.length; i < count; i++) {\n    compatType(specs, types[i]);\n  }\n}\nfunction makeTupleType(specs, entries) {\n  return specs.push({\n    def: {\n      Tuple: entries\n    }\n  }) - 1;\n}\nfunction makeVariantType(modName, variantType, specs, variants) {\n  return specs.push({\n    def: {\n      Variant: {\n        variants\n      }\n    },\n    path: [`pallet_${modName.toString()}`, 'pallet', variantType]\n  }) - 1;\n}\n/**\n * @internal\n * generate & register the OriginCaller type\n **/\nfunction registerOriginCaller(registry, modules, metaVersion) {\n  registry.register({\n    OriginCaller: {\n      _enum: modules.map((mod, index) => [mod.name.toString(), metaVersion >= 12 ? mod.index.toNumber() : index]).sort((a, b) => a[1] - b[1]).reduce((result, [name, index]) => {\n        for (let i = Object.keys(result).length; i < index; i++) {\n          result[`Empty${i}`] = 'Null';\n        }\n        result[name] = knownOrigins[name] || 'Null';\n        return result;\n      }, {})\n    }\n  });\n}\n/**\n * Find and apply the correct type override\n * @internal\n **/\nfunction setTypeOverride(sectionTypes, types) {\n  types.forEach(type => {\n    const override = Object.keys(sectionTypes).find(aliased => type.eq(aliased));\n    if (override) {\n      type.setOverride(sectionTypes[override]);\n    } else {\n      // FIXME: NOT happy with this approach, but gets over the initial hump cased by (Vec<Announcement>,BalanceOf)\n      const orig = type.toString();\n      const alias = Object.entries(sectionTypes).reduce((result, [src, dst]) => BOXES.reduce((result, [a, z]) => result.replace(`${a}${src}${z}`, `${a}${dst}${z}`), result), orig);\n      if (orig !== alias) {\n        type.setOverride(alias);\n      }\n    }\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n **/\nfunction convertCalls(specs, registry, modName, calls, sectionTypes) {\n  const variants = calls.map(({\n    args,\n    docs,\n    name\n  }, index) => {\n    setTypeOverride(sectionTypes, args.map(({\n      type\n    }) => type));\n    return registry.createTypeUnsafe('SiVariant', [{\n      docs,\n      fields: args.map(({\n        name,\n        type\n      }) => registry.createTypeUnsafe('SiField', [{\n        name,\n        type: compatType(specs, type)\n      }])),\n      index,\n      name\n    }]);\n  });\n  return registry.createTypeUnsafe('PalletCallMetadataV14', [{\n    type: makeVariantType(modName, 'Call', specs, variants)\n  }]);\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n */\nfunction convertConstants(specs, registry, constants, sectionTypes) {\n  return constants.map(({\n    docs,\n    name,\n    type,\n    value\n  }) => {\n    setTypeOverride(sectionTypes, [type]);\n    return registry.createTypeUnsafe('PalletConstantMetadataV14', [{\n      docs,\n      name,\n      type: compatType(specs, type),\n      value\n    }]);\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n */\nfunction convertErrors(specs, registry, modName, errors, _sectionTypes) {\n  const variants = errors.map(({\n    docs,\n    name\n  }, index) => registry.createTypeUnsafe('SiVariant', [{\n    docs,\n    fields: [],\n    index,\n    name\n  }]));\n  return registry.createTypeUnsafe('PalletErrorMetadataV14', [{\n    type: makeVariantType(modName, 'Error', specs, variants)\n  }]);\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n **/\nfunction convertEvents(specs, registry, modName, events, sectionTypes) {\n  const variants = events.map(({\n    args,\n    docs,\n    name\n  }, index) => {\n    setTypeOverride(sectionTypes, args);\n    return registry.createTypeUnsafe('SiVariant', [{\n      docs,\n      fields: args.map(t => registry.createTypeUnsafe('SiField', [{\n        type: compatType(specs, t)\n      }])),\n      index,\n      name\n    }]);\n  });\n  return registry.createTypeUnsafe('PalletEventMetadataV14', [{\n    type: makeVariantType(modName, 'Event', specs, variants)\n  }]);\n}\nfunction createMapEntry(specs, registry, sectionTypes, {\n  hashers,\n  isLinked,\n  isOptional,\n  keys,\n  value\n}) {\n  setTypeOverride(sectionTypes, [value, ...(Array.isArray(keys) ? keys : [keys])]);\n  return registry.createTypeUnsafe('StorageEntryTypeV14', [{\n    Map: {\n      hashers,\n      key: hashers.length === 1 ? compatType(specs, keys[0]) : makeTupleType(specs, keys.map(t => compatType(specs, t))),\n      value: isLinked\n      // For previous-generation linked-map support, the actual storage result\n      // is a Tuple with the value and the Linkage (Option appears in teh value-part only)\n      ? compatType(specs, `(${isOptional ? `Option<${value.toString()}>` : value.toString()}, Linkage<${keys[0].toString()}>)`) : compatType(specs, value)\n    }\n  }]);\n}\n/**\n * Apply module-specific storage type overrides (always part of toV14)\n * @internal\n **/\nfunction convertStorage(specs, registry, {\n  items,\n  prefix\n}, sectionTypes) {\n  return registry.createTypeUnsafe('PalletStorageMetadataV14', [{\n    items: items.map(({\n      docs,\n      fallback,\n      modifier,\n      name,\n      type\n    }) => {\n      let entryType;\n      if (type.isPlain) {\n        const plain = type.asPlain;\n        setTypeOverride(sectionTypes, [plain]);\n        entryType = registry.createTypeUnsafe('StorageEntryTypeV14', [{\n          Plain: compatType(specs, plain)\n        }]);\n      } else if (type.isMap) {\n        const map = type.asMap;\n        entryType = createMapEntry(specs, registry, sectionTypes, {\n          hashers: [map.hasher],\n          isLinked: map.linked.isTrue,\n          isOptional: modifier.isOptional,\n          keys: [map.key],\n          value: map.value\n        });\n      } else if (type.isDoubleMap) {\n        const dm = type.asDoubleMap;\n        entryType = createMapEntry(specs, registry, sectionTypes, {\n          hashers: [dm.hasher, dm.key2Hasher],\n          isLinked: false,\n          isOptional: modifier.isOptional,\n          keys: [dm.key1, dm.key2],\n          value: dm.value\n        });\n      } else {\n        const nm = type.asNMap;\n        entryType = createMapEntry(specs, registry, sectionTypes, {\n          hashers: nm.hashers,\n          isLinked: false,\n          isOptional: modifier.isOptional,\n          keys: nm.keyVec,\n          value: nm.value\n        });\n      }\n      return registry.createTypeUnsafe('StorageEntryMetadataV14', [{\n        docs,\n        fallback,\n        modifier,\n        name,\n        type: entryType\n      }]);\n    }),\n    prefix\n  }]);\n}\n/** @internal */\nfunction convertExtrinsic(registry, {\n  signedExtensions,\n  version\n}) {\n  return registry.createTypeUnsafe('ExtrinsicMetadataV14', [{\n    signedExtensions: signedExtensions.map(identifier => ({\n      identifier,\n      type: 0 // we don't map the fields at all\n    })),\n    type: 0,\n    // Map to extrinsic like in v14?\n    version\n  }]);\n}\n/** @internal */\nfunction createPallet(specs, registry, mod, {\n  calls,\n  constants,\n  errors,\n  events,\n  storage\n}) {\n  const sectionTypes = getAliasTypes(registry, stringCamelCase(mod.name));\n  return registry.createTypeUnsafe('PalletMetadataV14', [{\n    calls: calls && convertCalls(specs, registry, mod.name, calls, sectionTypes),\n    constants: convertConstants(specs, registry, constants, sectionTypes),\n    errors: errors && convertErrors(specs, registry, mod.name, errors, sectionTypes),\n    events: events && convertEvents(specs, registry, mod.name, events, sectionTypes),\n    index: mod.index,\n    name: mod.name,\n    storage: storage && convertStorage(specs, registry, storage, sectionTypes)\n  }]);\n}\n/**\n * Convert the Metadata to v14\n * @internal\n **/\nexport function toV14(registry, v13, metaVersion) {\n  const specs = [];\n  // position 0 always has Null, additionally add internal defaults\n  compatTypes(specs, 'Null', 'u8', 'u16', 'u32', 'u64');\n  registerOriginCaller(registry, v13.modules, metaVersion);\n  const extrinsic = convertExtrinsic(registry, v13.extrinsic);\n  const pallets = v13.modules.map(mod => createPallet(specs, registry, mod, {\n    calls: mod.calls.unwrapOr(null),\n    constants: mod.constants,\n    errors: mod.errors.length ? mod.errors : null,\n    events: mod.events.unwrapOr(null),\n    storage: mod.storage.unwrapOr(null)\n  }));\n  return registry.createTypeUnsafe('MetadataV14', [{\n    extrinsic,\n    lookup: {\n      types: specs.map((type, id) => registry.createTypeUnsafe('PortableType', [{\n        id,\n        type\n      }]))\n    },\n    pallets\n  }]);\n}","map":{"version":3,"names":["stringCamelCase","getAliasTypes","knownOrigins","BOXES","compatType","specs","_type","type","toString","index","findIndex","def","HistoricMetaCompat","push","compatTypes","types","i","count","length","makeTupleType","entries","Tuple","makeVariantType","modName","variantType","variants","Variant","path","registerOriginCaller","registry","modules","metaVersion","register","OriginCaller","_enum","map","mod","name","toNumber","sort","a","b","reduce","result","Object","keys","setTypeOverride","sectionTypes","forEach","override","find","aliased","eq","setOverride","orig","alias","src","dst","z","replace","convertCalls","calls","args","docs","createTypeUnsafe","fields","convertConstants","constants","value","convertErrors","errors","_sectionTypes","convertEvents","events","t","createMapEntry","hashers","isLinked","isOptional","Array","isArray","Map","key","convertStorage","items","prefix","fallback","modifier","entryType","isPlain","plain","asPlain","Plain","isMap","asMap","hasher","linked","isTrue","isDoubleMap","dm","asDoubleMap","key2Hasher","key1","key2","nm","asNMap","keyVec","convertExtrinsic","signedExtensions","version","identifier","createPallet","storage","toV14","v13","extrinsic","pallets","unwrapOr","lookup","id"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/metadata/v13/toV14.js"],"sourcesContent":["import { stringCamelCase } from '@polkadot/util';\nimport { getAliasTypes } from '../../interfaces/alias.js';\nimport { knownOrigins } from '../../interfaces/runtime/definitions.js';\nconst BOXES = [['<', '>'], ['<', ','], [',', '>'], ['(', ')'], ['(', ','], [',', ','], [',', ')']];\n/**\n * Creates a compatible type mapping\n * @internal\n **/\nfunction compatType(specs, _type) {\n    const type = _type.toString();\n    const index = specs.findIndex(({ def }) => def.HistoricMetaCompat === type);\n    if (index !== -1) {\n        return index;\n    }\n    return specs.push({\n        def: {\n            HistoricMetaCompat: type\n        }\n    }) - 1;\n}\nfunction compatTypes(specs, ...types) {\n    for (let i = 0, count = types.length; i < count; i++) {\n        compatType(specs, types[i]);\n    }\n}\nfunction makeTupleType(specs, entries) {\n    return specs.push({\n        def: {\n            Tuple: entries\n        }\n    }) - 1;\n}\nfunction makeVariantType(modName, variantType, specs, variants) {\n    return specs.push({\n        def: {\n            Variant: { variants }\n        },\n        path: [`pallet_${modName.toString()}`, 'pallet', variantType]\n    }) - 1;\n}\n/**\n * @internal\n * generate & register the OriginCaller type\n **/\nfunction registerOriginCaller(registry, modules, metaVersion) {\n    registry.register({\n        OriginCaller: {\n            _enum: modules\n                .map((mod, index) => [\n                mod.name.toString(),\n                metaVersion >= 12\n                    ? mod.index.toNumber()\n                    : index\n            ])\n                .sort((a, b) => a[1] - b[1])\n                .reduce((result, [name, index]) => {\n                for (let i = Object.keys(result).length; i < index; i++) {\n                    result[`Empty${i}`] = 'Null';\n                }\n                result[name] = knownOrigins[name] || 'Null';\n                return result;\n            }, {})\n        }\n    });\n}\n/**\n * Find and apply the correct type override\n * @internal\n **/\nfunction setTypeOverride(sectionTypes, types) {\n    types.forEach((type) => {\n        const override = Object.keys(sectionTypes).find((aliased) => type.eq(aliased));\n        if (override) {\n            type.setOverride(sectionTypes[override]);\n        }\n        else {\n            // FIXME: NOT happy with this approach, but gets over the initial hump cased by (Vec<Announcement>,BalanceOf)\n            const orig = type.toString();\n            const alias = Object\n                .entries(sectionTypes)\n                .reduce((result, [src, dst]) => BOXES.reduce((result, [a, z]) => result.replace(`${a}${src}${z}`, `${a}${dst}${z}`), result), orig);\n            if (orig !== alias) {\n                type.setOverride(alias);\n            }\n        }\n    });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n **/\nfunction convertCalls(specs, registry, modName, calls, sectionTypes) {\n    const variants = calls.map(({ args, docs, name }, index) => {\n        setTypeOverride(sectionTypes, args.map(({ type }) => type));\n        return registry.createTypeUnsafe('SiVariant', [{\n                docs,\n                fields: args.map(({ name, type }) => registry.createTypeUnsafe('SiField', [{ name, type: compatType(specs, type) }])),\n                index,\n                name\n            }]);\n    });\n    return registry.createTypeUnsafe('PalletCallMetadataV14', [{\n            type: makeVariantType(modName, 'Call', specs, variants)\n        }]);\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n */\nfunction convertConstants(specs, registry, constants, sectionTypes) {\n    return constants.map(({ docs, name, type, value }) => {\n        setTypeOverride(sectionTypes, [type]);\n        return registry.createTypeUnsafe('PalletConstantMetadataV14', [{\n                docs,\n                name,\n                type: compatType(specs, type),\n                value\n            }]);\n    });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n */\nfunction convertErrors(specs, registry, modName, errors, _sectionTypes) {\n    const variants = errors.map(({ docs, name }, index) => registry.createTypeUnsafe('SiVariant', [{\n            docs,\n            fields: [],\n            index,\n            name\n        }]));\n    return registry.createTypeUnsafe('PalletErrorMetadataV14', [{\n            type: makeVariantType(modName, 'Error', specs, variants)\n        }]);\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n **/\nfunction convertEvents(specs, registry, modName, events, sectionTypes) {\n    const variants = events.map(({ args, docs, name }, index) => {\n        setTypeOverride(sectionTypes, args);\n        return registry.createTypeUnsafe('SiVariant', [{\n                docs,\n                fields: args.map((t) => registry.createTypeUnsafe('SiField', [{ type: compatType(specs, t) }])),\n                index,\n                name\n            }]);\n    });\n    return registry.createTypeUnsafe('PalletEventMetadataV14', [{\n            type: makeVariantType(modName, 'Event', specs, variants)\n        }]);\n}\nfunction createMapEntry(specs, registry, sectionTypes, { hashers, isLinked, isOptional, keys, value }) {\n    setTypeOverride(sectionTypes, [value, ...(Array.isArray(keys) ? keys : [keys])]);\n    return registry.createTypeUnsafe('StorageEntryTypeV14', [{\n            Map: {\n                hashers,\n                key: hashers.length === 1\n                    ? compatType(specs, keys[0])\n                    : makeTupleType(specs, keys.map((t) => compatType(specs, t))),\n                value: isLinked\n                    // For previous-generation linked-map support, the actual storage result\n                    // is a Tuple with the value and the Linkage (Option appears in teh value-part only)\n                    ? compatType(specs, `(${isOptional ? `Option<${value.toString()}>` : value.toString()}, Linkage<${keys[0].toString()}>)`)\n                    : compatType(specs, value)\n            }\n        }]);\n}\n/**\n * Apply module-specific storage type overrides (always part of toV14)\n * @internal\n **/\nfunction convertStorage(specs, registry, { items, prefix }, sectionTypes) {\n    return registry.createTypeUnsafe('PalletStorageMetadataV14', [{\n            items: items.map(({ docs, fallback, modifier, name, type }) => {\n                let entryType;\n                if (type.isPlain) {\n                    const plain = type.asPlain;\n                    setTypeOverride(sectionTypes, [plain]);\n                    entryType = registry.createTypeUnsafe('StorageEntryTypeV14', [{\n                            Plain: compatType(specs, plain)\n                        }]);\n                }\n                else if (type.isMap) {\n                    const map = type.asMap;\n                    entryType = createMapEntry(specs, registry, sectionTypes, {\n                        hashers: [map.hasher],\n                        isLinked: map.linked.isTrue,\n                        isOptional: modifier.isOptional,\n                        keys: [map.key],\n                        value: map.value\n                    });\n                }\n                else if (type.isDoubleMap) {\n                    const dm = type.asDoubleMap;\n                    entryType = createMapEntry(specs, registry, sectionTypes, {\n                        hashers: [dm.hasher, dm.key2Hasher],\n                        isLinked: false,\n                        isOptional: modifier.isOptional,\n                        keys: [dm.key1, dm.key2],\n                        value: dm.value\n                    });\n                }\n                else {\n                    const nm = type.asNMap;\n                    entryType = createMapEntry(specs, registry, sectionTypes, {\n                        hashers: nm.hashers,\n                        isLinked: false,\n                        isOptional: modifier.isOptional,\n                        keys: nm.keyVec,\n                        value: nm.value\n                    });\n                }\n                return registry.createTypeUnsafe('StorageEntryMetadataV14', [{\n                        docs,\n                        fallback,\n                        modifier,\n                        name,\n                        type: entryType\n                    }]);\n            }),\n            prefix\n        }]);\n}\n/** @internal */\nfunction convertExtrinsic(registry, { signedExtensions, version }) {\n    return registry.createTypeUnsafe('ExtrinsicMetadataV14', [{\n            signedExtensions: signedExtensions.map((identifier) => ({\n                identifier,\n                type: 0 // we don't map the fields at all\n            })),\n            type: 0, // Map to extrinsic like in v14?\n            version\n        }]);\n}\n/** @internal */\nfunction createPallet(specs, registry, mod, { calls, constants, errors, events, storage }) {\n    const sectionTypes = getAliasTypes(registry, stringCamelCase(mod.name));\n    return registry.createTypeUnsafe('PalletMetadataV14', [{\n            calls: calls && convertCalls(specs, registry, mod.name, calls, sectionTypes),\n            constants: convertConstants(specs, registry, constants, sectionTypes),\n            errors: errors && convertErrors(specs, registry, mod.name, errors, sectionTypes),\n            events: events && convertEvents(specs, registry, mod.name, events, sectionTypes),\n            index: mod.index,\n            name: mod.name,\n            storage: storage && convertStorage(specs, registry, storage, sectionTypes)\n        }]);\n}\n/**\n * Convert the Metadata to v14\n * @internal\n **/\nexport function toV14(registry, v13, metaVersion) {\n    const specs = [];\n    // position 0 always has Null, additionally add internal defaults\n    compatTypes(specs, 'Null', 'u8', 'u16', 'u32', 'u64');\n    registerOriginCaller(registry, v13.modules, metaVersion);\n    const extrinsic = convertExtrinsic(registry, v13.extrinsic);\n    const pallets = v13.modules.map((mod) => createPallet(specs, registry, mod, {\n        calls: mod.calls.unwrapOr(null),\n        constants: mod.constants,\n        errors: mod.errors.length ? mod.errors : null,\n        events: mod.events.unwrapOr(null),\n        storage: mod.storage.unwrapOr(null)\n    }));\n    return registry.createTypeUnsafe('MetadataV14', [{\n            extrinsic,\n            lookup: {\n                types: specs.map((type, id) => registry.createTypeUnsafe('PortableType', [{ id, type }]))\n            },\n            pallets\n        }]);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}