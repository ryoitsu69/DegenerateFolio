{"ast":null,"code":"import { Point } from '../../../../maths/point/Point.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { SVGToGraphicsPath } from '../svg/SVGToGraphicsPath.mjs';\nimport { ShapePath } from './ShapePath.mjs';\n\"use strict\";\nclass GraphicsPath {\n  /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   */\n  constructor(instructions) {\n    this.instructions = [];\n    this.uid = uid(\"graphicsPath\");\n    this._dirty = true;\n    if (typeof instructions === \"string\") {\n      SVGToGraphicsPath(instructions, this);\n    } else {\n      this.instructions = instructions?.slice() ?? [];\n    }\n  }\n  /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */\n  get shapePath() {\n    if (!this._shapePath) {\n      this._shapePath = new ShapePath(this);\n    }\n    if (this._dirty) {\n      this._dirty = false;\n      this._shapePath.buildPath();\n    }\n    return this._shapePath;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    path = path.clone();\n    this.instructions.push({\n      action: \"addPath\",\n      data: [path, transform]\n    });\n    this._dirty = true;\n    return this;\n  }\n  arc(...args) {\n    this.instructions.push({\n      action: \"arc\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  arcTo(...args) {\n    this.instructions.push({\n      action: \"arcTo\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  arcToSvg(...args) {\n    this.instructions.push({\n      action: \"arcToSvg\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  bezierCurveTo(...args) {\n    this.instructions.push({\n      action: \"bezierCurveTo\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.shared);\n    let cp1x = 0;\n    let cp1y = 0;\n    if (!last || last.action !== \"bezierCurveTo\") {\n      cp1x = lastPoint.x;\n      cp1y = lastPoint.y;\n    } else {\n      cp1x = last.data[2];\n      cp1y = last.data[3];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cp1x = currentX + (currentX - cp1x);\n      cp1y = currentY + (currentY - cp1y);\n    }\n    this.instructions.push({\n      action: \"bezierCurveTo\",\n      data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness]\n    });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.instructions.push({\n      action: \"closePath\",\n      data: []\n    });\n    this._dirty = true;\n    return this;\n  }\n  ellipse(...args) {\n    this.instructions.push({\n      action: \"ellipse\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  lineTo(...args) {\n    this.instructions.push({\n      action: \"lineTo\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  moveTo(...args) {\n    this.instructions.push({\n      action: \"moveTo\",\n      data: args\n    });\n    return this;\n  }\n  quadraticCurveTo(...args) {\n    this.instructions.push({\n      action: \"quadraticCurveTo\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveToShort(x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.shared);\n    let cpx1 = 0;\n    let cpy1 = 0;\n    if (!last || last.action !== \"quadraticCurveTo\") {\n      cpx1 = lastPoint.x;\n      cpy1 = lastPoint.y;\n    } else {\n      cpx1 = last.data[0];\n      cpy1 = last.data[1];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cpx1 = currentX + (currentX - cpx1);\n      cpy1 = currentY + (currentY - cpy1);\n    }\n    this.instructions.push({\n      action: \"quadraticCurveTo\",\n      data: [cpx1, cpy1, x, y, smoothness]\n    });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.instructions.push({\n      action: \"rect\",\n      data: [x, y, w, h, transform]\n    });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.instructions.push({\n      action: \"circle\",\n      data: [x, y, radius, transform]\n    });\n    this._dirty = true;\n    return this;\n  }\n  roundRect(...args) {\n    this.instructions.push({\n      action: \"roundRect\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  poly(...args) {\n    this.instructions.push({\n      action: \"poly\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  regularPoly(...args) {\n    this.instructions.push({\n      action: \"regularPoly\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  roundPoly(...args) {\n    this.instructions.push({\n      action: \"roundPoly\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  roundShape(...args) {\n    this.instructions.push({\n      action: \"roundShape\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  filletRect(...args) {\n    this.instructions.push({\n      action: \"filletRect\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  chamferRect(...args) {\n    this.instructions.push({\n      action: \"chamferRect\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  // eslint-disable-next-line max-len\n  star(x, y, points, radius, innerRadius, rotation, transform) {\n    innerRadius = innerRadius || radius / 2;\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const len = points * 2;\n    const delta = Math.PI * 2 / len;\n    const polygon = [];\n    for (let i = 0; i < len; i++) {\n      const r = i % 2 ? innerRadius : radius;\n      const angle = i * delta + startAngle;\n      polygon.push(x + r * Math.cos(angle), y + r * Math.sin(angle));\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */\n  clone(deep = false) {\n    const newGraphicsPath2D = new GraphicsPath();\n    if (!deep) {\n      newGraphicsPath2D.instructions = this.instructions.slice();\n    } else {\n      for (let i = 0; i < this.instructions.length; i++) {\n        const instruction = this.instructions[i];\n        newGraphicsPath2D.instructions.push({\n          action: instruction.action,\n          data: instruction.data.slice()\n        });\n      }\n    }\n    return newGraphicsPath2D;\n  }\n  clear() {\n    this.instructions.length = 0;\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path's geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path's appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */\n  transform(matrix) {\n    if (matrix.isIdentity()) return this;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let x = 0;\n    let y = 0;\n    let cpx1 = 0;\n    let cpy1 = 0;\n    let cpx2 = 0;\n    let cpy2 = 0;\n    let rx = 0;\n    let ry = 0;\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const data = instruction.data;\n      switch (instruction.action) {\n        case \"moveTo\":\n        case \"lineTo\":\n          x = data[0];\n          y = data[1];\n          data[0] = a * x + c * y + tx;\n          data[1] = b * x + d * y + ty;\n          break;\n        case \"bezierCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          cpx2 = data[2];\n          cpy2 = data[3];\n          x = data[4];\n          y = data[5];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * cpx2 + c * cpy2 + tx;\n          data[3] = b * cpx2 + d * cpy2 + ty;\n          data[4] = a * x + c * y + tx;\n          data[5] = b * x + d * y + ty;\n          break;\n        case \"quadraticCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          x = data[2];\n          y = data[3];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * x + c * y + tx;\n          data[3] = b * x + d * y + ty;\n          break;\n        case \"arcToSvg\":\n          x = data[5];\n          y = data[6];\n          rx = data[0];\n          ry = data[1];\n          data[0] = a * rx + c * ry;\n          data[1] = b * rx + d * ry;\n          data[5] = a * x + c * y + tx;\n          data[6] = b * x + d * y + ty;\n          break;\n        case \"circle\":\n          data[4] = adjustTransform(data[3], matrix);\n          break;\n        case \"rect\":\n          data[4] = adjustTransform(data[4], matrix);\n          break;\n        case \"ellipse\":\n          data[8] = adjustTransform(data[8], matrix);\n          break;\n        case \"roundRect\":\n          data[5] = adjustTransform(data[5], matrix);\n          break;\n        case \"addPath\":\n          data[0].transform(matrix);\n          break;\n        case \"poly\":\n          data[2] = adjustTransform(data[2], matrix);\n          break;\n        default:\n          warn(\"unknown transform action\", instruction.action);\n          break;\n      }\n    }\n    this._dirty = true;\n    return this;\n  }\n  get bounds() {\n    return this.shapePath.bounds;\n  }\n  /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path's current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point's position is accurately determined regardless of the path's complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point's coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point's coordinates.\n   */\n  getLastPoint(out) {\n    let index = this.instructions.length - 1;\n    let lastInstruction = this.instructions[index];\n    if (!lastInstruction) {\n      out.x = 0;\n      out.y = 0;\n      return out;\n    }\n    while (lastInstruction.action === \"closePath\") {\n      index--;\n      if (index < 0) {\n        out.x = 0;\n        out.y = 0;\n        return out;\n      }\n      lastInstruction = this.instructions[index];\n    }\n    switch (lastInstruction.action) {\n      case \"moveTo\":\n      case \"lineTo\":\n        out.x = lastInstruction.data[0];\n        out.y = lastInstruction.data[1];\n        break;\n      case \"quadraticCurveTo\":\n        out.x = lastInstruction.data[2];\n        out.y = lastInstruction.data[3];\n        break;\n      case \"bezierCurveTo\":\n        out.x = lastInstruction.data[4];\n        out.y = lastInstruction.data[5];\n        break;\n      case \"arc\":\n      case \"arcToSvg\":\n        out.x = lastInstruction.data[5];\n        out.y = lastInstruction.data[6];\n        break;\n      case \"addPath\":\n        lastInstruction.data[0].getLastPoint(out);\n        break;\n    }\n    return out;\n  }\n}\nfunction adjustTransform(currentMatrix, transform) {\n  if (currentMatrix) {\n    return currentMatrix.prepend(transform);\n  }\n  return transform.clone();\n}\nexport { GraphicsPath };","map":{"version":3,"names":["GraphicsPath","constructor","instructions","uid","_dirty","SVGToGraphicsPath","slice","shapePath","_shapePath","ShapePath","buildPath","addPath","path","transform","clone","push","action","data","arc","args","arcTo","arcToSvg","bezierCurveTo","bezierCurveToShort","cp2x","cp2y","x","y","smoothness","last","length","lastPoint","getLastPoint","Point","shared","cp1x","cp1y","currentX","currentY","closePath","ellipse","lineTo","moveTo","quadraticCurveTo","quadraticCurveToShort","cpx1","cpy1","rect","w","h","circle","radius","roundRect","poly","regularPoly","roundPoly","roundShape","filletRect","chamferRect","star","points","innerRadius","rotation","startAngle","Math","PI","len","delta","polygon","i","r","angle","cos","sin","deep","newGraphicsPath2D","instruction","clear","matrix","isIdentity","a","b","c","d","tx","ty","cpx2","cpy2","rx","ry","adjustTransform","warn","bounds","out","index","lastInstruction","currentMatrix","prepend"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/graphics/shared/path/GraphicsPath.ts"],"sourcesContent":["import { Point } from '../../../../maths/point/Point';\nimport { uid } from '../../../../utils/data/uid';\nimport { warn } from '../../../../utils/logging/warn';\nimport { SVGToGraphicsPath } from '../svg/SVGToGraphicsPath';\nimport { ShapePath } from './ShapePath';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { Bounds } from '../../../container/bounds/Bounds';\nimport type { RoundedPoint } from './roundShape';\n\nexport interface PathInstruction\n{\n    action: 'moveTo' | 'lineTo' | 'quadraticCurveTo' |\n    'bezierCurveTo' | 'arc' | 'closePath' |\n    'addPath' | 'arcTo' | 'ellipse' |\n    'rect' | 'roundRect' | 'arcToSvg' |\n    'poly' | 'circle' |\n    'regularPoly' | 'roundPoly' | 'roundShape' | 'filletRect' | 'chamferRect'\n    data: any[];\n}\n\n/**\n * The `GraphicsPath` class is designed to represent a graphical path consisting of multiple drawing instructions.\n * This class serves as a collection of drawing commands that can be executed to render shapes and paths on a canvas or\n * similar graphical context. It supports high-level drawing operations like lines, arcs, curves, and more, enabling\n * complex graphic constructions with relative ease.\n */\nexport class GraphicsPath\n{\n    public instructions: PathInstruction[] = [];\n\n    public uid = uid('graphicsPath');\n\n    private _dirty = true;\n    // needed for hit testing and bounds calculations\n    private _shapePath: ShapePath;\n\n    /**\n     * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n     * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n     */\n    get shapePath(): ShapePath\n    {\n        if (!this._shapePath)\n        {\n            this._shapePath = new ShapePath(this);\n        }\n\n        if (this._dirty)\n        {\n            this._dirty = false;\n            this._shapePath.buildPath();\n        }\n\n        return this._shapePath;\n    }\n\n    /**\n     * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n     * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n     */\n    constructor(instructions?: string | PathInstruction[])\n    {\n        if (typeof instructions === 'string')\n        {\n            SVGToGraphicsPath(instructions, this);\n        }\n        else\n        {\n            this.instructions = instructions?.slice() ?? [];\n        }\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @param transform - An optional transformation to apply to the added path.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        path = path.clone();\n        this.instructions.push({ action: 'addPath', data: [path, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: [number, number, number, number, number, boolean]): this\n    {\n        this.instructions.push({ action: 'arc', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    // eslint-disable-next-line max-len\n    public arcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n    public arcToSvg(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcToSvg', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'bezierCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires two points: the second control point and the end point. The first control point is assumed to be\n     * The starting point is the last point in the current path.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveToShort(cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cp1x = 0;\n        let cp1y = 0;\n\n        if (!last || last.action !== 'bezierCurveTo')\n        {\n            cp1x = lastPoint.x;\n            cp1y = lastPoint.y;\n        }\n        else\n        {\n            cp1x = last.data[2];\n            cp1y = last.data[3];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cp1x = currentX + (currentX - cp1x);\n            cp1y = currentY + (currentY - cp1y);\n        }\n\n        this.instructions.push({ action: 'bezierCurveTo', data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.instructions.push({ action: 'closePath', data: [] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, matrix?: Matrix): this;\n    public ellipse(...args: [number, number, number, number, Matrix]): this\n    {\n        this.instructions.push({ action: 'ellipse', data: args });\n\n        // TODO nail this!\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'lineTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'moveTo', data: args });\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'quadraticCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It uses the previous point as the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveToShort(x: number, y: number, smoothness?: number): this\n    {\n        // check if we have a previous quadraticCurveTo\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n\n        if (!last || last.action !== 'quadraticCurveTo')\n        {\n            cpx1 = lastPoint.x;\n            cpy1 = lastPoint.y;\n        }\n        else\n        {\n            cpx1 = last.data[0];\n            cpy1 = last.data[1];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cpx1 = currentX + (currentX - cpx1);\n            cpy1 = currentY + (currentY - cpy1);\n        }\n\n        this.instructions.push({ action: 'quadraticCurveTo', data: [cpx1, cpy1, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'rect', data: [x, y, w, h, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'circle', data: [x, y, radius, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this;\n    public roundRect(...args: [number, number, number, number, number, Matrix?]): this\n    {\n        this.instructions.push({ action: 'roundRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this;\n    public poly(...args: [number[] | PointData[], boolean, Matrix?]): this\n    {\n        this.instructions.push({ action: 'poly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'regularPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: [number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'roundPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: [RoundedPoint[], number, boolean, number]): this\n    {\n        this.instructions.push({ action: 'roundShape', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'filletRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'chamferRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @param transform - An optional `Matrix` object to apply a transformation to the star.\n     * This can include rotations, scaling, and translations.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    // eslint-disable-next-line max-len\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number, transform?: Matrix): this\n    {\n        innerRadius = innerRadius || radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = (Math.PI * 2) / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n     * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n     * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n     * do not affect the original `GraphicsPath` and vice versa.\n     * @param deep - A boolean flag indicating whether the clone should be deep.\n     * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n     */\n    public clone(deep = false): GraphicsPath\n    {\n        const newGraphicsPath2D = new GraphicsPath();\n\n        if (!deep)\n        {\n            newGraphicsPath2D.instructions = this.instructions.slice();\n        }\n        else\n        {\n            for (let i = 0; i < this.instructions.length; i++)\n            {\n                const instruction = this.instructions[i];\n\n                newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n            }\n        }\n\n        return newGraphicsPath2D;\n    }\n\n    public clear(): this\n    {\n        this.instructions.length = 0;\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n     * This method enables the modification of the path's geometry according to the provided\n     * transformation matrix, which can include translations, rotations, scaling, and skewing.\n     *\n     * Each drawing instruction in the path is updated to reflect the transformation,\n     * ensuring the visual representation of the path is consistent with the applied matrix.\n     *\n     * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n     * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n     * allowing for fine-grained control over the path's appearance.\n     * @param matrix - A `Matrix` object representing the transformation to apply.\n     * @returns The instance of the current object for chaining further operations.\n     */\n    public transform(matrix: Matrix): this\n    {\n        if (matrix.isIdentity()) return this;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let x = 0;\n        let y = 0;\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n        let cpx2 = 0;\n        let cpy2 = 0;\n\n        let rx = 0;\n        let ry = 0;\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const data = instruction.data as any[];\n\n            switch (instruction.action)\n            {\n                case 'moveTo':\n                case 'lineTo':\n\n                    x = data[0];\n                    y = data[1];\n\n                    data[0] = (a * x) + (c * y) + tx;\n                    data[1] = (b * x) + (d * y) + ty;\n                    break;\n                case 'bezierCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    cpx2 = data[2];\n                    cpy2 = data[3];\n\n                    x = data[4];\n                    y = data[5];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n                    data[2] = (a * cpx2) + (c * cpy2) + tx;\n                    data[3] = (b * cpx2) + (d * cpy2) + ty;\n                    data[4] = (a * x) + (c * y) + tx;\n                    data[5] = (b * x) + (d * y) + ty;\n                    break;\n\n                case 'quadraticCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n\n                    x = data[2];\n                    y = data[3];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n\n                    data[2] = (a * x) + (c * y) + tx;\n                    data[3] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'arcToSvg':\n\n                    x = data[5];\n                    y = data[6];\n\n                    rx = data[0];\n                    ry = data[1];\n\n                    // multiply the radius by the transform..\n\n                    data[0] = (a * rx) + (c * ry);\n                    data[1] = (b * rx) + (d * ry);\n\n                    data[5] = (a * x) + (c * y) + tx;\n                    data[6] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'circle':\n                    data[4] = adjustTransform(data[3], matrix);\n                    break;\n                case 'rect':\n                    data[4] = adjustTransform(data[4], matrix);\n                    break;\n                case 'ellipse':\n                    data[8] = adjustTransform(data[8], matrix);\n                    break;\n                case 'roundRect':\n                    data[5] = adjustTransform(data[5], matrix);\n                    break;\n                case 'addPath':\n                    data[0].transform(matrix);\n                    break;\n                case 'poly':\n                    data[2] = adjustTransform(data[2], matrix);\n                    break;\n                default:\n                    // #if _DEBUG\n                    warn('unknown transform action', instruction.action);\n                    // #endif\n                    break;\n            }\n        }\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    get bounds(): Bounds\n    {\n        return this.shapePath.bounds;\n    }\n\n    /**\n     * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n     * This method is useful for operations that depend on the path's current endpoint,\n     * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n     * ensuring the last point's position is accurately determined regardless of the path's complexity.\n     *\n     * If the last instruction is a `closePath`, the method iterates backward through the instructions\n     *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n     * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n     * the last point from the nested path.\n     * @param out - A `Point` object where the last point's coordinates will be stored.\n     * This object is modified directly to contain the result.\n     * @returns The `Point` object containing the last point's coordinates.\n     */\n    public getLastPoint(out: Point): Point\n    {\n        let index = this.instructions.length - 1;\n\n        let lastInstruction = this.instructions[index];\n\n        if (!lastInstruction)\n        {\n            out.x = 0;\n            out.y = 0;\n\n            return out;\n        }\n\n        while (lastInstruction.action === 'closePath')\n        {\n            index--;\n\n            if (index < 0)\n            {\n                out.x = 0;\n                out.y = 0;\n\n                return out;\n            }\n\n            lastInstruction = this.instructions[index];\n        }\n\n        switch (lastInstruction.action)\n        {\n            case 'moveTo':\n            case 'lineTo':\n                out.x = lastInstruction.data[0];\n                out.y = lastInstruction.data[1];\n                break;\n            case 'quadraticCurveTo':\n                out.x = lastInstruction.data[2];\n                out.y = lastInstruction.data[3];\n                break;\n            case 'bezierCurveTo':\n                out.x = lastInstruction.data[4];\n                out.y = lastInstruction.data[5];\n                break;\n            case 'arc':\n            case 'arcToSvg':\n                out.x = lastInstruction.data[5];\n                out.y = lastInstruction.data[6];\n                break;\n            case 'addPath':\n                // TODO prolly should transform the last point of the path\n                lastInstruction.data[0].getLastPoint(out);\n                break;\n        }\n\n        return out;\n    }\n}\n\nfunction adjustTransform(currentMatrix?: Matrix, transform?: Matrix): Matrix\n{\n    if (currentMatrix)\n    {\n        return currentMatrix.prepend(transform);\n    }\n\n    return transform.clone();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}