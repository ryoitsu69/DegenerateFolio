{"ast":null,"code":"import { BN, BN_BILLION, BN_HUNDRED, BN_MILLION, BN_QUINTILL, bnToBn, bnToHex, bnToU8a, formatBalance, formatNumber, hexToBn, isBigInt, isBn, isFunction, isHex, isNumber, isObject, isString, isU8a, u8aToBn, u8aToNumber } from '@polkadot/util';\nexport const DEFAULT_UINT_BITS = 64;\nconst MAX_NUMBER_BITS = 52;\nconst MUL_P = new BN(10000);\nconst FORMATTERS = [['Perquintill', BN_QUINTILL], ['Perbill', BN_BILLION], ['Permill', BN_MILLION], ['Percent', BN_HUNDRED]];\nfunction isToBn(value) {\n  return isFunction(value.toBn);\n}\nfunction toPercentage(value, divisor) {\n  return `${(value.mul(MUL_P).div(divisor).toNumber() / 100).toFixed(2)}%`;\n}\n/** @internal */\nfunction decodeAbstractInt(value, isNegative) {\n  if (isNumber(value)) {\n    if (!Number.isInteger(value) || value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER) {\n      throw new Error('Number needs to be an integer <= Number.MAX_SAFE_INTEGER, i.e. 2 ^ 53 - 1');\n    }\n    return value;\n  } else if (isString(value)) {\n    if (isHex(value, -1, true)) {\n      return hexToBn(value, {\n        isLe: false,\n        isNegative\n      }).toString();\n    }\n    if (value.includes('.') || value.includes(',') || value.includes('e')) {\n      throw new Error('String should not contain decimal points or scientific notation');\n    }\n    return value;\n  } else if (isBn(value) || isBigInt(value)) {\n    return value.toString();\n  } else if (isObject(value)) {\n    if (isToBn(value)) {\n      return value.toBn().toString();\n    }\n    // Allow the construction from an object with a single top-level key. This means that\n    // single key objects can be treated equivalently to numbers, assuming they meet the\n    // specific requirements. (This is useful in Weights 1.5 where Objects are compact)\n    const keys = Object.keys(value);\n    if (keys.length !== 1) {\n      throw new Error('Unable to construct number from multi-key object');\n    }\n    return decodeAbstractInt(value[keys[0]], isNegative);\n  } else if (!value) {\n    return 0;\n  }\n  throw new Error(`Unable to create BN from unknown type ${typeof value}`);\n}\n/**\n * @name AbstractInt\n * @ignore\n * @noInheritDoc\n */\nexport class AbstractInt extends BN {\n  registry;\n  encodedLength;\n  isUnsigned;\n  createdAtHash;\n  initialU8aLength;\n  isStorageFallback;\n  __internal__bitLength;\n  constructor(registry, value = 0, bitLength = DEFAULT_UINT_BITS, isSigned = false) {\n    // Construct via a string/number, which will be passed in the BN constructor.\n    // It would be ideal to actually return a BN, but there is an issue:\n    // https://github.com/indutny/bn.js/issues/206\n    super(\n    // shortcut isU8a as used in SCALE decoding\n    isU8a(value) ? bitLength <= 48 ? u8aToNumber(value.subarray(0, bitLength / 8), {\n      isNegative: isSigned\n    }) : u8aToBn(value.subarray(0, bitLength / 8), {\n      isLe: true,\n      isNegative: isSigned\n    }).toString() : decodeAbstractInt(value, isSigned));\n    this.registry = registry;\n    this.__internal__bitLength = bitLength;\n    this.encodedLength = this.__internal__bitLength / 8;\n    this.initialU8aLength = this.__internal__bitLength / 8;\n    this.isUnsigned = !isSigned;\n    const isNegative = this.isNeg();\n    const maxBits = bitLength - (isSigned && !isNegative ? 1 : 0);\n    if (isNegative && !isSigned) {\n      throw new Error(`${this.toRawType()}: Negative number passed to unsigned type`);\n    } else if (super.bitLength() > maxBits) {\n      throw new Error(`${this.toRawType()}: Input too large. Found input with ${super.bitLength()} bits, expected ${maxBits}`);\n    }\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is a zero value (align elsewhere)\n   */\n  get isEmpty() {\n    return this.isZero();\n  }\n  /**\n   * @description Returns the number of bits in the value\n   */\n  bitLength() {\n    return this.__internal__bitLength;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  eq(other) {\n    // Here we are actually overriding the built-in .eq to take care of both\n    // number and BN inputs (no `.eqn` needed) - numbers will be converted\n    return super.eq(isHex(other) ? hexToBn(other.toString(), {\n      isLe: false,\n      isNegative: !this.isUnsigned\n    }) : bnToBn(other));\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return {\n      outer: [this.toU8a()]\n    };\n  }\n  /**\n   * @description True if this value is the max of the type\n   */\n  isMax() {\n    const u8a = this.toU8a().filter(b => b === 0xff);\n    return u8a.length === this.__internal__bitLength / 8;\n  }\n  /**\n   * @description Returns a BigInt representation of the number\n   */\n  toBigInt() {\n    return BigInt(this.toString());\n  }\n  /**\n   * @description Returns the BN representation of the number. (Compatibility)\n   */\n  toBn() {\n    return this;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex(isLe = false) {\n    // For display/JSON, this is BE, for compare, use isLe\n    return bnToHex(this, {\n      bitLength: this.bitLength(),\n      isLe,\n      isNegative: !this.isUnsigned\n    });\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(_isExpanded) {\n    const rawType = this.toRawType();\n    if (rawType === 'Balance') {\n      return this.isMax() ? 'everything'\n      // FIXME In the case of multiples we need some way of detecting which instance this belongs\n      // to. as it stands we will always format (incorrectly) against the first token defined\n      : formatBalance(this, {\n        decimals: this.registry.chainDecimals[0],\n        withSi: true,\n        withUnit: this.registry.chainTokens[0]\n      });\n    }\n    const [, divisor] = FORMATTERS.find(([type]) => type === rawType) || [];\n    return divisor ? toPercentage(this, divisor) : formatNumber(this);\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON(onlyHex = false) {\n    // FIXME this return type should by string | number, however BN returns string\n    // Options here are\n    //   - super.bitLength() - the actual used bits, use hex when close to MAX_SAFE_INTEGER\n    //   - this.__internal__bitLength - the max used bits, use hex when larger than native Rust type\n    return onlyHex || this.__internal__bitLength > 128 || super.bitLength() > MAX_NUMBER_BITS ? this.toHex() : this.toNumber();\n  }\n  /**\n   * @description Returns the value in a primitive form, either number when <= 52 bits, or string otherwise\n   */\n  toPrimitive() {\n    return super.bitLength() > MAX_NUMBER_BITS ? this.toString() : this.toNumber();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    // NOTE In the case of balances, which have a special meaning on the UI\n    // and can be interpreted differently, return a specific value for it so\n    // underlying it always matches (no matter which length it actually is)\n    return this instanceof this.registry.createClassUnsafe('Balance') ? 'Balance' : `${this.isUnsigned ? 'u' : 'i'}${this.bitLength()}`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   * @param base The base to use for the conversion\n   */\n  toString(base) {\n    // only included here since we do not inherit docs\n    return super.toString(base);\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   */\n  toU8a(_isBare) {\n    return bnToU8a(this, {\n      bitLength: this.bitLength(),\n      isLe: true,\n      isNegative: !this.isUnsigned\n    });\n  }\n}","map":{"version":3,"names":["BN","BN_BILLION","BN_HUNDRED","BN_MILLION","BN_QUINTILL","bnToBn","bnToHex","bnToU8a","formatBalance","formatNumber","hexToBn","isBigInt","isBn","isFunction","isHex","isNumber","isObject","isString","isU8a","u8aToBn","u8aToNumber","DEFAULT_UINT_BITS","MAX_NUMBER_BITS","MUL_P","FORMATTERS","isToBn","value","toBn","toPercentage","divisor","mul","div","toNumber","toFixed","decodeAbstractInt","isNegative","Number","isInteger","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","Error","isLe","toString","includes","keys","Object","length","AbstractInt","registry","encodedLength","isUnsigned","createdAtHash","initialU8aLength","isStorageFallback","__internal__bitLength","constructor","bitLength","isSigned","subarray","isNeg","maxBits","toRawType","hash","toU8a","isEmpty","isZero","eq","other","inspect","outer","isMax","u8a","filter","b","toBigInt","BigInt","toHex","toHuman","_isExpanded","rawType","decimals","chainDecimals","withSi","withUnit","chainTokens","find","type","toJSON","onlyHex","toPrimitive","createClassUnsafe","base","_isBare"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/abstract/Int.js"],"sourcesContent":["import { BN, BN_BILLION, BN_HUNDRED, BN_MILLION, BN_QUINTILL, bnToBn, bnToHex, bnToU8a, formatBalance, formatNumber, hexToBn, isBigInt, isBn, isFunction, isHex, isNumber, isObject, isString, isU8a, u8aToBn, u8aToNumber } from '@polkadot/util';\nexport const DEFAULT_UINT_BITS = 64;\nconst MAX_NUMBER_BITS = 52;\nconst MUL_P = new BN(10000);\nconst FORMATTERS = [\n    ['Perquintill', BN_QUINTILL],\n    ['Perbill', BN_BILLION],\n    ['Permill', BN_MILLION],\n    ['Percent', BN_HUNDRED]\n];\nfunction isToBn(value) {\n    return isFunction(value.toBn);\n}\nfunction toPercentage(value, divisor) {\n    return `${(value.mul(MUL_P).div(divisor).toNumber() / 100).toFixed(2)}%`;\n}\n/** @internal */\nfunction decodeAbstractInt(value, isNegative) {\n    if (isNumber(value)) {\n        if (!Number.isInteger(value) || value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER) {\n            throw new Error('Number needs to be an integer <= Number.MAX_SAFE_INTEGER, i.e. 2 ^ 53 - 1');\n        }\n        return value;\n    }\n    else if (isString(value)) {\n        if (isHex(value, -1, true)) {\n            return hexToBn(value, { isLe: false, isNegative }).toString();\n        }\n        if (value.includes('.') || value.includes(',') || value.includes('e')) {\n            throw new Error('String should not contain decimal points or scientific notation');\n        }\n        return value;\n    }\n    else if (isBn(value) || isBigInt(value)) {\n        return value.toString();\n    }\n    else if (isObject(value)) {\n        if (isToBn(value)) {\n            return value.toBn().toString();\n        }\n        // Allow the construction from an object with a single top-level key. This means that\n        // single key objects can be treated equivalently to numbers, assuming they meet the\n        // specific requirements. (This is useful in Weights 1.5 where Objects are compact)\n        const keys = Object.keys(value);\n        if (keys.length !== 1) {\n            throw new Error('Unable to construct number from multi-key object');\n        }\n        return decodeAbstractInt(value[keys[0]], isNegative);\n    }\n    else if (!value) {\n        return 0;\n    }\n    throw new Error(`Unable to create BN from unknown type ${typeof value}`);\n}\n/**\n * @name AbstractInt\n * @ignore\n * @noInheritDoc\n */\nexport class AbstractInt extends BN {\n    registry;\n    encodedLength;\n    isUnsigned;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    __internal__bitLength;\n    constructor(registry, value = 0, bitLength = DEFAULT_UINT_BITS, isSigned = false) {\n        // Construct via a string/number, which will be passed in the BN constructor.\n        // It would be ideal to actually return a BN, but there is an issue:\n        // https://github.com/indutny/bn.js/issues/206\n        super(\n        // shortcut isU8a as used in SCALE decoding\n        isU8a(value)\n            ? bitLength <= 48\n                ? u8aToNumber(value.subarray(0, bitLength / 8), { isNegative: isSigned })\n                : u8aToBn(value.subarray(0, bitLength / 8), { isLe: true, isNegative: isSigned }).toString()\n            : decodeAbstractInt(value, isSigned));\n        this.registry = registry;\n        this.__internal__bitLength = bitLength;\n        this.encodedLength = this.__internal__bitLength / 8;\n        this.initialU8aLength = this.__internal__bitLength / 8;\n        this.isUnsigned = !isSigned;\n        const isNegative = this.isNeg();\n        const maxBits = bitLength - (isSigned && !isNegative ? 1 : 0);\n        if (isNegative && !isSigned) {\n            throw new Error(`${this.toRawType()}: Negative number passed to unsigned type`);\n        }\n        else if (super.bitLength() > maxBits) {\n            throw new Error(`${this.toRawType()}: Input too large. Found input with ${super.bitLength()} bits, expected ${maxBits}`);\n        }\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is a zero value (align elsewhere)\n     */\n    get isEmpty() {\n        return this.isZero();\n    }\n    /**\n     * @description Returns the number of bits in the value\n     */\n    bitLength() {\n        return this.__internal__bitLength;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    eq(other) {\n        // Here we are actually overriding the built-in .eq to take care of both\n        // number and BN inputs (no `.eqn` needed) - numbers will be converted\n        return super.eq(isHex(other)\n            ? hexToBn(other.toString(), { isLe: false, isNegative: !this.isUnsigned })\n            : bnToBn(other));\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            outer: [this.toU8a()]\n        };\n    }\n    /**\n     * @description True if this value is the max of the type\n     */\n    isMax() {\n        const u8a = this.toU8a().filter((b) => b === 0xff);\n        return u8a.length === (this.__internal__bitLength / 8);\n    }\n    /**\n     * @description Returns a BigInt representation of the number\n     */\n    toBigInt() {\n        return BigInt(this.toString());\n    }\n    /**\n     * @description Returns the BN representation of the number. (Compatibility)\n     */\n    toBn() {\n        return this;\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex(isLe = false) {\n        // For display/JSON, this is BE, for compare, use isLe\n        return bnToHex(this, {\n            bitLength: this.bitLength(),\n            isLe,\n            isNegative: !this.isUnsigned\n        });\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(_isExpanded) {\n        const rawType = this.toRawType();\n        if (rawType === 'Balance') {\n            return this.isMax()\n                ? 'everything'\n                // FIXME In the case of multiples we need some way of detecting which instance this belongs\n                // to. as it stands we will always format (incorrectly) against the first token defined\n                : formatBalance(this, { decimals: this.registry.chainDecimals[0], withSi: true, withUnit: this.registry.chainTokens[0] });\n        }\n        const [, divisor] = FORMATTERS.find(([type]) => type === rawType) || [];\n        return divisor\n            ? toPercentage(this, divisor)\n            : formatNumber(this);\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON(onlyHex = false) {\n        // FIXME this return type should by string | number, however BN returns string\n        // Options here are\n        //   - super.bitLength() - the actual used bits, use hex when close to MAX_SAFE_INTEGER\n        //   - this.__internal__bitLength - the max used bits, use hex when larger than native Rust type\n        return onlyHex || (this.__internal__bitLength > 128) || (super.bitLength() > MAX_NUMBER_BITS)\n            ? this.toHex()\n            : this.toNumber();\n    }\n    /**\n     * @description Returns the value in a primitive form, either number when <= 52 bits, or string otherwise\n     */\n    toPrimitive() {\n        return super.bitLength() > MAX_NUMBER_BITS\n            ? this.toString()\n            : this.toNumber();\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        // NOTE In the case of balances, which have a special meaning on the UI\n        // and can be interpreted differently, return a specific value for it so\n        // underlying it always matches (no matter which length it actually is)\n        return this instanceof this.registry.createClassUnsafe('Balance')\n            ? 'Balance'\n            : `${this.isUnsigned ? 'u' : 'i'}${this.bitLength()}`;\n    }\n    /**\n     * @description Returns the string representation of the value\n     * @param base The base to use for the conversion\n     */\n    toString(base) {\n        // only included here since we do not inherit docs\n        return super.toString(base);\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     */\n    toU8a(_isBare) {\n        return bnToU8a(this, {\n            bitLength: this.bitLength(),\n            isLe: true,\n            isNegative: !this.isUnsigned\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}