{"ast":null,"code":"import { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { Bounds } from '../container/bounds/Bounds.mjs';\nimport { Container } from '../container/Container.mjs';\n\"use strict\";\nclass AbstractText extends Container {\n  constructor(options, styleClass) {\n    const {\n      text,\n      resolution,\n      style,\n      anchor,\n      width,\n      height,\n      roundPixels,\n      ...rest\n    } = options;\n    super({\n      ...rest\n    });\n    this.batched = true;\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     * @default 1\n     */\n    this.resolution = null;\n    this._didTextUpdate = true;\n    this._roundPixels = 0;\n    this._bounds = new Bounds();\n    this._boundsDirty = true;\n    this._styleClass = styleClass;\n    this.text = text ?? \"\";\n    this.style = style;\n    this.resolution = resolution ?? null;\n    this.allowChildren = false;\n    this._anchor = new ObservablePoint({\n      _onUpdate: () => {\n        this.onViewUpdate();\n      }\n    });\n    if (anchor) this.anchor = anchor;\n    this.roundPixels = roundPixels ?? false;\n    if (width) this.width = width;\n    if (height) this.height = height;\n  }\n  /**\n   * The anchor sets the origin point of the text.\n   * The default is `(0,0)`, this means the text's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Text } from 'pixi.js';\n   *\n   * const text = new Text('hello world');\n   * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /**\n   *  Whether or not to round the x/y position of the text.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  /** Set the copy for the text object. To split a line you can use '\\n'. */\n  set text(value) {\n    value = value.toString();\n    if (this._text === value) return;\n    this._text = value;\n    this.onViewUpdate();\n  }\n  get text() {\n    return this._text;\n  }\n  get style() {\n    return this._style;\n  }\n  /**\n   * Set the style of the text.\n   *\n   * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n   *\n   * If setting the `style` can also be partial {@link AnyTextStyleOptions}.\n   * @type {\n   * text.TextStyle |\n   * Partial<text.TextStyle> |\n   * text.TextStyleOptions |\n   * text.HTMLTextStyle |\n   * Partial<text.HTMLTextStyle> |\n   * text.HTMLTextStyleOptions\n   * }\n   */\n  set style(style) {\n    style = style || {};\n    this._style?.off(\"update\", this.onViewUpdate, this);\n    if (style instanceof this._styleClass) {\n      this._style = style;\n    } else {\n      this._style = new this._styleClass(style);\n    }\n    this._style.on(\"update\", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  /**\n   * The local bounds of the Text.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    if (this._boundsDirty) {\n      this._updateBounds();\n      this._boundsDirty = false;\n    }\n    return this._bounds;\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this.bounds.width;\n  }\n  set width(value) {\n    this._setWidth(value, this.bounds.width);\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this.bounds.height;\n  }\n  set height(value) {\n    this._setHeight(value, this.bounds.height);\n  }\n  /**\n   * Retrieves the size of the Text as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Text.\n   */\n  getSize(out) {\n    if (!out) {\n      out = {};\n    }\n    out.width = Math.abs(this.scale.x) * this.bounds.width;\n    out.height = Math.abs(this.scale.y) * this.bounds.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Text to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    let convertedWidth;\n    let convertedHeight;\n    if (typeof value !== \"object\") {\n      convertedWidth = value;\n      convertedHeight = height ?? value;\n    } else {\n      convertedWidth = value.width;\n      convertedHeight = value.height ?? value.width;\n    }\n    if (convertedWidth !== void 0) {\n      this._setWidth(convertedWidth, this.bounds.width);\n    }\n    if (convertedHeight !== void 0) {\n      this._setHeight(convertedHeight, this.bounds.height);\n    }\n  }\n  /**\n   * Adds the bounds of this text to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    const _bounds = this.bounds;\n    bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n  }\n  /**\n   * Checks if the text contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const width = this.bounds.maxX;\n    const height = this.bounds.maxY;\n    const x1 = -width * this.anchor.x;\n    let y1 = 0;\n    if (point.x >= x1 && point.x <= x1 + width) {\n      y1 = -height * this.anchor.y;\n      if (point.y >= y1 && point.y <= y1 + height) return true;\n    }\n    return false;\n  }\n  onViewUpdate() {\n    this._didChangeId += 1 << 12;\n    this._boundsDirty = true;\n    if (this.didViewUpdate) return;\n    this.didViewUpdate = true;\n    this._didTextUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n  }\n  _getKey() {\n    return `${this.text}:${this._style.styleKey}`;\n  }\n  /**\n   * Destroys this text renderable and optionally its style texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style\n   * @param {boolean} [options.style=false] - Should it destroy the style of the text\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    this.owner = null;\n    this._bounds = null;\n    this._anchor = null;\n    if (typeof options === \"boolean\" ? options : options?.style) {\n      this._style.destroy(options);\n    }\n    this._style = null;\n    this._text = null;\n  }\n}\nfunction ensureOptions(args, name) {\n  let options = args[0] ?? {};\n  if (typeof options === \"string\" || args[1]) {\n    deprecation(v8_0_0, `use new ${name}({ text: \"hi!\", style }) instead`);\n    options = {\n      text: options,\n      style: args[1]\n    };\n  }\n  return options;\n}\nexport { AbstractText, ensureOptions };","map":{"version":3,"names":["AbstractText","Container","constructor","options","styleClass","text","resolution","style","anchor","width","height","roundPixels","rest","batched","_didTextUpdate","_roundPixels","_bounds","Bounds","_boundsDirty","_styleClass","allowChildren","_anchor","ObservablePoint","_onUpdate","onViewUpdate","value","set","copyFrom","toString","_text","_style","off","on","bounds","_updateBounds","Math","abs","scale","x","_setWidth","y","_setHeight","getSize","out","setSize","convertedWidth","convertedHeight","addBounds","addFrame","minX","minY","maxX","maxY","containsPoint","point","x1","y1","_didChangeId","didViewUpdate","renderGroup","parentRenderGroup","onChildViewUpdate","_getKey","styleKey","destroy","owner","ensureOptions","args","name","deprecation","v8_0_0"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/text/AbstractText.ts"],"sourcesContent":["import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { Bounds } from '../container/bounds/Bounds';\nimport { Container } from '../container/Container';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { ContainerOptions } from '../container/Container';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../text-html/HtmlTextStyle';\nimport type { TextStyle, TextStyleOptions } from './TextStyle';\n\n/**\n * A string or number that can be used as text.\n * @memberof text\n */\nexport type TextString = string | number | { toString: () => string };\n/**\n * A union of all text styles, including HTML, Bitmap and Canvas text styles.\n * @memberof text\n * @see text.TextStyle\n * @see text.HTMLTextStyle\n */\nexport type AnyTextStyle = TextStyle | HTMLTextStyle;\n/**\n * A union of all text style options, including HTML, Bitmap and Canvas text style options.\n * @memberof text\n * @see text.TextStyleOptions\n * @see text.HTMLTextStyleOptions\n */\nexport type AnyTextStyleOptions = TextStyleOptions | HTMLTextStyleOptions;\n\n/**\n * Options for the {@link scene.Text} class.\n * @example\n * const text = new Text({\n *    text: 'Hello Pixi!',\n *    style: {\n *       fontFamily: 'Arial',\n *       fontSize: 24,\n *    fill: 0xff1010,\n *    align: 'center',\n *  }\n * });\n * @memberof text\n */\nexport interface TextOptions<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n> extends ContainerOptions\n{\n    /** The anchor point of the text. */\n    anchor?: PointData | number;\n    /** The copy for the text object. To split a line you can use '\\n'. */\n    text?: TextString;\n    /** The resolution of the text. */\n    resolution?: number;\n    /**\n     * The text style\n     * @type {\n     * text.TextStyle |\n     * Partial<text.TextStyle> |\n     * text.TextStyleOptions |\n     * text.HTMLTextStyle |\n     * Partial<text.HTMLTextStyle> |\n     * text.HTMLTextStyleOptions\n     * }\n     */\n    style?: TEXT_STYLE | TEXT_STYLE_OPTIONS;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * An abstract Text class, used by all text type in Pixi. This includes Canvas, HTML, and Bitmap Text.\n * @see scene.Text\n * @see scene.BitmapText\n * @see scene.HTMLText\n * @memberof scene\n */\nexport abstract class AbstractText<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n> extends Container implements View\n{\n    public abstract readonly renderPipeId: string;\n    public batched = true;\n    public _anchor: ObservablePoint;\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     * @default 1\n     */\n    public resolution: number = null;\n\n    public _style: TEXT_STYLE;\n    public _didTextUpdate = true;\n    public _roundPixels: 0 | 1 = 0;\n\n    protected _bounds: Bounds = new Bounds();\n    protected _boundsDirty = true;\n    protected _text: string;\n    private readonly _styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE;\n\n    constructor(\n        options: TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>,\n        styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE\n    )\n    {\n        const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;\n\n        super({\n            ...rest\n        });\n\n        this._styleClass = styleClass;\n\n        this.text = text ?? '';\n\n        this.style = style;\n\n        this.resolution = resolution ?? null;\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                },\n            },\n        );\n\n        if (anchor) this.anchor = anchor;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width) this.width = width;\n        if (height) this.height = height;\n    }\n\n    /**\n     * The anchor sets the origin point of the text.\n     * The default is `(0,0)`, this means the text's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { Text } from 'pixi.js';\n     *\n     * const text = new Text('hello world');\n     * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the text.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    /** Set the copy for the text object. To split a line you can use '\\n'. */\n    set text(value: TextString)\n    {\n        // check its a string\n        value = value.toString();\n\n        if (this._text === value) return;\n\n        this._text = value as string;\n        this.onViewUpdate();\n    }\n\n    get text(): string\n    {\n        return this._text;\n    }\n\n    get style(): TEXT_STYLE\n    {\n        return this._style;\n    }\n\n    /**\n     * Set the style of the text.\n     *\n     * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n     *\n     * If setting the `style` can also be partial {@link AnyTextStyleOptions}.\n     * @type {\n     * text.TextStyle |\n     * Partial<text.TextStyle> |\n     * text.TextStyleOptions |\n     * text.HTMLTextStyle |\n     * Partial<text.HTMLTextStyle> |\n     * text.HTMLTextStyleOptions\n     * }\n     */\n    set style(style: TEXT_STYLE | Partial<TEXT_STYLE> | TEXT_STYLE_OPTIONS)\n    {\n        style = style || {};\n\n        this._style?.off('update', this.onViewUpdate, this);\n\n        if (style instanceof this._styleClass)\n        {\n            this._style = style as TEXT_STYLE;\n        }\n        else\n        {\n            this._style = new this._styleClass(style as TEXT_STYLE_OPTIONS);\n        }\n\n        this._style.on('update', this.onViewUpdate, this);\n        this.onViewUpdate();\n    }\n\n    /**\n     * The local bounds of the Text.\n     * @type {rendering.Bounds}\n     */\n    get bounds()\n    {\n        if (this._boundsDirty)\n        {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n\n        return this._bounds;\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this.bounds.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this.bounds.width);\n    }\n\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this.bounds.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this.bounds.height);\n    }\n\n    /**\n     * Retrieves the size of the Text as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the Text.\n     */\n    public override getSize(out?: Size): Size\n    {\n        if (!out)\n        {\n            out = {} as Size;\n        }\n\n        out.width = Math.abs(this.scale.x) * this.bounds.width;\n        out.height = Math.abs(this.scale.y) * this.bounds.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Text to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        let convertedWidth: number;\n        let convertedHeight: number;\n\n        if (typeof value !== 'object')\n        {\n            convertedWidth = value;\n            convertedHeight = height ?? value;\n        }\n        else\n        {\n            convertedWidth = value.width;\n            convertedHeight = value.height ?? value.width;\n        }\n\n        if (convertedWidth !== undefined)\n        {\n            this._setWidth(convertedWidth, this.bounds.width);\n        }\n\n        if (convertedHeight !== undefined)\n        {\n            this._setHeight(convertedHeight, this.bounds.height);\n        }\n    }\n\n    /**\n     * Adds the bounds of this text to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this.bounds;\n\n        bounds.addFrame(\n            _bounds.minX,\n            _bounds.minY,\n            _bounds.maxX,\n            _bounds.maxY,\n        );\n    }\n\n    /**\n     * Checks if the text contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        const width = this.bounds.maxX;\n        const height = this.bounds.maxY;\n\n        const x1 = -width * this.anchor.x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this.anchor.y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    public onViewUpdate()\n    {\n        this._didChangeId += 1 << 12;\n        this._boundsDirty = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        this._didTextUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    public _getKey(): string\n    {\n        // TODO add a dirty flag...\n        return `${this.text}:${this._style.styleKey}`;\n    }\n\n    protected abstract _updateBounds(): void;\n\n    /**\n     * Destroys this text renderable and optionally its style texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style\n     * @param {boolean} [options.style=false] - Should it destroy the style of the text\n     */\n    public destroy(options: DestroyOptions = false): void\n    {\n        super.destroy(options);\n\n        (this as any).owner = null;\n        this._bounds = null;\n        this._anchor = null;\n\n        if (typeof options === 'boolean' ? options : options?.style)\n        {\n            this._style.destroy(options);\n        }\n\n        this._style = null;\n        this._text = null;\n    }\n}\n\nexport function ensureOptions<\n    TEXT_STYLE extends TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions\n>(\n    args: any[],\n    name: string\n): TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>\n{\n    let options = (args[0] ?? {}) as TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>;\n\n    // @deprecated\n    if (typeof options === 'string' || args[1])\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, `use new ${name}({ text: \"hi!\", style }) instead`);\n        // #endif\n\n        options = {\n            text: options,\n            style: args[1],\n        } as TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>;\n    }\n\n    return options;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}