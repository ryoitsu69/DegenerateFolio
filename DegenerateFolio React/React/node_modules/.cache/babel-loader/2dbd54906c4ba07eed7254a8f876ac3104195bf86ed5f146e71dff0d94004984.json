{"ast":null,"code":"import { SAMPLER_TYPES, TYPES, MIPMAP_MODES, WRAP_MODES, SCALE_MODES } from \"@pixi/constants\";\nimport { ExtensionType, extensions } from \"@pixi/extensions\";\nimport { removeItems } from \"@pixi/utils\";\nimport { BaseTexture } from \"./BaseTexture.mjs\";\nimport { GLTexture } from \"./GLTexture.mjs\";\nimport { mapInternalFormatToSamplerType } from \"./utils/mapInternalFormatToSamplerType.mjs\";\nimport { mapTypeAndFormatToInternalFormat } from \"./utils/mapTypeAndFormatToInternalFormat.mjs\";\nclass TextureSystem {\n  /**\n   * @param renderer - The renderer this system works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new BaseTexture(), this.hasIntegerTextures = !1;\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    const gl = this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = mapTypeAndFormatToInternalFormat(gl), this.samplerTypes = mapInternalFormatToSamplerType(gl);\n    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    this.boundTextures.length = maxTextures;\n    for (let i = 0; i < maxTextures; i++) this.boundTextures[i] = null;\n    this.emptyTextures = {};\n    const emptyTexture2D = new GLTexture(gl.createTexture());\n    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D, this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture()), gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);\n    for (let i = 0; i < 6; i++) gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    for (let i = 0; i < this.boundTextures.length; i++) this.bind(null, i);\n  }\n  /**\n   * Bind a texture to a specific location\n   *\n   * If you want to unbind something, please use `unbind(texture)` instead of `bind(null, textureLocation)`\n   * @param texture - Texture to bind\n   * @param [location=0] - Location to bind at\n   */\n  bind(texture, location = 0) {\n    const {\n      gl\n    } = this;\n    if (texture = texture?.castToBaseTexture(), texture?.valid && !texture.parentTextureArray) {\n      texture.touched = this.renderer.textureGC.count;\n      const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);\n      this.boundTextures[location] !== texture && (this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), gl.bindTexture(texture.target, glTexture.texture)), glTexture.dirtyId !== texture.dirtyId ? (this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), this.updateTexture(texture)) : glTexture.dirtyStyleId !== texture.dirtyStyleId && this.updateTextureStyle(texture), this.boundTextures[location] = texture;\n    } else this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture), this.boundTextures[location] = null;\n  }\n  /** Resets texture location and bound textures Actual `bind(null, i)` calls will be performed at next `unbind()` call */\n  reset() {\n    this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;\n    for (let i = 0; i < this.boundTextures.length; i++) this.boundTextures[i] = this.unknownTexture;\n  }\n  /**\n   * Unbind a texture.\n   * @param texture - Texture to bind\n   */\n  unbind(texture) {\n    const {\n      gl,\n      boundTextures\n    } = this;\n    if (this._unknownBoundTextures) {\n      this._unknownBoundTextures = !1;\n      for (let i = 0; i < boundTextures.length; i++) boundTextures[i] === this.unknownTexture && this.bind(null, i);\n    }\n    for (let i = 0; i < boundTextures.length; i++) boundTextures[i] === texture && (this.currentLocation !== i && (gl.activeTexture(gl.TEXTURE0 + i), this.currentLocation = i), gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture), boundTextures[i] = null);\n  }\n  /**\n   * Ensures that current boundTextures all have FLOAT sampler type,\n   * see {@link PIXI.SAMPLER_TYPES} for explanation.\n   * @param maxTextures - number of locations to check\n   */\n  ensureSamplerType(maxTextures) {\n    const {\n      boundTextures,\n      hasIntegerTextures,\n      CONTEXT_UID\n    } = this;\n    if (hasIntegerTextures) for (let i = maxTextures - 1; i >= 0; --i) {\n      const tex = boundTextures[i];\n      tex && tex._glTextures[CONTEXT_UID].samplerType !== SAMPLER_TYPES.FLOAT && this.renderer.texture.unbind(tex);\n    }\n  }\n  /**\n   * Initialize a texture\n   * @private\n   * @param texture - Texture to initialize\n   */\n  initTexture(texture) {\n    const glTexture = new GLTexture(this.gl.createTexture());\n    return glTexture.dirtyId = -1, texture._glTextures[this.CONTEXT_UID] = glTexture, this.managedTextures.push(texture), texture.on(\"dispose\", this.destroyTexture, this), glTexture;\n  }\n  initTextureType(texture, glTexture) {\n    glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format, glTexture.samplerType = this.samplerTypes[glTexture.internalFormat] ?? SAMPLER_TYPES.FLOAT, this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT ? glTexture.type = this.gl.HALF_FLOAT : glTexture.type = texture.type;\n  }\n  /**\n   * Update a texture\n   * @private\n   * @param {PIXI.BaseTexture} texture - Texture to initialize\n   */\n  updateTexture(texture) {\n    const glTexture = texture._glTextures[this.CONTEXT_UID];\n    if (!glTexture) return;\n    const renderer = this.renderer;\n    if (this.initTextureType(texture, glTexture), texture.resource?.upload(renderer, texture, glTexture)) glTexture.samplerType !== SAMPLER_TYPES.FLOAT && (this.hasIntegerTextures = !0);else {\n      const width = texture.realWidth,\n        height = texture.realHeight,\n        gl = renderer.gl;\n      (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) && (glTexture.width = width, glTexture.height = height, gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null));\n    }\n    texture.dirtyStyleId !== glTexture.dirtyStyleId && this.updateTextureStyle(texture), glTexture.dirtyId = texture.dirtyId;\n  }\n  /**\n   * Deletes the texture from WebGL\n   * @private\n   * @param texture - the texture to destroy\n   * @param [skipRemove=false] - Whether to skip removing the texture from the TextureManager.\n   */\n  destroyTexture(texture, skipRemove) {\n    const {\n      gl\n    } = this;\n    if (texture = texture.castToBaseTexture(), texture._glTextures[this.CONTEXT_UID] && (this.unbind(texture), gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture), texture.off(\"dispose\", this.destroyTexture, this), delete texture._glTextures[this.CONTEXT_UID], !skipRemove)) {\n      const i = this.managedTextures.indexOf(texture);\n      i !== -1 && removeItems(this.managedTextures, i, 1);\n    }\n  }\n  /**\n   * Update texture style such as mipmap flag\n   * @private\n   * @param {PIXI.BaseTexture} texture - Texture to update\n   */\n  updateTextureStyle(texture) {\n    const glTexture = texture._glTextures[this.CONTEXT_UID];\n    glTexture && ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo ? glTexture.mipmap = !1 : glTexture.mipmap = texture.mipmap >= 1, this.webGLVersion !== 2 && !texture.isPowerOfTwo ? glTexture.wrapMode = WRAP_MODES.CLAMP : glTexture.wrapMode = texture.wrapMode, texture.resource?.style(this.renderer, texture, glTexture) || this.setStyle(texture, glTexture), glTexture.dirtyStyleId = texture.dirtyStyleId);\n  }\n  /**\n   * Set style for texture\n   * @private\n   * @param texture - Texture to update\n   * @param glTexture\n   */\n  setStyle(texture, glTexture) {\n    const gl = this.gl;\n    if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL && gl.generateMipmap(texture.target), gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode), gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode), glTexture.mipmap) {\n      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n      const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;\n      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {\n        const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n      }\n    } else gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nTextureSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"texture\"\n};\nextensions.add(TextureSystem);\nexport { TextureSystem };","map":{"version":3,"names":["TextureSystem","constructor","renderer","boundTextures","currentLocation","managedTextures","_unknownBoundTextures","unknownTexture","BaseTexture","hasIntegerTextures","contextChange","gl","CONTEXT_UID","webGLVersion","context","internalFormats","mapTypeAndFormatToInternalFormat","samplerTypes","mapInternalFormatToSamplerType","maxTextures","getParameter","MAX_TEXTURE_IMAGE_UNITS","length","i","emptyTextures","emptyTexture2D","GLTexture","createTexture","bindTexture","TEXTURE_2D","texture","texImage2D","RGBA","UNSIGNED_BYTE","Uint8Array","TEXTURE_CUBE_MAP","TEXTURE_CUBE_MAP_POSITIVE_X","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","bind","location","castToBaseTexture","valid","parentTextureArray","touched","textureGC","count","glTexture","_glTextures","initTexture","activeTexture","TEXTURE0","target","dirtyId","updateTexture","dirtyStyleId","updateTextureStyle","reset","unbind","ensureSamplerType","tex","samplerType","SAMPLER_TYPES","FLOAT","push","on","destroyTexture","initTextureType","internalFormat","type","format","TYPES","HALF_FLOAT","resource","upload","width","realWidth","height","realHeight","skipRemove","deleteTexture","off","indexOf","removeItems","mipmap","MIPMAP_MODES","POW2","isPowerOfTwo","wrapMode","WRAP_MODES","CLAMP","style","setStyle","ON_MANUAL","generateMipmap","TEXTURE_WRAP_S","TEXTURE_WRAP_T","scaleMode","SCALE_MODES","LINEAR_MIPMAP_LINEAR","NEAREST_MIPMAP_NEAREST","anisotropicExt","extensions","anisotropicFiltering","anisotropicLevel","level","Math","min","MAX_TEXTURE_MAX_ANISOTROPY_EXT","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","NEAREST","destroy","extension","ExtensionType","RendererSystem","name","add"],"sources":["/home/ryoitsu/node_modules/@pixi/core/src/textures/TextureSystem.ts"],"sourcesContent":["import { MIPMAP_MODES, SAMPLER_TYPES, SCALE_MODES, TYPES, WRAP_MODES } from '@pixi/constants';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport { removeItems } from '@pixi/utils';\nimport { BaseTexture } from './BaseTexture';\nimport { GLTexture } from './GLTexture';\nimport { mapInternalFormatToSamplerType } from './utils/mapInternalFormatToSamplerType';\nimport { mapTypeAndFormatToInternalFormat } from './utils/mapTypeAndFormatToInternalFormat';\n\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { IRenderingContext } from '../IRenderer';\nimport type { Renderer } from '../Renderer';\nimport type { ISystem } from '../system/ISystem';\nimport type { Texture } from './Texture';\n\n/**\n * System plugin to the renderer to manage textures.\n * @memberof PIXI\n */\nexport class TextureSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'texture',\n    };\n\n    /**\n     * Bound textures.\n     * @readonly\n     */\n    public boundTextures: BaseTexture[];\n\n    /**\n     * List of managed textures.\n     * @readonly\n     */\n    public managedTextures: Array<BaseTexture>;\n\n    /** Whether glTexture with int/uint sampler type was uploaded. */\n    protected hasIntegerTextures: boolean;\n    protected CONTEXT_UID: number;\n    protected gl: IRenderingContext;\n    protected internalFormats: { [type: number]: { [format: number]: number } };\n    protected samplerTypes: Record<number, SAMPLER_TYPES>;\n    protected webGLVersion: number;\n\n    /**\n     * BaseTexture value that shows that we don't know what is bound.\n     * @readonly\n     */\n    protected unknownTexture: BaseTexture;\n\n    /**\n     * Did someone temper with textures state? We'll overwrite them when we need to unbind something.\n     * @private\n     */\n    protected _unknownBoundTextures: boolean;\n\n    /**\n     * Current location.\n     * @readonly\n     */\n    currentLocation: number;\n    emptyTextures: {[key: number]: GLTexture};\n    private renderer: Renderer;\n\n    /**\n     * @param renderer - The renderer this system works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n\n        // TODO set to max textures...\n        this.boundTextures = [];\n        this.currentLocation = -1;\n        this.managedTextures = [];\n\n        this._unknownBoundTextures = false;\n        this.unknownTexture = new BaseTexture();\n\n        this.hasIntegerTextures = false;\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    contextChange(): void\n    {\n        const gl = this.gl = this.renderer.gl;\n\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n\n        this.webGLVersion = this.renderer.context.webGLVersion;\n\n        this.internalFormats = mapTypeAndFormatToInternalFormat(gl);\n        this.samplerTypes = mapInternalFormatToSamplerType(gl);\n\n        const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n        this.boundTextures.length = maxTextures;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            this.boundTextures[i] = null;\n        }\n\n        // TODO move this.. to a nice make empty textures class..\n        this.emptyTextures = {};\n\n        const emptyTexture2D = new GLTexture(gl.createTexture());\n\n        gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));\n\n        this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;\n        this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());\n\n        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);\n\n        for (let i = 0; i < 6; i++)\n        {\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n        for (let i = 0; i < this.boundTextures.length; i++)\n        {\n            this.bind(null, i);\n        }\n    }\n\n    /**\n     * Bind a texture to a specific location\n     *\n     * If you want to unbind something, please use `unbind(texture)` instead of `bind(null, textureLocation)`\n     * @param texture - Texture to bind\n     * @param [location=0] - Location to bind at\n     */\n    bind(texture: Texture | BaseTexture, location = 0): void\n    {\n        const { gl } = this;\n\n        texture = texture?.castToBaseTexture();\n\n        // cannot bind partial texture\n        // TODO: report a warning\n        if (texture?.valid && !texture.parentTextureArray)\n        {\n            texture.touched = this.renderer.textureGC.count;\n\n            const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);\n\n            if (this.boundTextures[location] !== texture)\n            {\n                if (this.currentLocation !== location)\n                {\n                    this.currentLocation = location;\n                    gl.activeTexture(gl.TEXTURE0 + location);\n                }\n\n                gl.bindTexture(texture.target, glTexture.texture);\n            }\n\n            if (glTexture.dirtyId !== texture.dirtyId)\n            {\n                if (this.currentLocation !== location)\n                {\n                    this.currentLocation = location;\n                    gl.activeTexture(gl.TEXTURE0 + location);\n                }\n                this.updateTexture(texture);\n            }\n            else if (glTexture.dirtyStyleId !== texture.dirtyStyleId)\n            {\n                this.updateTextureStyle(texture);\n            }\n\n            this.boundTextures[location] = texture;\n        }\n        else\n        {\n            if (this.currentLocation !== location)\n            {\n                this.currentLocation = location;\n                gl.activeTexture(gl.TEXTURE0 + location);\n            }\n\n            gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);\n            this.boundTextures[location] = null;\n        }\n    }\n\n    /** Resets texture location and bound textures Actual `bind(null, i)` calls will be performed at next `unbind()` call */\n    reset(): void\n    {\n        this._unknownBoundTextures = true;\n        this.hasIntegerTextures = false;\n        this.currentLocation = -1;\n\n        for (let i = 0; i < this.boundTextures.length; i++)\n        {\n            this.boundTextures[i] = this.unknownTexture;\n        }\n    }\n\n    /**\n     * Unbind a texture.\n     * @param texture - Texture to bind\n     */\n    unbind(texture?: BaseTexture): void\n    {\n        const { gl, boundTextures } = this;\n\n        if (this._unknownBoundTextures)\n        {\n            this._unknownBoundTextures = false;\n            // someone changed webGL state,\n            // we have to be sure that our texture does not appear in multi-texture renderer samplers\n            for (let i = 0; i < boundTextures.length; i++)\n            {\n                if (boundTextures[i] === this.unknownTexture)\n                {\n                    this.bind(null, i);\n                }\n            }\n        }\n\n        for (let i = 0; i < boundTextures.length; i++)\n        {\n            if (boundTextures[i] === texture)\n            {\n                if (this.currentLocation !== i)\n                {\n                    gl.activeTexture(gl.TEXTURE0 + i);\n                    this.currentLocation = i;\n                }\n\n                gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);\n                boundTextures[i] = null;\n            }\n        }\n    }\n\n    /**\n     * Ensures that current boundTextures all have FLOAT sampler type,\n     * see {@link PIXI.SAMPLER_TYPES} for explanation.\n     * @param maxTextures - number of locations to check\n     */\n    ensureSamplerType(maxTextures: number): void\n    {\n        const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;\n\n        if (!hasIntegerTextures)\n        {\n            return;\n        }\n\n        for (let i = maxTextures - 1; i >= 0; --i)\n        {\n            const tex = boundTextures[i];\n\n            if (tex)\n            {\n                const glTexture = tex._glTextures[CONTEXT_UID];\n\n                if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT)\n                {\n                    this.renderer.texture.unbind(tex);\n                }\n            }\n        }\n    }\n\n    /**\n     * Initialize a texture\n     * @private\n     * @param texture - Texture to initialize\n     */\n    initTexture(texture: BaseTexture): GLTexture\n    {\n        const glTexture = new GLTexture(this.gl.createTexture());\n\n        // guarantee an update..\n        glTexture.dirtyId = -1;\n\n        texture._glTextures[this.CONTEXT_UID] = glTexture;\n\n        this.managedTextures.push(texture);\n        texture.on('dispose', this.destroyTexture, this);\n\n        return glTexture;\n    }\n\n    initTextureType(texture: BaseTexture, glTexture: GLTexture): void\n    {\n        glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format;\n        glTexture.samplerType = this.samplerTypes[glTexture.internalFormat] ?? SAMPLER_TYPES.FLOAT;\n\n        if (this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT)\n        {\n            // TYPES.HALF_FLOAT is WebGL1 HALF_FLOAT_OES\n            // we have to convert it to WebGL HALF_FLOAT\n            glTexture.type = this.gl.HALF_FLOAT;\n        }\n        else\n        {\n            glTexture.type = texture.type;\n        }\n    }\n\n    /**\n     * Update a texture\n     * @private\n     * @param {PIXI.BaseTexture} texture - Texture to initialize\n     */\n    updateTexture(texture: BaseTexture): void\n    {\n        const glTexture = texture._glTextures[this.CONTEXT_UID];\n\n        if (!glTexture)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n\n        this.initTextureType(texture, glTexture);\n\n        if (texture.resource?.upload(renderer, texture, glTexture))\n        {\n            // texture is uploaded, dont do anything!\n            if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT)\n            {\n                this.hasIntegerTextures = true;\n            }\n        }\n        else\n        {\n            // default, renderTexture-like logic\n            const width = texture.realWidth;\n            const height = texture.realHeight;\n            const gl = renderer.gl;\n\n            if (glTexture.width !== width\n                || glTexture.height !== height\n                || glTexture.dirtyId < 0)\n            {\n                glTexture.width = width;\n                glTexture.height = height;\n\n                gl.texImage2D(texture.target, 0,\n                    glTexture.internalFormat,\n                    width,\n                    height,\n                    0,\n                    texture.format,\n                    glTexture.type,\n                    null);\n            }\n        }\n\n        // lets only update what changes..\n        if (texture.dirtyStyleId !== glTexture.dirtyStyleId)\n        {\n            this.updateTextureStyle(texture);\n        }\n        glTexture.dirtyId = texture.dirtyId;\n    }\n\n    /**\n     * Deletes the texture from WebGL\n     * @private\n     * @param texture - the texture to destroy\n     * @param [skipRemove=false] - Whether to skip removing the texture from the TextureManager.\n     */\n    destroyTexture(texture: BaseTexture | Texture, skipRemove?: boolean): void\n    {\n        const { gl } = this;\n\n        texture = texture.castToBaseTexture();\n\n        if (texture._glTextures[this.CONTEXT_UID])\n        {\n            this.unbind(texture);\n\n            gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);\n            texture.off('dispose', this.destroyTexture, this);\n\n            delete texture._glTextures[this.CONTEXT_UID];\n\n            if (!skipRemove)\n            {\n                const i = this.managedTextures.indexOf(texture);\n\n                if (i !== -1)\n                {\n                    removeItems(this.managedTextures, i, 1);\n                }\n            }\n        }\n    }\n\n    /**\n     * Update texture style such as mipmap flag\n     * @private\n     * @param {PIXI.BaseTexture} texture - Texture to update\n     */\n    updateTextureStyle(texture: BaseTexture): void\n    {\n        const glTexture = texture._glTextures[this.CONTEXT_UID];\n\n        if (!glTexture)\n        {\n            return;\n        }\n\n        if ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo)\n        {\n            glTexture.mipmap = false;\n        }\n        else\n        {\n            glTexture.mipmap = texture.mipmap >= 1;\n        }\n\n        if (this.webGLVersion !== 2 && !texture.isPowerOfTwo)\n        {\n            glTexture.wrapMode = WRAP_MODES.CLAMP;\n        }\n        else\n        {\n            glTexture.wrapMode = texture.wrapMode;\n        }\n\n        if (texture.resource?.style(this.renderer, texture, glTexture))\n        {\n            // style is set, dont do anything!\n        }\n        else\n        {\n            this.setStyle(texture, glTexture);\n        }\n\n        glTexture.dirtyStyleId = texture.dirtyStyleId;\n    }\n\n    /**\n     * Set style for texture\n     * @private\n     * @param texture - Texture to update\n     * @param glTexture\n     */\n    setStyle(texture: BaseTexture, glTexture: GLTexture): void\n    {\n        const gl = this.gl;\n\n        if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL)\n        {\n            gl.generateMipmap(texture.target);\n        }\n\n        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);\n        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);\n\n        if (glTexture.mipmap)\n        {\n            /* eslint-disable max-len */\n            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n            /* eslint-disable max-len */\n\n            const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;\n\n            if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR)\n            {\n                const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n\n                gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n            }\n        }\n        else\n        {\n            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n        }\n\n        gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n    }\n\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n\nextensions.add(TextureSystem);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}