{"ast":null,"code":"import { lazyMethods, logger, objectClear } from '@polkadot/util';\nconst l = logger('api/augment');\nfunction logLength(type, values, and = []) {\n  return values.length ? ` ${values.length} ${type}${and.length ? ' and' : ''}` : '';\n}\nfunction logValues(type, values) {\n  return values.length ? `\\n\\t${type.padStart(7)}: ${values.sort().join(', ')}` : '';\n}\nfunction warn(prefix, type, [added, removed]) {\n  if (added.length || removed.length) {\n    l.warn(`api.${prefix}: Found${logLength('added', added, removed)}${logLength('removed', removed)} ${type}:${logValues('added', added)}${logValues('removed', removed)}`);\n  }\n}\nfunction findSectionExcludes(a, b) {\n  return a.filter(s => !b.includes(s));\n}\nfunction findSectionIncludes(a, b) {\n  return a.filter(s => b.includes(s));\n}\nfunction extractSections(src, dst) {\n  const srcSections = Object.keys(src);\n  const dstSections = Object.keys(dst);\n  return [findSectionExcludes(srcSections, dstSections), findSectionExcludes(dstSections, srcSections)];\n}\nfunction findMethodExcludes(src, dst) {\n  const srcSections = Object.keys(src);\n  const dstSections = findSectionIncludes(Object.keys(dst), srcSections);\n  const excludes = [];\n  for (let s = 0, scount = dstSections.length; s < scount; s++) {\n    const section = dstSections[s];\n    const srcMethods = Object.keys(src[section]);\n    const dstMethods = Object.keys(dst[section]);\n    for (let d = 0, mcount = dstMethods.length; d < mcount; d++) {\n      const method = dstMethods[d];\n      if (!srcMethods.includes(method)) {\n        excludes.push(`${section}.${method}`);\n      }\n    }\n  }\n  return excludes;\n}\nfunction extractMethods(src, dst) {\n  return [findMethodExcludes(dst, src), findMethodExcludes(src, dst)];\n}\n/**\n * @description Takes a decorated api section (e.g. api.tx) and augment it with the details. It does not override what is\n * already available, but rather just adds new missing items into the result object.\n * @internal\n */\nexport function augmentObject(prefix, src, dst, fromEmpty = false) {\n  fromEmpty && objectClear(dst);\n  // NOTE: This part is slightly problematic since it will get the\n  // values for at least all the sections and the names of the methods\n  // (Since methods won't be decorated before lazy, this _may_ be ok)\n  if (prefix && Object.keys(dst).length) {\n    warn(prefix, 'modules', extractSections(src, dst));\n    warn(prefix, 'calls', extractMethods(src, dst));\n  }\n  const sections = Object.keys(src);\n  for (let i = 0, count = sections.length; i < count; i++) {\n    const section = sections[i];\n    const methods = src[section];\n    // We don't set here with a lazy interface, we decorate based\n    // on the top-level structure (this bypasses adding lazy onto lazy)\n    if (!dst[section]) {\n      dst[section] = {};\n    }\n    lazyMethods(dst[section], Object.keys(methods), m => methods[m]);\n  }\n  return dst;\n}","map":{"version":3,"names":["lazyMethods","logger","objectClear","l","logLength","type","values","and","length","logValues","padStart","sort","join","warn","prefix","added","removed","findSectionExcludes","a","b","filter","s","includes","findSectionIncludes","extractSections","src","dst","srcSections","Object","keys","dstSections","findMethodExcludes","excludes","scount","section","srcMethods","dstMethods","d","mcount","method","push","extractMethods","augmentObject","fromEmpty","sections","i","count","methods","m"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api/util/augmentObject.js"],"sourcesContent":["import { lazyMethods, logger, objectClear } from '@polkadot/util';\nconst l = logger('api/augment');\nfunction logLength(type, values, and = []) {\n    return values.length\n        ? ` ${values.length} ${type}${and.length ? ' and' : ''}`\n        : '';\n}\nfunction logValues(type, values) {\n    return values.length\n        ? `\\n\\t${type.padStart(7)}: ${values.sort().join(', ')}`\n        : '';\n}\nfunction warn(prefix, type, [added, removed]) {\n    if (added.length || removed.length) {\n        l.warn(`api.${prefix}: Found${logLength('added', added, removed)}${logLength('removed', removed)} ${type}:${logValues('added', added)}${logValues('removed', removed)}`);\n    }\n}\nfunction findSectionExcludes(a, b) {\n    return a.filter((s) => !b.includes(s));\n}\nfunction findSectionIncludes(a, b) {\n    return a.filter((s) => b.includes(s));\n}\nfunction extractSections(src, dst) {\n    const srcSections = Object.keys(src);\n    const dstSections = Object.keys(dst);\n    return [\n        findSectionExcludes(srcSections, dstSections),\n        findSectionExcludes(dstSections, srcSections)\n    ];\n}\nfunction findMethodExcludes(src, dst) {\n    const srcSections = Object.keys(src);\n    const dstSections = findSectionIncludes(Object.keys(dst), srcSections);\n    const excludes = [];\n    for (let s = 0, scount = dstSections.length; s < scount; s++) {\n        const section = dstSections[s];\n        const srcMethods = Object.keys(src[section]);\n        const dstMethods = Object.keys(dst[section]);\n        for (let d = 0, mcount = dstMethods.length; d < mcount; d++) {\n            const method = dstMethods[d];\n            if (!srcMethods.includes(method)) {\n                excludes.push(`${section}.${method}`);\n            }\n        }\n    }\n    return excludes;\n}\nfunction extractMethods(src, dst) {\n    return [\n        findMethodExcludes(dst, src),\n        findMethodExcludes(src, dst)\n    ];\n}\n/**\n * @description Takes a decorated api section (e.g. api.tx) and augment it with the details. It does not override what is\n * already available, but rather just adds new missing items into the result object.\n * @internal\n */\nexport function augmentObject(prefix, src, dst, fromEmpty = false) {\n    fromEmpty && objectClear(dst);\n    // NOTE: This part is slightly problematic since it will get the\n    // values for at least all the sections and the names of the methods\n    // (Since methods won't be decorated before lazy, this _may_ be ok)\n    if (prefix && Object.keys(dst).length) {\n        warn(prefix, 'modules', extractSections(src, dst));\n        warn(prefix, 'calls', extractMethods(src, dst));\n    }\n    const sections = Object.keys(src);\n    for (let i = 0, count = sections.length; i < count; i++) {\n        const section = sections[i];\n        const methods = src[section];\n        // We don't set here with a lazy interface, we decorate based\n        // on the top-level structure (this bypasses adding lazy onto lazy)\n        if (!dst[section]) {\n            dst[section] = {};\n        }\n        lazyMethods(dst[section], Object.keys(methods), (m) => methods[m]);\n    }\n    return dst;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}