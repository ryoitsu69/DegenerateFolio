{"ast":null,"code":"import { warn } from '../../utils/logging/warn.mjs';\nimport { path } from '../../utils/path.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\nimport { isSingleItem } from '../utils/isSingleItem.mjs';\n\"use strict\";\nclass Loader {\n  constructor() {\n    this._parsers = [];\n    this._parsersValidated = false;\n    /**\n     * All loader parsers registered\n     * @type {assets.LoaderParser[]}\n     */\n    this.parsers = new Proxy(this._parsers, {\n      set: (target, key, value) => {\n        this._parsersValidated = false;\n        target[key] = value;\n        return true;\n      }\n    });\n    /** Cache loading promises that ae currently active */\n    this.promiseCache = {};\n  }\n  /** function used for testing */\n  reset() {\n    this._parsersValidated = false;\n    this.promiseCache = {};\n  }\n  /**\n   * Used internally to generate a promise for the asset to be loaded.\n   * @param url - The URL to be loaded\n   * @param data - any custom additional information relevant to the asset being loaded\n   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n   */\n  _getLoadPromiseAndParser(url, data) {\n    const result = {\n      promise: null,\n      parser: null\n    };\n    result.promise = (async () => {\n      let asset = null;\n      let parser = null;\n      if (data.loadParser) {\n        parser = this._parserHash[data.loadParser];\n        if (!parser) {\n          warn(`[Assets] specified load parser \"${data.loadParser}\" not found while loading ${url}`);\n        }\n      }\n      if (!parser) {\n        for (let i = 0; i < this.parsers.length; i++) {\n          const parserX = this.parsers[i];\n          if (parserX.load && parserX.test?.(url, data, this)) {\n            parser = parserX;\n            break;\n          }\n        }\n        if (!parser) {\n          warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);\n          return null;\n        }\n      }\n      asset = await parser.load(url, data, this);\n      result.parser = parser;\n      for (let i = 0; i < this.parsers.length; i++) {\n        const parser2 = this.parsers[i];\n        if (parser2.parse) {\n          if (parser2.parse && (await parser2.testParse?.(asset, data, this))) {\n            asset = (await parser2.parse(asset, data, this)) || asset;\n            result.parser = parser2;\n          }\n        }\n      }\n      return asset;\n    })();\n    return result;\n  }\n  async load(assetsToLoadIn, onProgress) {\n    if (!this._parsersValidated) {\n      this._validateParsers();\n    }\n    let count = 0;\n    const assets = {};\n    const singleAsset = isSingleItem(assetsToLoadIn);\n    const assetsToLoad = convertToList(assetsToLoadIn, item => ({\n      alias: [item],\n      src: item\n    }));\n    const total = assetsToLoad.length;\n    const promises = assetsToLoad.map(async asset => {\n      const url = path.toAbsolute(asset.src);\n      if (!assets[asset.src]) {\n        try {\n          if (!this.promiseCache[url]) {\n            this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n          }\n          assets[asset.src] = await this.promiseCache[url].promise;\n          if (onProgress) onProgress(++count / total);\n        } catch (e) {\n          delete this.promiseCache[url];\n          delete assets[asset.src];\n          throw new Error(`[Loader.load] Failed to load ${url}.\n${e}`);\n        }\n      }\n    });\n    await Promise.all(promises);\n    return singleAsset ? assets[assetsToLoad[0].src] : assets;\n  }\n  /**\n   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n   * The parser that created the asset, will be the one that unloads it.\n   * @example\n   * // Single asset:\n   * const asset = await Loader.load('cool.png');\n   *\n   * await Loader.unload('cool.png');\n   *\n   * console.log(asset.destroyed); // true\n   * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n   */\n  async unload(assetsToUnloadIn) {\n    const assetsToUnload = convertToList(assetsToUnloadIn, item => ({\n      alias: [item],\n      src: item\n    }));\n    const promises = assetsToUnload.map(async asset => {\n      const url = path.toAbsolute(asset.src);\n      const loadPromise = this.promiseCache[url];\n      if (loadPromise) {\n        const loadedAsset = await loadPromise.promise;\n        delete this.promiseCache[url];\n        await loadPromise.parser?.unload?.(loadedAsset, asset, this);\n      }\n    });\n    await Promise.all(promises);\n  }\n  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n  _validateParsers() {\n    this._parsersValidated = true;\n    this._parserHash = this._parsers.filter(parser => parser.name).reduce((hash, parser) => {\n      if (!parser.name) {\n        warn(`[Assets] loadParser should have a name`);\n      } else if (hash[parser.name]) {\n        warn(`[Assets] loadParser name conflict \"${parser.name}\"`);\n      }\n      return {\n        ...hash,\n        [parser.name]: parser\n      };\n    }, {});\n  }\n}\nexport { Loader };","map":{"version":3,"names":["Loader","constructor","_parsers","_parsersValidated","parsers","Proxy","set","target","key","value","promiseCache","reset","_getLoadPromiseAndParser","url","data","result","promise","parser","asset","loadParser","_parserHash","warn","i","length","parserX","load","test","parser2","parse","testParse","assetsToLoadIn","onProgress","_validateParsers","count","assets","singleAsset","isSingleItem","assetsToLoad","convertToList","item","alias","src","total","promises","map","path","toAbsolute","e","Error","Promise","all","unload","assetsToUnloadIn","assetsToUnload","loadPromise","loadedAsset","filter","name","reduce","hash"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/assets/loader/Loader.ts"],"sourcesContent":["import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type { ResolvedAsset } from '../types';\nimport type { LoaderParser } from './parsers/LoaderParser';\nimport type { PromiseAndParser } from './types';\n\n/**\n * The Loader is responsible for loading all assets, such as images, spritesheets, audio files, etc.\n * It does not do anything clever with URLs - it just loads stuff!\n * Behind the scenes all things are cached using promises. This means it's impossible to load an asset more than once.\n * Through the use of LoaderParsers, the loader can understand how to load any kind of file!\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the second major system of PixiJS' main Assets class\n * @memberof assets\n */\nexport class Loader\n{\n    private readonly _parsers: LoaderParser[] = [];\n    private _parserHash: Record<string, LoaderParser>;\n\n    private _parsersValidated = false;\n\n    /**\n     * All loader parsers registered\n     * @type {assets.LoaderParser[]}\n     */\n    public parsers = new Proxy(this._parsers, {\n        set: (target, key, value) =>\n        {\n            this._parsersValidated = false;\n\n            target[key as any as number] = value;\n\n            return true;\n        }\n    });\n\n    /** Cache loading promises that ae currently active */\n    public promiseCache: Record<string, PromiseAndParser> = {};\n\n    /** function used for testing */\n    public reset(): void\n    {\n        this._parsersValidated = false;\n        this.promiseCache = {};\n    }\n\n    /**\n     * Used internally to generate a promise for the asset to be loaded.\n     * @param url - The URL to be loaded\n     * @param data - any custom additional information relevant to the asset being loaded\n     * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n     */\n    private _getLoadPromiseAndParser(url: string, data?: ResolvedAsset): PromiseAndParser\n    {\n        const result: PromiseAndParser = {\n            promise: null,\n            parser: null\n        };\n\n        result.promise = (async () =>\n        {\n            let asset = null;\n\n            let parser: LoaderParser = null;\n\n            // first check to see if the user has specified a parser\n            if (data.loadParser)\n            {\n                // they have? lovely, lets use it\n                parser = this._parserHash[data.loadParser];\n\n                if (!parser)\n                {\n                    // #if _DEBUG\n                    // eslint-disable-next-line max-len\n                    warn(`[Assets] specified load parser \"${data.loadParser}\" not found while loading ${url}`);\n                    // #endif\n                }\n            }\n\n            // no parser specified, so lets try and find one using the tests\n            if (!parser)\n            {\n                for (let i = 0; i < this.parsers.length; i++)\n                {\n                    const parserX = this.parsers[i];\n\n                    if (parserX.load && parserX.test?.(url, data, this))\n                    {\n                        parser = parserX;\n                        break;\n                    }\n                }\n\n                if (!parser)\n                {\n                    // #if _DEBUG\n                    // eslint-disable-next-line max-len\n                    warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);\n                    // #endif\n\n                    return null;\n                }\n            }\n\n            asset = await parser.load(url, data, this);\n            result.parser = parser;\n\n            for (let i = 0; i < this.parsers.length; i++)\n            {\n                const parser = this.parsers[i];\n\n                if (parser.parse)\n                {\n                    if (parser.parse && await parser.testParse?.(asset, data, this))\n                    {\n                        // transform the asset..\n                        asset = await parser.parse(asset, data, this) || asset;\n\n                        result.parser = parser;\n                    }\n                }\n            }\n\n            return asset;\n        })();\n\n        return result;\n    }\n\n    /**\n     * Loads one or more assets using the parsers added to the Loader.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     * console.log(asset);\n     *\n     * // Multiple assets:\n     * const assets = await Loader.load(['cool.png', 'cooler.png']);\n     * console.log(assets);\n     * @param assetsToLoadIn - urls that you want to load, or a single one!\n     * @param onProgress - For multiple asset loading only, an optional function that is called\n     * when progress on asset loading is made. The function is passed a single parameter, `progress`,\n     * which represents the percentage (0.0 - 1.0) of the assets loaded. Do not use this function\n     * to detect when assets are complete and available, instead use the Promise returned by this function.\n     */\n    public async load<T = any>(\n        assetsToLoadIn: string | ResolvedAsset,\n        onProgress?: (progress: number) => void,\n    ): Promise<T>;\n    public async load<T = any>(\n        assetsToLoadIn: string[] | ResolvedAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        assetsToLoadIn: string | string[] | ResolvedAsset | ResolvedAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._parsersValidated)\n        {\n            this._validateParsers();\n        }\n\n        let count = 0;\n\n        const assets: Record<string, Promise<any>> = {};\n\n        const singleAsset = isSingleItem(assetsToLoadIn);\n\n        const assetsToLoad = convertToList<ResolvedAsset>(assetsToLoadIn, (item) => ({\n            alias: [item],\n            src: item,\n        }));\n\n        const total = assetsToLoad.length;\n\n        const promises: Promise<void>[] = assetsToLoad.map(async (asset: ResolvedAsset) =>\n        {\n            const url = path.toAbsolute(asset.src);\n\n            if (!assets[asset.src])\n            {\n                try\n                {\n                    if (!this.promiseCache[url])\n                    {\n                        this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n                    }\n\n                    assets[asset.src] = await this.promiseCache[url].promise;\n\n                    // Only progress if nothing goes wrong\n                    if (onProgress) onProgress(++count / total);\n                }\n                catch (e)\n                {\n                    // Delete eventually registered file and promises from internal cache\n                    // so they can be eligible for another loading attempt\n                    delete this.promiseCache[url];\n                    delete assets[asset.src];\n\n                    // Stop further execution\n                    throw new Error(`[Loader.load] Failed to load ${url}.\\n${e}`);\n                }\n            }\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? assets[assetsToLoad[0].src] : assets;\n    }\n\n    /**\n     * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n     * The parser that created the asset, will be the one that unloads it.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     *\n     * await Loader.unload('cool.png');\n     *\n     * console.log(asset.destroyed); // true\n     * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n     */\n    public async unload(\n        assetsToUnloadIn: string | string[] | ResolvedAsset | ResolvedAsset[],\n    ): Promise<void>\n    {\n        const assetsToUnload = convertToList<ResolvedAsset>(assetsToUnloadIn, (item) => ({\n            alias: [item],\n            src: item,\n        }));\n\n        const promises: Promise<void>[] = assetsToUnload.map(async (asset: ResolvedAsset) =>\n        {\n            const url = path.toAbsolute(asset.src);\n\n            const loadPromise = this.promiseCache[url];\n\n            if (loadPromise)\n            {\n                const loadedAsset = await loadPromise.promise;\n\n                delete this.promiseCache[url];\n\n                await loadPromise.parser?.unload?.(loadedAsset, asset, this);\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n    private _validateParsers()\n    {\n        this._parsersValidated = true;\n\n        this._parserHash = this._parsers\n            .filter((parser) => parser.name)\n            .reduce((hash, parser) =>\n            {\n                if (!parser.name)\n                {\n                    // #if _DEBUG\n                    warn(`[Assets] loadParser should have a name`);\n                    // #endif\n                }\n                else if (hash[parser.name])\n                {\n                    // #if _DEBUG\n                    warn(`[Assets] loadParser name conflict \"${parser.name}\"`);\n                    // #endif\n                }\n\n                return { ...hash, [parser.name]: parser };\n            }, {} as Record<string, LoaderParser>);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}