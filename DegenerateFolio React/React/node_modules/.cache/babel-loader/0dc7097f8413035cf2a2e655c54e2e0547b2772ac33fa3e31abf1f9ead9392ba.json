{"ast":null,"code":"const U8 = new Array(256);\nconst U16 = new Array(256 * 256);\nfor (let n = 0; n < 256; n++) {\n  U8[n] = n.toString(16).padStart(2, '0');\n}\nfor (let i = 0; i < 256; i++) {\n  const s = i << 8;\n  for (let j = 0; j < 256; j++) {\n    U16[s | j] = U8[i] + U8[j];\n  }\n}\n/** @internal */\nfunction hex(value, result) {\n  const mod = value.length % 2 | 0;\n  const length = value.length - mod | 0;\n  for (let i = 0; i < length; i += 2) {\n    result += U16[value[i] << 8 | value[i + 1]];\n  }\n  if (mod) {\n    result += U8[value[length] | 0];\n  }\n  return result;\n}\n/**\n * @name u8aToHex\n * @summary Creates a hex string from a Uint8Array object.\n * @description\n * `UInt8Array` input values return the actual hex string. `null` or `undefined` values returns an `0x` string.\n * @example\n * <BR>\n *\n * ```javascript\n * import { u8aToHex } from '@polkadot/util';\n *\n * u8aToHex(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0xf])); // 0x68656c0f\n * ```\n */\nexport function u8aToHex(value, bitLength = -1, isPrefixed = true) {\n  // this is not 100% correct sinmce we support isPrefixed = false....\n  const empty = isPrefixed ? '0x' : '';\n  if (!value?.length) {\n    return empty;\n  } else if (bitLength > 0) {\n    const length = Math.ceil(bitLength / 8);\n    if (value.length > length) {\n      return `${hex(value.subarray(0, length / 2), empty)}…${hex(value.subarray(value.length - length / 2), '')}`;\n    }\n  }\n  return hex(value, empty);\n}","map":{"version":3,"names":["U8","Array","U16","n","toString","padStart","i","s","j","hex","value","result","mod","length","u8aToHex","bitLength","isPrefixed","empty","Math","ceil","subarray"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util/u8a/toHex.js"],"sourcesContent":["const U8 = new Array(256);\nconst U16 = new Array(256 * 256);\nfor (let n = 0; n < 256; n++) {\n    U8[n] = n.toString(16).padStart(2, '0');\n}\nfor (let i = 0; i < 256; i++) {\n    const s = i << 8;\n    for (let j = 0; j < 256; j++) {\n        U16[s | j] = U8[i] + U8[j];\n    }\n}\n/** @internal */\nfunction hex(value, result) {\n    const mod = (value.length % 2) | 0;\n    const length = (value.length - mod) | 0;\n    for (let i = 0; i < length; i += 2) {\n        result += U16[(value[i] << 8) | value[i + 1]];\n    }\n    if (mod) {\n        result += U8[value[length] | 0];\n    }\n    return result;\n}\n/**\n * @name u8aToHex\n * @summary Creates a hex string from a Uint8Array object.\n * @description\n * `UInt8Array` input values return the actual hex string. `null` or `undefined` values returns an `0x` string.\n * @example\n * <BR>\n *\n * ```javascript\n * import { u8aToHex } from '@polkadot/util';\n *\n * u8aToHex(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0xf])); // 0x68656c0f\n * ```\n */\nexport function u8aToHex(value, bitLength = -1, isPrefixed = true) {\n    // this is not 100% correct sinmce we support isPrefixed = false....\n    const empty = isPrefixed\n        ? '0x'\n        : '';\n    if (!value?.length) {\n        return empty;\n    }\n    else if (bitLength > 0) {\n        const length = Math.ceil(bitLength / 8);\n        if (value.length > length) {\n            return `${hex(value.subarray(0, length / 2), empty)}…${hex(value.subarray(value.length - length / 2), '')}`;\n        }\n    }\n    return hex(value, empty);\n}\n"],"mappings":"AAAA,MAAMA,EAAE,GAAG,IAAIC,KAAK,CAAC,GAAG,CAAC;AACzB,MAAMC,GAAG,GAAG,IAAID,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC;AAChC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,GAAG,EAAEA,CAAC,EAAE,EAAE;EAC1BH,EAAE,CAACG,CAAC,CAAC,GAAGA,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;AAC3C;AACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,GAAG,EAAEA,CAAC,EAAE,EAAE;EAC1B,MAAMC,CAAC,GAAGD,CAAC,IAAI,CAAC;EAChB,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,GAAG,EAAEA,CAAC,EAAE,EAAE;IAC1BN,GAAG,CAACK,CAAC,GAAGC,CAAC,CAAC,GAAGR,EAAE,CAACM,CAAC,CAAC,GAAGN,EAAE,CAACQ,CAAC,CAAC;EAC9B;AACJ;AACA;AACA,SAASC,GAAGA,CAACC,KAAK,EAAEC,MAAM,EAAE;EACxB,MAAMC,GAAG,GAAIF,KAAK,CAACG,MAAM,GAAG,CAAC,GAAI,CAAC;EAClC,MAAMA,MAAM,GAAIH,KAAK,CAACG,MAAM,GAAGD,GAAG,GAAI,CAAC;EACvC,KAAK,IAAIN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGO,MAAM,EAAEP,CAAC,IAAI,CAAC,EAAE;IAChCK,MAAM,IAAIT,GAAG,CAAEQ,KAAK,CAACJ,CAAC,CAAC,IAAI,CAAC,GAAII,KAAK,CAACJ,CAAC,GAAG,CAAC,CAAC,CAAC;EACjD;EACA,IAAIM,GAAG,EAAE;IACLD,MAAM,IAAIX,EAAE,CAACU,KAAK,CAACG,MAAM,CAAC,GAAG,CAAC,CAAC;EACnC;EACA,OAAOF,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,QAAQA,CAACJ,KAAK,EAAEK,SAAS,GAAG,CAAC,CAAC,EAAEC,UAAU,GAAG,IAAI,EAAE;EAC/D;EACA,MAAMC,KAAK,GAAGD,UAAU,GAClB,IAAI,GACJ,EAAE;EACR,IAAI,CAACN,KAAK,EAAEG,MAAM,EAAE;IAChB,OAAOI,KAAK;EAChB,CAAC,MACI,IAAIF,SAAS,GAAG,CAAC,EAAE;IACpB,MAAMF,MAAM,GAAGK,IAAI,CAACC,IAAI,CAACJ,SAAS,GAAG,CAAC,CAAC;IACvC,IAAIL,KAAK,CAACG,MAAM,GAAGA,MAAM,EAAE;MACvB,OAAQ,GAAEJ,GAAG,CAACC,KAAK,CAACU,QAAQ,CAAC,CAAC,EAAEP,MAAM,GAAG,CAAC,CAAC,EAAEI,KAAK,CAAE,IAAGR,GAAG,CAACC,KAAK,CAACU,QAAQ,CAACV,KAAK,CAACG,MAAM,GAAGA,MAAM,GAAG,CAAC,CAAC,EAAE,EAAE,CAAE,EAAC;IAC/G;EACJ;EACA,OAAOJ,GAAG,CAACC,KAAK,EAAEO,KAAK,CAAC;AAC5B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}