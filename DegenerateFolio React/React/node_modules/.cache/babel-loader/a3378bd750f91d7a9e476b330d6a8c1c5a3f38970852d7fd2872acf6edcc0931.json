{"ast":null,"code":"import { GraphicsContextSystem } from '../GraphicsContextSystem.mjs';\n\"use strict\";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\nfunction buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(0.99,\n  // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n  Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness));\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {\n  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x34 = (x3 + x4) / 2;\n  const y34 = (y3 + y4) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  const x234 = (x23 + x34) / 2;\n  const y234 = (y23 + y34) / 2;\n  const x1234 = (x123 + x234) / 2;\n  const y1234 = (y123 + y234) / 2;\n  if (level > 0) {\n    let dx = x4 - x1;\n    let dy = y4 - y1;\n    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);\n    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);\n    let da1;\n    let da2;\n    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {\n      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        const a23 = Math.atan2(y3 - y2, x3 - x2);\n        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n        if (da1 >= pi) da1 = 2 * pi - da1;\n        if (da2 >= pi) da2 = 2 * pi - da2;\n        if (da1 + da2 < mAngleTolerance) {\n          points.push(x1234, y1234);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n          if (da2 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else if (d2 > FLT_EPSILON) {\n      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n        if (da1 >= pi) da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n        }\n      }\n    } else if (d3 > FLT_EPSILON) {\n      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n        if (da1 >= pi) da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else {\n      dx = x1234 - (x1 + x4) / 2;\n      dy = y1234 - (y1 + y4) / 2;\n      if (dx * dx + dy * dy <= distanceTolerance) {\n        points.push(x1234, y1234);\n        return;\n      }\n    }\n  }\n  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\nexport { buildAdaptiveBezier };","map":{"version":3,"names":["RECURSION_LIMIT","FLT_EPSILON","PATH_DISTANCE_EPSILON","curveAngleToleranceEpsilon","mAngleTolerance","mCuspLimit","buildAdaptiveBezier","points","sX","sY","cp1x","cp1y","cp2x","cp2y","eX","eY","smoothness","scale","smoothing","Math","min","max","GraphicsContextSystem","defaultOptions","bezierSmoothness","distanceTolerance","begin","recursive","push","x1","y1","x2","y2","x3","y3","x4","y4","level","pi","PI","x12","y12","x23","y23","x34","y34","x123","y123","x234","y234","x1234","y1234","dx","dy","d2","abs","d3","da1","da2","a23","atan2"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveBezier.ts"],"sourcesContent":["// thanks to https://github.com/mattdesl/adaptive-bezier-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\n\nexport function buildAdaptiveBezier(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    // TODO expose as a parameter\n    const scale = 1;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    // dont need to actually ad this!\n    // points.push(sX, sY);\n    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n    points.push(eX, eY);\n}\n\n// eslint-disable-next-line max-params\nfunction recursive(\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    x4: number, y4: number,\n    points: number[],\n    distanceTolerance: number,\n    level: number)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x34 = (x3 + x4) / 2;\n    const y34 = (y3 + y4) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    const x234 = (x23 + x34) / 2;\n    const y234 = (y23 + y34) / 2;\n    const x1234 = (x123 + x234) / 2;\n    const y1234 = (y123 + y234) / 2;\n\n    if (level > 0)\n    { // Enforce subdivision first time\n        // Try to approximate the full cubic curve by a single straight line\n        // ------------------\n        let dx = x4 - x1;\n        let dy = y4 - y1;\n\n        const d2 = Math.abs(((x2 - x4) * dy) - ((y2 - y4) * dx));\n        const d3 = Math.abs(((x3 - x4) * dy) - ((y3 - y4) * dx));\n\n        let da1; let da2;\n\n        if (d2 > FLT_EPSILON && d3 > FLT_EPSILON)\n        {\n            // Regular care\n            // -----------------\n            if ((d2 + d3) * (d2 + d3) <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                // If the curvature doesn't exceed the distanceTolerance value\n                // we tend to finish subdivisions.\n                // ----------------------\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle & Cusp Condition\n                // ----------------------\n                const a23 = Math.atan2(y3 - y2, x3 - x2);\n\n                da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n                da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n                if (da2 >= pi) da2 = (2 * pi) - da2;\n\n                if (da1 + da2 < mAngleTolerance)\n                {\n                    // Finally we can stop the recursion\n                    // ----------------------\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n\n                    if (da2 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d2 > FLT_EPSILON)\n        {\n            // p1,p3,p4 are collinear, p2 is considerable\n            // ----------------------\n            if (d2 * d2 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d3 > FLT_EPSILON)\n        {\n            // p1,p2,p4 are collinear, p3 is considerable\n            // ----------------------\n            if (d3 * d3 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else\n        {\n            // Collinear case\n            // -----------------\n            dx = x1234 - ((x1 + x4) / 2);\n            dy = y1234 - ((y1 + y4) / 2);\n            if ((dx * dx) + (dy * dy) <= distanceTolerance)\n            {\n                points.push(x1234, y1234);\n\n                return;\n            }\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}