{"ast":null,"code":"import { AbstractBase } from '@polkadot/types-codec';\nimport { isBigInt, isBn, isHex, isNumber, isU8a, u8aConcat, u8aToBn, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { decodeAddress } from '@polkadot/util-crypto';\nimport { GenericAccountId } from './AccountId.js';\nimport { GenericAccountIndex } from './AccountIndex.js';\nexport const ACCOUNT_ID_PREFIX = new Uint8Array([0xff]);\n/** @internal */\nfunction decodeString(registry, value) {\n  const decoded = decodeAddress(value);\n  return decoded.length === 32 ? registry.createTypeUnsafe('AccountId', [decoded]) : registry.createTypeUnsafe('AccountIndex', [u8aToBn(decoded)]);\n}\n/** @internal */\nfunction decodeU8a(registry, value) {\n  // This allows us to instantiate an address with a raw publicKey. Do this first before\n  // we checking the first byte, otherwise we may split an already-existent valid address\n  if (value.length === 32) {\n    return registry.createTypeUnsafe('AccountId', [value]);\n  } else if (value[0] === 0xff) {\n    return registry.createTypeUnsafe('AccountId', [value.subarray(1)]);\n  }\n  const [offset, length] = GenericAccountIndex.readLength(value);\n  return registry.createTypeUnsafe('AccountIndex', [u8aToBn(value.subarray(offset, offset + length))]);\n}\n/** @internal */\nfunction decodeAddressOrIndex(registry, value) {\n  return value instanceof GenericLookupSource ? value.inner : value instanceof GenericAccountId || value instanceof GenericAccountIndex ? value : isBn(value) || isNumber(value) || isBigInt(value) ? registry.createTypeUnsafe('AccountIndex', [value]) : Array.isArray(value) || isHex(value) || isU8a(value) ? decodeU8a(registry, u8aToU8a(value)) : decodeString(registry, value);\n}\n/**\n * @name LookupSource\n * @description\n * A wrapper around an AccountId and/or AccountIndex that is encoded with a prefix.\n * Since we are dealing with underlying publicKeys (or shorter encoded addresses),\n * we extend from Base with an AccountId/AccountIndex wrapper. Basically the Address\n * is encoded as `[ <prefix-byte>, ...publicKey/...bytes ]` as per spec\n */\nexport class GenericLookupSource extends AbstractBase {\n  constructor(registry, value = new Uint8Array()) {\n    super(registry, decodeAddressOrIndex(registry, value));\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    const rawLength = this._rawLength;\n    return rawLength + (\n    // for 1 byte AccountIndexes, we are not adding a specific prefix\n    rawLength > 1 ? 1 : 0);\n  }\n  /**\n   * @description The length of the raw value, either AccountIndex or AccountId\n   */\n  get _rawLength() {\n    return this.inner instanceof GenericAccountIndex ? GenericAccountIndex.calcLength(this.inner) : this.inner.encodedLength;\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    const value = this.inner.toU8a().subarray(0, this._rawLength);\n    return {\n      outer: [new Uint8Array(this.inner instanceof GenericAccountIndex ? GenericAccountIndex.writeLength(value) : ACCOUNT_ID_PREFIX), value]\n    };\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'Address';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    const encoded = this.inner.toU8a().subarray(0, this._rawLength);\n    return isBare ? encoded : u8aConcat(this.inner instanceof GenericAccountIndex ? GenericAccountIndex.writeLength(encoded) : ACCOUNT_ID_PREFIX, encoded);\n  }\n}","map":{"version":3,"names":["AbstractBase","isBigInt","isBn","isHex","isNumber","isU8a","u8aConcat","u8aToBn","u8aToHex","u8aToU8a","decodeAddress","GenericAccountId","GenericAccountIndex","ACCOUNT_ID_PREFIX","Uint8Array","decodeString","registry","value","decoded","length","createTypeUnsafe","decodeU8a","subarray","offset","readLength","decodeAddressOrIndex","GenericLookupSource","inner","Array","isArray","constructor","encodedLength","rawLength","_rawLength","calcLength","inspect","toU8a","outer","writeLength","toHex","toRawType","isBare","encoded"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/generic/LookupSource.js"],"sourcesContent":["import { AbstractBase } from '@polkadot/types-codec';\nimport { isBigInt, isBn, isHex, isNumber, isU8a, u8aConcat, u8aToBn, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { decodeAddress } from '@polkadot/util-crypto';\nimport { GenericAccountId } from './AccountId.js';\nimport { GenericAccountIndex } from './AccountIndex.js';\nexport const ACCOUNT_ID_PREFIX = new Uint8Array([0xff]);\n/** @internal */\nfunction decodeString(registry, value) {\n    const decoded = decodeAddress(value);\n    return decoded.length === 32\n        ? registry.createTypeUnsafe('AccountId', [decoded])\n        : registry.createTypeUnsafe('AccountIndex', [u8aToBn(decoded)]);\n}\n/** @internal */\nfunction decodeU8a(registry, value) {\n    // This allows us to instantiate an address with a raw publicKey. Do this first before\n    // we checking the first byte, otherwise we may split an already-existent valid address\n    if (value.length === 32) {\n        return registry.createTypeUnsafe('AccountId', [value]);\n    }\n    else if (value[0] === 0xff) {\n        return registry.createTypeUnsafe('AccountId', [value.subarray(1)]);\n    }\n    const [offset, length] = GenericAccountIndex.readLength(value);\n    return registry.createTypeUnsafe('AccountIndex', [u8aToBn(value.subarray(offset, offset + length))]);\n}\n/** @internal */\nfunction decodeAddressOrIndex(registry, value) {\n    return value instanceof GenericLookupSource\n        ? value.inner\n        : value instanceof GenericAccountId || value instanceof GenericAccountIndex\n            ? value\n            : isBn(value) || isNumber(value) || isBigInt(value)\n                ? registry.createTypeUnsafe('AccountIndex', [value])\n                : Array.isArray(value) || isHex(value) || isU8a(value)\n                    ? decodeU8a(registry, u8aToU8a(value))\n                    : decodeString(registry, value);\n}\n/**\n * @name LookupSource\n * @description\n * A wrapper around an AccountId and/or AccountIndex that is encoded with a prefix.\n * Since we are dealing with underlying publicKeys (or shorter encoded addresses),\n * we extend from Base with an AccountId/AccountIndex wrapper. Basically the Address\n * is encoded as `[ <prefix-byte>, ...publicKey/...bytes ]` as per spec\n */\nexport class GenericLookupSource extends AbstractBase {\n    constructor(registry, value = new Uint8Array()) {\n        super(registry, decodeAddressOrIndex(registry, value));\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        const rawLength = this._rawLength;\n        return rawLength + (\n        // for 1 byte AccountIndexes, we are not adding a specific prefix\n        rawLength > 1\n            ? 1\n            : 0);\n    }\n    /**\n     * @description The length of the raw value, either AccountIndex or AccountId\n     */\n    get _rawLength() {\n        return this.inner instanceof GenericAccountIndex\n            ? GenericAccountIndex.calcLength(this.inner)\n            : this.inner.encodedLength;\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        const value = this.inner.toU8a().subarray(0, this._rawLength);\n        return {\n            outer: [\n                new Uint8Array(this.inner instanceof GenericAccountIndex\n                    ? GenericAccountIndex.writeLength(value)\n                    : ACCOUNT_ID_PREFIX),\n                value\n            ]\n        };\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'Address';\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        const encoded = this.inner.toU8a().subarray(0, this._rawLength);\n        return isBare\n            ? encoded\n            : u8aConcat(this.inner instanceof GenericAccountIndex\n                ? GenericAccountIndex.writeLength(encoded)\n                : ACCOUNT_ID_PREFIX, encoded);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}