{"ast":null,"code":"import { Point } from '../../../../maths/point/Point.mjs';\nimport { closePointEps, curveEps } from '../const.mjs';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints.mjs';\n\"use strict\";\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight;\n  const iy = y - ny * innerWeight;\n  const ox = x + nx * outerWeight;\n  const oy = y + ny * outerWeight;\n  let exx;\n  let eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  const eix = ix + exx;\n  const eiy = iy + eyy;\n  const eox = ox + exx;\n  const eoy = oy + eyy;\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx;\n  const cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y);\n  let angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0;\n  const absAngleDiff = Math.abs(angleDiff);\n  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  const angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildLine(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {\n  const eps = closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const style = lineStyle;\n  let alignment = style.alignment;\n  if (lineStyle.alignment !== 0.5) {\n    let orientation = getOrientationOfPoints(points);\n    if (flipAlignment) orientation *= -1;\n    alignment = (alignment - 0.5) * orientation + 0.5;\n  }\n  const firstPoint = new Point(points[0], points[1]);\n  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n  const closedShape = closed;\n  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  const verts = vertices;\n  const length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2;\n  const width = style.width / 2;\n  const widthSquared = width * width;\n  const miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0];\n  let y0 = points[1];\n  let x1 = points[2];\n  let y1 = points[3];\n  let x2 = 0;\n  let y2 = 0;\n  let perpX = -(y0 - y1);\n  let perpY = x0 - x1;\n  let perp1x = 0;\n  let perp1y = 0;\n  let dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  const ratio = alignment;\n  const innerWeight = (1 - ratio) * 2;\n  const outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === \"round\") {\n      indexCount += round(x0 - perpX * (innerWeight - outerWeight) * 0.5, y0 - perpY * (innerWeight - outerWeight) * 0.5, x0 - perpX * innerWeight, y0 - perpY * innerWeight, x0 + perpX * outerWeight, y0 + perpY * outerWeight, verts, true) + 2;\n    } else if (style.cap === \"square\") {\n      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(x0 - perpX * innerWeight, y0 - perpY * innerWeight);\n  verts.push(x0 + perpX * outerWeight, y0 + perpY * outerWeight);\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n    dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    const dx0 = x1 - x0;\n    const dy0 = y0 - y1;\n    const dx1 = x1 - x2;\n    const dy1 = y2 - y1;\n    const dot = dx0 * dx1 + dy0 * dy1;\n    const cross = dy0 * dx1 - dy1 * dx0;\n    const clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n      if (dot >= 0) {\n        if (style.join === \"round\") {\n          indexCount += round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight);\n        verts.push(x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);\n      }\n      continue;\n    }\n    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);\n    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    const px = (dx0 * c2 - dx1 * c1) / cross;\n    const py = (dy1 * c1 - dy0 * c2) / cross;\n    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    const imx = x1 + (px - x1) * innerWeight;\n    const imy = y1 + (py - y1) * innerWeight;\n    const omx = x1 - (px - x1) * outerWeight;\n    const omy = y1 - (py - y1) * outerWeight;\n    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    const insideWeight = clockwise ? innerWeight : outerWeight;\n    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n    if (insideMiterOk) {\n      if (style.join === \"bevel\" || pDist / widthSquared > miterLimitSquared) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n        indexCount += 2;\n      } else if (style.join === \"round\") {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          indexCount += round(x1, y1, x1 + perpX * outerWeight, y1 + perpY * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          indexCount += round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else {\n      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n      if (style.join === \"round\") {\n        if (clockwise) {\n          indexCount += round(x1, y1, x1 + perpX * outerWeight, y1 + perpY * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;\n        } else {\n          indexCount += round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;\n        }\n      } else if (style.join === \"miter\" && pDist / widthSquared <= miterLimitSquared) {\n        if (clockwise) {\n          verts.push(omx, omy);\n          verts.push(omx, omy);\n        } else {\n          verts.push(imx, imy);\n          verts.push(imx, imy);\n        }\n        indexCount += 2;\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpX = -(y0 - y1);\n  perpY = x0 - x1;\n  dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n  if (!closedShape) {\n    if (style.cap === \"round\") {\n      indexCount += round(x1 - perpX * (innerWeight - outerWeight) * 0.5, y1 - perpY * (innerWeight - outerWeight) * 0.5, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 + perpX * outerWeight, y1 + perpY * outerWeight, verts, false) + 2;\n    } else if (style.cap === \"square\") {\n      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n    }\n  }\n  const eps2 = curveEps * curveEps;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\nexport { buildLine };","map":{"version":3,"names":["square","x","y","nx","ny","innerWeight","outerWeight","clockwise","verts","ix","iy","ox","oy","exx","eyy","eix","eiy","eox","eoy","push","round","cx","cy","sx","sy","ex","ey","cx2p0x","cy2p0y","angle0","Math","atan2","angle1","PI","startAngle","angleDiff","absAngleDiff","abs","radius","sqrt","segCount","angleInc","i","angle","sin","cos","buildLine","points","lineStyle","flipAlignment","closed","vertices","_verticesStride","_verticesOffset","indices","_indicesOffset","eps","closePointEps","length","style","alignment","orientation","getOrientationOfPoints","firstPoint","Point","lastPoint","closedShape","closedPath","slice","pop","set","midPointX","midPointY","unshift","indexCount","indexStart","width","widthSquared","miterLimitSquared","miterLimit","x0","y0","x1","y1","x2","y2","perpX","perpY","perp1x","perp1y","dist","ratio","cap","dx0","dy0","dx1","dy1","dot","cross","join","c1","c2","px","py","pDist","imx","imy","omx","omy","smallerInsideSegmentSq","min","insideWeight","smallerInsideDiagonalSq","insideMiterOk","eps2","curveEps"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildLine.ts"],"sourcesContent":["import { Point } from '../../../../maths/point/Point';\nimport { closePointEps, curveEps } from '../const';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints';\n\nimport type { StrokeStyle } from '../GraphicsContext';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array[]} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: number[],\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param lineStyle\n * @param flipAlignment\n * @param closed\n * @param vertices\n * @param _verticesStride\n * @param _verticesOffset\n * @param indices\n * @param _indicesOffset\n */\nexport function buildLine(\n    points: number[],\n    lineStyle: StrokeStyle,\n    flipAlignment: boolean,\n    closed: boolean,\n    // alignment:number,\n\n    vertices: number[],\n    _verticesStride: number,\n    _verticesOffset: number,\n\n    indices: number[],\n    _indicesOffset: number,\n\n): void\n{\n    // const shape = graphicsData.shape as Polygon;\n    //   let points = graphicsData.points || shape.points.slice();\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    const style = lineStyle;\n\n    let alignment = style.alignment;\n\n    if (lineStyle.alignment !== 0.5)\n    {\n        // rotate the points!\n        let orientation = getOrientationOfPoints(points);\n\n        if (flipAlignment)orientation *= -1;\n\n        alignment = ((alignment - 0.5) * orientation) + 0.5;\n    }\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = closed;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpX = -(y0 - y1);\n    let perpY = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    const ratio = alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x0 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpX * innerWeight),\n                y0 - (perpY * innerWeight),\n                x0 + (perpX * outerWeight),\n                y0 + (perpY * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpX * innerWeight),\n        y0 - (perpY * innerWeight));\n    verts.push(\n        x0 + (perpX * outerWeight),\n        y0 + (perpY * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpX = -(y0 - y1);\n        perpY = x0 - x1;\n\n        dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n        perpX /= dist;\n        perpY /= dist;\n        perpX *= width;\n        perpY *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight));\n            verts.push(\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === 'round')\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight),\n                    y1 - (perp1y * outerWeight));\n                verts.push(\n                    x1 + (perp1x * innerWeight),\n                    y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pDist is the distance between miter point and p1. */\n        const c1 = ((-perpX + x0) * (-perpY + y1)) - ((-perpX + x1) * (-perpY + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pDist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n\n        if (insideMiterOk)\n        {\n            if (style.join === 'bevel' || pDist / widthSquared > miterLimitSquared)\n            {\n                if (clockwise) /* rotating at inner angle */\n                {\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                }\n                else /* rotating at outer angle */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n                    verts.push(omx, omy); // outer miter point\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's outer vertex\n                    verts.push(omx, omy); // outer miter point\n                }\n\n                indexCount += 2;\n            }\n            else if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 4;\n\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                }\n                else /* arc is inside */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n                    verts.push(omx, omy);\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 4;\n\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                    verts.push(omx, omy);\n                }\n            }\n            else\n            {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n            verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n            if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 2;\n                }\n                else /* arc is inside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 2;\n                }\n            }\n            else if (style.join === 'miter' && pDist / widthSquared <= miterLimitSquared)\n            {\n                if (clockwise)\n                {\n                    verts.push(omx, omy); // inner miter point\n                    verts.push(omx, omy); // inner miter point\n                }\n                else\n                {\n                    verts.push(imx, imy); // outer miter point\n                    verts.push(imx, imy); // outer miter point\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's inner vertex\n            verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n\n    dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x1 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight),\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    // const indices = graphicsGeometry.indices;\n    const eps2 = curveEps * curveEps;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}