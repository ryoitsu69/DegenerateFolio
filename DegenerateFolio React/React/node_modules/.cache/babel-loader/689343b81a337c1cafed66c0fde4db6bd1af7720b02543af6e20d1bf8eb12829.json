{"ast":null,"code":"import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { collectAllRenderables } from '../../../scene/container/utils/buildInstructions.mjs';\nimport { CLEAR } from '../../renderers/gl/const.mjs';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const.mjs';\n\"use strict\";\nclass StencilMaskPipe {\n  constructor(renderer) {\n    // used when building and also when executing..\n    this._maskStackHash = {};\n    this._maskHash = /* @__PURE__ */new WeakMap();\n    this._renderer = renderer;\n  }\n  push(mask, _container, instructionSet) {\n    var _a;\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      canBundle: false\n    });\n    const maskContainer = effect.mask;\n    maskContainer.includeInBuild = true;\n    if (!this._maskHash.has(effect)) {\n      this._maskHash.set(effect, {\n        instructionsStart: 0,\n        instructionsLength: 0\n      });\n    }\n    const maskData = this._maskHash.get(effect);\n    maskData.instructionsStart = instructionSet.instructionSize;\n    collectAllRenderables(maskContainer, instructionSet, renderer.renderPipes);\n    maskContainer.includeInBuild = false;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      canBundle: false\n    });\n    const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n    maskData.instructionsLength = instructionsLength;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n  }\n  pop(mask, _container, instructionSet) {\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskBegin\",\n      canBundle: false\n    });\n    const maskData = this._maskHash.get(mask);\n    for (let i = 0; i < maskData.instructionsLength; i++) {\n      instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n    }\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskEnd\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    var _a;\n    const renderer = this._renderer;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n    if (instruction.action === \"pushMaskBegin\") {\n      renderer.renderTarget.ensureDepthStencil();\n      renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n      maskStackIndex++;\n      renderer.colorMask.setMask(0);\n    } else if (instruction.action === \"pushMaskEnd\") {\n      renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      renderer.colorMask.setMask(15);\n    } else if (instruction.action === \"popMaskBegin\") {\n      renderer.colorMask.setMask(0);\n      if (maskStackIndex !== 0) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n      } else {\n        renderer.renderTarget.clear(null, CLEAR.STENCIL);\n        renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n      }\n      maskStackIndex--;\n    } else if (instruction.action === \"popMaskEnd\") {\n      renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      renderer.colorMask.setMask(15);\n    }\n    this._maskStackHash[renderTargetUid] = maskStackIndex;\n  }\n  destroy() {\n    this._renderer = null;\n    this._maskStackHash = null;\n    this._maskHash = null;\n  }\n}\nStencilMaskPipe.extension = {\n  type: [ExtensionType.WebGLPipes, ExtensionType.WebGPUPipes, ExtensionType.CanvasPipes],\n  name: \"stencilMask\"\n};\nexport { StencilMaskPipe };","map":{"version":3,"names":["StencilMaskPipe","constructor","renderer","_maskStackHash","_maskHash","WeakMap","_renderer","push","mask","_container","instructionSet","_a","effect","renderPipes","batch","break","blendMode","setBlendMode","add","renderPipeId","action","canBundle","maskContainer","includeInBuild","has","set","instructionsStart","instructionsLength","maskData","get","instructionSize","collectAllRenderables","renderTargetUid","renderTarget","uid","pop","i","instructions","execute","instruction","maskStackIndex","ensureDepthStencil","stencil","setStencilMode","STENCIL_MODES","RENDERING_MASK_ADD","colorMask","setMask","MASK_ACTIVE","RENDERING_MASK_REMOVE","clear","CLEAR","STENCIL","DISABLED","destroy","extension","type","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","name"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/mask/stencil/StencilMaskPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { collectAllRenderables } from '../../../scene/container/utils/buildInstructions';\nimport { CLEAR } from '../../renderers/gl/const';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../renderers/shared/Renderable';\nimport type { Renderer } from '../../renderers/types';\nimport type { StencilMask } from './StencilMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nexport interface StencilMaskInstruction extends Instruction\n{\n    renderPipeId: 'stencilMask',\n    action: MaskMode,\n    mask: StencilMask,\n}\n\nexport class StencilMaskPipe implements InstructionPipe<StencilMaskInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'stencilMask',\n    } as const;\n\n    private _renderer: Renderer;\n\n    // used when building and also when executing..\n    private _maskStackHash: Record<number, number> = {};\n\n    private _maskHash = new WeakMap<StencilMask, {\n        instructionsStart: number,\n        instructionsLength: number,\n    }>();\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskBegin',\n            mask,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskContainer = effect.mask;\n\n        maskContainer.includeInBuild = true;\n\n        if (!this._maskHash.has(effect))\n        {\n            this._maskHash.set(effect, {\n                instructionsStart: 0,\n                instructionsLength: 0,\n            });\n        }\n\n        const maskData = this._maskHash.get(effect);\n\n        maskData.instructionsStart = instructionSet.instructionSize;\n\n        collectAllRenderables(\n            maskContainer,\n            instructionSet,\n            renderer.renderPipes,\n        );\n\n        maskContainer.includeInBuild = false;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskEnd',\n            mask,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n\n        maskData.instructionsLength = instructionsLength;\n\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        this._maskStackHash[renderTargetUid] ??= 0;\n    }\n\n    public pop(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        // stencil is stored based on current render target..\n        renderer.renderPipes.batch.break(instructionSet);\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskBegin',\n            canBundle: false,\n        });\n\n        const maskData = this._maskHash.get(mask as StencilMask);\n\n        for (let i = 0; i < maskData.instructionsLength; i++)\n        {\n            // eslint-disable-next-line max-len\n            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n        }\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskEnd',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: StencilMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        let maskStackIndex = this._maskStackHash[renderTargetUid] ??= 0;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            // we create the depth and stencil buffers JIT\n            // as no point allocating the memory if we don't use it\n            renderer.renderTarget.ensureDepthStencil();\n\n            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n\n            maskStackIndex++;\n\n            renderer.colorMask.setMask(0);\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            renderer.colorMask.setMask(0xF);\n        }\n        else if (instruction.action === 'popMaskBegin')\n        {\n            renderer.colorMask.setMask(0);\n\n            if (maskStackIndex !== 0)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.renderTarget.clear(null, CLEAR.STENCIL);\n                renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n            }\n\n            maskStackIndex--;\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n\n            renderer.colorMask.setMask(0xF);\n        }\n\n        this._maskStackHash[renderTargetUid] = maskStackIndex;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n        this._maskStackHash = null;\n        this._maskHash = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}