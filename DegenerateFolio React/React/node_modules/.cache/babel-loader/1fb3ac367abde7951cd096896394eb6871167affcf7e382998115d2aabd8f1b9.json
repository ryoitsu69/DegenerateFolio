{"ast":null,"code":"import { CLEAR } from '../../gl/const.mjs';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource.mjs';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource.mjs';\nimport { GpuRenderTarget } from './GpuRenderTarget.mjs';\n\"use strict\";\nclass GpuRenderTargetAdaptor {\n  init(renderer, renderTargetSystem) {\n    this._renderer = renderer;\n    this._renderTargetSystem = renderTargetSystem;\n  }\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    const renderer = this._renderer;\n    const baseGpuTexture = this._getGpuColorTexture(sourceRenderSurfaceTexture);\n    const backGpuTexture = renderer.texture.getGpuSource(destinationTexture.source);\n    renderer.encoder.commandEncoder.copyTextureToTexture({\n      texture: baseGpuTexture,\n      origin: originSrc\n    }, {\n      texture: backGpuTexture,\n      origin: originDest\n    }, size);\n    return destinationTexture;\n  }\n  startRenderPass(renderTarget, clear = true, clearColor, viewport) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n    gpuRenderTarget.descriptor = descriptor;\n    this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n    this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n    this._renderer.encoder.setViewport(viewport);\n  }\n  finishRenderPass() {\n    this._renderer.encoder.endRenderPass();\n  }\n  /**\n   * returns the gpu texture for the first color texture in the render target\n   * mainly used by the filter manager to get copy the texture for blending\n   * @param renderTarget\n   * @returns a gpu texture\n   */\n  _getGpuColorTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (gpuRenderTarget.contexts[0]) {\n      return gpuRenderTarget.contexts[0].getCurrentTexture();\n    }\n    return this._renderer.texture.getGpuSource(renderTarget.colorTextures[0].source);\n  }\n  getDescriptor(renderTarget, clear, clearValue) {\n    if (typeof clear === \"boolean\") {\n      clear = clear ? CLEAR.ALL : CLEAR.NONE;\n    }\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const colorAttachments = renderTarget.colorTextures.map((texture, i) => {\n      const context = gpuRenderTarget.contexts[i];\n      let view;\n      let resolveTarget;\n      if (context) {\n        const currentTexture = context.getCurrentTexture();\n        const canvasTextureView = currentTexture.createView();\n        view = canvasTextureView;\n      } else {\n        view = this._renderer.texture.getGpuSource(texture).createView({\n          mipLevelCount: 1\n        });\n      }\n      if (gpuRenderTarget.msaaTextures[i]) {\n        resolveTarget = view;\n        view = this._renderer.texture.getTextureView(gpuRenderTarget.msaaTextures[i]);\n      }\n      const loadOp = clear & CLEAR.COLOR ? \"clear\" : \"load\";\n      clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);\n      return {\n        view,\n        resolveTarget,\n        clearValue,\n        storeOp: \"store\",\n        loadOp\n      };\n    });\n    let depthStencilAttachment;\n    if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {\n      renderTarget.ensureDepthStencilTexture();\n      renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n    }\n    if (renderTarget.depthStencilTexture) {\n      const stencilLoadOp = clear & CLEAR.STENCIL ? \"clear\" : \"load\";\n      const depthLoadOp = clear & CLEAR.DEPTH ? \"clear\" : \"load\";\n      depthStencilAttachment = {\n        view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),\n        stencilStoreOp: \"store\",\n        stencilLoadOp,\n        depthClearValue: 1,\n        depthLoadOp,\n        depthStoreOp: \"store\"\n      };\n    }\n    const descriptor = {\n      colorAttachments,\n      depthStencilAttachment\n    };\n    return descriptor;\n  }\n  clear(renderTarget, clear = true, clearColor, viewport) {\n    if (!clear) return;\n    const {\n      gpu,\n      encoder\n    } = this._renderer;\n    const device = gpu.device;\n    const standAlone = encoder.commandEncoder === null;\n    if (standAlone) {\n      const commandEncoder = device.createCommandEncoder();\n      const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n      passEncoder.end();\n      const gpuCommands = commandEncoder.finish();\n      device.queue.submit([gpuCommands]);\n    } else {\n      this.startRenderPass(renderTarget, clear, clearColor, viewport);\n    }\n  }\n  initGpuRenderTarget(renderTarget) {\n    renderTarget.isRoot = true;\n    const gpuRenderTarget = new GpuRenderTarget();\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      if (CanvasSource.test(colorTexture.resource)) {\n        const context = colorTexture.resource.getContext(\"webgpu\");\n        const alphaMode = colorTexture.transparent ? \"premultiplied\" : \"opaque\";\n        try {\n          context.configure({\n            device: this._renderer.gpu.device,\n            // eslint-disable-next-line max-len\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n            format: \"bgra8unorm\",\n            alphaMode\n          });\n        } catch (e) {\n          console.error(e);\n        }\n        gpuRenderTarget.contexts[i] = context;\n      }\n      gpuRenderTarget.msaa = colorTexture.source.antialias;\n      if (colorTexture.source.antialias) {\n        const msaaTexture = new TextureSource({\n          width: 0,\n          height: 0,\n          sampleCount: 4\n        });\n        gpuRenderTarget.msaaTextures[i] = msaaTexture;\n      }\n    });\n    if (gpuRenderTarget.msaa) {\n      gpuRenderTarget.msaaSamples = 4;\n      if (renderTarget.depthStencilTexture) {\n        renderTarget.depthStencilTexture.source.sampleCount = 4;\n      }\n    }\n    return gpuRenderTarget;\n  }\n  destroyGpuRenderTarget(gpuRenderTarget) {\n    gpuRenderTarget.contexts.forEach(context => {\n      context.unconfigure();\n    });\n    gpuRenderTarget.msaaTextures.forEach(texture => {\n      texture.destroy();\n    });\n    gpuRenderTarget.msaaTextures.length = 0;\n    gpuRenderTarget.contexts.length = 0;\n  }\n  ensureDepthStencilTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {\n      renderTarget.depthStencilTexture.source.sampleCount = 4;\n    }\n  }\n  resizeGpuRenderTarget(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    gpuRenderTarget.width = renderTarget.width;\n    gpuRenderTarget.height = renderTarget.height;\n    if (gpuRenderTarget.msaa) {\n      renderTarget.colorTextures.forEach((colorTexture, i) => {\n        const msaaTexture = gpuRenderTarget.msaaTextures[i];\n        msaaTexture?.resize(colorTexture.source.width, colorTexture.source.height, colorTexture.source._resolution);\n      });\n    }\n  }\n}\nexport { GpuRenderTargetAdaptor };","map":{"version":3,"names":["GpuRenderTargetAdaptor","init","renderer","renderTargetSystem","_renderer","_renderTargetSystem","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","size","originDest","baseGpuTexture","_getGpuColorTexture","backGpuTexture","texture","getGpuSource","source","encoder","commandEncoder","copyTextureToTexture","origin","startRenderPass","renderTarget","clear","clearColor","viewport","gpuRenderTarget","getGpuRenderTarget","descriptor","getDescriptor","pipeline","setRenderTarget","beginRenderPass","setViewport","finishRenderPass","endRenderPass","contexts","getCurrentTexture","colorTextures","clearValue","CLEAR","ALL","NONE","colorAttachments","map","i","context","view","resolveTarget","currentTexture","canvasTextureView","createView","mipLevelCount","msaaTextures","getTextureView","loadOp","COLOR","defaultClearColor","storeOp","depthStencilAttachment","stencil","depth","depthStencilTexture","ensureDepthStencilTexture","sampleCount","msaa","stencilLoadOp","STENCIL","depthLoadOp","DEPTH","stencilStoreOp","depthClearValue","depthStoreOp","gpu","device","standAlone","createCommandEncoder","renderPassDescriptor","passEncoder","x","y","width","height","end","gpuCommands","finish","queue","submit","initGpuRenderTarget","isRoot","GpuRenderTarget","forEach","colorTexture","CanvasSource","test","resource","getContext","alphaMode","transparent","configure","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","RENDER_ATTACHMENT","COPY_SRC","format","e","console","error","antialias","msaaTexture","TextureSource","msaaSamples","destroyGpuRenderTarget","unconfigure","destroy","length","resizeGpuRenderTarget","resize","_resolution"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.ts"],"sourcesContent":["import { CLEAR } from '../../gl/const';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport { GpuRenderTarget } from './GpuRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/**\n * The WebGPU adaptor for the render target system. Allows the Render Target System to\n * be used with the WebGPU renderer\n * @memberof rendering\n * @ignore\n */\nexport class GpuRenderTargetAdaptor implements RenderTargetAdaptor<GpuRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GpuRenderTarget>;\n    private _renderer: WebGPURenderer<HTMLCanvasElement>;\n\n    public init(renderer: WebGPURenderer, renderTargetSystem: RenderTargetSystem<GpuRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderer = this._renderer;\n\n        const baseGpuTexture = this._getGpuColorTexture(\n            sourceRenderSurfaceTexture\n        );\n\n        const backGpuTexture = renderer.texture.getGpuSource(\n            destinationTexture.source\n        );\n\n        renderer.encoder.commandEncoder.copyTextureToTexture(\n            {\n                texture: baseGpuTexture,\n                origin: originSrc,\n            },\n            {\n                texture: backGpuTexture,\n                origin: originDest,\n            },\n            size\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n        gpuRenderTarget.descriptor = descriptor;\n\n        // TODO we should not finish a render pass each time we bind\n        // for example filters - we would want to push / pop render targets\n        this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n        this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n        this._renderer.encoder.setViewport(viewport);\n    }\n\n    public finishRenderPass()\n    {\n        this._renderer.encoder.endRenderPass();\n    }\n\n    /**\n     * returns the gpu texture for the first color texture in the render target\n     * mainly used by the filter manager to get copy the texture for blending\n     * @param renderTarget\n     * @returns a gpu texture\n     */\n    private _getGpuColorTexture(renderTarget: RenderTarget): GPUTexture\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (gpuRenderTarget.contexts[0])\n        {\n            return gpuRenderTarget.contexts[0].getCurrentTexture();\n        }\n\n        return this._renderer.texture.getGpuSource(\n            renderTarget.colorTextures[0].source\n        );\n    }\n\n    public getDescriptor(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL,\n        clearValue: RgbaArray\n    ): GPURenderPassDescriptor\n    {\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const colorAttachments = renderTarget.colorTextures.map(\n            (texture, i) =>\n            {\n                const context = gpuRenderTarget.contexts[i];\n\n                let view: GPUTextureView;\n                let resolveTarget: GPUTextureView;\n\n                if (context)\n                {\n                    const currentTexture = context.getCurrentTexture();\n\n                    const canvasTextureView = currentTexture.createView();\n\n                    view = canvasTextureView;\n                }\n                else\n                {\n                    view = this._renderer.texture.getGpuSource(texture).createView({\n                        mipLevelCount: 1,\n                    });\n                }\n\n                if (gpuRenderTarget.msaaTextures[i])\n                {\n                    resolveTarget = view;\n                    view = this._renderer.texture.getTextureView(\n                        gpuRenderTarget.msaaTextures[i]\n                    );\n                }\n\n                const loadOp = ((clear as CLEAR) & CLEAR.COLOR ? 'clear' : 'load') as GPULoadOp;\n\n                clearValue ??= renderTargetSystem.defaultClearColor;\n\n                return {\n                    view,\n                    resolveTarget,\n                    clearValue,\n                    storeOp: 'store',\n                    loadOp\n                };\n            }\n        ) as GPURenderPassColorAttachment[];\n\n        let depthStencilAttachment: GPURenderPassDepthStencilAttachment;\n\n        // if we have a depth or stencil buffer, we need to ensure we have a texture for it\n        // this is WebGPU specific - as WebGL does not require textures to run a depth / stencil buffer\n        if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture)\n        {\n            renderTarget.ensureDepthStencilTexture();\n            renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n        }\n\n        if (renderTarget.depthStencilTexture)\n        {\n            const stencilLoadOp = (clear & CLEAR.STENCIL ? 'clear' : 'load') as GPULoadOp;\n            const depthLoadOp = (clear & CLEAR.DEPTH ? 'clear' : 'load') as GPULoadOp;\n\n            depthStencilAttachment = {\n                view: this._renderer.texture\n                    .getGpuSource(renderTarget.depthStencilTexture.source)\n                    .createView(),\n                stencilStoreOp: 'store',\n                stencilLoadOp,\n                depthClearValue: 1.0,\n                depthLoadOp,\n                depthStoreOp: 'store',\n            };\n        }\n\n        const descriptor: GPURenderPassDescriptor = {\n            colorAttachments,\n            depthStencilAttachment,\n        };\n\n        return descriptor;\n    }\n\n    public clear(renderTarget: RenderTarget, clear: CLEAR_OR_BOOL = true, clearColor?: RgbaArray, viewport?: Rectangle)\n    {\n        if (!clear) return;\n\n        const { gpu, encoder } = this._renderer;\n\n        const device = gpu.device;\n\n        const standAlone = encoder.commandEncoder === null;\n\n        if (standAlone)\n        {\n            const commandEncoder = device.createCommandEncoder();\n            const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n\n            passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n            passEncoder.end();\n\n            const gpuCommands = commandEncoder.finish();\n\n            device.queue.submit([gpuCommands]);\n        }\n        else\n        {\n            this.startRenderPass(renderTarget, clear, clearColor, viewport);\n        }\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GpuRenderTarget\n    {\n        // always false for WebGPU\n        renderTarget.isRoot = true;\n\n        const gpuRenderTarget = new GpuRenderTarget();\n\n        // create a context...\n        // is a canvas...\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (CanvasSource.test(colorTexture.resource))\n            {\n                const context = colorTexture.resource.getContext(\n                    'webgpu'\n                ) as unknown as GPUCanvasContext;\n\n                const alphaMode = (colorTexture as CanvasSource).transparent ? 'premultiplied' : 'opaque';\n\n                try\n                {\n                    context.configure({\n                        device: this._renderer.gpu.device,\n                        // eslint-disable-next-line max-len\n                        usage: GPUTextureUsage.TEXTURE_BINDING\n                            | GPUTextureUsage.COPY_DST\n                            | GPUTextureUsage.RENDER_ATTACHMENT\n                            | GPUTextureUsage.COPY_SRC,\n                        format: 'bgra8unorm',\n                        alphaMode,\n                    });\n                }\n                catch (e)\n                {\n                    console.error(e);\n                }\n\n                gpuRenderTarget.contexts[i] = context;\n            }\n\n            gpuRenderTarget.msaa = colorTexture.source.antialias;\n\n            if (colorTexture.source.antialias)\n            {\n                const msaaTexture = new TextureSource({\n                    width: 0,\n                    height: 0,\n                    sampleCount: 4,\n                });\n\n                gpuRenderTarget.msaaTextures[i] = msaaTexture;\n            }\n        });\n\n        if (gpuRenderTarget.msaa)\n        {\n            gpuRenderTarget.msaaSamples = 4;\n\n            if (renderTarget.depthStencilTexture)\n            {\n                renderTarget.depthStencilTexture.source.sampleCount = 4;\n            }\n        }\n\n        return gpuRenderTarget;\n    }\n\n    public destroyGpuRenderTarget(gpuRenderTarget: GpuRenderTarget)\n    {\n        gpuRenderTarget.contexts.forEach((context) =>\n        {\n            context.unconfigure();\n        });\n\n        gpuRenderTarget.msaaTextures.forEach((texture) =>\n        {\n            texture.destroy();\n        });\n\n        gpuRenderTarget.msaaTextures.length = 0;\n        gpuRenderTarget.contexts.length = 0;\n    }\n\n    public ensureDepthStencilTexture(renderTarget: RenderTarget)\n    {\n        // TODO This function will be more useful once we cache the descriptors\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa)\n        {\n            renderTarget.depthStencilTexture.source.sampleCount = 4;\n        }\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        gpuRenderTarget.width = renderTarget.width;\n        gpuRenderTarget.height = renderTarget.height;\n\n        if (gpuRenderTarget.msaa)\n        {\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const msaaTexture = gpuRenderTarget.msaaTextures[i];\n\n                msaaTexture?.resize(\n                    colorTexture.source.width,\n                    colorTexture.source.height,\n                    colorTexture.source._resolution\n                );\n            });\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}