{"ast":null,"code":"\"use strict\";\n\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decrypt = exports.create = exports.privateKeyToAccount = exports.encrypt = exports.privateKeyToPublicKey = exports.privateKeyToAddress = exports.recover = exports.recoverTransaction = exports.signTransaction = exports.sign = exports.hashMessage = exports.parseAndValidatePrivateKey = void 0;\n/**\n * The web3 accounts package contains functions to generate Ethereum accounts and sign transactions & data.\n *\n * For using accounts functions, first install Web3 package using `npm i web3` or `yarn add web3` based on your package manager usage.\n * After that, Accounts functions will be available as mentioned in following snippet.\n * ```ts\n * import {Web3} from 'web3';\n *\n * const web3 = new Web3();\n * const account = web3.eth.accounts.create();\n * const result = web3.eth.accounts.hashMessage(\"Test Message\");\n *\n * ```\n *\n * For using individual package install `web3-eth-accounts` package using `npm i web3-eth-accounts` or `yarn add web3-eth-accounts` and only import required functions.\n * This is more efficient approach for building lightweight applications.\n * ```ts\n * import {create,hashMessage} from 'web3-eth-accounts';\n *\n * const account = create();\n * const result = hashMessage(\"Test Message\");\n *\n * ```\n * @module Accounts\n *\n */\nconst aes_js_1 = require(\"ethereum-cryptography/aes.js\");\nconst pbkdf2_js_1 = require(\"ethereum-cryptography/pbkdf2.js\");\nconst scrypt_js_1 = require(\"ethereum-cryptography/scrypt.js\");\nconst web3_errors_1 = require(\"web3-errors\");\nconst web3_utils_1 = require(\"web3-utils\");\nconst web3_validator_1 = require(\"web3-validator\");\nconst constants_js_1 = require(\"./tx/constants.js\");\nconst schemas_js_1 = require(\"./schemas.js\");\nconst transactionFactory_js_1 = require(\"./tx/transactionFactory.js\");\n/**\n * Get the private key Uint8Array after the validation.\n * Note: This function is not exported through main web3 package, so for using it directly import from accounts package.\n * @param data - Private key\n * @param ignoreLength - Optional, ignore length check during validation\n * @returns The Uint8Array private key\n *\n * ```ts\n * parseAndValidatePrivateKey(\"0x08c673022000ece7964ea4db2d9369c50442b2869cbd8fc21baaca59e18f642c\")\n *\n * > Uint8Array(32) [\n * 186,  26, 143, 168, 235, 179,  90,  75,\n * 101,  63,  84, 221, 152, 150,  30, 203,\n *   8, 113,  94, 226,  53, 213, 216,   5,\n * 194, 159,  17,  53, 219,  97, 121, 248\n * ]\n *\n * ```\n */\nconst parseAndValidatePrivateKey = (data, ignoreLength) => {\n  let privateKeyUint8Array;\n  // To avoid the case of 1 character less in a hex string which is prefixed with '0' by using 'bytesToUint8Array'\n  if (!ignoreLength && typeof data === 'string' && (0, web3_validator_1.isHexStrict)(data) && data.length !== 66) {\n    throw new web3_errors_1.PrivateKeyLengthError();\n  }\n  try {\n    privateKeyUint8Array = (0, web3_utils_1.isUint8Array)(data) ? data : (0, web3_utils_1.bytesToUint8Array)(data);\n  } catch (_a) {\n    throw new web3_errors_1.InvalidPrivateKeyError();\n  }\n  if (!ignoreLength && privateKeyUint8Array.byteLength !== 32) {\n    throw new web3_errors_1.PrivateKeyLengthError();\n  }\n  return privateKeyUint8Array;\n};\nexports.parseAndValidatePrivateKey = parseAndValidatePrivateKey;\n/**\n *\n * Hashes the given message. The data will be `UTF-8 HEX` decoded and enveloped as follows:\n * `\"\\x19Ethereum Signed Message:\\n\" + message.length + message` and hashed using keccak256.\n *\n * @param message - A message to hash, if its HEX it will be UTF8 decoded.\n * @returns The hashed message\n *\n * ```ts\n * web3.eth.accounts.hashMessage(\"Hello world\")\n *\n * > \"0x8144a6fa26be252b86456491fbcd43c1de7e022241845ffea1c3df066f7cfede\"\n *\n * web3.eth.accounts.hashMessage(web3.utils.utf8ToHex(\"Hello world\")) // Will be hex decoded in hashMessage\n *\n * > \"0x8144a6fa26be252b86456491fbcd43c1de7e022241845ffea1c3df066f7cfede\"\n * ```\n */\nconst hashMessage = message => {\n  const messageHex = (0, web3_validator_1.isHexStrict)(message) ? message : (0, web3_utils_1.utf8ToHex)(message);\n  const messageBytes = (0, web3_utils_1.hexToBytes)(messageHex);\n  const preamble = (0, web3_utils_1.hexToBytes)((0, web3_utils_1.fromUtf8)(\"\\x19Ethereum Signed Message:\\n\".concat(messageBytes.byteLength)));\n  const ethMessage = (0, web3_utils_1.uint8ArrayConcat)(preamble, messageBytes);\n  return (0, web3_utils_1.sha3Raw)(ethMessage); // using keccak in web3-utils.sha3Raw instead of SHA3 (NIST Standard) as both are different\n};\nexports.hashMessage = hashMessage;\n/**\n * Signs arbitrary data with a given private key.\n * :::info\n * The value passed as the data parameter will be UTF-8 HEX decoded and wrapped as follows: \"\\\\x19Ethereum Signed Message:\\\\n\" + message.length + message\n * :::\n\n * @param data - The data to sign\n * @param privateKey - The 32 byte private key to sign with\n * @returns The signature Object containing the message, messageHash, signature r, s, v\n *\n * ```ts\n * web3.eth.accounts.sign('Some data', '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318')\n * > {\n * message: 'Some data',\n * messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\n * v: '0x1c',\n * r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd',\n * s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029',\n * signature: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c'\n * }\n * ```\n */\nconst sign = (data, privateKey) => {\n  const privateKeyUint8Array = (0, exports.parseAndValidatePrivateKey)(privateKey);\n  const hash = (0, exports.hashMessage)(data);\n  const signature = constants_js_1.secp256k1.sign(hash.substring(2), privateKeyUint8Array);\n  const signatureBytes = signature.toCompactRawBytes();\n  const r = signature.r.toString(16).padStart(64, '0');\n  const s = signature.s.toString(16).padStart(64, '0');\n  const v = signature.recovery + 27;\n  return {\n    message: data,\n    messageHash: hash,\n    v: (0, web3_utils_1.numberToHex)(v),\n    r: \"0x\".concat(r),\n    s: \"0x\".concat(s),\n    signature: \"\".concat((0, web3_utils_1.bytesToHex)(signatureBytes)).concat(v.toString(16))\n  };\n};\nexports.sign = sign;\n/**\n * Signs an Ethereum transaction with a given private key.\n *\n * @param transaction - The transaction, must be a legacy, EIP2930 or EIP 1559 transaction type\n * @param privateKey -  The private key to import. This is 32 bytes of random data.\n * @returns A signTransactionResult object that contains message hash, r, s, v, transaction hash and raw transaction.\n *\n * This function is not stateful here. We need network access to get the account `nonce` and `chainId` to sign the transaction.\n * This function will rely on user to provide the full transaction to be signed. If you want to sign a partial transaction object\n * Use {@link Web3.eth.accounts.sign} instead.\n *\n * Signing a legacy transaction\n * ```ts\n * import {signTransaction, Transaction} from 'web3-eth-accounts';\n *\n * signTransaction(new Transaction({\n *\tto: '0x118C2E5F57FD62C2B5b46a5ae9216F4FF4011a07',\n *\tvalue: '0x186A0',\n *\tgasLimit: '0x520812',\n *\tgasPrice: '0x09184e72a000',\n *\tdata: '',\n *\tchainId: 1,\n *\tnonce: 0 }),\n * '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318')\n *\n * > {\n * messageHash: '0x28b7b75f7ba48d588a902c1ff4d5d13cc0ca9ac0aaa39562368146923fb853bf',\n * v: '0x25',\n * r: '0x601b0017b0e20dd0eeda4b895fbc1a9e8968990953482214f880bae593e71b5',\n * s: '0x690d984493560552e3ebdcc19a65b9c301ea9ddc82d3ab8cfde60485fd5722ce',\n * rawTransaction: '0xf869808609184e72a0008352081294118c2e5f57fd62c2b5b46a5ae9216f4ff4011a07830186a08025a00601b0017b0e20dd0eeda4b895fbc1a9e8968990953482214f880bae593e71b5a0690d984493560552e3ebdcc19a65b9c301ea9ddc82d3ab8cfde60485fd5722ce',\n * transactionHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\n * ```\n *\n * Signing an eip 1559 transaction\n * ```ts\n * import {signTransaction, Transaction} from 'web3-eth-accounts';\n *\n * signTransaction(new Transaction({\n *\tto: '0xF0109fC8DF283027b6285cc889F5aA624EaC1F55',\n *\tmaxPriorityFeePerGas: '0x3B9ACA00',\n *\tmaxFeePerGas: '0xB2D05E00',\n *\tgasLimit: '0x6A4012',\n *\tvalue: '0x186A0',\n *\tdata: '',\n *\tchainId: 1,\n *\tnonce: 0}),\n * \"0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318\")\n * > {\n *  messageHash: '0x5744f24d5f0aff6c70487c8e85adf07d8564e50b08558788f00479611d7bae5f',\n * v: '0x25',\n * r: '0x78a5a6b2876c3985f90f82073d18d57ac299b608cc76a4ba697b8bb085048347',\n * s: '0x9cfcb40cc7d505ed17ff2d3337b51b066648f10c6b7e746117de69b2eb6358d',\n * rawTransaction: '0xf8638080836a401294f0109fc8df283027b6285cc889f5aa624eac1f55830186a08025a078a5a6b2876c3985f90f82073d18d57ac299b608cc76a4ba697b8bb085048347a009cfcb40cc7d505ed17ff2d3337b51b066648f10c6b7e746117de69b2eb6358d',\n * transactionHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\n * }\n * ```\n *\n * Signing an eip 2930 transaction\n * ```ts\n * import {signTransaction, Transaction} from 'web3-eth-accounts';\n *\n * signTransaction(new Transaction ({\n *\tchainId: 1,\n *\tnonce: 0,\n *\tgasPrice: '0x09184e72a000',\n *\tgasLimit: '0x2710321',\n *\tto: '0xF0109fC8DF283027b6285cc889F5aA624EaC1F55',\n *\tvalue: '0x186A0',\n *\tdata: '',\n *\taccessList: [\n *\t\t{\n *\t\t\taddress: '0x0000000000000000000000000000000000000101',\n *\t\t\tstorageKeys: [\n *\t\t\t\t'0x0000000000000000000000000000000000000000000000000000000000000000',\n *\t\t\t\t'0x00000000000000000000000000000000000000000000000000000000000060a7',\n *\t\t\t],\n *\t\t},\n *\t],\n * }),\"0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318\")\n *\n * > {\n * messageHash: '0xc55ea24bdb4c379550a7c9a6818ac39ca33e75bc78ddb862bd82c31cc1c7a073',\n * v: '0x26',\n * r: '0x27344e77871c8b2068bc998bf28e0b5f9920867a69c455b2ed0c1c150fec098e',\n * s: '0x519f0130a1d662841d4a28082e9c9bb0a15e0e59bb46cfc39a52f0e285dec6b9',\n * rawTransaction: '0xf86a808609184e72a000840271032194f0109fc8df283027b6285cc889f5aa624eac1f55830186a08026a027344e77871c8b2068bc998bf28e0b5f9920867a69c455b2ed0c1c150fec098ea0519f0130a1d662841d4a28082e9c9bb0a15e0e59bb46cfc39a52f0e285dec6b9',\n * transactionHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\n * }\n * ```\n */\nconst signTransaction = (transaction, privateKey) => __awaiter(void 0, void 0, void 0, function* () {\n  const signedTx = transaction.sign((0, web3_utils_1.hexToBytes)(privateKey));\n  if ((0, web3_validator_1.isNullish)(signedTx.v) || (0, web3_validator_1.isNullish)(signedTx.r) || (0, web3_validator_1.isNullish)(signedTx.s)) throw new web3_errors_1.TransactionSigningError('Signer Error');\n  const validationErrors = signedTx.validate(true);\n  if (validationErrors.length > 0) {\n    let errorString = 'Signer Error ';\n    for (const validationError of validationErrors) {\n      errorString += \"\".concat(errorString, \" \").concat(validationError, \".\");\n    }\n    throw new web3_errors_1.TransactionSigningError(errorString);\n  }\n  const rawTx = (0, web3_utils_1.bytesToHex)(signedTx.serialize());\n  const txHash = (0, web3_utils_1.sha3Raw)(rawTx); // using keccak in web3-utils.sha3Raw instead of SHA3 (NIST Standard) as both are different\n  return {\n    messageHash: (0, web3_utils_1.bytesToHex)(signedTx.getMessageToSign(true)),\n    v: \"0x\".concat(signedTx.v.toString(16)),\n    r: \"0x\".concat(signedTx.r.toString(16).padStart(64, '0')),\n    s: \"0x\".concat(signedTx.s.toString(16).padStart(64, '0')),\n    rawTransaction: rawTx,\n    transactionHash: (0, web3_utils_1.bytesToHex)(txHash)\n  };\n});\nexports.signTransaction = signTransaction;\n/**\n * Recovers the Ethereum address which was used to sign the given RLP encoded transaction.\n *\n * @param rawTransaction - The hex string having RLP encoded transaction\n * @returns The Ethereum address used to sign this transaction\n * ```ts\n * web3.eth.accounts.recoverTransaction('0xf869808504e3b29200831e848094f0109fc8df283027b6285cc889f5aa624eac1f55843b9aca008025a0c9cf86333bcb065d140032ecaab5d9281bde80f21b9687b3e94161de42d51895a0727a108a0b8d101465414033c3f705a9c7b826e596766046ee1183dbc8aeaa68');\n * > \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\"\n * ```\n */\nconst recoverTransaction = rawTransaction => {\n  if ((0, web3_validator_1.isNullish)(rawTransaction)) throw new web3_errors_1.UndefinedRawTransactionError();\n  const tx = transactionFactory_js_1.TransactionFactory.fromSerializedData((0, web3_utils_1.hexToBytes)(rawTransaction));\n  return (0, web3_utils_1.toChecksumAddress)(tx.getSenderAddress().toString());\n};\nexports.recoverTransaction = recoverTransaction;\n/**\n * Recovers the Ethereum address which was used to sign the given data\n *\n * @param data - Either a signed message, hash, or the {@link signatureObject}\n * @param signature - The raw RLP encoded signature\n * @param signatureOrV - signature or V\n * @param prefixedOrR - prefixed or R\n * @param s - S value in signature\n * @param prefixed - (default: false) If the last parameter is true, the given message will NOT automatically be prefixed with `\"\\\\x19Ethereum Signed Message:\\\\n\" + message.length + message`, and assumed to be already prefixed.\n * @returns The Ethereum address used to sign this data\n *\n * ```ts\n * const data = 'Some data';\n * const sigObj = web3.eth.accounts.sign(data, '0xbe6383dad004f233317e46ddb46ad31b16064d14447a95cc1d8c8d4bc61c3728')\n *\n * > {\n *   message: 'Some data',\n *   messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\n *   v: '0x1b',\n *   r: '0xa8037a6116c176a25e6fc224947fde9e79a2deaa0dd8b67b366fbdfdbffc01f9',\n *   s: '0x53e41351267b20d4a89ebfe9c8f03c04de9b345add4a52f15bd026b63c8fb150',\n *   signature: '0xa8037a6116c176a25e6fc224947fde9e79a2deaa0dd8b67b366fbdfdbffc01f953e41351267b20d4a89ebfe9c8f03c04de9b345add4a52f15bd026b63c8fb1501b'\n * }\n *\n * // now recover\n * web3.eth.accounts.recover(data, sigObj.v, sigObj.r, sigObj.s)\n *\n * > 0xEB014f8c8B418Db6b45774c326A0E64C78914dC0\n * ```\n */\nconst recover = (data, signatureOrV, prefixedOrR, s, prefixed) => {\n  if (typeof data === 'object') {\n    const signatureStr = \"\".concat(data.r).concat(data.s.slice(2)).concat(data.v.slice(2));\n    return (0, exports.recover)(data.messageHash, signatureStr, prefixedOrR);\n  }\n  if (typeof signatureOrV === 'string' && typeof prefixedOrR === 'string' && !(0, web3_validator_1.isNullish)(s)) {\n    const signatureStr = \"\".concat(prefixedOrR).concat(s.slice(2)).concat(signatureOrV.slice(2));\n    return (0, exports.recover)(data, signatureStr, prefixed);\n  }\n  if ((0, web3_validator_1.isNullish)(signatureOrV)) throw new web3_errors_1.InvalidSignatureError('signature string undefined');\n  const V_INDEX = 130; // r = first 32 bytes, s = second 32 bytes, v = last byte of signature\n  const hashedMessage = prefixedOrR ? data : (0, exports.hashMessage)(data);\n  let v = parseInt(signatureOrV.substring(V_INDEX), 16); // 0x + r + s + v\n  if (v > 26) {\n    v -= 27;\n  }\n  const ecPublicKey = constants_js_1.secp256k1.Signature.fromCompact(signatureOrV.slice(2, V_INDEX)).addRecoveryBit(v).recoverPublicKey(hashedMessage.replace('0x', '')).toRawBytes(false);\n  const publicHash = (0, web3_utils_1.sha3Raw)(ecPublicKey.subarray(1));\n  const address = (0, web3_utils_1.toChecksumAddress)(\"0x\".concat(publicHash.slice(-40)));\n  return address;\n};\nexports.recover = recover;\n;\n/**\n * Get the ethereum Address from a private key\n *\n * @param privateKey - String or Uint8Array of 32 bytes\n * @param ignoreLength - if true, will not error check length\n * @returns The Ethereum address\n * @example\n * ```ts\n * web3.eth.accounts.privateKeyToAddress(\"0xbe6383dad004f233317e46ddb46ad31b16064d14447a95cc1d8c8d4bc61c3728\")\n *\n * > \"0xEB014f8c8B418Db6b45774c326A0E64C78914dC0\"\n * ```\n */\nconst privateKeyToAddress = privateKey => {\n  const privateKeyUint8Array = (0, exports.parseAndValidatePrivateKey)(privateKey);\n  // Get public key from private key in compressed format\n  const publicKey = constants_js_1.secp256k1.getPublicKey(privateKeyUint8Array, false);\n  // Uncompressed ECDSA public key contains the prefix `0x04` which is not used in the Ethereum public key\n  const publicKeyHash = (0, web3_utils_1.sha3Raw)(publicKey.slice(1));\n  // The hash is returned as 256 bits (32 bytes) or 64 hex characters\n  // To get the address, take the last 20 bytes of the public hash\n  const address = publicKeyHash.slice(-40);\n  return (0, web3_utils_1.toChecksumAddress)(\"0x\".concat(address));\n};\nexports.privateKeyToAddress = privateKeyToAddress;\n/**\n * Get the public key from a private key\n *\n * @param privateKey - String or Uint8Array of 32 bytes\n * @param isCompressed - if true, will generate a 33 byte compressed public key instead of a 65 byte public key\n * @returns The public key\n * @example\n * ```ts\n * web3.eth.accounts.privateKeyToPublicKey(\"0x1e046a882bb38236b646c9f135cf90ad90a140810f439875f2a6dd8e50fa261f\", true)\n *\n * > \"0x42beb65f179720abaa3ec9a70a539629cbbc5ec65bb57e7fc78977796837e537662dd17042e6449dc843c281067a4d6d8d1a1775a13c41901670d5de7ee6503a\" // uncompressed public key\n * ```\n */\nconst privateKeyToPublicKey = (privateKey, isCompressed) => {\n  const privateKeyUint8Array = (0, exports.parseAndValidatePrivateKey)(privateKey);\n  // Get public key from private key in compressed format\n  return \"0x\".concat((0, web3_utils_1.bytesToHex)(constants_js_1.secp256k1.getPublicKey(privateKeyUint8Array, isCompressed)).slice(4)); // 0x and removing compression byte\n};\nexports.privateKeyToPublicKey = privateKeyToPublicKey;\n/**\n * encrypt a private key with a password, returns a V3 JSON Keystore\n *\n * Read more: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n *\n * @param privateKey - The private key to encrypt, 32 bytes.\n * @param password - The password used for encryption.\n * @param options - Options to configure to encrypt the keystore either scrypt or pbkdf2\n * @returns Returns a V3 JSON Keystore\n *\n * Encrypt using scrypt options:\n * ```ts\n *\n * web3.eth.accounts.encrypt(\n *    '0x67f476289210e3bef3c1c75e4de993ff0a00663df00def84e73aa7411eac18a6',\n *    '123',\n *    {\n *        n: 8192,\n *\t    iv: web3.utils.hexToBytes('0xbfb43120ae00e9de110f8325143a2709'),\n *\t    salt: web3.utils.hexToBytes('0x210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd'),\n *\t}).then(console.log)\n *\n * > {\n * version: 3,\n * id: 'c0cb0a94-4702-4492-b6e6-eb2ac404344a',\n * address: 'cda9a91875fc35c8ac1320e098e584495d66e47c',\n * crypto: {\n *   ciphertext: 'cb3e13e3281ff3861a3f0257fad4c9a51b0eb046f9c7821825c46b210f040b8f',\n *   cipherparams: { iv: 'bfb43120ae00e9de110f8325143a2709' },\n *   cipher: 'aes-128-ctr',\n *   kdf: 'scrypt',\n *   kdfparams: {\n *     n: 8192,\n *     r: 8,\n *     p: 1,\n *     dklen: 32,\n *     salt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd'\n *   },\n *   mac: 'efbf6d3409f37c0084a79d5fdf9a6f5d97d11447517ef1ea8374f51e581b7efd'\n * }\n *}\n *```\n *\n * Encrypting using pbkdf2 options:\n * ```ts\n * web3.eth.accounts.encrypt('0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n *'123',\n *{\n *\tiv: 'bfb43120ae00e9de110f8325143a2709',\n *\tsalt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd',\n *\tc: 262144,\n *\tkdf: 'pbkdf2',\n *}).then(console.log)\n *\n * >\n * {\n *   version: 3,\n *   id: '77381417-0973-4e4b-b590-8eb3ace0fe2d',\n *   address: 'b8ce9ab6943e0eced004cde8e3bbed6568b2fa01',\n *   crypto: {\n *     ciphertext: '76512156a34105fa6473ad040c666ae7b917d14c06543accc0d2dc28e6073b12',\n *     cipherparams: { iv: 'bfb43120ae00e9de110f8325143a2709' },\n *     cipher: 'aes-128-ctr',\n *     kdf: 'pbkdf2',\n *     kdfparams: {\n *       dklen: 32,\n *       salt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd',\n *       c: 262144,\n *       prf: 'hmac-sha256'\n *     },\n *   mac: '46eb4884e82dc43b5aa415faba53cc653b7038e9d61cc32fd643cf8c396189b7'\n *   }\n * }\n *```\n */\nconst encrypt = (privateKey, password, options) => __awaiter(void 0, void 0, void 0, function* () {\n  var _a, _b, _c, _d, _e, _f, _g;\n  const privateKeyUint8Array = (0, exports.parseAndValidatePrivateKey)(privateKey);\n  // if given salt or iv is a string, convert it to a Uint8Array\n  let salt;\n  if (options === null || options === void 0 ? void 0 : options.salt) {\n    salt = typeof options.salt === 'string' ? (0, web3_utils_1.hexToBytes)(options.salt) : options.salt;\n  } else {\n    salt = (0, web3_utils_1.randomBytes)(32);\n  }\n  if (!((0, web3_validator_1.isString)(password) || (0, web3_utils_1.isUint8Array)(password))) {\n    throw new web3_errors_1.InvalidPasswordError();\n  }\n  const uint8ArrayPassword = typeof password === 'string' ? (0, web3_utils_1.hexToBytes)((0, web3_utils_1.utf8ToHex)(password)) : password;\n  let initializationVector;\n  if (options === null || options === void 0 ? void 0 : options.iv) {\n    initializationVector = typeof options.iv === 'string' ? (0, web3_utils_1.hexToBytes)(options.iv) : options.iv;\n    if (initializationVector.length !== 16) {\n      throw new web3_errors_1.IVLengthError();\n    }\n  } else {\n    initializationVector = (0, web3_utils_1.randomBytes)(16);\n  }\n  const kdf = (_a = options === null || options === void 0 ? void 0 : options.kdf) !== null && _a !== void 0 ? _a : 'scrypt';\n  let derivedKey;\n  let kdfparams;\n  // derive key from key derivation function\n  if (kdf === 'pbkdf2') {\n    kdfparams = {\n      dklen: (_b = options === null || options === void 0 ? void 0 : options.dklen) !== null && _b !== void 0 ? _b : 32,\n      salt: (0, web3_utils_1.bytesToHex)(salt).replace('0x', ''),\n      c: (_c = options === null || options === void 0 ? void 0 : options.c) !== null && _c !== void 0 ? _c : 262144,\n      prf: 'hmac-sha256'\n    };\n    if (kdfparams.c < 1000) {\n      // error when c < 1000, pbkdf2 is less secure with less iterations\n      throw new web3_errors_1.PBKDF2IterationsError();\n    }\n    derivedKey = (0, pbkdf2_js_1.pbkdf2Sync)(uint8ArrayPassword, salt, kdfparams.c, kdfparams.dklen, 'sha256');\n  } else if (kdf === 'scrypt') {\n    kdfparams = {\n      n: (_d = options === null || options === void 0 ? void 0 : options.n) !== null && _d !== void 0 ? _d : 8192,\n      r: (_e = options === null || options === void 0 ? void 0 : options.r) !== null && _e !== void 0 ? _e : 8,\n      p: (_f = options === null || options === void 0 ? void 0 : options.p) !== null && _f !== void 0 ? _f : 1,\n      dklen: (_g = options === null || options === void 0 ? void 0 : options.dklen) !== null && _g !== void 0 ? _g : 32,\n      salt: (0, web3_utils_1.bytesToHex)(salt).replace('0x', '')\n    };\n    derivedKey = (0, scrypt_js_1.scryptSync)(uint8ArrayPassword, salt, kdfparams.n, kdfparams.p, kdfparams.r, kdfparams.dklen);\n  } else {\n    throw new web3_errors_1.InvalidKdfError();\n  }\n  const cipher = yield (0, aes_js_1.encrypt)(privateKeyUint8Array, derivedKey.slice(0, 16), initializationVector, 'aes-128-ctr');\n  const ciphertext = (0, web3_utils_1.bytesToHex)(cipher).slice(2);\n  const mac = (0, web3_utils_1.sha3Raw)((0, web3_utils_1.uint8ArrayConcat)(derivedKey.slice(16, 32), cipher)).replace('0x', '');\n  return {\n    version: 3,\n    id: (0, web3_utils_1.uuidV4)(),\n    address: (0, exports.privateKeyToAddress)(privateKeyUint8Array).toLowerCase().replace('0x', ''),\n    crypto: {\n      ciphertext,\n      cipherparams: {\n        iv: (0, web3_utils_1.bytesToHex)(initializationVector).replace('0x', '')\n      },\n      cipher: 'aes-128-ctr',\n      kdf,\n      kdfparams,\n      mac\n    }\n  };\n});\nexports.encrypt = encrypt;\n/**\n * Get an Account object from the privateKey\n *\n * @param privateKey - String or Uint8Array of 32 bytes\n * @param ignoreLength - if true, will not error check length\n * @returns A Web3Account object\n *\n * :::info\n * The `Web3Account.signTransaction` is not stateful if directly imported from accounts package and used. Network access is required to get the account `nonce` and `chainId` to sign the transaction, so use {@link Web3.eth.accounts.signTransaction} for signing transactions.\n * ::::\n *\n * ```ts\n * web3.eth.accounts.privateKeyToAccount(\"0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709\");\n *\n * >    {\n * \t\t\taddress: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01',\n * \t\t\tprivateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n * \t\t\tsign,\n * \t\t\tsignTransaction,\n * \t\t\tencrypt,\n * \t}\n * ```\n */\nconst privateKeyToAccount = (privateKey, ignoreLength) => {\n  const privateKeyUint8Array = (0, exports.parseAndValidatePrivateKey)(privateKey, ignoreLength);\n  return {\n    address: (0, exports.privateKeyToAddress)(privateKeyUint8Array),\n    privateKey: (0, web3_utils_1.bytesToHex)(privateKeyUint8Array),\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    signTransaction: _tx => {\n      throw new web3_errors_1.TransactionSigningError('Do not have network access to sign the transaction');\n    },\n    sign: data => (0, exports.sign)(typeof data === 'string' ? data : JSON.stringify(data), privateKeyUint8Array),\n    encrypt: (password, options) => __awaiter(void 0, void 0, void 0, function* () {\n      return (0, exports.encrypt)(privateKeyUint8Array, password, options);\n    })\n  };\n};\nexports.privateKeyToAccount = privateKeyToAccount;\n/**\n *\n * Generates and returns a Web3Account object that includes the private and public key\n * For creation of private key, it uses an audited package ethereum-cryptography/secp256k1\n * that is cryptographically secure random number with certain characteristics.\n * Read more: https://www.npmjs.com/package/ethereum-cryptography#secp256k1-curve\n *\n * @returns A Web3Account object\n * ```ts\n * web3.eth.accounts.create();\n * {\n * address: '0xbD504f977021b5E5DdccD8741A368b147B3B38bB',\n * privateKey: '0x964ced1c69ad27a311c432fdc0d8211e987595f7eb34ab405a5f16bdc9563ec5',\n * signTransaction: [Function: signTransaction],\n * sign: [Function: sign],\n * encrypt: [AsyncFunction: encrypt]\n * }\n * ```\n */\nconst create = () => {\n  const privateKey = constants_js_1.secp256k1.utils.randomPrivateKey();\n  return (0, exports.privateKeyToAccount)(\"\".concat((0, web3_utils_1.bytesToHex)(privateKey)));\n};\nexports.create = create;\n/**\n * Decrypts a v3 keystore JSON, and creates the account.\n *\n * @param keystore - the encrypted Keystore object or string to decrypt\n * @param password - The password that was used for encryption\n * @param nonStrict - if true and given a json string, the keystore will be parsed as lowercase.\n * @returns Returns the decrypted Web3Account object\n * Decrypting scrypt\n *\n * ```ts\n * web3.eth.accounts.decrypt({\n *   version: 3,\n *   id: 'c0cb0a94-4702-4492-b6e6-eb2ac404344a',\n *   address: 'cda9a91875fc35c8ac1320e098e584495d66e47c',\n *   crypto: {\n *   ciphertext: 'cb3e13e3281ff3861a3f0257fad4c9a51b0eb046f9c7821825c46b210f040b8f',\n *      cipherparams: { iv: 'bfb43120ae00e9de110f8325143a2709' },\n *      cipher: 'aes-128-ctr',\n *      kdf: 'scrypt',\n *      kdfparams: {\n *        n: 8192,\n *        r: 8,\n *        p: 1,\n *        dklen: 32,\n *        salt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd'\n *      },\n *      mac: 'efbf6d3409f37c0084a79d5fdf9a6f5d97d11447517ef1ea8374f51e581b7efd'\n *    }\n *   }, '123').then(console.log);\n *\n *\n * > {\n * address: '0xcdA9A91875fc35c8Ac1320E098e584495d66e47c',\n * privateKey: '67f476289210e3bef3c1c75e4de993ff0a00663df00def84e73aa7411eac18a6',\n * signTransaction: [Function: signTransaction],\n * sign: [Function: sign],\n * encrypt: [AsyncFunction: encrypt]\n * }\n * ```\n */\nconst decrypt = (keystore, password, nonStrict) => __awaiter(void 0, void 0, void 0, function* () {\n  const json = typeof keystore === 'object' ? keystore : JSON.parse(nonStrict ? keystore.toLowerCase() : keystore);\n  web3_validator_1.validator.validateJSONSchema(schemas_js_1.keyStoreSchema, json);\n  if (json.version !== 3) throw new web3_errors_1.KeyStoreVersionError();\n  const uint8ArrayPassword = typeof password === 'string' ? (0, web3_utils_1.hexToBytes)((0, web3_utils_1.utf8ToHex)(password)) : password;\n  web3_validator_1.validator.validate(['bytes'], [uint8ArrayPassword]);\n  let derivedKey;\n  if (json.crypto.kdf === 'scrypt') {\n    const kdfparams = json.crypto.kdfparams;\n    const uint8ArraySalt = typeof kdfparams.salt === 'string' ? (0, web3_utils_1.hexToBytes)(kdfparams.salt) : kdfparams.salt;\n    derivedKey = (0, scrypt_js_1.scryptSync)(uint8ArrayPassword, uint8ArraySalt, kdfparams.n, kdfparams.p, kdfparams.r, kdfparams.dklen);\n  } else if (json.crypto.kdf === 'pbkdf2') {\n    const kdfparams = json.crypto.kdfparams;\n    const uint8ArraySalt = typeof kdfparams.salt === 'string' ? (0, web3_utils_1.hexToBytes)(kdfparams.salt) : kdfparams.salt;\n    derivedKey = (0, pbkdf2_js_1.pbkdf2Sync)(uint8ArrayPassword, uint8ArraySalt, kdfparams.c, kdfparams.dklen, 'sha256');\n  } else {\n    throw new web3_errors_1.InvalidKdfError();\n  }\n  const ciphertext = (0, web3_utils_1.hexToBytes)(json.crypto.ciphertext);\n  const mac = (0, web3_utils_1.sha3Raw)((0, web3_utils_1.uint8ArrayConcat)(derivedKey.slice(16, 32), ciphertext)).replace('0x', '');\n  if (mac !== json.crypto.mac) {\n    throw new web3_errors_1.KeyDerivationError();\n  }\n  const seed = yield (0, aes_js_1.decrypt)((0, web3_utils_1.hexToBytes)(json.crypto.ciphertext), derivedKey.slice(0, 16), (0, web3_utils_1.hexToBytes)(json.crypto.cipherparams.iv));\n  return (0, exports.privateKeyToAccount)(seed);\n});\nexports.decrypt = decrypt;","map":{"version":3,"names":["aes_js_1","require","pbkdf2_js_1","scrypt_js_1","web3_errors_1","web3_utils_1","web3_validator_1","constants_js_1","schemas_js_1","transactionFactory_js_1","parseAndValidatePrivateKey","data","ignoreLength","privateKeyUint8Array","isHexStrict","length","PrivateKeyLengthError","isUint8Array","bytesToUint8Array","_a","InvalidPrivateKeyError","byteLength","exports","hashMessage","message","messageHex","utf8ToHex","messageBytes","hexToBytes","preamble","fromUtf8","concat","ethMessage","uint8ArrayConcat","sha3Raw","sign","privateKey","hash","signature","secp256k1","substring","signatureBytes","toCompactRawBytes","r","toString","padStart","s","v","recovery","messageHash","numberToHex","bytesToHex","signTransaction","transaction","__awaiter","signedTx","isNullish","TransactionSigningError","validationErrors","validate","errorString","validationError","rawTx","serialize","txHash","getMessageToSign","rawTransaction","transactionHash","recoverTransaction","UndefinedRawTransactionError","tx","TransactionFactory","fromSerializedData","toChecksumAddress","getSenderAddress","recover","signatureOrV","prefixedOrR","prefixed","signatureStr","slice","InvalidSignatureError","V_INDEX","hashedMessage","parseInt","ecPublicKey","Signature","fromCompact","addRecoveryBit","recoverPublicKey","replace","toRawBytes","publicHash","subarray","address","privateKeyToAddress","publicKey","getPublicKey","publicKeyHash","privateKeyToPublicKey","isCompressed","encrypt","password","options","salt","randomBytes","isString","InvalidPasswordError","uint8ArrayPassword","initializationVector","iv","IVLengthError","kdf","derivedKey","kdfparams","dklen","_b","c","_c","prf","PBKDF2IterationsError","pbkdf2Sync","n","_d","_e","p","_f","_g","scryptSync","InvalidKdfError","cipher","ciphertext","mac","version","id","uuidV4","toLowerCase","crypto","cipherparams","privateKeyToAccount","_tx","JSON","stringify","create","utils","randomPrivateKey","decrypt","keystore","nonStrict","json","parse","validator","validateJSONSchema","keyStoreSchema","KeyStoreVersionError","uint8ArraySalt","KeyDerivationError","seed"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/web3-eth-accounts/src/account.ts"],"sourcesContent":["﻿/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * The web3 accounts package contains functions to generate Ethereum accounts and sign transactions & data.\n * \n * For using accounts functions, first install Web3 package using `npm i web3` or `yarn add web3` based on your package manager usage.\n * After that, Accounts functions will be available as mentioned in following snippet. \n * ```ts\n * import {Web3} from 'web3';\n * \n * const web3 = new Web3();\n * const account = web3.eth.accounts.create();\n * const result = web3.eth.accounts.hashMessage(\"Test Message\");\n * \n * ```\n * \n * For using individual package install `web3-eth-accounts` package using `npm i web3-eth-accounts` or `yarn add web3-eth-accounts` and only import required functions.\n * This is more efficient approach for building lightweight applications. \n * ```ts\n * import {create,hashMessage} from 'web3-eth-accounts';\n * \n * const account = create();\n * const result = hashMessage(\"Test Message\");\n * \n * ```\n * @module Accounts\n * \n */\n\nimport {\n\tdecrypt as createDecipheriv,\n\tencrypt as createCipheriv,\n} from 'ethereum-cryptography/aes.js';\nimport { pbkdf2Sync } from 'ethereum-cryptography/pbkdf2.js';\nimport { scryptSync } from 'ethereum-cryptography/scrypt.js';\nimport {\n\tInvalidKdfError,\n\tInvalidPasswordError,\n\tInvalidPrivateKeyError,\n\tInvalidSignatureError,\n\tIVLengthError,\n\tKeyDerivationError,\n\tKeyStoreVersionError,\n\tPBKDF2IterationsError,\n\tPrivateKeyLengthError,\n\tTransactionSigningError,\n\tUndefinedRawTransactionError,\n} from 'web3-errors';\nimport {\n\tAddress,\n\tBytes,\n\tCipherOptions,\n\tHexString,\n\tKeyStore,\n\tPBKDF2SHA256Params,\n\tScryptParams,\n\tTransaction,\n} from 'web3-types';\nimport {\n\tbytesToUint8Array,\n\tbytesToHex,\n\tfromUtf8,\n\thexToBytes,\n\tisUint8Array,\n\tnumberToHex,\n\trandomBytes,\n\tsha3Raw,\n\ttoChecksumAddress,\n\tuint8ArrayConcat,\n\tutf8ToHex,\n\tuuidV4,\n} from 'web3-utils';\n\nimport { isHexStrict, isNullish, isString, validator } from 'web3-validator';\nimport { secp256k1 } from './tx/constants.js';\nimport { keyStoreSchema } from './schemas.js';\nimport { TransactionFactory } from './tx/transactionFactory.js';\nimport type {\n\tSignatureObject,\n\tSignTransactionResult,\n\tTypedTransaction,\n\tWeb3Account,\n\tSignResult,\n} from './types.js';\n\n\n/**\n * Get the private key Uint8Array after the validation.\n * Note: This function is not exported through main web3 package, so for using it directly import from accounts package. \n * @param data - Private key\n * @param ignoreLength - Optional, ignore length check during validation \n * @returns The Uint8Array private key\n *\n * ```ts\n * parseAndValidatePrivateKey(\"0x08c673022000ece7964ea4db2d9369c50442b2869cbd8fc21baaca59e18f642c\")\n * \n * > Uint8Array(32) [\n * 186,  26, 143, 168, 235, 179,  90,  75,\n * 101,  63,  84, 221, 152, 150,  30, 203,\n *   8, 113,  94, 226,  53, 213, 216,   5,\n * 194, 159,  17,  53, 219,  97, 121, 248\n * ]\n * \n * ```\n */\nexport const parseAndValidatePrivateKey = (data: Bytes, ignoreLength?: boolean): Uint8Array => {\n\tlet privateKeyUint8Array: Uint8Array;\n\n\t// To avoid the case of 1 character less in a hex string which is prefixed with '0' by using 'bytesToUint8Array'\n\tif (!ignoreLength && typeof data === 'string' && isHexStrict(data) && data.length !== 66) {\n\t\tthrow new PrivateKeyLengthError();\n\t}\n\n\ttry {\n\t\tprivateKeyUint8Array = isUint8Array(data) ? (data ) : bytesToUint8Array(data);\n\t} catch {\n\t\tthrow new InvalidPrivateKeyError();\n\t}\n\n\tif (!ignoreLength && privateKeyUint8Array.byteLength !== 32) {\n\t\tthrow new PrivateKeyLengthError();\n\t}\n\n\treturn privateKeyUint8Array;\n};\n\n/**\n *\n * Hashes the given message. The data will be `UTF-8 HEX` decoded and enveloped as follows:\n * `\"\\x19Ethereum Signed Message:\\n\" + message.length + message` and hashed using keccak256.\n *\n * @param message - A message to hash, if its HEX it will be UTF8 decoded.\n * @returns The hashed message\n *\n * ```ts\n * web3.eth.accounts.hashMessage(\"Hello world\")\n * \n * > \"0x8144a6fa26be252b86456491fbcd43c1de7e022241845ffea1c3df066f7cfede\"\n * \n * web3.eth.accounts.hashMessage(web3.utils.utf8ToHex(\"Hello world\")) // Will be hex decoded in hashMessage\n * \n * > \"0x8144a6fa26be252b86456491fbcd43c1de7e022241845ffea1c3df066f7cfede\"\n * ```\n */\nexport const hashMessage = (message: string): string => {\n\tconst messageHex = isHexStrict(message) ? message : utf8ToHex(message);\n\n\tconst messageBytes = hexToBytes(messageHex);\n\n\tconst preamble = hexToBytes(\n\t\tfromUtf8(`\\x19Ethereum Signed Message:\\n${messageBytes.byteLength}`),\n\t);\n\n\tconst ethMessage = uint8ArrayConcat(preamble, messageBytes);\n\n\treturn sha3Raw(ethMessage); // using keccak in web3-utils.sha3Raw instead of SHA3 (NIST Standard) as both are different\n};\n\n/**\n * Signs arbitrary data with a given private key.\n * :::info\n * The value passed as the data parameter will be UTF-8 HEX decoded and wrapped as follows: \"\\\\x19Ethereum Signed Message:\\\\n\" + message.length + message\n * :::\n\n * @param data - The data to sign\n * @param privateKey - The 32 byte private key to sign with\n * @returns The signature Object containing the message, messageHash, signature r, s, v\n *\n * ```ts\n * web3.eth.accounts.sign('Some data', '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318')\n * > {\n * message: 'Some data',\n * messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\n * v: '0x1c',\n * r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd',\n * s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029',\n * signature: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c'\n * }\n * ```\n */\nexport const sign = (data: string, privateKey: Bytes): SignResult => {\n\tconst privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);\n\n\tconst hash = hashMessage(data);\n\n\tconst signature = secp256k1.sign(hash.substring(2), privateKeyUint8Array);\n\tconst signatureBytes = signature.toCompactRawBytes();\n\tconst r = signature.r.toString(16).padStart(64, '0');\n\tconst s = signature.s.toString(16).padStart(64, '0');\n\tconst v = signature.recovery! + 27;\n\n\treturn {\n\t\tmessage: data,\n\t\tmessageHash: hash,\n\t\tv: numberToHex(v),\n\t\tr: `0x${r}`,\n\t\ts: `0x${s}`,\n\t\tsignature: `${bytesToHex(signatureBytes)}${v.toString(16)}`,\n\t};\n};\n\n/**\n * Signs an Ethereum transaction with a given private key.\n *\n * @param transaction - The transaction, must be a legacy, EIP2930 or EIP 1559 transaction type\n * @param privateKey -  The private key to import. This is 32 bytes of random data.\n * @returns A signTransactionResult object that contains message hash, r, s, v, transaction hash and raw transaction.\n *\n * This function is not stateful here. We need network access to get the account `nonce` and `chainId` to sign the transaction.\n * This function will rely on user to provide the full transaction to be signed. If you want to sign a partial transaction object\n * Use {@link Web3.eth.accounts.sign} instead.\n *\n * Signing a legacy transaction\n * ```ts\n * import {signTransaction, Transaction} from 'web3-eth-accounts';\n * \n * signTransaction(new Transaction({\n *\tto: '0x118C2E5F57FD62C2B5b46a5ae9216F4FF4011a07',\n *\tvalue: '0x186A0',\n *\tgasLimit: '0x520812',\n *\tgasPrice: '0x09184e72a000',\n *\tdata: '',\n *\tchainId: 1,\n *\tnonce: 0 }),\n * '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318')\n * \n * > {\n * messageHash: '0x28b7b75f7ba48d588a902c1ff4d5d13cc0ca9ac0aaa39562368146923fb853bf',\n * v: '0x25',\n * r: '0x601b0017b0e20dd0eeda4b895fbc1a9e8968990953482214f880bae593e71b5',\n * s: '0x690d984493560552e3ebdcc19a65b9c301ea9ddc82d3ab8cfde60485fd5722ce',\n * rawTransaction: '0xf869808609184e72a0008352081294118c2e5f57fd62c2b5b46a5ae9216f4ff4011a07830186a08025a00601b0017b0e20dd0eeda4b895fbc1a9e8968990953482214f880bae593e71b5a0690d984493560552e3ebdcc19a65b9c301ea9ddc82d3ab8cfde60485fd5722ce',\n * transactionHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\n * ```\n * \n * Signing an eip 1559 transaction\n * ```ts\n * import {signTransaction, Transaction} from 'web3-eth-accounts';\n * \n * signTransaction(new Transaction({\n *\tto: '0xF0109fC8DF283027b6285cc889F5aA624EaC1F55',\n *\tmaxPriorityFeePerGas: '0x3B9ACA00',\n *\tmaxFeePerGas: '0xB2D05E00',\n *\tgasLimit: '0x6A4012',\n *\tvalue: '0x186A0',\n *\tdata: '',\n *\tchainId: 1,\n *\tnonce: 0}),\n * \"0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318\")\n * > {\n *  messageHash: '0x5744f24d5f0aff6c70487c8e85adf07d8564e50b08558788f00479611d7bae5f',\n * v: '0x25',\n * r: '0x78a5a6b2876c3985f90f82073d18d57ac299b608cc76a4ba697b8bb085048347',\n * s: '0x9cfcb40cc7d505ed17ff2d3337b51b066648f10c6b7e746117de69b2eb6358d',\n * rawTransaction: '0xf8638080836a401294f0109fc8df283027b6285cc889f5aa624eac1f55830186a08025a078a5a6b2876c3985f90f82073d18d57ac299b608cc76a4ba697b8bb085048347a009cfcb40cc7d505ed17ff2d3337b51b066648f10c6b7e746117de69b2eb6358d',\n * transactionHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\n * }\n * ```\n * \n * Signing an eip 2930 transaction\n * ```ts\n * import {signTransaction, Transaction} from 'web3-eth-accounts';\n * \n * signTransaction(new Transaction ({\n *\tchainId: 1,\n *\tnonce: 0,\n *\tgasPrice: '0x09184e72a000',\n *\tgasLimit: '0x2710321',\n *\tto: '0xF0109fC8DF283027b6285cc889F5aA624EaC1F55',\n *\tvalue: '0x186A0',\n *\tdata: '',\n *\taccessList: [\n *\t\t{\n *\t\t\taddress: '0x0000000000000000000000000000000000000101',\n *\t\t\tstorageKeys: [\n *\t\t\t\t'0x0000000000000000000000000000000000000000000000000000000000000000',\n *\t\t\t\t'0x00000000000000000000000000000000000000000000000000000000000060a7',\n *\t\t\t],\n *\t\t},\n *\t],\n * }),\"0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318\")\n * \n * > {\n * messageHash: '0xc55ea24bdb4c379550a7c9a6818ac39ca33e75bc78ddb862bd82c31cc1c7a073',\n * v: '0x26',\n * r: '0x27344e77871c8b2068bc998bf28e0b5f9920867a69c455b2ed0c1c150fec098e',\n * s: '0x519f0130a1d662841d4a28082e9c9bb0a15e0e59bb46cfc39a52f0e285dec6b9',\n * rawTransaction: '0xf86a808609184e72a000840271032194f0109fc8df283027b6285cc889f5aa624eac1f55830186a08026a027344e77871c8b2068bc998bf28e0b5f9920867a69c455b2ed0c1c150fec098ea0519f0130a1d662841d4a28082e9c9bb0a15e0e59bb46cfc39a52f0e285dec6b9',\n * transactionHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\n * }\n * ```\n */\nexport const signTransaction = async (\n\ttransaction: TypedTransaction,\n\tprivateKey: HexString,\n\t// To make it compatible with rest of the API, have to keep it async\n\t// eslint-disable-next-line @typescript-eslint/require-await\n): Promise<SignTransactionResult> => {\n\tconst signedTx = transaction.sign(hexToBytes(privateKey));\n\tif (isNullish(signedTx.v) || isNullish(signedTx.r) || isNullish(signedTx.s))\n\t\tthrow new TransactionSigningError('Signer Error');\n\n\tconst validationErrors = signedTx.validate(true);\n\n\tif (validationErrors.length > 0) {\n\t\tlet errorString = 'Signer Error ';\n\t\tfor (const validationError of validationErrors) {\n\t\t\terrorString += `${errorString} ${validationError}.`;\n\t\t}\n\t\tthrow new TransactionSigningError(errorString);\n\t}\n\n\tconst rawTx = bytesToHex(signedTx.serialize());\n\tconst txHash = sha3Raw(rawTx); // using keccak in web3-utils.sha3Raw instead of SHA3 (NIST Standard) as both are different\n\n\treturn {\n\t\tmessageHash: bytesToHex(signedTx.getMessageToSign(true)),\n\t\tv: `0x${signedTx.v.toString(16)}`,\n\t\tr: `0x${signedTx.r.toString(16).padStart(64, '0')}`,\n\t\ts: `0x${signedTx.s.toString(16).padStart(64, '0')}`,\n\t\trawTransaction: rawTx,\n\t\ttransactionHash: bytesToHex(txHash),\n\t};\n};\n\n/**\n * Recovers the Ethereum address which was used to sign the given RLP encoded transaction.\n *\n * @param rawTransaction - The hex string having RLP encoded transaction\n * @returns The Ethereum address used to sign this transaction\n * ```ts\n * web3.eth.accounts.recoverTransaction('0xf869808504e3b29200831e848094f0109fc8df283027b6285cc889f5aa624eac1f55843b9aca008025a0c9cf86333bcb065d140032ecaab5d9281bde80f21b9687b3e94161de42d51895a0727a108a0b8d101465414033c3f705a9c7b826e596766046ee1183dbc8aeaa68');\n * > \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\"\n * ```\n */\nexport const recoverTransaction = (rawTransaction: HexString): Address => {\n\tif (isNullish(rawTransaction)) throw new UndefinedRawTransactionError();\n\n\tconst tx = TransactionFactory.fromSerializedData(hexToBytes(rawTransaction));\n\n\treturn toChecksumAddress(tx.getSenderAddress().toString());\n};\n\n/**\n * Recovers the Ethereum address which was used to sign the given data\n *\n * @param data - Either a signed message, hash, or the {@link signatureObject}\n * @param signature - The raw RLP encoded signature\n * @param signatureOrV - signature or V\n * @param prefixedOrR - prefixed or R\n * @param s - S value in signature\n * @param prefixed - (default: false) If the last parameter is true, the given message will NOT automatically be prefixed with `\"\\\\x19Ethereum Signed Message:\\\\n\" + message.length + message`, and assumed to be already prefixed.\n * @returns The Ethereum address used to sign this data\n * \n * ```ts\n * const data = 'Some data';\n * const sigObj = web3.eth.accounts.sign(data, '0xbe6383dad004f233317e46ddb46ad31b16064d14447a95cc1d8c8d4bc61c3728')\n * \n * > {\n *   message: 'Some data',\n *   messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\n *   v: '0x1b',\n *   r: '0xa8037a6116c176a25e6fc224947fde9e79a2deaa0dd8b67b366fbdfdbffc01f9',\n *   s: '0x53e41351267b20d4a89ebfe9c8f03c04de9b345add4a52f15bd026b63c8fb150',\n *   signature: '0xa8037a6116c176a25e6fc224947fde9e79a2deaa0dd8b67b366fbdfdbffc01f953e41351267b20d4a89ebfe9c8f03c04de9b345add4a52f15bd026b63c8fb1501b'\n * }\n * \n * // now recover\n * web3.eth.accounts.recover(data, sigObj.v, sigObj.r, sigObj.s)\n * \n * > 0xEB014f8c8B418Db6b45774c326A0E64C78914dC0\n * ```\n */\nexport const recover = (\n\tdata: string | SignatureObject,\n\tsignatureOrV?: string,\n\tprefixedOrR?: boolean | string,\n\ts?: string,\n\tprefixed?: boolean,\n): Address => {\n\tif (typeof data === 'object') {\n\t\tconst signatureStr = `${data.r}${data.s.slice(2)}${data.v.slice(2)}`;\n\t\treturn recover(data.messageHash, signatureStr, prefixedOrR);\n\t}\n\tif (typeof signatureOrV === 'string' && typeof prefixedOrR === 'string' && !isNullish(s)) {\n\t\tconst signatureStr = `${prefixedOrR}${s.slice(2)}${signatureOrV.slice(2)}`;\n\t\treturn recover(data, signatureStr, prefixed);\n\t}\n\n\tif (isNullish(signatureOrV)) throw new InvalidSignatureError('signature string undefined');\n\n\tconst V_INDEX = 130; // r = first 32 bytes, s = second 32 bytes, v = last byte of signature\n\tconst hashedMessage = prefixedOrR ? data : hashMessage(data);\n\n\tlet v = parseInt(signatureOrV.substring(V_INDEX), 16); // 0x + r + s + v\n\tif (v > 26) {\n\t\tv -= 27;\n\t}\n\n\tconst ecPublicKey = secp256k1.Signature.fromCompact(signatureOrV.slice(2, V_INDEX))\n\t\t.addRecoveryBit(v)\n\t\t.recoverPublicKey(hashedMessage.replace('0x', ''))\n\t\t.toRawBytes(false);\n\n\tconst publicHash = sha3Raw(ecPublicKey.subarray(1));\n\n\tconst address = toChecksumAddress(`0x${publicHash.slice(-40)}`);\n\n\treturn address;\n};;\n\n/**\n * Get the ethereum Address from a private key\n *\n * @param privateKey - String or Uint8Array of 32 bytes\n * @param ignoreLength - if true, will not error check length\n * @returns The Ethereum address\n * @example\n * ```ts\n * web3.eth.accounts.privateKeyToAddress(\"0xbe6383dad004f233317e46ddb46ad31b16064d14447a95cc1d8c8d4bc61c3728\")\n * \n * > \"0xEB014f8c8B418Db6b45774c326A0E64C78914dC0\"\n * ```\n */\nexport const privateKeyToAddress = (privateKey: Bytes): string => {\n\tconst privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);\n\n\t// Get public key from private key in compressed format\n\tconst publicKey = secp256k1.getPublicKey(privateKeyUint8Array, false);\n\n\t// Uncompressed ECDSA public key contains the prefix `0x04` which is not used in the Ethereum public key\n\tconst publicKeyHash = sha3Raw(publicKey.slice(1));\n\n\t// The hash is returned as 256 bits (32 bytes) or 64 hex characters\n\t// To get the address, take the last 20 bytes of the public hash\n\tconst address = publicKeyHash.slice(-40);\n\n\treturn toChecksumAddress(`0x${address}`);\n};\n\n/**\n * Get the public key from a private key\n *\n * @param privateKey - String or Uint8Array of 32 bytes\n * @param isCompressed - if true, will generate a 33 byte compressed public key instead of a 65 byte public key\n * @returns The public key\n * @example\n * ```ts\n * web3.eth.accounts.privateKeyToPublicKey(\"0x1e046a882bb38236b646c9f135cf90ad90a140810f439875f2a6dd8e50fa261f\", true)\n * \n * > \"0x42beb65f179720abaa3ec9a70a539629cbbc5ec65bb57e7fc78977796837e537662dd17042e6449dc843c281067a4d6d8d1a1775a13c41901670d5de7ee6503a\" // uncompressed public key\n * ```\n */\nexport const privateKeyToPublicKey = (privateKey: Bytes, isCompressed: boolean): string => {\n\tconst privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);\n\n\t// Get public key from private key in compressed format\n\treturn `0x${bytesToHex(secp256k1.getPublicKey(privateKeyUint8Array, isCompressed)).slice(4)}`; // 0x and removing compression byte\n};\n\n/**\n * encrypt a private key with a password, returns a V3 JSON Keystore\n *\n * Read more: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n *\n * @param privateKey - The private key to encrypt, 32 bytes.\n * @param password - The password used for encryption.\n * @param options - Options to configure to encrypt the keystore either scrypt or pbkdf2\n * @returns Returns a V3 JSON Keystore\n *\n * Encrypt using scrypt options:\n * ```ts\n * \n * web3.eth.accounts.encrypt(\n *    '0x67f476289210e3bef3c1c75e4de993ff0a00663df00def84e73aa7411eac18a6',\n *    '123',\n *    {\n *        n: 8192,\n *\t    iv: web3.utils.hexToBytes('0xbfb43120ae00e9de110f8325143a2709'),\n *\t    salt: web3.utils.hexToBytes('0x210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd'),\n *\t}).then(console.log)\n *\n * > {\n * version: 3,\n * id: 'c0cb0a94-4702-4492-b6e6-eb2ac404344a',\n * address: 'cda9a91875fc35c8ac1320e098e584495d66e47c',\n * crypto: {\n *   ciphertext: 'cb3e13e3281ff3861a3f0257fad4c9a51b0eb046f9c7821825c46b210f040b8f',\n *   cipherparams: { iv: 'bfb43120ae00e9de110f8325143a2709' },\n *   cipher: 'aes-128-ctr',\n *   kdf: 'scrypt',\n *   kdfparams: {\n *     n: 8192,\n *     r: 8,\n *     p: 1,\n *     dklen: 32,\n *     salt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd'\n *   },\n *   mac: 'efbf6d3409f37c0084a79d5fdf9a6f5d97d11447517ef1ea8374f51e581b7efd'\n * }\n *}\n *```\n *\n * Encrypting using pbkdf2 options:\n * ```ts\n * web3.eth.accounts.encrypt('0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n *'123',\n *{\n *\tiv: 'bfb43120ae00e9de110f8325143a2709',\n *\tsalt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd',\n *\tc: 262144,\n *\tkdf: 'pbkdf2',\n *}).then(console.log)\n *\n * >\n * {\n *   version: 3,\n *   id: '77381417-0973-4e4b-b590-8eb3ace0fe2d',\n *   address: 'b8ce9ab6943e0eced004cde8e3bbed6568b2fa01',\n *   crypto: {\n *     ciphertext: '76512156a34105fa6473ad040c666ae7b917d14c06543accc0d2dc28e6073b12',\n *     cipherparams: { iv: 'bfb43120ae00e9de110f8325143a2709' },\n *     cipher: 'aes-128-ctr',\n *     kdf: 'pbkdf2',\n *     kdfparams: {\n *       dklen: 32,\n *       salt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd',\n *       c: 262144,\n *       prf: 'hmac-sha256'\n *     },\n *   mac: '46eb4884e82dc43b5aa415faba53cc653b7038e9d61cc32fd643cf8c396189b7'\n *   }\n * }\n *```\n */\nexport const encrypt = async (\n\tprivateKey: Bytes,\n\tpassword: string | Uint8Array,\n\toptions?: CipherOptions,\n): Promise<KeyStore> => {\n\tconst privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);\n\n\t// if given salt or iv is a string, convert it to a Uint8Array\n\tlet salt;\n\tif (options?.salt) {\n\t\tsalt = typeof options.salt === 'string' ? hexToBytes(options.salt) : options.salt;\n\t} else {\n\t\tsalt = randomBytes(32);\n\t}\n\n\tif (!(isString(password) || isUint8Array(password))) {\n\t\tthrow new InvalidPasswordError();\n\t}\n\n\tconst uint8ArrayPassword =\n\t\ttypeof password === 'string' ? hexToBytes(utf8ToHex(password)) : password;\n\n\tlet initializationVector;\n\tif (options?.iv) {\n\t\tinitializationVector = typeof options.iv === 'string' ? hexToBytes(options.iv) : options.iv;\n\t\tif (initializationVector.length !== 16) {\n\t\t\tthrow new IVLengthError();\n\t\t}\n\t} else {\n\t\tinitializationVector = randomBytes(16);\n\t}\n\n\tconst kdf = options?.kdf ?? 'scrypt';\n\n\tlet derivedKey;\n\tlet kdfparams: ScryptParams | PBKDF2SHA256Params;\n\n\t// derive key from key derivation function\n\tif (kdf === 'pbkdf2') {\n\t\tkdfparams = {\n\t\t\tdklen: options?.dklen ?? 32,\n\t\t\tsalt: bytesToHex(salt).replace('0x', ''),\n\t\t\tc: options?.c ?? 262144,\n\t\t\tprf: 'hmac-sha256',\n\t\t};\n\n\t\tif (kdfparams.c < 1000) {\n\t\t\t// error when c < 1000, pbkdf2 is less secure with less iterations\n\t\t\tthrow new PBKDF2IterationsError();\n\t\t}\n\t\tderivedKey = pbkdf2Sync(uint8ArrayPassword, salt, kdfparams.c, kdfparams.dklen, 'sha256');\n\t} else if (kdf === 'scrypt') {\n\t\tkdfparams = {\n\t\t\tn: options?.n ?? 8192,\n\t\t\tr: options?.r ?? 8,\n\t\t\tp: options?.p ?? 1,\n\t\t\tdklen: options?.dklen ?? 32,\n\t\t\tsalt: bytesToHex(salt).replace('0x', ''),\n\t\t};\n\t\tderivedKey = scryptSync(\n\t\t\tuint8ArrayPassword,\n\t\t\tsalt,\n\t\t\tkdfparams.n,\n\t\t\tkdfparams.p,\n\t\t\tkdfparams.r,\n\t\t\tkdfparams.dklen,\n\t\t);\n\t} else {\n\t\tthrow new InvalidKdfError();\n\t}\n\n\tconst cipher = await createCipheriv(\n\t\tprivateKeyUint8Array,\n\t\tderivedKey.slice(0, 16),\n\t\tinitializationVector,\n\t\t'aes-128-ctr',\n\t);\n\n\tconst ciphertext = bytesToHex(cipher).slice(2);\n\n\tconst mac = sha3Raw(uint8ArrayConcat(derivedKey.slice(16, 32), cipher)).replace('0x', '');\n\treturn {\n\t\tversion: 3,\n\t\tid: uuidV4(),\n\t\taddress: privateKeyToAddress(privateKeyUint8Array).toLowerCase().replace('0x', ''),\n\t\tcrypto: {\n\t\t\tciphertext,\n\t\t\tcipherparams: {\n\t\t\t\tiv: bytesToHex(initializationVector).replace('0x', ''),\n\t\t\t},\n\t\t\tcipher: 'aes-128-ctr',\n\t\t\tkdf,\n\t\t\tkdfparams,\n\t\t\tmac,\n\t\t},\n\t};\n};\n\n/**\n * Get an Account object from the privateKey\n *\n * @param privateKey - String or Uint8Array of 32 bytes\n * @param ignoreLength - if true, will not error check length\n * @returns A Web3Account object\n *\n * :::info\n * The `Web3Account.signTransaction` is not stateful if directly imported from accounts package and used. Network access is required to get the account `nonce` and `chainId` to sign the transaction, so use {@link Web3.eth.accounts.signTransaction} for signing transactions.\n * ::::\n *\n * ```ts\n * web3.eth.accounts.privateKeyToAccount(\"0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709\");\n * \n * >    {\n * \t\t\taddress: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01',\n * \t\t\tprivateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n * \t\t\tsign,\n * \t\t\tsignTransaction,\n * \t\t\tencrypt,\n * \t}\n * ```\n */\nexport const privateKeyToAccount = (privateKey: Bytes, ignoreLength?: boolean): Web3Account => {\n\tconst privateKeyUint8Array = parseAndValidatePrivateKey(privateKey, ignoreLength);\n\n\treturn {\n\t\taddress: privateKeyToAddress(privateKeyUint8Array),\n\t\tprivateKey: bytesToHex(privateKeyUint8Array),\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\tsignTransaction: (_tx: Transaction) => {\n\t\t\tthrow new TransactionSigningError('Do not have network access to sign the transaction');\n\t\t},\n\t\tsign: (data: Record<string, unknown> | string) =>\n\t\t\tsign(typeof data === 'string' ? data : JSON.stringify(data), privateKeyUint8Array),\n\t\tencrypt: async (password: string, options?: Record<string, unknown>) =>\n\t\t\tencrypt(privateKeyUint8Array, password, options),\n\t};\n};\n\n/**\n *\n * Generates and returns a Web3Account object that includes the private and public key\n * For creation of private key, it uses an audited package ethereum-cryptography/secp256k1\n * that is cryptographically secure random number with certain characteristics.\n * Read more: https://www.npmjs.com/package/ethereum-cryptography#secp256k1-curve\n *\n * @returns A Web3Account object\n * ```ts\n * web3.eth.accounts.create();\n * {\n * address: '0xbD504f977021b5E5DdccD8741A368b147B3B38bB',\n * privateKey: '0x964ced1c69ad27a311c432fdc0d8211e987595f7eb34ab405a5f16bdc9563ec5',\n * signTransaction: [Function: signTransaction],\n * sign: [Function: sign],\n * encrypt: [AsyncFunction: encrypt]\n * }\n * ```\n */\nexport const create = (): Web3Account => {\n\tconst privateKey = secp256k1.utils.randomPrivateKey();\n\n\treturn privateKeyToAccount(`${bytesToHex(privateKey)}`);\n};\n\n/**\n * Decrypts a v3 keystore JSON, and creates the account.\n *\n * @param keystore - the encrypted Keystore object or string to decrypt\n * @param password - The password that was used for encryption\n * @param nonStrict - if true and given a json string, the keystore will be parsed as lowercase.\n * @returns Returns the decrypted Web3Account object\n * Decrypting scrypt\n *\n * ```ts\n * web3.eth.accounts.decrypt({\n *   version: 3,\n *   id: 'c0cb0a94-4702-4492-b6e6-eb2ac404344a',\n *   address: 'cda9a91875fc35c8ac1320e098e584495d66e47c',\n *   crypto: {\n *   ciphertext: 'cb3e13e3281ff3861a3f0257fad4c9a51b0eb046f9c7821825c46b210f040b8f',\n *      cipherparams: { iv: 'bfb43120ae00e9de110f8325143a2709' },\n *      cipher: 'aes-128-ctr',\n *      kdf: 'scrypt',\n *      kdfparams: {\n *        n: 8192,\n *        r: 8,\n *        p: 1,\n *        dklen: 32,\n *        salt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd'\n *      },\n *      mac: 'efbf6d3409f37c0084a79d5fdf9a6f5d97d11447517ef1ea8374f51e581b7efd'\n *    }\n *   }, '123').then(console.log);\n * \n * \n * > {\n * address: '0xcdA9A91875fc35c8Ac1320E098e584495d66e47c',\n * privateKey: '67f476289210e3bef3c1c75e4de993ff0a00663df00def84e73aa7411eac18a6',\n * signTransaction: [Function: signTransaction],\n * sign: [Function: sign],\n * encrypt: [AsyncFunction: encrypt]\n * }\n * ```\n */\nexport const decrypt = async (\n\tkeystore: KeyStore | string,\n\tpassword: string | Uint8Array,\n\tnonStrict?: boolean,\n): Promise<Web3Account> => {\n\tconst json =\n\t\ttypeof keystore === 'object'\n\t\t\t? keystore\n\t\t\t: (JSON.parse(nonStrict ? keystore.toLowerCase() : keystore) as KeyStore);\n\n\tvalidator.validateJSONSchema(keyStoreSchema, json);\n\n\tif (json.version !== 3) throw new KeyStoreVersionError();\n\n\tconst uint8ArrayPassword =\n\t\ttypeof password === 'string' ? hexToBytes(utf8ToHex(password)) : password;\n\n\tvalidator.validate(['bytes'], [uint8ArrayPassword]);\n\n\tlet derivedKey;\n\tif (json.crypto.kdf === 'scrypt') {\n\t\tconst kdfparams = json.crypto.kdfparams as ScryptParams;\n\t\tconst uint8ArraySalt =\n\t\t\ttypeof kdfparams.salt === 'string' ? hexToBytes(kdfparams.salt) : kdfparams.salt;\n\t\tderivedKey = scryptSync(\n\t\t\tuint8ArrayPassword,\n\t\t\tuint8ArraySalt,\n\t\t\tkdfparams.n,\n\t\t\tkdfparams.p,\n\t\t\tkdfparams.r,\n\t\t\tkdfparams.dklen,\n\t\t);\n\t} else if (json.crypto.kdf === 'pbkdf2') {\n\t\tconst kdfparams: PBKDF2SHA256Params = json.crypto.kdfparams as PBKDF2SHA256Params;\n\n\t\tconst uint8ArraySalt =\n\t\t\ttypeof kdfparams.salt === 'string' ? hexToBytes(kdfparams.salt) : kdfparams.salt;\n\n\t\tderivedKey = pbkdf2Sync(\n\t\t\tuint8ArrayPassword,\n\t\t\tuint8ArraySalt,\n\t\t\tkdfparams.c,\n\t\t\tkdfparams.dklen,\n\t\t\t'sha256',\n\t\t);\n\t} else {\n\t\tthrow new InvalidKdfError();\n\t}\n\n\tconst ciphertext = hexToBytes(json.crypto.ciphertext);\n\tconst mac = sha3Raw(uint8ArrayConcat(derivedKey.slice(16, 32), ciphertext)).replace('0x', '');\n\n\tif (mac !== json.crypto.mac) {\n\t\tthrow new KeyDerivationError();\n\t}\n\n\tconst seed = await createDecipheriv(\n\t\thexToBytes(json.crypto.ciphertext),\n\t\tderivedKey.slice(0, 16),\n\t\thexToBytes(json.crypto.cipherparams.iv),\n\t);\n\n\treturn privateKeyToAccount(seed);\n};\n"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,MAAAA,QAAA,GAAAC,OAAA;AAIA,MAAAC,WAAA,GAAAD,OAAA;AACA,MAAAE,WAAA,GAAAF,OAAA;AACA,MAAAG,aAAA,GAAAH,OAAA;AAuBA,MAAAI,YAAA,GAAAJ,OAAA;AAeA,MAAAK,gBAAA,GAAAL,OAAA;AACA,MAAAM,cAAA,GAAAN,OAAA;AACA,MAAAO,YAAA,GAAAP,OAAA;AACA,MAAAQ,uBAAA,GAAAR,OAAA;AAUA;;;;;;;;;;;;;;;;;;;AAmBO,MAAMS,0BAA0B,GAAGA,CAACC,IAAW,EAAEC,YAAsB,KAAgB;EAC7F,IAAIC,oBAAgC;EAEpC;EACA,IAAI,CAACD,YAAY,IAAI,OAAOD,IAAI,KAAK,QAAQ,IAAI,IAAAL,gBAAA,CAAAQ,WAAW,EAACH,IAAI,CAAC,IAAIA,IAAI,CAACI,MAAM,KAAK,EAAE,EAAE;IACzF,MAAM,IAAIX,aAAA,CAAAY,qBAAqB,EAAE;;EAGlC,IAAI;IACHH,oBAAoB,GAAG,IAAAR,YAAA,CAAAY,YAAY,EAACN,IAAI,CAAC,GAAIA,IAAI,GAAK,IAAAN,YAAA,CAAAa,iBAAiB,EAACP,IAAI,CAAC;GAC7E,CAAC,OAAAQ,EAAA,EAAM;IACP,MAAM,IAAIf,aAAA,CAAAgB,sBAAsB,EAAE;;EAGnC,IAAI,CAACR,YAAY,IAAIC,oBAAoB,CAACQ,UAAU,KAAK,EAAE,EAAE;IAC5D,MAAM,IAAIjB,aAAA,CAAAY,qBAAqB,EAAE;;EAGlC,OAAOH,oBAAoB;AAC5B,CAAC;AAnBYS,OAAA,CAAAZ,0BAA0B,GAAAA,0BAAA;AAqBvC;;;;;;;;;;;;;;;;;;AAkBO,MAAMa,WAAW,GAAIC,OAAe,IAAY;EACtD,MAAMC,UAAU,GAAG,IAAAnB,gBAAA,CAAAQ,WAAW,EAACU,OAAO,CAAC,GAAGA,OAAO,GAAG,IAAAnB,YAAA,CAAAqB,SAAS,EAACF,OAAO,CAAC;EAEtE,MAAMG,YAAY,GAAG,IAAAtB,YAAA,CAAAuB,UAAU,EAACH,UAAU,CAAC;EAE3C,MAAMI,QAAQ,GAAG,IAAAxB,YAAA,CAAAuB,UAAU,EAC1B,IAAAvB,YAAA,CAAAyB,QAAQ,mCAAAC,MAAA,CAAkCJ,YAAY,CAACN,UAAU,CAAE,CAAC,CACpE;EAED,MAAMW,UAAU,GAAG,IAAA3B,YAAA,CAAA4B,gBAAgB,EAACJ,QAAQ,EAAEF,YAAY,CAAC;EAE3D,OAAO,IAAAtB,YAAA,CAAA6B,OAAO,EAACF,UAAU,CAAC,CAAC,CAAC;AAC7B,CAAC;AAZYV,OAAA,CAAAC,WAAW,GAAAA,WAAA;AAcxB;;;;;;;;;;;;;;;;;;;;;;AAsBO,MAAMY,IAAI,GAAGA,CAACxB,IAAY,EAAEyB,UAAiB,KAAgB;EACnE,MAAMvB,oBAAoB,GAAG,IAAAS,OAAA,CAAAZ,0BAA0B,EAAC0B,UAAU,CAAC;EAEnE,MAAMC,IAAI,GAAG,IAAAf,OAAA,CAAAC,WAAW,EAACZ,IAAI,CAAC;EAE9B,MAAM2B,SAAS,GAAG/B,cAAA,CAAAgC,SAAS,CAACJ,IAAI,CAACE,IAAI,CAACG,SAAS,CAAC,CAAC,CAAC,EAAE3B,oBAAoB,CAAC;EACzE,MAAM4B,cAAc,GAAGH,SAAS,CAACI,iBAAiB,EAAE;EACpD,MAAMC,CAAC,GAAGL,SAAS,CAACK,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC;EACpD,MAAMC,CAAC,GAAGR,SAAS,CAACQ,CAAC,CAACF,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC;EACpD,MAAME,CAAC,GAAGT,SAAS,CAACU,QAAS,GAAG,EAAE;EAElC,OAAO;IACNxB,OAAO,EAAEb,IAAI;IACbsC,WAAW,EAAEZ,IAAI;IACjBU,CAAC,EAAE,IAAA1C,YAAA,CAAA6C,WAAW,EAACH,CAAC,CAAC;IACjBJ,CAAC,OAAAZ,MAAA,CAAOY,CAAC,CAAE;IACXG,CAAC,OAAAf,MAAA,CAAOe,CAAC,CAAE;IACXR,SAAS,KAAAP,MAAA,CAAK,IAAA1B,YAAA,CAAA8C,UAAU,EAACV,cAAc,CAAC,EAAAV,MAAA,CAAGgB,CAAC,CAACH,QAAQ,CAAC,EAAE,CAAC;GACzD;AACF,CAAC;AAnBYtB,OAAA,CAAAa,IAAI,GAAAA,IAAA;AAqBjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2FO,MAAMiB,eAAe,GAAGA,CAC9BC,WAA6B,EAC7BjB,UAAqB,KAGckB,SAAA;EACnC,MAAMC,QAAQ,GAAGF,WAAW,CAAClB,IAAI,CAAC,IAAA9B,YAAA,CAAAuB,UAAU,EAACQ,UAAU,CAAC,CAAC;EACzD,IAAI,IAAA9B,gBAAA,CAAAkD,SAAS,EAACD,QAAQ,CAACR,CAAC,CAAC,IAAI,IAAAzC,gBAAA,CAAAkD,SAAS,EAACD,QAAQ,CAACZ,CAAC,CAAC,IAAI,IAAArC,gBAAA,CAAAkD,SAAS,EAACD,QAAQ,CAACT,CAAC,CAAC,EAC1E,MAAM,IAAI1C,aAAA,CAAAqD,uBAAuB,CAAC,cAAc,CAAC;EAElD,MAAMC,gBAAgB,GAAGH,QAAQ,CAACI,QAAQ,CAAC,IAAI,CAAC;EAEhD,IAAID,gBAAgB,CAAC3C,MAAM,GAAG,CAAC,EAAE;IAChC,IAAI6C,WAAW,GAAG,eAAe;IACjC,KAAK,MAAMC,eAAe,IAAIH,gBAAgB,EAAE;MAC/CE,WAAW,OAAA7B,MAAA,CAAO6B,WAAW,OAAA7B,MAAA,CAAI8B,eAAe,MAAG;;IAEpD,MAAM,IAAIzD,aAAA,CAAAqD,uBAAuB,CAACG,WAAW,CAAC;;EAG/C,MAAME,KAAK,GAAG,IAAAzD,YAAA,CAAA8C,UAAU,EAACI,QAAQ,CAACQ,SAAS,EAAE,CAAC;EAC9C,MAAMC,MAAM,GAAG,IAAA3D,YAAA,CAAA6B,OAAO,EAAC4B,KAAK,CAAC,CAAC,CAAC;EAE/B,OAAO;IACNb,WAAW,EAAE,IAAA5C,YAAA,CAAA8C,UAAU,EAACI,QAAQ,CAACU,gBAAgB,CAAC,IAAI,CAAC,CAAC;IACxDlB,CAAC,OAAAhB,MAAA,CAAOwB,QAAQ,CAACR,CAAC,CAACH,QAAQ,CAAC,EAAE,CAAC,CAAE;IACjCD,CAAC,OAAAZ,MAAA,CAAOwB,QAAQ,CAACZ,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC,CAAE;IACnDC,CAAC,OAAAf,MAAA,CAAOwB,QAAQ,CAACT,CAAC,CAACF,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC,CAAE;IACnDqB,cAAc,EAAEJ,KAAK;IACrBK,eAAe,EAAE,IAAA9D,YAAA,CAAA8C,UAAU,EAACa,MAAM;GAClC;AACF,CAAC;AA/BY1C,OAAA,CAAA8B,eAAe,GAAAA,eAAA;AAiC5B;;;;;;;;;;AAUO,MAAMgB,kBAAkB,GAAIF,cAAyB,IAAa;EACxE,IAAI,IAAA5D,gBAAA,CAAAkD,SAAS,EAACU,cAAc,CAAC,EAAE,MAAM,IAAI9D,aAAA,CAAAiE,4BAA4B,EAAE;EAEvE,MAAMC,EAAE,GAAG7D,uBAAA,CAAA8D,kBAAkB,CAACC,kBAAkB,CAAC,IAAAnE,YAAA,CAAAuB,UAAU,EAACsC,cAAc,CAAC,CAAC;EAE5E,OAAO,IAAA7D,YAAA,CAAAoE,iBAAiB,EAACH,EAAE,CAACI,gBAAgB,EAAE,CAAC9B,QAAQ,EAAE,CAAC;AAC3D,CAAC;AANYtB,OAAA,CAAA8C,kBAAkB,GAAAA,kBAAA;AAQ/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BO,MAAMO,OAAO,GAAGA,CACtBhE,IAA8B,EAC9BiE,YAAqB,EACrBC,WAA8B,EAC9B/B,CAAU,EACVgC,QAAkB,KACN;EACZ,IAAI,OAAOnE,IAAI,KAAK,QAAQ,EAAE;IAC7B,MAAMoE,YAAY,MAAAhD,MAAA,CAAMpB,IAAI,CAACgC,CAAC,EAAAZ,MAAA,CAAGpB,IAAI,CAACmC,CAAC,CAACkC,KAAK,CAAC,CAAC,CAAC,EAAAjD,MAAA,CAAGpB,IAAI,CAACoC,CAAC,CAACiC,KAAK,CAAC,CAAC,CAAC,CAAE;IACpE,OAAO,IAAA1D,OAAA,CAAAqD,OAAO,EAAChE,IAAI,CAACsC,WAAW,EAAE8B,YAAY,EAAEF,WAAW,CAAC;;EAE5D,IAAI,OAAOD,YAAY,KAAK,QAAQ,IAAI,OAAOC,WAAW,KAAK,QAAQ,IAAI,CAAC,IAAAvE,gBAAA,CAAAkD,SAAS,EAACV,CAAC,CAAC,EAAE;IACzF,MAAMiC,YAAY,MAAAhD,MAAA,CAAM8C,WAAW,EAAA9C,MAAA,CAAGe,CAAC,CAACkC,KAAK,CAAC,CAAC,CAAC,EAAAjD,MAAA,CAAG6C,YAAY,CAACI,KAAK,CAAC,CAAC,CAAC,CAAE;IAC1E,OAAO,IAAA1D,OAAA,CAAAqD,OAAO,EAAChE,IAAI,EAAEoE,YAAY,EAAED,QAAQ,CAAC;;EAG7C,IAAI,IAAAxE,gBAAA,CAAAkD,SAAS,EAACoB,YAAY,CAAC,EAAE,MAAM,IAAIxE,aAAA,CAAA6E,qBAAqB,CAAC,4BAA4B,CAAC;EAE1F,MAAMC,OAAO,GAAG,GAAG,CAAC,CAAC;EACrB,MAAMC,aAAa,GAAGN,WAAW,GAAGlE,IAAI,GAAG,IAAAW,OAAA,CAAAC,WAAW,EAACZ,IAAI,CAAC;EAE5D,IAAIoC,CAAC,GAAGqC,QAAQ,CAACR,YAAY,CAACpC,SAAS,CAAC0C,OAAO,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;EACvD,IAAInC,CAAC,GAAG,EAAE,EAAE;IACXA,CAAC,IAAI,EAAE;;EAGR,MAAMsC,WAAW,GAAG9E,cAAA,CAAAgC,SAAS,CAAC+C,SAAS,CAACC,WAAW,CAACX,YAAY,CAACI,KAAK,CAAC,CAAC,EAAEE,OAAO,CAAC,CAAC,CACjFM,cAAc,CAACzC,CAAC,CAAC,CACjB0C,gBAAgB,CAACN,aAAa,CAACO,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,CACjDC,UAAU,CAAC,KAAK,CAAC;EAEnB,MAAMC,UAAU,GAAG,IAAAvF,YAAA,CAAA6B,OAAO,EAACmD,WAAW,CAACQ,QAAQ,CAAC,CAAC,CAAC,CAAC;EAEnD,MAAMC,OAAO,GAAG,IAAAzF,YAAA,CAAAoE,iBAAiB,OAAA1C,MAAA,CAAM6D,UAAU,CAACZ,KAAK,CAAC,CAAC,EAAE,CAAC,CAAE,CAAC;EAE/D,OAAOc,OAAO;AACf,CAAC;AApCYxE,OAAA,CAAAqD,OAAO,GAAAA,OAAA;AAoClB;AAEF;;;;;;;;;;;;;AAaO,MAAMoB,mBAAmB,GAAI3D,UAAiB,IAAY;EAChE,MAAMvB,oBAAoB,GAAG,IAAAS,OAAA,CAAAZ,0BAA0B,EAAC0B,UAAU,CAAC;EAEnE;EACA,MAAM4D,SAAS,GAAGzF,cAAA,CAAAgC,SAAS,CAAC0D,YAAY,CAACpF,oBAAoB,EAAE,KAAK,CAAC;EAErE;EACA,MAAMqF,aAAa,GAAG,IAAA7F,YAAA,CAAA6B,OAAO,EAAC8D,SAAS,CAAChB,KAAK,CAAC,CAAC,CAAC,CAAC;EAEjD;EACA;EACA,MAAMc,OAAO,GAAGI,aAAa,CAAClB,KAAK,CAAC,CAAC,EAAE,CAAC;EAExC,OAAO,IAAA3E,YAAA,CAAAoE,iBAAiB,OAAA1C,MAAA,CAAM+D,OAAO,CAAE,CAAC;AACzC,CAAC;AAdYxE,OAAA,CAAAyE,mBAAmB,GAAAA,mBAAA;AAgBhC;;;;;;;;;;;;;AAaO,MAAMI,qBAAqB,GAAGA,CAAC/D,UAAiB,EAAEgE,YAAqB,KAAY;EACzF,MAAMvF,oBAAoB,GAAG,IAAAS,OAAA,CAAAZ,0BAA0B,EAAC0B,UAAU,CAAC;EAEnE;EACA,YAAAL,MAAA,CAAY,IAAA1B,YAAA,CAAA8C,UAAU,EAAC5C,cAAA,CAAAgC,SAAS,CAAC0D,YAAY,CAACpF,oBAAoB,EAAEuF,YAAY,CAAC,CAAC,CAACpB,KAAK,CAAC,CAAC,CAAC,EAAG,CAAC;AAChG,CAAC;AALY1D,OAAA,CAAA6E,qBAAqB,GAAAA,qBAAA;AAOlC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2EO,MAAME,OAAO,GAAGA,CACtBjE,UAAiB,EACjBkE,QAA6B,EAC7BC,OAAuB,KACDjD,SAAA;;EACtB,MAAMzC,oBAAoB,GAAG,IAAAS,OAAA,CAAAZ,0BAA0B,EAAC0B,UAAU,CAAC;EAEnE;EACA,IAAIoE,IAAI;EACR,IAAID,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEC,IAAI,EAAE;IAClBA,IAAI,GAAG,OAAOD,OAAO,CAACC,IAAI,KAAK,QAAQ,GAAG,IAAAnG,YAAA,CAAAuB,UAAU,EAAC2E,OAAO,CAACC,IAAI,CAAC,GAAGD,OAAO,CAACC,IAAI;GACjF,MAAM;IACNA,IAAI,GAAG,IAAAnG,YAAA,CAAAoG,WAAW,EAAC,EAAE,CAAC;;EAGvB,IAAI,EAAE,IAAAnG,gBAAA,CAAAoG,QAAQ,EAACJ,QAAQ,CAAC,IAAI,IAAAjG,YAAA,CAAAY,YAAY,EAACqF,QAAQ,CAAC,CAAC,EAAE;IACpD,MAAM,IAAIlG,aAAA,CAAAuG,oBAAoB,EAAE;;EAGjC,MAAMC,kBAAkB,GACvB,OAAON,QAAQ,KAAK,QAAQ,GAAG,IAAAjG,YAAA,CAAAuB,UAAU,EAAC,IAAAvB,YAAA,CAAAqB,SAAS,EAAC4E,QAAQ,CAAC,CAAC,GAAGA,QAAQ;EAE1E,IAAIO,oBAAoB;EACxB,IAAIN,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEO,EAAE,EAAE;IAChBD,oBAAoB,GAAG,OAAON,OAAO,CAACO,EAAE,KAAK,QAAQ,GAAG,IAAAzG,YAAA,CAAAuB,UAAU,EAAC2E,OAAO,CAACO,EAAE,CAAC,GAAGP,OAAO,CAACO,EAAE;IAC3F,IAAID,oBAAoB,CAAC9F,MAAM,KAAK,EAAE,EAAE;MACvC,MAAM,IAAIX,aAAA,CAAA2G,aAAa,EAAE;;GAE1B,MAAM;IACNF,oBAAoB,GAAG,IAAAxG,YAAA,CAAAoG,WAAW,EAAC,EAAE,CAAC;;EAGvC,MAAMO,GAAG,GAAG,CAAA7F,EAAA,GAAAoF,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAES,GAAG,cAAA7F,EAAA,cAAAA,EAAA,GAAI,QAAQ;EAEpC,IAAI8F,UAAU;EACd,IAAIC,SAA4C;EAEhD;EACA,IAAIF,GAAG,KAAK,QAAQ,EAAE;IACrBE,SAAS,GAAG;MACXC,KAAK,EAAE,CAAAC,EAAA,GAAAb,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEY,KAAK,cAAAC,EAAA,cAAAA,EAAA,GAAI,EAAE;MAC3BZ,IAAI,EAAE,IAAAnG,YAAA,CAAA8C,UAAU,EAACqD,IAAI,CAAC,CAACd,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;MACxC2B,CAAC,EAAE,CAAAC,EAAA,GAAAf,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEc,CAAC,cAAAC,EAAA,cAAAA,EAAA,GAAI,MAAM;MACvBC,GAAG,EAAE;KACL;IAED,IAAIL,SAAS,CAACG,CAAC,GAAG,IAAI,EAAE;MACvB;MACA,MAAM,IAAIjH,aAAA,CAAAoH,qBAAqB,EAAE;;IAElCP,UAAU,GAAG,IAAA/G,WAAA,CAAAuH,UAAU,EAACb,kBAAkB,EAAEJ,IAAI,EAAEU,SAAS,CAACG,CAAC,EAAEH,SAAS,CAACC,KAAK,EAAE,QAAQ,CAAC;GACzF,MAAM,IAAIH,GAAG,KAAK,QAAQ,EAAE;IAC5BE,SAAS,GAAG;MACXQ,CAAC,EAAE,CAAAC,EAAA,GAAApB,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEmB,CAAC,cAAAC,EAAA,cAAAA,EAAA,GAAI,IAAI;MACrBhF,CAAC,EAAE,CAAAiF,EAAA,GAAArB,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE5D,CAAC,cAAAiF,EAAA,cAAAA,EAAA,GAAI,CAAC;MAClBC,CAAC,EAAE,CAAAC,EAAA,GAAAvB,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEsB,CAAC,cAAAC,EAAA,cAAAA,EAAA,GAAI,CAAC;MAClBX,KAAK,EAAE,CAAAY,EAAA,GAAAxB,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEY,KAAK,cAAAY,EAAA,cAAAA,EAAA,GAAI,EAAE;MAC3BvB,IAAI,EAAE,IAAAnG,YAAA,CAAA8C,UAAU,EAACqD,IAAI,CAAC,CAACd,OAAO,CAAC,IAAI,EAAE,EAAE;KACvC;IACDuB,UAAU,GAAG,IAAA9G,WAAA,CAAA6H,UAAU,EACtBpB,kBAAkB,EAClBJ,IAAI,EACJU,SAAS,CAACQ,CAAC,EACXR,SAAS,CAACW,CAAC,EACXX,SAAS,CAACvE,CAAC,EACXuE,SAAS,CAACC,KAAK,CACf;GACD,MAAM;IACN,MAAM,IAAI/G,aAAA,CAAA6H,eAAe,EAAE;;EAG5B,MAAMC,MAAM,GAAG,MAAM,IAAAlI,QAAA,CAAAqG,OAAc,EAClCxF,oBAAoB,EACpBoG,UAAU,CAACjC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,EACvB6B,oBAAoB,EACpB,aAAa,CACb;EAED,MAAMsB,UAAU,GAAG,IAAA9H,YAAA,CAAA8C,UAAU,EAAC+E,MAAM,CAAC,CAAClD,KAAK,CAAC,CAAC,CAAC;EAE9C,MAAMoD,GAAG,GAAG,IAAA/H,YAAA,CAAA6B,OAAO,EAAC,IAAA7B,YAAA,CAAA4B,gBAAgB,EAACgF,UAAU,CAACjC,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC,EAAEkD,MAAM,CAAC,CAAC,CAACxC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;EACzF,OAAO;IACN2C,OAAO,EAAE,CAAC;IACVC,EAAE,EAAE,IAAAjI,YAAA,CAAAkI,MAAM,GAAE;IACZzC,OAAO,EAAE,IAAAxE,OAAA,CAAAyE,mBAAmB,EAAClF,oBAAoB,CAAC,CAAC2H,WAAW,EAAE,CAAC9C,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;IAClF+C,MAAM,EAAE;MACPN,UAAU;MACVO,YAAY,EAAE;QACb5B,EAAE,EAAE,IAAAzG,YAAA,CAAA8C,UAAU,EAAC0D,oBAAoB,CAAC,CAACnB,OAAO,CAAC,IAAI,EAAE,EAAE;OACrD;MACDwC,MAAM,EAAE,aAAa;MACrBlB,GAAG;MACHE,SAAS;MACTkB;;GAED;AACF,CAAC;AAhGY9G,OAAA,CAAA+E,OAAO,GAAAA,OAAA;AAkGpB;;;;;;;;;;;;;;;;;;;;;;;AAuBO,MAAMsC,mBAAmB,GAAGA,CAACvG,UAAiB,EAAExB,YAAsB,KAAiB;EAC7F,MAAMC,oBAAoB,GAAG,IAAAS,OAAA,CAAAZ,0BAA0B,EAAC0B,UAAU,EAAExB,YAAY,CAAC;EAEjF,OAAO;IACNkF,OAAO,EAAE,IAAAxE,OAAA,CAAAyE,mBAAmB,EAAClF,oBAAoB,CAAC;IAClDuB,UAAU,EAAE,IAAA/B,YAAA,CAAA8C,UAAU,EAACtC,oBAAoB,CAAC;IAC5C;IACAuC,eAAe,EAAGwF,GAAgB,IAAI;MACrC,MAAM,IAAIxI,aAAA,CAAAqD,uBAAuB,CAAC,oDAAoD,CAAC;IACxF,CAAC;IACDtB,IAAI,EAAGxB,IAAsC,IAC5C,IAAAW,OAAA,CAAAa,IAAI,EAAC,OAAOxB,IAAI,KAAK,QAAQ,GAAGA,IAAI,GAAGkI,IAAI,CAACC,SAAS,CAACnI,IAAI,CAAC,EAAEE,oBAAoB,CAAC;IACnFwF,OAAO,EAAEA,CAAOC,QAAgB,EAAEC,OAAiC,KAAIjD,SAAA;MACtE,WAAAhC,OAAA,CAAA+E,OAAO,EAACxF,oBAAoB,EAAEyF,QAAQ,EAAEC,OAAO,CAAC;IAAA;GACjD;AACF,CAAC;AAfYjF,OAAA,CAAAqH,mBAAmB,GAAAA,mBAAA;AAiBhC;;;;;;;;;;;;;;;;;;;AAmBO,MAAMI,MAAM,GAAGA,CAAA,KAAkB;EACvC,MAAM3G,UAAU,GAAG7B,cAAA,CAAAgC,SAAS,CAACyG,KAAK,CAACC,gBAAgB,EAAE;EAErD,OAAO,IAAA3H,OAAA,CAAAqH,mBAAmB,KAAA5G,MAAA,CAAI,IAAA1B,YAAA,CAAA8C,UAAU,EAACf,UAAU,CAAC,CAAE,CAAC;AACxD,CAAC;AAJYd,OAAA,CAAAyH,MAAM,GAAAA,MAAA;AAMnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwCO,MAAMG,OAAO,GAAGA,CACtBC,QAA2B,EAC3B7C,QAA6B,EAC7B8C,SAAmB,KACM9F,SAAA;EACzB,MAAM+F,IAAI,GACT,OAAOF,QAAQ,KAAK,QAAQ,GACzBA,QAAQ,GACPN,IAAI,CAACS,KAAK,CAACF,SAAS,GAAGD,QAAQ,CAACX,WAAW,EAAE,GAAGW,QAAQ,CAAc;EAE3E7I,gBAAA,CAAAiJ,SAAS,CAACC,kBAAkB,CAAChJ,YAAA,CAAAiJ,cAAc,EAAEJ,IAAI,CAAC;EAElD,IAAIA,IAAI,CAAChB,OAAO,KAAK,CAAC,EAAE,MAAM,IAAIjI,aAAA,CAAAsJ,oBAAoB,EAAE;EAExD,MAAM9C,kBAAkB,GACvB,OAAON,QAAQ,KAAK,QAAQ,GAAG,IAAAjG,YAAA,CAAAuB,UAAU,EAAC,IAAAvB,YAAA,CAAAqB,SAAS,EAAC4E,QAAQ,CAAC,CAAC,GAAGA,QAAQ;EAE1EhG,gBAAA,CAAAiJ,SAAS,CAAC5F,QAAQ,CAAC,CAAC,OAAO,CAAC,EAAE,CAACiD,kBAAkB,CAAC,CAAC;EAEnD,IAAIK,UAAU;EACd,IAAIoC,IAAI,CAACZ,MAAM,CAACzB,GAAG,KAAK,QAAQ,EAAE;IACjC,MAAME,SAAS,GAAGmC,IAAI,CAACZ,MAAM,CAACvB,SAAyB;IACvD,MAAMyC,cAAc,GACnB,OAAOzC,SAAS,CAACV,IAAI,KAAK,QAAQ,GAAG,IAAAnG,YAAA,CAAAuB,UAAU,EAACsF,SAAS,CAACV,IAAI,CAAC,GAAGU,SAAS,CAACV,IAAI;IACjFS,UAAU,GAAG,IAAA9G,WAAA,CAAA6H,UAAU,EACtBpB,kBAAkB,EAClB+C,cAAc,EACdzC,SAAS,CAACQ,CAAC,EACXR,SAAS,CAACW,CAAC,EACXX,SAAS,CAACvE,CAAC,EACXuE,SAAS,CAACC,KAAK,CACf;GACD,MAAM,IAAIkC,IAAI,CAACZ,MAAM,CAACzB,GAAG,KAAK,QAAQ,EAAE;IACxC,MAAME,SAAS,GAAuBmC,IAAI,CAACZ,MAAM,CAACvB,SAA+B;IAEjF,MAAMyC,cAAc,GACnB,OAAOzC,SAAS,CAACV,IAAI,KAAK,QAAQ,GAAG,IAAAnG,YAAA,CAAAuB,UAAU,EAACsF,SAAS,CAACV,IAAI,CAAC,GAAGU,SAAS,CAACV,IAAI;IAEjFS,UAAU,GAAG,IAAA/G,WAAA,CAAAuH,UAAU,EACtBb,kBAAkB,EAClB+C,cAAc,EACdzC,SAAS,CAACG,CAAC,EACXH,SAAS,CAACC,KAAK,EACf,QAAQ,CACR;GACD,MAAM;IACN,MAAM,IAAI/G,aAAA,CAAA6H,eAAe,EAAE;;EAG5B,MAAME,UAAU,GAAG,IAAA9H,YAAA,CAAAuB,UAAU,EAACyH,IAAI,CAACZ,MAAM,CAACN,UAAU,CAAC;EACrD,MAAMC,GAAG,GAAG,IAAA/H,YAAA,CAAA6B,OAAO,EAAC,IAAA7B,YAAA,CAAA4B,gBAAgB,EAACgF,UAAU,CAACjC,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC,EAAEmD,UAAU,CAAC,CAAC,CAACzC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;EAE7F,IAAI0C,GAAG,KAAKiB,IAAI,CAACZ,MAAM,CAACL,GAAG,EAAE;IAC5B,MAAM,IAAIhI,aAAA,CAAAwJ,kBAAkB,EAAE;;EAG/B,MAAMC,IAAI,GAAG,MAAM,IAAA7J,QAAA,CAAAkJ,OAAgB,EAClC,IAAA7I,YAAA,CAAAuB,UAAU,EAACyH,IAAI,CAACZ,MAAM,CAACN,UAAU,CAAC,EAClClB,UAAU,CAACjC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,EACvB,IAAA3E,YAAA,CAAAuB,UAAU,EAACyH,IAAI,CAACZ,MAAM,CAACC,YAAY,CAAC5B,EAAE,CAAC,CACvC;EAED,OAAO,IAAAxF,OAAA,CAAAqH,mBAAmB,EAACkB,IAAI,CAAC;AACjC,CAAC;AA/DYvI,OAAA,CAAA4H,OAAO,GAAAA,OAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}