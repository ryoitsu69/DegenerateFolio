{"ast":null,"code":"import { BehaviorSubject, combineLatest, from, map, of, switchMap, tap, toArray } from 'rxjs';\nimport { getAvailableDerives } from '@polkadot/api-derive';\nimport { memo, RpcCore } from '@polkadot/rpc-core';\nimport { WsProvider } from '@polkadot/rpc-provider';\nimport { expandMetadata, GenericExtrinsic, typeDefinitions, TypeRegistry } from '@polkadot/types';\nimport { getSpecRuntime } from '@polkadot/types-known';\nimport { arrayChunk, arrayFlatten, assertReturn, BN, compactStripLength, lazyMethod, lazyMethods, logger, nextTick, objectSpread, stringCamelCase, stringUpperFirst, u8aConcatStrict, u8aToHex } from '@polkadot/util';\nimport { blake2AsHex } from '@polkadot/util-crypto';\nimport { createSubmittable } from '../submittable/index.js';\nimport { augmentObject } from '../util/augmentObject.js';\nimport { decorateDeriveSections } from '../util/decorate.js';\nimport { extractStorageArgs } from '../util/validate.js';\nimport { Events } from './Events.js';\nimport { findCall, findError } from './find.js';\nconst PAGE_SIZE_K = 1000; // limit aligned with the 1k on the node (trie lookups are heavy)\nconst PAGE_SIZE_V = 250; // limited since the data may be > 16MB (e.g. misfiring elections)\nconst PAGE_SIZE_Q = 50; // queue of pending storage queries (mapped together, next tick)\nconst l = logger('api/init');\nlet instanceCounter = 0;\nfunction getAtQueryFn(api, {\n  method,\n  section\n}) {\n  return assertReturn(api.rx.query[section] && api.rx.query[section][method], () => `query.${section}.${method} is not available in this version of the metadata`);\n}\nexport class Decorate extends Events {\n  __internal__instanceId;\n  __internal__runtimeLog = {};\n  __internal__registry;\n  __internal__storageGetQ = [];\n  __internal__storageSubQ = [];\n  // HACK Use BN import so decorateDerive works... yes, wtf.\n  __phantom = new BN(0);\n  _type;\n  _call = {};\n  _consts = {};\n  _derive;\n  _errors = {};\n  _events = {};\n  _extrinsics;\n  _extrinsicType = GenericExtrinsic.LATEST_EXTRINSIC_VERSION;\n  _genesisHash;\n  _isConnected;\n  _isReady = false;\n  _query = {};\n  _queryMulti;\n  _rpc;\n  _rpcCore;\n  _runtimeMap = {};\n  _runtimeChain;\n  _runtimeMetadata;\n  _runtimeVersion;\n  _rx = {\n    call: {},\n    consts: {},\n    query: {},\n    tx: {}\n  };\n  _options;\n  /**\n   * This is the one and only method concrete children classes need to implement.\n   * It's a higher-order function, which takes one argument\n   * `method: Method extends (...args: any[]) => Observable<any>`\n   * (and one optional `options`), and should return the user facing method.\n   * For example:\n   * - For ApiRx, `decorateMethod` should just be identity, because the input\n   * function is already an Observable\n   * - For ApiPromise, `decorateMethod` should return a function that takes all\n   * the parameters from `method`, adds an optional `callback` argument, and\n   * returns a Promise.\n   *\n   * We could easily imagine other user-facing interfaces, which are simply\n   * implemented by transforming the Observable to Stream/Iterator/Kefir/Bacon\n   * via `decorateMethod`.\n   */\n  _decorateMethod;\n  /**\n   * @description Create an instance of the class\n   *\n   * @param options Options object to create API instance or a Provider instance\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * import Api from '@polkadot/api/promise';\n   *\n   * const api = new Api().isReady();\n   *\n   * api.rpc.subscribeNewHeads((header) => {\n   *   console.log(`new block #${header.number.toNumber()}`);\n   * });\n   * ```\n   */\n  constructor(options, type, decorateMethod) {\n    super();\n    this.__internal__instanceId = `${++instanceCounter}`;\n    this.__internal__registry = options.source?.registry || options.registry || new TypeRegistry();\n    this._rx.callAt = (blockHash, knownVersion) => from(this.at(blockHash, knownVersion)).pipe(map(a => a.rx.call));\n    this._rx.queryAt = (blockHash, knownVersion) => from(this.at(blockHash, knownVersion)).pipe(map(a => a.rx.query));\n    this._rx.registry = this.__internal__registry;\n    this._decorateMethod = decorateMethod;\n    this._options = options;\n    this._type = type;\n    const provider = options.source ? options.source._rpcCore.provider.isClonable ? options.source._rpcCore.provider.clone() : options.source._rpcCore.provider : options.provider || new WsProvider();\n    // The RPC interface decorates the known interfaces on init\n    this._rpcCore = new RpcCore(this.__internal__instanceId, this.__internal__registry, {\n      isPedantic: this._options.isPedantic,\n      provider,\n      userRpc: this._options.rpc\n    });\n    this._isConnected = new BehaviorSubject(this._rpcCore.provider.isConnected);\n    this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;\n  }\n  /**\n   * @description Return the current used registry\n   */\n  get registry() {\n    return this.__internal__registry;\n  }\n  /**\n   * @description Creates an instance of a type as registered\n   */\n  createType(type, ...params) {\n    return this.__internal__registry.createType(type, ...params);\n  }\n  /**\n   * @description Register additional user-defined of chain-specific types in the type registry\n   */\n  registerTypes(types) {\n    types && this.__internal__registry.register(types);\n  }\n  /**\n   * @returns `true` if the API operates with subscriptions\n   */\n  get hasSubscriptions() {\n    return this._rpcCore.provider.hasSubscriptions;\n  }\n  /**\n   * @returns `true` if the API decorate multi-key queries\n   */\n  get supportMulti() {\n    return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;\n  }\n  _emptyDecorated(registry, blockHash) {\n    return {\n      call: {},\n      consts: {},\n      errors: {},\n      events: {},\n      query: {},\n      registry,\n      rx: {\n        call: {},\n        query: {}\n      },\n      tx: createSubmittable(this._type, this._rx, this._decorateMethod, registry, blockHash)\n    };\n  }\n  _createDecorated(registry, fromEmpty, decoratedApi, blockHash) {\n    if (!decoratedApi) {\n      decoratedApi = this._emptyDecorated(registry.registry, blockHash);\n    }\n    if (fromEmpty || !registry.decoratedMeta) {\n      registry.decoratedMeta = expandMetadata(registry.registry, registry.metadata);\n    }\n    const runtime = this._decorateCalls(registry, this._decorateMethod, blockHash);\n    const runtimeRx = this._decorateCalls(registry, this._rxDecorateMethod, blockHash);\n    const storage = this._decorateStorage(registry.decoratedMeta, this._decorateMethod, blockHash);\n    const storageRx = this._decorateStorage(registry.decoratedMeta, this._rxDecorateMethod, blockHash);\n    augmentObject('consts', registry.decoratedMeta.consts, decoratedApi.consts, fromEmpty);\n    augmentObject('errors', registry.decoratedMeta.errors, decoratedApi.errors, fromEmpty);\n    augmentObject('events', registry.decoratedMeta.events, decoratedApi.events, fromEmpty);\n    augmentObject('query', storage, decoratedApi.query, fromEmpty);\n    augmentObject('query', storageRx, decoratedApi.rx.query, fromEmpty);\n    augmentObject('call', runtime, decoratedApi.call, fromEmpty);\n    augmentObject('call', runtimeRx, decoratedApi.rx.call, fromEmpty);\n    decoratedApi.findCall = callIndex => findCall(registry.registry, callIndex);\n    decoratedApi.findError = errorIndex => findError(registry.registry, errorIndex);\n    decoratedApi.queryMulti = blockHash ? this._decorateMultiAt(decoratedApi, this._decorateMethod, blockHash) : this._decorateMulti(this._decorateMethod);\n    decoratedApi.runtimeVersion = registry.runtimeVersion;\n    return {\n      createdAt: blockHash,\n      decoratedApi,\n      decoratedMeta: registry.decoratedMeta\n    };\n  }\n  _injectMetadata(registry, fromEmpty = false) {\n    // clear the decoration, we are redoing it here\n    if (fromEmpty || !registry.decoratedApi) {\n      registry.decoratedApi = this._emptyDecorated(registry.registry);\n    }\n    const {\n      decoratedApi,\n      decoratedMeta\n    } = this._createDecorated(registry, fromEmpty, registry.decoratedApi);\n    this._call = decoratedApi.call;\n    this._consts = decoratedApi.consts;\n    this._errors = decoratedApi.errors;\n    this._events = decoratedApi.events;\n    this._query = decoratedApi.query;\n    this._rx.call = decoratedApi.rx.call;\n    this._rx.query = decoratedApi.rx.query;\n    const tx = this._decorateExtrinsics(decoratedMeta, this._decorateMethod);\n    const rxtx = this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod);\n    if (fromEmpty || !this._extrinsics) {\n      this._extrinsics = tx;\n      this._rx.tx = rxtx;\n    } else {\n      augmentObject('tx', tx, this._extrinsics, false);\n      augmentObject(null, rxtx, this._rx.tx, false);\n    }\n    augmentObject(null, decoratedMeta.consts, this._rx.consts, fromEmpty);\n    this.emit('decorated');\n  }\n  /**\n   * @deprecated\n   * backwards compatible endpoint for metadata injection, may be removed in the future (However, it is still useful for testing injection)\n   */\n  injectMetadata(metadata, fromEmpty, registry) {\n    this._injectMetadata({\n      counter: 0,\n      metadata,\n      registry: registry || this.__internal__registry,\n      runtimeVersion: this.__internal__registry.createType('RuntimeVersionPartial')\n    }, fromEmpty);\n  }\n  _decorateFunctionMeta(input, output) {\n    output.meta = input.meta;\n    output.method = input.method;\n    output.section = input.section;\n    output.toJSON = input.toJSON;\n    if (input.callIndex) {\n      output.callIndex = input.callIndex;\n    }\n    return output;\n  }\n  // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following\n  // manner to cater for both old and new:\n  //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)\n  //   - when non-zero, remove anything that is not in the array (we don't do this)\n  _filterRpc(methods, additional) {\n    // add any specific user-base RPCs\n    if (Object.keys(additional).length !== 0) {\n      this._rpcCore.addUserInterfaces(additional);\n      // re-decorate, only adding any new additional interfaces\n      this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc);\n      this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc);\n    }\n    // extract the actual sections from the methods (this is useful when\n    // we try and create mappings to runtime names via a hash mapping)\n    const sectionMap = {};\n    for (let i = 0, count = methods.length; i < count; i++) {\n      const [section] = methods[i].split('_');\n      sectionMap[section] = true;\n    }\n    // convert the actual section names into an easy name lookup\n    const sections = Object.keys(sectionMap);\n    for (let i = 0, count = sections.length; i < count; i++) {\n      const nameA = stringUpperFirst(sections[i]);\n      const nameB = `${nameA}Api`;\n      this._runtimeMap[blake2AsHex(nameA, 64)] = nameA;\n      this._runtimeMap[blake2AsHex(nameB, 64)] = nameB;\n    }\n    // finally we filter the actual methods to expose\n    this._filterRpcMethods(methods);\n  }\n  _filterRpcMethods(exposed) {\n    const hasResults = exposed.length !== 0;\n    const allKnown = [...this._rpcCore.mapping.entries()];\n    const allKeys = [];\n    const count = allKnown.length;\n    for (let i = 0; i < count; i++) {\n      const [, {\n        alias,\n        endpoint,\n        method,\n        pubsub,\n        section\n      }] = allKnown[i];\n      allKeys.push(`${section}_${method}`);\n      if (pubsub) {\n        allKeys.push(`${section}_${pubsub[1]}`);\n        allKeys.push(`${section}_${pubsub[2]}`);\n      }\n      if (alias) {\n        allKeys.push(...alias);\n      }\n      if (endpoint) {\n        allKeys.push(endpoint);\n      }\n    }\n    const unknown = exposed.filter(k => !allKeys.includes(k) && !k.includes('_unstable_'));\n    if (unknown.length && !this._options.noInitWarn) {\n      l.warn(`RPC methods not decorated: ${unknown.join(', ')}`);\n    }\n    // loop through all entries we have (populated in decorate) and filter as required\n    // only remove when we have results and method missing, or with no results if optional\n    for (let i = 0; i < count; i++) {\n      const [k, {\n        method,\n        section\n      }] = allKnown[i];\n      if (hasResults && !exposed.includes(k) && k !== 'rpc_methods') {\n        if (this._rpc[section]) {\n          delete this._rpc[section][method];\n          delete this._rx.rpc[section][method];\n        }\n      }\n    }\n  }\n  _rpcSubmitter(decorateMethod) {\n    const method = (method, ...params) => {\n      return from(this._rpcCore.provider.send(method, params));\n    };\n    return decorateMethod(method);\n  }\n  _decorateRpc(rpc, decorateMethod, input = this._rpcSubmitter(decorateMethod)) {\n    const out = input;\n    const decorateFn = (section, method) => {\n      const source = rpc[section][method];\n      const fn = decorateMethod(source, {\n        methodName: method\n      });\n      fn.meta = source.meta;\n      fn.raw = decorateMethod(source.raw, {\n        methodName: method\n      });\n      return fn;\n    };\n    for (let s = 0, scount = rpc.sections.length; s < scount; s++) {\n      const section = rpc.sections[s];\n      if (!Object.prototype.hasOwnProperty.call(out, section)) {\n        const methods = Object.keys(rpc[section]);\n        const decorateInternal = method => decorateFn(section, method);\n        for (let m = 0, mcount = methods.length; m < mcount; m++) {\n          const method = methods[m];\n          //  skip subscriptions where we have a non-subscribe interface\n          if (this.hasSubscriptions || !(method.startsWith('subscribe') || method.startsWith('unsubscribe'))) {\n            if (!Object.prototype.hasOwnProperty.call(out, section)) {\n              out[section] = {};\n            }\n            lazyMethod(out[section], method, decorateInternal);\n          }\n        }\n      }\n    }\n    return out;\n  }\n  // add all definition entries\n  _addRuntimeDef(result, additional) {\n    if (!additional) {\n      return;\n    }\n    const entries = Object.entries(additional);\n    for (let j = 0, ecount = entries.length; j < ecount; j++) {\n      const [key, defs] = entries[j];\n      if (result[key]) {\n        // we have this one already, step through for new versions or\n        // new methods and add those as applicable\n        for (let k = 0, dcount = defs.length; k < dcount; k++) {\n          const def = defs[k];\n          const prev = result[key].find(({\n            version\n          }) => def.version === version);\n          if (prev) {\n            // interleave the new methods with the old - last definition wins\n            objectSpread(prev.methods, def.methods);\n          } else {\n            // we don't have this specific version, add it\n            result[key].push(def);\n          }\n        }\n      } else {\n        // we don't have this runtime definition, add it as-is\n        result[key] = defs;\n      }\n    }\n  }\n  // extract all runtime definitions\n  _getRuntimeDefs(registry, specName, chain = '') {\n    const result = {};\n    const defValues = Object.values(typeDefinitions);\n    // options > chain/spec > built-in, apply in reverse order with\n    // methods overriding previous definitions (or interleave missing)\n    for (let i = 0, count = defValues.length; i < count; i++) {\n      this._addRuntimeDef(result, defValues[i].runtime);\n    }\n    this._addRuntimeDef(result, getSpecRuntime(registry, chain, specName));\n    this._addRuntimeDef(result, this._options.runtime);\n    return Object.entries(result);\n  }\n  // pre-metadata decoration\n  _decorateCalls({\n    registry,\n    runtimeVersion: {\n      apis,\n      specName,\n      specVersion\n    }\n  }, decorateMethod, blockHash) {\n    const result = {};\n    const named = {};\n    const hashes = {};\n    const sections = this._getRuntimeDefs(registry, specName, this._runtimeChain);\n    const older = [];\n    const implName = `${specName.toString()}/${specVersion.toString()}`;\n    const hasLogged = this.__internal__runtimeLog[implName] || false;\n    this.__internal__runtimeLog[implName] = true;\n    for (let i = 0, scount = sections.length; i < scount; i++) {\n      const [_section, secs] = sections[i];\n      const sectionHash = blake2AsHex(_section, 64);\n      const rtApi = apis.find(([a]) => a.eq(sectionHash));\n      hashes[sectionHash] = true;\n      if (rtApi) {\n        const all = secs.map(({\n          version\n        }) => version).sort();\n        const sec = secs.find(({\n          version\n        }) => rtApi[1].eq(version));\n        if (sec) {\n          const section = stringCamelCase(_section);\n          const methods = Object.entries(sec.methods);\n          if (methods.length) {\n            if (!named[section]) {\n              named[section] = {};\n            }\n            for (let m = 0, mcount = methods.length; m < mcount; m++) {\n              const [_method, def] = methods[m];\n              const method = stringCamelCase(_method);\n              named[section][method] = objectSpread({\n                method,\n                name: `${_section}_${_method}`,\n                section,\n                sectionHash\n              }, def);\n            }\n          }\n        } else {\n          older.push(`${_section}/${rtApi[1].toString()} (${all.join('/')} known)`);\n        }\n      }\n    }\n    // find the runtimes that we don't have hashes for\n    const notFound = apis.map(([a, v]) => [a.toHex(), v.toString()]).filter(([a]) => !hashes[a]).map(([a, v]) => `${this._runtimeMap[a] || a}/${v}`);\n    if (!this._options.noInitWarn && !hasLogged) {\n      if (older.length) {\n        l.warn(`${implName}: Not decorating runtime apis without matching versions: ${older.join(', ')}`);\n      }\n      if (notFound.length) {\n        l.warn(`${implName}: Not decorating unknown runtime apis: ${notFound.join(', ')}`);\n      }\n    }\n    const stateCall = blockHash ? (name, bytes) => this._rpcCore.state.call(name, bytes, blockHash) : (name, bytes) => this._rpcCore.state.call(name, bytes);\n    const lazySection = section => lazyMethods({}, Object.keys(named[section]), method => this._decorateCall(registry, named[section][method], stateCall, decorateMethod));\n    const modules = Object.keys(named);\n    for (let i = 0, count = modules.length; i < count; i++) {\n      lazyMethod(result, modules[i], lazySection);\n    }\n    return result;\n  }\n  _decorateCall(registry, def, stateCall, decorateMethod) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const decorated = decorateMethod((...args) => {\n      if (args.length !== def.params.length) {\n        throw new Error(`${def.name}:: Expected ${def.params.length} arguments, found ${args.length}`);\n      }\n      const bytes = registry.createType('Raw', u8aConcatStrict(args.map((a, i) => registry.createTypeUnsafe(def.params[i].type, [a]).toU8a())));\n      return stateCall(def.name, bytes).pipe(map(r => registry.createTypeUnsafe(def.type, [r])));\n    });\n    decorated.meta = def;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorated;\n  }\n  // only be called if supportMulti is true\n  _decorateMulti(decorateMethod) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorateMethod(keys => keys.length ? (this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt)(keys.map(args => Array.isArray(args) ? args[0].creator.meta.type.isPlain ? [args[0].creator] : args[0].creator.meta.type.asMap.hashers.length === 1 ? [args[0].creator, args.slice(1)] : [args[0].creator, ...args.slice(1)] : [args.creator])) : of([]));\n  }\n  _decorateMultiAt(atApi, decorateMethod, blockHash) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorateMethod(calls => calls.length ? this._rpcCore.state.queryStorageAt(calls.map(args => {\n      if (Array.isArray(args)) {\n        const {\n          creator\n        } = getAtQueryFn(atApi, args[0].creator);\n        return creator.meta.type.isPlain ? [creator] : creator.meta.type.asMap.hashers.length === 1 ? [creator, args.slice(1)] : [creator, ...args.slice(1)];\n      }\n      return [getAtQueryFn(atApi, args.creator).creator];\n    }), blockHash) : of([]));\n  }\n  _decorateExtrinsics({\n    tx\n  }, decorateMethod) {\n    const result = createSubmittable(this._type, this._rx, decorateMethod);\n    const lazySection = section => lazyMethods({}, Object.keys(tx[section]), method => method.startsWith('$') ? tx[section][method] : this._decorateExtrinsicEntry(tx[section][method], result));\n    const sections = Object.keys(tx);\n    for (let i = 0, count = sections.length; i < count; i++) {\n      lazyMethod(result, sections[i], lazySection);\n    }\n    return result;\n  }\n  _decorateExtrinsicEntry(method, creator) {\n    const decorated = (...params) => creator(method(...params));\n    // pass through the `.is`\n    decorated.is = other => method.is(other);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return this._decorateFunctionMeta(method, decorated);\n  }\n  _decorateStorage({\n    query,\n    registry\n  }, decorateMethod, blockHash) {\n    const result = {};\n    const lazySection = section => lazyMethods({}, Object.keys(query[section]), method => blockHash ? this._decorateStorageEntryAt(registry, query[section][method], decorateMethod, blockHash) : this._decorateStorageEntry(query[section][method], decorateMethod));\n    const sections = Object.keys(query);\n    for (let i = 0, count = sections.length; i < count; i++) {\n      lazyMethod(result, sections[i], lazySection);\n    }\n    return result;\n  }\n  _decorateStorageEntry(creator, decorateMethod) {\n    const getArgs = (args, registry) => extractStorageArgs(registry || this.__internal__registry, creator, args);\n    const getQueryAt = blockHash => from(this.at(blockHash)).pipe(map(api => getAtQueryFn(api, creator)));\n    // Disable this where it occurs for each field we are decorating\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n    const decorated = this._decorateStorageCall(creator, decorateMethod);\n    decorated.creator = creator;\n    // eslint-disable-next-line deprecation/deprecation\n    decorated.at = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap(q => q(...args))));\n    decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args)));\n    decorated.is = key => key.section === creator.section && key.method === creator.method;\n    decorated.key = (...args) => u8aToHex(compactStripLength(creator(...args))[1]);\n    decorated.keyPrefix = (...args) => u8aToHex(creator.keyPrefix(...args));\n    decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args)));\n    // eslint-disable-next-line deprecation/deprecation\n    decorated.sizeAt = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap(q => this._rpcCore.state.getStorageSize(getArgs(args, q.creator.meta.registry), blockHash))));\n    // .keys() & .entries() only available on map types\n    if (creator.iterKey && creator.meta.type.isMap) {\n      decorated.entries = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapEntries(creator, null, args)));\n      // eslint-disable-next-line deprecation/deprecation\n      decorated.entriesAt = decorateMethod(memo(this.__internal__instanceId, (blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap(q => this._retrieveMapEntries(q.creator, blockHash, args)))));\n      decorated.entriesPaged = decorateMethod(memo(this.__internal__instanceId, opts => this._retrieveMapEntriesPaged(creator, undefined, opts)));\n      decorated.keys = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapKeys(creator, null, args)));\n      // eslint-disable-next-line deprecation/deprecation\n      decorated.keysAt = decorateMethod(memo(this.__internal__instanceId, (blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap(q => this._retrieveMapKeys(q.creator, blockHash, args)))));\n      decorated.keysPaged = decorateMethod(memo(this.__internal__instanceId, opts => this._retrieveMapKeysPaged(creator, undefined, opts)));\n    }\n    if (this.supportMulti && creator.meta.type.isMap) {\n      // When using double map storage function, user need to pass double map key as an array\n      decorated.multi = decorateMethod(args => creator.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(args.map(a => [creator, [a]])) : this._retrieveMulti(args.map(a => [creator, a])));\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n    return this._decorateFunctionMeta(creator, decorated);\n  }\n  _decorateStorageEntryAt(registry, creator, decorateMethod, blockHash) {\n    const getArgs = args => extractStorageArgs(registry, creator, args);\n    // Disable this where it occurs for each field we are decorating\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n    const decorated = decorateMethod((...args) => this._rpcCore.state.getStorage(getArgs(args), blockHash));\n    decorated.creator = creator;\n    decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args), blockHash));\n    decorated.is = key => key.section === creator.section && key.method === creator.method;\n    decorated.key = (...args) => u8aToHex(compactStripLength(creator(...args))[1]);\n    decorated.keyPrefix = (...keys) => u8aToHex(creator.keyPrefix(...keys));\n    decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args), blockHash));\n    // .keys() & .entries() only available on map types\n    if (creator.iterKey && creator.meta.type.isMap) {\n      decorated.entries = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapEntries(creator, blockHash, args)));\n      decorated.entriesPaged = decorateMethod(memo(this.__internal__instanceId, opts => this._retrieveMapEntriesPaged(creator, blockHash, opts)));\n      decorated.keys = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapKeys(creator, blockHash, args)));\n      decorated.keysPaged = decorateMethod(memo(this.__internal__instanceId, opts => this._retrieveMapKeysPaged(creator, blockHash, opts)));\n    }\n    if (this.supportMulti && creator.meta.type.isMap) {\n      // When using double map storage function, user need to pass double map key as an array\n      decorated.multi = decorateMethod(args => creator.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(args.map(a => [creator, [a]]), blockHash) : this._retrieveMulti(args.map(a => [creator, a]), blockHash));\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n    return this._decorateFunctionMeta(creator, decorated);\n  }\n  _queueStorage(call, queue) {\n    const query = queue === this.__internal__storageSubQ ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;\n    let queueIdx = queue.length - 1;\n    let valueIdx = 0;\n    let valueObs;\n    // if we don't have queue entries yet,\n    // or the current queue has fired (see from below),\n    // or the current queue has the max entries,\n    // then we create a new queue\n    if (queueIdx === -1 || !queue[queueIdx] || queue[queueIdx][1].length === PAGE_SIZE_Q) {\n      queueIdx++;\n      valueObs = from(\n      // we delay the execution until the next tick, this allows\n      // any queries made in this timeframe to be added to the same\n      // queue for a single query\n      new Promise(resolve => {\n        nextTick(() => {\n          // get all the calls in this instance, resolve with it\n          // and then clear the queue so we don't add more\n          // (anything after this will be added to a new queue)\n          const calls = queue[queueIdx][1];\n          delete queue[queueIdx];\n          resolve(calls);\n        });\n      })).pipe(switchMap(calls => query(calls)));\n      queue.push([valueObs, [call]]);\n    } else {\n      valueObs = queue[queueIdx][0];\n      valueIdx = queue[queueIdx][1].length;\n      queue[queueIdx][1].push(call);\n    }\n    return valueObs.pipe(\n    // return the single value at this index\n    map(values => values[valueIdx]));\n  }\n  // Decorate the base storage call. In the case or rxjs or promise-without-callback (await)\n  // we make a subscription, alternatively we push this through a single-shot query\n  _decorateStorageCall(creator, decorateMethod) {\n    const memoed = memo(this.__internal__instanceId, (...args) => {\n      const call = extractStorageArgs(this.__internal__registry, creator, args);\n      if (!this.hasSubscriptions) {\n        return this._rpcCore.state.getStorage(call);\n      }\n      return this._queueStorage(call, this.__internal__storageSubQ);\n    });\n    return decorateMethod(memoed, {\n      methodName: creator.method,\n      overrideNoSub: (...args) => this._queueStorage(extractStorageArgs(this.__internal__registry, creator, args), this.__internal__storageGetQ)\n    });\n  }\n  // retrieve a set of values for a specific set of keys - here we chunk the keys into PAGE_SIZE sizes\n  _retrieveMulti(keys, blockHash) {\n    if (!keys.length) {\n      return of([]);\n    }\n    const query = this.hasSubscriptions && !blockHash ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;\n    if (keys.length <= PAGE_SIZE_V) {\n      return blockHash ? query(keys, blockHash) : query(keys);\n    }\n    return combineLatest(arrayChunk(keys, PAGE_SIZE_V).map(k => blockHash ? query(k, blockHash) : query(k))).pipe(map(arrayFlatten));\n  }\n  _retrieveMapKeys({\n    iterKey,\n    meta,\n    method,\n    section\n  }, at, args) {\n    if (!iterKey || !meta.type.isMap) {\n      throw new Error('keys can only be retrieved on maps');\n    }\n    const headKey = iterKey(...args).toHex();\n    const startSubject = new BehaviorSubject(headKey);\n    const query = at ? startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey, at) : startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey);\n    const setMeta = key => key.setMeta(meta, section, method);\n    return startSubject.pipe(switchMap(query), map(keys => keys.map(setMeta)), tap(keys => nextTick(() => {\n      keys.length === PAGE_SIZE_K ? startSubject.next(keys[PAGE_SIZE_K - 1].toHex()) : startSubject.complete();\n    })), toArray(),\n    // toArray since we want to startSubject to be completed\n    map(arrayFlatten));\n  }\n  _retrieveMapKeysPaged({\n    iterKey,\n    meta,\n    method,\n    section\n  }, at, opts) {\n    if (!iterKey || !meta.type.isMap) {\n      throw new Error('keys can only be retrieved on maps');\n    }\n    const setMeta = key => key.setMeta(meta, section, method);\n    const query = at ? headKey => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey, at) : headKey => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey);\n    return query(iterKey(...opts.args).toHex()).pipe(map(keys => keys.map(setMeta)));\n  }\n  _retrieveMapEntries(entry, at, args) {\n    const query = at ? keys => this._rpcCore.state.queryStorageAt(keys, at) : keys => this._rpcCore.state.queryStorageAt(keys);\n    return this._retrieveMapKeys(entry, at, args).pipe(switchMap(keys => keys.length ? combineLatest(arrayChunk(keys, PAGE_SIZE_V).map(query)).pipe(map(valsArr => arrayFlatten(valsArr).map((value, index) => [keys[index], value]))) : of([])));\n  }\n  _retrieveMapEntriesPaged(entry, at, opts) {\n    const query = at ? keys => this._rpcCore.state.queryStorageAt(keys, at) : keys => this._rpcCore.state.queryStorageAt(keys);\n    return this._retrieveMapKeysPaged(entry, at, opts).pipe(switchMap(keys => keys.length ? query(keys).pipe(map(valsArr => valsArr.map((value, index) => [keys[index], value]))) : of([])));\n  }\n  _decorateDeriveRx(decorateMethod) {\n    const specName = this._runtimeVersion?.specName.toString();\n    // Pull in derive from api-derive\n    const available = getAvailableDerives(this.__internal__instanceId, this._rx, objectSpread({}, this._options.derives, this._options.typesBundle?.spec?.[specName || '']?.derives));\n    return decorateDeriveSections(decorateMethod, available);\n  }\n  _decorateDerive(decorateMethod) {\n    return decorateDeriveSections(decorateMethod, this._rx.derive);\n  }\n  /**\n   * Put the `this.onCall` function of ApiRx here, because it is needed by\n   * `api._rx`.\n   */\n  _rxDecorateMethod = method => {\n    return method;\n  };\n}","map":{"version":3,"names":["BehaviorSubject","combineLatest","from","map","of","switchMap","tap","toArray","getAvailableDerives","memo","RpcCore","WsProvider","expandMetadata","GenericExtrinsic","typeDefinitions","TypeRegistry","getSpecRuntime","arrayChunk","arrayFlatten","assertReturn","BN","compactStripLength","lazyMethod","lazyMethods","logger","nextTick","objectSpread","stringCamelCase","stringUpperFirst","u8aConcatStrict","u8aToHex","blake2AsHex","createSubmittable","augmentObject","decorateDeriveSections","extractStorageArgs","Events","findCall","findError","PAGE_SIZE_K","PAGE_SIZE_V","PAGE_SIZE_Q","l","instanceCounter","getAtQueryFn","api","method","section","rx","query","Decorate","__internal__instanceId","__internal__runtimeLog","__internal__registry","__internal__storageGetQ","__internal__storageSubQ","__phantom","_type","_call","_consts","_derive","_errors","_events","_extrinsics","_extrinsicType","LATEST_EXTRINSIC_VERSION","_genesisHash","_isConnected","_isReady","_query","_queryMulti","_rpc","_rpcCore","_runtimeMap","_runtimeChain","_runtimeMetadata","_runtimeVersion","_rx","call","consts","tx","_options","_decorateMethod","constructor","options","type","decorateMethod","source","registry","callAt","blockHash","knownVersion","at","pipe","a","queryAt","provider","isClonable","clone","isPedantic","userRpc","rpc","isConnected","hasSubscriptions","createType","params","registerTypes","types","register","supportMulti","state","queryStorageAt","_emptyDecorated","errors","events","_createDecorated","fromEmpty","decoratedApi","decoratedMeta","metadata","runtime","_decorateCalls","runtimeRx","_rxDecorateMethod","storage","_decorateStorage","storageRx","callIndex","errorIndex","queryMulti","_decorateMultiAt","_decorateMulti","runtimeVersion","createdAt","_injectMetadata","_decorateExtrinsics","rxtx","emit","injectMetadata","counter","_decorateFunctionMeta","input","output","meta","toJSON","_filterRpc","methods","additional","Object","keys","length","addUserInterfaces","_decorateRpc","sectionMap","i","count","split","sections","nameA","nameB","_filterRpcMethods","exposed","hasResults","allKnown","mapping","entries","allKeys","alias","endpoint","pubsub","push","unknown","filter","k","includes","noInitWarn","warn","join","_rpcSubmitter","send","out","decorateFn","fn","methodName","raw","s","scount","prototype","hasOwnProperty","decorateInternal","m","mcount","startsWith","_addRuntimeDef","result","j","ecount","key","defs","dcount","def","prev","find","version","_getRuntimeDefs","specName","chain","defValues","values","apis","specVersion","named","hashes","older","implName","toString","hasLogged","_section","secs","sectionHash","rtApi","eq","all","sort","sec","_method","name","notFound","v","toHex","stateCall","bytes","lazySection","_decorateCall","modules","decorated","args","Error","createTypeUnsafe","toU8a","r","subscribeStorage","Array","isArray","creator","isPlain","asMap","hashers","slice","atApi","calls","_decorateExtrinsicEntry","is","other","_decorateStorageEntryAt","_decorateStorageEntry","getArgs","getQueryAt","_decorateStorageCall","q","hash","getStorageHash","keyPrefix","size","getStorageSize","sizeAt","iterKey","isMap","_retrieveMapEntries","entriesAt","entriesPaged","opts","_retrieveMapEntriesPaged","undefined","_retrieveMapKeys","keysAt","keysPaged","_retrieveMapKeysPaged","multi","_retrieveMulti","getStorage","_queueStorage","queue","queueIdx","valueIdx","valueObs","Promise","resolve","memoed","overrideNoSub","headKey","startSubject","startKey","getKeysPaged","setMeta","next","complete","pageSize","entry","valsArr","value","index","_decorateDeriveRx","available","derives","typesBundle","spec","_decorateDerive","derive"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api/base/Decorate.js"],"sourcesContent":["import { BehaviorSubject, combineLatest, from, map, of, switchMap, tap, toArray } from 'rxjs';\nimport { getAvailableDerives } from '@polkadot/api-derive';\nimport { memo, RpcCore } from '@polkadot/rpc-core';\nimport { WsProvider } from '@polkadot/rpc-provider';\nimport { expandMetadata, GenericExtrinsic, typeDefinitions, TypeRegistry } from '@polkadot/types';\nimport { getSpecRuntime } from '@polkadot/types-known';\nimport { arrayChunk, arrayFlatten, assertReturn, BN, compactStripLength, lazyMethod, lazyMethods, logger, nextTick, objectSpread, stringCamelCase, stringUpperFirst, u8aConcatStrict, u8aToHex } from '@polkadot/util';\nimport { blake2AsHex } from '@polkadot/util-crypto';\nimport { createSubmittable } from '../submittable/index.js';\nimport { augmentObject } from '../util/augmentObject.js';\nimport { decorateDeriveSections } from '../util/decorate.js';\nimport { extractStorageArgs } from '../util/validate.js';\nimport { Events } from './Events.js';\nimport { findCall, findError } from './find.js';\nconst PAGE_SIZE_K = 1000; // limit aligned with the 1k on the node (trie lookups are heavy)\nconst PAGE_SIZE_V = 250; // limited since the data may be > 16MB (e.g. misfiring elections)\nconst PAGE_SIZE_Q = 50; // queue of pending storage queries (mapped together, next tick)\nconst l = logger('api/init');\nlet instanceCounter = 0;\nfunction getAtQueryFn(api, { method, section }) {\n    return assertReturn(api.rx.query[section] && api.rx.query[section][method], () => `query.${section}.${method} is not available in this version of the metadata`);\n}\nexport class Decorate extends Events {\n    __internal__instanceId;\n    __internal__runtimeLog = {};\n    __internal__registry;\n    __internal__storageGetQ = [];\n    __internal__storageSubQ = [];\n    // HACK Use BN import so decorateDerive works... yes, wtf.\n    __phantom = new BN(0);\n    _type;\n    _call = {};\n    _consts = {};\n    _derive;\n    _errors = {};\n    _events = {};\n    _extrinsics;\n    _extrinsicType = GenericExtrinsic.LATEST_EXTRINSIC_VERSION;\n    _genesisHash;\n    _isConnected;\n    _isReady = false;\n    _query = {};\n    _queryMulti;\n    _rpc;\n    _rpcCore;\n    _runtimeMap = {};\n    _runtimeChain;\n    _runtimeMetadata;\n    _runtimeVersion;\n    _rx = { call: {}, consts: {}, query: {}, tx: {} };\n    _options;\n    /**\n     * This is the one and only method concrete children classes need to implement.\n     * It's a higher-order function, which takes one argument\n     * `method: Method extends (...args: any[]) => Observable<any>`\n     * (and one optional `options`), and should return the user facing method.\n     * For example:\n     * - For ApiRx, `decorateMethod` should just be identity, because the input\n     * function is already an Observable\n     * - For ApiPromise, `decorateMethod` should return a function that takes all\n     * the parameters from `method`, adds an optional `callback` argument, and\n     * returns a Promise.\n     *\n     * We could easily imagine other user-facing interfaces, which are simply\n     * implemented by transforming the Observable to Stream/Iterator/Kefir/Bacon\n     * via `decorateMethod`.\n     */\n    _decorateMethod;\n    /**\n     * @description Create an instance of the class\n     *\n     * @param options Options object to create API instance or a Provider instance\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * import Api from '@polkadot/api/promise';\n     *\n     * const api = new Api().isReady();\n     *\n     * api.rpc.subscribeNewHeads((header) => {\n     *   console.log(`new block #${header.number.toNumber()}`);\n     * });\n     * ```\n     */\n    constructor(options, type, decorateMethod) {\n        super();\n        this.__internal__instanceId = `${++instanceCounter}`;\n        this.__internal__registry = options.source?.registry || options.registry || new TypeRegistry();\n        this._rx.callAt = (blockHash, knownVersion) => from(this.at(blockHash, knownVersion)).pipe(map((a) => a.rx.call));\n        this._rx.queryAt = (blockHash, knownVersion) => from(this.at(blockHash, knownVersion)).pipe(map((a) => a.rx.query));\n        this._rx.registry = this.__internal__registry;\n        this._decorateMethod = decorateMethod;\n        this._options = options;\n        this._type = type;\n        const provider = options.source\n            ? options.source._rpcCore.provider.isClonable\n                ? options.source._rpcCore.provider.clone()\n                : options.source._rpcCore.provider\n            : (options.provider || new WsProvider());\n        // The RPC interface decorates the known interfaces on init\n        this._rpcCore = new RpcCore(this.__internal__instanceId, this.__internal__registry, {\n            isPedantic: this._options.isPedantic,\n            provider,\n            userRpc: this._options.rpc\n        });\n        this._isConnected = new BehaviorSubject(this._rpcCore.provider.isConnected);\n        this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;\n    }\n    /**\n     * @description Return the current used registry\n     */\n    get registry() {\n        return this.__internal__registry;\n    }\n    /**\n     * @description Creates an instance of a type as registered\n     */\n    createType(type, ...params) {\n        return this.__internal__registry.createType(type, ...params);\n    }\n    /**\n     * @description Register additional user-defined of chain-specific types in the type registry\n     */\n    registerTypes(types) {\n        types && this.__internal__registry.register(types);\n    }\n    /**\n     * @returns `true` if the API operates with subscriptions\n     */\n    get hasSubscriptions() {\n        return this._rpcCore.provider.hasSubscriptions;\n    }\n    /**\n     * @returns `true` if the API decorate multi-key queries\n     */\n    get supportMulti() {\n        return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;\n    }\n    _emptyDecorated(registry, blockHash) {\n        return {\n            call: {},\n            consts: {},\n            errors: {},\n            events: {},\n            query: {},\n            registry,\n            rx: {\n                call: {},\n                query: {}\n            },\n            tx: createSubmittable(this._type, this._rx, this._decorateMethod, registry, blockHash)\n        };\n    }\n    _createDecorated(registry, fromEmpty, decoratedApi, blockHash) {\n        if (!decoratedApi) {\n            decoratedApi = this._emptyDecorated(registry.registry, blockHash);\n        }\n        if (fromEmpty || !registry.decoratedMeta) {\n            registry.decoratedMeta = expandMetadata(registry.registry, registry.metadata);\n        }\n        const runtime = this._decorateCalls(registry, this._decorateMethod, blockHash);\n        const runtimeRx = this._decorateCalls(registry, this._rxDecorateMethod, blockHash);\n        const storage = this._decorateStorage(registry.decoratedMeta, this._decorateMethod, blockHash);\n        const storageRx = this._decorateStorage(registry.decoratedMeta, this._rxDecorateMethod, blockHash);\n        augmentObject('consts', registry.decoratedMeta.consts, decoratedApi.consts, fromEmpty);\n        augmentObject('errors', registry.decoratedMeta.errors, decoratedApi.errors, fromEmpty);\n        augmentObject('events', registry.decoratedMeta.events, decoratedApi.events, fromEmpty);\n        augmentObject('query', storage, decoratedApi.query, fromEmpty);\n        augmentObject('query', storageRx, decoratedApi.rx.query, fromEmpty);\n        augmentObject('call', runtime, decoratedApi.call, fromEmpty);\n        augmentObject('call', runtimeRx, decoratedApi.rx.call, fromEmpty);\n        decoratedApi.findCall = (callIndex) => findCall(registry.registry, callIndex);\n        decoratedApi.findError = (errorIndex) => findError(registry.registry, errorIndex);\n        decoratedApi.queryMulti = blockHash\n            ? this._decorateMultiAt(decoratedApi, this._decorateMethod, blockHash)\n            : this._decorateMulti(this._decorateMethod);\n        decoratedApi.runtimeVersion = registry.runtimeVersion;\n        return {\n            createdAt: blockHash,\n            decoratedApi,\n            decoratedMeta: registry.decoratedMeta\n        };\n    }\n    _injectMetadata(registry, fromEmpty = false) {\n        // clear the decoration, we are redoing it here\n        if (fromEmpty || !registry.decoratedApi) {\n            registry.decoratedApi = this._emptyDecorated(registry.registry);\n        }\n        const { decoratedApi, decoratedMeta } = this._createDecorated(registry, fromEmpty, registry.decoratedApi);\n        this._call = decoratedApi.call;\n        this._consts = decoratedApi.consts;\n        this._errors = decoratedApi.errors;\n        this._events = decoratedApi.events;\n        this._query = decoratedApi.query;\n        this._rx.call = decoratedApi.rx.call;\n        this._rx.query = decoratedApi.rx.query;\n        const tx = this._decorateExtrinsics(decoratedMeta, this._decorateMethod);\n        const rxtx = this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod);\n        if (fromEmpty || !this._extrinsics) {\n            this._extrinsics = tx;\n            this._rx.tx = rxtx;\n        }\n        else {\n            augmentObject('tx', tx, this._extrinsics, false);\n            augmentObject(null, rxtx, this._rx.tx, false);\n        }\n        augmentObject(null, decoratedMeta.consts, this._rx.consts, fromEmpty);\n        this.emit('decorated');\n    }\n    /**\n     * @deprecated\n     * backwards compatible endpoint for metadata injection, may be removed in the future (However, it is still useful for testing injection)\n     */\n    injectMetadata(metadata, fromEmpty, registry) {\n        this._injectMetadata({ counter: 0, metadata, registry: registry || this.__internal__registry, runtimeVersion: this.__internal__registry.createType('RuntimeVersionPartial') }, fromEmpty);\n    }\n    _decorateFunctionMeta(input, output) {\n        output.meta = input.meta;\n        output.method = input.method;\n        output.section = input.section;\n        output.toJSON = input.toJSON;\n        if (input.callIndex) {\n            output.callIndex = input.callIndex;\n        }\n        return output;\n    }\n    // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following\n    // manner to cater for both old and new:\n    //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)\n    //   - when non-zero, remove anything that is not in the array (we don't do this)\n    _filterRpc(methods, additional) {\n        // add any specific user-base RPCs\n        if (Object.keys(additional).length !== 0) {\n            this._rpcCore.addUserInterfaces(additional);\n            // re-decorate, only adding any new additional interfaces\n            this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc);\n            this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc);\n        }\n        // extract the actual sections from the methods (this is useful when\n        // we try and create mappings to runtime names via a hash mapping)\n        const sectionMap = {};\n        for (let i = 0, count = methods.length; i < count; i++) {\n            const [section] = methods[i].split('_');\n            sectionMap[section] = true;\n        }\n        // convert the actual section names into an easy name lookup\n        const sections = Object.keys(sectionMap);\n        for (let i = 0, count = sections.length; i < count; i++) {\n            const nameA = stringUpperFirst(sections[i]);\n            const nameB = `${nameA}Api`;\n            this._runtimeMap[blake2AsHex(nameA, 64)] = nameA;\n            this._runtimeMap[blake2AsHex(nameB, 64)] = nameB;\n        }\n        // finally we filter the actual methods to expose\n        this._filterRpcMethods(methods);\n    }\n    _filterRpcMethods(exposed) {\n        const hasResults = exposed.length !== 0;\n        const allKnown = [...this._rpcCore.mapping.entries()];\n        const allKeys = [];\n        const count = allKnown.length;\n        for (let i = 0; i < count; i++) {\n            const [, { alias, endpoint, method, pubsub, section }] = allKnown[i];\n            allKeys.push(`${section}_${method}`);\n            if (pubsub) {\n                allKeys.push(`${section}_${pubsub[1]}`);\n                allKeys.push(`${section}_${pubsub[2]}`);\n            }\n            if (alias) {\n                allKeys.push(...alias);\n            }\n            if (endpoint) {\n                allKeys.push(endpoint);\n            }\n        }\n        const unknown = exposed.filter((k) => !allKeys.includes(k) &&\n            !k.includes('_unstable_'));\n        if (unknown.length && !this._options.noInitWarn) {\n            l.warn(`RPC methods not decorated: ${unknown.join(', ')}`);\n        }\n        // loop through all entries we have (populated in decorate) and filter as required\n        // only remove when we have results and method missing, or with no results if optional\n        for (let i = 0; i < count; i++) {\n            const [k, { method, section }] = allKnown[i];\n            if (hasResults && !exposed.includes(k) && k !== 'rpc_methods') {\n                if (this._rpc[section]) {\n                    delete this._rpc[section][method];\n                    delete this._rx.rpc[section][method];\n                }\n            }\n        }\n    }\n    _rpcSubmitter(decorateMethod) {\n        const method = (method, ...params) => {\n            return from(this._rpcCore.provider.send(method, params));\n        };\n        return decorateMethod(method);\n    }\n    _decorateRpc(rpc, decorateMethod, input = this._rpcSubmitter(decorateMethod)) {\n        const out = input;\n        const decorateFn = (section, method) => {\n            const source = rpc[section][method];\n            const fn = decorateMethod(source, { methodName: method });\n            fn.meta = source.meta;\n            fn.raw = decorateMethod(source.raw, { methodName: method });\n            return fn;\n        };\n        for (let s = 0, scount = rpc.sections.length; s < scount; s++) {\n            const section = rpc.sections[s];\n            if (!Object.prototype.hasOwnProperty.call(out, section)) {\n                const methods = Object.keys(rpc[section]);\n                const decorateInternal = (method) => decorateFn(section, method);\n                for (let m = 0, mcount = methods.length; m < mcount; m++) {\n                    const method = methods[m];\n                    //  skip subscriptions where we have a non-subscribe interface\n                    if (this.hasSubscriptions || !(method.startsWith('subscribe') || method.startsWith('unsubscribe'))) {\n                        if (!Object.prototype.hasOwnProperty.call(out, section)) {\n                            out[section] = {};\n                        }\n                        lazyMethod(out[section], method, decorateInternal);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n    // add all definition entries\n    _addRuntimeDef(result, additional) {\n        if (!additional) {\n            return;\n        }\n        const entries = Object.entries(additional);\n        for (let j = 0, ecount = entries.length; j < ecount; j++) {\n            const [key, defs] = entries[j];\n            if (result[key]) {\n                // we have this one already, step through for new versions or\n                // new methods and add those as applicable\n                for (let k = 0, dcount = defs.length; k < dcount; k++) {\n                    const def = defs[k];\n                    const prev = result[key].find(({ version }) => def.version === version);\n                    if (prev) {\n                        // interleave the new methods with the old - last definition wins\n                        objectSpread(prev.methods, def.methods);\n                    }\n                    else {\n                        // we don't have this specific version, add it\n                        result[key].push(def);\n                    }\n                }\n            }\n            else {\n                // we don't have this runtime definition, add it as-is\n                result[key] = defs;\n            }\n        }\n    }\n    // extract all runtime definitions\n    _getRuntimeDefs(registry, specName, chain = '') {\n        const result = {};\n        const defValues = Object.values(typeDefinitions);\n        // options > chain/spec > built-in, apply in reverse order with\n        // methods overriding previous definitions (or interleave missing)\n        for (let i = 0, count = defValues.length; i < count; i++) {\n            this._addRuntimeDef(result, defValues[i].runtime);\n        }\n        this._addRuntimeDef(result, getSpecRuntime(registry, chain, specName));\n        this._addRuntimeDef(result, this._options.runtime);\n        return Object.entries(result);\n    }\n    // pre-metadata decoration\n    _decorateCalls({ registry, runtimeVersion: { apis, specName, specVersion } }, decorateMethod, blockHash) {\n        const result = {};\n        const named = {};\n        const hashes = {};\n        const sections = this._getRuntimeDefs(registry, specName, this._runtimeChain);\n        const older = [];\n        const implName = `${specName.toString()}/${specVersion.toString()}`;\n        const hasLogged = this.__internal__runtimeLog[implName] || false;\n        this.__internal__runtimeLog[implName] = true;\n        for (let i = 0, scount = sections.length; i < scount; i++) {\n            const [_section, secs] = sections[i];\n            const sectionHash = blake2AsHex(_section, 64);\n            const rtApi = apis.find(([a]) => a.eq(sectionHash));\n            hashes[sectionHash] = true;\n            if (rtApi) {\n                const all = secs.map(({ version }) => version).sort();\n                const sec = secs.find(({ version }) => rtApi[1].eq(version));\n                if (sec) {\n                    const section = stringCamelCase(_section);\n                    const methods = Object.entries(sec.methods);\n                    if (methods.length) {\n                        if (!named[section]) {\n                            named[section] = {};\n                        }\n                        for (let m = 0, mcount = methods.length; m < mcount; m++) {\n                            const [_method, def] = methods[m];\n                            const method = stringCamelCase(_method);\n                            named[section][method] = objectSpread({ method, name: `${_section}_${_method}`, section, sectionHash }, def);\n                        }\n                    }\n                }\n                else {\n                    older.push(`${_section}/${rtApi[1].toString()} (${all.join('/')} known)`);\n                }\n            }\n        }\n        // find the runtimes that we don't have hashes for\n        const notFound = apis\n            .map(([a, v]) => [a.toHex(), v.toString()])\n            .filter(([a]) => !hashes[a])\n            .map(([a, v]) => `${this._runtimeMap[a] || a}/${v}`);\n        if (!this._options.noInitWarn && !hasLogged) {\n            if (older.length) {\n                l.warn(`${implName}: Not decorating runtime apis without matching versions: ${older.join(', ')}`);\n            }\n            if (notFound.length) {\n                l.warn(`${implName}: Not decorating unknown runtime apis: ${notFound.join(', ')}`);\n            }\n        }\n        const stateCall = blockHash\n            ? (name, bytes) => this._rpcCore.state.call(name, bytes, blockHash)\n            : (name, bytes) => this._rpcCore.state.call(name, bytes);\n        const lazySection = (section) => lazyMethods({}, Object.keys(named[section]), (method) => this._decorateCall(registry, named[section][method], stateCall, decorateMethod));\n        const modules = Object.keys(named);\n        for (let i = 0, count = modules.length; i < count; i++) {\n            lazyMethod(result, modules[i], lazySection);\n        }\n        return result;\n    }\n    _decorateCall(registry, def, stateCall, decorateMethod) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const decorated = decorateMethod((...args) => {\n            if (args.length !== def.params.length) {\n                throw new Error(`${def.name}:: Expected ${def.params.length} arguments, found ${args.length}`);\n            }\n            const bytes = registry.createType('Raw', u8aConcatStrict(args.map((a, i) => registry.createTypeUnsafe(def.params[i].type, [a]).toU8a())));\n            return stateCall(def.name, bytes).pipe(map((r) => registry.createTypeUnsafe(def.type, [r])));\n        });\n        decorated.meta = def;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return decorated;\n    }\n    // only be called if supportMulti is true\n    _decorateMulti(decorateMethod) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return decorateMethod((keys) => keys.length\n            ? (this.hasSubscriptions\n                ? this._rpcCore.state.subscribeStorage\n                : this._rpcCore.state.queryStorageAt)(keys.map((args) => Array.isArray(args)\n                ? args[0].creator.meta.type.isPlain\n                    ? [args[0].creator]\n                    : args[0].creator.meta.type.asMap.hashers.length === 1\n                        ? [args[0].creator, args.slice(1)]\n                        : [args[0].creator, ...args.slice(1)]\n                : [args.creator]))\n            : of([]));\n    }\n    _decorateMultiAt(atApi, decorateMethod, blockHash) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return decorateMethod((calls) => calls.length\n            ? this._rpcCore.state.queryStorageAt(calls.map((args) => {\n                if (Array.isArray(args)) {\n                    const { creator } = getAtQueryFn(atApi, args[0].creator);\n                    return creator.meta.type.isPlain\n                        ? [creator]\n                        : creator.meta.type.asMap.hashers.length === 1\n                            ? [creator, args.slice(1)]\n                            : [creator, ...args.slice(1)];\n                }\n                return [getAtQueryFn(atApi, args.creator).creator];\n            }), blockHash)\n            : of([]));\n    }\n    _decorateExtrinsics({ tx }, decorateMethod) {\n        const result = createSubmittable(this._type, this._rx, decorateMethod);\n        const lazySection = (section) => lazyMethods({}, Object.keys(tx[section]), (method) => method.startsWith('$')\n            ? tx[section][method]\n            : this._decorateExtrinsicEntry(tx[section][method], result));\n        const sections = Object.keys(tx);\n        for (let i = 0, count = sections.length; i < count; i++) {\n            lazyMethod(result, sections[i], lazySection);\n        }\n        return result;\n    }\n    _decorateExtrinsicEntry(method, creator) {\n        const decorated = (...params) => creator(method(...params));\n        // pass through the `.is`\n        decorated.is = (other) => method.is(other);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return this._decorateFunctionMeta(method, decorated);\n    }\n    _decorateStorage({ query, registry }, decorateMethod, blockHash) {\n        const result = {};\n        const lazySection = (section) => lazyMethods({}, Object.keys(query[section]), (method) => blockHash\n            ? this._decorateStorageEntryAt(registry, query[section][method], decorateMethod, blockHash)\n            : this._decorateStorageEntry(query[section][method], decorateMethod));\n        const sections = Object.keys(query);\n        for (let i = 0, count = sections.length; i < count; i++) {\n            lazyMethod(result, sections[i], lazySection);\n        }\n        return result;\n    }\n    _decorateStorageEntry(creator, decorateMethod) {\n        const getArgs = (args, registry) => extractStorageArgs(registry || this.__internal__registry, creator, args);\n        const getQueryAt = (blockHash) => from(this.at(blockHash)).pipe(map((api) => getAtQueryFn(api, creator)));\n        // Disable this where it occurs for each field we are decorating\n        /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n        const decorated = this._decorateStorageCall(creator, decorateMethod);\n        decorated.creator = creator;\n        // eslint-disable-next-line deprecation/deprecation\n        decorated.at = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => q(...args))));\n        decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args)));\n        decorated.is = (key) => key.section === creator.section &&\n            key.method === creator.method;\n        decorated.key = (...args) => u8aToHex(compactStripLength(creator(...args))[1]);\n        decorated.keyPrefix = (...args) => u8aToHex(creator.keyPrefix(...args));\n        decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args)));\n        // eslint-disable-next-line deprecation/deprecation\n        decorated.sizeAt = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => this._rpcCore.state.getStorageSize(getArgs(args, q.creator.meta.registry), blockHash))));\n        // .keys() & .entries() only available on map types\n        if (creator.iterKey && creator.meta.type.isMap) {\n            decorated.entries = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapEntries(creator, null, args)));\n            // eslint-disable-next-line deprecation/deprecation\n            decorated.entriesAt = decorateMethod(memo(this.__internal__instanceId, (blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => this._retrieveMapEntries(q.creator, blockHash, args)))));\n            decorated.entriesPaged = decorateMethod(memo(this.__internal__instanceId, (opts) => this._retrieveMapEntriesPaged(creator, undefined, opts)));\n            decorated.keys = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapKeys(creator, null, args)));\n            // eslint-disable-next-line deprecation/deprecation\n            decorated.keysAt = decorateMethod(memo(this.__internal__instanceId, (blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => this._retrieveMapKeys(q.creator, blockHash, args)))));\n            decorated.keysPaged = decorateMethod(memo(this.__internal__instanceId, (opts) => this._retrieveMapKeysPaged(creator, undefined, opts)));\n        }\n        if (this.supportMulti && creator.meta.type.isMap) {\n            // When using double map storage function, user need to pass double map key as an array\n            decorated.multi = decorateMethod((args) => creator.meta.type.asMap.hashers.length === 1\n                ? this._retrieveMulti(args.map((a) => [creator, [a]]))\n                : this._retrieveMulti(args.map((a) => [creator, a])));\n        }\n        /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n        return this._decorateFunctionMeta(creator, decorated);\n    }\n    _decorateStorageEntryAt(registry, creator, decorateMethod, blockHash) {\n        const getArgs = (args) => extractStorageArgs(registry, creator, args);\n        // Disable this where it occurs for each field we are decorating\n        /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n        const decorated = decorateMethod((...args) => this._rpcCore.state.getStorage(getArgs(args), blockHash));\n        decorated.creator = creator;\n        decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args), blockHash));\n        decorated.is = (key) => key.section === creator.section &&\n            key.method === creator.method;\n        decorated.key = (...args) => u8aToHex(compactStripLength(creator(...args))[1]);\n        decorated.keyPrefix = (...keys) => u8aToHex(creator.keyPrefix(...keys));\n        decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args), blockHash));\n        // .keys() & .entries() only available on map types\n        if (creator.iterKey && creator.meta.type.isMap) {\n            decorated.entries = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapEntries(creator, blockHash, args)));\n            decorated.entriesPaged = decorateMethod(memo(this.__internal__instanceId, (opts) => this._retrieveMapEntriesPaged(creator, blockHash, opts)));\n            decorated.keys = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapKeys(creator, blockHash, args)));\n            decorated.keysPaged = decorateMethod(memo(this.__internal__instanceId, (opts) => this._retrieveMapKeysPaged(creator, blockHash, opts)));\n        }\n        if (this.supportMulti && creator.meta.type.isMap) {\n            // When using double map storage function, user need to pass double map key as an array\n            decorated.multi = decorateMethod((args) => creator.meta.type.asMap.hashers.length === 1\n                ? this._retrieveMulti(args.map((a) => [creator, [a]]), blockHash)\n                : this._retrieveMulti(args.map((a) => [creator, a]), blockHash));\n        }\n        /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n        return this._decorateFunctionMeta(creator, decorated);\n    }\n    _queueStorage(call, queue) {\n        const query = queue === this.__internal__storageSubQ\n            ? this._rpcCore.state.subscribeStorage\n            : this._rpcCore.state.queryStorageAt;\n        let queueIdx = queue.length - 1;\n        let valueIdx = 0;\n        let valueObs;\n        // if we don't have queue entries yet,\n        // or the current queue has fired (see from below),\n        // or the current queue has the max entries,\n        // then we create a new queue\n        if (queueIdx === -1 || !queue[queueIdx] || queue[queueIdx][1].length === PAGE_SIZE_Q) {\n            queueIdx++;\n            valueObs = from(\n            // we delay the execution until the next tick, this allows\n            // any queries made in this timeframe to be added to the same\n            // queue for a single query\n            new Promise((resolve) => {\n                nextTick(() => {\n                    // get all the calls in this instance, resolve with it\n                    // and then clear the queue so we don't add more\n                    // (anything after this will be added to a new queue)\n                    const calls = queue[queueIdx][1];\n                    delete queue[queueIdx];\n                    resolve(calls);\n                });\n            })).pipe(switchMap((calls) => query(calls)));\n            queue.push([valueObs, [call]]);\n        }\n        else {\n            valueObs = queue[queueIdx][0];\n            valueIdx = queue[queueIdx][1].length;\n            queue[queueIdx][1].push(call);\n        }\n        return valueObs.pipe(\n        // return the single value at this index\n        map((values) => values[valueIdx]));\n    }\n    // Decorate the base storage call. In the case or rxjs or promise-without-callback (await)\n    // we make a subscription, alternatively we push this through a single-shot query\n    _decorateStorageCall(creator, decorateMethod) {\n        const memoed = memo(this.__internal__instanceId, (...args) => {\n            const call = extractStorageArgs(this.__internal__registry, creator, args);\n            if (!this.hasSubscriptions) {\n                return this._rpcCore.state.getStorage(call);\n            }\n            return this._queueStorage(call, this.__internal__storageSubQ);\n        });\n        return decorateMethod(memoed, {\n            methodName: creator.method,\n            overrideNoSub: (...args) => this._queueStorage(extractStorageArgs(this.__internal__registry, creator, args), this.__internal__storageGetQ)\n        });\n    }\n    // retrieve a set of values for a specific set of keys - here we chunk the keys into PAGE_SIZE sizes\n    _retrieveMulti(keys, blockHash) {\n        if (!keys.length) {\n            return of([]);\n        }\n        const query = this.hasSubscriptions && !blockHash\n            ? this._rpcCore.state.subscribeStorage\n            : this._rpcCore.state.queryStorageAt;\n        if (keys.length <= PAGE_SIZE_V) {\n            return blockHash\n                ? query(keys, blockHash)\n                : query(keys);\n        }\n        return combineLatest(arrayChunk(keys, PAGE_SIZE_V).map((k) => blockHash\n            ? query(k, blockHash)\n            : query(k))).pipe(map(arrayFlatten));\n    }\n    _retrieveMapKeys({ iterKey, meta, method, section }, at, args) {\n        if (!iterKey || !meta.type.isMap) {\n            throw new Error('keys can only be retrieved on maps');\n        }\n        const headKey = iterKey(...args).toHex();\n        const startSubject = new BehaviorSubject(headKey);\n        const query = at\n            ? (startKey) => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey, at)\n            : (startKey) => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey);\n        const setMeta = (key) => key.setMeta(meta, section, method);\n        return startSubject.pipe(switchMap(query), map((keys) => keys.map(setMeta)), tap((keys) => nextTick(() => {\n            keys.length === PAGE_SIZE_K\n                ? startSubject.next(keys[PAGE_SIZE_K - 1].toHex())\n                : startSubject.complete();\n        })), toArray(), // toArray since we want to startSubject to be completed\n        map(arrayFlatten));\n    }\n    _retrieveMapKeysPaged({ iterKey, meta, method, section }, at, opts) {\n        if (!iterKey || !meta.type.isMap) {\n            throw new Error('keys can only be retrieved on maps');\n        }\n        const setMeta = (key) => key.setMeta(meta, section, method);\n        const query = at\n            ? (headKey) => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey, at)\n            : (headKey) => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey);\n        return query(iterKey(...opts.args).toHex()).pipe(map((keys) => keys.map(setMeta)));\n    }\n    _retrieveMapEntries(entry, at, args) {\n        const query = at\n            ? (keys) => this._rpcCore.state.queryStorageAt(keys, at)\n            : (keys) => this._rpcCore.state.queryStorageAt(keys);\n        return this._retrieveMapKeys(entry, at, args).pipe(switchMap((keys) => keys.length\n            ? combineLatest(arrayChunk(keys, PAGE_SIZE_V).map(query)).pipe(map((valsArr) => arrayFlatten(valsArr).map((value, index) => [keys[index], value])))\n            : of([])));\n    }\n    _retrieveMapEntriesPaged(entry, at, opts) {\n        const query = at\n            ? (keys) => this._rpcCore.state.queryStorageAt(keys, at)\n            : (keys) => this._rpcCore.state.queryStorageAt(keys);\n        return this._retrieveMapKeysPaged(entry, at, opts).pipe(switchMap((keys) => keys.length\n            ? query(keys).pipe(map((valsArr) => valsArr.map((value, index) => [keys[index], value])))\n            : of([])));\n    }\n    _decorateDeriveRx(decorateMethod) {\n        const specName = this._runtimeVersion?.specName.toString();\n        // Pull in derive from api-derive\n        const available = getAvailableDerives(this.__internal__instanceId, this._rx, objectSpread({}, this._options.derives, this._options.typesBundle?.spec?.[specName || '']?.derives));\n        return decorateDeriveSections(decorateMethod, available);\n    }\n    _decorateDerive(decorateMethod) {\n        return decorateDeriveSections(decorateMethod, this._rx.derive);\n    }\n    /**\n     * Put the `this.onCall` function of ApiRx here, because it is needed by\n     * `api._rx`.\n     */\n    _rxDecorateMethod = (method) => {\n        return method;\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}