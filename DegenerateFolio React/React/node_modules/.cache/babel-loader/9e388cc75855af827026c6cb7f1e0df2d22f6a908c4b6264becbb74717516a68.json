{"ast":null,"code":"import { catchError, EMPTY, tap } from 'rxjs';\nimport { isFunction, nextTick } from '@polkadot/util';\nexport function promiseTracker(resolve, reject) {\n  let isCompleted = false;\n  return {\n    reject: error => {\n      if (!isCompleted) {\n        isCompleted = true;\n        reject(error);\n      }\n      return EMPTY;\n    },\n    resolve: value => {\n      if (!isCompleted) {\n        isCompleted = true;\n        resolve(value);\n      }\n    }\n  };\n}\nfunction extractArgs(args, needsCallback) {\n  const actualArgs = args.slice();\n  // If the last arg is a function, we pop it, put it into callback.\n  // actualArgs will then hold the actual arguments to be passed to `method`\n  const callback = args.length && isFunction(args[args.length - 1]) ? actualArgs.pop() : undefined;\n  // When we need a subscription, ensure that a valid callback is actually passed\n  if (needsCallback && !isFunction(callback)) {\n    throw new Error('Expected a callback to be passed with subscriptions');\n  }\n  return [actualArgs, callback];\n}\nfunction decorateCall(method, args) {\n  return new Promise((resolve, reject) => {\n    // single result tracker - either reject with Error or resolve with Codec result\n    const tracker = promiseTracker(resolve, reject);\n    // encoding errors reject immediately, any result unsubscribes and resolves\n    const subscription = method(...args).pipe(catchError(error => tracker.reject(error))).subscribe(result => {\n      tracker.resolve(result);\n      nextTick(() => subscription.unsubscribe());\n    });\n  });\n}\nfunction decorateSubscribe(method, args, resultCb) {\n  return new Promise((resolve, reject) => {\n    // either reject with error or resolve with unsubscribe callback\n    const tracker = promiseTracker(resolve, reject);\n    // errors reject immediately, the first result resolves with an unsubscribe promise, all results via callback\n    const subscription = method(...args).pipe(catchError(error => tracker.reject(error)), tap(() => tracker.resolve(() => subscription.unsubscribe()))).subscribe(result => {\n      // queue result (back of queue to clear current)\n      nextTick(() => resultCb(result));\n    });\n  });\n}\n/**\n * @description Decorate method for ApiPromise, where the results are converted to the Promise equivalent\n */\nexport function toPromiseMethod(method, options) {\n  const needsCallback = !!(options?.methodName && options.methodName.includes('subscribe'));\n  return function (...args) {\n    const [actualArgs, resultCb] = extractArgs(args, needsCallback);\n    return resultCb ? decorateSubscribe(method, actualArgs, resultCb) : decorateCall(options?.overrideNoSub || method, actualArgs);\n  };\n}","map":{"version":3,"names":["catchError","EMPTY","tap","isFunction","nextTick","promiseTracker","resolve","reject","isCompleted","error","value","extractArgs","args","needsCallback","actualArgs","slice","callback","length","pop","undefined","Error","decorateCall","method","Promise","tracker","subscription","pipe","subscribe","result","unsubscribe","decorateSubscribe","resultCb","toPromiseMethod","options","methodName","includes","overrideNoSub"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api/promise/decorateMethod.js"],"sourcesContent":["import { catchError, EMPTY, tap } from 'rxjs';\nimport { isFunction, nextTick } from '@polkadot/util';\nexport function promiseTracker(resolve, reject) {\n    let isCompleted = false;\n    return {\n        reject: (error) => {\n            if (!isCompleted) {\n                isCompleted = true;\n                reject(error);\n            }\n            return EMPTY;\n        },\n        resolve: (value) => {\n            if (!isCompleted) {\n                isCompleted = true;\n                resolve(value);\n            }\n        }\n    };\n}\nfunction extractArgs(args, needsCallback) {\n    const actualArgs = args.slice();\n    // If the last arg is a function, we pop it, put it into callback.\n    // actualArgs will then hold the actual arguments to be passed to `method`\n    const callback = (args.length && isFunction(args[args.length - 1]))\n        ? actualArgs.pop()\n        : undefined;\n    // When we need a subscription, ensure that a valid callback is actually passed\n    if (needsCallback && !isFunction(callback)) {\n        throw new Error('Expected a callback to be passed with subscriptions');\n    }\n    return [actualArgs, callback];\n}\nfunction decorateCall(method, args) {\n    return new Promise((resolve, reject) => {\n        // single result tracker - either reject with Error or resolve with Codec result\n        const tracker = promiseTracker(resolve, reject);\n        // encoding errors reject immediately, any result unsubscribes and resolves\n        const subscription = method(...args)\n            .pipe(catchError((error) => tracker.reject(error)))\n            .subscribe((result) => {\n            tracker.resolve(result);\n            nextTick(() => subscription.unsubscribe());\n        });\n    });\n}\nfunction decorateSubscribe(method, args, resultCb) {\n    return new Promise((resolve, reject) => {\n        // either reject with error or resolve with unsubscribe callback\n        const tracker = promiseTracker(resolve, reject);\n        // errors reject immediately, the first result resolves with an unsubscribe promise, all results via callback\n        const subscription = method(...args)\n            .pipe(catchError((error) => tracker.reject(error)), tap(() => tracker.resolve(() => subscription.unsubscribe())))\n            .subscribe((result) => {\n            // queue result (back of queue to clear current)\n            nextTick(() => resultCb(result));\n        });\n    });\n}\n/**\n * @description Decorate method for ApiPromise, where the results are converted to the Promise equivalent\n */\nexport function toPromiseMethod(method, options) {\n    const needsCallback = !!(options?.methodName && options.methodName.includes('subscribe'));\n    return function (...args) {\n        const [actualArgs, resultCb] = extractArgs(args, needsCallback);\n        return resultCb\n            ? decorateSubscribe(method, actualArgs, resultCb)\n            : decorateCall(options?.overrideNoSub || method, actualArgs);\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}