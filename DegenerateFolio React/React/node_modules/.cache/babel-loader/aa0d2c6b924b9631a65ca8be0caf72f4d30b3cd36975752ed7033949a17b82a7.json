{"ast":null,"code":"import _defineProperty from \"/home/ryoitsu/Documents/test/react-todo-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { Struct } from '@polkadot/types-codec';\nimport { isU8a, isUndefined, objectProperties, objectSpread, stringify, u8aToHex } from '@polkadot/util';\nimport { EMPTY_U8A, IMMORTAL_ERA } from '../constants.js';\nimport { GenericExtrinsicPayloadV4 } from './ExtrinsicPayload.js';\nconst FAKE_SIGNATURE = new Uint8Array(256).fill(1);\nfunction toAddress(registry, address) {\n  return registry.createTypeUnsafe('Address', [isU8a(address) ? u8aToHex(address) : address]);\n}\n/**\n * @name GenericExtrinsicSignatureV4\n * @description\n * A container for the [[Signature]] associated with a specific [[Extrinsic]]\n */\nexport class GenericExtrinsicSignatureV4 extends Struct {\n  constructor(registry, value) {\n    let {\n      isSigned\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const signTypes = registry.getSignedExtensionTypes();\n    super(registry, objectSpread(\n    // eslint-disable-next-line sort-keys\n    {\n      signer: 'Address',\n      signature: 'ExtrinsicSignature'\n    }, signTypes), GenericExtrinsicSignatureV4.decodeExtrinsicSignature(value, isSigned));\n    _defineProperty(this, \"__internal__signKeys\", void 0);\n    this.__internal__signKeys = Object.keys(signTypes);\n    objectProperties(this, this.__internal__signKeys, k => this.get(k));\n  }\n  /** @internal */\n  static decodeExtrinsicSignature(value) {\n    let isSigned = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!value) {\n      return EMPTY_U8A;\n    } else if (value instanceof GenericExtrinsicSignatureV4) {\n      return value;\n    }\n    return isSigned ? value : EMPTY_U8A;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    return this.isSigned ? super.encodedLength : 0;\n  }\n  /**\n   * @description `true` if the signature is valid\n   */\n  get isSigned() {\n    return !this.signature.isEmpty;\n  }\n  /**\n   * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to\n   */\n  get era() {\n    return this.getT('era');\n  }\n  /**\n   * @description The [[Index]] for the signature\n   */\n  get nonce() {\n    return this.getT('nonce');\n  }\n  /**\n   * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]\n   */\n  get signature() {\n    // the second case here is when we don't have an enum signature, treat as raw\n    return this.multiSignature.value || this.multiSignature;\n  }\n  /**\n   * @description The raw [[ExtrinsicSignature]]\n   */\n  get multiSignature() {\n    return this.getT('signature');\n  }\n  /**\n   * @description The [[Address]] that signed\n   */\n  get signer() {\n    return this.getT('signer');\n  }\n  /**\n   * @description The [[Balance]] tip\n   */\n  get tip() {\n    return this.getT('tip');\n  }\n  /**\n   * @description The [[u32]] or [[MultiLocation]] assetId\n   */\n  get assetId() {\n    return this.getT('assetId');\n  }\n  _injectSignature(signer, signature, payload) {\n    // use the fields exposed to guide the getters\n    for (let i = 0, count = this.__internal__signKeys.length; i < count; i++) {\n      const k = this.__internal__signKeys[i];\n      const v = payload.get(k);\n      if (!isUndefined(v)) {\n        this.set(k, v);\n      }\n    }\n    // additional fields (exposed in struct itself)\n    this.set('signer', signer);\n    this.set('signature', signature);\n    return this;\n  }\n  /**\n   * @description Adds a raw signature\n   */\n  addSignature(signer, signature, payload) {\n    return this._injectSignature(toAddress(this.registry, signer), this.registry.createTypeUnsafe('ExtrinsicSignature', [signature]), new GenericExtrinsicPayloadV4(this.registry, payload));\n  }\n  /**\n   * @description Creates a payload from the supplied options\n   */\n  createPayload(method, options) {\n    const {\n      era,\n      runtimeVersion: {\n        specVersion,\n        transactionVersion\n      }\n    } = options;\n    return new GenericExtrinsicPayloadV4(this.registry, objectSpread({}, options, {\n      era: era || IMMORTAL_ERA,\n      method: method.toHex(),\n      specVersion,\n      transactionVersion\n    }));\n  }\n  /**\n   * @description Generate a payload and applies the signature from a keypair\n   */\n  sign(method, account, options) {\n    if (!(account !== null && account !== void 0 && account.addressRaw)) {\n      throw new Error(\"Expected a valid keypair for signing, found \".concat(stringify(account)));\n    }\n    const payload = this.createPayload(method, options);\n    return this._injectSignature(toAddress(this.registry, account.addressRaw), this.registry.createTypeUnsafe('ExtrinsicSignature', [payload.sign(account)]), payload);\n  }\n  /**\n   * @description Generate a payload and applies a fake signature\n   */\n  signFake(method, address, options) {\n    if (!address) {\n      throw new Error(\"Expected a valid address for signing, found \".concat(stringify(address)));\n    }\n    const payload = this.createPayload(method, options);\n    return this._injectSignature(toAddress(this.registry, address), this.registry.createTypeUnsafe('ExtrinsicSignature', [FAKE_SIGNATURE]), payload);\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    return this.isSigned ? super.toU8a(isBare) : EMPTY_U8A;\n  }\n}","map":{"version":3,"names":["Struct","isU8a","isUndefined","objectProperties","objectSpread","stringify","u8aToHex","EMPTY_U8A","IMMORTAL_ERA","GenericExtrinsicPayloadV4","FAKE_SIGNATURE","Uint8Array","fill","toAddress","registry","address","createTypeUnsafe","GenericExtrinsicSignatureV4","constructor","value","isSigned","arguments","length","undefined","signTypes","getSignedExtensionTypes","signer","signature","decodeExtrinsicSignature","_defineProperty","__internal__signKeys","Object","keys","k","get","encodedLength","isEmpty","era","getT","nonce","multiSignature","tip","assetId","_injectSignature","payload","i","count","v","set","addSignature","createPayload","method","options","runtimeVersion","specVersion","transactionVersion","toHex","sign","account","addressRaw","Error","concat","signFake","toU8a","isBare"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/extrinsic/v4/ExtrinsicSignature.js"],"sourcesContent":["import { Struct } from '@polkadot/types-codec';\nimport { isU8a, isUndefined, objectProperties, objectSpread, stringify, u8aToHex } from '@polkadot/util';\nimport { EMPTY_U8A, IMMORTAL_ERA } from '../constants.js';\nimport { GenericExtrinsicPayloadV4 } from './ExtrinsicPayload.js';\nconst FAKE_SIGNATURE = new Uint8Array(256).fill(1);\nfunction toAddress(registry, address) {\n    return registry.createTypeUnsafe('Address', [isU8a(address) ? u8aToHex(address) : address]);\n}\n/**\n * @name GenericExtrinsicSignatureV4\n * @description\n * A container for the [[Signature]] associated with a specific [[Extrinsic]]\n */\nexport class GenericExtrinsicSignatureV4 extends Struct {\n    __internal__signKeys;\n    constructor(registry, value, { isSigned } = {}) {\n        const signTypes = registry.getSignedExtensionTypes();\n        super(registry, objectSpread(\n        // eslint-disable-next-line sort-keys\n        { signer: 'Address', signature: 'ExtrinsicSignature' }, signTypes), GenericExtrinsicSignatureV4.decodeExtrinsicSignature(value, isSigned));\n        this.__internal__signKeys = Object.keys(signTypes);\n        objectProperties(this, this.__internal__signKeys, (k) => this.get(k));\n    }\n    /** @internal */\n    static decodeExtrinsicSignature(value, isSigned = false) {\n        if (!value) {\n            return EMPTY_U8A;\n        }\n        else if (value instanceof GenericExtrinsicSignatureV4) {\n            return value;\n        }\n        return isSigned\n            ? value\n            : EMPTY_U8A;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return this.isSigned\n            ? super.encodedLength\n            : 0;\n    }\n    /**\n     * @description `true` if the signature is valid\n     */\n    get isSigned() {\n        return !this.signature.isEmpty;\n    }\n    /**\n     * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to\n     */\n    get era() {\n        return this.getT('era');\n    }\n    /**\n     * @description The [[Index]] for the signature\n     */\n    get nonce() {\n        return this.getT('nonce');\n    }\n    /**\n     * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]\n     */\n    get signature() {\n        // the second case here is when we don't have an enum signature, treat as raw\n        return (this.multiSignature.value || this.multiSignature);\n    }\n    /**\n     * @description The raw [[ExtrinsicSignature]]\n     */\n    get multiSignature() {\n        return this.getT('signature');\n    }\n    /**\n     * @description The [[Address]] that signed\n     */\n    get signer() {\n        return this.getT('signer');\n    }\n    /**\n     * @description The [[Balance]] tip\n     */\n    get tip() {\n        return this.getT('tip');\n    }\n    /**\n     * @description The [[u32]] or [[MultiLocation]] assetId\n     */\n    get assetId() {\n        return this.getT('assetId');\n    }\n    _injectSignature(signer, signature, payload) {\n        // use the fields exposed to guide the getters\n        for (let i = 0, count = this.__internal__signKeys.length; i < count; i++) {\n            const k = this.__internal__signKeys[i];\n            const v = payload.get(k);\n            if (!isUndefined(v)) {\n                this.set(k, v);\n            }\n        }\n        // additional fields (exposed in struct itself)\n        this.set('signer', signer);\n        this.set('signature', signature);\n        return this;\n    }\n    /**\n     * @description Adds a raw signature\n     */\n    addSignature(signer, signature, payload) {\n        return this._injectSignature(toAddress(this.registry, signer), this.registry.createTypeUnsafe('ExtrinsicSignature', [signature]), new GenericExtrinsicPayloadV4(this.registry, payload));\n    }\n    /**\n     * @description Creates a payload from the supplied options\n     */\n    createPayload(method, options) {\n        const { era, runtimeVersion: { specVersion, transactionVersion } } = options;\n        return new GenericExtrinsicPayloadV4(this.registry, objectSpread({}, options, {\n            era: era || IMMORTAL_ERA,\n            method: method.toHex(),\n            specVersion,\n            transactionVersion\n        }));\n    }\n    /**\n     * @description Generate a payload and applies the signature from a keypair\n     */\n    sign(method, account, options) {\n        if (!account?.addressRaw) {\n            throw new Error(`Expected a valid keypair for signing, found ${stringify(account)}`);\n        }\n        const payload = this.createPayload(method, options);\n        return this._injectSignature(toAddress(this.registry, account.addressRaw), this.registry.createTypeUnsafe('ExtrinsicSignature', [payload.sign(account)]), payload);\n    }\n    /**\n     * @description Generate a payload and applies a fake signature\n     */\n    signFake(method, address, options) {\n        if (!address) {\n            throw new Error(`Expected a valid address for signing, found ${stringify(address)}`);\n        }\n        const payload = this.createPayload(method, options);\n        return this._injectSignature(toAddress(this.registry, address), this.registry.createTypeUnsafe('ExtrinsicSignature', [FAKE_SIGNATURE]), payload);\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        return this.isSigned\n            ? super.toU8a(isBare)\n            : EMPTY_U8A;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}