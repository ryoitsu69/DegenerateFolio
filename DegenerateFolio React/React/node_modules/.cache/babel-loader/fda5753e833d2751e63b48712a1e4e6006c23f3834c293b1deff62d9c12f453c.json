{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/*\n * Licensed to the Software Freedom Conservancy (SFC) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The SFC licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n'use strict';\n\nconst {\n  By,\n  escapeCss\n} = require('./by');\nconst error = require('./error');\n\n/**\n * ISelect interface makes a protocol for all kind of select elements (standard html and custom\n * model)\n *\n * @interface\n */\n// eslint-disable-next-line no-unused-vars\nclass ISelect {\n  /**\n   * @return {!Promise<boolean>} Whether this select element supports selecting multiple options at the same time? This\n   * is done by checking the value of the \"multiple\" attribute.\n   */\n  isMultiple() {} // eslint-disable-line\n\n  /**\n   * @return {!Promise<!Array<!WebElement>>} All options belonging to this select tag\n   */\n  getOptions() {} // eslint-disable-line\n\n  /**\n   * @return {!Promise<!Array<!WebElement>>} All selected options belonging to this select tag\n   */\n  getAllSelectedOptions() {} // eslint-disable-line\n\n  /**\n   * @return {!Promise<!WebElement>} The first selected option in this select tag (or the currently selected option in a\n   * normal select)\n   */\n  getFirstSelectedOption() {} // eslint-disable-line\n\n  /**\n   * Select all options that display text matching the argument. That is, when given \"Bar\" this\n   * would select an option like:\n   *\n   * &lt;option value=\"foo\"&gt;Bar&lt;/option&gt;\n   *\n   * @param {string} text The visible text to match against\n   * @return {Promise<void>}\n   */\n  selectByVisibleText(text) {} // eslint-disable-line\n\n  /**\n   * Select all options that have a value matching the argument. That is, when given \"foo\" this\n   * would select an option like:\n   *\n   * &lt;option value=\"foo\"&gt;Bar&lt;/option&gt;\n   *\n   * @param {string} value The value to match against\n   * @return {Promise<void>}\n   */\n  selectByValue(value) {} // eslint-disable-line\n\n  /**\n   * Select the option at the given index. This is done by examining the \"index\" attribute of an\n   * element, and not merely by counting.\n   *\n   * @param {Number} index The option at this index will be selected\n   * @return {Promise<void>}\n   */\n  selectByIndex(index) {} // eslint-disable-line\n\n  /**\n   * Clear all selected entries. This is only valid when the SELECT supports multiple selections.\n   *\n   * @return {Promise<void>}\n   */\n  deselectAll() {} // eslint-disable-line\n\n  /**\n   * Deselect all options that display text matching the argument. That is, when given \"Bar\" this\n   * would deselect an option like:\n   *\n   * &lt;option value=\"foo\"&gt;Bar&lt;/option&gt;\n   *\n   * @param {string} text The visible text to match against\n   * @return {Promise<void>}\n   */\n  deselectByVisibleText(text) {} // eslint-disable-line\n\n  /**\n   * Deselect all options that have a value matching the argument. That is, when given \"foo\" this\n   * would deselect an option like:\n   *\n   * @param {string} value The value to match against\n   * @return {Promise<void>}\n   */\n  deselectByValue(value) {} // eslint-disable-line\n\n  /**\n   * Deselect the option at the given index. This is done by examining the \"index\" attribute of an\n   * element, and not merely by counting.\n   *\n   * @param {Number} index The option at this index will be deselected\n   * @return {Promise<void>}\n   */\n  deselectByIndex(index) {} // eslint-disable-line\n}\n\n/**\n * @implements ISelect\n */\nclass Select {\n  /**\n   * Create an Select Element\n   * @param {WebElement} element Select WebElement.\n   */\n  constructor(element) {\n    this.element = element;\n    this.element.getAttribute('tagName').then(function (tagName) {\n      if (tagName.toLowerCase() !== 'select') {\n        throw new Error(`Select only works on <select> elements`);\n      }\n    });\n  }\n\n  /**\n   *\n   * Select option with specified index.\n   *\n   * <example>\n   <select id=\"selectbox\">\n   <option value=\"1\">Option 1</option>\n   <option value=\"2\">Option 2</option>\n   <option value=\"3\">Option 3</option>\n   </select>\n   const selectBox = await driver.findElement(By.id(\"selectbox\"));\n   await selectObject.selectByIndex(1);\n   * </example>\n   *\n   * @param index\n   */\n  async selectByIndex(index) {\n    if (index < 0) {\n      throw new Error('Index needs to be 0 or any other positive number');\n    }\n    let options = await this.element.findElements(By.tagName('option'));\n    if (options.length === 0) {\n      throw new Error(\"Select element doesn't contain any option element\");\n    }\n    if (options.length - 1 < index) {\n      throw new Error(`Option with index \"${index}\" not found. Select element only contains ${options.length - 1} option elements`);\n    }\n    for (let option of options) {\n      if ((await option.getAttribute('index')) === index.toString()) {\n        await this.setSelected(option);\n      }\n    }\n  }\n\n  /**\n   *\n   * Select option by specific value.\n   *\n   * <example>\n   <select id=\"selectbox\">\n   <option value=\"1\">Option 1</option>\n   <option value=\"2\">Option 2</option>\n   <option value=\"3\">Option 3</option>\n   </select>\n   const selectBox = await driver.findElement(By.id(\"selectbox\"));\n   await selectObject.selectByVisibleText(\"Option 2\");\n   * </example>\n   *\n   *\n   * @param {string} value value of option element to be selected\n   */\n  async selectByValue(value) {\n    let matched = false;\n    let isMulti = await this.isMultiple();\n    let options = await this.element.findElements({\n      css: 'option[value =' + escapeCss(value) + ']'\n    });\n    for (let option of options) {\n      await this.setSelected(option);\n      if (!isMulti) {\n        return;\n      }\n      matched = true;\n    }\n    if (!matched) {\n      throw new Error(`Cannot locate option with value: ${value}`);\n    }\n  }\n\n  /**\n   *\n   * Select option with displayed text matching the argument.\n   *\n   * <example>\n   <select id=\"selectbox\">\n   <option value=\"1\">Option 1</option>\n   <option value=\"2\">Option 2</option>\n   <option value=\"3\">Option 3</option>\n   </select>\n   const selectBox = await driver.findElement(By.id(\"selectbox\"));\n   await selectObject.selectByVisibleText(\"Option 2\");\n   * </example>\n   *\n   * @param {String|Number} text       text of option element to get selected\n   *\n   */\n  async selectByVisibleText(text) {\n    text = typeof text === 'number' ? text.toString() : text;\n    const normalized = text.trim() // strip leading and trailing white-space characters\n    .replace(/\\s+/, ' '); // replace sequences of whitespace characters by a single space\n\n    /**\n     * find option element using xpath\n     */\n    const formatted = /\"/.test(normalized) ? 'concat(\"' + normalized.split('\"').join('\", \\'\"\\', \"') + '\")' : `\"${normalized}\"`;\n    const dotFormat = `[. = ${formatted}]`;\n    const spaceFormat = `[normalize-space(text()) = ${formatted}]`;\n    const selections = [`./option${dotFormat}`, `./option${spaceFormat}`, `./optgroup/option${dotFormat}`, `./optgroup/option${spaceFormat}`];\n    const optionElement = await this.element.findElement({\n      xpath: selections.join('|')\n    });\n    await this.setSelected(optionElement);\n  }\n\n  /**\n   * Returns a list of all options belonging to this select tag\n   * @returns {!Promise<!Array<!WebElement>>}\n   */\n  async getOptions() {\n    return await this.element.findElements({\n      tagName: 'option'\n    });\n  }\n\n  /**\n   * Returns a boolean value if the select tag is multiple\n   * @returns {Promise<boolean>}\n   */\n  async isMultiple() {\n    return (await this.element.getAttribute('multiple')) !== null;\n  }\n\n  /**\n   * Returns a list of all selected options belonging to this select tag\n   *\n   * @returns {Promise<void>}\n   */\n  async getAllSelectedOptions() {\n    const opts = await this.getOptions();\n    const results = [];\n    for (let options of opts) {\n      if (await options.isSelected()) {\n        results.push(options);\n      }\n    }\n    return results;\n  }\n\n  /**\n   * Returns first Selected Option\n   * @returns {Promise<Element>}\n   */\n  async getFirstSelectedOption() {\n    return (await this.getAllSelectedOptions())[0];\n  }\n\n  /**\n   * Deselects all selected options\n   * @returns {Promise<void>}\n   */\n  async deselectAll() {\n    if (!this.isMultiple()) {\n      throw new Error('You may only deselect all options of a multi-select');\n    }\n    const options = await this.getOptions();\n    for (let option of options) {\n      if (await option.isSelected()) {\n        await option.click();\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {string|Number}text text of option to deselect\n   * @returns {Promise<void>}\n   */\n  async deselectByVisibleText(text) {\n    if (!(await this.isMultiple())) {\n      throw new Error('You may only deselect options of a multi-select');\n    }\n\n    /**\n     * convert value into string\n     */\n    text = typeof text === 'number' ? text.toString() : text;\n    const normalized = text.trim() // strip leading and trailing white-space characters\n    .replace(/\\s+/, ' '); // replace sequences of whitespace characters by a single space\n\n    /**\n     * find option element using xpath\n     */\n    const formatted = /\"/.test(normalized) ? 'concat(\"' + normalized.split('\"').join('\", \\'\"\\', \"') + '\")' : `\"${normalized}\"`;\n    const dotFormat = `[. = ${formatted}]`;\n    const spaceFormat = `[normalize-space(text()) = ${formatted}]`;\n    const selections = [`./option${dotFormat}`, `./option${spaceFormat}`, `./optgroup/option${dotFormat}`, `./optgroup/option${spaceFormat}`];\n    const optionElement = await this.element.findElement({\n      xpath: selections.join('|')\n    });\n    if (await optionElement.isSelected()) {\n      await optionElement.click();\n    }\n  }\n\n  /**\n   *\n   * @param {Number} index       index of option element to deselect\n   * Deselect the option at the given index.\n   * This is done by examining the \"index\"\n   * attribute of an element, and not merely by counting.\n   * @returns {Promise<void>}\n   */\n  async deselectByIndex(index) {\n    if (!(await this.isMultiple())) {\n      throw new Error('You may only deselect options of a multi-select');\n    }\n    if (index < 0) {\n      throw new Error('Index needs to be 0 or any other positive number');\n    }\n    let options = await this.element.findElements(By.tagName('option'));\n    if (options.length === 0) {\n      throw new Error(\"Select element doesn't contain any option element\");\n    }\n    if (options.length - 1 < index) {\n      throw new Error(`Option with index \"${index}\" not found. Select element only contains ${options.length - 1} option elements`);\n    }\n    for (let option of options) {\n      if ((await option.getAttribute('index')) === index.toString()) {\n        if (await option.isSelected()) {\n          await option.click();\n        }\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {String} value value of an option to deselect\n   * @returns {Promise<void>}\n   */\n  async deselectByValue(value) {\n    if (!(await this.isMultiple())) {\n      throw new Error('You may only deselect options of a multi-select');\n    }\n    let matched = false;\n    let options = await this.element.findElements({\n      css: 'option[value =' + escapeCss(value) + ']'\n    });\n    for (let option of options) {\n      if (await option.isSelected()) {\n        await option.click();\n      }\n      matched = true;\n    }\n    if (!matched) {\n      throw new Error(`Cannot locate option with value: ${value}`);\n    }\n  }\n  async setSelected(option) {\n    if (!(await option.isSelected())) {\n      if (!(await option.isEnabled())) {\n        throw new error.UnsupportedOperationError(`You may not select a disabled option`);\n      }\n      await option.click();\n    }\n  }\n}\nmodule.exports = {\n  Select\n};","map":{"version":3,"names":["By","escapeCss","require","error","ISelect","isMultiple","getOptions","getAllSelectedOptions","getFirstSelectedOption","selectByVisibleText","text","selectByValue","value","selectByIndex","index","deselectAll","deselectByVisibleText","deselectByValue","deselectByIndex","Select","constructor","element","getAttribute","then","tagName","toLowerCase","Error","options","findElements","length","option","toString","setSelected","matched","isMulti","css","normalized","trim","replace","formatted","test","split","join","dotFormat","spaceFormat","selections","optionElement","findElement","xpath","opts","results","isSelected","push","click","isEnabled","UnsupportedOperationError","module","exports"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/selenium-webdriver/lib/select.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/*\n * Licensed to the Software Freedom Conservancy (SFC) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The SFC licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n'use strict'\n\nconst { By, escapeCss } = require('./by')\nconst error = require('./error')\n\n/**\n * ISelect interface makes a protocol for all kind of select elements (standard html and custom\n * model)\n *\n * @interface\n */\n// eslint-disable-next-line no-unused-vars\nclass ISelect {\n  /**\n   * @return {!Promise<boolean>} Whether this select element supports selecting multiple options at the same time? This\n   * is done by checking the value of the \"multiple\" attribute.\n   */\n  isMultiple() {} // eslint-disable-line\n\n  /**\n   * @return {!Promise<!Array<!WebElement>>} All options belonging to this select tag\n   */\n  getOptions() {} // eslint-disable-line\n\n  /**\n   * @return {!Promise<!Array<!WebElement>>} All selected options belonging to this select tag\n   */\n  getAllSelectedOptions() {} // eslint-disable-line\n\n  /**\n   * @return {!Promise<!WebElement>} The first selected option in this select tag (or the currently selected option in a\n   * normal select)\n   */\n  getFirstSelectedOption() {} // eslint-disable-line\n\n  /**\n   * Select all options that display text matching the argument. That is, when given \"Bar\" this\n   * would select an option like:\n   *\n   * &lt;option value=\"foo\"&gt;Bar&lt;/option&gt;\n   *\n   * @param {string} text The visible text to match against\n   * @return {Promise<void>}\n   */\n  selectByVisibleText(text) {} // eslint-disable-line\n\n  /**\n   * Select all options that have a value matching the argument. That is, when given \"foo\" this\n   * would select an option like:\n   *\n   * &lt;option value=\"foo\"&gt;Bar&lt;/option&gt;\n   *\n   * @param {string} value The value to match against\n   * @return {Promise<void>}\n   */\n  selectByValue(value) {} // eslint-disable-line\n\n  /**\n   * Select the option at the given index. This is done by examining the \"index\" attribute of an\n   * element, and not merely by counting.\n   *\n   * @param {Number} index The option at this index will be selected\n   * @return {Promise<void>}\n   */\n  selectByIndex(index) {} // eslint-disable-line\n\n  /**\n   * Clear all selected entries. This is only valid when the SELECT supports multiple selections.\n   *\n   * @return {Promise<void>}\n   */\n  deselectAll() {} // eslint-disable-line\n\n  /**\n   * Deselect all options that display text matching the argument. That is, when given \"Bar\" this\n   * would deselect an option like:\n   *\n   * &lt;option value=\"foo\"&gt;Bar&lt;/option&gt;\n   *\n   * @param {string} text The visible text to match against\n   * @return {Promise<void>}\n   */\n  deselectByVisibleText(text) {} // eslint-disable-line\n\n  /**\n   * Deselect all options that have a value matching the argument. That is, when given \"foo\" this\n   * would deselect an option like:\n   *\n   * @param {string} value The value to match against\n   * @return {Promise<void>}\n   */\n  deselectByValue(value) {} // eslint-disable-line\n\n  /**\n   * Deselect the option at the given index. This is done by examining the \"index\" attribute of an\n   * element, and not merely by counting.\n   *\n   * @param {Number} index The option at this index will be deselected\n   * @return {Promise<void>}\n   */\n  deselectByIndex(index) {} // eslint-disable-line\n}\n\n/**\n * @implements ISelect\n */\nclass Select {\n  /**\n   * Create an Select Element\n   * @param {WebElement} element Select WebElement.\n   */\n  constructor(element) {\n    this.element = element\n\n    this.element.getAttribute('tagName').then(function (tagName) {\n      if (tagName.toLowerCase() !== 'select') {\n        throw new Error(`Select only works on <select> elements`)\n      }\n    })\n  }\n\n  /**\n   *\n   * Select option with specified index.\n   *\n   * <example>\n   <select id=\"selectbox\">\n   <option value=\"1\">Option 1</option>\n   <option value=\"2\">Option 2</option>\n   <option value=\"3\">Option 3</option>\n   </select>\n   const selectBox = await driver.findElement(By.id(\"selectbox\"));\n   await selectObject.selectByIndex(1);\n   * </example>\n   *\n   * @param index\n   */\n  async selectByIndex(index) {\n    if (index < 0) {\n      throw new Error('Index needs to be 0 or any other positive number')\n    }\n\n    let options = await this.element.findElements(By.tagName('option'))\n\n    if (options.length === 0) {\n      throw new Error(\"Select element doesn't contain any option element\")\n    }\n\n    if (options.length - 1 < index) {\n      throw new Error(\n        `Option with index \"${index}\" not found. Select element only contains ${options.length - 1} option elements`,\n      )\n    }\n\n    for (let option of options) {\n      if ((await option.getAttribute('index')) === index.toString()) {\n        await this.setSelected(option)\n      }\n    }\n  }\n\n  /**\n   *\n   * Select option by specific value.\n   *\n   * <example>\n   <select id=\"selectbox\">\n   <option value=\"1\">Option 1</option>\n   <option value=\"2\">Option 2</option>\n   <option value=\"3\">Option 3</option>\n   </select>\n   const selectBox = await driver.findElement(By.id(\"selectbox\"));\n   await selectObject.selectByVisibleText(\"Option 2\");\n   * </example>\n   *\n   *\n   * @param {string} value value of option element to be selected\n   */\n  async selectByValue(value) {\n    let matched = false\n    let isMulti = await this.isMultiple()\n\n    let options = await this.element.findElements({\n      css: 'option[value =' + escapeCss(value) + ']',\n    })\n\n    for (let option of options) {\n      await this.setSelected(option)\n\n      if (!isMulti) {\n        return\n      }\n      matched = true\n    }\n\n    if (!matched) {\n      throw new Error(`Cannot locate option with value: ${value}`)\n    }\n  }\n\n  /**\n   *\n   * Select option with displayed text matching the argument.\n   *\n   * <example>\n   <select id=\"selectbox\">\n   <option value=\"1\">Option 1</option>\n   <option value=\"2\">Option 2</option>\n   <option value=\"3\">Option 3</option>\n   </select>\n   const selectBox = await driver.findElement(By.id(\"selectbox\"));\n   await selectObject.selectByVisibleText(\"Option 2\");\n   * </example>\n   *\n   * @param {String|Number} text       text of option element to get selected\n   *\n   */\n  async selectByVisibleText(text) {\n    text = typeof text === 'number' ? text.toString() : text\n\n    const normalized = text\n      .trim() // strip leading and trailing white-space characters\n      .replace(/\\s+/, ' ') // replace sequences of whitespace characters by a single space\n\n    /**\n     * find option element using xpath\n     */\n    const formatted = /\"/.test(normalized)\n      ? 'concat(\"' + normalized.split('\"').join('\", \\'\"\\', \"') + '\")'\n      : `\"${normalized}\"`\n    const dotFormat = `[. = ${formatted}]`\n    const spaceFormat = `[normalize-space(text()) = ${formatted}]`\n\n    const selections = [\n      `./option${dotFormat}`,\n      `./option${spaceFormat}`,\n      `./optgroup/option${dotFormat}`,\n      `./optgroup/option${spaceFormat}`,\n    ]\n\n    const optionElement = await this.element.findElement({\n      xpath: selections.join('|'),\n    })\n    await this.setSelected(optionElement)\n  }\n\n  /**\n   * Returns a list of all options belonging to this select tag\n   * @returns {!Promise<!Array<!WebElement>>}\n   */\n  async getOptions() {\n    return await this.element.findElements({ tagName: 'option' })\n  }\n\n  /**\n   * Returns a boolean value if the select tag is multiple\n   * @returns {Promise<boolean>}\n   */\n  async isMultiple() {\n    return (await this.element.getAttribute('multiple')) !== null\n  }\n\n  /**\n   * Returns a list of all selected options belonging to this select tag\n   *\n   * @returns {Promise<void>}\n   */\n  async getAllSelectedOptions() {\n    const opts = await this.getOptions()\n    const results = []\n    for (let options of opts) {\n      if (await options.isSelected()) {\n        results.push(options)\n      }\n    }\n    return results\n  }\n\n  /**\n   * Returns first Selected Option\n   * @returns {Promise<Element>}\n   */\n  async getFirstSelectedOption() {\n    return (await this.getAllSelectedOptions())[0]\n  }\n\n  /**\n   * Deselects all selected options\n   * @returns {Promise<void>}\n   */\n  async deselectAll() {\n    if (!this.isMultiple()) {\n      throw new Error('You may only deselect all options of a multi-select')\n    }\n\n    const options = await this.getOptions()\n\n    for (let option of options) {\n      if (await option.isSelected()) {\n        await option.click()\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {string|Number}text text of option to deselect\n   * @returns {Promise<void>}\n   */\n  async deselectByVisibleText(text) {\n    if (!(await this.isMultiple())) {\n      throw new Error('You may only deselect options of a multi-select')\n    }\n\n    /**\n     * convert value into string\n     */\n    text = typeof text === 'number' ? text.toString() : text\n\n    const normalized = text\n      .trim() // strip leading and trailing white-space characters\n      .replace(/\\s+/, ' ') // replace sequences of whitespace characters by a single space\n\n    /**\n     * find option element using xpath\n     */\n    const formatted = /\"/.test(normalized)\n      ? 'concat(\"' + normalized.split('\"').join('\", \\'\"\\', \"') + '\")'\n      : `\"${normalized}\"`\n    const dotFormat = `[. = ${formatted}]`\n    const spaceFormat = `[normalize-space(text()) = ${formatted}]`\n\n    const selections = [\n      `./option${dotFormat}`,\n      `./option${spaceFormat}`,\n      `./optgroup/option${dotFormat}`,\n      `./optgroup/option${spaceFormat}`,\n    ]\n\n    const optionElement = await this.element.findElement({\n      xpath: selections.join('|'),\n    })\n    if (await optionElement.isSelected()) {\n      await optionElement.click()\n    }\n  }\n\n  /**\n   *\n   * @param {Number} index       index of option element to deselect\n   * Deselect the option at the given index.\n   * This is done by examining the \"index\"\n   * attribute of an element, and not merely by counting.\n   * @returns {Promise<void>}\n   */\n  async deselectByIndex(index) {\n    if (!(await this.isMultiple())) {\n      throw new Error('You may only deselect options of a multi-select')\n    }\n\n    if (index < 0) {\n      throw new Error('Index needs to be 0 or any other positive number')\n    }\n\n    let options = await this.element.findElements(By.tagName('option'))\n\n    if (options.length === 0) {\n      throw new Error(\"Select element doesn't contain any option element\")\n    }\n\n    if (options.length - 1 < index) {\n      throw new Error(\n        `Option with index \"${index}\" not found. Select element only contains ${options.length - 1} option elements`,\n      )\n    }\n\n    for (let option of options) {\n      if ((await option.getAttribute('index')) === index.toString()) {\n        if (await option.isSelected()) {\n          await option.click()\n        }\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {String} value value of an option to deselect\n   * @returns {Promise<void>}\n   */\n  async deselectByValue(value) {\n    if (!(await this.isMultiple())) {\n      throw new Error('You may only deselect options of a multi-select')\n    }\n\n    let matched = false\n\n    let options = await this.element.findElements({\n      css: 'option[value =' + escapeCss(value) + ']',\n    })\n\n    for (let option of options) {\n      if (await option.isSelected()) {\n        await option.click()\n      }\n      matched = true\n    }\n\n    if (!matched) {\n      throw new Error(`Cannot locate option with value: ${value}`)\n    }\n  }\n\n  async setSelected(option) {\n    if (!(await option.isSelected())) {\n      if (!(await option.isEnabled())) {\n        throw new error.UnsupportedOperationError(`You may not select a disabled option`)\n      }\n      await option.click()\n    }\n  }\n}\n\nmodule.exports = { Select }\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAM;EAAEA,EAAE;EAAEC;AAAU,CAAC,GAAGC,OAAO,CAAC,MAAM,CAAC;AACzC,MAAMC,KAAK,GAAGD,OAAO,CAAC,SAAS,CAAC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,OAAO,CAAC;EACZ;AACF;AACA;AACA;EACEC,UAAUA,CAAA,EAAG,CAAC,CAAC,CAAC;;EAEhB;AACF;AACA;EACEC,UAAUA,CAAA,EAAG,CAAC,CAAC,CAAC;;EAEhB;AACF;AACA;EACEC,qBAAqBA,CAAA,EAAG,CAAC,CAAC,CAAC;;EAE3B;AACF;AACA;AACA;EACEC,sBAAsBA,CAAA,EAAG,CAAC,CAAC,CAAC;;EAE5B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,mBAAmBA,CAACC,IAAI,EAAE,CAAC,CAAC,CAAC;;EAE7B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,aAAaA,CAACC,KAAK,EAAE,CAAC,CAAC,CAAC;;EAExB;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,aAAaA,CAACC,KAAK,EAAE,CAAC,CAAC,CAAC;;EAExB;AACF;AACA;AACA;AACA;EACEC,WAAWA,CAAA,EAAG,CAAC,CAAC,CAAC;;EAEjB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,qBAAqBA,CAACN,IAAI,EAAE,CAAC,CAAC,CAAC;;EAE/B;AACF;AACA;AACA;AACA;AACA;AACA;EACEO,eAAeA,CAACL,KAAK,EAAE,CAAC,CAAC,CAAC;;EAE1B;AACF;AACA;AACA;AACA;AACA;AACA;EACEM,eAAeA,CAACJ,KAAK,EAAE,CAAC,CAAC,CAAC;AAC5B;;AAEA;AACA;AACA;AACA,MAAMK,MAAM,CAAC;EACX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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}