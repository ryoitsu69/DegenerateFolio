{"ast":null,"code":"import { EventEmitter } from 'eventemitter3';\nimport { isChildClass, isNull, isUndefined, logger, noop, objectSpread, stringify } from '@polkadot/util';\nimport { xglobal } from '@polkadot/x-global';\nimport { WebSocket } from '@polkadot/x-ws';\nimport { RpcCoder } from '../coder/index.js';\nimport defaults from '../defaults.js';\nimport { DEFAULT_CAPACITY, LRUCache } from '../lru.js';\nimport { getWSErrorString } from './errors.js';\nconst ALIASES = {\n  chain_finalisedHead: 'chain_finalizedHead',\n  chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',\n  chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'\n};\nconst RETRY_DELAY = 2500;\nconst DEFAULT_TIMEOUT_MS = 60 * 1000;\nconst TIMEOUT_INTERVAL = 5000;\nconst l = logger('api-ws');\n/** @internal Clears a Record<*> of all keys, optionally with all callback on clear */\nfunction eraseRecord(record, cb) {\n  Object.keys(record).forEach(key => {\n    if (cb) {\n      cb(record[key]);\n    }\n    delete record[key];\n  });\n}\n/** @internal Creates a default/empty stats object */\nfunction defaultEndpointStats() {\n  return {\n    bytesRecv: 0,\n    bytesSent: 0,\n    cached: 0,\n    errors: 0,\n    requests: 0,\n    subscriptions: 0,\n    timeout: 0\n  };\n}\n/**\n * # @polkadot/rpc-provider/ws\n *\n * @name WsProvider\n *\n * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Api from '@polkadot/api/promise';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const api = new Api(provider);\n * ```\n *\n * @see [[HttpProvider]]\n */\nexport class WsProvider {\n  __internal__callCache;\n  __internal__coder;\n  __internal__endpoints;\n  __internal__headers;\n  __internal__eventemitter;\n  __internal__handlers = {};\n  __internal__isReadyPromise;\n  __internal__stats;\n  __internal__waitingForId = {};\n  __internal__autoConnectMs;\n  __internal__endpointIndex;\n  __internal__endpointStats;\n  __internal__isConnected = false;\n  __internal__subscriptions = {};\n  __internal__timeoutId = null;\n  __internal__websocket;\n  __internal__timeout;\n  /**\n   * @param {string | string[]}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.\n   * @param {number | false} autoConnectMs Whether to connect automatically or not (default). Provided value is used as a delay between retries.\n   * @param {Record<string, string>} headers The headers provided to the underlying WebSocket\n   * @param {number} [timeout] Custom timeout value used per request . Defaults to `DEFAULT_TIMEOUT_MS`\n   */\n  constructor(endpoint = defaults.WS_URL, autoConnectMs = RETRY_DELAY, headers = {}, timeout, cacheCapacity) {\n    const endpoints = Array.isArray(endpoint) ? endpoint : [endpoint];\n    if (endpoints.length === 0) {\n      throw new Error('WsProvider requires at least one Endpoint');\n    }\n    endpoints.forEach(endpoint => {\n      if (!/^(wss|ws):\\/\\//.test(endpoint)) {\n        throw new Error(`Endpoint should start with 'ws://', received '${endpoint}'`);\n      }\n    });\n    this.__internal__callCache = new LRUCache(cacheCapacity || DEFAULT_CAPACITY);\n    this.__internal__eventemitter = new EventEmitter();\n    this.__internal__autoConnectMs = autoConnectMs || 0;\n    this.__internal__coder = new RpcCoder();\n    this.__internal__endpointIndex = -1;\n    this.__internal__endpoints = endpoints;\n    this.__internal__headers = headers;\n    this.__internal__websocket = null;\n    this.__internal__stats = {\n      active: {\n        requests: 0,\n        subscriptions: 0\n      },\n      total: defaultEndpointStats()\n    };\n    this.__internal__endpointStats = defaultEndpointStats();\n    this.__internal__timeout = timeout || DEFAULT_TIMEOUT_MS;\n    if (autoConnectMs && autoConnectMs > 0) {\n      this.connectWithRetry().catch(noop);\n    }\n    this.__internal__isReadyPromise = new Promise(resolve => {\n      this.__internal__eventemitter.once('connected', () => {\n        resolve(this);\n      });\n    });\n  }\n  /**\n   * @summary `true` when this provider supports subscriptions\n   */\n  get hasSubscriptions() {\n    return !!true;\n  }\n  /**\n   * @summary `true` when this provider supports clone()\n   */\n  get isClonable() {\n    return !!true;\n  }\n  /**\n   * @summary Whether the node is connected or not.\n   * @return {boolean} true if connected\n   */\n  get isConnected() {\n    return this.__internal__isConnected;\n  }\n  /**\n   * @description Promise that resolves the first time we are connected and loaded\n   */\n  get isReady() {\n    return this.__internal__isReadyPromise;\n  }\n  get endpoint() {\n    return this.__internal__endpoints[this.__internal__endpointIndex];\n  }\n  /**\n   * @description Returns a clone of the object\n   */\n  clone() {\n    return new WsProvider(this.__internal__endpoints);\n  }\n  selectEndpointIndex(endpoints) {\n    return (this.__internal__endpointIndex + 1) % endpoints.length;\n  }\n  /**\n   * @summary Manually connect\n   * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may\n   * connect manually using this method.\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async connect() {\n    if (this.__internal__websocket) {\n      throw new Error('WebSocket is already connected');\n    }\n    try {\n      this.__internal__endpointIndex = this.selectEndpointIndex(this.__internal__endpoints);\n      // the as here is Deno-specific - not available on the globalThis\n      this.__internal__websocket = typeof xglobal.WebSocket !== 'undefined' && isChildClass(xglobal.WebSocket, WebSocket) ? new WebSocket(this.endpoint)\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore - WS may be an instance of ws, which supports options\n      : new WebSocket(this.endpoint, undefined, {\n        headers: this.__internal__headers\n      });\n      if (this.__internal__websocket) {\n        this.__internal__websocket.onclose = this.__internal__onSocketClose;\n        this.__internal__websocket.onerror = this.__internal__onSocketError;\n        this.__internal__websocket.onmessage = this.__internal__onSocketMessage;\n        this.__internal__websocket.onopen = this.__internal__onSocketOpen;\n      }\n      // timeout any handlers that have not had a response\n      this.__internal__timeoutId = setInterval(() => this.__internal__timeoutHandlers(), TIMEOUT_INTERVAL);\n    } catch (error) {\n      l.error(error);\n      this.__internal__emit('error', error);\n      throw error;\n    }\n  }\n  /**\n   * @description Connect, never throwing an error, but rather forcing a retry\n   */\n  async connectWithRetry() {\n    if (this.__internal__autoConnectMs > 0) {\n      try {\n        await this.connect();\n      } catch {\n        setTimeout(() => {\n          this.connectWithRetry().catch(noop);\n        }, this.__internal__autoConnectMs);\n      }\n    }\n  }\n  /**\n   * @description Manually disconnect from the connection, clearing auto-connect logic\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async disconnect() {\n    // switch off autoConnect, we are in manual mode now\n    this.__internal__autoConnectMs = 0;\n    try {\n      if (this.__internal__websocket) {\n        // 1000 - Normal closure; the connection successfully completed\n        this.__internal__websocket.close(1000);\n      }\n    } catch (error) {\n      l.error(error);\n      this.__internal__emit('error', error);\n      throw error;\n    }\n  }\n  /**\n   * @description Returns the connection stats\n   */\n  get stats() {\n    return {\n      active: {\n        requests: Object.keys(this.__internal__handlers).length,\n        subscriptions: Object.keys(this.__internal__subscriptions).length\n      },\n      total: this.__internal__stats.total\n    };\n  }\n  get endpointStats() {\n    return this.__internal__endpointStats;\n  }\n  /**\n   * @summary Listens on events after having subscribed using the [[subscribe]] function.\n   * @param  {ProviderInterfaceEmitted} type Event\n   * @param  {ProviderInterfaceEmitCb}  sub  Callback\n   * @return unsubscribe function\n   */\n  on(type, sub) {\n    this.__internal__eventemitter.on(type, sub);\n    return () => {\n      this.__internal__eventemitter.removeListener(type, sub);\n    };\n  }\n  /**\n   * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.\n   * @param method The RPC methods to execute\n   * @param params Encoded parameters as applicable for the method\n   * @param subscription Subscription details (internally used)\n   */\n  send(method, params, isCacheable, subscription) {\n    this.__internal__endpointStats.requests++;\n    this.__internal__stats.total.requests++;\n    const [id, body] = this.__internal__coder.encodeJson(method, params);\n    const cacheKey = isCacheable ? `${method}::${stringify(params)}` : '';\n    let resultPromise = isCacheable ? this.__internal__callCache.get(cacheKey) : null;\n    if (!resultPromise) {\n      resultPromise = this.__internal__send(id, body, method, params, subscription);\n      if (isCacheable) {\n        this.__internal__callCache.set(cacheKey, resultPromise);\n      }\n    } else {\n      this.__internal__endpointStats.cached++;\n      this.__internal__stats.total.cached++;\n    }\n    return resultPromise;\n  }\n  async __internal__send(id, body, method, params, subscription) {\n    return new Promise((resolve, reject) => {\n      try {\n        if (!this.isConnected || this.__internal__websocket === null) {\n          throw new Error('WebSocket is not connected');\n        }\n        const callback = (error, result) => {\n          error ? reject(error) : resolve(result);\n        };\n        l.debug(() => ['calling', method, body]);\n        this.__internal__handlers[id] = {\n          callback,\n          method,\n          params,\n          start: Date.now(),\n          subscription\n        };\n        const bytesSent = body.length;\n        this.__internal__endpointStats.bytesSent += bytesSent;\n        this.__internal__stats.total.bytesSent += bytesSent;\n        this.__internal__websocket.send(body);\n      } catch (error) {\n        this.__internal__endpointStats.errors++;\n        this.__internal__stats.total.errors++;\n        reject(error);\n      }\n    });\n  }\n  /**\n   * @name subscribe\n   * @summary Allows subscribing to a specific event.\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * const provider = new WsProvider('ws://127.0.0.1:9944');\n   * const rpc = new Rpc(provider);\n   *\n   * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {\n   *   console.log(values)\n   * }).then((subscriptionId) => {\n   *   console.log('balance changes subscription id: ', subscriptionId)\n   * })\n   * ```\n   */\n  subscribe(type, method, params, callback) {\n    this.__internal__endpointStats.subscriptions++;\n    this.__internal__stats.total.subscriptions++;\n    // subscriptions are not cached, LRU applies to .at(<blockHash>) only\n    return this.send(method, params, false, {\n      callback,\n      type\n    });\n  }\n  /**\n   * @summary Allows unsubscribing to subscriptions made with [[subscribe]].\n   */\n  async unsubscribe(type, method, id) {\n    const subscription = `${type}::${id}`;\n    // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub\n    // the assigned id now does not match what the API user originally received. It has\n    // a slight complication in solving - since we cannot rely on the send id, but rather\n    // need to find the actual subscription id to map it\n    if (isUndefined(this.__internal__subscriptions[subscription])) {\n      l.debug(() => `Unable to find active subscription=${subscription}`);\n      return false;\n    }\n    delete this.__internal__subscriptions[subscription];\n    try {\n      return this.isConnected && !isNull(this.__internal__websocket) ? this.send(method, [id]) : true;\n    } catch {\n      return false;\n    }\n  }\n  __internal__emit = (type, ...args) => {\n    this.__internal__eventemitter.emit(type, ...args);\n  };\n  __internal__onSocketClose = event => {\n    const error = new Error(`disconnected from ${this.endpoint}: ${event.code}:: ${event.reason || getWSErrorString(event.code)}`);\n    if (this.__internal__autoConnectMs > 0) {\n      l.error(error.message);\n    }\n    this.__internal__isConnected = false;\n    if (this.__internal__websocket) {\n      this.__internal__websocket.onclose = null;\n      this.__internal__websocket.onerror = null;\n      this.__internal__websocket.onmessage = null;\n      this.__internal__websocket.onopen = null;\n      this.__internal__websocket = null;\n    }\n    if (this.__internal__timeoutId) {\n      clearInterval(this.__internal__timeoutId);\n      this.__internal__timeoutId = null;\n    }\n    // reject all hanging requests\n    eraseRecord(this.__internal__handlers, h => {\n      try {\n        h.callback(error, undefined);\n      } catch (err) {\n        // does not throw\n        l.error(err);\n      }\n    });\n    eraseRecord(this.__internal__waitingForId);\n    // Reset stats for active endpoint\n    this.__internal__endpointStats = defaultEndpointStats();\n    this.__internal__emit('disconnected');\n    if (this.__internal__autoConnectMs > 0) {\n      setTimeout(() => {\n        this.connectWithRetry().catch(noop);\n      }, this.__internal__autoConnectMs);\n    }\n  };\n  __internal__onSocketError = error => {\n    l.debug(() => ['socket error', error]);\n    this.__internal__emit('error', error);\n  };\n  __internal__onSocketMessage = message => {\n    l.debug(() => ['received', message.data]);\n    const bytesRecv = message.data.length;\n    this.__internal__endpointStats.bytesRecv += bytesRecv;\n    this.__internal__stats.total.bytesRecv += bytesRecv;\n    const response = JSON.parse(message.data);\n    return isUndefined(response.method) ? this.__internal__onSocketMessageResult(response) : this.__internal__onSocketMessageSubscribe(response);\n  };\n  __internal__onSocketMessageResult = response => {\n    const handler = this.__internal__handlers[response.id];\n    if (!handler) {\n      l.debug(() => `Unable to find handler for id=${response.id}`);\n      return;\n    }\n    try {\n      const {\n        method,\n        params,\n        subscription\n      } = handler;\n      const result = this.__internal__coder.decodeResponse(response);\n      // first send the result - in case of subs, we may have an update\n      // immediately if we have some queued results already\n      handler.callback(null, result);\n      if (subscription) {\n        const subId = `${subscription.type}::${result}`;\n        this.__internal__subscriptions[subId] = objectSpread({}, subscription, {\n          method,\n          params\n        });\n        // if we have a result waiting for this subscription already\n        if (this.__internal__waitingForId[subId]) {\n          this.__internal__onSocketMessageSubscribe(this.__internal__waitingForId[subId]);\n        }\n      }\n    } catch (error) {\n      this.__internal__endpointStats.errors++;\n      this.__internal__stats.total.errors++;\n      handler.callback(error, undefined);\n    }\n    delete this.__internal__handlers[response.id];\n  };\n  __internal__onSocketMessageSubscribe = response => {\n    if (!response.method) {\n      throw new Error('No method found in JSONRPC response');\n    }\n    const method = ALIASES[response.method] || response.method;\n    const subId = `${method}::${response.params.subscription}`;\n    const handler = this.__internal__subscriptions[subId];\n    if (!handler) {\n      // store the JSON, we could have out-of-order subid coming in\n      this.__internal__waitingForId[subId] = response;\n      l.debug(() => `Unable to find handler for subscription=${subId}`);\n      return;\n    }\n    // housekeeping\n    delete this.__internal__waitingForId[subId];\n    try {\n      const result = this.__internal__coder.decodeResponse(response);\n      handler.callback(null, result);\n    } catch (error) {\n      this.__internal__endpointStats.errors++;\n      this.__internal__stats.total.errors++;\n      handler.callback(error, undefined);\n    }\n  };\n  __internal__onSocketOpen = () => {\n    if (this.__internal__websocket === null) {\n      throw new Error('WebSocket cannot be null in onOpen');\n    }\n    l.debug(() => ['connected to', this.endpoint]);\n    this.__internal__isConnected = true;\n    this.__internal__resubscribe();\n    this.__internal__emit('connected');\n    return true;\n  };\n  __internal__resubscribe = () => {\n    const subscriptions = this.__internal__subscriptions;\n    this.__internal__subscriptions = {};\n    Promise.all(Object.keys(subscriptions).map(async id => {\n      const {\n        callback,\n        method,\n        params,\n        type\n      } = subscriptions[id];\n      // only re-create subscriptions which are not in author (only area where\n      // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n      // are not included (and will not be re-broadcast)\n      if (type.startsWith('author_')) {\n        return;\n      }\n      try {\n        await this.subscribe(type, method, params, callback);\n      } catch (error) {\n        l.error(error);\n      }\n    })).catch(l.error);\n  };\n  __internal__timeoutHandlers = () => {\n    const now = Date.now();\n    const ids = Object.keys(this.__internal__handlers);\n    for (let i = 0, count = ids.length; i < count; i++) {\n      const handler = this.__internal__handlers[ids[i]];\n      if (now - handler.start > this.__internal__timeout) {\n        try {\n          handler.callback(new Error(`No response received from RPC endpoint in ${this.__internal__timeout / 1000}s`), undefined);\n        } catch {\n          // ignore\n        }\n        this.__internal__endpointStats.timeout++;\n        this.__internal__stats.total.timeout++;\n        delete this.__internal__handlers[ids[i]];\n      }\n    }\n  };\n}","map":{"version":3,"names":["EventEmitter","isChildClass","isNull","isUndefined","logger","noop","objectSpread","stringify","xglobal","WebSocket","RpcCoder","defaults","DEFAULT_CAPACITY","LRUCache","getWSErrorString","ALIASES","chain_finalisedHead","chain_subscribeFinalisedHeads","chain_unsubscribeFinalisedHeads","RETRY_DELAY","DEFAULT_TIMEOUT_MS","TIMEOUT_INTERVAL","l","eraseRecord","record","cb","Object","keys","forEach","key","defaultEndpointStats","bytesRecv","bytesSent","cached","errors","requests","subscriptions","timeout","WsProvider","__internal__callCache","__internal__coder","__internal__endpoints","__internal__headers","__internal__eventemitter","__internal__handlers","__internal__isReadyPromise","__internal__stats","__internal__waitingForId","__internal__autoConnectMs","__internal__endpointIndex","__internal__endpointStats","__internal__isConnected","__internal__subscriptions","__internal__timeoutId","__internal__websocket","__internal__timeout","constructor","endpoint","WS_URL","autoConnectMs","headers","cacheCapacity","endpoints","Array","isArray","length","Error","test","active","total","connectWithRetry","catch","Promise","resolve","once","hasSubscriptions","isClonable","isConnected","isReady","clone","selectEndpointIndex","connect","undefined","onclose","__internal__onSocketClose","onerror","__internal__onSocketError","onmessage","__internal__onSocketMessage","onopen","__internal__onSocketOpen","setInterval","__internal__timeoutHandlers","error","__internal__emit","setTimeout","disconnect","close","stats","endpointStats","on","type","sub","removeListener","send","method","params","isCacheable","subscription","id","body","encodeJson","cacheKey","resultPromise","get","__internal__send","set","reject","callback","result","debug","start","Date","now","subscribe","unsubscribe","args","emit","event","code","reason","message","clearInterval","h","err","data","response","JSON","parse","__internal__onSocketMessageResult","__internal__onSocketMessageSubscribe","handler","decodeResponse","subId","__internal__resubscribe","all","map","startsWith","ids","i","count"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/rpc-provider/ws/index.js"],"sourcesContent":["import { EventEmitter } from 'eventemitter3';\nimport { isChildClass, isNull, isUndefined, logger, noop, objectSpread, stringify } from '@polkadot/util';\nimport { xglobal } from '@polkadot/x-global';\nimport { WebSocket } from '@polkadot/x-ws';\nimport { RpcCoder } from '../coder/index.js';\nimport defaults from '../defaults.js';\nimport { DEFAULT_CAPACITY, LRUCache } from '../lru.js';\nimport { getWSErrorString } from './errors.js';\nconst ALIASES = {\n    chain_finalisedHead: 'chain_finalizedHead',\n    chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',\n    chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'\n};\nconst RETRY_DELAY = 2500;\nconst DEFAULT_TIMEOUT_MS = 60 * 1000;\nconst TIMEOUT_INTERVAL = 5000;\nconst l = logger('api-ws');\n/** @internal Clears a Record<*> of all keys, optionally with all callback on clear */\nfunction eraseRecord(record, cb) {\n    Object.keys(record).forEach((key) => {\n        if (cb) {\n            cb(record[key]);\n        }\n        delete record[key];\n    });\n}\n/** @internal Creates a default/empty stats object */\nfunction defaultEndpointStats() {\n    return { bytesRecv: 0, bytesSent: 0, cached: 0, errors: 0, requests: 0, subscriptions: 0, timeout: 0 };\n}\n/**\n * # @polkadot/rpc-provider/ws\n *\n * @name WsProvider\n *\n * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Api from '@polkadot/api/promise';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const api = new Api(provider);\n * ```\n *\n * @see [[HttpProvider]]\n */\nexport class WsProvider {\n    __internal__callCache;\n    __internal__coder;\n    __internal__endpoints;\n    __internal__headers;\n    __internal__eventemitter;\n    __internal__handlers = {};\n    __internal__isReadyPromise;\n    __internal__stats;\n    __internal__waitingForId = {};\n    __internal__autoConnectMs;\n    __internal__endpointIndex;\n    __internal__endpointStats;\n    __internal__isConnected = false;\n    __internal__subscriptions = {};\n    __internal__timeoutId = null;\n    __internal__websocket;\n    __internal__timeout;\n    /**\n     * @param {string | string[]}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.\n     * @param {number | false} autoConnectMs Whether to connect automatically or not (default). Provided value is used as a delay between retries.\n     * @param {Record<string, string>} headers The headers provided to the underlying WebSocket\n     * @param {number} [timeout] Custom timeout value used per request . Defaults to `DEFAULT_TIMEOUT_MS`\n     */\n    constructor(endpoint = defaults.WS_URL, autoConnectMs = RETRY_DELAY, headers = {}, timeout, cacheCapacity) {\n        const endpoints = Array.isArray(endpoint)\n            ? endpoint\n            : [endpoint];\n        if (endpoints.length === 0) {\n            throw new Error('WsProvider requires at least one Endpoint');\n        }\n        endpoints.forEach((endpoint) => {\n            if (!/^(wss|ws):\\/\\//.test(endpoint)) {\n                throw new Error(`Endpoint should start with 'ws://', received '${endpoint}'`);\n            }\n        });\n        this.__internal__callCache = new LRUCache(cacheCapacity || DEFAULT_CAPACITY);\n        this.__internal__eventemitter = new EventEmitter();\n        this.__internal__autoConnectMs = autoConnectMs || 0;\n        this.__internal__coder = new RpcCoder();\n        this.__internal__endpointIndex = -1;\n        this.__internal__endpoints = endpoints;\n        this.__internal__headers = headers;\n        this.__internal__websocket = null;\n        this.__internal__stats = {\n            active: { requests: 0, subscriptions: 0 },\n            total: defaultEndpointStats()\n        };\n        this.__internal__endpointStats = defaultEndpointStats();\n        this.__internal__timeout = timeout || DEFAULT_TIMEOUT_MS;\n        if (autoConnectMs && autoConnectMs > 0) {\n            this.connectWithRetry().catch(noop);\n        }\n        this.__internal__isReadyPromise = new Promise((resolve) => {\n            this.__internal__eventemitter.once('connected', () => {\n                resolve(this);\n            });\n        });\n    }\n    /**\n     * @summary `true` when this provider supports subscriptions\n     */\n    get hasSubscriptions() {\n        return !!true;\n    }\n    /**\n     * @summary `true` when this provider supports clone()\n     */\n    get isClonable() {\n        return !!true;\n    }\n    /**\n     * @summary Whether the node is connected or not.\n     * @return {boolean} true if connected\n     */\n    get isConnected() {\n        return this.__internal__isConnected;\n    }\n    /**\n     * @description Promise that resolves the first time we are connected and loaded\n     */\n    get isReady() {\n        return this.__internal__isReadyPromise;\n    }\n    get endpoint() {\n        return this.__internal__endpoints[this.__internal__endpointIndex];\n    }\n    /**\n     * @description Returns a clone of the object\n     */\n    clone() {\n        return new WsProvider(this.__internal__endpoints);\n    }\n    selectEndpointIndex(endpoints) {\n        return (this.__internal__endpointIndex + 1) % endpoints.length;\n    }\n    /**\n     * @summary Manually connect\n     * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may\n     * connect manually using this method.\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async connect() {\n        if (this.__internal__websocket) {\n            throw new Error('WebSocket is already connected');\n        }\n        try {\n            this.__internal__endpointIndex = this.selectEndpointIndex(this.__internal__endpoints);\n            // the as here is Deno-specific - not available on the globalThis\n            this.__internal__websocket = typeof xglobal.WebSocket !== 'undefined' && isChildClass(xglobal.WebSocket, WebSocket)\n                ? new WebSocket(this.endpoint)\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore - WS may be an instance of ws, which supports options\n                : new WebSocket(this.endpoint, undefined, {\n                    headers: this.__internal__headers\n                });\n            if (this.__internal__websocket) {\n                this.__internal__websocket.onclose = this.__internal__onSocketClose;\n                this.__internal__websocket.onerror = this.__internal__onSocketError;\n                this.__internal__websocket.onmessage = this.__internal__onSocketMessage;\n                this.__internal__websocket.onopen = this.__internal__onSocketOpen;\n            }\n            // timeout any handlers that have not had a response\n            this.__internal__timeoutId = setInterval(() => this.__internal__timeoutHandlers(), TIMEOUT_INTERVAL);\n        }\n        catch (error) {\n            l.error(error);\n            this.__internal__emit('error', error);\n            throw error;\n        }\n    }\n    /**\n     * @description Connect, never throwing an error, but rather forcing a retry\n     */\n    async connectWithRetry() {\n        if (this.__internal__autoConnectMs > 0) {\n            try {\n                await this.connect();\n            }\n            catch {\n                setTimeout(() => {\n                    this.connectWithRetry().catch(noop);\n                }, this.__internal__autoConnectMs);\n            }\n        }\n    }\n    /**\n     * @description Manually disconnect from the connection, clearing auto-connect logic\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async disconnect() {\n        // switch off autoConnect, we are in manual mode now\n        this.__internal__autoConnectMs = 0;\n        try {\n            if (this.__internal__websocket) {\n                // 1000 - Normal closure; the connection successfully completed\n                this.__internal__websocket.close(1000);\n            }\n        }\n        catch (error) {\n            l.error(error);\n            this.__internal__emit('error', error);\n            throw error;\n        }\n    }\n    /**\n     * @description Returns the connection stats\n     */\n    get stats() {\n        return {\n            active: {\n                requests: Object.keys(this.__internal__handlers).length,\n                subscriptions: Object.keys(this.__internal__subscriptions).length\n            },\n            total: this.__internal__stats.total\n        };\n    }\n    get endpointStats() {\n        return this.__internal__endpointStats;\n    }\n    /**\n     * @summary Listens on events after having subscribed using the [[subscribe]] function.\n     * @param  {ProviderInterfaceEmitted} type Event\n     * @param  {ProviderInterfaceEmitCb}  sub  Callback\n     * @return unsubscribe function\n     */\n    on(type, sub) {\n        this.__internal__eventemitter.on(type, sub);\n        return () => {\n            this.__internal__eventemitter.removeListener(type, sub);\n        };\n    }\n    /**\n     * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.\n     * @param method The RPC methods to execute\n     * @param params Encoded parameters as applicable for the method\n     * @param subscription Subscription details (internally used)\n     */\n    send(method, params, isCacheable, subscription) {\n        this.__internal__endpointStats.requests++;\n        this.__internal__stats.total.requests++;\n        const [id, body] = this.__internal__coder.encodeJson(method, params);\n        const cacheKey = isCacheable ? `${method}::${stringify(params)}` : '';\n        let resultPromise = isCacheable\n            ? this.__internal__callCache.get(cacheKey)\n            : null;\n        if (!resultPromise) {\n            resultPromise = this.__internal__send(id, body, method, params, subscription);\n            if (isCacheable) {\n                this.__internal__callCache.set(cacheKey, resultPromise);\n            }\n        }\n        else {\n            this.__internal__endpointStats.cached++;\n            this.__internal__stats.total.cached++;\n        }\n        return resultPromise;\n    }\n    async __internal__send(id, body, method, params, subscription) {\n        return new Promise((resolve, reject) => {\n            try {\n                if (!this.isConnected || this.__internal__websocket === null) {\n                    throw new Error('WebSocket is not connected');\n                }\n                const callback = (error, result) => {\n                    error\n                        ? reject(error)\n                        : resolve(result);\n                };\n                l.debug(() => ['calling', method, body]);\n                this.__internal__handlers[id] = {\n                    callback,\n                    method,\n                    params,\n                    start: Date.now(),\n                    subscription\n                };\n                const bytesSent = body.length;\n                this.__internal__endpointStats.bytesSent += bytesSent;\n                this.__internal__stats.total.bytesSent += bytesSent;\n                this.__internal__websocket.send(body);\n            }\n            catch (error) {\n                this.__internal__endpointStats.errors++;\n                this.__internal__stats.total.errors++;\n                reject(error);\n            }\n        });\n    }\n    /**\n     * @name subscribe\n     * @summary Allows subscribing to a specific event.\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * const provider = new WsProvider('ws://127.0.0.1:9944');\n     * const rpc = new Rpc(provider);\n     *\n     * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {\n     *   console.log(values)\n     * }).then((subscriptionId) => {\n     *   console.log('balance changes subscription id: ', subscriptionId)\n     * })\n     * ```\n     */\n    subscribe(type, method, params, callback) {\n        this.__internal__endpointStats.subscriptions++;\n        this.__internal__stats.total.subscriptions++;\n        // subscriptions are not cached, LRU applies to .at(<blockHash>) only\n        return this.send(method, params, false, { callback, type });\n    }\n    /**\n     * @summary Allows unsubscribing to subscriptions made with [[subscribe]].\n     */\n    async unsubscribe(type, method, id) {\n        const subscription = `${type}::${id}`;\n        // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub\n        // the assigned id now does not match what the API user originally received. It has\n        // a slight complication in solving - since we cannot rely on the send id, but rather\n        // need to find the actual subscription id to map it\n        if (isUndefined(this.__internal__subscriptions[subscription])) {\n            l.debug(() => `Unable to find active subscription=${subscription}`);\n            return false;\n        }\n        delete this.__internal__subscriptions[subscription];\n        try {\n            return this.isConnected && !isNull(this.__internal__websocket)\n                ? this.send(method, [id])\n                : true;\n        }\n        catch {\n            return false;\n        }\n    }\n    __internal__emit = (type, ...args) => {\n        this.__internal__eventemitter.emit(type, ...args);\n    };\n    __internal__onSocketClose = (event) => {\n        const error = new Error(`disconnected from ${this.endpoint}: ${event.code}:: ${event.reason || getWSErrorString(event.code)}`);\n        if (this.__internal__autoConnectMs > 0) {\n            l.error(error.message);\n        }\n        this.__internal__isConnected = false;\n        if (this.__internal__websocket) {\n            this.__internal__websocket.onclose = null;\n            this.__internal__websocket.onerror = null;\n            this.__internal__websocket.onmessage = null;\n            this.__internal__websocket.onopen = null;\n            this.__internal__websocket = null;\n        }\n        if (this.__internal__timeoutId) {\n            clearInterval(this.__internal__timeoutId);\n            this.__internal__timeoutId = null;\n        }\n        // reject all hanging requests\n        eraseRecord(this.__internal__handlers, (h) => {\n            try {\n                h.callback(error, undefined);\n            }\n            catch (err) {\n                // does not throw\n                l.error(err);\n            }\n        });\n        eraseRecord(this.__internal__waitingForId);\n        // Reset stats for active endpoint\n        this.__internal__endpointStats = defaultEndpointStats();\n        this.__internal__emit('disconnected');\n        if (this.__internal__autoConnectMs > 0) {\n            setTimeout(() => {\n                this.connectWithRetry().catch(noop);\n            }, this.__internal__autoConnectMs);\n        }\n    };\n    __internal__onSocketError = (error) => {\n        l.debug(() => ['socket error', error]);\n        this.__internal__emit('error', error);\n    };\n    __internal__onSocketMessage = (message) => {\n        l.debug(() => ['received', message.data]);\n        const bytesRecv = message.data.length;\n        this.__internal__endpointStats.bytesRecv += bytesRecv;\n        this.__internal__stats.total.bytesRecv += bytesRecv;\n        const response = JSON.parse(message.data);\n        return isUndefined(response.method)\n            ? this.__internal__onSocketMessageResult(response)\n            : this.__internal__onSocketMessageSubscribe(response);\n    };\n    __internal__onSocketMessageResult = (response) => {\n        const handler = this.__internal__handlers[response.id];\n        if (!handler) {\n            l.debug(() => `Unable to find handler for id=${response.id}`);\n            return;\n        }\n        try {\n            const { method, params, subscription } = handler;\n            const result = this.__internal__coder.decodeResponse(response);\n            // first send the result - in case of subs, we may have an update\n            // immediately if we have some queued results already\n            handler.callback(null, result);\n            if (subscription) {\n                const subId = `${subscription.type}::${result}`;\n                this.__internal__subscriptions[subId] = objectSpread({}, subscription, {\n                    method,\n                    params\n                });\n                // if we have a result waiting for this subscription already\n                if (this.__internal__waitingForId[subId]) {\n                    this.__internal__onSocketMessageSubscribe(this.__internal__waitingForId[subId]);\n                }\n            }\n        }\n        catch (error) {\n            this.__internal__endpointStats.errors++;\n            this.__internal__stats.total.errors++;\n            handler.callback(error, undefined);\n        }\n        delete this.__internal__handlers[response.id];\n    };\n    __internal__onSocketMessageSubscribe = (response) => {\n        if (!response.method) {\n            throw new Error('No method found in JSONRPC response');\n        }\n        const method = ALIASES[response.method] || response.method;\n        const subId = `${method}::${response.params.subscription}`;\n        const handler = this.__internal__subscriptions[subId];\n        if (!handler) {\n            // store the JSON, we could have out-of-order subid coming in\n            this.__internal__waitingForId[subId] = response;\n            l.debug(() => `Unable to find handler for subscription=${subId}`);\n            return;\n        }\n        // housekeeping\n        delete this.__internal__waitingForId[subId];\n        try {\n            const result = this.__internal__coder.decodeResponse(response);\n            handler.callback(null, result);\n        }\n        catch (error) {\n            this.__internal__endpointStats.errors++;\n            this.__internal__stats.total.errors++;\n            handler.callback(error, undefined);\n        }\n    };\n    __internal__onSocketOpen = () => {\n        if (this.__internal__websocket === null) {\n            throw new Error('WebSocket cannot be null in onOpen');\n        }\n        l.debug(() => ['connected to', this.endpoint]);\n        this.__internal__isConnected = true;\n        this.__internal__resubscribe();\n        this.__internal__emit('connected');\n        return true;\n    };\n    __internal__resubscribe = () => {\n        const subscriptions = this.__internal__subscriptions;\n        this.__internal__subscriptions = {};\n        Promise.all(Object.keys(subscriptions).map(async (id) => {\n            const { callback, method, params, type } = subscriptions[id];\n            // only re-create subscriptions which are not in author (only area where\n            // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n            // are not included (and will not be re-broadcast)\n            if (type.startsWith('author_')) {\n                return;\n            }\n            try {\n                await this.subscribe(type, method, params, callback);\n            }\n            catch (error) {\n                l.error(error);\n            }\n        })).catch(l.error);\n    };\n    __internal__timeoutHandlers = () => {\n        const now = Date.now();\n        const ids = Object.keys(this.__internal__handlers);\n        for (let i = 0, count = ids.length; i < count; i++) {\n            const handler = this.__internal__handlers[ids[i]];\n            if ((now - handler.start) > this.__internal__timeout) {\n                try {\n                    handler.callback(new Error(`No response received from RPC endpoint in ${this.__internal__timeout / 1000}s`), undefined);\n                }\n                catch {\n                    // ignore\n                }\n                this.__internal__endpointStats.timeout++;\n                this.__internal__stats.total.timeout++;\n                delete this.__internal__handlers[ids[i]];\n            }\n        }\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}