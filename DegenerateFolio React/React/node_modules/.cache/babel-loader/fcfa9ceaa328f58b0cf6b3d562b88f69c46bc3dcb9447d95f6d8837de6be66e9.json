{"ast":null,"code":"var _jsxFileName = \"/home/ryoitsu/Documents/test/react-todo-app/src/index.js\";\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport ShadertoyReact from \"shadertoy-react\";\nimport './css/index.css';\nimport TodoApp from './components/todo.jsx';\nimport reportWebVitals from './reportWebVitals';\nimport vertex from './shaders/mosaic/mosaic.vert';\nimport fragment from './shaders/mosaic/mosaic.frag';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nconst fragmentShader = `\n // by srtuss, 2013\n\n // rotate position around axis\n vec2 rotate(vec2 p, float a)\n {\n     return vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n }\n\n // 1D random numbers\n float rand(float n)\n {\n     return fract(sin(n) * 43758.5453123);\n }\n\n // 2D random numbers\n vec2 rand2(in vec2 p)\n {\n     return fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n }\n\n // 1D noise\n float noise1(float p)\n {\n     float fl = floor(p);\n     float fc = fract(p);\n     return mix(rand(fl), rand(fl + 1.0), fc);\n }\n\n // voronoi distance noise, based on iq's articles\n float voronoi(in vec2 x)\n {\n     vec2 p = floor(x);\n     vec2 f = fract(x);\n\n     vec2 res = vec2(8.0);\n     for(int j = -1; j <= 1; j ++)\n     {\n         for(int i = -1; i <= 1; i ++)\n         {\n             vec2 b = vec2(i, j);\n             vec2 r = vec2(b) - f + rand2(p + b);\n\n             // chebyshev distance, one of many ways to do this\n             float d = max(abs(r.x), abs(r.y));\n\n             if(d < res.x)\n             {\n                 res.y = res.x;\n                 res.x = d;\n             }\n             else if(d < res.y)\n             {\n                 res.y = d;\n             }\n         }\n     }\n     return res.y - res.x;\n }\n\n\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n     float flicker = noise1(iTime * 2.0) * 0.8 + 0.4;\n\n     vec2 uv = fragCoord.xy / iResolution.xy;\n     uv = (uv - 0.5) * 2.0;\n     vec2 suv = uv;\n     uv.x *= iResolution.x / iResolution.y;\n\n\n     float v = 0.0;\n\n     // that looks highly interesting:\n     //v = 1.0 - length(uv) * 1.3;\n\n\n     // a bit of camera movement\n     uv *= 0.6 + sin(iTime * 0.1) * 0.4;\n     uv = rotate(uv, sin(iTime * 0.3) * 1.0);\n     uv += iTime * 0.4;\n\n\n     // add some noise octaves\n     float a = 0.6, f = 1.0;\n\n     for(int i = 0; i < 3; i ++) // 4 octaves also look nice, its getting a bit slow though\n     {\n         float v1 = voronoi(uv * f + 5.0);\n         float v2 = 0.0;\n\n         // make the moving electrons-effect for higher octaves\n         if(i > 0)\n         {\n             // of course everything based on voronoi\n             v2 = voronoi(uv * f * 0.5 + 50.0 + iTime);\n\n             float va = 0.0, vb = 0.0;\n             va = 1.0 - smoothstep(0.0, 0.1, v1);\n             vb = 1.0 - smoothstep(0.0, 0.08, v2);\n             v += a * pow(va * (0.5 + vb), 2.0);\n         }\n\n         // make sharp edges\n         v1 = 1.0 - smoothstep(0.0, 0.3, v1);\n\n         // noise is used as intensity map\n         v2 = a * (noise1(v1 * 5.5 + 0.1));\n\n         // octave 0's intensity changes a bit\n         if(i == 0)\n             v += v2 * flicker;\n         else\n             v += v2;\n\n         f *= 3.0;\n         a *= 0.7;\n     }\n\n     // slight vignetting\n     v *= exp(-0.6 * length(suv)) * 1.2;\n\n     // use texture channel0 for color? why not.\n     vec3 cexp = texture(iChannel0, uv * 0.001).xyz * 3.0 + texture(iChannel0, uv * 0.01).xyz;//vec3(1.0, 2.0, 4.0);\n     cexp *= 1.4;\n\n     // old blueish color set\n     //vec3 cexp = vec3(6.0, 4.0, 2.0);\n\n     vec3 col = vec3(pow(v, cexp.x), pow(v, cexp.y), pow(v, cexp.z)) * 2.0;\n\n     fragColor = vec4(col, 1.0);\n }\n\n `;\nroot.render( /*#__PURE__*/_jsxDEV(_Fragment, {\n  children: [/*#__PURE__*/_jsxDEV(ShadertoyReact, {\n    fs: fragmentShader\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 150,\n    columnNumber: 1\n  }, this), /*#__PURE__*/_jsxDEV(TodoApp, {}, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 151,\n    columnNumber: 1\n  }, this), /*#__PURE__*/_jsxDEV(\"footer\", {\n    children: \"\\xA92024 Ultra Degenerate Labs, No Rights Reserved\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 152,\n    columnNumber: 1\n  }, this)]\n}, void 0, true));\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();","map":{"version":3,"names":["React","ReactDOM","ShadertoyReact","TodoApp","reportWebVitals","vertex","fragment","jsxDEV","_jsxDEV","Fragment","_Fragment","root","createRoot","document","getElementById","fragmentShader","render","children","fs","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/src/index.js"],"sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport ShadertoyReact from \"shadertoy-react\";\nimport './css/index.css';\nimport TodoApp from './components/todo.jsx';\nimport reportWebVitals from './reportWebVitals';\nimport vertex from './shaders/mosaic/mosaic.vert';\nimport fragment from './shaders/mosaic/mosaic.frag';\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n\n const fragmentShader = `\n // by srtuss, 2013\n\n // rotate position around axis\n vec2 rotate(vec2 p, float a)\n {\n     return vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n }\n\n // 1D random numbers\n float rand(float n)\n {\n     return fract(sin(n) * 43758.5453123);\n }\n\n // 2D random numbers\n vec2 rand2(in vec2 p)\n {\n     return fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n }\n\n // 1D noise\n float noise1(float p)\n {\n     float fl = floor(p);\n     float fc = fract(p);\n     return mix(rand(fl), rand(fl + 1.0), fc);\n }\n\n // voronoi distance noise, based on iq's articles\n float voronoi(in vec2 x)\n {\n     vec2 p = floor(x);\n     vec2 f = fract(x);\n\n     vec2 res = vec2(8.0);\n     for(int j = -1; j <= 1; j ++)\n     {\n         for(int i = -1; i <= 1; i ++)\n         {\n             vec2 b = vec2(i, j);\n             vec2 r = vec2(b) - f + rand2(p + b);\n\n             // chebyshev distance, one of many ways to do this\n             float d = max(abs(r.x), abs(r.y));\n\n             if(d < res.x)\n             {\n                 res.y = res.x;\n                 res.x = d;\n             }\n             else if(d < res.y)\n             {\n                 res.y = d;\n             }\n         }\n     }\n     return res.y - res.x;\n }\n\n\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n     float flicker = noise1(iTime * 2.0) * 0.8 + 0.4;\n\n     vec2 uv = fragCoord.xy / iResolution.xy;\n     uv = (uv - 0.5) * 2.0;\n     vec2 suv = uv;\n     uv.x *= iResolution.x / iResolution.y;\n\n\n     float v = 0.0;\n\n     // that looks highly interesting:\n     //v = 1.0 - length(uv) * 1.3;\n\n\n     // a bit of camera movement\n     uv *= 0.6 + sin(iTime * 0.1) * 0.4;\n     uv = rotate(uv, sin(iTime * 0.3) * 1.0);\n     uv += iTime * 0.4;\n\n\n     // add some noise octaves\n     float a = 0.6, f = 1.0;\n\n     for(int i = 0; i < 3; i ++) // 4 octaves also look nice, its getting a bit slow though\n     {\n         float v1 = voronoi(uv * f + 5.0);\n         float v2 = 0.0;\n\n         // make the moving electrons-effect for higher octaves\n         if(i > 0)\n         {\n             // of course everything based on voronoi\n             v2 = voronoi(uv * f * 0.5 + 50.0 + iTime);\n\n             float va = 0.0, vb = 0.0;\n             va = 1.0 - smoothstep(0.0, 0.1, v1);\n             vb = 1.0 - smoothstep(0.0, 0.08, v2);\n             v += a * pow(va * (0.5 + vb), 2.0);\n         }\n\n         // make sharp edges\n         v1 = 1.0 - smoothstep(0.0, 0.3, v1);\n\n         // noise is used as intensity map\n         v2 = a * (noise1(v1 * 5.5 + 0.1));\n\n         // octave 0's intensity changes a bit\n         if(i == 0)\n             v += v2 * flicker;\n         else\n             v += v2;\n\n         f *= 3.0;\n         a *= 0.7;\n     }\n\n     // slight vignetting\n     v *= exp(-0.6 * length(suv)) * 1.2;\n\n     // use texture channel0 for color? why not.\n     vec3 cexp = texture(iChannel0, uv * 0.001).xyz * 3.0 + texture(iChannel0, uv * 0.01).xyz;//vec3(1.0, 2.0, 4.0);\n     cexp *= 1.4;\n\n     // old blueish color set\n     //vec3 cexp = vec3(6.0, 4.0, 2.0);\n\n     vec3 col = vec3(pow(v, cexp.x), pow(v, cexp.y), pow(v, cexp.z)) * 2.0;\n\n     fragColor = vec4(col, 1.0);\n }\n\n `;\n\nroot.render(\n    <>\n<ShadertoyReact fs={fragmentShader} />\n<TodoApp />\n<footer>Â©2024 Ultra Degenerate Labs, No Rights Reserved</footer>\n</>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"mappings":";AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAOC,QAAQ,MAAM,kBAAkB;AACvC,OAAOC,cAAc,MAAM,iBAAiB;AAC5C,OAAO,iBAAiB;AACxB,OAAOC,OAAO,MAAM,uBAAuB;AAC3C,OAAOC,eAAe,MAAM,mBAAmB;AAC/C,OAAOC,MAAM,MAAM,8BAA8B;AACjD,OAAOC,QAAQ,MAAM,8BAA8B;AAAC,SAAAC,MAAA,IAAAC,OAAA,EAAAC,QAAA,IAAAC,SAAA;AACpD,MAAMC,IAAI,GAAGV,QAAQ,CAACW,UAAU,CAACC,QAAQ,CAACC,cAAc,CAAC,MAAM,CAAC,CAAC;AAEhE,MAAMC,cAAc,GAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AAEFJ,IAAI,CAACK,MAAM,eACPR,OAAA,CAAAE,SAAA;EAAAO,QAAA,gBACJT,OAAA,CAACN,cAAc;IAACgB,EAAE,EAAEH;EAAe;IAAAI,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAE,CAAC,eACtCd,OAAA,CAACL,OAAO;IAAAgB,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAE,CAAC,eACXd,OAAA;IAAAS,QAAA,EAAQ;EAA+C;IAAAE,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAQ,CAAC;AAAA,eAC9D,CACF,CAAC;;AAED;AACA;AACA;AACAlB,eAAe,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}