{"ast":null,"code":"import { utils } from \"@pixi/core\";\nimport { convertToList } from \"../utils/convertToList.mjs\";\nimport { createStringVariations } from \"../utils/createStringVariations.mjs\";\nimport { isSingleItem } from \"../utils/isSingleItem.mjs\";\nclass Resolver {\n  constructor() {\n    this._defaultBundleIdentifierOptions = {\n      connector: \"-\",\n      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,\n      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, \"\")\n    }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};\n  }\n  /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */\n  setBundleIdentifier(bundleIdentifier) {\n    if (this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector, this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle(\"foo\", this._createBundleAssetId(\"foo\", \"bar\")) !== \"bar\") throw new Error(\"[Resolver] GenerateBundleAssetId are not working correctly\");\n  }\n  /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: ['format', 'resolution'],\n   *     params:{\n   *         format:'webp', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n   * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n   * @param preferOrders - the prefer options\n   */\n  prefer(...preferOrders) {\n    preferOrders.forEach(prefer => {\n      this._preferredOrder.push(prefer), prefer.priority || (prefer.priority = Object.keys(prefer.params));\n    }), this._resolverHash = {};\n  }\n  /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = 'https://home.com/';\n   * resolver.add('foo', 'bar.ong');\n   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n   * @param basePath - the base path to use\n   */\n  set basePath(basePath) {\n    this._basePath = basePath;\n  }\n  get basePath() {\n    return this._basePath;\n  }\n  /**\n   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = 'https://home.com/some-path/';\n   * resolver.rootPath = 'https://home.com/';\n   * resolver.add('foo', '/bar.png');\n   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n   * @param rootPath - the root path to use\n   */\n  set rootPath(rootPath) {\n    this._rootPath = rootPath;\n  }\n  get rootPath() {\n    return this._rootPath;\n  }\n  /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add('foo', [\n   *     {\n   *         resolution: 2,\n   *         format: 'png',\n   *         src: 'image@2x.png',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:'png',\n   *         src: 'image.png',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n   *         format: value.split('.').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add('foo', [\n   *     'image@2x.png',\n   *     'image.png',\n   * ]);\n   */\n  get parsers() {\n    return this._parsers;\n  }\n  /** Used for testing, this resets the resolver to its initial state */\n  reset() {\n    this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;\n  }\n  /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */\n  setDefaultSearchParams(searchParams) {\n    if (typeof searchParams == \"string\") this._defaultSearchParams = searchParams;else {\n      const queryValues = searchParams;\n      this._defaultSearchParams = Object.keys(queryValues).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join(\"&\");\n    }\n  }\n  /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */\n  getAlias(asset) {\n    const {\n      alias,\n      name,\n      src,\n      srcs\n    } = asset;\n    return convertToList(alias || name || src || srcs, value => typeof value == \"string\" ? value : Array.isArray(value) ? value.map(v => v?.src ?? v?.srcs ?? v) : value?.src || value?.srcs ? value.src ?? value.srcs : value, !0);\n  }\n  /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */\n  addManifest(manifest) {\n    this._manifest && console.warn(\"[Resolver] Manifest already exists, this will be overwritten\"), this._manifest = manifest, manifest.bundles.forEach(bundle => {\n      this.addBundle(bundle.name, bundle.assets);\n    });\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle('animals');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    const assetNames = [];\n    Array.isArray(assets) ? assets.forEach(asset => {\n      const srcs = asset.src ?? asset.srcs,\n        aliases = asset.alias ?? asset.name;\n      let ids;\n      if (typeof aliases == \"string\") {\n        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n        assetNames.push(bundleAssetId), ids = [aliases, bundleAssetId];\n      } else {\n        const bundleIds = aliases.map(name => this._createBundleAssetId(bundleId, name));\n        assetNames.push(...bundleIds), ids = [...aliases, ...bundleIds];\n      }\n      this.add({\n        ...asset,\n        alias: ids,\n        src: srcs\n      });\n    }) : Object.keys(assets).forEach(key => {\n      const aliases = [key, this._createBundleAssetId(bundleId, key)];\n      if (typeof assets[key] == \"string\") this.add({\n        alias: aliases,\n        src: assets[key]\n      });else if (Array.isArray(assets[key])) this.add({\n        alias: aliases,\n        src: assets[key]\n      });else {\n        const asset = assets[key],\n          assetSrc = asset.src ?? asset.srcs;\n        this.add({\n          ...asset,\n          alias: aliases,\n          src: Array.isArray(assetSrc) ? assetSrc : [assetSrc]\n        });\n      }\n      assetNames.push(...aliases);\n    }), this._bundles[bundleId] = assetNames;\n  }\n  add(aliases, srcs, data, format, loadParser) {\n    const assets = [];\n    typeof aliases == \"string\" || Array.isArray(aliases) && typeof aliases[0] == \"string\" ? (utils.deprecation(\"7.2.0\", `Assets.add now uses an object instead of individual parameters.\nPlease use Assets.add({ alias, src, data, format, loadParser }) instead.`), assets.push({\n      alias: aliases,\n      src: srcs,\n      data,\n      format,\n      loadParser\n    })) : Array.isArray(aliases) ? assets.push(...aliases) : assets.push(aliases);\n    let keyCheck;\n    keyCheck = key => {\n      this.hasKey(key) && console.warn(`[Resolver] already has key: ${key} overwriting`);\n    }, convertToList(assets).forEach(asset => {\n      const {\n        src,\n        srcs: srcs2\n      } = asset;\n      let {\n        data: data2,\n        format: format2,\n        loadParser: loadParser2\n      } = asset;\n      const srcsToUse = convertToList(src || srcs2).map(src2 => typeof src2 == \"string\" ? createStringVariations(src2) : Array.isArray(src2) ? src2 : [src2]),\n        aliasesToUse = this.getAlias(asset);\n      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n      const resolvedAssets = [];\n      srcsToUse.forEach(srcs3 => {\n        srcs3.forEach(src2 => {\n          let formattedAsset = {};\n          if (typeof src2 != \"object\") {\n            formattedAsset.src = src2;\n            for (let i = 0; i < this._parsers.length; i++) {\n              const parser = this._parsers[i];\n              if (parser.test(src2)) {\n                formattedAsset = parser.parse(src2);\n                break;\n              }\n            }\n          } else data2 = src2.data ?? data2, format2 = src2.format ?? format2, loadParser2 = src2.loadParser ?? loadParser2, formattedAsset = {\n            ...formattedAsset,\n            ...src2\n          };\n          if (!aliasesToUse) throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n          formattedAsset = this.buildResolvedAsset(formattedAsset, {\n            aliases: aliasesToUse,\n            data: data2,\n            format: format2,\n            loadParser: loadParser2\n          }), resolvedAssets.push(formattedAsset);\n        });\n      }), aliasesToUse.forEach(alias => {\n        this._assetMap[alias] = resolvedAssets;\n      });\n    });\n  }\n  // TODO: this needs an overload like load did in Assets\n  /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle('load-screen');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */\n  resolveBundle(bundleIds) {\n    const singleAsset = isSingleItem(bundleIds);\n    bundleIds = convertToList(bundleIds);\n    const out = {};\n    return bundleIds.forEach(bundleId => {\n      const assetNames = this._bundles[bundleId];\n      if (assetNames) {\n        const results = this.resolve(assetNames),\n          assets = {};\n        for (const key in results) {\n          const asset = results[key];\n          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n        }\n        out[bundleId] = assets;\n      }\n    }), singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */\n  resolveUrl(key) {\n    const result = this.resolve(key);\n    if (typeof key != \"string\") {\n      const out = {};\n      for (const i in result) out[i] = result[i].src;\n      return out;\n    }\n    return result.src;\n  }\n  resolve(keys) {\n    const singleAsset = isSingleItem(keys);\n    keys = convertToList(keys);\n    const result = {};\n    return keys.forEach(key => {\n      if (!this._resolverHash[key]) if (this._assetMap[key]) {\n        let assets = this._assetMap[key];\n        const bestAsset = assets[0],\n          preferredOrder = this._getPreferredOrder(assets);\n        preferredOrder?.priority.forEach(priorityKey => {\n          preferredOrder.params[priorityKey].forEach(value => {\n            const filteredAssets = assets.filter(asset => asset[priorityKey] ? asset[priorityKey] === value : !1);\n            filteredAssets.length && (assets = filteredAssets);\n          });\n        }), this._resolverHash[key] = assets[0] ?? bestAsset;\n      } else this._resolverHash[key] = this.buildResolvedAsset({\n        alias: [key],\n        src: key\n      }, {});\n      result[key] = this._resolverHash[key];\n    }), singleAsset ? result[keys[0]] : result;\n  }\n  /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */\n  hasKey(key) {\n    return !!this._assetMap[key];\n  }\n  /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */\n  hasBundle(key) {\n    return !!this._bundles[key];\n  }\n  /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */\n  _getPreferredOrder(assets) {\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[0],\n        preferred = this._preferredOrder.find(preference => preference.params.format.includes(asset.format));\n      if (preferred) return preferred;\n    }\n    return this._preferredOrder[0];\n  }\n  /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */\n  _appendDefaultSearchParams(url) {\n    if (!this._defaultSearchParams) return url;\n    const paramConnector = /\\?/.test(url) ? \"&\" : \"?\";\n    return `${url}${paramConnector}${this._defaultSearchParams}`;\n  }\n  buildResolvedAsset(formattedAsset, data) {\n    const {\n      aliases,\n      data: assetData,\n      loadParser,\n      format\n    } = data;\n    return (this._basePath || this._rootPath) && (formattedAsset.src = utils.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath)), formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src], formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src), formattedAsset.data = {\n      ...(assetData || {}),\n      ...formattedAsset.data\n    }, formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser, formattedAsset.format = format ?? formattedAsset.format ?? utils.path.extname(formattedAsset.src).slice(1), formattedAsset.srcs = formattedAsset.src, formattedAsset.name = formattedAsset.alias, formattedAsset;\n  }\n}\nexport { Resolver };","map":{"version":3,"names":["Resolver","constructor","_defaultBundleIdentifierOptions","connector","createBundleAssetId","bundleId","assetId","_bundleIdConnector","extractAssetIdFromBundle","assetBundleId","replace","_createBundleAssetId","_extractAssetIdFromBundle","_assetMap","_preferredOrder","_parsers","_resolverHash","_bundles","setBundleIdentifier","bundleIdentifier","Error","prefer","preferOrders","forEach","push","priority","Object","keys","params","basePath","_basePath","rootPath","_rootPath","parsers","reset","_manifest","_defaultSearchParams","setDefaultSearchParams","searchParams","queryValues","map","key","encodeURIComponent","join","getAlias","asset","alias","name","src","srcs","convertToList","value","Array","isArray","v","addManifest","manifest","console","warn","bundles","bundle","addBundle","assets","assetNames","aliases","ids","bundleAssetId","bundleIds","add","assetSrc","data","format","loadParser","utils","deprecation","keyCheck","hasKey","srcs2","data2","format2","loadParser2","srcsToUse","src2","createStringVariations","aliasesToUse","resolvedAssets","srcs3","formattedAsset","i","length","parser","test","parse","buildResolvedAsset","resolveBundle","singleAsset","isSingleItem","out","results","resolve","resolveUrl","result","bestAsset","preferredOrder","_getPreferredOrder","priorityKey","filteredAssets","filter","hasBundle","preferred","find","preference","includes","_appendDefaultSearchParams","url","paramConnector","assetData","path","toAbsolute","extname","slice"],"sources":["/home/ryoitsu/node_modules/@pixi/assets/src/resolver/Resolver.ts"],"sourcesContent":["import { utils } from '@pixi/core';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type {\n    ArrayOr,\n    AssetsBundle,\n    AssetsManifest,\n    AssetSrc,\n    LoadParserName,\n    ResolvedAsset,\n    ResolvedSrc,\n    UnresolvedAsset,\n    UnresolvedAssetObject\n} from '../types';\nimport type { PreferOrder, ResolveURLParser } from './types';\n\nexport interface BundleIdentifierOptions\n{\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    connector?: string;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    createBundleAssetId?: (bundleId: string, assetId: string) => string;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    extractAssetIdFromBundle?: (bundleId: string, assetBundleId: string) => string;\n}\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```js\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```js\n * resolver.prefer({\n *     params: {\n *         format: 'webp',\n *         resolution: 2,\n *     }\n * });\n *\n * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @memberof PIXI\n */\nexport class Resolver\n{\n    private _defaultBundleIdentifierOptions: Required<BundleIdentifierOptions> = {\n        connector: '-',\n        createBundleAssetId: (bundleId, assetId) =>\n            `${bundleId}${this._bundleIdConnector}${assetId}`,\n        extractAssetIdFromBundle: (bundleId, assetBundleId) =>\n            assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, ''),\n    };\n\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    private _bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    private _createBundleAssetId: (\n        bundleId: string,\n        assetId: string\n    ) => string = this._defaultBundleIdentifierOptions.createBundleAssetId;\n\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    private _extractAssetIdFromBundle: (\n        bundleId: string,\n        assetBundleId: string\n    ) => string = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n\n    private _assetMap: Record<string, ResolvedAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolvedAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: AssetsManifest;\n    private _bundles: Record<string, string[]> = {};\n    private _defaultSearchParams: string;\n\n    /**\n     * Override how the resolver deals with generating bundle ids.\n     * must be called before any bundles are added\n     * @param bundleIdentifier - the bundle identifier options\n     */\n    public setBundleIdentifier(bundleIdentifier: BundleIdentifierOptions): void\n    {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n\n        if (this._extractAssetIdFromBundle('foo', this._createBundleAssetId('foo', 'bar')) !== 'bar')\n        {\n            throw new Error('[Resolver] GenerateBundleAssetId are not working correctly');\n        }\n    }\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *     {\n     *         resolution: 2,\n     *         format: 'png',\n     *         src: 'image@2x.png',\n     *     },\n     *     {\n     *         resolution:1,\n     *         format:'png',\n     *         src: 'image.png',\n     *     },\n     * ]);\n     *\n     * // With a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // Now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *     'image@2x.png',\n     *     'image.png',\n     * ]);\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n\n        this._assetMap = {};\n        this._preferredOrder = [];\n        // Do not reset this._parsers\n\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n\n    /**\n     * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n     * @param searchParams - the default url parameters to append when resolving urls\n     */\n    public setDefaultSearchParams(searchParams: string | Record<string, unknown>): void\n    {\n        if (typeof searchParams === 'string')\n        {\n            this._defaultSearchParams = searchParams;\n        }\n        else\n        {\n            const queryValues = searchParams as Record<string, any>;\n\n            this._defaultSearchParams = Object.keys(queryValues)\n                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`)\n                .join('&');\n        }\n    }\n\n    /**\n     * Returns the aliases for a given asset\n     * @param asset - the asset to get the aliases for\n     */\n    public getAlias(asset: UnresolvedAsset): string[]\n    {\n        const { alias, name, src, srcs } = asset;\n        const aliasesToUse = convertToList<ArrayOr<string | AssetSrc>>(\n            alias || name || src || srcs, (value: string | AssetSrc) =>\n            {\n                if (typeof value === 'string') return value;\n\n                if (Array.isArray(value)) return value.map((v) => (v as ResolvedSrc)?.src ?? (v as ResolvedSrc)?.srcs ?? v);\n\n                if (value?.src || value?.srcs) return value.src ?? value.srcs;\n\n                return value;\n            }, true) as string[];\n\n        return aliasesToUse;\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: AssetsManifest): void\n    {\n        if (this._manifest)\n        {\n            if (process.env.DEBUG)\n            {\n                console.warn('[Resolver] Manifest already exists, this will be overwritten');\n            }\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * resolver.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n\n        // when storing keys against a bundle we prepend the bundleId to each asset key\n        // and pass it through as an additional alias for the asset\n        // this keeps clashing ids separate on a per-bundle basis\n        // you can also resolve a file using the bundleId-assetId syntax\n        if (Array.isArray(assets))\n        {\n            assets.forEach((asset) =>\n            {\n                const srcs = asset.src ?? asset.srcs;\n                const aliases = asset.alias ?? asset.name;\n                let ids: string[];\n\n                if (typeof aliases === 'string')\n                {\n                    const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n\n                    assetNames.push(bundleAssetId);\n                    ids = [aliases, bundleAssetId];\n                }\n                else\n                {\n                    const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n\n                    assetNames.push(...bundleIds);\n                    ids = [...aliases, ...bundleIds];\n                }\n\n                this.add({\n                    ...asset,\n                    ...{\n                        alias: ids,\n                        src: srcs,\n                    }\n                });\n            });\n        }\n        else\n        {\n            Object.keys(assets).forEach((key) =>\n            {\n                const aliases: string[] = [key, this._createBundleAssetId(bundleId, key)];\n\n                if (typeof assets[key] === 'string')\n                {\n                    this.add({\n                        alias: aliases,\n                        src: assets[key] as string,\n                    });\n                }\n                else if (Array.isArray(assets[key]))\n                {\n                    this.add({\n                        alias: aliases,\n                        src: assets[key] as string[],\n                    });\n                }\n                else\n                {\n                    const asset = assets[key] as UnresolvedAssetObject;\n                    const assetSrc = asset.src ?? asset.srcs;\n\n                    this.add({\n                        ...asset,\n                        ...{\n                            alias: aliases,\n                            src: Array.isArray(assetSrc) ? assetSrc : [assetSrc],\n                        }\n                    });\n                }\n\n                assetNames.push(...aliases);\n            });\n        }\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /** @deprecated */\n    public add(a: ArrayOr<string>, s?: AssetSrc, d?: unknown, f?: string, lp?: LoadParserName): void;\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // Single key, single asset:\n     * resolver.add({alias: 'foo', src: 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Multiple keys, single asset:\n     * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // Multiple keys, multiple assets:\n     * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Add custom data attached to the resolver\n     * Resolver.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny{png,webp}',\n     *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n     * @param data - the data to add to the resolver\n     * @param data.aliases - the key or keys that you will reference when loading this asset\n     * @param data.srcs - the asset or assets that will be chosen from when loading via the specified key\n     * @param data.data - asset-specific data that will be passed to the loaders\n     * - Useful if you want to initiate loaded objects with specific data\n     * @param data.format - the format of the asset\n     * @param data.loadParser - the name of the load parser to use\n     */\n    public add(data:(ArrayOr<UnresolvedAsset>)): void;\n    public add(\n        aliases: ArrayOr<string> | (ArrayOr<UnresolvedAsset>),\n        srcs?: AssetSrc,\n        data?: unknown,\n        format?: string,\n        loadParser?: LoadParserName\n    ): void\n    {\n        const assets: UnresolvedAsset[] = [];\n\n        if (typeof aliases === 'string' || (Array.isArray(aliases) && typeof aliases[0] === 'string'))\n        {\n            if (process.env.DEBUG)\n            {\n                // eslint-disable-next-line max-len\n                utils.deprecation('7.2.0', `Assets.add now uses an object instead of individual parameters.\\nPlease use Assets.add({ alias, src, data, format, loadParser }) instead.`);\n            }\n\n            assets.push({ alias: aliases as ArrayOr<string>, src: srcs, data, format, loadParser });\n        }\n        else if (Array.isArray(aliases))\n        {\n            assets.push(...(aliases as UnresolvedAsset[]));\n        }\n        else\n        {\n            assets.push(aliases as UnresolvedAsset);\n        }\n\n        let keyCheck: (key: string) => void;\n\n        if (process.env.DEBUG)\n        {\n            keyCheck = (key: string) =>\n            {\n                if (this.hasKey(key))\n                {\n                    console.warn(`[Resolver] already has key: ${key} overwriting`);\n                }\n            };\n        }\n\n        const assetArray = convertToList(assets);\n\n        // loop through all the assets and generate a resolve asset for each src\n        assetArray.forEach((asset) =>\n        {\n            const { src, srcs } = asset;\n            let { data, format, loadParser } = asset;\n\n            // src can contain an unresolved asset itself\n            // so we need to merge that data with the current asset\n            // we dont need to create string variations for the src if it is a ResolvedAsset\n            const srcsToUse: (string | ResolvedSrc)[][] = convertToList<AssetSrc>(src || srcs).map((src) =>\n            {\n                if (typeof src === 'string')\n                { return createStringVariations(src); }\n\n                return Array.isArray(src) ? src : [src];\n            });\n\n            const aliasesToUse = this.getAlias(asset);\n\n            if (process.env.DEBUG)\n            {\n                // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n            }\n\n            // loop through all the srcs and generate a resolve asset for each src\n            const resolvedAssets: ResolvedAsset[] = [];\n\n            srcsToUse.forEach((srcs) =>\n            {\n                srcs.forEach((src) =>\n                {\n                    let formattedAsset = {} as ResolvedAsset;\n\n                    if (typeof src !== 'object')\n                    {\n                        formattedAsset.src = src;\n                        // first see if it contains any {} tags...\n                        for (let i = 0; i < this._parsers.length; i++)\n                        {\n                            const parser = this._parsers[i];\n\n                            if (parser.test(src))\n                            {\n                                formattedAsset = parser.parse(src);\n                                break;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        data = src.data ?? data;\n                        format = src.format ?? format;\n                        loadParser = src.loadParser ?? loadParser;\n                        formattedAsset = {\n                            ...formattedAsset,\n                            ...src,\n                        };\n                    }\n\n                    // check if aliases is undefined\n                    if (!aliasesToUse)\n                    {\n                        throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n                    }\n\n                    formattedAsset = this.buildResolvedAsset(formattedAsset, {\n                        aliases: aliasesToUse,\n                        data,\n                        format,\n                        loadParser,\n                    });\n\n                    resolvedAssets.push(formattedAsset);\n                });\n            });\n\n            aliasesToUse.forEach((alias) =>\n            {\n                this._assetMap[alias] = resolvedAssets;\n            });\n        });\n    }\n\n    // TODO: this needs an overload like load did in Assets\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: ArrayOr<string>):\n    Record<string, ResolvedAsset> | Record<string, Record<string, ResolvedAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolvedAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                const results = this.resolve(assetNames) as Record<string, ResolvedAsset>;\n\n                const assets: Record<string, ResolvedAsset> = {};\n\n                for (const key in results)\n                {\n                    const asset = results[key];\n\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n\n                out[bundleId] = assets;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: ArrayOr<string>): string | Record<string, string>\n    {\n        const result = this.resolve(key as string) as ResolvedAsset | Record<string, ResolvedAsset>;\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolvedAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolvedAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => { src: 'bunny.png' }\n     *\n     * // Will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => { src: 'another-thing.png' }\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string): ResolvedAsset;\n    public resolve(keys: string[]): Record<string, ResolvedAsset>;\n    public resolve(keys: ArrayOr<string>): ResolvedAsset | Record<string, ResolvedAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolvedAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n                    const bestAsset = assets[0];\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey as keyof ResolvedAsset])\n                                {\n                                    return asset[priorityKey as keyof ResolvedAsset] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = (assets[0] ?? bestAsset);\n                }\n                else\n                {\n                    this._resolverHash[key] = this.buildResolvedAsset({\n                        alias: [key],\n                        src: key,\n                    }, {});\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Checks if an asset with a given key exists in the resolver\n     * @param key - The key of the asset\n     */\n    public hasKey(key: string): boolean\n    {\n        return !!this._assetMap[key];\n    }\n\n    /**\n     * Checks if a bundle with the given key exists in the resolver\n     * @param key - The key of the bundle\n     */\n    public hasBundle(key: string): boolean\n    {\n        return !!this._bundles[key];\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolvedAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[0];\n\n            const preferred = this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n\n    /**\n     * Appends the default url parameters to the url\n     * @param url - The url to append the default parameters to\n     * @returns - The url with the default parameters appended\n     */\n    private _appendDefaultSearchParams(url: string): string\n    {\n        if (!this._defaultSearchParams) return url;\n\n        const paramConnector = (/\\?/).test(url) ? '&' : '?';\n\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n\n    private buildResolvedAsset(formattedAsset: ResolvedAsset, data?: {\n        aliases?: string[],\n        data?: Record<string, unknown>\n        loadParser?: string,\n        format?: string,\n    }): ResolvedAsset\n    {\n        const { aliases, data: assetData, loadParser, format } = data;\n\n        if (this._basePath || this._rootPath)\n        {\n            formattedAsset.src = utils.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n        }\n\n        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n        formattedAsset.format = format ?? formattedAsset.format ?? utils.path.extname(formattedAsset.src).slice(1);\n        formattedAsset.srcs = formattedAsset.src;\n        formattedAsset.name = formattedAsset.alias;\n\n        return formattedAsset;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}