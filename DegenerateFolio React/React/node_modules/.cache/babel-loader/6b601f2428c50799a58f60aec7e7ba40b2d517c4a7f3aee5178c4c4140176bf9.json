{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findAttribute = exports.parseRawLog = exports.parseLogs = exports.parseLog = exports.parseEvent = exports.parseAttribute = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\nconst utils_1 = require(\"@cosmjs/utils\");\nfunction parseAttribute(input) {\n  if (!(0, utils_1.isNonNullObject)(input)) throw new Error(\"Attribute must be a non-null object\");\n  const {\n    key,\n    value\n  } = input;\n  if (typeof key !== \"string\" || !key) throw new Error(\"Attribute's key must be a non-empty string\");\n  if (typeof value !== \"string\" && typeof value !== \"undefined\") {\n    throw new Error(\"Attribute's value must be a string or unset\");\n  }\n  return {\n    key: key,\n    value: value || \"\"\n  };\n}\nexports.parseAttribute = parseAttribute;\nfunction parseEvent(input) {\n  if (!(0, utils_1.isNonNullObject)(input)) throw new Error(\"Event must be a non-null object\");\n  const {\n    type,\n    attributes\n  } = input;\n  if (typeof type !== \"string\" || type === \"\") {\n    throw new Error(`Event type must be a non-empty string`);\n  }\n  if (!Array.isArray(attributes)) throw new Error(\"Event's attributes must be an array\");\n  return {\n    type: type,\n    attributes: attributes.map(parseAttribute)\n  };\n}\nexports.parseEvent = parseEvent;\nfunction parseLog(input) {\n  if (!(0, utils_1.isNonNullObject)(input)) throw new Error(\"Log must be a non-null object\");\n  const {\n    msg_index,\n    log,\n    events\n  } = input;\n  if (typeof msg_index !== \"number\") throw new Error(\"Log's msg_index must be a number\");\n  if (typeof log !== \"string\") throw new Error(\"Log's log must be a string\");\n  if (!Array.isArray(events)) throw new Error(\"Log's events must be an array\");\n  return {\n    msg_index: msg_index,\n    log: log,\n    events: events.map(parseEvent)\n  };\n}\nexports.parseLog = parseLog;\nfunction parseLogs(input) {\n  if (!Array.isArray(input)) throw new Error(\"Logs must be an array\");\n  return input.map(parseLog);\n}\nexports.parseLogs = parseLogs;\nfunction parseRawLog(input) {\n  // Cosmos SDK >= 0.50 gives us an empty string here. This should be handled like undefined.\n  if (!input) return [];\n  const logsToParse = JSON.parse(input).map(({\n    events\n  }, i) => ({\n    msg_index: i,\n    events,\n    log: \"\"\n  }));\n  return parseLogs(logsToParse);\n}\nexports.parseRawLog = parseRawLog;\n/**\n * Searches in logs for the first event of the given event type and in that event\n * for the first first attribute with the given attribute key.\n *\n * Throws if the attribute was not found.\n */\nfunction findAttribute(logs, eventType, attrKey) {\n  const firstLogs = logs.find(() => true);\n  const out = firstLogs?.events.find(event => event.type === eventType)?.attributes.find(attr => attr.key === attrKey);\n  if (!out) {\n    throw new Error(`Could not find attribute '${attrKey}' in first event of type '${eventType}' in first log.`);\n  }\n  return out;\n}\nexports.findAttribute = findAttribute;","map":{"version":3,"names":["utils_1","require","parseAttribute","input","isNonNullObject","Error","key","value","exports","parseEvent","type","attributes","Array","isArray","map","parseLog","msg_index","log","events","parseLogs","parseRawLog","logsToParse","JSON","parse","i","findAttribute","logs","eventType","attrKey","firstLogs","find","out","event","attr"],"sources":["../src/logs.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}