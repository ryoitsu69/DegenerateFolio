{"ast":null,"code":"import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl.mjs';\nimport { checkDataUrl } from '../../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../../utils/checkExtension.mjs';\nimport { WorkerManager } from '../../workers/WorkerManager.mjs';\nimport { LoaderParserPriority } from '../LoaderParser.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\n\"use strict\";\nconst validImageExtensions = [\".jpeg\", \".jpg\", \".png\", \".webp\", \".avif\"];\nconst validImageMIMEs = [\"image/jpeg\", \"image/png\", \"image/webp\", \"image/avif\"];\nasync function loadImageBitmap(url) {\n  const response = await DOMAdapter.get().fetch(url);\n  if (!response.ok) {\n    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n  }\n  const imageBlob = await response.blob();\n  const imageBitmap = await createImageBitmap(imageBlob);\n  return imageBitmap;\n}\nconst loadTextures = {\n  name: \"loadTextures\",\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.High\n  },\n  config: {\n    preferWorkers: true,\n    preferCreateImageBitmap: true,\n    crossOrigin: \"anonymous\"\n  },\n  test(url) {\n    return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n  },\n  async load(url, asset, loader) {\n    let src = null;\n    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {\n      if (this.config.preferWorkers && (await WorkerManager.isImageBitmapSupported())) {\n        src = await WorkerManager.loadImageBitmap(url);\n      } else {\n        src = await loadImageBitmap(url);\n      }\n    } else {\n      src = await new Promise(resolve => {\n        src = new Image();\n        src.crossOrigin = this.config.crossOrigin;\n        src.src = url;\n        if (src.complete) {\n          resolve(src);\n        } else {\n          src.onload = () => {\n            resolve(src);\n          };\n        }\n      });\n    }\n    const base = new ImageSource({\n      resource: src,\n      alphaMode: \"premultiply-alpha-on-upload\",\n      resolution: asset.data?.resolution || getResolutionOfUrl(url),\n      ...asset.data\n    });\n    return createTexture(base, loader, url);\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\nexport { loadImageBitmap, loadTextures };","map":{"version":3,"names":["validImageExtensions","validImageMIMEs","loadImageBitmap","url","response","DOMAdapter","get","fetch","ok","Error","status","statusText","imageBlob","blob","imageBitmap","createImageBitmap","loadTextures","name","extension","type","ExtensionType","LoadParser","priority","LoaderParserPriority","High","config","preferWorkers","preferCreateImageBitmap","crossOrigin","test","checkDataUrl","checkExtension","load","asset","loader","src","globalThis","WorkerManager","isImageBitmapSupported","Promise","resolve","Image","complete","onload","base","ImageSource","resource","alphaMode","resolution","data","getResolutionOfUrl","createTexture","unload","texture","destroy"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/assets/loader/parsers/textures/loadTextures.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { WorkerManager } from '../../workers/WorkerManager';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { createTexture } from './utils/createTexture';\n\nimport type { TextureSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validImageExtensions = ['.jpeg', '.jpg', '.png', '.webp', '.avif'];\nconst validImageMIMEs = [\n    'image/jpeg',\n    'image/png',\n    'image/webp',\n    'image/avif',\n];\n\n/**\n * Configuration for the [loadTextures]{@link assets.loadTextures} plugin.\n * @see assets.loadTextures\n * @memberof assets\n */\nexport interface LoadTextureConfig\n{\n    /**\n     * When set to `true`, loading and decoding images will happen with Worker thread,\n     * if available on the browser. This is much more performant as network requests\n     * and decoding can be expensive on the CPU. However, not all environments support\n     * Workers, in some cases it can be helpful to disable by setting to `false`.\n     * @default true\n     */\n    preferWorkers: boolean;\n    /**\n     * When set to `true`, loading and decoding images will happen with `createImageBitmap`,\n     * otherwise it will use `new Image()`.\n     * @default true\n     */\n    preferCreateImageBitmap: boolean;\n    /**\n     * The crossOrigin value to use for images when `preferCreateImageBitmap` is `false`.\n     * @default 'anonymous'\n     */\n    crossOrigin: HTMLImageElement['crossOrigin'];\n}\n\n/**\n * Returns a promise that resolves an ImageBitmaps.\n * This function is designed to be used by a worker.\n * Part of WorkerManager!\n * @param url - The image to load an image bitmap for\n * @ignore\n */\nexport async function loadImageBitmap(url: string): Promise<ImageBitmap>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    if (!response.ok)\n    {\n        throw new Error(`[loadImageBitmap] Failed to fetch ${url}: `\n            + `${response.status} ${response.statusText}`);\n    }\n\n    const imageBlob = await response.blob();\n    const imageBitmap = await createImageBitmap(imageBlob);\n\n    return imageBitmap;\n}\n\n/**\n * A simple plugin to load our textures!\n * This makes use of imageBitmaps where available.\n * We load the `ImageBitmap` on a different thread using workers if possible.\n * We can then use the `ImageBitmap` as a source for a Pixi texture\n *\n * You can customize the behavior of this loader by setting the `config` property.\n * Which can be found [here]{@link assets.LoadTextureConfig}\n * ```js\n * // Set the config\n * import { loadTextures } from 'pixi.js';\n *\n * loadTextures.config = {\n *    // If true we will use a worker to load the ImageBitmap\n *    preferWorkers: true,\n *    // If false we will use new Image() instead of createImageBitmap,\n *    // we'll also disable the use of workers as it requires createImageBitmap\n *    preferCreateImageBitmap: true,\n *    crossOrigin: 'anonymous',\n * };\n * ```\n * @memberof assets\n */\nexport const loadTextures = {\n\n    name: 'loadTextures',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    config: {\n        preferWorkers: true,\n        preferCreateImageBitmap: true,\n        crossOrigin: 'anonymous',\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n    },\n\n    async load(url: string, asset: ResolvedAsset<TextureSourceOptions>, loader: Loader): Promise<Texture>\n    {\n        let src: any = null;\n\n        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap)\n        {\n            if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported())\n            {\n                src = await WorkerManager.loadImageBitmap(url);\n            }\n            else\n            {\n                src = await loadImageBitmap(url);\n            }\n        }\n        else\n        {\n            src = await new Promise((resolve) =>\n            {\n                src = new Image();\n                src.crossOrigin = this.config.crossOrigin;\n\n                src.src = url;\n                if (src.complete)\n                {\n                    resolve(src);\n                }\n                else\n                {\n                    src.onload = (): void =>\n                    {\n                        resolve(src);\n                    };\n                }\n            });\n        }\n\n        const base = new ImageSource({\n            resource: src,\n            alphaMode: 'premultiply-alpha-on-upload',\n            resolution: asset.data?.resolution || getResolutionOfUrl(url),\n            ...asset.data,\n        });\n\n        return createTexture(base, loader, url);\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} as LoaderParser<Texture, TextureSourceOptions, LoadTextureConfig>;\n"],"mappings":";;;;;;;;;;AAgBA,MAAMA,oBAAA,GAAuB,CAAC,SAAS,MAAQ,UAAQ,SAAS,OAAO;AACvE,MAAMC,eAAkB,IACpB,cACA,aACA,cACA,aACJ;AAqCA,eAAsBC,gBAAgBC,GACtC;EACI,MAAMC,QAAA,GAAW,MAAMC,UAAA,CAAWC,GAAI,GAAEC,KAAA,CAAMJ,GAAG;EAE7C,KAACC,QAAA,CAASI,EACd;IACU,UAAIC,KAAM,sCAAqCN,GAAG,KAC/CC,QAAA,CAASM,MAAM,IAAIN,QAAS,CAAAO,UAAY;EAAA;EAG/C,MAAAC,SAAA,GAAY,MAAMR,QAAA,CAASS,IAAK;EAChC,MAAAC,WAAA,GAAc,MAAMC,iBAAA,CAAkBH,SAAS;EAE9C,OAAAE,WAAA;AACX;AAyBO,MAAME,YAAe;EAExBC,IAAM;EAENC,SAAW;IACPC,IAAA,EAAMC,aAAc,CAAAC,UAAA;IACpBC,QAAA,EAAUC,oBAAqB,CAAAC;EAAA,CACnC;EAEAC,MAAQ;IACJC,aAAe;IACfC,uBAAyB;IACzBC,WAAa;EAAA,CACjB;EAEAC,KAAK1B,GACL;IACI,OAAO2B,YAAA,CAAa3B,GAAK,EAAAF,eAAe,CAAK,IAAA8B,cAAA,CAAe5B,GAAA,EAAKH,oBAAoB;EAAA,CACzF;EAEA,MAAMgC,KAAK7B,GAAa,EAAA8B,KAAA,EAA4CC,MACpE;IACI,IAAIC,GAAW;IAEf,IAAIC,UAAW,CAAArB,iBAAA,IAAqB,IAAK,CAAAU,MAAA,CAAOE,uBAChD;MACI,IAAI,KAAKF,MAAO,CAAAC,aAAA,KAAiB,MAAMW,aAAA,CAAcC,sBAAA,EACrD;QACUH,GAAA,SAAME,aAAc,CAAAnC,eAAA,CAAgBC,GAAG;MAAA,CAGjD;QACUgC,GAAA,SAAMjC,eAAA,CAAgBC,GAAG;MAAA;IACnC,CAGJ;MACIgC,GAAA,GAAM,MAAM,IAAII,OAAQ,CAACC,OACzB;QACIL,GAAA,GAAM,IAAIM,KAAM;QACZN,GAAA,CAAAP,WAAA,GAAc,KAAKH,MAAO,CAAAG,WAAA;QAE9BO,GAAA,CAAIA,GAAM,GAAAhC,GAAA;QACV,IAAIgC,GAAA,CAAIO,QACR;UACIF,OAAA,CAAQL,GAAG;QAAA,CAGf;UACIA,GAAA,CAAIQ,MAAA,GAAS,MACb;YACIH,OAAA,CAAQL,GAAG;UAAA,CACf;QAAA;MACJ,CACH;IAAA;IAGC,MAAAS,IAAA,GAAO,IAAIC,WAAY;MACzBC,QAAU,EAAAX,GAAA;MACVY,SAAW;MACXC,UAAY,EAAAf,KAAA,CAAMgB,IAAM,EAAAD,UAAA,IAAcE,kBAAA,CAAmB/C,GAAG;MAC5D,GAAG8B,KAAM,CAAAgB;IAAA,CACZ;IAEM,OAAAE,aAAA,CAAcP,IAAM,EAAAV,MAAA,EAAQ/B,GAAG;EAAA,CAC1C;EAEAiD,OAAOC,OACP;IACIA,OAAA,CAAQC,OAAA,CAAQ,IAAI;EAAA;AAE5B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}