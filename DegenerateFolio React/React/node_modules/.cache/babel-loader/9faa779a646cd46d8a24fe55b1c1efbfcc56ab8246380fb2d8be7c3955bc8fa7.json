{"ast":null,"code":"import { catchError, combineLatest, map, of, switchMap } from 'rxjs';\nimport { isFunction } from '@polkadot/util';\nimport { firstObservable } from '../util/index.js';\nimport { callMethod, withSection } from './helpers.js';\nfunction parse(api, [hashes, proposals, votes]) {\n  return proposals.map((o, index) => ({\n    hash: api.registry.createType('Hash', hashes[index]),\n    proposal: o && o.isSome ? o.unwrap() : null,\n    votes: votes[index].unwrapOr(null)\n  }));\n}\nfunction _proposalsFrom(api, query, hashes) {\n  return (isFunction(query?.proposals) && hashes.length ? combineLatest([of(hashes),\n  // this should simply be api.query[section].proposalOf.multi<Option<Proposal>>(hashes),\n  // however we have had cases on Edgeware where the indices have moved around after an\n  // upgrade, which results in invalid on-chain data\n  query.proposalOf.multi(hashes).pipe(catchError(() => of(hashes.map(() => null)))), query.voting.multi(hashes)]) : of([[], [], []])).pipe(map(r => parse(api, r)));\n}\nexport function hasProposals(section) {\n  return withSection(section, query => () => of(isFunction(query?.proposals)));\n}\nexport function proposals(section) {\n  return withSection(section, (query, api) => () => api.derive[section].proposalHashes().pipe(switchMap(all => _proposalsFrom(api, query, all))));\n}\nexport function proposal(section) {\n  return withSection(section, (query, api) => hash => isFunction(query?.proposals) ? firstObservable(_proposalsFrom(api, query, [hash])) : of(null));\n}\nexport const proposalCount = /*#__PURE__*/callMethod('proposalCount', null);\nexport const proposalHashes = /*#__PURE__*/callMethod('proposals', []);","map":{"version":3,"names":["catchError","combineLatest","map","of","switchMap","isFunction","firstObservable","callMethod","withSection","parse","api","hashes","proposals","votes","o","index","hash","registry","createType","proposal","isSome","unwrap","unwrapOr","_proposalsFrom","query","length","proposalOf","multi","pipe","voting","r","hasProposals","section","derive","proposalHashes","all","proposalCount"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api-derive/collective/proposals.js"],"sourcesContent":["import { catchError, combineLatest, map, of, switchMap } from 'rxjs';\nimport { isFunction } from '@polkadot/util';\nimport { firstObservable } from '../util/index.js';\nimport { callMethod, withSection } from './helpers.js';\nfunction parse(api, [hashes, proposals, votes]) {\n    return proposals.map((o, index) => ({\n        hash: api.registry.createType('Hash', hashes[index]),\n        proposal: o && o.isSome\n            ? o.unwrap()\n            : null,\n        votes: votes[index].unwrapOr(null)\n    }));\n}\nfunction _proposalsFrom(api, query, hashes) {\n    return (isFunction(query?.proposals) && hashes.length\n        ? combineLatest([\n            of(hashes),\n            // this should simply be api.query[section].proposalOf.multi<Option<Proposal>>(hashes),\n            // however we have had cases on Edgeware where the indices have moved around after an\n            // upgrade, which results in invalid on-chain data\n            query.proposalOf.multi(hashes).pipe(catchError(() => of(hashes.map(() => null)))),\n            query.voting.multi(hashes)\n        ])\n        : of([[], [], []])).pipe(map((r) => parse(api, r)));\n}\nexport function hasProposals(section) {\n    return withSection(section, (query) => () => of(isFunction(query?.proposals)));\n}\nexport function proposals(section) {\n    return withSection(section, (query, api) => () => api.derive[section].proposalHashes().pipe(switchMap((all) => _proposalsFrom(api, query, all))));\n}\nexport function proposal(section) {\n    return withSection(section, (query, api) => (hash) => isFunction(query?.proposals)\n        ? firstObservable(_proposalsFrom(api, query, [hash]))\n        : of(null));\n}\nexport const proposalCount = /*#__PURE__*/ callMethod('proposalCount', null);\nexport const proposalHashes = /*#__PURE__*/ callMethod('proposals', []);\n"],"mappings":"AAAA,SAASA,UAAU,EAAEC,aAAa,EAAEC,GAAG,EAAEC,EAAE,EAAEC,SAAS,QAAQ,MAAM;AACpE,SAASC,UAAU,QAAQ,gBAAgB;AAC3C,SAASC,eAAe,QAAQ,kBAAkB;AAClD,SAASC,UAAU,EAAEC,WAAW,QAAQ,cAAc;AACtD,SAASC,KAAKA,CAACC,GAAG,EAAE,CAACC,MAAM,EAAEC,SAAS,EAAEC,KAAK,CAAC,EAAE;EAC5C,OAAOD,SAAS,CAACV,GAAG,CAAC,CAACY,CAAC,EAAEC,KAAK,MAAM;IAChCC,IAAI,EAAEN,GAAG,CAACO,QAAQ,CAACC,UAAU,CAAC,MAAM,EAAEP,MAAM,CAACI,KAAK,CAAC,CAAC;IACpDI,QAAQ,EAAEL,CAAC,IAAIA,CAAC,CAACM,MAAM,GACjBN,CAAC,CAACO,MAAM,CAAC,CAAC,GACV,IAAI;IACVR,KAAK,EAAEA,KAAK,CAACE,KAAK,CAAC,CAACO,QAAQ,CAAC,IAAI;EACrC,CAAC,CAAC,CAAC;AACP;AACA,SAASC,cAAcA,CAACb,GAAG,EAAEc,KAAK,EAAEb,MAAM,EAAE;EACxC,OAAO,CAACN,UAAU,CAACmB,KAAK,EAAEZ,SAAS,CAAC,IAAID,MAAM,CAACc,MAAM,GAC/CxB,aAAa,CAAC,CACZE,EAAE,CAACQ,MAAM,CAAC;EACV;EACA;EACA;EACAa,KAAK,CAACE,UAAU,CAACC,KAAK,CAAChB,MAAM,CAAC,CAACiB,IAAI,CAAC5B,UAAU,CAAC,MAAMG,EAAE,CAACQ,MAAM,CAACT,GAAG,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC,EACjFsB,KAAK,CAACK,MAAM,CAACF,KAAK,CAAChB,MAAM,CAAC,CAC7B,CAAC,GACAR,EAAE,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,EAAEyB,IAAI,CAAC1B,GAAG,CAAE4B,CAAC,IAAKrB,KAAK,CAACC,GAAG,EAAEoB,CAAC,CAAC,CAAC,CAAC;AAC3D;AACA,OAAO,SAASC,YAAYA,CAACC,OAAO,EAAE;EAClC,OAAOxB,WAAW,CAACwB,OAAO,EAAGR,KAAK,IAAK,MAAMrB,EAAE,CAACE,UAAU,CAACmB,KAAK,EAAEZ,SAAS,CAAC,CAAC,CAAC;AAClF;AACA,OAAO,SAASA,SAASA,CAACoB,OAAO,EAAE;EAC/B,OAAOxB,WAAW,CAACwB,OAAO,EAAE,CAACR,KAAK,EAAEd,GAAG,KAAK,MAAMA,GAAG,CAACuB,MAAM,CAACD,OAAO,CAAC,CAACE,cAAc,CAAC,CAAC,CAACN,IAAI,CAACxB,SAAS,CAAE+B,GAAG,IAAKZ,cAAc,CAACb,GAAG,EAAEc,KAAK,EAAEW,GAAG,CAAC,CAAC,CAAC,CAAC;AACrJ;AACA,OAAO,SAAShB,QAAQA,CAACa,OAAO,EAAE;EAC9B,OAAOxB,WAAW,CAACwB,OAAO,EAAE,CAACR,KAAK,EAAEd,GAAG,KAAMM,IAAI,IAAKX,UAAU,CAACmB,KAAK,EAAEZ,SAAS,CAAC,GAC5EN,eAAe,CAACiB,cAAc,CAACb,GAAG,EAAEc,KAAK,EAAE,CAACR,IAAI,CAAC,CAAC,CAAC,GACnDb,EAAE,CAAC,IAAI,CAAC,CAAC;AACnB;AACA,OAAO,MAAMiC,aAAa,GAAG,aAAc7B,UAAU,CAAC,eAAe,EAAE,IAAI,CAAC;AAC5E,OAAO,MAAM2B,cAAc,GAAG,aAAc3B,UAAU,CAAC,WAAW,EAAE,EAAE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}