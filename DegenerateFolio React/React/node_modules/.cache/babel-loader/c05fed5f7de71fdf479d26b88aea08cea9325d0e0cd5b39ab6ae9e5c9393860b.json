{"ast":null,"code":"\"use strict\";\n\nclass TickerListener {\n  /**\n   * Constructor\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param priority - The priority for emitting\n   * @param once - If the handler should fire once\n   */\n  constructor(fn, context = null, priority = 0, once = false) {\n    /** The next item in chain. */\n    this.next = null;\n    /** The previous item in chain. */\n    this.previous = null;\n    /** `true` if this listener has been destroyed already. */\n    this._destroyed = false;\n    this._fn = fn;\n    this._context = context;\n    this.priority = priority;\n    this._once = once;\n  }\n  /**\n   * Simple compare function to figure out if a function and context match.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @returns `true` if the listener match the arguments\n   */\n  match(fn, context = null) {\n    return this._fn === fn && this._context === context;\n  }\n  /**\n   * Emit by calling the current function.\n   * @param ticker - The ticker emitting.\n   * @returns Next ticker\n   */\n  emit(ticker) {\n    if (this._fn) {\n      if (this._context) {\n        this._fn.call(this._context, ticker);\n      } else {\n        this._fn(ticker);\n      }\n    }\n    const redirect = this.next;\n    if (this._once) {\n      this.destroy(true);\n    }\n    if (this._destroyed) {\n      this.next = null;\n    }\n    return redirect;\n  }\n  /**\n   * Connect to the list.\n   * @param previous - Input node, previous listener\n   */\n  connect(previous) {\n    this.previous = previous;\n    if (previous.next) {\n      previous.next.previous = this;\n    }\n    this.next = previous.next;\n    previous.next = this;\n  }\n  /**\n   * Destroy and don't use after this.\n   * @param hard - `true` to remove the `next` reference, this\n   *        is considered a hard destroy. Soft destroy maintains the next reference.\n   * @returns The listener to redirect while emitting or removing.\n   */\n  destroy(hard = false) {\n    this._destroyed = true;\n    this._fn = null;\n    this._context = null;\n    if (this.previous) {\n      this.previous.next = this.next;\n    }\n    if (this.next) {\n      this.next.previous = this.previous;\n    }\n    const redirect = this.next;\n    this.next = hard ? null : redirect;\n    this.previous = null;\n    return redirect;\n  }\n}\nexport { TickerListener };","map":{"version":3,"names":["TickerListener","constructor","fn","context","priority","once","next","previous","_destroyed","_fn","_context","_once","match","emit","ticker","call","redirect","destroy","connect","hard"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/ticker/TickerListener.ts"],"sourcesContent":["import type { Ticker, TickerCallback } from './Ticker';\n\n/**\n * Internal class for handling the priority sorting of ticker handlers.\n * @private\n * @class\n */\nexport class TickerListener<T = any>\n{\n    /** The current priority. */\n    public priority: number;\n    /** The next item in chain. */\n    public next: TickerListener = null;\n    /** The previous item in chain. */\n    public previous: TickerListener = null;\n\n    /** The handler function to execute. */\n    private _fn: TickerCallback<T>;\n    /** The calling to execute. */\n    private _context: T;\n    /** If this should only execute once. */\n    private readonly _once: boolean;\n    /** `true` if this listener has been destroyed already. */\n    private _destroyed = false;\n\n    /**\n     * Constructor\n     * @private\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param priority - The priority for emitting\n     * @param once - If the handler should fire once\n     */\n    constructor(fn: TickerCallback<T>, context: T = null, priority = 0, once = false)\n    {\n        this._fn = fn;\n        this._context = context;\n        this.priority = priority;\n        this._once = once;\n    }\n\n    /**\n     * Simple compare function to figure out if a function and context match.\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @returns `true` if the listener match the arguments\n     */\n    public match(fn: TickerCallback<T>, context: any = null): boolean\n    {\n        return this._fn === fn && this._context === context;\n    }\n\n    /**\n     * Emit by calling the current function.\n     * @param ticker - The ticker emitting.\n     * @returns Next ticker\n     */\n    public emit(ticker: Ticker): TickerListener\n    {\n        if (this._fn)\n        {\n            if (this._context)\n            {\n                this._fn.call(this._context, ticker);\n            }\n            else\n            {\n                (this as TickerListener<any>)._fn(ticker);\n            }\n        }\n\n        const redirect = this.next;\n\n        if (this._once)\n        {\n            this.destroy(true);\n        }\n\n        // Soft-destroying should remove\n        // the next reference\n        if (this._destroyed)\n        {\n            this.next = null;\n        }\n\n        return redirect;\n    }\n\n    /**\n     * Connect to the list.\n     * @param previous - Input node, previous listener\n     */\n    public connect(previous: TickerListener): void\n    {\n        this.previous = previous;\n        if (previous.next)\n        {\n            previous.next.previous = this;\n        }\n        this.next = previous.next;\n        previous.next = this;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @param hard - `true` to remove the `next` reference, this\n     *        is considered a hard destroy. Soft destroy maintains the next reference.\n     * @returns The listener to redirect while emitting or removing.\n     */\n    public destroy(hard = false): TickerListener\n    {\n        this._destroyed = true;\n        this._fn = null;\n        this._context = null;\n\n        // Disconnect, hook up next and previous\n        if (this.previous)\n        {\n            this.previous.next = this.next;\n        }\n\n        if (this.next)\n        {\n            this.next.previous = this.previous;\n        }\n\n        // Redirect to the next item\n        const redirect = this.next;\n\n        // Remove references\n        this.next = hard ? null : redirect;\n        this.previous = null;\n\n        return redirect;\n    }\n}\n"],"mappings":";;AAOO,MAAMA,cACb;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAyBIC,YAAYC,EAAuB,EAAAC,OAAA,GAAa,MAAMC,QAAW,MAAGC,IAAA,GAAO,KAC3E;IAtBA;IAAA,KAAOC,IAAuB;IAE9B;IAAA,KAAOC,QAA2B;IASlC;IAAA,KAAQC,UAAa;IAYjB,KAAKC,GAAM,GAAAP,EAAA;IACX,KAAKQ,QAAW,GAAAP,OAAA;IAChB,KAAKC,QAAW,GAAAA,QAAA;IAChB,KAAKO,KAAQ,GAAAN,IAAA;EAAA;EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;EAQOO,MAAMV,EAAuB,EAAAC,OAAA,GAAe,IACnD;IACI,OAAO,IAAK,CAAAM,GAAA,KAAQP,EAAM,SAAKQ,QAAa,KAAAP,OAAA;EAAA;EAChD;AAAA;AAAA;AAAA;AAAA;EAOOU,KAAKC,MACZ;IACI,IAAI,KAAKL,GACT;MACI,IAAI,KAAKC,QACT;QACI,KAAKD,GAAI,CAAAM,IAAA,CAAK,IAAK,CAAAL,QAAA,EAAUI,MAAM;MAAA,CAGvC;QACK,KAA6BL,GAAA,CAAIK,MAAM;MAAA;IAC5C;IAGJ,MAAME,QAAA,GAAW,IAAK,CAAAV,IAAA;IAEtB,IAAI,KAAKK,KACT;MACI,KAAKM,OAAA,CAAQ,IAAI;IAAA;IAKrB,IAAI,KAAKT,UACT;MACI,KAAKF,IAAO;IAAA;IAGT,OAAAU,QAAA;EAAA;EACX;AAAA;AAAA;AAAA;EAMOE,QAAQX,QACf;IACI,KAAKA,QAAW,GAAAA,QAAA;IAChB,IAAIA,QAAA,CAASD,IACb;MACIC,QAAA,CAASD,IAAA,CAAKC,QAAW;IAAA;IAE7B,KAAKD,IAAA,GAAOC,QAAS,CAAAD,IAAA;IACrBC,QAAA,CAASD,IAAO;EAAA;EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;EAQOW,QAAQE,IAAA,GAAO,KACtB;IACI,KAAKX,UAAa;IAClB,KAAKC,GAAM;IACX,KAAKC,QAAW;IAGhB,IAAI,KAAKH,QACT;MACS,KAAAA,QAAA,CAASD,IAAA,GAAO,IAAK,CAAAA,IAAA;IAAA;IAG9B,IAAI,KAAKA,IACT;MACS,KAAAA,IAAA,CAAKC,QAAA,GAAW,IAAK,CAAAA,QAAA;IAAA;IAI9B,MAAMS,QAAA,GAAW,IAAK,CAAAV,IAAA;IAGjB,KAAAA,IAAA,GAAOa,IAAA,GAAO,IAAO,GAAAH,QAAA;IAC1B,KAAKT,QAAW;IAET,OAAAS,QAAA;EAAA;AAEf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}