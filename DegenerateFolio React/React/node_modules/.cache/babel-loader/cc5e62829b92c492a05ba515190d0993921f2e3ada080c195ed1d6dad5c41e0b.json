{"ast":null,"code":"import { DoNotConstruct, Json, Raw } from '@polkadot/types-codec';\nimport { constructTypeClass, createClassUnsafe, createTypeUnsafe } from '@polkadot/types-create';\nimport { assertReturn, BN_ZERO, formatBalance, isBn, isFunction, isNumber, isString, isU8a, lazyMethod, logger, objectSpread, stringCamelCase, stringify } from '@polkadot/util';\nimport { blake2AsU8a } from '@polkadot/util-crypto';\nimport { expandExtensionTypes, fallbackExtensions, findUnknownExtensions } from '../extrinsic/signedExtensions/index.js';\nimport { GenericEventData } from '../generic/Event.js';\nimport * as baseTypes from '../index.types.js';\nimport * as definitions from '../interfaces/definitions.js';\nimport { createCallFunction } from '../metadata/decorate/extrinsics/index.js';\nimport { decorateConstants, filterCallsSome, filterEventsSome } from '../metadata/decorate/index.js';\nimport { Metadata } from '../metadata/Metadata.js';\nimport { PortableRegistry } from '../metadata/PortableRegistry/index.js';\nimport { lazyVariants } from './lazy.js';\nconst DEFAULT_FIRST_CALL_IDX = new Uint8Array(2);\nconst l = logger('registry');\nfunction sortDecimalStrings(a, b) {\n  return parseInt(a, 10) - parseInt(b, 10);\n}\nfunction valueToString(v) {\n  return v.toString();\n}\nfunction getFieldArgs(lookup, fields) {\n  const count = fields.length;\n  const args = new Array(count);\n  for (let i = 0; i < count; i++) {\n    args[i] = lookup.getTypeDef(fields[i].type).type;\n  }\n  return args;\n}\nfunction clearRecord(record) {\n  const keys = Object.keys(record);\n  for (let i = 0, count = keys.length; i < count; i++) {\n    delete record[keys[i]];\n  }\n}\nfunction getVariantStringIdx({\n  index\n}) {\n  return index.toString();\n}\nfunction injectErrors(_, {\n  lookup,\n  pallets\n}, version, result) {\n  clearRecord(result);\n  for (let i = 0, count = pallets.length; i < count; i++) {\n    const {\n      errors,\n      index,\n      name\n    } = pallets[i];\n    if (errors.isSome) {\n      const sectionName = stringCamelCase(name);\n      lazyMethod(result, version >= 12 ? index.toNumber() : i, () => lazyVariants(lookup, errors.unwrap(), getVariantStringIdx, ({\n        docs,\n        fields,\n        index,\n        name\n      }) => ({\n        args: getFieldArgs(lookup, fields),\n        docs: docs.map(valueToString),\n        fields,\n        index: index.toNumber(),\n        method: name.toString(),\n        name: name.toString(),\n        section: sectionName\n      })));\n    }\n  }\n}\nfunction injectEvents(registry, {\n  lookup,\n  pallets\n}, version, result) {\n  const filtered = pallets.filter(filterEventsSome);\n  clearRecord(result);\n  for (let i = 0, count = filtered.length; i < count; i++) {\n    const {\n      events,\n      index,\n      name\n    } = filtered[i];\n    lazyMethod(result, version >= 12 ? index.toNumber() : i, () => lazyVariants(lookup, events.unwrap(), getVariantStringIdx, variant => {\n      const meta = registry.createType('EventMetadataLatest', objectSpread({}, variant, {\n        args: getFieldArgs(lookup, variant.fields)\n      }));\n      return class extends GenericEventData {\n        constructor(registry, value) {\n          super(registry, value, meta, stringCamelCase(name), variant.name.toString());\n        }\n      };\n    }));\n  }\n}\nfunction injectExtrinsics(registry, {\n  lookup,\n  pallets\n}, version, result, mapping) {\n  const filtered = pallets.filter(filterCallsSome);\n  clearRecord(result);\n  clearRecord(mapping);\n  for (let i = 0, count = filtered.length; i < count; i++) {\n    const {\n      calls,\n      index,\n      name\n    } = filtered[i];\n    const sectionIndex = version >= 12 ? index.toNumber() : i;\n    const sectionName = stringCamelCase(name);\n    const allCalls = calls.unwrap();\n    lazyMethod(result, sectionIndex, () => lazyVariants(lookup, allCalls, getVariantStringIdx, variant => createCallFunction(registry, lookup, variant, sectionName, sectionIndex)));\n    const {\n      path\n    } = registry.lookup.getSiType(allCalls.type);\n    // frame_system::pallet::Call / pallet_balances::pallet::Call / polkadot_runtime_parachains::configuration::pallet::Call /\n    const palletIdx = path.findIndex(v => v.eq('pallet'));\n    if (palletIdx !== -1) {\n      const name = stringCamelCase(path.slice(0, palletIdx).map((p, i) => i === 0\n      // frame_system || pallet_balances\n      ? p.replace(/^(frame|pallet)_/, '') : p).join(' '));\n      if (!mapping[name]) {\n        mapping[name] = [sectionName];\n      } else {\n        mapping[name].push(sectionName);\n      }\n    }\n  }\n}\nfunction extractProperties(registry, metadata) {\n  const original = registry.getChainProperties();\n  const constants = decorateConstants(registry, metadata.asLatest, metadata.version);\n  const ss58Format = constants['system'] && (constants['system']['sS58Prefix'] || constants['system']['ss58Prefix']);\n  if (!ss58Format) {\n    return original;\n  }\n  const {\n    isEthereum,\n    tokenDecimals,\n    tokenSymbol\n  } = original || {};\n  return registry.createTypeUnsafe('ChainProperties', [{\n    isEthereum,\n    ss58Format,\n    tokenDecimals,\n    tokenSymbol\n  }]);\n}\nexport class TypeRegistry {\n  __internal__chainProperties;\n  __internal__classes = new Map();\n  __internal__definitions = new Map();\n  __internal__firstCallIndex = null;\n  __internal__hasher = blake2AsU8a;\n  __internal__knownTypes = {};\n  __internal__lookup;\n  __internal__metadata;\n  __internal__metadataVersion = 0;\n  __internal__signedExtensions = fallbackExtensions;\n  __internal__unknownTypes = new Map();\n  __internal__userExtensions;\n  __internal__knownDefaults;\n  __internal__knownDefaultsEntries;\n  __internal__knownDefinitions;\n  __internal__metadataCalls = {};\n  __internal__metadataErrors = {};\n  __internal__metadataEvents = {};\n  __internal__moduleMap = {};\n  createdAtHash;\n  constructor(createdAtHash) {\n    this.__internal__knownDefaults = objectSpread({\n      Json,\n      Metadata,\n      PortableRegistry,\n      Raw\n    }, baseTypes);\n    this.__internal__knownDefaultsEntries = Object.entries(this.__internal__knownDefaults);\n    this.__internal__knownDefinitions = definitions;\n    const allKnown = Object.values(this.__internal__knownDefinitions);\n    for (let i = 0, count = allKnown.length; i < count; i++) {\n      this.register(allKnown[i].types);\n    }\n    if (createdAtHash) {\n      this.createdAtHash = this.createType('BlockHash', createdAtHash);\n    }\n  }\n  get chainDecimals() {\n    if (this.__internal__chainProperties?.tokenDecimals.isSome) {\n      const allDecimals = this.__internal__chainProperties.tokenDecimals.unwrap();\n      if (allDecimals.length) {\n        return allDecimals.map(b => b.toNumber());\n      }\n    }\n    return [12];\n  }\n  get chainIsEthereum() {\n    return this.__internal__chainProperties?.isEthereum.isTrue || false;\n  }\n  get chainSS58() {\n    return this.__internal__chainProperties?.ss58Format.isSome ? this.__internal__chainProperties.ss58Format.unwrap().toNumber() : undefined;\n  }\n  get chainTokens() {\n    if (this.__internal__chainProperties?.tokenSymbol.isSome) {\n      const allTokens = this.__internal__chainProperties.tokenSymbol.unwrap();\n      if (allTokens.length) {\n        return allTokens.map(valueToString);\n      }\n    }\n    return [formatBalance.getDefaults().unit];\n  }\n  get firstCallIndex() {\n    return this.__internal__firstCallIndex || DEFAULT_FIRST_CALL_IDX;\n  }\n  /**\n   * @description Returns true if the type is in a Compat format\n   */\n  isLookupType(value) {\n    return /Lookup\\d+$/.test(value);\n  }\n  /**\n   * @description Creates a lookup string from the supplied id\n   */\n  createLookupType(lookupId) {\n    return `Lookup${typeof lookupId === 'number' ? lookupId : lookupId.toNumber()}`;\n  }\n  get knownTypes() {\n    return this.__internal__knownTypes;\n  }\n  get lookup() {\n    return assertReturn(this.__internal__lookup, 'PortableRegistry has not been set on this registry');\n  }\n  get metadata() {\n    return assertReturn(this.__internal__metadata, 'Metadata has not been set on this registry');\n  }\n  get unknownTypes() {\n    return [...this.__internal__unknownTypes.keys()];\n  }\n  get signedExtensions() {\n    return this.__internal__signedExtensions;\n  }\n  clearCache() {\n    this.__internal__classes = new Map();\n  }\n  /**\n   * @describe Creates an instance of the class\n   */\n  createClass(type) {\n    return createClassUnsafe(this, type);\n  }\n  /**\n   * @describe Creates an instance of the class\n   */\n  createClassUnsafe(type) {\n    return createClassUnsafe(this, type);\n  }\n  /**\n   * @description Creates an instance of a type as registered\n   */\n  createType(type, ...params) {\n    return createTypeUnsafe(this, type, params);\n  }\n  /**\n   * @description Creates an instance of a type as registered\n   */\n  createTypeUnsafe(type, params, options) {\n    return createTypeUnsafe(this, type, params, options);\n  }\n  // find a specific call\n  findMetaCall(callIndex) {\n    const [section, method] = [callIndex[0], callIndex[1]];\n    return assertReturn(this.__internal__metadataCalls[`${section}`] && this.__internal__metadataCalls[`${section}`][`${method}`], () => `findMetaCall: Unable to find Call with index [${section}, ${method}]/[${callIndex.toString()}]`);\n  }\n  // finds an error\n  findMetaError(errorIndex) {\n    const [section, method] = isU8a(errorIndex) ? [errorIndex[0], errorIndex[1]] : [errorIndex.index.toNumber(), isU8a(errorIndex.error) ? errorIndex.error[0] : errorIndex.error.toNumber()];\n    return assertReturn(this.__internal__metadataErrors[`${section}`] && this.__internal__metadataErrors[`${section}`][`${method}`], () => `findMetaError: Unable to find Error with index [${section}, ${method}]/[${errorIndex.toString()}]`);\n  }\n  findMetaEvent(eventIndex) {\n    const [section, method] = [eventIndex[0], eventIndex[1]];\n    return assertReturn(this.__internal__metadataEvents[`${section}`] && this.__internal__metadataEvents[`${section}`][`${method}`], () => `findMetaEvent: Unable to find Event with index [${section}, ${method}]/[${eventIndex.toString()}]`);\n  }\n  get(name, withUnknown, knownTypeDef) {\n    return this.getUnsafe(name, withUnknown, knownTypeDef);\n  }\n  getUnsafe(name, withUnknown, knownTypeDef) {\n    let Type = this.__internal__classes.get(name) || this.__internal__knownDefaults[name];\n    // we have not already created the type, attempt it\n    if (!Type) {\n      const definition = this.__internal__definitions.get(name);\n      let BaseType;\n      // we have a definition, so create the class now (lazily)\n      if (definition) {\n        BaseType = createClassUnsafe(this, definition);\n      } else if (knownTypeDef) {\n        BaseType = constructTypeClass(this, knownTypeDef);\n      } else if (withUnknown) {\n        l.warn(`Unable to resolve type ${name}, it will fail on construction`);\n        this.__internal__unknownTypes.set(name, true);\n        BaseType = DoNotConstruct.with(name);\n      }\n      if (BaseType) {\n        // NOTE If we didn't extend here, we would have strange artifacts. An example is\n        // Balance, with this, new Balance() instanceof u128 is true, but Balance !== u128\n        // Additionally, we now pass through the registry, which is a link to ourselves\n        Type = class extends BaseType {};\n        this.__internal__classes.set(name, Type);\n        // In the case of lookups, we also want to store the actual class against\n        // the lookup name, instad of having to traverse again\n        if (knownTypeDef && isNumber(knownTypeDef.lookupIndex)) {\n          this.__internal__classes.set(this.createLookupType(knownTypeDef.lookupIndex), Type);\n        }\n      }\n    }\n    return Type;\n  }\n  getChainProperties() {\n    return this.__internal__chainProperties;\n  }\n  getClassName(Type) {\n    // we cannot rely on export order (anymore, since babel/core 7.15.8), so in the case of\n    // items such as u32 & U32, we get the lowercase versions here... not quite as optimal\n    // (previously this used to be a simple find & return)\n    const names = [];\n    for (const [name, Clazz] of this.__internal__knownDefaultsEntries) {\n      if (Type === Clazz) {\n        names.push(name);\n      }\n    }\n    for (const [name, Clazz] of this.__internal__classes.entries()) {\n      if (Type === Clazz) {\n        names.push(name);\n      }\n    }\n    return names.length\n    // both sort and reverse are done in-place\n    // ['U32', 'u32'] -> ['u32', 'U32']\n    ? names.sort().reverse()[0] : undefined;\n  }\n  getDefinition(typeName) {\n    return this.__internal__definitions.get(typeName);\n  }\n  getModuleInstances(specName, moduleName) {\n    return this.__internal__knownTypes?.typesBundle?.spec?.[specName.toString()]?.instances?.[moduleName] || this.__internal__moduleMap[moduleName];\n  }\n  getOrThrow(name) {\n    const Clazz = this.get(name);\n    if (!Clazz) {\n      throw new Error(`type ${name} not found`);\n    }\n    return Clazz;\n  }\n  getOrUnknown(name) {\n    return this.get(name, true);\n  }\n  getSignedExtensionExtra() {\n    return expandExtensionTypes(this.__internal__signedExtensions, 'payload', this.__internal__userExtensions);\n  }\n  getSignedExtensionTypes() {\n    return expandExtensionTypes(this.__internal__signedExtensions, 'extrinsic', this.__internal__userExtensions);\n  }\n  hasClass(name) {\n    return this.__internal__classes.has(name) || !!this.__internal__knownDefaults[name];\n  }\n  hasDef(name) {\n    return this.__internal__definitions.has(name);\n  }\n  hasType(name) {\n    return !this.__internal__unknownTypes.get(name) && (this.hasClass(name) || this.hasDef(name));\n  }\n  hash(data) {\n    return this.createType('CodecHash', this.__internal__hasher(data));\n  }\n  // eslint-disable-next-line no-dupe-class-members\n  register(arg1, arg2) {\n    // NOTE Constructors appear as functions here\n    if (isFunction(arg1)) {\n      this.__internal__classes.set(arg1.name, arg1);\n    } else if (isString(arg1)) {\n      if (!isFunction(arg2)) {\n        throw new Error(`Expected class definition passed to '${arg1}' registration`);\n      } else if (arg1 === arg2.toString()) {\n        throw new Error(`Unable to register circular ${arg1} === ${arg1}`);\n      }\n      this.__internal__classes.set(arg1, arg2);\n    } else {\n      this.__internal__registerObject(arg1);\n    }\n  }\n  __internal__registerObject = obj => {\n    const entries = Object.entries(obj);\n    for (let e = 0, count = entries.length; e < count; e++) {\n      const [name, type] = entries[e];\n      if (isFunction(type)) {\n        // This _looks_ a bit funny, but `typeof Clazz === 'function'\n        this.__internal__classes.set(name, type);\n      } else {\n        const def = isString(type) ? type : stringify(type);\n        if (name === def) {\n          throw new Error(`Unable to register circular ${name} === ${def}`);\n        }\n        // we already have this type, remove the classes registered for it\n        if (this.__internal__classes.has(name)) {\n          this.__internal__classes.delete(name);\n        }\n        this.__internal__definitions.set(name, def);\n      }\n    }\n  };\n  // sets the chain properties\n  setChainProperties(properties) {\n    if (properties) {\n      this.__internal__chainProperties = properties;\n    }\n  }\n  setHasher(hasher) {\n    this.__internal__hasher = hasher || blake2AsU8a;\n  }\n  setKnownTypes(knownTypes) {\n    this.__internal__knownTypes = knownTypes;\n  }\n  setLookup(lookup) {\n    this.__internal__lookup = lookup;\n    // register all applicable types found\n    lookup.register();\n  }\n  // register alias types alongside the portable/lookup setup\n  // (we don't combine this into setLookup since that would/could\n  // affect stand-along lookups, such as ABIs which don't have\n  // actual on-chain metadata)\n  __internal__registerLookup = lookup => {\n    // attach the lookup before we register any types\n    this.setLookup(lookup);\n    // we detect based on runtime configuration\n    let Weight = null;\n    if (this.hasType('SpWeightsWeightV2Weight')) {\n      // detection for WeightV2 type based on latest naming\n      const weightv2 = this.createType('SpWeightsWeightV2Weight');\n      Weight = weightv2.refTime && weightv2.proofSize\n      // with both refTime & proofSize we use as-is (WeightV2)\n      ? 'SpWeightsWeightV2Weight'\n      // fallback to WeightV1 (WeightV1.5 is a struct, single field)\n      : 'WeightV1';\n    } else if (!isBn(this.createType('Weight'))) {\n      // where we have an already-supplied BN override, we don't clobber\n      // it with our detected value (This protects against pre-defines\n      // where Weight may be aliassed to WeightV0, e.g. in early Kusama chains)\n      Weight = 'WeightV1';\n    }\n    if (Weight) {\n      // we have detected a version, adjust the definition\n      this.register({\n        Weight\n      });\n    }\n  };\n  // sets the metadata\n  setMetadata(metadata, signedExtensions, userExtensions, noInitWarn) {\n    this.__internal__metadata = metadata.asLatest;\n    this.__internal__metadataVersion = metadata.version;\n    this.__internal__firstCallIndex = null;\n    // attach the lookup at this point and register relevant types (before injecting)\n    this.__internal__registerLookup(this.__internal__metadata.lookup);\n    injectExtrinsics(this, this.__internal__metadata, this.__internal__metadataVersion, this.__internal__metadataCalls, this.__internal__moduleMap);\n    injectErrors(this, this.__internal__metadata, this.__internal__metadataVersion, this.__internal__metadataErrors);\n    injectEvents(this, this.__internal__metadata, this.__internal__metadataVersion, this.__internal__metadataEvents);\n    // set the default call index (the lowest section, the lowest method)\n    // in most chains this should be 0,0\n    const [defSection] = Object.keys(this.__internal__metadataCalls).sort(sortDecimalStrings);\n    if (defSection) {\n      const [defMethod] = Object.keys(this.__internal__metadataCalls[defSection]).sort(sortDecimalStrings);\n      if (defMethod) {\n        this.__internal__firstCallIndex = new Uint8Array([parseInt(defSection, 10), parseInt(defMethod, 10)]);\n      }\n    }\n    // setup the available extensions\n    this.setSignedExtensions(signedExtensions || (this.__internal__metadata.extrinsic.version.gt(BN_ZERO)\n    // FIXME Use the extension and their injected types\n    ? this.__internal__metadata.extrinsic.signedExtensions.map(({\n      identifier\n    }) => identifier.toString()) : fallbackExtensions), userExtensions, noInitWarn);\n    // setup the chain properties with format overrides\n    this.setChainProperties(extractProperties(this, metadata));\n  }\n  // sets the available signed extensions\n  setSignedExtensions(signedExtensions = fallbackExtensions, userExtensions, noInitWarn) {\n    this.__internal__signedExtensions = signedExtensions;\n    this.__internal__userExtensions = userExtensions;\n    if (!noInitWarn) {\n      const unknown = findUnknownExtensions(this.__internal__signedExtensions, this.__internal__userExtensions);\n      if (unknown.length) {\n        l.warn(`Unknown signed extensions ${unknown.join(', ')} found, treating them as no-effect`);\n      }\n    }\n  }\n}","map":{"version":3,"names":["DoNotConstruct","Json","Raw","constructTypeClass","createClassUnsafe","createTypeUnsafe","assertReturn","BN_ZERO","formatBalance","isBn","isFunction","isNumber","isString","isU8a","lazyMethod","logger","objectSpread","stringCamelCase","stringify","blake2AsU8a","expandExtensionTypes","fallbackExtensions","findUnknownExtensions","GenericEventData","baseTypes","definitions","createCallFunction","decorateConstants","filterCallsSome","filterEventsSome","Metadata","PortableRegistry","lazyVariants","DEFAULT_FIRST_CALL_IDX","Uint8Array","l","sortDecimalStrings","a","b","parseInt","valueToString","v","toString","getFieldArgs","lookup","fields","count","length","args","Array","i","getTypeDef","type","clearRecord","record","keys","Object","getVariantStringIdx","index","injectErrors","_","pallets","version","result","errors","name","isSome","sectionName","toNumber","unwrap","docs","map","method","section","injectEvents","registry","filtered","filter","events","variant","meta","createType","constructor","value","injectExtrinsics","mapping","calls","sectionIndex","allCalls","path","getSiType","palletIdx","findIndex","eq","slice","p","replace","join","push","extractProperties","metadata","original","getChainProperties","constants","asLatest","ss58Format","isEthereum","tokenDecimals","tokenSymbol","TypeRegistry","__internal__chainProperties","__internal__classes","Map","__internal__definitions","__internal__firstCallIndex","__internal__hasher","__internal__knownTypes","__internal__lookup","__internal__metadata","__internal__metadataVersion","__internal__signedExtensions","__internal__unknownTypes","__internal__userExtensions","__internal__knownDefaults","__internal__knownDefaultsEntries","__internal__knownDefinitions","__internal__metadataCalls","__internal__metadataErrors","__internal__metadataEvents","__internal__moduleMap","createdAtHash","entries","allKnown","values","register","types","chainDecimals","allDecimals","chainIsEthereum","isTrue","chainSS58","undefined","chainTokens","allTokens","getDefaults","unit","firstCallIndex","isLookupType","test","createLookupType","lookupId","knownTypes","unknownTypes","signedExtensions","clearCache","createClass","params","options","findMetaCall","callIndex","findMetaError","errorIndex","error","findMetaEvent","eventIndex","get","withUnknown","knownTypeDef","getUnsafe","Type","definition","BaseType","warn","set","with","lookupIndex","getClassName","names","Clazz","sort","reverse","getDefinition","typeName","getModuleInstances","specName","moduleName","typesBundle","spec","instances","getOrThrow","Error","getOrUnknown","getSignedExtensionExtra","getSignedExtensionTypes","hasClass","has","hasDef","hasType","hash","data","arg1","arg2","__internal__registerObject","obj","e","def","delete","setChainProperties","properties","setHasher","hasher","setKnownTypes","setLookup","__internal__registerLookup","Weight","weightv2","refTime","proofSize","setMetadata","userExtensions","noInitWarn","defSection","defMethod","setSignedExtensions","extrinsic","gt","identifier","unknown"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/create/registry.js"],"sourcesContent":["import { DoNotConstruct, Json, Raw } from '@polkadot/types-codec';\nimport { constructTypeClass, createClassUnsafe, createTypeUnsafe } from '@polkadot/types-create';\nimport { assertReturn, BN_ZERO, formatBalance, isBn, isFunction, isNumber, isString, isU8a, lazyMethod, logger, objectSpread, stringCamelCase, stringify } from '@polkadot/util';\nimport { blake2AsU8a } from '@polkadot/util-crypto';\nimport { expandExtensionTypes, fallbackExtensions, findUnknownExtensions } from '../extrinsic/signedExtensions/index.js';\nimport { GenericEventData } from '../generic/Event.js';\nimport * as baseTypes from '../index.types.js';\nimport * as definitions from '../interfaces/definitions.js';\nimport { createCallFunction } from '../metadata/decorate/extrinsics/index.js';\nimport { decorateConstants, filterCallsSome, filterEventsSome } from '../metadata/decorate/index.js';\nimport { Metadata } from '../metadata/Metadata.js';\nimport { PortableRegistry } from '../metadata/PortableRegistry/index.js';\nimport { lazyVariants } from './lazy.js';\nconst DEFAULT_FIRST_CALL_IDX = new Uint8Array(2);\nconst l = logger('registry');\nfunction sortDecimalStrings(a, b) {\n    return parseInt(a, 10) - parseInt(b, 10);\n}\nfunction valueToString(v) {\n    return v.toString();\n}\nfunction getFieldArgs(lookup, fields) {\n    const count = fields.length;\n    const args = new Array(count);\n    for (let i = 0; i < count; i++) {\n        args[i] = lookup.getTypeDef(fields[i].type).type;\n    }\n    return args;\n}\nfunction clearRecord(record) {\n    const keys = Object.keys(record);\n    for (let i = 0, count = keys.length; i < count; i++) {\n        delete record[keys[i]];\n    }\n}\nfunction getVariantStringIdx({ index }) {\n    return index.toString();\n}\nfunction injectErrors(_, { lookup, pallets }, version, result) {\n    clearRecord(result);\n    for (let i = 0, count = pallets.length; i < count; i++) {\n        const { errors, index, name } = pallets[i];\n        if (errors.isSome) {\n            const sectionName = stringCamelCase(name);\n            lazyMethod(result, version >= 12 ? index.toNumber() : i, () => lazyVariants(lookup, errors.unwrap(), getVariantStringIdx, ({ docs, fields, index, name }) => ({\n                args: getFieldArgs(lookup, fields),\n                docs: docs.map(valueToString),\n                fields,\n                index: index.toNumber(),\n                method: name.toString(),\n                name: name.toString(),\n                section: sectionName\n            })));\n        }\n    }\n}\nfunction injectEvents(registry, { lookup, pallets }, version, result) {\n    const filtered = pallets.filter(filterEventsSome);\n    clearRecord(result);\n    for (let i = 0, count = filtered.length; i < count; i++) {\n        const { events, index, name } = filtered[i];\n        lazyMethod(result, version >= 12 ? index.toNumber() : i, () => lazyVariants(lookup, events.unwrap(), getVariantStringIdx, (variant) => {\n            const meta = registry.createType('EventMetadataLatest', objectSpread({}, variant, { args: getFieldArgs(lookup, variant.fields) }));\n            return class extends GenericEventData {\n                constructor(registry, value) {\n                    super(registry, value, meta, stringCamelCase(name), variant.name.toString());\n                }\n            };\n        }));\n    }\n}\nfunction injectExtrinsics(registry, { lookup, pallets }, version, result, mapping) {\n    const filtered = pallets.filter(filterCallsSome);\n    clearRecord(result);\n    clearRecord(mapping);\n    for (let i = 0, count = filtered.length; i < count; i++) {\n        const { calls, index, name } = filtered[i];\n        const sectionIndex = version >= 12 ? index.toNumber() : i;\n        const sectionName = stringCamelCase(name);\n        const allCalls = calls.unwrap();\n        lazyMethod(result, sectionIndex, () => lazyVariants(lookup, allCalls, getVariantStringIdx, (variant) => createCallFunction(registry, lookup, variant, sectionName, sectionIndex)));\n        const { path } = registry.lookup.getSiType(allCalls.type);\n        // frame_system::pallet::Call / pallet_balances::pallet::Call / polkadot_runtime_parachains::configuration::pallet::Call /\n        const palletIdx = path.findIndex((v) => v.eq('pallet'));\n        if (palletIdx !== -1) {\n            const name = stringCamelCase(path\n                .slice(0, palletIdx)\n                .map((p, i) => i === 0\n                // frame_system || pallet_balances\n                ? p.replace(/^(frame|pallet)_/, '')\n                : p)\n                .join(' '));\n            if (!mapping[name]) {\n                mapping[name] = [sectionName];\n            }\n            else {\n                mapping[name].push(sectionName);\n            }\n        }\n    }\n}\nfunction extractProperties(registry, metadata) {\n    const original = registry.getChainProperties();\n    const constants = decorateConstants(registry, metadata.asLatest, metadata.version);\n    const ss58Format = constants['system'] && (constants['system']['sS58Prefix'] || constants['system']['ss58Prefix']);\n    if (!ss58Format) {\n        return original;\n    }\n    const { isEthereum, tokenDecimals, tokenSymbol } = original || {};\n    return registry.createTypeUnsafe('ChainProperties', [{ isEthereum, ss58Format, tokenDecimals, tokenSymbol }]);\n}\nexport class TypeRegistry {\n    __internal__chainProperties;\n    __internal__classes = new Map();\n    __internal__definitions = new Map();\n    __internal__firstCallIndex = null;\n    __internal__hasher = blake2AsU8a;\n    __internal__knownTypes = {};\n    __internal__lookup;\n    __internal__metadata;\n    __internal__metadataVersion = 0;\n    __internal__signedExtensions = fallbackExtensions;\n    __internal__unknownTypes = new Map();\n    __internal__userExtensions;\n    __internal__knownDefaults;\n    __internal__knownDefaultsEntries;\n    __internal__knownDefinitions;\n    __internal__metadataCalls = {};\n    __internal__metadataErrors = {};\n    __internal__metadataEvents = {};\n    __internal__moduleMap = {};\n    createdAtHash;\n    constructor(createdAtHash) {\n        this.__internal__knownDefaults = objectSpread({ Json, Metadata, PortableRegistry, Raw }, baseTypes);\n        this.__internal__knownDefaultsEntries = Object.entries(this.__internal__knownDefaults);\n        this.__internal__knownDefinitions = definitions;\n        const allKnown = Object.values(this.__internal__knownDefinitions);\n        for (let i = 0, count = allKnown.length; i < count; i++) {\n            this.register(allKnown[i].types);\n        }\n        if (createdAtHash) {\n            this.createdAtHash = this.createType('BlockHash', createdAtHash);\n        }\n    }\n    get chainDecimals() {\n        if (this.__internal__chainProperties?.tokenDecimals.isSome) {\n            const allDecimals = this.__internal__chainProperties.tokenDecimals.unwrap();\n            if (allDecimals.length) {\n                return allDecimals.map((b) => b.toNumber());\n            }\n        }\n        return [12];\n    }\n    get chainIsEthereum() {\n        return this.__internal__chainProperties?.isEthereum.isTrue || false;\n    }\n    get chainSS58() {\n        return this.__internal__chainProperties?.ss58Format.isSome\n            ? this.__internal__chainProperties.ss58Format.unwrap().toNumber()\n            : undefined;\n    }\n    get chainTokens() {\n        if (this.__internal__chainProperties?.tokenSymbol.isSome) {\n            const allTokens = this.__internal__chainProperties.tokenSymbol.unwrap();\n            if (allTokens.length) {\n                return allTokens.map(valueToString);\n            }\n        }\n        return [formatBalance.getDefaults().unit];\n    }\n    get firstCallIndex() {\n        return this.__internal__firstCallIndex || DEFAULT_FIRST_CALL_IDX;\n    }\n    /**\n     * @description Returns true if the type is in a Compat format\n     */\n    isLookupType(value) {\n        return /Lookup\\d+$/.test(value);\n    }\n    /**\n     * @description Creates a lookup string from the supplied id\n     */\n    createLookupType(lookupId) {\n        return `Lookup${typeof lookupId === 'number' ? lookupId : lookupId.toNumber()}`;\n    }\n    get knownTypes() {\n        return this.__internal__knownTypes;\n    }\n    get lookup() {\n        return assertReturn(this.__internal__lookup, 'PortableRegistry has not been set on this registry');\n    }\n    get metadata() {\n        return assertReturn(this.__internal__metadata, 'Metadata has not been set on this registry');\n    }\n    get unknownTypes() {\n        return [...this.__internal__unknownTypes.keys()];\n    }\n    get signedExtensions() {\n        return this.__internal__signedExtensions;\n    }\n    clearCache() {\n        this.__internal__classes = new Map();\n    }\n    /**\n     * @describe Creates an instance of the class\n     */\n    createClass(type) {\n        return createClassUnsafe(this, type);\n    }\n    /**\n     * @describe Creates an instance of the class\n     */\n    createClassUnsafe(type) {\n        return createClassUnsafe(this, type);\n    }\n    /**\n     * @description Creates an instance of a type as registered\n     */\n    createType(type, ...params) {\n        return createTypeUnsafe(this, type, params);\n    }\n    /**\n     * @description Creates an instance of a type as registered\n     */\n    createTypeUnsafe(type, params, options) {\n        return createTypeUnsafe(this, type, params, options);\n    }\n    // find a specific call\n    findMetaCall(callIndex) {\n        const [section, method] = [callIndex[0], callIndex[1]];\n        return assertReturn(this.__internal__metadataCalls[`${section}`] && this.__internal__metadataCalls[`${section}`][`${method}`], () => `findMetaCall: Unable to find Call with index [${section}, ${method}]/[${callIndex.toString()}]`);\n    }\n    // finds an error\n    findMetaError(errorIndex) {\n        const [section, method] = isU8a(errorIndex)\n            ? [errorIndex[0], errorIndex[1]]\n            : [\n                errorIndex.index.toNumber(),\n                isU8a(errorIndex.error)\n                    ? errorIndex.error[0]\n                    : errorIndex.error.toNumber()\n            ];\n        return assertReturn(this.__internal__metadataErrors[`${section}`] && this.__internal__metadataErrors[`${section}`][`${method}`], () => `findMetaError: Unable to find Error with index [${section}, ${method}]/[${errorIndex.toString()}]`);\n    }\n    findMetaEvent(eventIndex) {\n        const [section, method] = [eventIndex[0], eventIndex[1]];\n        return assertReturn(this.__internal__metadataEvents[`${section}`] && this.__internal__metadataEvents[`${section}`][`${method}`], () => `findMetaEvent: Unable to find Event with index [${section}, ${method}]/[${eventIndex.toString()}]`);\n    }\n    get(name, withUnknown, knownTypeDef) {\n        return this.getUnsafe(name, withUnknown, knownTypeDef);\n    }\n    getUnsafe(name, withUnknown, knownTypeDef) {\n        let Type = this.__internal__classes.get(name) || this.__internal__knownDefaults[name];\n        // we have not already created the type, attempt it\n        if (!Type) {\n            const definition = this.__internal__definitions.get(name);\n            let BaseType;\n            // we have a definition, so create the class now (lazily)\n            if (definition) {\n                BaseType = createClassUnsafe(this, definition);\n            }\n            else if (knownTypeDef) {\n                BaseType = constructTypeClass(this, knownTypeDef);\n            }\n            else if (withUnknown) {\n                l.warn(`Unable to resolve type ${name}, it will fail on construction`);\n                this.__internal__unknownTypes.set(name, true);\n                BaseType = DoNotConstruct.with(name);\n            }\n            if (BaseType) {\n                // NOTE If we didn't extend here, we would have strange artifacts. An example is\n                // Balance, with this, new Balance() instanceof u128 is true, but Balance !== u128\n                // Additionally, we now pass through the registry, which is a link to ourselves\n                Type = class extends BaseType {\n                };\n                this.__internal__classes.set(name, Type);\n                // In the case of lookups, we also want to store the actual class against\n                // the lookup name, instad of having to traverse again\n                if (knownTypeDef && isNumber(knownTypeDef.lookupIndex)) {\n                    this.__internal__classes.set(this.createLookupType(knownTypeDef.lookupIndex), Type);\n                }\n            }\n        }\n        return Type;\n    }\n    getChainProperties() {\n        return this.__internal__chainProperties;\n    }\n    getClassName(Type) {\n        // we cannot rely on export order (anymore, since babel/core 7.15.8), so in the case of\n        // items such as u32 & U32, we get the lowercase versions here... not quite as optimal\n        // (previously this used to be a simple find & return)\n        const names = [];\n        for (const [name, Clazz] of this.__internal__knownDefaultsEntries) {\n            if (Type === Clazz) {\n                names.push(name);\n            }\n        }\n        for (const [name, Clazz] of this.__internal__classes.entries()) {\n            if (Type === Clazz) {\n                names.push(name);\n            }\n        }\n        return names.length\n            // both sort and reverse are done in-place\n            // ['U32', 'u32'] -> ['u32', 'U32']\n            ? names.sort().reverse()[0]\n            : undefined;\n    }\n    getDefinition(typeName) {\n        return this.__internal__definitions.get(typeName);\n    }\n    getModuleInstances(specName, moduleName) {\n        return this.__internal__knownTypes?.typesBundle?.spec?.[specName.toString()]?.instances?.[moduleName] || this.__internal__moduleMap[moduleName];\n    }\n    getOrThrow(name) {\n        const Clazz = this.get(name);\n        if (!Clazz) {\n            throw new Error(`type ${name} not found`);\n        }\n        return Clazz;\n    }\n    getOrUnknown(name) {\n        return this.get(name, true);\n    }\n    getSignedExtensionExtra() {\n        return expandExtensionTypes(this.__internal__signedExtensions, 'payload', this.__internal__userExtensions);\n    }\n    getSignedExtensionTypes() {\n        return expandExtensionTypes(this.__internal__signedExtensions, 'extrinsic', this.__internal__userExtensions);\n    }\n    hasClass(name) {\n        return this.__internal__classes.has(name) || !!this.__internal__knownDefaults[name];\n    }\n    hasDef(name) {\n        return this.__internal__definitions.has(name);\n    }\n    hasType(name) {\n        return !this.__internal__unknownTypes.get(name) && (this.hasClass(name) || this.hasDef(name));\n    }\n    hash(data) {\n        return this.createType('CodecHash', this.__internal__hasher(data));\n    }\n    // eslint-disable-next-line no-dupe-class-members\n    register(arg1, arg2) {\n        // NOTE Constructors appear as functions here\n        if (isFunction(arg1)) {\n            this.__internal__classes.set(arg1.name, arg1);\n        }\n        else if (isString(arg1)) {\n            if (!isFunction(arg2)) {\n                throw new Error(`Expected class definition passed to '${arg1}' registration`);\n            }\n            else if (arg1 === arg2.toString()) {\n                throw new Error(`Unable to register circular ${arg1} === ${arg1}`);\n            }\n            this.__internal__classes.set(arg1, arg2);\n        }\n        else {\n            this.__internal__registerObject(arg1);\n        }\n    }\n    __internal__registerObject = (obj) => {\n        const entries = Object.entries(obj);\n        for (let e = 0, count = entries.length; e < count; e++) {\n            const [name, type] = entries[e];\n            if (isFunction(type)) {\n                // This _looks_ a bit funny, but `typeof Clazz === 'function'\n                this.__internal__classes.set(name, type);\n            }\n            else {\n                const def = isString(type)\n                    ? type\n                    : stringify(type);\n                if (name === def) {\n                    throw new Error(`Unable to register circular ${name} === ${def}`);\n                }\n                // we already have this type, remove the classes registered for it\n                if (this.__internal__classes.has(name)) {\n                    this.__internal__classes.delete(name);\n                }\n                this.__internal__definitions.set(name, def);\n            }\n        }\n    };\n    // sets the chain properties\n    setChainProperties(properties) {\n        if (properties) {\n            this.__internal__chainProperties = properties;\n        }\n    }\n    setHasher(hasher) {\n        this.__internal__hasher = hasher || blake2AsU8a;\n    }\n    setKnownTypes(knownTypes) {\n        this.__internal__knownTypes = knownTypes;\n    }\n    setLookup(lookup) {\n        this.__internal__lookup = lookup;\n        // register all applicable types found\n        lookup.register();\n    }\n    // register alias types alongside the portable/lookup setup\n    // (we don't combine this into setLookup since that would/could\n    // affect stand-along lookups, such as ABIs which don't have\n    // actual on-chain metadata)\n    __internal__registerLookup = (lookup) => {\n        // attach the lookup before we register any types\n        this.setLookup(lookup);\n        // we detect based on runtime configuration\n        let Weight = null;\n        if (this.hasType('SpWeightsWeightV2Weight')) {\n            // detection for WeightV2 type based on latest naming\n            const weightv2 = this.createType('SpWeightsWeightV2Weight');\n            Weight = weightv2.refTime && weightv2.proofSize\n                // with both refTime & proofSize we use as-is (WeightV2)\n                ? 'SpWeightsWeightV2Weight'\n                // fallback to WeightV1 (WeightV1.5 is a struct, single field)\n                : 'WeightV1';\n        }\n        else if (!isBn(this.createType('Weight'))) {\n            // where we have an already-supplied BN override, we don't clobber\n            // it with our detected value (This protects against pre-defines\n            // where Weight may be aliassed to WeightV0, e.g. in early Kusama chains)\n            Weight = 'WeightV1';\n        }\n        if (Weight) {\n            // we have detected a version, adjust the definition\n            this.register({ Weight });\n        }\n    };\n    // sets the metadata\n    setMetadata(metadata, signedExtensions, userExtensions, noInitWarn) {\n        this.__internal__metadata = metadata.asLatest;\n        this.__internal__metadataVersion = metadata.version;\n        this.__internal__firstCallIndex = null;\n        // attach the lookup at this point and register relevant types (before injecting)\n        this.__internal__registerLookup(this.__internal__metadata.lookup);\n        injectExtrinsics(this, this.__internal__metadata, this.__internal__metadataVersion, this.__internal__metadataCalls, this.__internal__moduleMap);\n        injectErrors(this, this.__internal__metadata, this.__internal__metadataVersion, this.__internal__metadataErrors);\n        injectEvents(this, this.__internal__metadata, this.__internal__metadataVersion, this.__internal__metadataEvents);\n        // set the default call index (the lowest section, the lowest method)\n        // in most chains this should be 0,0\n        const [defSection] = Object\n            .keys(this.__internal__metadataCalls)\n            .sort(sortDecimalStrings);\n        if (defSection) {\n            const [defMethod] = Object\n                .keys(this.__internal__metadataCalls[defSection])\n                .sort(sortDecimalStrings);\n            if (defMethod) {\n                this.__internal__firstCallIndex = new Uint8Array([parseInt(defSection, 10), parseInt(defMethod, 10)]);\n            }\n        }\n        // setup the available extensions\n        this.setSignedExtensions(signedExtensions || (this.__internal__metadata.extrinsic.version.gt(BN_ZERO)\n            // FIXME Use the extension and their injected types\n            ? this.__internal__metadata.extrinsic.signedExtensions.map(({ identifier }) => identifier.toString())\n            : fallbackExtensions), userExtensions, noInitWarn);\n        // setup the chain properties with format overrides\n        this.setChainProperties(extractProperties(this, metadata));\n    }\n    // sets the available signed extensions\n    setSignedExtensions(signedExtensions = fallbackExtensions, userExtensions, noInitWarn) {\n        this.__internal__signedExtensions = signedExtensions;\n        this.__internal__userExtensions = userExtensions;\n        if (!noInitWarn) {\n            const unknown = findUnknownExtensions(this.__internal__signedExtensions, this.__internal__userExtensions);\n            if (unknown.length) {\n                l.warn(`Unknown signed extensions ${unknown.join(', ')} found, treating them as no-effect`);\n            }\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}