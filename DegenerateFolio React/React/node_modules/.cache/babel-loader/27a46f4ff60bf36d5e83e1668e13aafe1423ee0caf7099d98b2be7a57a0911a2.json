{"ast":null,"code":"\"use strict\";\n\nfunction buildArc(points, x, y, radius, start, end, clockwise, steps) {\n  let dist = Math.abs(start - end);\n  if (!clockwise && start > end) {\n    dist = 2 * Math.PI - dist;\n  } else if (clockwise && end > start) {\n    dist = 2 * Math.PI - dist;\n  }\n  steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));\n  steps = Math.max(steps, 3);\n  let f = dist / steps;\n  let t = start;\n  f *= clockwise ? -1 : 1;\n  for (let i = 0; i < steps + 1; i++) {\n    const cs = Math.cos(t);\n    const sn = Math.sin(t);\n    const nx = x + cs * radius;\n    const ny = y + sn * radius;\n    points.push(nx, ny);\n    t += f;\n  }\n}\nexport { buildArc };","map":{"version":3,"names":["buildArc","points","x","y","radius","start","end","clockwise","steps","dist","Math","abs","PI","max","floor","pow","f","t","i","cs","cos","sn","sin","nx","ny","push"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArc.ts"],"sourcesContent":["export function buildArc(\n    points: number[],\n    x: number, y: number,\n    radius: number,\n    start: number,\n    end: number,\n    clockwise: boolean,\n    steps?: number\n)\n{\n    // determine distance between the two angles\n    // ...probably a nicer way of writing this\n    let dist = Math.abs(start - end);\n\n    if (!clockwise && start > end)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n    else if (clockwise && end > start)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n\n    // approximate the # of steps using the cube root of the radius\n\n    steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / (Math.PI))));\n\n    // ensure we have at least 3 steps..\n    steps = Math.max(steps, 3);\n\n    let f = dist / (steps);\n    let t = start;\n\n    // modify direction\n    f *= clockwise ? -1 : 1;\n\n    for (let i = 0; i < steps + 1; i++)\n    {\n        const cs = Math.cos(t);\n        const sn = Math.sin(t);\n\n        const nx = x + (cs * radius);\n        const ny = y + (sn * radius);\n\n        points.push(nx, ny);\n\n        t += f;\n    }\n}\n"],"mappings":";;AAAgB,SAAAA,SACZC,MAAA,EACAC,CAAW,EAAAC,CAAA,EACXC,MAAA,EACAC,KACA,EAAAC,GAAA,EACAC,SAAA,EACAC,KAEJ;EAGI,IAAIC,IAAO,GAAAC,IAAA,CAAKC,GAAI,CAAAN,KAAA,GAAQC,GAAG;EAE3B,KAACC,SAAa,IAAAF,KAAA,GAAQC,GAC1B;IACYG,IAAA,OAAIC,IAAA,CAAKE,EAAM,GAAAH,IAAA;EAAA,CAC3B,UACSF,SAAa,IAAAD,GAAA,GAAMD,KAC5B;IACYI,IAAA,OAAIC,IAAA,CAAKE,EAAM,GAAAH,IAAA;EAAA;EAK3BD,KAAA,GAAQA,KAAA,IAASE,IAAK,CAAAG,GAAA,CAAI,CAAG,EAAAH,IAAA,CAAKI,KAAA,CAAM,CAAI,GAAAJ,IAAA,CAAKK,GAAI,CAAAX,MAAA,EAAQ,IAAI,CAAC,KAAKK,IAAQ,GAAAC,IAAA,CAAKE,EAAA,CAAI,CAAC;EAGjFJ,KAAA,GAAAE,IAAA,CAAKG,GAAI,CAAAL,KAAA,EAAO,CAAC;EAEzB,IAAIQ,CAAA,GAAIP,IAAQ,GAAAD,KAAA;EAChB,IAAIS,CAAI,GAAAZ,KAAA;EAGRW,CAAA,IAAKT,SAAA,GAAY,CAAK;EAEtB,SAASW,CAAI,MAAGA,CAAI,GAAAV,KAAA,GAAQ,GAAGU,CAC/B;IACU,MAAAC,EAAA,GAAKT,IAAK,CAAAU,GAAA,CAAIH,CAAC;IACf,MAAAI,EAAA,GAAKX,IAAK,CAAAY,GAAA,CAAIL,CAAC;IAEf,MAAAM,EAAA,GAAKrB,CAAA,GAAKiB,EAAK,GAAAf,MAAA;IACf,MAAAoB,EAAA,GAAKrB,CAAA,GAAKkB,EAAK,GAAAjB,MAAA;IAEdH,MAAA,CAAAwB,IAAA,CAAKF,EAAA,EAAIC,EAAE;IAEbP,CAAA,IAAAD,CAAA;EAAA;AAEb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}