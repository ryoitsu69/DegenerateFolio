{"ast":null,"code":"import { Circle } from '../../../../maths/shapes/Circle.mjs';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse.mjs';\nimport { Polygon } from '../../../../maths/shapes/Polygon.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle.mjs';\nimport { Bounds } from '../../../container/bounds/Bounds.mjs';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier.mjs';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic.mjs';\nimport { buildArc } from '../buildCommands/buildArc.mjs';\nimport { buildArcTo } from '../buildCommands/buildArcTo.mjs';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg.mjs';\nimport { roundedShapeQuadraticCurve, roundedShapeArc } from './roundShape.mjs';\n\"use strict\";\nconst tempRectangle = new Rectangle();\nclass ShapePath {\n  constructor(graphicsPath2D) {\n    /** The list of shape primitives that make up the path. */\n    this.shapePrimitives = [];\n    this._currentPoly = null;\n    this._bounds = new Bounds();\n    this._graphicsPath2D = graphicsPath2D;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this.startPoly(x, y);\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  }\n  /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._ensurePoly(false);\n    const points = this._currentPoly.points;\n    buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n    return this;\n  }\n  /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    buildArcTo(points, x1, y1, x2, y2, radius);\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    const points = this._currentPoly.points;\n    buildArcToSvg(points, this._currentPoly.lastX, this._currentPoly.lastY, x, y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag);\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveBezier(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, cp2x, cp2y, x, y, smoothness);\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveQuadratic(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, x, y, smoothing);\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.endPoly(true);\n    return this;\n  }\n  /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    this.endPoly();\n    if (transform && !transform.isIdentity()) {\n      path = path.clone(true);\n      path.transform(transform);\n    }\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    return this;\n  }\n  /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */\n  finish(closePath = false) {\n    this.endPoly(closePath);\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.drawShape(new Rectangle(x, y, w, h), transform);\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.drawShape(new Circle(x, y, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  poly(points, close, transform) {\n    const polygon = new Polygon(points);\n    polygon.closePath = close;\n    this.drawShape(polygon, transform);\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    sides = Math.max(sides | 0, 3);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const polygon = [];\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      polygon.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle));\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n    sides = Math.max(sides | 0, 3);\n    if (corner <= 0) {\n      return this.regularPoly(x, y, radius, sides, rotation);\n    }\n    const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n    corner = Math.min(corner, sideLength);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const internalAngle = (sides - 2) * Math.PI / sides / 2;\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      const x0 = x + radius * Math.cos(angle);\n      const y0 = y + radius * Math.sin(angle);\n      const a1 = angle + Math.PI + internalAngle;\n      const a2 = angle - Math.PI - internalAngle;\n      const x1 = x0 + corner * Math.cos(a1);\n      const y1 = y0 + corner * Math.sin(a1);\n      const x3 = x0 + corner * Math.cos(a2);\n      const y3 = y0 + corner * Math.sin(a2);\n      if (i === 0) {\n        this.moveTo(x1, y1);\n      } else {\n        this.lineTo(x1, y1);\n      }\n      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic = false, smoothness) {\n    if (points.length < 3) {\n      return this;\n    }\n    if (useQuadratic) {\n      roundedShapeQuadraticCurve(this, points, radius, smoothness);\n    } else {\n      roundedShapeArc(this, points, radius);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    if (fillet === 0) {\n      return this.rect(x, y, width, height);\n    }\n    const maxFillet = Math.min(width, height) / 2;\n    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n    const right = x + width;\n    const bottom = y + height;\n    const dir = inset < 0 ? -inset : 0;\n    const size = Math.abs(inset);\n    return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    if (chamfer <= 0) {\n      return this.rect(x, y, width, height);\n    }\n    const inset = Math.min(chamfer, Math.min(width, height) / 2);\n    const right = x + width;\n    const bottom = y + height;\n    const points = [x + inset, y, right - inset, y, right, y + inset, right, bottom - inset, right - inset, bottom, x + inset, bottom, x, bottom - inset, x, y + inset];\n    for (let i = points.length - 1; i >= 2; i -= 2) {\n      if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {\n        points.splice(i - 1, 2);\n      }\n    }\n    return this.poly(points, true, transform);\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY, transform) {\n    this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius, transform) {\n    this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */\n  drawShape(shape, matrix) {\n    this.endPoly();\n    this.shapePrimitives.push({\n      shape,\n      transform: matrix\n    });\n    return this;\n  }\n  /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  startPoly(x, y) {\n    let currentPoly = this._currentPoly;\n    if (currentPoly) {\n      this.endPoly();\n    }\n    currentPoly = new Polygon();\n    currentPoly.points.push(x, y);\n    this._currentPoly = currentPoly;\n    return this;\n  }\n  /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  endPoly(closePath = false) {\n    const shape = this._currentPoly;\n    if (shape && shape.points.length > 2) {\n      shape.closePath = closePath;\n      this.shapePrimitives.push({\n        shape\n      });\n    }\n    this._currentPoly = null;\n    return this;\n  }\n  _ensurePoly(start = true) {\n    if (this._currentPoly) return;\n    this._currentPoly = new Polygon();\n    if (start) {\n      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n      if (lastShape) {\n        let lx = lastShape.shape.x;\n        let ly = lastShape.shape.y;\n        if (!lastShape.transform.isIdentity()) {\n          const t = lastShape.transform;\n          const tempX = lx;\n          lx = t.a * lx + t.c * ly + t.tx;\n          ly = t.b * tempX + t.d * ly + t.ty;\n        }\n        this._currentPoly.points.push(lx, ly);\n      } else {\n        this._currentPoly.points.push(0, 0);\n      }\n    }\n  }\n  /** Builds the path. */\n  buildPath() {\n    const path = this._graphicsPath2D;\n    this.shapePrimitives.length = 0;\n    this._currentPoly = null;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    this.finish();\n  }\n  /** Gets the bounds of the path. */\n  get bounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    const shapePrimitives = this.shapePrimitives;\n    for (let i = 0; i < shapePrimitives.length; i++) {\n      const shapePrimitive = shapePrimitives[i];\n      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n      if (shapePrimitive.transform) {\n        bounds.addRect(boundsRect, shapePrimitive.transform);\n      } else {\n        bounds.addRect(boundsRect);\n      }\n    }\n    return bounds;\n  }\n}\nexport { ShapePath };","map":{"version":3,"names":["tempRectangle","Rectangle","ShapePath","constructor","graphicsPath2D","shapePrimitives","_currentPoly","_bounds","Bounds","_graphicsPath2D","moveTo","x","y","startPoly","lineTo","_ensurePoly","points","fromX","length","fromY","push","arc","radius","startAngle","endAngle","counterclockwise","buildArc","arcTo","x1","y1","x2","y2","buildArcTo","arcToSvg","rx","ry","xAxisRotation","largeArcFlag","sweepFlag","buildArcToSvg","lastX","lastY","bezierCurveTo","cp1x","cp1y","cp2x","cp2y","smoothness","currentPoly","buildAdaptiveBezier","quadraticCurveTo","smoothing","buildAdaptiveQuadratic","closePath","endPoly","addPath","path","transform","isIdentity","clone","i","instructions","instruction","action","data","finish","rect","w","h","drawShape","circle","Circle","poly","close","polygon","Polygon","regularPoly","sides","rotation","Math","max","PI","delta","angle","cos","sin","roundPoly","corner","sideLength","min","internalAngle","x0","y0","a1","a2","x3","y3","roundShape","useQuadratic","roundedShapeQuadraticCurve","roundedShapeArc","filletRect","width","height","fillet","maxFillet","inset","right","bottom","dir","size","abs","chamferRect","chamfer","splice","ellipse","radiusX","radiusY","Ellipse","roundRect","RoundedRectangle","shape","matrix","start","lastShape","lx","ly","t","tempX","a","c","tx","b","d","ty","buildPath","bounds","clear","shapePrimitive","boundsRect","getBounds","addRect"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/graphics/shared/path/ShapePath.ts"],"sourcesContent":["// a shape lets you build out a shape with lines and curves and primitives..\n\nimport { Circle } from '../../../../maths/shapes/Circle';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport { Polygon } from '../../../../maths/shapes/Polygon';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport { Bounds } from '../../../container/bounds/Bounds';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic';\nimport { buildArc } from '../buildCommands/buildArc';\nimport { buildArcTo } from '../buildCommands/buildArcTo';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg';\nimport { roundedShapeArc, roundedShapeQuadraticCurve } from './roundShape';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { GraphicsPath } from './GraphicsPath';\nimport type { RoundedPoint } from './roundShape';\n\nconst tempRectangle = new Rectangle();\n\n/**\n * The `ShapePath` class acts as a bridge between high-level drawing commands\n * and the lower-level `GraphicsContext` rendering engine.\n * It translates drawing commands, such as those for creating lines, arcs, ellipses, rectangles, and complex polygons, into a\n * format that can be efficiently processed by a `GraphicsContext`. This includes handling path starts,\n * ends, and transformations for shapes.\n *\n * It is used internally by `GraphicsPath` to build up the path.\n * @memberof scene\n */\nexport class ShapePath\n{\n    /** The list of shape primitives that make up the path. */\n    public shapePrimitives: { shape: ShapePrimitive, transform?: Matrix }[] = [];\n    private _currentPoly: Polygon | null = null;\n    private readonly _graphicsPath2D: GraphicsPath;\n    private readonly _bounds = new Bounds();\n\n    constructor(graphicsPath2D: GraphicsPath)\n    {\n        this._graphicsPath2D = graphicsPath2D;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly(x, y);\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise: boolean): this\n    {\n        // TODO - if its 360 degrees.. make it a circle object?\n\n        this._ensurePoly(false);\n\n        const points = this._currentPoly.points;\n\n        buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        buildArcTo(points, x1, y1, x2, y2, radius);\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number, largeArcFlag: number, sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        const points = this._currentPoly.points;\n\n        // this needs to work on both canvas and GPU backends so might want to move this to the Graphics2D path..\n        buildArcToSvg(\n            points,\n            this._currentPoly.lastX,\n            this._currentPoly.lastY,\n            x,\n            y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveBezier(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, cp2x, cp2y, x, y,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cp1x: number, cp1y: number, x: number, y: number, smoothing?: number): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveQuadratic(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, x, y,\n            smoothing,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.endPoly(true);\n\n        return this;\n    }\n\n    /**\n     * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n     * @param path - The `GraphicsPath` object representing the path to add.\n     * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        this.endPoly();\n\n        if (transform && !transform.isIdentity())\n        {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n            // build out the path points\n        }\n\n        return this;\n    }\n\n    /**\n     * Finalizes the drawing of the current path. Optionally, it can close the path.\n     * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n     */\n    public finish(closePath = false)\n    {\n        this.endPoly(closePath);\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.drawShape(new Rectangle(x, y, w, h), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.drawShape(new Circle(x, y, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n     * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this\n    {\n        const polygon = new Polygon(points);\n\n        polygon.closePath = close;\n\n        this.drawShape(polygon, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const polygon = [];\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (radius * Math.cos(angle)),\n                y + (radius * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(\n        x: number, y: number,\n        radius: number,\n        sides: number, corner: number,\n        rotation = 0,\n        smoothness?: number,\n    ): this\n    {\n        sides = Math.max((sides | 0), 3);\n\n        if (corner <= 0)\n        {\n            return this.regularPoly(x, y, radius, sides, rotation);\n        }\n\n        const sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;\n\n        corner = Math.min(corner, sideLength);\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const internalAngle = ((sides - 2) * Math.PI) / sides / 2;\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n            const x0 = x + (radius * Math.cos(angle));\n            const y0 = y + (radius * Math.sin(angle));\n            const a1 = angle + (Math.PI) + internalAngle;\n            const a2 = angle - (Math.PI) - internalAngle;\n            const x1 = x0 + (corner * Math.cos(a1));\n            const y1 = y0 + (corner * Math.sin(a1));\n            const x3 = x0 + (corner * Math.cos(a2));\n            const y3 = y0 + (corner * Math.sin(a2));\n\n            if (i === 0)\n            {\n                this.moveTo(x1, y1);\n            }\n            else\n            {\n                this.lineTo(x1, y1);\n            }\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic = false, smoothness?: number): this\n    {\n        if (points.length < 3)\n        {\n            return this;\n        }\n\n        if (useQuadratic)\n        {\n            roundedShapeQuadraticCurve(this, points, radius, smoothness);\n        }\n        else\n        {\n            roundedShapeArc(this, points, radius);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        if (fillet === 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n\n        return this\n            .moveTo(x, y + size)\n            .arcTo(x + dir, y + dir, x + size, y, size)\n            .lineTo(right - size, y)\n            .arcTo(right - dir, y + dir, right, y + size, size)\n            .lineTo(right, bottom - size)\n            .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)\n            .lineTo(x + size, bottom)\n            .arcTo(x + dir, bottom - dir, x, bottom - size, size)\n            .closePath();\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        if (chamfer <= 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset, y,\n            right - inset, y,\n            right, y + inset,\n            right, bottom - inset,\n            right - inset, bottom,\n            x + inset, bottom,\n            x, bottom - inset,\n            x, y + inset,\n        ];\n\n        // Remove overlapping points\n        for (let i = points.length - 1; i >= 2; i -= 2)\n        {\n            if (points[i] === points[i - 2] && points[i - 1] === points[i - 3])\n            {\n                points.splice(i - 1, 2);\n            }\n        }\n\n        return this.poly(points, true, transform);\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, transform?: Matrix): this\n    {\n        // TODO apply rotation to transform...\n\n        this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this\n    {\n        this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a given shape on the canvas.\n     * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n     * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n     * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n     * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n     * scaling, and translations.\n     * @returns The instance of the current object for chaining.\n     */\n    public drawShape(shape: ShapePrimitive, matrix?: Matrix): this\n    {\n        this.endPoly();\n\n        this.shapePrimitives.push({ shape, transform: matrix });\n\n        return this;\n    }\n\n    /**\n     * Starts a new polygon path from the specified starting point.\n     * This method initializes a new polygon or ends the current one if it exists.\n     * @param x - The x-coordinate of the starting point of the new polygon.\n     * @param y - The y-coordinate of the starting point of the new polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public startPoly(x: number, y: number): this\n    {\n        let currentPoly = this._currentPoly;\n\n        if (currentPoly)\n        {\n            this.endPoly();\n        }\n\n        currentPoly = new Polygon();\n\n        currentPoly.points.push(x, y);\n\n        this._currentPoly = currentPoly;\n\n        return this;\n    }\n\n    /**\n     * Ends the current polygon path. If `closePath` is set to true,\n     * the path is closed by connecting the last point to the first one.\n     * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n     * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n     *  back to the starting point. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public endPoly(closePath = false): this\n    {\n        const shape = this._currentPoly;\n\n        if (shape && shape.points.length > 2)\n        {\n            shape.closePath = closePath;\n\n            this.shapePrimitives.push({ shape });\n        }\n\n        this._currentPoly = null;\n\n        return this;\n    }\n\n    private _ensurePoly(start = true): void\n    {\n        if (this._currentPoly) return;\n\n        this._currentPoly = new Polygon();\n\n        if (start)\n        {\n            // get last points..\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n\n            if (lastShape)\n            {\n                // i KNOW its a rect..\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n\n                if (!lastShape.transform.isIdentity())\n                {\n                    const t = lastShape.transform;\n\n                    const tempX = lx;\n\n                    lx = (t.a * lx) + (t.c * ly) + t.tx;\n                    ly = (t.b * tempX) + (t.d * ly) + t.ty;\n                }\n\n                this._currentPoly.points.push(lx, ly);\n            }\n            else\n            {\n                this._currentPoly.points.push(0, 0);\n            }\n        }\n    }\n\n    /** Builds the path. */\n    public buildPath()\n    {\n        const path = this._graphicsPath2D;\n\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        this.finish();\n    }\n\n    /** Gets the bounds of the path. */\n    get bounds(): Bounds\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        const shapePrimitives = this.shapePrimitives;\n\n        for (let i = 0; i < shapePrimitives.length; i++)\n        {\n            const shapePrimitive = shapePrimitives[i];\n\n            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n\n            if (shapePrimitive.transform)\n            {\n                bounds.addRect(boundsRect, shapePrimitive.transform);\n            }\n            else\n            {\n                bounds.addRect(boundsRect);\n            }\n        }\n\n        return bounds;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}