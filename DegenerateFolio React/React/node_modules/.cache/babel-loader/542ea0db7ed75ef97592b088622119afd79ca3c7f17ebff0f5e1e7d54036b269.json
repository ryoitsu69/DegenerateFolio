{"ast":null,"code":"import { Cache } from '../../../../../assets/cache/Cache.mjs';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from '../sources/TextureSource.mjs';\nimport { Texture } from '../Texture.mjs';\n\"use strict\";\nconst sources = [];\nextensions.handleByList(ExtensionType.TextureSource, sources);\nfunction autoDetectSource(options = {}) {\n  const hasResource = options && options.resource;\n  const res = hasResource ? options.resource : options;\n  const opts = hasResource ? options : {\n    resource: options\n  };\n  for (let i = 0; i < sources.length; i++) {\n    const Source = sources[i];\n    if (Source.test(res)) {\n      return new Source(opts);\n    }\n  }\n  throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\nfunction resourceToTexture(options = {}, skipCache = false) {\n  const hasResource = options && options.resource;\n  const resource = hasResource ? options.resource : options;\n  const opts = hasResource ? options : {\n    resource: options\n  };\n  if (!skipCache && Cache.has(resource)) {\n    return Cache.get(resource);\n  }\n  const texture = new Texture({\n    source: autoDetectSource(opts)\n  });\n  texture.on(\"destroy\", () => {\n    if (Cache.has(resource)) {\n      Cache.remove(resource);\n    }\n  });\n  if (!skipCache) {\n    Cache.set(resource, texture);\n  }\n  return texture;\n}\nfunction textureFrom(id, skipCache = false) {\n  if (typeof id === \"string\") {\n    return Cache.get(id);\n  } else if (id instanceof TextureSource) {\n    return new Texture({\n      source: id\n    });\n  }\n  return resourceToTexture(id, skipCache);\n}\nTexture.from = textureFrom;\nexport { autoDetectSource, resourceToTexture, textureFrom };","map":{"version":3,"names":["sources","extensions","handleByList","ExtensionType","TextureSource","autoDetectSource","options","hasResource","resource","res","opts","i","length","Source","test","Error","resourceToTexture","skipCache","Cache","has","get","texture","Texture","source","on","remove","set","textureFrom","id","from"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/textureFrom.ts"],"sourcesContent":["import { Cache } from '../../../../../assets/cache/Cache';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from '../sources/TextureSource';\nimport { Texture } from '../Texture';\n\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { BufferSourceOptions } from '../sources/BufferSource';\nimport type { ImageResource } from '../sources/ImageSource';\nimport type { TextureSourceOptions } from '../sources/TextureSource';\nimport type { TextureSourceLike } from '../Texture';\n\ninterface TextureSourceConstructor<T extends TextureSource = TextureSource>\n{\n    new (options: TextureSourceOptions): T;\n    test(options: ImageResource | TypedArray | ArrayBuffer): boolean;\n}\n\nconst sources: TextureSourceConstructor[] = [];\n\nextensions.handleByList(ExtensionType.TextureSource, sources);\n\nexport type TextureResourceOrOptions =\n  ImageResource\n  | TextureSourceOptions<ImageResource>\n  | BufferSourceOptions;\n\nexport function autoDetectSource(options: TextureResourceOrOptions = {}): TextureSource\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const res = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    for (let i = 0; i < sources.length; i++)\n    {\n        const Source = sources[i];\n\n        if (Source.test(res))\n        {\n            return new Source(opts);\n        }\n    }\n\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\n\nexport function resourceToTexture(\n    options: TextureResourceOrOptions = {},\n    skipCache = false\n): Texture\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const resource = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    if (!skipCache && Cache.has(resource))\n    {\n        return Cache.get(resource);\n    }\n\n    const texture = new Texture({ source: autoDetectSource(opts) });\n\n    texture.on('destroy', () =>\n    {\n        if (Cache.has(resource))\n        {\n            Cache.remove(resource);\n        }\n    });\n\n    if (!skipCache)\n    {\n        Cache.set(resource, texture);\n    }\n\n    return texture;\n}\n\n/**\n * Helper function that creates a returns Texture based on the source you provide.\n * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n * @param id - String or Source to create texture from\n * @param skipCache - Skip adding the texture to the cache\n * @returns The texture based on the Id provided\n */\nexport function textureFrom(id: TextureSourceLike, skipCache = false): Texture\n{\n    if (typeof id === 'string')\n    {\n        return Cache.get(id);\n    }\n    else if (id instanceof TextureSource)\n    {\n        return new Texture({ source: id });\n    }\n\n    // return a auto generated texture from resource\n    return resourceToTexture(id, skipCache);\n}\n\nTexture.from = textureFrom;\n"],"mappings":";;;;;AAiBA,MAAMA,OAAA,GAAsC,EAAC;AAE7CC,UAAW,CAAAC,YAAA,CAAaC,aAAc,CAAAC,aAAA,EAAeJ,OAAO;AAO5C,SAAAK,iBAAiBC,OAAoC,KACrE;EACU,MAAAC,WAAA,GAAcD,OAAA,IAAYA,OAAiC,CAAAE,QAAA;EAC3D,MAAAC,GAAA,GAAMF,WAAe,GAAAD,OAAA,CAAiCE,QAAW,GAAAF,OAAA;EACvE,MAAMI,IAAO,GAAAH,WAAA,GAAcD,OAAkC;IAAEE,QAAA,EAAUF;EAAQ;EAEjF,SAASK,CAAI,MAAGA,CAAI,GAAAX,OAAA,CAAQY,MAAA,EAAQD,CACpC;IACU,MAAAE,MAAA,GAASb,OAAA,CAAQW,CAAC;IAEpB,IAAAE,MAAA,CAAOC,IAAK,CAAAL,GAAG,CACnB;MACW,WAAII,MAAA,CAAOH,IAAI;IAAA;EAC1B;EAGJ,MAAM,IAAIK,KAAA,CAAoD,8CAAAL,IAAA,CAAKF,QAAU;AACjF;AAEO,SAASQ,iBACZA,CAAAV,OAAA,GAAoC,EAAC,EACrCW,SAAA,GAAY,KAEhB;EACU,MAAAV,WAAA,GAAcD,OAAA,IAAYA,OAAiC,CAAAE,QAAA;EAC3D,MAAAA,QAAA,GAAWD,WAAe,GAAAD,OAAA,CAAiCE,QAAW,GAAAF,OAAA;EAC5E,MAAMI,IAAO,GAAAH,WAAA,GAAcD,OAAkC;IAAEE,QAAA,EAAUF;EAAQ;EAEjF,IAAI,CAACW,SAAA,IAAaC,KAAM,CAAAC,GAAA,CAAIX,QAAQ,CACpC;IACW,OAAAU,KAAA,CAAME,GAAA,CAAIZ,QAAQ;EAAA;EAGvB,MAAAa,OAAA,GAAU,IAAIC,OAAQ;IAAEC,MAAA,EAAQlB,gBAAiB,CAAAK,IAAI;EAAA,CAAG;EAEtDW,OAAA,CAAAG,EAAA,CAAG,WAAW,MACtB;IACQ,IAAAN,KAAA,CAAMC,GAAI,CAAAX,QAAQ,CACtB;MACIU,KAAA,CAAMO,MAAA,CAAOjB,QAAQ;IAAA;EACzB,CACH;EAED,IAAI,CAACS,SACL;IACUC,KAAA,CAAAQ,GAAA,CAAIlB,QAAA,EAAUa,OAAO;EAAA;EAGxB,OAAAA,OAAA;AACX;AASgB,SAAAM,YAAYC,EAAuB,EAAAX,SAAA,GAAY,KAC/D;EACQ,WAAOW,EAAA,KAAO,QAClB;IACW,OAAAV,KAAA,CAAME,GAAA,CAAIQ,EAAE;EAAA,CACvB,UACSA,EAAA,YAAcxB,aACvB;IACI,OAAO,IAAIkB,OAAA,CAAQ;MAAEC,MAAA,EAAQK;IAAA,CAAI;EAAA;EAI9B,OAAAZ,iBAAA,CAAkBY,EAAA,EAAIX,SAAS;AAC1C;AAEAK,OAAA,CAAQO,IAAO,GAAAF,WAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}