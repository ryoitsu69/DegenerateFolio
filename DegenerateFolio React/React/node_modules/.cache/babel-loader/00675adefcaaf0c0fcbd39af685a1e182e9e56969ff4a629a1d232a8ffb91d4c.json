{"ast":null,"code":"\"use strict\";\n\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeNumber = exports.encodeNumber = void 0;\nconst web3_errors_1 = require(\"web3-errors\");\nconst web3_utils_1 = require(\"web3-utils\");\nconst web3_validator_1 = require(\"web3-validator\");\nconst utils_js_1 = require(\"../utils.js\");\nconst numbersLimits_js_1 = require(\"./numbersLimits.js\");\n// eslint-disable-next-line no-bitwise\nconst mask = BigInt(1) << BigInt(256);\nfunction bigIntToUint8Array(value) {\n  let byteLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : utils_js_1.WORD_SIZE;\n  let hexValue;\n  if (value < 0) {\n    hexValue = (mask + value).toString(16);\n  } else {\n    hexValue = value.toString(16);\n  }\n  hexValue = (0, web3_utils_1.padLeft)(hexValue, byteLength * 2);\n  return web3_validator_1.utils.hexToUint8Array(hexValue);\n}\nfunction uint8ArrayToBigInt(value, max) {\n  const hexValue = web3_validator_1.utils.uint8ArrayToHexString(value);\n  const result = BigInt(hexValue);\n  if (result <= max) return result;\n  return result - mask;\n}\nfunction encodeNumber(param, input) {\n  let value;\n  try {\n    value = (0, web3_utils_1.toBigInt)(input);\n  } catch (e) {\n    throw new web3_errors_1.AbiError('provided input is not number value', {\n      type: param.type,\n      value: input,\n      name: param.name\n    });\n  }\n  const limit = numbersLimits_js_1.numberLimits.get(param.type);\n  if (!limit) {\n    throw new web3_errors_1.AbiError('provided abi contains invalid number datatype', {\n      type: param.type\n    });\n  }\n  if (value < limit.min) {\n    throw new web3_errors_1.AbiError('provided input is less then minimum for given type', {\n      type: param.type,\n      value: input,\n      name: param.name,\n      minimum: limit.min.toString()\n    });\n  }\n  if (value > limit.max) {\n    throw new web3_errors_1.AbiError('provided input is greater then maximum for given type', {\n      type: param.type,\n      value: input,\n      name: param.name,\n      maximum: limit.max.toString()\n    });\n  }\n  return {\n    dynamic: false,\n    encoded: bigIntToUint8Array(value)\n  };\n}\nexports.encodeNumber = encodeNumber;\nfunction decodeNumber(param, bytes) {\n  if (bytes.length < utils_js_1.WORD_SIZE) {\n    throw new web3_errors_1.AbiError('Not enough bytes left to decode', {\n      param,\n      bytesLeft: bytes.length\n    });\n  }\n  const boolBytes = bytes.subarray(0, utils_js_1.WORD_SIZE);\n  const limit = numbersLimits_js_1.numberLimits.get(param.type);\n  if (!limit) {\n    throw new web3_errors_1.AbiError('provided abi contains invalid number datatype', {\n      type: param.type\n    });\n  }\n  const numberResult = uint8ArrayToBigInt(boolBytes, limit.max);\n  if (numberResult < limit.min) {\n    throw new web3_errors_1.AbiError('decoded value is less then minimum for given type', {\n      type: param.type,\n      value: numberResult,\n      name: param.name,\n      minimum: limit.min.toString()\n    });\n  }\n  if (numberResult > limit.max) {\n    throw new web3_errors_1.AbiError('decoded value is greater then maximum for given type', {\n      type: param.type,\n      value: numberResult,\n      name: param.name,\n      maximum: limit.max.toString()\n    });\n  }\n  return {\n    result: numberResult,\n    encoded: bytes.subarray(utils_js_1.WORD_SIZE),\n    consumed: utils_js_1.WORD_SIZE\n  };\n}\nexports.decodeNumber = decodeNumber;","map":{"version":3,"names":["web3_errors_1","require","web3_utils_1","web3_validator_1","utils_js_1","numbersLimits_js_1","mask","BigInt","bigIntToUint8Array","value","byteLength","arguments","length","undefined","WORD_SIZE","hexValue","toString","padLeft","utils","hexToUint8Array","uint8ArrayToBigInt","max","uint8ArrayToHexString","result","encodeNumber","param","input","toBigInt","e","AbiError","type","name","limit","numberLimits","get","min","minimum","maximum","dynamic","encoded","exports","decodeNumber","bytes","bytesLeft","boolBytes","subarray","numberResult","consumed"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/web3-eth-abi/src/coders/base/number.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { AbiError } from 'web3-errors';\nimport type { AbiParameter } from 'web3-types';\nimport { padLeft, toBigInt } from 'web3-utils';\nimport { utils } from 'web3-validator';\nimport { DecoderResult, EncoderResult } from '../types.js';\nimport { WORD_SIZE } from '../utils.js';\nimport { numberLimits } from './numbersLimits.js';\n\n// eslint-disable-next-line no-bitwise\nconst mask = BigInt(1) << BigInt(256);\n\nfunction bigIntToUint8Array(value: bigint, byteLength = WORD_SIZE): Uint8Array {\n\tlet hexValue;\n\tif (value < 0) {\n\t\thexValue = (mask + value).toString(16);\n\t} else {\n\t\thexValue = value.toString(16);\n\t}\n\thexValue = padLeft(hexValue, byteLength * 2);\n\treturn utils.hexToUint8Array(hexValue);\n}\n\nfunction uint8ArrayToBigInt(value: Uint8Array, max: bigint): bigint {\n\tconst hexValue = utils.uint8ArrayToHexString(value);\n\tconst result = BigInt(hexValue);\n\tif (result <= max) return result;\n\treturn result - mask;\n}\n\nexport function encodeNumber(param: AbiParameter, input: unknown): EncoderResult {\n\tlet value;\n\ttry {\n\t\tvalue = toBigInt(input);\n\t} catch (e) {\n\t\tthrow new AbiError('provided input is not number value', {\n\t\t\ttype: param.type,\n\t\t\tvalue: input,\n\t\t\tname: param.name,\n\t\t});\n\t}\n\tconst limit = numberLimits.get(param.type);\n\tif (!limit) {\n\t\tthrow new AbiError('provided abi contains invalid number datatype', { type: param.type });\n\t}\n\tif (value < limit.min) {\n\t\tthrow new AbiError('provided input is less then minimum for given type', {\n\t\t\ttype: param.type,\n\t\t\tvalue: input,\n\t\t\tname: param.name,\n\t\t\tminimum: limit.min.toString(),\n\t\t});\n\t}\n\tif (value > limit.max) {\n\t\tthrow new AbiError('provided input is greater then maximum for given type', {\n\t\t\ttype: param.type,\n\t\t\tvalue: input,\n\t\t\tname: param.name,\n\t\t\tmaximum: limit.max.toString(),\n\t\t});\n\t}\n\treturn {\n\t\tdynamic: false,\n\t\tencoded: bigIntToUint8Array(value),\n\t};\n}\n\nexport function decodeNumber(param: AbiParameter, bytes: Uint8Array): DecoderResult<bigint> {\n\tif (bytes.length < WORD_SIZE) {\n\t\tthrow new AbiError('Not enough bytes left to decode', { param, bytesLeft: bytes.length });\n\t}\n\tconst boolBytes = bytes.subarray(0, WORD_SIZE);\n\tconst limit = numberLimits.get(param.type);\n\tif (!limit) {\n\t\tthrow new AbiError('provided abi contains invalid number datatype', { type: param.type });\n\t}\n\tconst numberResult = uint8ArrayToBigInt(boolBytes, limit.max);\n\n\tif (numberResult < limit.min) {\n\t\tthrow new AbiError('decoded value is less then minimum for given type', {\n\t\t\ttype: param.type,\n\t\t\tvalue: numberResult,\n\t\t\tname: param.name,\n\t\t\tminimum: limit.min.toString(),\n\t\t});\n\t}\n\tif (numberResult > limit.max) {\n\t\tthrow new AbiError('decoded value is greater then maximum for given type', {\n\t\t\ttype: param.type,\n\t\t\tvalue: numberResult,\n\t\t\tname: param.name,\n\t\t\tmaximum: limit.max.toString(),\n\t\t});\n\t}\n\treturn {\n\t\tresult: numberResult,\n\t\tencoded: bytes.subarray(WORD_SIZE),\n\t\tconsumed: WORD_SIZE,\n\t};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}