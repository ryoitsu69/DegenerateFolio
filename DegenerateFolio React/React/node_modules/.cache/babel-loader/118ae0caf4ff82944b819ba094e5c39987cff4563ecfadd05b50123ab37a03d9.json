{"ast":null,"code":"import { Enum, Raw, Tuple, U64 } from '@polkadot/types-codec';\nimport { bnToBn, formatNumber, hexToU8a, isHex, isObject, isU8a, u8aToBn, u8aToU8a } from '@polkadot/util';\nimport { IMMORTAL_ERA } from './constants.js';\nfunction getTrailingZeros(period) {\n  const binary = period.toString(2);\n  let index = 0;\n  while (binary[binary.length - 1 - index] === '0') {\n    index++;\n  }\n  return index;\n}\n/** @internal */\nfunction decodeMortalEra(registry, value) {\n  if (isU8a(value) || isHex(value) || Array.isArray(value)) {\n    return decodeMortalU8a(registry, u8aToU8a(value));\n  } else if (!value) {\n    return [new U64(registry), new U64(registry)];\n  } else if (isObject(value)) {\n    return decodeMortalObject(registry, value);\n  }\n  throw new Error('Invalid data passed to Mortal era');\n}\n/** @internal */\nfunction decodeMortalObject(registry, value) {\n  const {\n    current,\n    period\n  } = value;\n  let calPeriod = Math.pow(2, Math.ceil(Math.log2(period)));\n  calPeriod = Math.min(Math.max(calPeriod, 4), 1 << 16);\n  const phase = current % calPeriod;\n  const quantizeFactor = Math.max(calPeriod >> 12, 1);\n  const quantizedPhase = phase / quantizeFactor * quantizeFactor;\n  return [new U64(registry, calPeriod), new U64(registry, quantizedPhase)];\n}\n/** @internal */\nfunction decodeMortalU8a(registry, value) {\n  if (value.length === 0) {\n    return [new U64(registry), new U64(registry)];\n  }\n  const first = u8aToBn(value.subarray(0, 1)).toNumber();\n  const second = u8aToBn(value.subarray(1, 2)).toNumber();\n  const encoded = first + (second << 8);\n  const period = 2 << encoded % (1 << 4);\n  const quantizeFactor = Math.max(period >> 12, 1);\n  const phase = (encoded >> 4) * quantizeFactor;\n  if (period < 4 || phase >= period) {\n    throw new Error('Invalid data passed to Mortal era');\n  }\n  return [new U64(registry, period), new U64(registry, phase)];\n}\n/** @internal */\nfunction decodeExtrinsicEra() {\n  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n  if (isU8a(value)) {\n    return !value.length || value[0] === 0 ? new Uint8Array([0]) : new Uint8Array([1, value[0], value[1]]);\n  } else if (!value) {\n    return new Uint8Array([0]);\n  } else if (value instanceof GenericExtrinsicEra) {\n    return decodeExtrinsicEra(value.toU8a());\n  } else if (isHex(value)) {\n    return decodeExtrinsicEra(hexToU8a(value));\n  } else if (isObject(value)) {\n    const entries = Object.entries(value).map(_ref => {\n      let [k, v] = _ref;\n      return [k.toLowerCase(), v];\n    });\n    const mortal = entries.find(_ref2 => {\n      let [k] = _ref2;\n      return k.toLowerCase() === 'mortalera';\n    });\n    const immortal = entries.find(_ref3 => {\n      let [k] = _ref3;\n      return k.toLowerCase() === 'immortalera';\n    });\n    // this is to de-serialize from JSON\n    return mortal ? {\n      MortalEra: mortal[1]\n    } : immortal ? {\n      ImmortalEra: immortal[1]\n    } : {\n      MortalEra: value\n    };\n  }\n  throw new Error('Invalid data passed to Era');\n}\n/**\n * @name ImmortalEra\n * @description\n * The ImmortalEra for an extrinsic\n */\nexport class ImmortalEra extends Raw {\n  constructor(registry, _value) {\n    // For immortals, we always provide the known value (i.e. treated as a\n    // constant no matter how it is constructed - it is a fixed structure)\n    super(registry, IMMORTAL_ERA);\n  }\n}\n/**\n * @name MortalEra\n * @description\n * The MortalEra for an extrinsic, indicating period and phase\n */\nexport class MortalEra extends Tuple {\n  constructor(registry, value) {\n    super(registry, {\n      period: U64,\n      phase: U64\n    }, decodeMortalEra(registry, value));\n  }\n  /**\n   * @description Encoded length for mortals occupy 2 bytes, different from the actual Tuple since it is encoded. This is a shortcut fro `toU8a().length`\n   */\n  get encodedLength() {\n    return 2 | 0;\n  }\n  /**\n   * @description The period of this Mortal wraps as a [[U64]]\n   */\n  get period() {\n    return this[0];\n  }\n  /**\n   * @description The phase of this Mortal wraps as a [[U64]]\n   */\n  get phase() {\n    return this[1];\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman() {\n    return {\n      period: formatNumber(this.period),\n      phase: formatNumber(this.phase)\n    };\n  }\n  /**\n   * @description Returns a JSON representation of the actual value\n   */\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   * Period and phase are encoded:\n   *   - The period of validity from the block hash found in the signing material.\n   *   - The phase in the period that this transaction's lifetime begins (and, importantly,\n   *     implies which block hash is included in the signature material). If the `period` is\n   *     greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that\n   *     `period` is.\n   */\n  toU8a(_isBare) {\n    const period = this.period.toNumber();\n    const encoded = Math.min(15, Math.max(1, getTrailingZeros(period) - 1)) + (this.phase.toNumber() / Math.max(period >> 12, 1) << 4);\n    return new Uint8Array([encoded & 0xff, encoded >> 8]);\n  }\n  /**\n   * @description Get the block number of the start of the era whose properties this object describes that `current` belongs to.\n   */\n  birth(current) {\n    const phase = this.phase.toNumber();\n    const period = this.period.toNumber();\n    // FIXME No toNumber() here\n    return ~~((Math.max(bnToBn(current).toNumber(), phase) - phase) / period) * period + phase;\n  }\n  /**\n   * @description Get the block number of the first block at which the era has ended.\n   */\n  death(current) {\n    // FIXME No toNumber() here\n    return this.birth(current) + this.period.toNumber();\n  }\n}\n/**\n * @name GenericExtrinsicEra\n * @description\n * The era for an extrinsic, indicating either a mortal or immortal extrinsic\n */\nexport class GenericExtrinsicEra extends Enum {\n  constructor(registry, value) {\n    super(registry, {\n      ImmortalEra,\n      MortalEra\n    }, decodeExtrinsicEra(value));\n  }\n  /**\n   * @description Override the encoded length method\n   */\n  get encodedLength() {\n    return this.isImmortalEra ? this.asImmortalEra.encodedLength : this.asMortalEra.encodedLength;\n  }\n  /**\n   * @description Returns the item as a [[ImmortalEra]]\n   */\n  get asImmortalEra() {\n    if (!this.isImmortalEra) {\n      throw new Error(\"Cannot convert '\".concat(this.type, \"' via asImmortalEra\"));\n    }\n    return this.inner;\n  }\n  /**\n   * @description Returns the item as a [[MortalEra]]\n   */\n  get asMortalEra() {\n    if (!this.isMortalEra) {\n      throw new Error(\"Cannot convert '\".concat(this.type, \"' via asMortalEra\"));\n    }\n    return this.inner;\n  }\n  /**\n   * @description `true` if Immortal\n   */\n  get isImmortalEra() {\n    return this.index === 0;\n  }\n  /**\n   * @description `true` if Mortal\n   */\n  get isMortalEra() {\n    return this.index > 0;\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    return this.isMortalEra ? this.asMortalEra.toU8a(isBare) : this.asImmortalEra.toU8a(isBare);\n  }\n}","map":{"version":3,"names":["Enum","Raw","Tuple","U64","bnToBn","formatNumber","hexToU8a","isHex","isObject","isU8a","u8aToBn","u8aToU8a","IMMORTAL_ERA","getTrailingZeros","period","binary","toString","index","length","decodeMortalEra","registry","value","Array","isArray","decodeMortalU8a","decodeMortalObject","Error","current","calPeriod","Math","pow","ceil","log2","min","max","phase","quantizeFactor","quantizedPhase","first","subarray","toNumber","second","encoded","decodeExtrinsicEra","arguments","undefined","Uint8Array","GenericExtrinsicEra","toU8a","entries","Object","map","_ref","k","v","toLowerCase","mortal","find","_ref2","immortal","_ref3","MortalEra","ImmortalEra","constructor","_value","encodedLength","toHuman","toJSON","toHex","_isBare","birth","death","isImmortalEra","asImmortalEra","asMortalEra","concat","type","inner","isMortalEra","isBare"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/extrinsic/ExtrinsicEra.js"],"sourcesContent":["import { Enum, Raw, Tuple, U64 } from '@polkadot/types-codec';\nimport { bnToBn, formatNumber, hexToU8a, isHex, isObject, isU8a, u8aToBn, u8aToU8a } from '@polkadot/util';\nimport { IMMORTAL_ERA } from './constants.js';\nfunction getTrailingZeros(period) {\n    const binary = period.toString(2);\n    let index = 0;\n    while (binary[binary.length - 1 - index] === '0') {\n        index++;\n    }\n    return index;\n}\n/** @internal */\nfunction decodeMortalEra(registry, value) {\n    if (isU8a(value) || isHex(value) || Array.isArray(value)) {\n        return decodeMortalU8a(registry, u8aToU8a(value));\n    }\n    else if (!value) {\n        return [new U64(registry), new U64(registry)];\n    }\n    else if (isObject(value)) {\n        return decodeMortalObject(registry, value);\n    }\n    throw new Error('Invalid data passed to Mortal era');\n}\n/** @internal */\nfunction decodeMortalObject(registry, value) {\n    const { current, period } = value;\n    let calPeriod = Math.pow(2, Math.ceil(Math.log2(period)));\n    calPeriod = Math.min(Math.max(calPeriod, 4), 1 << 16);\n    const phase = current % calPeriod;\n    const quantizeFactor = Math.max(calPeriod >> 12, 1);\n    const quantizedPhase = phase / quantizeFactor * quantizeFactor;\n    return [new U64(registry, calPeriod), new U64(registry, quantizedPhase)];\n}\n/** @internal */\nfunction decodeMortalU8a(registry, value) {\n    if (value.length === 0) {\n        return [new U64(registry), new U64(registry)];\n    }\n    const first = u8aToBn(value.subarray(0, 1)).toNumber();\n    const second = u8aToBn(value.subarray(1, 2)).toNumber();\n    const encoded = first + (second << 8);\n    const period = 2 << (encoded % (1 << 4));\n    const quantizeFactor = Math.max(period >> 12, 1);\n    const phase = (encoded >> 4) * quantizeFactor;\n    if (period < 4 || phase >= period) {\n        throw new Error('Invalid data passed to Mortal era');\n    }\n    return [new U64(registry, period), new U64(registry, phase)];\n}\n/** @internal */\nfunction decodeExtrinsicEra(value = new Uint8Array()) {\n    if (isU8a(value)) {\n        return (!value.length || value[0] === 0)\n            ? new Uint8Array([0])\n            : new Uint8Array([1, value[0], value[1]]);\n    }\n    else if (!value) {\n        return new Uint8Array([0]);\n    }\n    else if (value instanceof GenericExtrinsicEra) {\n        return decodeExtrinsicEra(value.toU8a());\n    }\n    else if (isHex(value)) {\n        return decodeExtrinsicEra(hexToU8a(value));\n    }\n    else if (isObject(value)) {\n        const entries = Object.entries(value).map(([k, v]) => [k.toLowerCase(), v]);\n        const mortal = entries.find(([k]) => k.toLowerCase() === 'mortalera');\n        const immortal = entries.find(([k]) => k.toLowerCase() === 'immortalera');\n        // this is to de-serialize from JSON\n        return mortal\n            ? { MortalEra: mortal[1] }\n            : immortal\n                ? { ImmortalEra: immortal[1] }\n                : { MortalEra: value };\n    }\n    throw new Error('Invalid data passed to Era');\n}\n/**\n * @name ImmortalEra\n * @description\n * The ImmortalEra for an extrinsic\n */\nexport class ImmortalEra extends Raw {\n    constructor(registry, _value) {\n        // For immortals, we always provide the known value (i.e. treated as a\n        // constant no matter how it is constructed - it is a fixed structure)\n        super(registry, IMMORTAL_ERA);\n    }\n}\n/**\n * @name MortalEra\n * @description\n * The MortalEra for an extrinsic, indicating period and phase\n */\nexport class MortalEra extends Tuple {\n    constructor(registry, value) {\n        super(registry, {\n            period: U64,\n            phase: U64\n        }, decodeMortalEra(registry, value));\n    }\n    /**\n     * @description Encoded length for mortals occupy 2 bytes, different from the actual Tuple since it is encoded. This is a shortcut fro `toU8a().length`\n     */\n    get encodedLength() {\n        return 2 | 0;\n    }\n    /**\n     * @description The period of this Mortal wraps as a [[U64]]\n     */\n    get period() {\n        return this[0];\n    }\n    /**\n     * @description The phase of this Mortal wraps as a [[U64]]\n     */\n    get phase() {\n        return this[1];\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman() {\n        return {\n            period: formatNumber(this.period),\n            phase: formatNumber(this.phase)\n        };\n    }\n    /**\n     * @description Returns a JSON representation of the actual value\n     */\n    toJSON() {\n        return this.toHex();\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     * Period and phase are encoded:\n     *   - The period of validity from the block hash found in the signing material.\n     *   - The phase in the period that this transaction's lifetime begins (and, importantly,\n     *     implies which block hash is included in the signature material). If the `period` is\n     *     greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that\n     *     `period` is.\n     */\n    toU8a(_isBare) {\n        const period = this.period.toNumber();\n        const encoded = Math.min(15, Math.max(1, getTrailingZeros(period) - 1)) + ((this.phase.toNumber() / Math.max(period >> 12, 1)) << 4);\n        return new Uint8Array([\n            encoded & 0xff,\n            encoded >> 8\n        ]);\n    }\n    /**\n     * @description Get the block number of the start of the era whose properties this object describes that `current` belongs to.\n     */\n    birth(current) {\n        const phase = this.phase.toNumber();\n        const period = this.period.toNumber();\n        // FIXME No toNumber() here\n        return (~~((Math.max(bnToBn(current).toNumber(), phase) - phase) / period) * period) + phase;\n    }\n    /**\n     * @description Get the block number of the first block at which the era has ended.\n     */\n    death(current) {\n        // FIXME No toNumber() here\n        return this.birth(current) + this.period.toNumber();\n    }\n}\n/**\n * @name GenericExtrinsicEra\n * @description\n * The era for an extrinsic, indicating either a mortal or immortal extrinsic\n */\nexport class GenericExtrinsicEra extends Enum {\n    constructor(registry, value) {\n        super(registry, {\n            ImmortalEra,\n            MortalEra\n        }, decodeExtrinsicEra(value));\n    }\n    /**\n     * @description Override the encoded length method\n     */\n    get encodedLength() {\n        return this.isImmortalEra\n            ? this.asImmortalEra.encodedLength\n            : this.asMortalEra.encodedLength;\n    }\n    /**\n     * @description Returns the item as a [[ImmortalEra]]\n     */\n    get asImmortalEra() {\n        if (!this.isImmortalEra) {\n            throw new Error(`Cannot convert '${this.type}' via asImmortalEra`);\n        }\n        return this.inner;\n    }\n    /**\n     * @description Returns the item as a [[MortalEra]]\n     */\n    get asMortalEra() {\n        if (!this.isMortalEra) {\n            throw new Error(`Cannot convert '${this.type}' via asMortalEra`);\n        }\n        return this.inner;\n    }\n    /**\n     * @description `true` if Immortal\n     */\n    get isImmortalEra() {\n        return this.index === 0;\n    }\n    /**\n     * @description `true` if Mortal\n     */\n    get isMortalEra() {\n        return this.index > 0;\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        return this.isMortalEra\n            ? this.asMortalEra.toU8a(isBare)\n            : this.asImmortalEra.toU8a(isBare);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}