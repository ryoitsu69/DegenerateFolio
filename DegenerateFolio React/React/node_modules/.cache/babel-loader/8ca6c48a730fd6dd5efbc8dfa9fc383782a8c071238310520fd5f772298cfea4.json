{"ast":null,"code":"import { FilterEffect } from '../../../filters/FilterEffect.mjs';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager.mjs';\n\"use strict\";\nconst effectsMixin = {\n  _maskEffect: null,\n  _filterEffect: null,\n  /**\n   * @todo Needs docs.\n   * @memberof scene.Container#\n   * @type {Array<Effect>}\n   */\n  effects: [],\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to add.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  addEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index !== -1) return;\n    this.effects.push(effect);\n    this.effects.sort((a, b) => a.priority - b.priority);\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n    this._updateIsSimple();\n  },\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to remove.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  removeEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index === -1) return;\n    this.effects.splice(index, 1);\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateIsSimple();\n  },\n  set mask(value) {\n    const effect = this._maskEffect;\n    if (effect?.mask === value) return;\n    if (effect) {\n      this.removeEffect(effect);\n      MaskEffectManager.returnMaskEffect(effect);\n    }\n    if (value === null || value === void 0) return;\n    this._maskEffect = MaskEffectManager.getMaskEffect(value);\n    this.addEffect(this._maskEffect);\n  },\n  /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n   * To remove a mask, set this property to `null`.\n   *\n   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n   * @example\n   * import { Graphics, Sprite } from 'pixi.js';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.mask = graphics;\n   * @memberof scene.Container#\n   */\n  get mask() {\n    return this._maskEffect?.mask;\n  },\n  set filters(value) {\n    if (!Array.isArray(value) && value) value = [value];\n    const effect = this._filterEffect || (this._filterEffect = new FilterEffect());\n    value = value;\n    const hasFilters = value?.length > 0;\n    const hadFilters = effect.filters?.length > 0;\n    const didChange = hasFilters !== hadFilters;\n    value = Array.isArray(value) ? value.slice(0) : value;\n    effect.filters = Object.freeze(value);\n    if (didChange) {\n      if (hasFilters) {\n        this.addEffect(effect);\n      } else {\n        this.removeEffect(effect);\n        effect.filters = value ?? null;\n      }\n    }\n  },\n  /**\n   * Sets the filters for the displayObject.\n   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n   * To remove filters simply set this property to `'null'`.\n   * @memberof scene.Container#\n   */\n  get filters() {\n    return this._filterEffect?.filters;\n  },\n  set filterArea(value) {\n    this._filterEffect || (this._filterEffect = new FilterEffect());\n    this._filterEffect.filterArea = value;\n  },\n  /**\n   * The area the filter is applied to. This is used as more of an optimization\n   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n   *\n   * Also works as an interaction mask.\n   * @memberof scene.Container#\n   */\n  get filterArea() {\n    return this._filterEffect?.filterArea;\n  }\n};\nexport { effectsMixin };","map":{"version":3,"names":["effectsMixin","_maskEffect","_filterEffect","effects","addEffect","effect","index","indexOf","push","sort","a","b","priority","renderGroup","parentRenderGroup","structureDidChange","_updateIsSimple","removeEffect","splice","mask","value","MaskEffectManager","returnMaskEffect","getMaskEffect","filters","Array","isArray","FilterEffect","hasFilters","length","hadFilters","didChange","slice","Object","freeze","filterArea"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/container/container-mixins/effectsMixin.ts"],"sourcesContent":["import { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager';\n\nimport type { Filter } from '../../../filters/Filter';\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { MaskEffect } from '../../../rendering/mask/MaskEffectManager';\nimport type { Container } from '../Container';\nimport type { Effect } from '../Effect';\n\nexport interface EffectsMixinConstructor\n{\n    mask?: number | Container | null;\n    filters?: Filter | Filter[];\n}\nexport interface EffectsMixin extends Required<EffectsMixinConstructor>\n{\n    _maskEffect?: MaskEffect;\n    _filterEffect?: FilterEffect,\n\n    filterArea?: Rectangle,\n    effects?: Effect[];\n\n    addEffect(effect: Effect): void;\n    removeEffect(effect: Effect): void;\n}\n\nexport const effectsMixin: Partial<Container> = {\n    _maskEffect: null,\n    _filterEffect: null,\n\n    /**\n     * @todo Needs docs.\n     * @memberof scene.Container#\n     * @type {Array<Effect>}\n     */\n    effects: [],\n\n    /**\n     * @todo Needs docs.\n     * @param effect - The effect to add.\n     * @memberof scene.Container#\n     * @ignore\n     */\n    addEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index !== -1) return; // already exists!\n\n        this.effects.push(effect);\n\n        this.effects.sort((a, b) => a.priority - b.priority);\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.structureDidChange = true;\n        }\n\n        // if (this.renderGroup)\n        // {\n        //     this.renderGroup.structureDidChange = true;\n        // }\n\n        this._updateIsSimple();\n    },\n    /**\n     * @todo Needs docs.\n     * @param effect - The effect to remove.\n     * @memberof scene.Container#\n     * @ignore\n     */\n    removeEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index === -1) return; // already exists!\n\n        this.effects.splice(index, 1);\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateIsSimple();\n    },\n\n    set mask(value: number | Container | null)\n    {\n        const effect = this._maskEffect;\n\n        if (effect?.mask === value) return;\n\n        if (effect)\n        {\n            this.removeEffect(effect);\n\n            MaskEffectManager.returnMaskEffect(effect);\n        }\n\n        if (value === null || value === undefined) return;\n\n        this._maskEffect = MaskEffectManager.getMaskEffect(value);\n\n        this.addEffect(this._maskEffect);\n    },\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n     * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n     * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n     * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n     * To remove a mask, set this property to `null`.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * import { Graphics, Sprite } from 'pixi.js';\n     *\n     * const graphics = new Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.mask = graphics;\n     * @memberof scene.Container#\n     */\n    get mask(): unknown\n    {\n        return this._maskEffect?.mask;\n    },\n\n    set filters(value: Filter | Filter[] | null | undefined)\n    {\n        if (!Array.isArray(value) && value) value = [value];\n\n        const effect = this._filterEffect ||= new FilterEffect();\n\n        // Ignore the Filter type\n        value = value as Filter[] | null | undefined;\n\n        const hasFilters = value?.length > 0;\n        const hadFilters = effect.filters?.length > 0;\n\n        const didChange = hasFilters !== hadFilters;\n\n        // Clone the filters array so we don't freeze the user-input\n        value = Array.isArray(value) ? value.slice(0) : value;\n\n        // Ensure filters are immutable via filters getter\n        effect.filters = Object.freeze(value);\n\n        if (didChange)\n        {\n            if (hasFilters)\n            {\n                this.addEffect(effect);\n            }\n            else\n            {\n                this.removeEffect(effect);\n\n                // sets the empty array...\n                effect.filters = value ?? null;\n            }\n        }\n    },\n\n    /**\n     * Sets the filters for the displayObject.\n     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to `'null'`.\n     * @memberof scene.Container#\n     */\n    get filters(): readonly Filter[]\n    {\n        return this._filterEffect?.filters;\n    },\n\n    set filterArea(value: Rectangle)\n    {\n        this._filterEffect ||= new FilterEffect();\n\n        this._filterEffect.filterArea = value;\n    },\n\n    /**\n     * The area the filter is applied to. This is used as more of an optimization\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n     *\n     * Also works as an interaction mask.\n     * @memberof scene.Container#\n     */\n    get filterArea(): Rectangle\n    {\n        return this._filterEffect?.filterArea;\n    },\n\n} as Container;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}