{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n// eslint-disable-next-line node/no-missing-require\nconst {\n  EventEmitter\n} = require('node:events');\nconst WebSocket = require('ws');\nconst RESPONSE_TIMEOUT = 1000 * 30;\nclass Index extends EventEmitter {\n  id = 0;\n  connected = false;\n  events = [];\n  browsingContexts = [];\n\n  /**\n   * Create a new websocket connection\n   * @param _webSocketUrl\n   */\n  constructor(_webSocketUrl) {\n    super();\n    this.connected = false;\n    this._ws = new WebSocket(_webSocketUrl);\n    this._ws.on('open', () => {\n      this.connected = true;\n    });\n  }\n\n  /**\n   * @returns {WebSocket}\n   */\n  get socket() {\n    return this._ws;\n  }\n\n  /**\n   * @returns {boolean|*}\n   */\n  get isConnected() {\n    return this.connected;\n  }\n\n  /**\n   * Get Bidi Status\n   * @returns {Promise<*>}\n   */\n  get status() {\n    return this.send({\n      method: 'session.status',\n      params: {}\n    });\n  }\n\n  /**\n   * Resolve connection\n   * @returns {Promise<unknown>}\n   */\n  async waitForConnection() {\n    return new Promise(resolve => {\n      if (this.connected) {\n        resolve();\n      } else {\n        this._ws.once('open', () => {\n          resolve();\n        });\n      }\n    });\n  }\n\n  /**\n   * Sends a bidi request\n   * @param params\n   * @returns {Promise<unknown>}\n   */\n  async send(params) {\n    if (!this.connected) {\n      await this.waitForConnection();\n    }\n    const id = ++this.id;\n    this._ws.send(JSON.stringify({\n      id,\n      ...params\n    }));\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new Error(`Request with id ${id} timed out`));\n        handler.off('message', listener);\n      }, RESPONSE_TIMEOUT);\n      const listener = data => {\n        try {\n          const payload = JSON.parse(data.toString());\n          if (payload.id === id) {\n            clearTimeout(timeoutId);\n            handler.off('message', listener);\n            resolve(payload);\n          }\n        } catch (err) {\n          // eslint-disable-next-line no-undef\n          log.error(`Failed parse message: ${err.message}`);\n        }\n      };\n      const handler = this._ws.on('message', listener);\n    });\n  }\n\n  /**\n   * Subscribe to events\n   * @param events\n   * @param browsingContexts\n   * @returns {Promise<void>}\n   */\n  async subscribe(events, browsingContexts) {\n    function toArray(arg) {\n      if (arg === undefined) {\n        return [];\n      }\n      return Array.isArray(arg) ? [...arg] : [arg];\n    }\n    const eventsArray = toArray(events);\n    const contextsArray = toArray(browsingContexts);\n    const params = {\n      method: 'session.subscribe',\n      params: {}\n    };\n    if (eventsArray.length && eventsArray.some(event => typeof event !== 'string')) {\n      throw new TypeError('events should be string or string array');\n    }\n    if (contextsArray.length && contextsArray.some(context => typeof context !== 'string')) {\n      throw new TypeError('browsingContexts should be string or string array');\n    }\n    if (eventsArray.length) {\n      params.params.events = eventsArray;\n    }\n    if (contextsArray.length) {\n      params.params.contexts = contextsArray;\n    }\n    await this.send(params);\n  }\n\n  /**\n   * Unsubscribe to events\n   * @param events\n   * @param browsingContexts\n   * @returns {Promise<void>}\n   */\n  async unsubscribe(events, browsingContexts) {\n    if (typeof events === 'string') {\n      this.events = this.events.filter(event => event !== events);\n    } else if (Array.isArray(events)) {\n      this.events = this.events.filter(event => !events.includes(event));\n    }\n    if (typeof browsingContexts === 'string') {\n      this.browsingContexts.pop();\n    } else if (Array.isArray(browsingContexts)) {\n      this.browsingContexts = this.browsingContexts.filter(id => !browsingContexts.includes(id));\n    }\n    const params = {\n      method: 'session.unsubscribe',\n      params: {\n        events: this.events\n      }\n    };\n    if (this.browsingContexts.length > 0) {\n      params.params.contexts = this.browsingContexts;\n    }\n    await this.send(params);\n  }\n\n  /**\n   * Close ws connection.\n   * @returns {Promise<unknown>}\n   */\n  close() {\n    const closeWebSocket = callback => {\n      // don't close if it's already closed\n      if (this._ws.readyState === 3) {\n        callback();\n      } else {\n        // don't notify on user-initiated shutdown ('disconnect' event)\n        this._ws.removeAllListeners('close');\n        this._ws.once('close', () => {\n          this._ws.removeAllListeners();\n          callback();\n        });\n        this._ws.close();\n      }\n    };\n    return new Promise((fulfill, _) => {\n      closeWebSocket(fulfill);\n    });\n  }\n}\n\n/**\n * API\n * @type {function(*): Promise<Index>}\n */\nmodule.exports = Index;","map":{"version":3,"names":["EventEmitter","require","WebSocket","RESPONSE_TIMEOUT","Index","id","connected","events","browsingContexts","constructor","_webSocketUrl","_ws","on","socket","isConnected","status","send","method","params","waitForConnection","Promise","resolve","once","JSON","stringify","reject","timeoutId","setTimeout","Error","handler","off","listener","data","payload","parse","toString","clearTimeout","err","log","error","message","subscribe","toArray","arg","undefined","Array","isArray","eventsArray","contextsArray","length","some","event","TypeError","context","contexts","unsubscribe","filter","includes","pop","close","closeWebSocket","callback","readyState","removeAllListeners","fulfill","_","module","exports"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/selenium-webdriver/bidi/index.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n// eslint-disable-next-line node/no-missing-require\nconst { EventEmitter } = require('node:events')\nconst WebSocket = require('ws')\n\nconst RESPONSE_TIMEOUT = 1000 * 30\n\nclass Index extends EventEmitter {\n  id = 0\n  connected = false\n  events = []\n  browsingContexts = []\n\n  /**\n   * Create a new websocket connection\n   * @param _webSocketUrl\n   */\n  constructor(_webSocketUrl) {\n    super()\n    this.connected = false\n    this._ws = new WebSocket(_webSocketUrl)\n    this._ws.on('open', () => {\n      this.connected = true\n    })\n  }\n\n  /**\n   * @returns {WebSocket}\n   */\n  get socket() {\n    return this._ws\n  }\n\n  /**\n   * @returns {boolean|*}\n   */\n  get isConnected() {\n    return this.connected\n  }\n\n  /**\n   * Get Bidi Status\n   * @returns {Promise<*>}\n   */\n  get status() {\n    return this.send({\n      method: 'session.status',\n      params: {},\n    })\n  }\n\n  /**\n   * Resolve connection\n   * @returns {Promise<unknown>}\n   */\n  async waitForConnection() {\n    return new Promise((resolve) => {\n      if (this.connected) {\n        resolve()\n      } else {\n        this._ws.once('open', () => {\n          resolve()\n        })\n      }\n    })\n  }\n\n  /**\n   * Sends a bidi request\n   * @param params\n   * @returns {Promise<unknown>}\n   */\n  async send(params) {\n    if (!this.connected) {\n      await this.waitForConnection()\n    }\n\n    const id = ++this.id\n\n    this._ws.send(JSON.stringify({ id, ...params }))\n\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new Error(`Request with id ${id} timed out`))\n        handler.off('message', listener)\n      }, RESPONSE_TIMEOUT)\n\n      const listener = (data) => {\n        try {\n          const payload = JSON.parse(data.toString())\n          if (payload.id === id) {\n            clearTimeout(timeoutId)\n            handler.off('message', listener)\n            resolve(payload)\n          }\n        } catch (err) {\n          // eslint-disable-next-line no-undef\n          log.error(`Failed parse message: ${err.message}`)\n        }\n      }\n\n      const handler = this._ws.on('message', listener)\n    })\n  }\n\n  /**\n   * Subscribe to events\n   * @param events\n   * @param browsingContexts\n   * @returns {Promise<void>}\n   */\n  async subscribe(events, browsingContexts) {\n    function toArray(arg) {\n      if (arg === undefined) {\n        return []\n      }\n\n      return Array.isArray(arg) ? [...arg] : [arg]\n    }\n\n    const eventsArray = toArray(events)\n    const contextsArray = toArray(browsingContexts)\n\n    const params = {\n      method: 'session.subscribe',\n      params: {},\n    }\n\n    if (eventsArray.length && eventsArray.some((event) => typeof event !== 'string')) {\n      throw new TypeError('events should be string or string array')\n    }\n\n    if (contextsArray.length && contextsArray.some((context) => typeof context !== 'string')) {\n      throw new TypeError('browsingContexts should be string or string array')\n    }\n\n    if (eventsArray.length) {\n      params.params.events = eventsArray\n    }\n\n    if (contextsArray.length) {\n      params.params.contexts = contextsArray\n    }\n\n    await this.send(params)\n  }\n\n  /**\n   * Unsubscribe to events\n   * @param events\n   * @param browsingContexts\n   * @returns {Promise<void>}\n   */\n  async unsubscribe(events, browsingContexts) {\n    if (typeof events === 'string') {\n      this.events = this.events.filter((event) => event !== events)\n    } else if (Array.isArray(events)) {\n      this.events = this.events.filter((event) => !events.includes(event))\n    }\n\n    if (typeof browsingContexts === 'string') {\n      this.browsingContexts.pop()\n    } else if (Array.isArray(browsingContexts)) {\n      this.browsingContexts = this.browsingContexts.filter((id) => !browsingContexts.includes(id))\n    }\n\n    const params = {\n      method: 'session.unsubscribe',\n      params: {\n        events: this.events,\n      },\n    }\n\n    if (this.browsingContexts.length > 0) {\n      params.params.contexts = this.browsingContexts\n    }\n\n    await this.send(params)\n  }\n\n  /**\n   * Close ws connection.\n   * @returns {Promise<unknown>}\n   */\n  close() {\n    const closeWebSocket = (callback) => {\n      // don't close if it's already closed\n      if (this._ws.readyState === 3) {\n        callback()\n      } else {\n        // don't notify on user-initiated shutdown ('disconnect' event)\n        this._ws.removeAllListeners('close')\n        this._ws.once('close', () => {\n          this._ws.removeAllListeners()\n          callback()\n        })\n        this._ws.close()\n      }\n    }\n    return new Promise((fulfill, _) => {\n      closeWebSocket(fulfill)\n    })\n  }\n}\n\n/**\n * API\n * @type {function(*): Promise<Index>}\n */\nmodule.exports = Index\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}