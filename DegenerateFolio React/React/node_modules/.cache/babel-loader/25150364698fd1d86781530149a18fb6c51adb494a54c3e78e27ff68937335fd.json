{"ast":null,"code":"import { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds.mjs';\nimport { Container } from '../container/Container.mjs';\n\"use strict\";\nclass Sprite extends Container {\n  /**\n   * @param options - The options for creating the sprite.\n   */\n  constructor(options = Texture.EMPTY) {\n    if (options instanceof Texture) {\n      options = {\n        texture: options\n      };\n    }\n    const {\n      texture = Texture.EMPTY,\n      anchor,\n      roundPixels,\n      width,\n      height,\n      ...rest\n    } = options;\n    super({\n      label: \"Sprite\",\n      ...rest\n    });\n    this.renderPipeId = \"sprite\";\n    this.batched = true;\n    this._didSpriteUpdate = false;\n    this._bounds = {\n      minX: 0,\n      maxX: 1,\n      minY: 0,\n      maxY: 0\n    };\n    this._sourceBounds = {\n      minX: 0,\n      maxX: 1,\n      minY: 0,\n      maxY: 0\n    };\n    this._boundsDirty = true;\n    this._sourceBoundsDirty = true;\n    this._roundPixels = 0;\n    this._anchor = new ObservablePoint({\n      _onUpdate: () => {\n        this.onViewUpdate();\n      }\n    });\n    if (anchor) {\n      this.anchor = anchor;\n    } else if (texture.defaultAnchor) {\n      this.anchor = texture.defaultAnchor;\n    }\n    this.texture = texture;\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n    if (width) this.width = width;\n    if (height) this.height = height;\n  }\n  /**\n   * Helper function that creates a new sprite based on the source you provide.\n   * The source can be - frame id, image, video, canvas element, video element, texture\n   * @param source - Source to create texture from\n   * @param [skipCache] - Whether to skip the cache or not\n   * @returns The newly created sprite\n   */\n  static from(source, skipCache = false) {\n    if (source instanceof Texture) {\n      return new Sprite(source);\n    }\n    return new Sprite(Texture.from(source, skipCache));\n  }\n  set texture(value) {\n    value || (value = Texture.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value) return;\n    if (currentTexture && currentTexture.dynamic) currentTexture.off(\"update\", this.onViewUpdate, this);\n    if (value.dynamic) value.on(\"update\", this.onViewUpdate, this);\n    this._texture = value;\n    this.onViewUpdate();\n  }\n  /** The texture that the sprite is using. */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * The local bounds of the sprite.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    if (this._boundsDirty) {\n      this._updateBounds();\n      this._boundsDirty = false;\n    }\n    return this._bounds;\n  }\n  /**\n   * The bounds of the sprite, taking the texture's trim into account.\n   * @type {rendering.Bounds}\n   */\n  get sourceBounds() {\n    if (this._sourceBoundsDirty) {\n      this._updateSourceBounds();\n      this._sourceBoundsDirty = false;\n    }\n    return this._sourceBounds;\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const bounds = this.sourceBounds;\n    if (point.x >= bounds.maxX && point.x <= bounds.minX) {\n      if (point.y >= bounds.maxY && point.y <= bounds.minY) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;\n    bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n  }\n  onViewUpdate() {\n    this._didChangeId += 1 << 12;\n    this._didSpriteUpdate = true;\n    this._sourceBoundsDirty = this._boundsDirty = true;\n    if (this.didViewUpdate) return;\n    this.didViewUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n  }\n  _updateBounds() {\n    updateQuadBounds(this._bounds, this._anchor, this._texture, 0);\n  }\n  _updateSourceBounds() {\n    const anchor = this._anchor;\n    const texture = this._texture;\n    const sourceBounds = this._sourceBounds;\n    const {\n      width,\n      height\n    } = texture.orig;\n    sourceBounds.maxX = -anchor._x * width;\n    sourceBounds.minX = sourceBounds.maxX + width;\n    sourceBounds.maxY = -anchor._y * height;\n    sourceBounds.minY = sourceBounds.maxY + height;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n    this._bounds = null;\n    this._sourceBounds = null;\n    this._anchor = null;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Sprite } from 'pixi.js';\n   *\n   * const sprite = new Sprite({texture: Texture.WHITE});\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /**\n   *  Whether or not to round the x/y position of the sprite.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    this._setWidth(value, this._texture.orig.width);\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    this._setHeight(value, this._texture.orig.height);\n  }\n  /**\n   * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Sprite.\n   */\n  getSize(out) {\n    if (!out) {\n      out = {};\n    }\n    out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n    out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Sprite to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    let convertedWidth;\n    let convertedHeight;\n    if (typeof value !== \"object\") {\n      convertedWidth = value;\n      convertedHeight = height ?? value;\n    } else {\n      convertedWidth = value.width;\n      convertedHeight = value.height ?? value.width;\n    }\n    if (convertedWidth !== void 0) {\n      this._setWidth(convertedWidth, this._texture.orig.width);\n    }\n    if (convertedHeight !== void 0) {\n      this._setHeight(convertedHeight, this._texture.orig.height);\n    }\n  }\n}\nexport { Sprite };","map":{"version":3,"names":["Sprite","Container","constructor","options","Texture","EMPTY","texture","anchor","roundPixels","width","height","rest","label","renderPipeId","batched","_didSpriteUpdate","_bounds","minX","maxX","minY","maxY","_sourceBounds","_boundsDirty","_sourceBoundsDirty","_roundPixels","_anchor","ObservablePoint","_onUpdate","onViewUpdate","defaultAnchor","allowChildren","from","source","skipCache","value","currentTexture","_texture","dynamic","off","on","bounds","_updateBounds","sourceBounds","_updateSourceBounds","containsPoint","point","x","y","addBounds","trim","addFrame","_didChangeId","didViewUpdate","renderGroup","parentRenderGroup","onChildViewUpdate","updateQuadBounds","orig","_x","_y","destroy","destroyTexture","destroyTextureSource","textureSource","set","copyFrom","Math","abs","scale","_setWidth","_setHeight","getSize","out","setSize","convertedWidth","convertedHeight"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/sprite/Sprite.ts"],"sourcesContent":["import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { Container } from '../container/Container';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { TextureSourceLike } from '../../rendering/renderers/shared/texture/Texture';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { Bounds, BoundsData } from '../container/bounds/Bounds';\nimport type { ContainerOptions } from '../container/Container';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Options for the {@link scene.Sprite} constructor.\n * @memberof scene\n */\nexport interface SpriteOptions extends ContainerOptions\n{\n    /** The texture to use for the sprite. */\n    texture?: Texture;\n    /** The anchor point of the sprite. */\n    anchor?: PointData | number;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * The Sprite object is one of the most important objects in PixiJS. It is a\n * drawing item that can be added to a scene and rendered to the screen.\n *\n * A sprite can be created directly from an image like this:\n *\n * ```js\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('assets/image.png');\n * ```\n *\n * The more efficient way to create sprites is using a {@link assets.Spritesheet},\n * as swapping base textures when rendering to the screen is inefficient.\n *\n * ```js\n * import { Assets, Sprite } from 'pixi.js';\n *\n * const sheet = await Assets.load('assets/spritesheet.json');\n * const sprite = new Sprite(sheet.textures['image.png']);\n * ```\n * @memberof scene\n * @extends scene.Container\n */\nexport class Sprite extends Container implements View\n{\n    /**\n     * Helper function that creates a new sprite based on the source you provide.\n     * The source can be - frame id, image, video, canvas element, video element, texture\n     * @param source - Source to create texture from\n     * @param [skipCache] - Whether to skip the cache or not\n     * @returns The newly created sprite\n     */\n    public static from(source: Texture | TextureSourceLike, skipCache = false): Sprite\n    {\n        if (source instanceof Texture)\n        {\n            return new Sprite(source);\n        }\n\n        return new Sprite(Texture.from(source, skipCache));\n    }\n\n    public readonly renderPipeId = 'sprite';\n\n    public batched = true;\n    public readonly _anchor: ObservablePoint;\n\n    // sprite specific..\n    public _texture: Texture;\n    public _didSpriteUpdate = false;\n\n    private readonly _bounds: BoundsData = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    private readonly _sourceBounds: BoundsData = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    private _boundsDirty = true;\n    private _sourceBoundsDirty = true;\n\n    public _roundPixels: 0 | 1 = 0;\n\n    /**\n     * @param options - The options for creating the sprite.\n     */\n    constructor(options: SpriteOptions | Texture = Texture.EMPTY)\n    {\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        // split out\n        const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;\n\n        super({\n            label: 'Sprite',\n            ...rest\n        });\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        if (anchor)\n        {\n            this.anchor = anchor;\n        }\n        else if (texture.defaultAnchor)\n        {\n            this.anchor = texture.defaultAnchor;\n        }\n\n        this.texture = texture;\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width) this.width = width;\n        if (height) this.height = height;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        this.onViewUpdate();\n    }\n\n    /** The texture that the sprite is using. */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /**\n     * The local bounds of the sprite.\n     * @type {rendering.Bounds}\n     */\n    get bounds()\n    {\n        if (this._boundsDirty)\n        {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n\n        return this._bounds;\n    }\n\n    /**\n     * The bounds of the sprite, taking the texture's trim into account.\n     * @type {rendering.Bounds}\n     */\n    get sourceBounds()\n    {\n        if (this._sourceBoundsDirty)\n        {\n            this._updateSourceBounds();\n            this._sourceBoundsDirty = false;\n        }\n\n        return this._sourceBounds;\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        const bounds = this.sourceBounds;\n\n        if (point.x >= bounds.maxX && point.x <= bounds.minX)\n        {\n            if (point.y >= bounds.maxY && point.y <= bounds.minY)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;\n\n        bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n    }\n\n    public onViewUpdate()\n    {\n        // increment from the 12th bit!\n        this._didChangeId += 1 << 12;\n        this._didSpriteUpdate = true;\n        this._sourceBoundsDirty = this._boundsDirty = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    private _updateBounds()\n    {\n        updateQuadBounds(this._bounds, this._anchor, this._texture, 0);\n    }\n\n    private _updateSourceBounds()\n    {\n        const anchor = this._anchor;\n        const texture = this._texture;\n\n        const sourceBounds = this._sourceBounds;\n\n        const { width, height } = texture.orig;\n\n        sourceBounds.maxX = -anchor._x * width;\n        sourceBounds.minX = sourceBounds.maxX + width;\n\n        sourceBounds.maxY = -anchor._y * height;\n        sourceBounds.minY = sourceBounds.maxY + height;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n        (this._bounds as null) = null;\n        (this._sourceBounds as null) = null;\n        (this._anchor as null) = null;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * The default is `(0,0)`, this means the sprite's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite({texture: Texture.WHITE});\n     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the sprite.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this._texture.orig.width);\n    }\n\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this._texture.orig.height);\n    }\n\n    /**\n     * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the Sprite.\n     */\n    public override getSize(out?: Size): Size\n    {\n        if (!out)\n        {\n            out = {} as Size;\n        }\n\n        out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n        out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Sprite to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        let convertedWidth: number;\n        let convertedHeight: number;\n\n        if (typeof value !== 'object')\n        {\n            convertedWidth = value;\n            convertedHeight = height ?? value;\n        }\n        else\n        {\n            convertedWidth = value.width;\n            convertedHeight = value.height ?? value.width;\n        }\n\n        if (convertedWidth !== undefined)\n        {\n            this._setWidth(convertedWidth, this._texture.orig.width);\n        }\n\n        if (convertedHeight !== undefined)\n        {\n            this._setHeight(convertedHeight, this._texture.orig.height);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}