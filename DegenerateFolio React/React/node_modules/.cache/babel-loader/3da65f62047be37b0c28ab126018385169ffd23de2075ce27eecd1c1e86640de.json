{"ast":null,"code":"import { combineLatest, map, mergeMap, of, switchMap } from 'rxjs';\nimport { memo, unwrapBlockNumber } from '../util/index.js';\nexport function createBlockNumberDerive(fn) {\n  return (instanceId, api) => memo(instanceId, () => fn(api).pipe(map(unwrapBlockNumber)));\n}\n/** @internal */\nfunction getAuthorDetailsWithAt(header, queryAt) {\n  var _queryAt$session;\n  const validators = (_queryAt$session = queryAt.session) !== null && _queryAt$session !== void 0 && _queryAt$session.validators ? queryAt.session.validators() : of(null);\n  // nimbus consensus stores the session key of the block author in header logs\n  const {\n    logs: [log]\n  } = header.digest;\n  const loggedAuthor = log && (log.isConsensus && log.asConsensus[0].isNimbus && log.asConsensus[1] || log.isPreRuntime && log.asPreRuntime[0].isNimbus && log.asPreRuntime[1]);\n  if (loggedAuthor) {\n    var _queryAt$authorMappin, _queryAt$parachainSta, _queryAt$session2;\n    // use the author mapping pallet, if available (ie: moonbeam, moonriver), to map session (nimbus) key to author (collator/validator) key\n    if ((_queryAt$authorMappin = queryAt['authorMapping']) !== null && _queryAt$authorMappin !== void 0 && _queryAt$authorMappin['mappingWithDeposit']) {\n      return combineLatest([of(header), validators, queryAt['authorMapping']['mappingWithDeposit'](loggedAuthor).pipe(map(o => o.unwrapOr({\n        account: null\n      }).account))]);\n    }\n    // fall back to session and parachain staking pallets, if available (ie: manta, calamari), to map session (nimbus) key to author (collator) key\n    if ((_queryAt$parachainSta = queryAt['parachainStaking']) !== null && _queryAt$parachainSta !== void 0 && _queryAt$parachainSta['selectedCandidates'] && (_queryAt$session2 = queryAt.session) !== null && _queryAt$session2 !== void 0 && _queryAt$session2.nextKeys) {\n      const loggedHex = loggedAuthor.toHex();\n      return combineLatest([of(header), validators, queryAt['parachainStaking']['selectedCandidates']().pipe(mergeMap(selectedCandidates => combineLatest([of(selectedCandidates), queryAt.session.nextKeys.multi(selectedCandidates).pipe(map(nextKeys => nextKeys.findIndex(o => o.unwrapOrDefault().nimbus.toHex() === loggedHex)))])), map(_ref => {\n        let [selectedCandidates, index] = _ref;\n        return index === -1 ? null : selectedCandidates[index];\n      }))]);\n    }\n  }\n  // normal operation, non-mapping\n  return combineLatest([of(header), validators, of(null)]);\n}\nexport function getAuthorDetails(api, header, blockHash) {\n  // For on-chain state, we need to retrieve it as per the start\n  // of the block being constructed, i.e. session validators would\n  // be at the point of the block construction, not when all operations\n  // has been supplied.\n  //\n  // However for the first block (no parentHash available), we would\n  // just use the as-is\n  return api.queryAt(header.parentHash.isEmpty ? blockHash || header.hash : header.parentHash).pipe(switchMap(queryAt => getAuthorDetailsWithAt(header, queryAt)));\n}","map":{"version":3,"names":["combineLatest","map","mergeMap","of","switchMap","memo","unwrapBlockNumber","createBlockNumberDerive","fn","instanceId","api","pipe","getAuthorDetailsWithAt","header","queryAt","_queryAt$session","validators","session","logs","log","digest","loggedAuthor","isConsensus","asConsensus","isNimbus","isPreRuntime","asPreRuntime","_queryAt$authorMappin","_queryAt$parachainSta","_queryAt$session2","o","unwrapOr","account","nextKeys","loggedHex","toHex","selectedCandidates","multi","findIndex","unwrapOrDefault","nimbus","_ref","index","getAuthorDetails","blockHash","parentHash","isEmpty","hash"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api-derive/chain/util.js"],"sourcesContent":["import { combineLatest, map, mergeMap, of, switchMap } from 'rxjs';\nimport { memo, unwrapBlockNumber } from '../util/index.js';\nexport function createBlockNumberDerive(fn) {\n    return (instanceId, api) => memo(instanceId, () => fn(api).pipe(map(unwrapBlockNumber)));\n}\n/** @internal */\nfunction getAuthorDetailsWithAt(header, queryAt) {\n    const validators = queryAt.session?.validators\n        ? queryAt.session.validators()\n        : of(null);\n    // nimbus consensus stores the session key of the block author in header logs\n    const { logs: [log] } = header.digest;\n    const loggedAuthor = (log && ((log.isConsensus && log.asConsensus[0].isNimbus && log.asConsensus[1]) ||\n        (log.isPreRuntime && log.asPreRuntime[0].isNimbus && log.asPreRuntime[1])));\n    if (loggedAuthor) {\n        // use the author mapping pallet, if available (ie: moonbeam, moonriver), to map session (nimbus) key to author (collator/validator) key\n        if (queryAt['authorMapping']?.['mappingWithDeposit']) {\n            return combineLatest([\n                of(header),\n                validators,\n                queryAt['authorMapping']['mappingWithDeposit'](loggedAuthor).pipe(map((o) => o.unwrapOr({ account: null }).account))\n            ]);\n        }\n        // fall back to session and parachain staking pallets, if available (ie: manta, calamari), to map session (nimbus) key to author (collator) key\n        if (queryAt['parachainStaking']?.['selectedCandidates'] && queryAt.session?.nextKeys) {\n            const loggedHex = loggedAuthor.toHex();\n            return combineLatest([\n                of(header),\n                validators,\n                queryAt['parachainStaking']['selectedCandidates']().pipe(mergeMap((selectedCandidates) => combineLatest([\n                    of(selectedCandidates),\n                    queryAt.session.nextKeys.multi(selectedCandidates).pipe(map((nextKeys) => nextKeys.findIndex((o) => o.unwrapOrDefault().nimbus.toHex() === loggedHex)))\n                ])), map(([selectedCandidates, index]) => index === -1\n                    ? null\n                    : selectedCandidates[index]))\n            ]);\n        }\n    }\n    // normal operation, non-mapping\n    return combineLatest([\n        of(header),\n        validators,\n        of(null)\n    ]);\n}\nexport function getAuthorDetails(api, header, blockHash) {\n    // For on-chain state, we need to retrieve it as per the start\n    // of the block being constructed, i.e. session validators would\n    // be at the point of the block construction, not when all operations\n    // has been supplied.\n    //\n    // However for the first block (no parentHash available), we would\n    // just use the as-is\n    return api.queryAt(header.parentHash.isEmpty\n        ? blockHash || header.hash\n        : header.parentHash).pipe(switchMap((queryAt) => getAuthorDetailsWithAt(header, queryAt)));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}