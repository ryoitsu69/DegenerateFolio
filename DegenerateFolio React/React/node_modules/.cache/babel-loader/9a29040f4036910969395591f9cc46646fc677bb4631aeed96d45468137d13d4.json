{"ast":null,"code":"import { Rectangle } from '../../maths/shapes/Rectangle.mjs';\n\"use strict\";\nfunction checkRow(data, width, y) {\n  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {\n    if (data[index + 3] !== 0) return false;\n  }\n  return true;\n}\nfunction checkColumn(data, width, x, top, bottom) {\n  const stride = 4 * width;\n  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {\n    if (data[index + 3] !== 0) return false;\n  }\n  return true;\n}\nfunction getCanvasBoundingBox(canvas, resolution = 1) {\n  const {\n    width,\n    height\n  } = canvas;\n  const context = canvas.getContext(\"2d\", {\n    willReadFrequently: true\n  });\n  if (context === null) {\n    throw new TypeError(\"Failed to get canvas 2D context\");\n  }\n  const imageData = context.getImageData(0, 0, width, height);\n  const data = imageData.data;\n  let left = 0;\n  let top = 0;\n  let right = width - 1;\n  let bottom = height - 1;\n  while (top < height && checkRow(data, width, top)) ++top;\n  if (top === height) return Rectangle.EMPTY;\n  while (checkRow(data, width, bottom)) --bottom;\n  while (checkColumn(data, width, left, top, bottom)) ++left;\n  while (checkColumn(data, width, right, top, bottom)) --right;\n  ++right;\n  ++bottom;\n  return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\nexport { getCanvasBoundingBox };","map":{"version":3,"names":["checkRow","data","width","y","x","index","checkColumn","top","bottom","stride","getCanvasBoundingBox","canvas","resolution","height","context","getContext","willReadFrequently","TypeError","imageData","getImageData","left","right","Rectangle","EMPTY"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/utils/canvas/getCanvasBoundingBox.ts"],"sourcesContent":["import { Rectangle } from '../../maths/shapes/Rectangle';\n\nimport type { ICanvas } from '../../environment/canvas/ICanvas';\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/**\n * Measuring the bounds of a canvas' visible (non-transparent) pixels.\n * @param canvas - The canvas to measure.\n * @param resolution - The resolution of the canvas.\n * @returns The bounding box of the canvas' visible pixels.\n * @since 7.1.0\n * @memberof utils\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution = 1): Rectangle\n{\n    // https://gist.github.com/timdown/021d9c8f2aabc7092df564996f5afbbf\n\n    const { width, height } = canvas;\n\n    const context = canvas.getContext('2d', {\n        willReadFrequently: true,\n    });\n\n    if (context === null)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    const imageData = context.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return Rectangle.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n"],"mappings":";;AAIA,SAASA,SAASC,IAAyB,EAAAC,KAAA,EAAeC,CAC1D;EACa,SAAAC,CAAA,GAAI,CAAG,EAAAC,KAAA,GAAQ,CAAI,GAAAF,CAAA,GAAID,KAAO,EAAAE,CAAA,GAAIF,KAAO,IAAEE,CAAG,EAAAC,KAAA,IAAS,CAChE;IACQ,IAAAJ,IAAA,CAAKI,KAAQ,IAAC,CAAM,QAAU;EAAA;EAG/B;AACX;AAEA,SAASC,WAAYA,CAAAL,IAAA,EAAyBC,KAAe,EAAAE,CAAA,EAAWG,GAAA,EAAaC,MACrF;EACI,MAAMC,MAAA,GAAS,CAAI,GAAAP,KAAA;EAEnB,SAASC,CAAI,GAAAI,GAAA,EAAKF,KAAS,GAAAE,GAAA,GAAME,MAAW,OAAIL,CAAI,EAAAD,CAAA,IAAKK,MAAQ,IAAEL,CAAG,EAAAE,KAAA,IAASI,MAC/E;IACQ,IAAAR,IAAA,CAAKI,KAAQ,IAAC,CAAM,QAAU;EAAA;EAG/B;AACX;AAUgB,SAAAK,qBAAqBC,MAAiB,EAAAC,UAAA,GAAa,CACnE;EAGU;IAAEV,KAAO;IAAAW;EAAA,CAAW,GAAAF,MAAA;EAEpB,MAAAG,OAAA,GAAUH,MAAO,CAAAI,UAAA,CAAW,IAAM;IACpCC,kBAAoB;EAAA,CACvB;EAED,IAAIF,OAAA,KAAY,IAChB;IACU,UAAIG,SAAA,CAAU,iCAAiC;EAAA;EAGzD,MAAMC,SAAA,GAAYJ,OAAQ,CAAAK,YAAA,CAAa,CAAG,KAAGjB,KAAA,EAAOW,MAAM;EAC1D,MAAMZ,IAAA,GAAOiB,SAAU,CAAAjB,IAAA;EAEvB,IAAImB,IAAO;EACX,IAAIb,GAAM;EACV,IAAIc,KAAA,GAAQnB,KAAQ;EACpB,IAAIM,MAAA,GAASK,MAAS;EAEtB,OAAON,GAAM,GAAAM,MAAA,IAAUb,QAAS,CAAAC,IAAA,EAAMC,KAAA,EAAOK,GAAG,GAAK,EAAAA,GAAA;EACrD,IAAIA,GAAQ,KAAAM,MAAA,EAAQ,OAAOS,SAAU,CAAAC,KAAA;EAC9B,OAAAvB,QAAA,CAASC,IAAM,EAAAC,KAAA,EAAOM,MAAM,GAAK,EAAAA,MAAA;EACxC,OAAOF,WAAY,CAAAL,IAAA,EAAMC,KAAO,EAAAkB,IAAA,EAAMb,GAAA,EAAKC,MAAM,GAAK,EAAAY,IAAA;EACtD,OAAOd,WAAY,CAAAL,IAAA,EAAMC,KAAO,EAAAmB,KAAA,EAAOd,GAAA,EAAKC,MAAM,GAAK,EAAAa,KAAA;EAErD,EAAAA,KAAA;EACA,EAAAb,MAAA;EAEK,WAAIc,SAAU,CAAAF,IAAA,GAAOR,UAAY,EAAAL,GAAA,GAAMK,UAAa,GAAAS,KAAA,GAAQD,IAAQ,IAAAR,UAAA,GAAaJ,MAAS,GAAAD,GAAA,IAAOK,UAAU;AACtH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}