{"ast":null,"code":"import { ALPHA_MODES } from \"@pixi/constants\";\nimport { determineCrossOrigin } from \"@pixi/utils\";\nimport { Resource } from \"./Resource.mjs\";\nclass BaseImageResource extends Resource {\n  /**\n   * @param {PIXI.ImageSourcee} source\n   */\n  constructor(source) {\n    const sourceAny = source,\n      width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.displayWidth || sourceAny.width,\n      height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.displayHeight || sourceAny.height;\n    super(width, height), this.source = source, this.noSubImage = !1;\n  }\n  /**\n   * Set cross origin based detecting the url and the crossorigin\n   * @param element - Element to apply crossOrigin\n   * @param url - URL to check\n   * @param crossorigin - Cross origin value to use\n   */\n  static crossOrigin(element, url, crossorigin) {\n    crossorigin === void 0 && !url.startsWith(\"data:\") ? element.crossOrigin = determineCrossOrigin(url) : crossorigin !== !1 && (element.crossOrigin = typeof crossorigin == \"string\" ? crossorigin : \"anonymous\");\n  }\n  /**\n   * Upload the texture to the GPU.\n   * @param renderer - Upload to the renderer\n   * @param baseTexture - Reference to parent texture\n   * @param glTexture\n   * @param {PIXI.ImageSourcee} [source] - (optional)\n   * @returns - true is success\n   */\n  upload(renderer, baseTexture, glTexture, source) {\n    const gl = renderer.gl,\n      width = baseTexture.realWidth,\n      height = baseTexture.realHeight;\n    if (source = source || this.source, typeof HTMLImageElement < \"u\" && source instanceof HTMLImageElement) {\n      if (!source.complete || source.naturalWidth === 0) return !1;\n    } else if (typeof HTMLVideoElement < \"u\" && source instanceof HTMLVideoElement && source.readyState <= 1) return !1;\n    return gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK), !this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height ? gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source) : (glTexture.width = width, glTexture.height = height, gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source)), !0;\n  }\n  /**\n   * Checks if source width/height was changed, resize can cause extra baseTexture update.\n   * Triggers one update in any case.\n   */\n  update() {\n    if (this.destroyed) return;\n    const source = this.source,\n      width = source.naturalWidth || source.videoWidth || source.width,\n      height = source.naturalHeight || source.videoHeight || source.height;\n    this.resize(width, height), super.update();\n  }\n  /** Destroy this {@link PIXI.BaseImageResource} */\n  dispose() {\n    this.source = null;\n  }\n}\nexport { BaseImageResource };","map":{"version":3,"names":["BaseImageResource","Resource","constructor","source","sourceAny","width","naturalWidth","videoWidth","displayWidth","height","naturalHeight","videoHeight","displayHeight","noSubImage","crossOrigin","element","url","crossorigin","startsWith","determineCrossOrigin","upload","renderer","baseTexture","glTexture","gl","realWidth","realHeight","HTMLImageElement","complete","HTMLVideoElement","readyState","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","alphaMode","ALPHA_MODES","UNPACK","target","TEXTURE_2D","texSubImage2D","format","type","texImage2D","internalFormat","update","destroyed","resize","dispose"],"sources":["/home/ryoitsu/node_modules/@pixi/core/src/textures/resources/BaseImageResource.ts"],"sourcesContent":["import { ALPHA_MODES } from '@pixi/constants';\nimport { determineCrossOrigin } from '@pixi/utils';\nimport { Resource } from './Resource';\n\nimport type { Renderer } from '../../Renderer';\nimport type { BaseTexture, ImageSource } from '../BaseTexture';\nimport type { GLTexture } from '../GLTexture';\n\n/**\n * Base for all the image/canvas resources.\n * @memberof PIXI\n */\nexport class BaseImageResource extends Resource\n{\n    /**\n     * The source element.\n     * @member {PIXI.ImageSourcee}\n     * @readonly\n     */\n    public source: ImageSource;\n\n    /**\n     * If set to `true`, will force `texImage2D` over `texSubImage2D` for uploading.\n     * Certain types of media (e.g. video) using `texImage2D` is more performant.\n     * @default false\n     * @private\n     */\n    public noSubImage: boolean;\n\n    /**\n     * @param {PIXI.ImageSourcee} source\n     */\n    constructor(source: ImageSource)\n    {\n        const sourceAny = source as any;\n        const width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.displayWidth || sourceAny.width;\n        const height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.displayHeight || sourceAny.height;\n\n        super(width, height);\n\n        this.source = source;\n        this.noSubImage = false;\n    }\n\n    /**\n     * Set cross origin based detecting the url and the crossorigin\n     * @param element - Element to apply crossOrigin\n     * @param url - URL to check\n     * @param crossorigin - Cross origin value to use\n     */\n    static crossOrigin(element: HTMLImageElement | HTMLVideoElement, url: string, crossorigin?: boolean | string): void\n    {\n        if (crossorigin === undefined && !url.startsWith('data:'))\n        {\n            element.crossOrigin = determineCrossOrigin(url);\n        }\n        else if (crossorigin !== false)\n        {\n            element.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';\n        }\n    }\n\n    /**\n     * Upload the texture to the GPU.\n     * @param renderer - Upload to the renderer\n     * @param baseTexture - Reference to parent texture\n     * @param glTexture\n     * @param {PIXI.ImageSourcee} [source] - (optional)\n     * @returns - true is success\n     */\n    override upload(renderer: Renderer, baseTexture: BaseTexture, glTexture: GLTexture, source?: ImageSource): boolean\n    {\n        const gl = renderer.gl;\n        const width = baseTexture.realWidth;\n        const height = baseTexture.realHeight;\n\n        source = source || this.source;\n\n        if (typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement)\n        {\n            if (!source.complete || source.naturalWidth === 0)\n            {\n                return false;\n            }\n        }\n        else if (typeof HTMLVideoElement !== 'undefined' && source instanceof HTMLVideoElement)\n        {\n            if (source.readyState <= 1)\n            {\n                return false;\n            }\n        }\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);\n\n        if (!this.noSubImage\n            && baseTexture.target === gl.TEXTURE_2D\n            && glTexture.width === width\n            && glTexture.height === height)\n        {\n            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);\n        }\n        else\n        {\n            glTexture.width = width;\n            glTexture.height = height;\n\n            gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks if source width/height was changed, resize can cause extra baseTexture update.\n     * Triggers one update in any case.\n     */\n    override update(): void\n    {\n        if (this.destroyed)\n        {\n            return;\n        }\n\n        const source = this.source as any;\n\n        const width = source.naturalWidth || source.videoWidth || source.width;\n        const height = source.naturalHeight || source.videoHeight || source.height;\n\n        this.resize(width, height);\n\n        super.update();\n    }\n\n    /** Destroy this {@link PIXI.BaseImageResource} */\n    override dispose(): void\n    {\n        this.source = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}