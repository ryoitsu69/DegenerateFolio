{"ast":null,"code":"import { getTypeDef, TypeDefInfo } from '@polkadot/types-create';\nfunction extractSubSingle(_, {\n  sub\n}) {\n  const {\n    lookupName,\n    type\n  } = sub;\n  return extractTypes([lookupName || type]);\n}\nfunction extractSubArray(_, {\n  sub\n}) {\n  return extractTypes(sub.map(({\n    lookupName,\n    type\n  }) => lookupName || type));\n}\nfunction unhandled(type, {\n  info\n}) {\n  throw new Error(`Unhandled: Unable to create and validate type from ${type} (info=${TypeDefInfo[info]})`);\n}\nconst mapping = {\n  [TypeDefInfo.BTreeMap]: extractSubArray,\n  [TypeDefInfo.BTreeSet]: extractSubSingle,\n  [TypeDefInfo.Compact]: extractSubSingle,\n  [TypeDefInfo.DoNotConstruct]: unhandled,\n  [TypeDefInfo.Enum]: extractSubArray,\n  [TypeDefInfo.HashMap]: extractSubArray,\n  [TypeDefInfo.Int]: unhandled,\n  [TypeDefInfo.Linkage]: extractSubSingle,\n  [TypeDefInfo.Null]: unhandled,\n  [TypeDefInfo.Option]: extractSubSingle,\n  [TypeDefInfo.Plain]: (_, typeDef) => typeDef.lookupName || typeDef.type,\n  [TypeDefInfo.Range]: extractSubSingle,\n  [TypeDefInfo.RangeInclusive]: extractSubSingle,\n  [TypeDefInfo.Result]: extractSubArray,\n  [TypeDefInfo.Set]: extractSubArray,\n  [TypeDefInfo.Si]: unhandled,\n  [TypeDefInfo.Struct]: extractSubArray,\n  [TypeDefInfo.Tuple]: extractSubArray,\n  [TypeDefInfo.UInt]: unhandled,\n  [TypeDefInfo.Vec]: extractSubSingle,\n  [TypeDefInfo.VecFixed]: extractSubSingle,\n  [TypeDefInfo.WrapperKeepOpaque]: extractSubSingle,\n  [TypeDefInfo.WrapperOpaque]: extractSubSingle\n};\n/** @internal */\nexport function extractTypes(types) {\n  const count = types.length;\n  const result = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const type = types[i];\n    const typeDef = getTypeDef(type);\n    result[i] = mapping[typeDef.info](type, typeDef);\n  }\n  return result;\n}","map":{"version":3,"names":["getTypeDef","TypeDefInfo","extractSubSingle","_","sub","lookupName","type","extractTypes","extractSubArray","map","unhandled","info","Error","mapping","BTreeMap","BTreeSet","Compact","DoNotConstruct","Enum","HashMap","Int","Linkage","Null","Option","Plain","typeDef","Range","RangeInclusive","Result","Set","Si","Struct","Tuple","UInt","Vec","VecFixed","WrapperKeepOpaque","WrapperOpaque","types","count","length","result","Array","i"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/metadata/util/extractTypes.js"],"sourcesContent":["import { getTypeDef, TypeDefInfo } from '@polkadot/types-create';\nfunction extractSubSingle(_, { sub }) {\n    const { lookupName, type } = sub;\n    return extractTypes([lookupName || type]);\n}\nfunction extractSubArray(_, { sub }) {\n    return extractTypes(sub.map(({ lookupName, type }) => lookupName || type));\n}\nfunction unhandled(type, { info }) {\n    throw new Error(`Unhandled: Unable to create and validate type from ${type} (info=${TypeDefInfo[info]})`);\n}\nconst mapping = {\n    [TypeDefInfo.BTreeMap]: extractSubArray,\n    [TypeDefInfo.BTreeSet]: extractSubSingle,\n    [TypeDefInfo.Compact]: extractSubSingle,\n    [TypeDefInfo.DoNotConstruct]: unhandled,\n    [TypeDefInfo.Enum]: extractSubArray,\n    [TypeDefInfo.HashMap]: extractSubArray,\n    [TypeDefInfo.Int]: unhandled,\n    [TypeDefInfo.Linkage]: extractSubSingle,\n    [TypeDefInfo.Null]: unhandled,\n    [TypeDefInfo.Option]: extractSubSingle,\n    [TypeDefInfo.Plain]: (_, typeDef) => typeDef.lookupName || typeDef.type,\n    [TypeDefInfo.Range]: extractSubSingle,\n    [TypeDefInfo.RangeInclusive]: extractSubSingle,\n    [TypeDefInfo.Result]: extractSubArray,\n    [TypeDefInfo.Set]: extractSubArray,\n    [TypeDefInfo.Si]: unhandled,\n    [TypeDefInfo.Struct]: extractSubArray,\n    [TypeDefInfo.Tuple]: extractSubArray,\n    [TypeDefInfo.UInt]: unhandled,\n    [TypeDefInfo.Vec]: extractSubSingle,\n    [TypeDefInfo.VecFixed]: extractSubSingle,\n    [TypeDefInfo.WrapperKeepOpaque]: extractSubSingle,\n    [TypeDefInfo.WrapperOpaque]: extractSubSingle\n};\n/** @internal */\nexport function extractTypes(types) {\n    const count = types.length;\n    const result = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const type = types[i];\n        const typeDef = getTypeDef(type);\n        result[i] = mapping[typeDef.info](type, typeDef);\n    }\n    return result;\n}\n"],"mappings":"AAAA,SAASA,UAAU,EAAEC,WAAW,QAAQ,wBAAwB;AAChE,SAASC,gBAAgBA,CAACC,CAAC,EAAE;EAAEC;AAAI,CAAC,EAAE;EAClC,MAAM;IAAEC,UAAU;IAAEC;EAAK,CAAC,GAAGF,GAAG;EAChC,OAAOG,YAAY,CAAC,CAACF,UAAU,IAAIC,IAAI,CAAC,CAAC;AAC7C;AACA,SAASE,eAAeA,CAACL,CAAC,EAAE;EAAEC;AAAI,CAAC,EAAE;EACjC,OAAOG,YAAY,CAACH,GAAG,CAACK,GAAG,CAAC,CAAC;IAAEJ,UAAU;IAAEC;EAAK,CAAC,KAAKD,UAAU,IAAIC,IAAI,CAAC,CAAC;AAC9E;AACA,SAASI,SAASA,CAACJ,IAAI,EAAE;EAAEK;AAAK,CAAC,EAAE;EAC/B,MAAM,IAAIC,KAAK,CAAE,sDAAqDN,IAAK,UAASL,WAAW,CAACU,IAAI,CAAE,GAAE,CAAC;AAC7G;AACA,MAAME,OAAO,GAAG;EACZ,CAACZ,WAAW,CAACa,QAAQ,GAAGN,eAAe;EACvC,CAACP,WAAW,CAACc,QAAQ,GAAGb,gBAAgB;EACxC,CAACD,WAAW,CAACe,OAAO,GAAGd,gBAAgB;EACvC,CAACD,WAAW,CAACgB,cAAc,GAAGP,SAAS;EACvC,CAACT,WAAW,CAACiB,IAAI,GAAGV,eAAe;EACnC,CAACP,WAAW,CAACkB,OAAO,GAAGX,eAAe;EACtC,CAACP,WAAW,CAACmB,GAAG,GAAGV,SAAS;EAC5B,CAACT,WAAW,CAACoB,OAAO,GAAGnB,gBAAgB;EACvC,CAACD,WAAW,CAACqB,IAAI,GAAGZ,SAAS;EAC7B,CAACT,WAAW,CAACsB,MAAM,GAAGrB,gBAAgB;EACtC,CAACD,WAAW,CAACuB,KAAK,GAAG,CAACrB,CAAC,EAAEsB,OAAO,KAAKA,OAAO,CAACpB,UAAU,IAAIoB,OAAO,CAACnB,IAAI;EACvE,CAACL,WAAW,CAACyB,KAAK,GAAGxB,gBAAgB;EACrC,CAACD,WAAW,CAAC0B,cAAc,GAAGzB,gBAAgB;EAC9C,CAACD,WAAW,CAAC2B,MAAM,GAAGpB,eAAe;EACrC,CAACP,WAAW,CAAC4B,GAAG,GAAGrB,eAAe;EAClC,CAACP,WAAW,CAAC6B,EAAE,GAAGpB,SAAS;EAC3B,CAACT,WAAW,CAAC8B,MAAM,GAAGvB,eAAe;EACrC,CAACP,WAAW,CAAC+B,KAAK,GAAGxB,eAAe;EACpC,CAACP,WAAW,CAACgC,IAAI,GAAGvB,SAAS;EAC7B,CAACT,WAAW,CAACiC,GAAG,GAAGhC,gBAAgB;EACnC,CAACD,WAAW,CAACkC,QAAQ,GAAGjC,gBAAgB;EACxC,CAACD,WAAW,CAACmC,iBAAiB,GAAGlC,gBAAgB;EACjD,CAACD,WAAW,CAACoC,aAAa,GAAGnC;AACjC,CAAC;AACD;AACA,OAAO,SAASK,YAAYA,CAAC+B,KAAK,EAAE;EAChC,MAAMC,KAAK,GAAGD,KAAK,CAACE,MAAM;EAC1B,MAAMC,MAAM,GAAG,IAAIC,KAAK,CAACH,KAAK,CAAC;EAC/B,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,EAAEI,CAAC,EAAE,EAAE;IAC5B,MAAMrC,IAAI,GAAGgC,KAAK,CAACK,CAAC,CAAC;IACrB,MAAMlB,OAAO,GAAGzB,UAAU,CAACM,IAAI,CAAC;IAChCmC,MAAM,CAACE,CAAC,CAAC,GAAG9B,OAAO,CAACY,OAAO,CAACd,IAAI,CAAC,CAACL,IAAI,EAAEmB,OAAO,CAAC;EACpD;EACA,OAAOgB,MAAM;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}