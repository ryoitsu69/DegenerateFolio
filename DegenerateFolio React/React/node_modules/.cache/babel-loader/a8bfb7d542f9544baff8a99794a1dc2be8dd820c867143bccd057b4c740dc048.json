{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst tmp = require('tmp');\n\n/**\n * @param {!Function} fn .\n * @return {!Promise<T>} .\n * @template T\n */\nfunction checkedCall(fn) {\n  return new Promise((resolve, reject) => {\n    try {\n      fn((err, value) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(value);\n        }\n      });\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\n/**\n * Recursively removes a directory and all of its contents. This is equivalent\n * to {@code rm -rf} on a POSIX system.\n * @param {string} dirPath Path to the directory to remove.\n * @return {!Promise} A promise to be resolved when the operation has\n *     completed.\n */\nfunction rmDir(dirPath) {\n  return new Promise(function (fulfill, reject) {\n    fs.rm(dirPath, {\n      recursive: true,\n      maxRetries: 2\n    }, function (err) {\n      if (err && err.code === 'ENOENT') {\n        fulfill();\n      } else if (err) {\n        reject(err);\n      }\n      fulfill();\n    });\n  });\n}\n\n/**\n * Copies one file to another.\n * @param {string} src The source file.\n * @param {string} dst The destination file.\n * @return {!Promise<string>} A promise for the copied file's path.\n */\nfunction copy(src, dst) {\n  return new Promise(function (fulfill, reject) {\n    const rs = fs.createReadStream(src);\n    rs.on('error', reject);\n    const ws = fs.createWriteStream(dst);\n    ws.on('error', reject);\n    ws.on('close', () => fulfill(dst));\n    rs.pipe(ws);\n  });\n}\n\n/**\n * Recursively copies the contents of one directory to another.\n * @param {string} src The source directory to copy.\n * @param {string} dst The directory to copy into.\n * @param {(RegExp|function(string): boolean)=} opt_exclude An exclusion filter\n *     as either a regex or predicate function. All files matching this filter\n *     will not be copied.\n * @return {!Promise<string>} A promise for the destination\n *     directory's path once all files have been copied.\n */\nfunction copyDir(src, dst, opt_exclude) {\n  let predicate = opt_exclude;\n  if (opt_exclude && typeof opt_exclude !== 'function') {\n    predicate = function (p) {\n      return !opt_exclude.test(p);\n    };\n  }\n  if (!fs.existsSync(dst)) {\n    fs.mkdirSync(dst);\n  }\n  let files = fs.readdirSync(src);\n  files = files.map(function (file) {\n    return path.join(src, file);\n  });\n  if (predicate) {\n    files = files.filter( /** @type {function(string): boolean} */predicate);\n  }\n  const results = [];\n  files.forEach(function (file) {\n    const stats = fs.statSync(file);\n    const target = path.join(dst, path.basename(file));\n    if (stats.isDirectory()) {\n      if (!fs.existsSync(target)) {\n        fs.mkdirSync(target, stats.mode);\n      }\n      results.push(copyDir(file, target, predicate));\n    } else {\n      results.push(copy(file, target));\n    }\n  });\n  return Promise.all(results).then(() => dst);\n}\n\n/**\n * Tests if a file path exists.\n * @param {string} aPath The path to test.\n * @return {!Promise<boolean>} A promise for whether the file exists.\n */\nfunction exists(aPath) {\n  return new Promise(function (fulfill, reject) {\n    let type = typeof aPath;\n    if (type !== 'string') {\n      reject(TypeError(`expected string path, but got ${type}`));\n    } else {\n      fulfill(fs.existsSync(aPath));\n    }\n  });\n}\n\n/**\n * Calls `stat(2)`.\n * @param {string} aPath The path to stat.\n * @return {!Promise<!fs.Stats>} A promise for the file stats.\n */\nfunction stat(aPath) {\n  return checkedCall(callback => fs.stat(aPath, callback));\n}\n\n/**\n * Deletes a name from the filesystem and possibly the file it refers to. Has\n * no effect if the file does not exist.\n * @param {string} aPath The path to remove.\n * @return {!Promise} A promise for when the file has been removed.\n */\nfunction unlink(aPath) {\n  return new Promise(function (fulfill, reject) {\n    const exists = fs.existsSync(aPath);\n    if (exists) {\n      fs.unlink(aPath, function (err) {\n        ;\n        err && reject(err) || fulfill();\n      });\n    } else {\n      fulfill();\n    }\n  });\n}\n\n/**\n * @return {!Promise<string>} A promise for the path to a temporary directory.\n * @see https://www.npmjs.org/package/tmp\n */\nfunction tmpDir() {\n  return checkedCall(callback => tmp.dir({\n    unsafeCleanup: true\n  }, callback));\n}\n\n/**\n * @param {{postfix: string}=} opt_options Temporary file options.\n * @return {!Promise<string>} A promise for the path to a temporary file.\n * @see https://www.npmjs.org/package/tmp\n */\nfunction tmpFile(opt_options) {\n  return checkedCall(callback => {\n    /**  check fixed in v > 0.2.1 if\n     * (typeof options === 'function') {\n     *     return [{}, options];\n     * }\n     */\n    tmp.file(opt_options, callback);\n  });\n}\n\n/**\n * Searches the {@code PATH} environment variable for the given file.\n * @param {string} file The file to locate on the PATH.\n * @param {boolean=} opt_checkCwd Whether to always start with the search with\n *     the current working directory, regardless of whether it is explicitly\n *     listed on the PATH.\n * @return {?string} Path to the located file, or {@code null} if it could\n *     not be found.\n */\nfunction findInPath(file, opt_checkCwd) {\n  const dirs = [];\n  if (opt_checkCwd) {\n    dirs.push(process.cwd());\n  }\n  dirs.push.apply(dirs, process.env['PATH'].split(path.delimiter));\n  let foundInDir = dirs.find(dir => {\n    let tmp = path.join(dir, file);\n    try {\n      let stats = fs.statSync(tmp);\n      return stats.isFile() && !stats.isDirectory();\n    } catch (ex) {\n      return false;\n    }\n  });\n  return foundInDir ? path.join(foundInDir, file) : null;\n}\n\n/**\n * Reads the contents of the given file.\n *\n * @param {string} aPath Path to the file to read.\n * @return {!Promise<!Buffer>} A promise that will resolve with a buffer of the\n *     file contents.\n */\nfunction read(aPath) {\n  return checkedCall(callback => fs.readFile(aPath, callback));\n}\n\n/**\n * Writes to a file.\n *\n * @param {string} aPath Path to the file to write to.\n * @param {(string|!Buffer)} data The data to write.\n * @return {!Promise} A promise that will resolve when the operation has\n *     completed.\n */\nfunction write(aPath, data) {\n  return checkedCall(callback => fs.writeFile(aPath, data, callback));\n}\n\n/**\n * Creates a directory.\n *\n * @param {string} aPath The directory path.\n * @return {!Promise<string>} A promise that will resolve with the path of the\n *     created directory.\n */\nfunction mkdir(aPath) {\n  return checkedCall(callback => {\n    fs.mkdir(aPath, undefined, err => {\n      if (err && err.code !== 'EEXIST') {\n        callback(err);\n      } else {\n        callback(null, aPath);\n      }\n    });\n  });\n}\n\n/**\n * Recursively creates a directory and any ancestors that do not yet exist.\n *\n * @param {string} dir The directory path to create.\n * @return {!Promise<string>} A promise that will resolve with the path of the\n *     created directory.\n */\nfunction mkdirp(dir) {\n  return checkedCall(callback => {\n    fs.mkdir(dir, undefined, err => {\n      if (!err) {\n        callback(null, dir);\n        return;\n      }\n      switch (err.code) {\n        case 'EEXIST':\n          callback(null, dir);\n          return;\n        case 'ENOENT':\n          return mkdirp(path.dirname(dir)).then(() => mkdirp(dir)).then(() => callback(null, dir), err => callback(err));\n        default:\n          callback(err);\n          return;\n      }\n    });\n  });\n}\n\n/**\n * Recursively walks a directory, returning a promise that will resolve with\n * a list of all files/directories seen.\n *\n * @param {string} rootPath the directory to walk.\n * @return {!Promise<!Array<{path: string, dir: boolean}>>} a promise that will\n *     resolve with a list of entries seen. For each entry, the recorded path\n *     will be relative to `rootPath`.\n */\nfunction walkDir(rootPath) {\n  const seen = [];\n  return function walk(dir) {\n    return checkedCall(callback => fs.readdir(dir, callback)).then(files => Promise.all(files.map(file => {\n      file = path.join(dir, file);\n      return checkedCall(cb => fs.stat(file, cb)).then(stats => {\n        seen.push({\n          path: path.relative(rootPath, file),\n          dir: stats.isDirectory()\n        });\n        return stats.isDirectory() && walk(file);\n      });\n    })));\n  }(rootPath).then(() => seen);\n}\n\n// PUBLIC API\nmodule.exports = {\n  walkDir,\n  rmDir,\n  mkdirp,\n  mkdir,\n  write,\n  read,\n  findInPath,\n  tmpFile,\n  tmpDir,\n  unlink,\n  copy,\n  copyDir,\n  exists,\n  stat\n};","map":{"version":3,"names":["fs","require","path","tmp","checkedCall","fn","Promise","resolve","reject","err","value","e","rmDir","dirPath","fulfill","rm","recursive","maxRetries","code","copy","src","dst","rs","createReadStream","on","ws","createWriteStream","pipe","copyDir","opt_exclude","predicate","p","test","existsSync","mkdirSync","files","readdirSync","map","file","join","filter","results","forEach","stats","statSync","target","basename","isDirectory","mode","push","all","then","exists","aPath","type","TypeError","stat","callback","unlink","tmpDir","dir","unsafeCleanup","tmpFile","opt_options","findInPath","opt_checkCwd","dirs","process","cwd","apply","env","split","delimiter","foundInDir","find","isFile","ex","read","readFile","write","data","writeFile","mkdir","undefined","mkdirp","dirname","walkDir","rootPath","seen","walk","readdir","cb","relative","module","exports"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/selenium-webdriver/io/index.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\nconst tmp = require('tmp')\n\n/**\n * @param {!Function} fn .\n * @return {!Promise<T>} .\n * @template T\n */\nfunction checkedCall(fn) {\n  return new Promise((resolve, reject) => {\n    try {\n      fn((err, value) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(value)\n        }\n      })\n    } catch (e) {\n      reject(e)\n    }\n  })\n}\n\n/**\n * Recursively removes a directory and all of its contents. This is equivalent\n * to {@code rm -rf} on a POSIX system.\n * @param {string} dirPath Path to the directory to remove.\n * @return {!Promise} A promise to be resolved when the operation has\n *     completed.\n */\nfunction rmDir(dirPath) {\n  return new Promise(function (fulfill, reject) {\n    fs.rm(dirPath, { recursive: true, maxRetries: 2 }, function (err) {\n      if (err && err.code === 'ENOENT') {\n        fulfill()\n      } else if (err) {\n        reject(err)\n      }\n      fulfill()\n    })\n  })\n}\n\n/**\n * Copies one file to another.\n * @param {string} src The source file.\n * @param {string} dst The destination file.\n * @return {!Promise<string>} A promise for the copied file's path.\n */\nfunction copy(src, dst) {\n  return new Promise(function (fulfill, reject) {\n    const rs = fs.createReadStream(src)\n    rs.on('error', reject)\n\n    const ws = fs.createWriteStream(dst)\n    ws.on('error', reject)\n    ws.on('close', () => fulfill(dst))\n\n    rs.pipe(ws)\n  })\n}\n\n/**\n * Recursively copies the contents of one directory to another.\n * @param {string} src The source directory to copy.\n * @param {string} dst The directory to copy into.\n * @param {(RegExp|function(string): boolean)=} opt_exclude An exclusion filter\n *     as either a regex or predicate function. All files matching this filter\n *     will not be copied.\n * @return {!Promise<string>} A promise for the destination\n *     directory's path once all files have been copied.\n */\nfunction copyDir(src, dst, opt_exclude) {\n  let predicate = opt_exclude\n  if (opt_exclude && typeof opt_exclude !== 'function') {\n    predicate = function (p) {\n      return !opt_exclude.test(p)\n    }\n  }\n\n  if (!fs.existsSync(dst)) {\n    fs.mkdirSync(dst)\n  }\n\n  let files = fs.readdirSync(src)\n  files = files.map(function (file) {\n    return path.join(src, file)\n  })\n\n  if (predicate) {\n    files = files.filter(/** @type {function(string): boolean} */ (predicate))\n  }\n\n  const results = []\n  files.forEach(function (file) {\n    const stats = fs.statSync(file)\n    const target = path.join(dst, path.basename(file))\n\n    if (stats.isDirectory()) {\n      if (!fs.existsSync(target)) {\n        fs.mkdirSync(target, stats.mode)\n      }\n      results.push(copyDir(file, target, predicate))\n    } else {\n      results.push(copy(file, target))\n    }\n  })\n\n  return Promise.all(results).then(() => dst)\n}\n\n/**\n * Tests if a file path exists.\n * @param {string} aPath The path to test.\n * @return {!Promise<boolean>} A promise for whether the file exists.\n */\nfunction exists(aPath) {\n  return new Promise(function (fulfill, reject) {\n    let type = typeof aPath\n    if (type !== 'string') {\n      reject(TypeError(`expected string path, but got ${type}`))\n    } else {\n      fulfill(fs.existsSync(aPath))\n    }\n  })\n}\n\n/**\n * Calls `stat(2)`.\n * @param {string} aPath The path to stat.\n * @return {!Promise<!fs.Stats>} A promise for the file stats.\n */\nfunction stat(aPath) {\n  return checkedCall((callback) => fs.stat(aPath, callback))\n}\n\n/**\n * Deletes a name from the filesystem and possibly the file it refers to. Has\n * no effect if the file does not exist.\n * @param {string} aPath The path to remove.\n * @return {!Promise} A promise for when the file has been removed.\n */\nfunction unlink(aPath) {\n  return new Promise(function (fulfill, reject) {\n    const exists = fs.existsSync(aPath)\n    if (exists) {\n      fs.unlink(aPath, function (err) {\n        ;(err && reject(err)) || fulfill()\n      })\n    } else {\n      fulfill()\n    }\n  })\n}\n\n/**\n * @return {!Promise<string>} A promise for the path to a temporary directory.\n * @see https://www.npmjs.org/package/tmp\n */\nfunction tmpDir() {\n  return checkedCall((callback) => tmp.dir({ unsafeCleanup: true }, callback))\n}\n\n/**\n * @param {{postfix: string}=} opt_options Temporary file options.\n * @return {!Promise<string>} A promise for the path to a temporary file.\n * @see https://www.npmjs.org/package/tmp\n */\nfunction tmpFile(opt_options) {\n  return checkedCall((callback) => {\n    /**  check fixed in v > 0.2.1 if\n     * (typeof options === 'function') {\n     *     return [{}, options];\n     * }\n     */\n    tmp.file(opt_options, callback)\n  })\n}\n\n/**\n * Searches the {@code PATH} environment variable for the given file.\n * @param {string} file The file to locate on the PATH.\n * @param {boolean=} opt_checkCwd Whether to always start with the search with\n *     the current working directory, regardless of whether it is explicitly\n *     listed on the PATH.\n * @return {?string} Path to the located file, or {@code null} if it could\n *     not be found.\n */\nfunction findInPath(file, opt_checkCwd) {\n  const dirs = []\n  if (opt_checkCwd) {\n    dirs.push(process.cwd())\n  }\n  dirs.push.apply(dirs, process.env['PATH'].split(path.delimiter))\n\n  let foundInDir = dirs.find((dir) => {\n    let tmp = path.join(dir, file)\n    try {\n      let stats = fs.statSync(tmp)\n      return stats.isFile() && !stats.isDirectory()\n    } catch (ex) {\n      return false\n    }\n  })\n\n  return foundInDir ? path.join(foundInDir, file) : null\n}\n\n/**\n * Reads the contents of the given file.\n *\n * @param {string} aPath Path to the file to read.\n * @return {!Promise<!Buffer>} A promise that will resolve with a buffer of the\n *     file contents.\n */\nfunction read(aPath) {\n  return checkedCall((callback) => fs.readFile(aPath, callback))\n}\n\n/**\n * Writes to a file.\n *\n * @param {string} aPath Path to the file to write to.\n * @param {(string|!Buffer)} data The data to write.\n * @return {!Promise} A promise that will resolve when the operation has\n *     completed.\n */\nfunction write(aPath, data) {\n  return checkedCall((callback) => fs.writeFile(aPath, data, callback))\n}\n\n/**\n * Creates a directory.\n *\n * @param {string} aPath The directory path.\n * @return {!Promise<string>} A promise that will resolve with the path of the\n *     created directory.\n */\nfunction mkdir(aPath) {\n  return checkedCall((callback) => {\n    fs.mkdir(aPath, undefined, (err) => {\n      if (err && err.code !== 'EEXIST') {\n        callback(err)\n      } else {\n        callback(null, aPath)\n      }\n    })\n  })\n}\n\n/**\n * Recursively creates a directory and any ancestors that do not yet exist.\n *\n * @param {string} dir The directory path to create.\n * @return {!Promise<string>} A promise that will resolve with the path of the\n *     created directory.\n */\nfunction mkdirp(dir) {\n  return checkedCall((callback) => {\n    fs.mkdir(dir, undefined, (err) => {\n      if (!err) {\n        callback(null, dir)\n        return\n      }\n\n      switch (err.code) {\n        case 'EEXIST':\n          callback(null, dir)\n          return\n        case 'ENOENT':\n          return mkdirp(path.dirname(dir))\n            .then(() => mkdirp(dir))\n            .then(\n              () => callback(null, dir),\n              (err) => callback(err),\n            )\n        default:\n          callback(err)\n          return\n      }\n    })\n  })\n}\n\n/**\n * Recursively walks a directory, returning a promise that will resolve with\n * a list of all files/directories seen.\n *\n * @param {string} rootPath the directory to walk.\n * @return {!Promise<!Array<{path: string, dir: boolean}>>} a promise that will\n *     resolve with a list of entries seen. For each entry, the recorded path\n *     will be relative to `rootPath`.\n */\nfunction walkDir(rootPath) {\n  const seen = []\n  return (function walk(dir) {\n    return checkedCall((callback) => fs.readdir(dir, callback)).then((files) =>\n      Promise.all(\n        files.map((file) => {\n          file = path.join(dir, file)\n          return checkedCall((cb) => fs.stat(file, cb)).then((stats) => {\n            seen.push({\n              path: path.relative(rootPath, file),\n              dir: stats.isDirectory(),\n            })\n            return stats.isDirectory() && walk(file)\n          })\n        }),\n      ),\n    )\n  })(rootPath).then(() => seen)\n}\n\n// PUBLIC API\nmodule.exports = {\n  walkDir,\n  rmDir,\n  mkdirp,\n  mkdir,\n  write,\n  read,\n  findInPath,\n  tmpFile,\n  tmpDir,\n  unlink,\n  copy,\n  copyDir,\n  exists,\n  stat,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}