{"ast":null,"code":"import { u8aToHex } from '@polkadot/util';\n/** @internal */\nfunction formatFailure(registry, fn, _result, {\n  message\n}, u8a, i, count, Type, key) {\n  let type = '';\n  try {\n    type = `: ${new Type(registry).toRawType()}`;\n  } catch {\n    // ignore\n  }\n  // This is extra debugging info (we most-probably want this in in some way, shape or form,\n  // but at this point not quite sure how to include and format it (it can be quite massive)\n  // console.error(JSON.stringify(result, null, 2));\n  return `${fn}: failed at ${u8aToHex(u8a.subarray(0, 16))}…${key ? ` on ${key}` : ''} (index ${i + 1}/${count})${type}:: ${message}`;\n}\n/**\n * @internal\n *\n * Given an u8a, and an array of Type constructors, decode the u8a against the\n * types, and return an array of decoded values.\n *\n * @param u8a - The u8a to decode.\n * @param result - The result array (will be returned with values pushed)\n * @param types - The array of CodecClass to decode the U8a against.\n */\nexport function decodeU8a(registry, result, u8a, [Types, keys]) {\n  const count = result.length;\n  let offset = 0;\n  let i = 0;\n  try {\n    while (i < count) {\n      const value = new Types[i](registry, u8a.subarray(offset));\n      offset += value.initialU8aLength || value.encodedLength;\n      result[i] = value;\n      i++;\n    }\n  } catch (error) {\n    throw new Error(formatFailure(registry, 'decodeU8a', result, error, u8a.subarray(offset), i, count, Types[i], keys[i]));\n  }\n  return [result, offset];\n}\n/**\n * @internal\n *\n * Split from decodeU8a since this is specialized to zip returns ... while we duplicate, this\n * is all on the hot-path, so it is not great, however there is (some) method behind the madness\n */\nexport function decodeU8aStruct(registry, result, u8a, [Types, keys]) {\n  const count = result.length;\n  let offset = 0;\n  let i = 0;\n  try {\n    while (i < count) {\n      const value = new Types[i](registry, u8a.subarray(offset));\n      offset += value.initialU8aLength || value.encodedLength;\n      result[i] = [keys[i], value];\n      i++;\n    }\n  } catch (error) {\n    throw new Error(formatFailure(registry, 'decodeU8aStruct', result, error, u8a.subarray(offset), i, count, Types[i], keys[i]));\n  }\n  return [result, offset];\n}\n/**\n * @internal\n *\n * Split from decodeU8a since this is specialized to 1 instance ... while we duplicate, this\n * is all on the hot-path, so it is not great, however there is (some) method behind the madness\n */\nexport function decodeU8aVec(registry, result, u8a, startAt, Type) {\n  const count = result.length;\n  let offset = startAt;\n  let i = 0;\n  try {\n    while (i < count) {\n      const value = new Type(registry, u8a.subarray(offset));\n      offset += value.initialU8aLength || value.encodedLength;\n      result[i] = value;\n      i++;\n    }\n  } catch (error) {\n    throw new Error(formatFailure(registry, 'decodeU8aVec', result, error, u8a.subarray(offset), i, count, Type));\n  }\n  return [offset, offset - startAt];\n}","map":{"version":3,"names":["u8aToHex","formatFailure","registry","fn","_result","message","u8a","i","count","Type","key","type","toRawType","subarray","decodeU8a","result","Types","keys","length","offset","value","initialU8aLength","encodedLength","error","Error","decodeU8aStruct","decodeU8aVec","startAt"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/utils/decodeU8a.js"],"sourcesContent":["import { u8aToHex } from '@polkadot/util';\n/** @internal */\nfunction formatFailure(registry, fn, _result, { message }, u8a, i, count, Type, key) {\n    let type = '';\n    try {\n        type = `: ${new Type(registry).toRawType()}`;\n    }\n    catch {\n        // ignore\n    }\n    // This is extra debugging info (we most-probably want this in in some way, shape or form,\n    // but at this point not quite sure how to include and format it (it can be quite massive)\n    // console.error(JSON.stringify(result, null, 2));\n    return `${fn}: failed at ${u8aToHex(u8a.subarray(0, 16))}…${key ? ` on ${key}` : ''} (index ${i + 1}/${count})${type}:: ${message}`;\n}\n/**\n * @internal\n *\n * Given an u8a, and an array of Type constructors, decode the u8a against the\n * types, and return an array of decoded values.\n *\n * @param u8a - The u8a to decode.\n * @param result - The result array (will be returned with values pushed)\n * @param types - The array of CodecClass to decode the U8a against.\n */\nexport function decodeU8a(registry, result, u8a, [Types, keys]) {\n    const count = result.length;\n    let offset = 0;\n    let i = 0;\n    try {\n        while (i < count) {\n            const value = new Types[i](registry, u8a.subarray(offset));\n            offset += value.initialU8aLength || value.encodedLength;\n            result[i] = value;\n            i++;\n        }\n    }\n    catch (error) {\n        throw new Error(formatFailure(registry, 'decodeU8a', result, error, u8a.subarray(offset), i, count, Types[i], keys[i]));\n    }\n    return [result, offset];\n}\n/**\n * @internal\n *\n * Split from decodeU8a since this is specialized to zip returns ... while we duplicate, this\n * is all on the hot-path, so it is not great, however there is (some) method behind the madness\n */\nexport function decodeU8aStruct(registry, result, u8a, [Types, keys]) {\n    const count = result.length;\n    let offset = 0;\n    let i = 0;\n    try {\n        while (i < count) {\n            const value = new Types[i](registry, u8a.subarray(offset));\n            offset += value.initialU8aLength || value.encodedLength;\n            result[i] = [keys[i], value];\n            i++;\n        }\n    }\n    catch (error) {\n        throw new Error(formatFailure(registry, 'decodeU8aStruct', result, error, u8a.subarray(offset), i, count, Types[i], keys[i]));\n    }\n    return [result, offset];\n}\n/**\n * @internal\n *\n * Split from decodeU8a since this is specialized to 1 instance ... while we duplicate, this\n * is all on the hot-path, so it is not great, however there is (some) method behind the madness\n */\nexport function decodeU8aVec(registry, result, u8a, startAt, Type) {\n    const count = result.length;\n    let offset = startAt;\n    let i = 0;\n    try {\n        while (i < count) {\n            const value = new Type(registry, u8a.subarray(offset));\n            offset += value.initialU8aLength || value.encodedLength;\n            result[i] = value;\n            i++;\n        }\n    }\n    catch (error) {\n        throw new Error(formatFailure(registry, 'decodeU8aVec', result, error, u8a.subarray(offset), i, count, Type));\n    }\n    return [offset, offset - startAt];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}