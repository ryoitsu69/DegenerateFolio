{"ast":null,"code":"import { Raw } from '@polkadot/types-codec';\nimport { compactAddLength, compactStripLength, isUndefined, objectSpread, stringCamelCase, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { xxhashAsU8a } from '@polkadot/util-crypto';\nimport { getSiName } from '../../util/index.js';\nimport { getHasher } from './getHasher.js';\nexport const NO_RAW_ARGS = {\n  args: [],\n  hashers: [],\n  keys: []\n};\n/** @internal */\nfunction filterDefined(a) {\n  return !isUndefined(a);\n}\n/** @internal */\nfunction assertArgs(_ref, _ref2) {\n  let {\n    method,\n    section\n  } = _ref;\n  let {\n    args,\n    keys\n  } = _ref2;\n  if (!Array.isArray(args)) {\n    throw new Error(\"Call to \".concat(stringCamelCase(section || 'unknown'), \".\").concat(stringCamelCase(method || 'unknown'), \" needs \").concat(keys.length, \" arguments\"));\n  } else if (args.filter(filterDefined).length !== keys.length) {\n    throw new Error(\"Call to \".concat(stringCamelCase(section || 'unknown'), \".\").concat(stringCamelCase(method || 'unknown'), \" needs \").concat(keys.length, \" arguments, found [\").concat(args.join(', '), \"]\"));\n  }\n}\n/** @internal */\nexport function createKeyRawParts(registry, itemFn, _ref3) {\n  let {\n    args,\n    hashers,\n    keys\n  } = _ref3;\n  const count = keys.length;\n  const extra = new Array(count);\n  for (let i = 0; i < count; i++) {\n    extra[i] = getHasher(hashers[i])(registry.createTypeUnsafe(registry.createLookupType(keys[i]), [args[i]]).toU8a());\n  }\n  return [[xxhashAsU8a(itemFn.prefix, 128), xxhashAsU8a(itemFn.method, 128)], extra];\n}\n/** @internal */\nexport function createKeyInspect(registry, itemFn, args) {\n  assertArgs(itemFn, args);\n  const {\n    meta\n  } = itemFn;\n  const [prefix, extra] = createKeyRawParts(registry, itemFn, args);\n  let types = [];\n  if (meta.type.isMap) {\n    const {\n      hashers,\n      key\n    } = meta.type.asMap;\n    types = hashers.length === 1 ? [\"\".concat(hashers[0].type, \"(\").concat(getSiName(registry.lookup, key), \")\")] : registry.lookup.getSiType(key).def.asTuple.map((k, i) => \"\".concat(hashers[i].type, \"(\").concat(getSiName(registry.lookup, k), \")\"));\n  }\n  const names = ['module', 'method'].concat(...args.args.map((_, i) => types[i]));\n  return {\n    inner: prefix.concat(...extra).map((v, i) => ({\n      name: names[i],\n      outer: [v]\n    }))\n  };\n}\n/** @internal */\nexport function createKeyRaw(registry, itemFn, args) {\n  const [prefix, extra] = createKeyRawParts(registry, itemFn, args);\n  return u8aConcat(...prefix, ...extra);\n}\n/** @internal */\nfunction createKey(registry, itemFn, args) {\n  assertArgs(itemFn, args);\n  // always add the length prefix (underlying it is Bytes)\n  return compactAddLength(createKeyRaw(registry, itemFn, args));\n}\n/** @internal */\nfunction createStorageInspect(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  return function () {\n    if (type.isPlain) {\n      return options.skipHashing ? {\n        inner: [],\n        name: 'wellKnown',\n        outer: [u8aToU8a(options.key)]\n      } : createKeyInspect(registry, itemFn, NO_RAW_ARGS);\n    }\n    const {\n      hashers,\n      key\n    } = type.asMap;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return hashers.length === 1 ? createKeyInspect(registry, itemFn, {\n      args,\n      hashers,\n      keys: [key]\n    }) : createKeyInspect(registry, itemFn, {\n      args,\n      hashers,\n      keys: registry.lookup.getSiType(key).def.asTuple\n    });\n  };\n}\n/** @internal */\nfunction createStorageFn(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  let cacheKey = null;\n  // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For higher-map queries the params are passed in as an tuple, [key1, key2]\n  return function () {\n    if (type.isPlain) {\n      if (!cacheKey) {\n        cacheKey = options.skipHashing ? compactAddLength(u8aToU8a(options.key)) : createKey(registry, itemFn, NO_RAW_ARGS);\n      }\n      return cacheKey;\n    }\n    const {\n      hashers,\n      key\n    } = type.asMap;\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return hashers.length === 1 ? createKey(registry, itemFn, {\n      args,\n      hashers,\n      keys: [key]\n    }) : createKey(registry, itemFn, {\n      args,\n      hashers,\n      keys: registry.lookup.getSiType(key).def.asTuple\n    });\n  };\n}\n/** @internal */\nfunction createWithMeta(registry, itemFn, options) {\n  const {\n    meta,\n    method,\n    prefix,\n    section\n  } = itemFn;\n  const storageFn = createStorageFn(registry, itemFn, options);\n  storageFn.inspect = createStorageInspect(registry, itemFn, options);\n  storageFn.meta = meta;\n  storageFn.method = stringCamelCase(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section;\n  // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n  storageFn.toJSON = () => objectSpread({\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  }, meta.toJSON());\n  return storageFn;\n}\n/** @internal */\nfunction extendHeadMeta(registry, _ref4, _ref5, iterFn) {\n  let {\n    meta: {\n      docs,\n      name,\n      type\n    },\n    section\n  } = _ref4;\n  let {\n    method\n  } = _ref5;\n  // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n  const meta = registry.createTypeUnsafe('StorageEntryMetadataLatest', [{\n    docs,\n    fallback: registry.createTypeUnsafe('Bytes', []),\n    modifier: registry.createTypeUnsafe('StorageEntryModifierLatest', [1]),\n    // required\n    name,\n    type: registry.createTypeUnsafe('StorageEntryTypeLatest', [type.asMap.key, 0])\n  }]);\n  iterFn.meta = meta;\n  const fn = function () {\n    return registry.createTypeUnsafe('StorageKey', [iterFn(...arguments), {\n      method,\n      section\n    }]);\n  };\n  fn.meta = meta;\n  return fn;\n}\n/** @internal */\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    },\n    method,\n    section\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    if (args.length && (type.isPlain || args.length >= type.asMap.hashers.length)) {\n      throw new Error(\"Iteration of \".concat(stringCamelCase(section || 'unknown'), \".\").concat(stringCamelCase(method || 'unknown'), \" needs arguments to be at least one less than the full arguments, found [\").concat(args.join(', '), \"]\"));\n    }\n    if (args.length) {\n      if (type.isMap) {\n        const {\n          hashers,\n          key\n        } = type.asMap;\n        const keysVec = hashers.length === 1 ? [key] : registry.lookup.getSiType(key).def.asTuple;\n        return new Raw(registry, createKeyRaw(registry, itemFn, {\n          args,\n          hashers: hashers.slice(0, args.length),\n          keys: keysVec.slice(0, args.length)\n        }));\n      }\n    }\n    return new Raw(registry, createKeyRaw(registry, itemFn, NO_RAW_ARGS));\n  });\n  return storageFn;\n}\n/** @internal */\nexport function createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  const storageFn = createWithMeta(registry, itemFn, options);\n  if (type.isMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  }\n  storageFn.keyPrefix = function () {\n    return storageFn.iterKey && storageFn.iterKey(...arguments) || compactStripLength(storageFn())[1];\n  };\n  return storageFn;\n}","map":{"version":3,"names":["Raw","compactAddLength","compactStripLength","isUndefined","objectSpread","stringCamelCase","u8aConcat","u8aToU8a","xxhashAsU8a","getSiName","getHasher","NO_RAW_ARGS","args","hashers","keys","filterDefined","a","assertArgs","_ref","_ref2","method","section","Array","isArray","Error","concat","length","filter","join","createKeyRawParts","registry","itemFn","_ref3","count","extra","i","createTypeUnsafe","createLookupType","toU8a","prefix","createKeyInspect","meta","types","type","isMap","key","asMap","lookup","getSiType","def","asTuple","map","k","names","_","inner","v","name","outer","createKeyRaw","createKey","createStorageInspect","options","isPlain","skipHashing","_len","arguments","_key","createStorageFn","cacheKey","_len2","_key2","createWithMeta","storageFn","inspect","toJSON","storage","extendHeadMeta","_ref4","_ref5","iterFn","docs","fallback","modifier","fn","extendPrefixedMap","iterKey","_len3","_key3","keysVec","slice","createFunction","keyPrefix"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/metadata/decorate/storage/createFunction.js"],"sourcesContent":["import { Raw } from '@polkadot/types-codec';\nimport { compactAddLength, compactStripLength, isUndefined, objectSpread, stringCamelCase, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { xxhashAsU8a } from '@polkadot/util-crypto';\nimport { getSiName } from '../../util/index.js';\nimport { getHasher } from './getHasher.js';\nexport const NO_RAW_ARGS = {\n    args: [],\n    hashers: [],\n    keys: []\n};\n/** @internal */\nfunction filterDefined(a) {\n    return !isUndefined(a);\n}\n/** @internal */\nfunction assertArgs({ method, section }, { args, keys }) {\n    if (!Array.isArray(args)) {\n        throw new Error(`Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments`);\n    }\n    else if (args.filter(filterDefined).length !== keys.length) {\n        throw new Error(`Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments, found [${args.join(', ')}]`);\n    }\n}\n/** @internal */\nexport function createKeyRawParts(registry, itemFn, { args, hashers, keys }) {\n    const count = keys.length;\n    const extra = new Array(count);\n    for (let i = 0; i < count; i++) {\n        extra[i] = getHasher(hashers[i])(registry.createTypeUnsafe(registry.createLookupType(keys[i]), [args[i]]).toU8a());\n    }\n    return [\n        [\n            xxhashAsU8a(itemFn.prefix, 128),\n            xxhashAsU8a(itemFn.method, 128)\n        ],\n        extra\n    ];\n}\n/** @internal */\nexport function createKeyInspect(registry, itemFn, args) {\n    assertArgs(itemFn, args);\n    const { meta } = itemFn;\n    const [prefix, extra] = createKeyRawParts(registry, itemFn, args);\n    let types = [];\n    if (meta.type.isMap) {\n        const { hashers, key } = meta.type.asMap;\n        types = hashers.length === 1\n            ? [`${hashers[0].type}(${getSiName(registry.lookup, key)})`]\n            : registry.lookup.getSiType(key).def.asTuple.map((k, i) => `${hashers[i].type}(${getSiName(registry.lookup, k)})`);\n    }\n    const names = ['module', 'method'].concat(...args.args.map((_, i) => types[i]));\n    return {\n        inner: prefix\n            .concat(...extra)\n            .map((v, i) => ({ name: names[i], outer: [v] }))\n    };\n}\n/** @internal */\nexport function createKeyRaw(registry, itemFn, args) {\n    const [prefix, extra] = createKeyRawParts(registry, itemFn, args);\n    return u8aConcat(...prefix, ...extra);\n}\n/** @internal */\nfunction createKey(registry, itemFn, args) {\n    assertArgs(itemFn, args);\n    // always add the length prefix (underlying it is Bytes)\n    return compactAddLength(createKeyRaw(registry, itemFn, args));\n}\n/** @internal */\nfunction createStorageInspect(registry, itemFn, options) {\n    const { meta: { type } } = itemFn;\n    return (...args) => {\n        if (type.isPlain) {\n            return options.skipHashing\n                ? { inner: [], name: 'wellKnown', outer: [u8aToU8a(options.key)] }\n                : createKeyInspect(registry, itemFn, NO_RAW_ARGS);\n        }\n        const { hashers, key } = type.asMap;\n        return hashers.length === 1\n            ? createKeyInspect(registry, itemFn, { args, hashers, keys: [key] })\n            : createKeyInspect(registry, itemFn, { args, hashers, keys: registry.lookup.getSiType(key).def.asTuple });\n    };\n}\n/** @internal */\nfunction createStorageFn(registry, itemFn, options) {\n    const { meta: { type } } = itemFn;\n    let cacheKey = null;\n    // Can only have zero or one argument:\n    //   - storage.system.account(address)\n    //   - storage.timestamp.blockPeriod()\n    // For higher-map queries the params are passed in as an tuple, [key1, key2]\n    return (...args) => {\n        if (type.isPlain) {\n            if (!cacheKey) {\n                cacheKey = options.skipHashing\n                    ? compactAddLength(u8aToU8a(options.key))\n                    : createKey(registry, itemFn, NO_RAW_ARGS);\n            }\n            return cacheKey;\n        }\n        const { hashers, key } = type.asMap;\n        return hashers.length === 1\n            ? createKey(registry, itemFn, { args, hashers, keys: [key] })\n            : createKey(registry, itemFn, { args, hashers, keys: registry.lookup.getSiType(key).def.asTuple });\n    };\n}\n/** @internal */\nfunction createWithMeta(registry, itemFn, options) {\n    const { meta, method, prefix, section } = itemFn;\n    const storageFn = createStorageFn(registry, itemFn, options);\n    storageFn.inspect = createStorageInspect(registry, itemFn, options);\n    storageFn.meta = meta;\n    storageFn.method = stringCamelCase(method);\n    storageFn.prefix = prefix;\n    storageFn.section = section;\n    // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n    // instances (e.g. collective) will not work since it is only matched on param meta\n    storageFn.toJSON = () => objectSpread({ storage: { method, prefix, section } }, meta.toJSON());\n    return storageFn;\n}\n/** @internal */\nfunction extendHeadMeta(registry, { meta: { docs, name, type }, section }, { method }, iterFn) {\n    // metadata with a fallback value using the type of the key, the normal\n    // meta fallback only applies to actual entry values, create one for head\n    const meta = registry.createTypeUnsafe('StorageEntryMetadataLatest', [{\n            docs,\n            fallback: registry.createTypeUnsafe('Bytes', []),\n            modifier: registry.createTypeUnsafe('StorageEntryModifierLatest', [1]), // required\n            name,\n            type: registry.createTypeUnsafe('StorageEntryTypeLatest', [type.asMap.key, 0])\n        }]);\n    iterFn.meta = meta;\n    const fn = (...args) => registry.createTypeUnsafe('StorageKey', [iterFn(...args), { method, section }]);\n    fn.meta = meta;\n    return fn;\n}\n/** @internal */\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n    const { meta: { type }, method, section } = itemFn;\n    storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, (...args) => {\n        if (args.length && (type.isPlain || (args.length >= type.asMap.hashers.length))) {\n            throw new Error(`Iteration of ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs arguments to be at least one less than the full arguments, found [${args.join(', ')}]`);\n        }\n        if (args.length) {\n            if (type.isMap) {\n                const { hashers, key } = type.asMap;\n                const keysVec = hashers.length === 1\n                    ? [key]\n                    : registry.lookup.getSiType(key).def.asTuple;\n                return new Raw(registry, createKeyRaw(registry, itemFn, { args, hashers: hashers.slice(0, args.length), keys: keysVec.slice(0, args.length) }));\n            }\n        }\n        return new Raw(registry, createKeyRaw(registry, itemFn, NO_RAW_ARGS));\n    });\n    return storageFn;\n}\n/** @internal */\nexport function createFunction(registry, itemFn, options) {\n    const { meta: { type } } = itemFn;\n    const storageFn = createWithMeta(registry, itemFn, options);\n    if (type.isMap) {\n        extendPrefixedMap(registry, itemFn, storageFn);\n    }\n    storageFn.keyPrefix = (...args) => (storageFn.iterKey && storageFn.iterKey(...args)) ||\n        compactStripLength(storageFn())[1];\n    return storageFn;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}