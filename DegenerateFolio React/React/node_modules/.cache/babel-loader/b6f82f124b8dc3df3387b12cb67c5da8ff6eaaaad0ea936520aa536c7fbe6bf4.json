{"ast":null,"code":"import { number, exists, output } from './_assert.js';\nimport { Hash, toBytes, u32 } from './utils.js';\n// Blake is based on ChaCha permutation.\n// For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n// prettier-ignore\nexport const SIGMA = /* @__PURE__ */new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3]);\nexport class BLAKE2 extends Hash {\n  constructor(blockLen, outputLen) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let keyLen = arguments.length > 3 ? arguments[3] : undefined;\n    let saltLen = arguments.length > 4 ? arguments[4] : undefined;\n    let persLen = arguments.length > 5 ? arguments[5] : undefined;\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.length = 0;\n    this.pos = 0;\n    this.finished = false;\n    this.destroyed = false;\n    number(blockLen);\n    number(outputLen);\n    number(keyLen);\n    if (outputLen < 0 || outputLen > keyLen) throw new Error('outputLen bigger than keyLen');\n    if (opts.key !== undefined && (opts.key.length < 1 || opts.key.length > keyLen)) throw new Error(\"key must be up 1..\".concat(keyLen, \" byte long or undefined\"));\n    if (opts.salt !== undefined && opts.salt.length !== saltLen) throw new Error(\"salt must be \".concat(saltLen, \" byte long or undefined\"));\n    if (opts.personalization !== undefined && opts.personalization.length !== persLen) throw new Error(\"personalization must be \".concat(persLen, \" byte long or undefined\"));\n    this.buffer32 = u32(this.buffer = new Uint8Array(blockLen));\n  }\n  update(data) {\n    exists(this);\n    // Main difference with other hashes: there is flag for last block,\n    // so we cannot process current block before we know that there\n    // is the next one. This significantly complicates logic and reduces ability\n    // to do zero-copy processing\n    const {\n      blockLen,\n      buffer,\n      buffer32\n    } = this;\n    data = toBytes(data);\n    const len = data.length;\n    const offset = data.byteOffset;\n    const buf = data.buffer;\n    for (let pos = 0; pos < len;) {\n      // If buffer is full and we still have input (don't process last block, same as blake2s)\n      if (this.pos === blockLen) {\n        this.compress(buffer32, 0, false);\n        this.pos = 0;\n      }\n      const take = Math.min(blockLen - this.pos, len - pos);\n      const dataOffset = offset + pos;\n      // full block && aligned to 4 bytes && not last in input\n      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n          this.length += blockLen;\n          this.compress(data32, pos32, false);\n        }\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      this.length += take;\n      pos += take;\n    }\n    return this;\n  }\n  digestInto(out) {\n    exists(this);\n    output(out, this);\n    const {\n      pos,\n      buffer32\n    } = this;\n    this.finished = true;\n    // Padding\n    this.buffer.subarray(pos).fill(0);\n    this.compress(buffer32, 0, true);\n    const out32 = u32(out);\n    this.get().forEach((v, i) => out32[i] = v);\n  }\n  digest() {\n    const {\n      buffer,\n      outputLen\n    } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to) {\n    const {\n      buffer,\n      length,\n      finished,\n      destroyed,\n      outputLen,\n      pos\n    } = this;\n    to || (to = new this.constructor({\n      dkLen: outputLen\n    }));\n    to.set(...this.get());\n    to.length = length;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.outputLen = outputLen;\n    to.buffer.set(buffer);\n    to.pos = pos;\n    return to;\n  }\n}","map":{"version":3,"names":["number","exists","output","Hash","toBytes","u32","SIGMA","Uint8Array","BLAKE2","constructor","blockLen","outputLen","opts","arguments","length","undefined","keyLen","saltLen","persLen","pos","finished","destroyed","Error","key","concat","salt","personalization","buffer32","buffer","update","data","len","offset","byteOffset","buf","compress","take","Math","min","dataOffset","data32","Uint32Array","floor","pos32","set","subarray","digestInto","out","fill","out32","get","forEach","v","i","digest","res","slice","destroy","_cloneInto","to","dkLen"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@noble/hashes/src/_blake2.ts"],"sourcesContent":["import { number, exists, output } from './_assert.js';\nimport { Hash, Input, toBytes, u32 } from './utils.js';\n\n// Blake is based on ChaCha permutation.\n\n// For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n// prettier-ignore\nexport const SIGMA = /* @__PURE__ */ new Uint8Array([\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n]);\n\nexport type BlakeOpts = {\n  dkLen?: number;\n  key?: Input;\n  salt?: Input;\n  personalization?: Input;\n};\n\nexport abstract class BLAKE2<T extends BLAKE2<T>> extends Hash<T> {\n  protected abstract compress(msg: Uint32Array, offset: number, isLast: boolean): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected buffer: Uint8Array;\n  protected buffer32: Uint32Array;\n  protected length: number = 0;\n  protected pos: number = 0;\n  protected finished = false;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    opts: BlakeOpts = {},\n    keyLen: number,\n    saltLen: number,\n    persLen: number\n  ) {\n    super();\n    number(blockLen);\n    number(outputLen);\n    number(keyLen);\n    if (outputLen < 0 || outputLen > keyLen) throw new Error('outputLen bigger than keyLen');\n    if (opts.key !== undefined && (opts.key.length < 1 || opts.key.length > keyLen))\n      throw new Error(`key must be up 1..${keyLen} byte long or undefined`);\n    if (opts.salt !== undefined && opts.salt.length !== saltLen)\n      throw new Error(`salt must be ${saltLen} byte long or undefined`);\n    if (opts.personalization !== undefined && opts.personalization.length !== persLen)\n      throw new Error(`personalization must be ${persLen} byte long or undefined`);\n    this.buffer32 = u32((this.buffer = new Uint8Array(blockLen)));\n  }\n  update(data: Input) {\n    exists(this);\n    // Main difference with other hashes: there is flag for last block,\n    // so we cannot process current block before we know that there\n    // is the next one. This significantly complicates logic and reduces ability\n    // to do zero-copy processing\n    const { blockLen, buffer, buffer32 } = this;\n    data = toBytes(data);\n    const len = data.length;\n    const offset = data.byteOffset;\n    const buf = data.buffer;\n    for (let pos = 0; pos < len; ) {\n      // If buffer is full and we still have input (don't process last block, same as blake2s)\n      if (this.pos === blockLen) {\n        this.compress(buffer32, 0, false);\n        this.pos = 0;\n      }\n      const take = Math.min(blockLen - this.pos, len - pos);\n      const dataOffset = offset + pos;\n      // full block && aligned to 4 bytes && not last in input\n      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n          this.length += blockLen;\n          this.compress(data32, pos32, false);\n        }\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      this.length += take;\n      pos += take;\n    }\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    exists(this);\n    output(out, this);\n    const { pos, buffer32 } = this;\n    this.finished = true;\n    // Padding\n    this.buffer.subarray(pos).fill(0);\n    this.compress(buffer32, 0, true);\n    const out32 = u32(out);\n    this.get().forEach((v, i) => (out32[i] = v));\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    const { buffer, length, finished, destroyed, outputLen, pos } = this;\n    to ||= new (this.constructor as any)({ dkLen: outputLen }) as T;\n    to.set(...this.get());\n    to.length = length;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.outputLen = outputLen;\n    to.buffer.set(buffer);\n    to.pos = pos;\n    return to;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}