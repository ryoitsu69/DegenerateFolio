{"ast":null,"code":"import { bnToBn } from '@polkadot/util';\nimport { typesChain } from './chain/index.js';\nimport { typesSpec } from './spec/index.js';\nimport { upgrades } from './upgrades/index.js';\n/**\n * @description Perform the callback function using the stringified spec/chain\n * @internal\n * */\nfunction withNames(chainName, specName, fn) {\n  return fn(chainName.toString(), specName.toString());\n}\n/**\n * @descriptionFflatten a VersionedType[] into a Record<string, string>\n * @internal\n * */\nfunction filterVersions(versions = [], specVersion) {\n  return versions.filter(({\n    minmax: [min, max]\n  }) => (min === undefined || min === null || specVersion >= min) && (max === undefined || max === null || specVersion <= max)).reduce((result, {\n    types\n  }) => ({\n    ...result,\n    ...types\n  }), {});\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable signed extensions (ready for registration)\n */\nexport function getSpecExtensions({\n  knownTypes\n}, chainName, specName) {\n  return withNames(chainName, specName, (c, s) => ({\n    ...(knownTypes.typesBundle?.spec?.[s]?.signedExtensions ?? {}),\n    ...(knownTypes.typesBundle?.chain?.[c]?.signedExtensions ?? {})\n  }));\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable types (ready for registration)\n */\nexport function getSpecTypes({\n  knownTypes\n}, chainName, specName, specVersion) {\n  const _specVersion = bnToBn(specVersion).toNumber();\n  return withNames(chainName, specName, (c, s) => ({\n    // The order here is always, based on -\n    //   - spec then chain\n    //   - typesBundle takes higher precedence\n    //   - types is the final catch-all override\n    ...filterVersions(typesSpec[s], _specVersion),\n    ...filterVersions(typesChain[c], _specVersion),\n    ...filterVersions(knownTypes.typesBundle?.spec?.[s]?.types, _specVersion),\n    ...filterVersions(knownTypes.typesBundle?.chain?.[c]?.types, _specVersion),\n    ...(knownTypes.typesSpec?.[s] ?? {}),\n    ...(knownTypes.typesChain?.[c] ?? {}),\n    ...(knownTypes.types ?? {})\n  }));\n}\n/**\n * @description Based on the chain or spec, return the hasher used\n */\nexport function getSpecHasher({\n  knownTypes\n}, chainName, specName) {\n  return withNames(chainName, specName, (c, s) => knownTypes.hasher || knownTypes.typesBundle?.chain?.[c]?.hasher || knownTypes.typesBundle?.spec?.[s]?.hasher || null);\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable rpc definitions (ready for registration)\n */\nexport function getSpecRpc({\n  knownTypes\n}, chainName, specName) {\n  return withNames(chainName, specName, (c, s) => ({\n    ...(knownTypes.typesBundle?.spec?.[s]?.rpc ?? {}),\n    ...(knownTypes.typesBundle?.chain?.[c]?.rpc ?? {})\n  }));\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable runtime definitions (ready for registration)\n */\nexport function getSpecRuntime({\n  knownTypes\n}, chainName, specName) {\n  return withNames(chainName, specName, (c, s) => ({\n    ...(knownTypes.typesBundle?.spec?.[s]?.runtime ?? {}),\n    ...(knownTypes.typesBundle?.chain?.[c]?.runtime ?? {})\n  }));\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable alias definitions (ready for registration)\n */\nexport function getSpecAlias({\n  knownTypes\n}, chainName, specName) {\n  return withNames(chainName, specName, (c, s) => ({\n    // as per versions, first spec, then chain then finally non-versioned\n    ...(knownTypes.typesBundle?.spec?.[s]?.alias ?? {}),\n    ...(knownTypes.typesBundle?.chain?.[c]?.alias ?? {}),\n    ...(knownTypes.typesAlias ?? {})\n  }));\n}\n/**\n * @description Returns a version record for known chains where upgrades are being tracked\n */\nexport function getUpgradeVersion(genesisHash, blockNumber) {\n  const known = upgrades.find(u => genesisHash.eq(u.genesisHash));\n  return known ? [known.versions.reduce((last, version) => {\n    return blockNumber.gt(version.blockNumber) ? version : last;\n  }, undefined), known.versions.find(version => blockNumber.lte(version.blockNumber))] : [undefined, undefined];\n}","map":{"version":3,"names":["bnToBn","typesChain","typesSpec","upgrades","withNames","chainName","specName","fn","toString","filterVersions","versions","specVersion","filter","minmax","min","max","undefined","reduce","result","types","getSpecExtensions","knownTypes","c","s","typesBundle","spec","signedExtensions","chain","getSpecTypes","_specVersion","toNumber","getSpecHasher","hasher","getSpecRpc","rpc","getSpecRuntime","runtime","getSpecAlias","alias","typesAlias","getUpgradeVersion","genesisHash","blockNumber","known","find","u","eq","last","version","gt","lte"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-known/util.js"],"sourcesContent":["import { bnToBn } from '@polkadot/util';\nimport { typesChain } from './chain/index.js';\nimport { typesSpec } from './spec/index.js';\nimport { upgrades } from './upgrades/index.js';\n/**\n * @description Perform the callback function using the stringified spec/chain\n * @internal\n * */\nfunction withNames(chainName, specName, fn) {\n    return fn(chainName.toString(), specName.toString());\n}\n/**\n * @descriptionFflatten a VersionedType[] into a Record<string, string>\n * @internal\n * */\nfunction filterVersions(versions = [], specVersion) {\n    return versions\n        .filter(({ minmax: [min, max] }) => (min === undefined || min === null || specVersion >= min) &&\n        (max === undefined || max === null || specVersion <= max))\n        .reduce((result, { types }) => ({ ...result, ...types }), {});\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable signed extensions (ready for registration)\n */\nexport function getSpecExtensions({ knownTypes }, chainName, specName) {\n    return withNames(chainName, specName, (c, s) => ({\n        ...(knownTypes.typesBundle?.spec?.[s]?.signedExtensions ?? {}),\n        ...(knownTypes.typesBundle?.chain?.[c]?.signedExtensions ?? {})\n    }));\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable types (ready for registration)\n */\nexport function getSpecTypes({ knownTypes }, chainName, specName, specVersion) {\n    const _specVersion = bnToBn(specVersion).toNumber();\n    return withNames(chainName, specName, (c, s) => ({\n        // The order here is always, based on -\n        //   - spec then chain\n        //   - typesBundle takes higher precedence\n        //   - types is the final catch-all override\n        ...filterVersions(typesSpec[s], _specVersion),\n        ...filterVersions(typesChain[c], _specVersion),\n        ...filterVersions(knownTypes.typesBundle?.spec?.[s]?.types, _specVersion),\n        ...filterVersions(knownTypes.typesBundle?.chain?.[c]?.types, _specVersion),\n        ...(knownTypes.typesSpec?.[s] ?? {}),\n        ...(knownTypes.typesChain?.[c] ?? {}),\n        ...(knownTypes.types ?? {})\n    }));\n}\n/**\n * @description Based on the chain or spec, return the hasher used\n */\nexport function getSpecHasher({ knownTypes }, chainName, specName) {\n    return withNames(chainName, specName, (c, s) => knownTypes.hasher ||\n        knownTypes.typesBundle?.chain?.[c]?.hasher ||\n        knownTypes.typesBundle?.spec?.[s]?.hasher ||\n        null);\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable rpc definitions (ready for registration)\n */\nexport function getSpecRpc({ knownTypes }, chainName, specName) {\n    return withNames(chainName, specName, (c, s) => ({\n        ...(knownTypes.typesBundle?.spec?.[s]?.rpc ?? {}),\n        ...(knownTypes.typesBundle?.chain?.[c]?.rpc ?? {})\n    }));\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable runtime definitions (ready for registration)\n */\nexport function getSpecRuntime({ knownTypes }, chainName, specName) {\n    return withNames(chainName, specName, (c, s) => ({\n        ...(knownTypes.typesBundle?.spec?.[s]?.runtime ?? {}),\n        ...(knownTypes.typesBundle?.chain?.[c]?.runtime ?? {})\n    }));\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable alias definitions (ready for registration)\n */\nexport function getSpecAlias({ knownTypes }, chainName, specName) {\n    return withNames(chainName, specName, (c, s) => ({\n        // as per versions, first spec, then chain then finally non-versioned\n        ...(knownTypes.typesBundle?.spec?.[s]?.alias ?? {}),\n        ...(knownTypes.typesBundle?.chain?.[c]?.alias ?? {}),\n        ...(knownTypes.typesAlias ?? {})\n    }));\n}\n/**\n * @description Returns a version record for known chains where upgrades are being tracked\n */\nexport function getUpgradeVersion(genesisHash, blockNumber) {\n    const known = upgrades.find((u) => genesisHash.eq(u.genesisHash));\n    return known\n        ? [\n            known.versions.reduce((last, version) => {\n                return blockNumber.gt(version.blockNumber)\n                    ? version\n                    : last;\n            }, undefined),\n            known.versions.find((version) => blockNumber.lte(version.blockNumber))\n        ]\n        : [undefined, undefined];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}