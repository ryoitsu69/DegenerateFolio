{"ast":null,"code":"class MeshBatchUvs {\n  /**\n   * @param uvBuffer - Buffer with normalized uv's\n   * @param uvMatrix - Material UV matrix\n   */\n  constructor(uvBuffer, uvMatrix) {\n    this.uvBuffer = uvBuffer, this.uvMatrix = uvMatrix, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;\n  }\n  /**\n   * Updates\n   * @param forceUpdate - force the update\n   */\n  update(forceUpdate) {\n    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) return;\n    this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;\n    const data = this.uvBuffer.data;\n    (!this.data || this.data.length !== data.length) && (this.data = new Float32Array(data.length)), this.uvMatrix.multiplyUvs(data, this.data), this._updateID++;\n  }\n}\nexport { MeshBatchUvs };","map":{"version":3,"names":["MeshBatchUvs","constructor","uvBuffer","uvMatrix","data","_bufferUpdateId","_textureUpdateId","_updateID","update","forceUpdate","length","Float32Array","multiplyUvs"],"sources":["/home/ryoitsu/node_modules/@pixi/mesh/src/MeshBatchUvs.ts"],"sourcesContent":["import type { Buffer, TextureMatrix } from '@pixi/core';\n\n/**\n * Class controls cache for UV mapping from Texture normal space to BaseTexture normal space.\n * @memberof PIXI\n */\nexport class MeshBatchUvs\n{\n    /** UV Buffer data. */\n    public readonly data: Float32Array;\n\n    /** Buffer with normalized UV's. */\n    public uvBuffer: Buffer;\n\n    /** Material UV matrix. */\n    public uvMatrix: TextureMatrix;\n\n    private _bufferUpdateId: number;\n    private _textureUpdateId: number;\n\n    // Internal-only properties\n    _updateID: number;\n\n    /**\n     * @param uvBuffer - Buffer with normalized uv's\n     * @param uvMatrix - Material UV matrix\n     */\n    constructor(uvBuffer: Buffer, uvMatrix: TextureMatrix)\n    {\n        this.uvBuffer = uvBuffer;\n        this.uvMatrix = uvMatrix;\n        this.data = null;\n\n        this._bufferUpdateId = -1;\n        this._textureUpdateId = -1;\n        this._updateID = 0;\n    }\n\n    /**\n     * Updates\n     * @param forceUpdate - force the update\n     */\n    public update(forceUpdate?: boolean): void\n    {\n        if (!forceUpdate\n            && this._bufferUpdateId === this.uvBuffer._updateID\n            && this._textureUpdateId === this.uvMatrix._updateID\n        )\n        {\n            return;\n        }\n\n        this._bufferUpdateId = this.uvBuffer._updateID;\n        this._textureUpdateId = this.uvMatrix._updateID;\n\n        const data = this.uvBuffer.data as Float32Array;\n\n        if (!this.data || this.data.length !== data.length)\n        {\n            (this.data as any) = new Float32Array(data.length);\n        }\n\n        this.uvMatrix.multiplyUvs(data, this.data);\n\n        this._updateID++;\n    }\n}\n"],"mappings":"AAMO,MAAMA,YAAA,CACb;EAAA;AAAA;AAAA;AAAA;EAoBIC,YAAYC,QAAA,EAAkBC,QAAA,EAC9B;IACI,KAAKD,QAAA,GAAWA,QAAA,EAChB,KAAKC,QAAA,GAAWA,QAAA,EAChB,KAAKC,IAAA,GAAO,MAEZ,KAAKC,eAAA,GAAkB,IACvB,KAAKC,gBAAA,GAAmB,IACxB,KAAKC,SAAA,GAAY;EACrB;EAAA;AAAA;AAAA;AAAA;EAMOC,OAAOC,WAAA,EACd;IACQ,KAACA,WAAA,IACE,KAAKJ,eAAA,KAAoB,KAAKH,QAAA,CAASK,SAAA,IACvC,KAAKD,gBAAA,KAAqB,KAAKH,QAAA,CAASI,SAAA,EAG3C;IAGJ,KAAKF,eAAA,GAAkB,KAAKH,QAAA,CAASK,SAAA,EACrC,KAAKD,gBAAA,GAAmB,KAAKH,QAAA,CAASI,SAAA;IAEhC,MAAAH,IAAA,GAAO,KAAKF,QAAA,CAASE,IAAA;IAEvB,EAAC,KAAKA,IAAA,IAAQ,KAAKA,IAAA,CAAKM,MAAA,KAAWN,IAAA,CAAKM,MAAA,MAEvC,KAAKN,IAAA,GAAe,IAAIO,YAAA,CAAaP,IAAA,CAAKM,MAAM,IAGrD,KAAKP,QAAA,CAASS,WAAA,CAAYR,IAAA,EAAM,KAAKA,IAAI,GAEzC,KAAKG,SAAA;EACT;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}