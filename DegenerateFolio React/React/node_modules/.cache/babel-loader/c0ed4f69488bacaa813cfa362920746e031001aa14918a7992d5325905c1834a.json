{"ast":null,"code":"import { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Filter } from '../../Filter.mjs';\nimport vertex from '../defaultFilter.vert.mjs';\nimport fragment from './alpha.frag.mjs';\nimport source from './alpha.wgsl.mjs';\n\"use strict\";\nconst _AlphaFilter = class _AlphaFilter extends Filter {\n  constructor(options) {\n    options = {\n      ..._AlphaFilter.defaultOptions,\n      ...options\n    };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"alpha-filter\"\n    });\n    const {\n      alpha,\n      ...rest\n    } = options;\n    const alphaUniforms = new UniformGroup({\n      uAlpha: {\n        value: alpha,\n        type: \"f32\"\n      }\n    });\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      resources: {\n        alphaUniforms\n      }\n    });\n  }\n  /**\n   * Coefficient for alpha multiplication\n   * @default 1\n   */\n  get alpha() {\n    return this.resources.alphaUniforms.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.resources.alphaUniforms.uniforms.uAlpha = value;\n  }\n};\n/** Default filter options */\n_AlphaFilter.defaultOptions = {\n  /** Amount of alpha from 0 to 1, where 0 is transparent */\n  alpha: 1\n};\nlet AlphaFilter = _AlphaFilter;\nexport { AlphaFilter };","map":{"version":3,"names":["_AlphaFilter","Filter","constructor","options","defaultOptions","gpuProgram","GpuProgram","from","vertex","source","entryPoint","fragment","glProgram","GlProgram","name","alpha","rest","alphaUniforms","UniformGroup","uAlpha","value","type","resources","uniforms","AlphaFilter"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/filters/defaults/alpha/AlphaFilter.ts"],"sourcesContent":["import { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Filter } from '../../Filter';\nimport vertex from '../defaultFilter.vert';\nimport fragment from './alpha.frag';\nimport source from './alpha.wgsl';\n\nimport type { FilterOptions } from '../../Filter';\n\n/**\n * Options for AlphaFilter\n * @memberof filters\n */\nexport interface AlphaFilterOptions extends FilterOptions\n{\n    /**\n     * Amount of alpha from 0 to 1, where 0 is transparent\n     * @default 1\n     */\n    alpha: number;\n}\n\n/**\n * Simplest filter - applies alpha.\n *\n * Use this instead of Container's alpha property to avoid visual layering of individual elements.\n * AlphaFilter applies alpha evenly across the entire display object and any opaque elements it contains.\n * If elements are not opaque, they will blend with each other anyway.\n *\n * Very handy if you want to use common features of all filters:\n *\n * 1. Assign a blendMode to this filter, blend all elements inside display object with background.\n *\n * 2. To use clipping in display coordinates, assign a filterArea to the same container that has this filter.\n * @memberof filters\n */\nexport class AlphaFilter extends Filter\n{\n    /** Default filter options */\n    public static readonly defaultOptions: AlphaFilterOptions = {\n        /** Amount of alpha from 0 to 1, where 0 is transparent */\n        alpha: 1,\n    };\n\n    constructor(options?: AlphaFilterOptions)\n    {\n        options = { ...AlphaFilter.defaultOptions, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'alpha-filter'\n        });\n\n        const { alpha, ...rest } = options;\n\n        const alphaUniforms = new UniformGroup({\n            uAlpha: { value: alpha, type: 'f32' },\n        });\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            resources: {\n                alphaUniforms\n            },\n        });\n    }\n\n    /**\n     * Coefficient for alpha multiplication\n     * @default 1\n     */\n    get alpha(): number { return this.resources.alphaUniforms.uniforms.uAlpha; }\n    set alpha(value: number) { this.resources.alphaUniforms.uniforms.uAlpha = value; }\n}\n"],"mappings":";;;;;;;;AAqCO,MAAMA,YAAA,GAAN,MAAMA,YAAA,SAAoBC,MACjC;EAOIC,YAAYC,OACZ;IACIA,OAAA,GAAU;MAAE,GAAGH,YAAY,CAAAI,cAAA;MAAgB,GAAGD;IAAQ;IAEhD,MAAAE,UAAA,GAAaC,UAAA,CAAWC,IAAK;MAC/BC,MAAQ;QACJC,MAAA;QACAC,UAAY;MAAA,CAChB;MACAC,QAAU;QACNF,MAAA;QACAC,UAAY;MAAA;IAChB,CACH;IAEK,MAAAE,SAAA,GAAYC,SAAA,CAAUN,IAAK;MAC7BC,MAAA;MACAG,QAAA;MACAG,IAAM;IAAA,CACT;IAED,MAAM;MAAEC,KAAA;MAAO,GAAGC;IAAA,CAAS,GAAAb,OAAA;IAErB,MAAAc,aAAA,GAAgB,IAAIC,YAAa;MACnCC,MAAQ;QAAEC,KAAO,EAAAL,KAAA;QAAOM,IAAA,EAAM;MAAM;IAAA,CACvC;IAEK;MACF,GAAGL,IAAA;MACHX,UAAA;MACAO,SAAA;MACAU,SAAW;QACPL;MAAA;IACJ,CACH;EAAA;EACL;AAAA;AAAA;AAAA;EAMA,IAAIF,KAAgBA,CAAA;IAAS,YAAKO,SAAU,CAAAL,aAAA,CAAcM,QAAS,CAAAJ,MAAA;EAAA;EACnE,IAAIJ,MAAMK,KAAe;IAAO,KAAAE,SAAA,CAAUL,aAAc,CAAAM,QAAA,CAASJ,MAAS,GAAAC,KAAA;EAAA;AAC9E;AAAA;AAnDapB,YAAA,CAGcI,cAAqC;EAAA;EAExDW,KAAO;AACX;AANG,IAAMS,WAAN,GAAAxB,YAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}