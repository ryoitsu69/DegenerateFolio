{"ast":null,"code":"import _defineProperty from \"/home/ryoitsu/Documents/test/react-todo-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { sanitize, Struct } from '@polkadot/types-codec';\nimport { getTypeDef, TypeDefInfo, withTypeString } from '@polkadot/types-create';\nimport { assertUnreachable, isNumber, isString, logger, objectSpread, stringCamelCase, stringify, stringPascalCase } from '@polkadot/util';\nconst l = logger('PortableRegistry');\nconst TYPE_UNWRAP = {\n  toNumber: () => -1\n};\nconst PRIMITIVE_ALIAS = {\n  Char: 'u32',\n  // Rust char is 4-bytes\n  Str: 'Text'\n};\nconst PATHS_ALIAS = splitNamespace([\n// full matching on exact names...\n// these are well-known types with additional encoding\n'sp_core::crypto::AccountId32', 'sp_runtime::generic::era::Era', 'sp_runtime::multiaddress::MultiAddress',\n// ethereum overrides (Frontier, Moonbeam, Polkadot claims)\n'fp_account::AccountId20', 'account::AccountId20', 'polkadot_runtime_common::claims::EthereumAddress',\n// weights 2 is a structure, however for 1.5. with a single field it\n// should be flatenned (can appear in Compact<Weight> extrinsics)\n'frame_support::weights::weight_v2::Weight', 'sp_weights::weight_v2::Weight',\n// wildcard matching in place...\n// these have a specific encoding or logic, use a wildcard for {pallet, darwinia}_democracy\n'*_democracy::vote::Vote', '*_conviction_voting::vote::Vote', '*_identity::types::Data',\n// these are opaque Vec<u8> wrappers\n'sp_core::OpaqueMetadata', 'sp_core::OpaquePeerId', 'sp_core::offchain::OpaqueMultiaddr',\n// shorten some well-known types\n'primitive_types::*', 'sp_arithmetic::per_things::*',\n// runtime\n'*_runtime::RuntimeCall', '*_runtime::RuntimeEvent',\n// ink!\n'ink::env::types::*', 'ink::primitives::types::*', 'ink_env::types::*', 'ink_primitives::types::*',\n// noir\n'np_runtime::accountname::AccountName', 'np_runtime::universaladdress::UniversalAddress']);\nconst PATHS_SET = splitNamespace(['pallet_identity::types::BitFlags']);\nconst BITVEC_NS_LSB = ['bitvec::order::Lsb0', 'BitOrderLsb0'];\nconst BITVEC_NS_MSB = ['bitvec::order::Msb0', 'BitOrderMsb0'];\nconst BITVEC_NS = [...BITVEC_NS_LSB, ...BITVEC_NS_MSB];\nconst WRAPPERS = ['BoundedBTreeMap', 'BoundedBTreeSet', 'BoundedVec', 'Box', 'BTreeMap', 'BTreeSet', 'Cow', 'Option', 'Range', 'RangeInclusive', 'Result', 'WeakBoundedVec', 'WrapperKeepOpaque', 'WrapperOpaque'];\nconst RESERVED = [\n// JS reserved words\n'entries', 'keys', 'new', 'size',\n// exposed by all Codec objects\n'hash', 'registry'];\nconst PATH_RM_INDEX_1 = ['generic', 'misc', 'pallet', 'traits', 'types'];\n/** @internal Converts a Text[] into string[] (used as part of definitions) */\nfunction sanitizeDocs(docs) {\n  const count = docs.length;\n  const result = new Array(count);\n  for (let i = 0; i < count; i++) {\n    result[i] = docs[i].toString();\n  }\n  return result;\n}\n/** @internal Split a namespace with :: into individual parts */\nfunction splitNamespace(values) {\n  const count = values.length;\n  const result = new Array(count);\n  for (let i = 0; i < count; i++) {\n    result[i] = values[i].split('::');\n  }\n  return result;\n}\n/** @internal Match a namespace based on parts (alongside wildcards) */\nfunction matchParts(first, second) {\n  return first.length === second.length && first.every((a, index) => {\n    const b = second[index].toString();\n    if (a === '*' || a === b) {\n      return true;\n    }\n    if (a.includes('*') && a.includes('_') && b.includes('_')) {\n      let suba = a.split('_');\n      let subb = b.split('_');\n      // match initial *'s to multiples if we have a match for the other\n      if (suba[0] === '*') {\n        const indexOf = subb.indexOf(suba[1]);\n        if (indexOf !== -1) {\n          suba = suba.slice(1);\n          subb = subb.slice(indexOf);\n        }\n      }\n      // check for * matches at the end, adjust accordingly\n      if (suba.length === 2 && suba[1] === '*' && suba[0] === subb[0]) {\n        return true;\n      }\n      return matchParts(suba, subb);\n    }\n    return false;\n  });\n}\n/** @internal check if the path matches the PATHS_ALIAS (with wildcards) */\nfunction getAliasPath(_ref) {\n  let {\n    def,\n    path\n  } = _ref;\n  // specific logic for weights - we override when non-complex struct\n  // (as applied in Weight 1.5 where we also have `Compact<{ refTime: u64 }>)\n  if (['frame_support::weights::weight_v2::Weight', 'sp_weights::weight_v2::Weight'].includes(path.join('::'))) {\n    return !def.isComposite || def.asComposite.fields.length === 1 ? 'WeightV1' : null;\n  }\n  // TODO We need to handle ink! Balance in some way\n  return path.length && PATHS_ALIAS.some(a => matchParts(a, path)) ? path[path.length - 1].toString() : null;\n}\n/** @internal Converts a type name into a JS-API compatible name */\nfunction extractNameFlat(portable, lookupIndex, params, path) {\n  let isInternal = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  const count = path.length;\n  // if we have no path or determined as a wrapper, we just skip it\n  if (count === 0 || WRAPPERS.includes(path[count - 1].toString())) {\n    return null;\n  }\n  const camels = new Array(count);\n  const lowers = new Array(count);\n  // initially just create arrays of the camelCase and lowercase path\n  // parts - we will check these to extract the final values. While\n  // we have 2 loops here, we also don't do the same operation twice\n  for (let i = 0; i < count; i++) {\n    const c = stringPascalCase(isInternal ? path[i].replace('pallet_', '') : path[i]);\n    const l = c.toLowerCase();\n    camels[i] = c;\n    lowers[i] = l;\n  }\n  let name = '';\n  for (let i = 0; i < count; i++) {\n    const l = lowers[i];\n    // Remove ::{generic, misc, pallet, traits, types}::\n    if (i !== 1 || !PATH_RM_INDEX_1.includes(l)) {\n      // sp_runtime::generic::digest::Digest -> sp_runtime::generic::Digest\n      // sp_runtime::multiaddress::MultiAddress -> sp_runtime::MultiAddress\n      if (l !== lowers[i + 1]) {\n        name += camels[i];\n      }\n    }\n  }\n  // do magic for RawOrigin lookup, e.g. pallet_collective::RawOrigin\n  if (camels[1] === 'RawOrigin' && count === 2 && params.length === 2 && params[1].type.isSome) {\n    const instanceType = portable[params[1].type.unwrap().toNumber()];\n    if (instanceType.type.path.length === 2) {\n      name = \"\".concat(name).concat(instanceType.type.path[1].toString());\n    }\n  }\n  return {\n    lookupIndex,\n    name,\n    params\n  };\n}\n/** @internal Alias for extractNameFlat with PortableType as a last parameter */\nfunction extractName(portable, lookupIndex, _ref2) {\n  let {\n    type: {\n      params,\n      path\n    }\n  } = _ref2;\n  return extractNameFlat(portable, lookupIndex, params, path);\n}\n/** @internal Check for dupes from a specific index onwards */\nfunction nextDupeMatches(name, startAt, names) {\n  const result = [names[startAt]];\n  for (let i = startAt + 1, count = names.length; i < count; i++) {\n    const v = names[i];\n    if (v.name === name) {\n      result.push(v);\n    }\n  }\n  return result;\n}\n/** @internal Checks to see if a type is a full duplicate (with all params matching) */\nfunction rewriteDupes(input, rewrite) {\n  const count = input.length;\n  for (let i = 0; i < count; i++) {\n    const a = input[i];\n    for (let j = i + 1; j < count; j++) {\n      const b = input[j];\n      // if the indexes are not the same and the names match, we have a dupe\n      if (a.lookupIndex !== b.lookupIndex && a.name === b.name) {\n        return false;\n      }\n    }\n  }\n  // add all the adjusted values to the rewite map\n  for (let i = 0; i < count; i++) {\n    const p = input[i];\n    rewrite[p.lookupIndex] = p.name;\n  }\n  return true;\n}\n/** @internal Find duplicates and adjust the names based on parameters */\nfunction removeDupeNames(lookup, portable, names) {\n  const rewrite = {};\n  return names.map((original, startAt) => {\n    const {\n      lookupIndex,\n      name,\n      params\n    } = original;\n    if (!name) {\n      // the name is empty (this is not expected, but have a failsafe)\n      return null;\n    } else if (rewrite[lookupIndex]) {\n      // we have already rewritten this one, we can skip it\n      return original;\n    }\n    // those where the name is matching starting from this index\n    const allSame = nextDupeMatches(name, startAt, names);\n    // we only have one, so all ok\n    if (allSame.length === 1) {\n      return original;\n    }\n    // are there param differences between matching names\n    const anyDiff = allSame.some(o => params.length !== o.params.length || params.some((p, index) => !p.name.eq(o.params[index].name) || p.type.unwrapOr(TYPE_UNWRAP).toNumber() !== o.params[index].type.unwrapOr(TYPE_UNWRAP).toNumber()));\n    // everything matches, we can combine these\n    if (!anyDiff) {\n      return original;\n    }\n    // TODO We probably want to attach all the indexes with differences,\n    // not just the first\n    // find the first parameter that yields differences\n    const paramIdx = params.findIndex((_ref3, index) => {\n      let {\n        type\n      } = _ref3;\n      return allSame.every((_ref4, aIndex) => {\n        let {\n          params\n        } = _ref4;\n        return params[index].type.isSome && (aIndex === 0 || !params[index].type.eq(type));\n      });\n    });\n    // No param found that is different\n    if (paramIdx === -1) {\n      return original;\n    }\n    // see if using the param type helps\n    const sameCount = allSame.length;\n    const adjusted = new Array(sameCount);\n    // loop through all, specifically checking that index where the\n    // first param yields differences\n    for (let i = 0; i < sameCount; i++) {\n      const {\n        lookupIndex,\n        name,\n        params\n      } = allSame[i];\n      const {\n        def,\n        path\n      } = lookup.getSiType(params[paramIdx].type.unwrap());\n      // if it is not a primitive and it doesn't have a path, we really cannot\n      // do anything at this point\n      if (!def.isPrimitive && !path.length) {\n        return null;\n      }\n      adjusted[i] = {\n        lookupIndex,\n        name: def.isPrimitive ? \"\".concat(name).concat(def.asPrimitive.toString()) : \"\".concat(name).concat(path[path.length - 1].toString())\n      };\n    }\n    // check to see if the adjusted names have no issues\n    if (rewriteDupes(adjusted, rewrite)) {\n      return original;\n    }\n    // TODO This is duplicated from the section just above...\n    // ... we certainly need a better solution here\n    //\n    // Last-ditch effort to use the full type path - ugly\n    // loop through all, specifically checking that index where the\n    // first param yields differences\n    for (let i = 0; i < sameCount; i++) {\n      const {\n        lookupIndex,\n        name,\n        params\n      } = allSame[i];\n      const {\n        def,\n        path\n      } = lookup.getSiType(params[paramIdx].type.unwrap());\n      const flat = extractNameFlat(portable, lookupIndex, params, path, true);\n      if (def.isPrimitive || !flat) {\n        return null;\n      }\n      adjusted[i] = {\n        lookupIndex,\n        name: \"\".concat(name).concat(flat.name)\n      };\n    }\n    // check to see if the adjusted names have no issues\n    if (rewriteDupes(adjusted, rewrite)) {\n      return original;\n    }\n    return null;\n  }).filter(n => !!n).map(_ref5 => {\n    let {\n      lookupIndex,\n      name,\n      params\n    } = _ref5;\n    return {\n      lookupIndex,\n      name: rewrite[lookupIndex] || name,\n      params\n    };\n  });\n}\n/** @internal Detect on-chain types (AccountId/Signature) as set as the default */\nfunction registerTypes(lookup, lookups, names, params) {\n  // Register the types we extracted\n  lookup.registry.register(lookups);\n  // Try and extract the AccountId/Address/Signature type from UncheckedExtrinsic\n  if (params.SpRuntimeUncheckedExtrinsic) {\n    // Address, Call, Signature, Extra\n    const [addrParam,, sigParam] = params.SpRuntimeUncheckedExtrinsic;\n    const siAddress = lookup.getSiType(addrParam.type.unwrap());\n    const siSignature = lookup.getSiType(sigParam.type.unwrap());\n    const nsSignature = siSignature.path.join('::');\n    let nsAccountId = siAddress.path.join('::');\n    const isMultiAddress = nsAccountId === 'sp_runtime::multiaddress::MultiAddress';\n    // With multiaddress, we check the first type param again\n    if (isMultiAddress) {\n      // AccountId, AccountIndex\n      const [idParam] = siAddress.params;\n      nsAccountId = lookup.getSiType(idParam.type.unwrap()).path.join('::');\n    }\n    lookup.registry.register({\n      // known: account::AccountId20, fp_account::AccountId20, primitive_types::H160\n      AccountId: nsAccountId.endsWith('::AccountId20') || nsAccountId.endsWith('::H160') ? 'AccountId20' : 'AccountId32',\n      Address: isMultiAddress ? 'MultiAddress' : 'AccountId',\n      ExtrinsicSignature: ['sp_runtime::MultiSignature'].includes(nsSignature) ? 'MultiSignature' : names[sigParam.type.unwrap().toNumber()] || 'MultiSignature'\n    });\n  }\n}\n/**\n * @internal Extracts aliases based on what we know the runtime config looks like in a\n * Substrate chain. Specifically we want to have access to the Call and Event params\n **/\nfunction extractAliases(params, isContract) {\n  const hasParams = Object.keys(params).some(k => !k.startsWith('Pallet'));\n  const alias = {};\n  if (params.SpRuntimeUncheckedExtrinsic) {\n    // Address, Call, Signature, Extra\n    const [, {\n      type\n    }] = params.SpRuntimeUncheckedExtrinsic;\n    alias[type.unwrap().toNumber()] = 'Call';\n  } else if (hasParams && !isContract) {\n    l.warn('Unable to determine runtime Call type, cannot inspect sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic');\n  }\n  if (params.FrameSystemEventRecord) {\n    // Event, Topic\n    const [{\n      type\n    }] = params.FrameSystemEventRecord;\n    alias[type.unwrap().toNumber()] = 'Event';\n  } else if (hasParams && !isContract) {\n    l.warn('Unable to determine runtime Event type, cannot inspect frame_system::EventRecord');\n  }\n  return alias;\n}\n/** @internal Extracts all the intreresting type information for this registry */\nfunction extractTypeInfo(lookup, portable) {\n  const nameInfo = [];\n  const types = {};\n  for (let i = 0, count = portable.length; i < count; i++) {\n    const type = portable[i];\n    const lookupIndex = type.id.toNumber();\n    const extracted = extractName(portable, lookupIndex, portable[i]);\n    if (extracted) {\n      nameInfo.push(extracted);\n    }\n    types[lookupIndex] = type;\n  }\n  const lookups = {};\n  const names = {};\n  const params = {};\n  const dedup = removeDupeNames(lookup, portable, nameInfo);\n  for (let i = 0, count = dedup.length; i < count; i++) {\n    const {\n      lookupIndex,\n      name,\n      params: p\n    } = dedup[i];\n    names[lookupIndex] = name;\n    lookups[name] = lookup.registry.createLookupType(lookupIndex);\n    params[name] = p;\n  }\n  return {\n    lookups,\n    names,\n    params,\n    types\n  };\n}\nexport class PortableRegistry extends Struct {\n  constructor(registry, value, isContract) {\n    // const timeStart = performance.now()\n    super(registry, {\n      types: 'Vec<PortableType>'\n    }, value);\n    _defineProperty(this, \"__internal__alias\", void 0);\n    _defineProperty(this, \"__internal__lookups\", void 0);\n    _defineProperty(this, \"__internal__names\", void 0);\n    _defineProperty(this, \"__internal__params\", void 0);\n    _defineProperty(this, \"__internal__typeDefs\", {});\n    _defineProperty(this, \"__internal__types\", void 0);\n    const {\n      lookups,\n      names,\n      params,\n      types\n    } = extractTypeInfo(this, this.types);\n    this.__internal__alias = extractAliases(params, isContract);\n    this.__internal__lookups = lookups;\n    this.__internal__names = names;\n    this.__internal__params = params;\n    this.__internal__types = types;\n    // console.log('PortableRegistry', `${(performance.now() - timeStart).toFixed(2)}ms`)\n  }\n  /**\n   * @description Returns all the available type names for this chain\n   **/\n  get names() {\n    return Object.values(this.__internal__names).sort();\n  }\n  /**\n   * @description Returns all the available parameterized types for this chain\n   **/\n  get paramTypes() {\n    return this.__internal__params;\n  }\n  /**\n   * @description The types of the registry\n   */\n  get types() {\n    return this.getT('types');\n  }\n  /**\n   * @description Register all available types into the registry (generally for internal usage)\n   */\n  register() {\n    registerTypes(this, this.__internal__lookups, this.__internal__names, this.__internal__params);\n  }\n  /**\n   * @description Returns the name for a specific lookup\n   */\n  getName(lookupId) {\n    return this.__internal__names[this.__internal__getLookupId(lookupId)];\n  }\n  /**\n   * @description Finds a specific type in the registry\n   */\n  getSiType(lookupId) {\n    // NOTE catch-22 - this may already be used as part of the constructor, so\n    // ensure that we have actually initialized it correctly\n    const found = (this.__internal__types || this.types)[this.__internal__getLookupId(lookupId)];\n    if (!found) {\n      throw new Error(\"PortableRegistry: Unable to find type with lookupId \".concat(lookupId.toString()));\n    }\n    return found.type;\n  }\n  /**\n   * @description Lookup the type definition for the index\n   */\n  getTypeDef(lookupId) {\n    const lookupIndex = this.__internal__getLookupId(lookupId);\n    if (!this.__internal__typeDefs[lookupIndex]) {\n      const lookupName = this.__internal__names[lookupIndex];\n      const empty = {\n        info: TypeDefInfo.DoNotConstruct,\n        lookupIndex,\n        lookupName,\n        type: this.registry.createLookupType(lookupIndex)\n      };\n      // Set named items since we will get into circular lookups along the way\n      if (lookupName) {\n        this.__internal__typeDefs[lookupIndex] = empty;\n      }\n      const extracted = this.__internal__extract(this.getSiType(lookupId), lookupIndex);\n      // For non-named items, we only set this right at the end\n      if (!lookupName) {\n        this.__internal__typeDefs[lookupIndex] = empty;\n      }\n      Object.keys(extracted).forEach(k => {\n        if (k !== 'lookupName' || extracted[k]) {\n          // these are safe since we are looking through the keys as set\n          this.__internal__typeDefs[lookupIndex][k] = extracted[k];\n        }\n      });\n      // don't set lookupName on lower-level, we want to always direct to the type\n      if (extracted.info === TypeDefInfo.Plain) {\n        this.__internal__typeDefs[lookupIndex].lookupNameRoot = this.__internal__typeDefs[lookupIndex].lookupName;\n        delete this.__internal__typeDefs[lookupIndex].lookupName;\n      }\n    }\n    return this.__internal__typeDefs[lookupIndex];\n  }\n  /**\n   * @description For a specific field, perform adjustments to not have built-in conflicts\n   */\n  sanitizeField(name) {\n    let nameField = null;\n    let nameOrig = null;\n    if (name.isSome) {\n      nameField = stringCamelCase(name.unwrap());\n      if (nameField.includes('#')) {\n        nameOrig = nameField;\n        nameField = nameOrig.replace(/#/g, '_');\n      } else if (RESERVED.includes(nameField)) {\n        nameOrig = nameField;\n        nameField = \"\".concat(nameField, \"_\");\n      }\n    }\n    return [nameField, nameOrig];\n  }\n  /** @internal Creates a TypeDef based on an internal lookupId */\n  __internal__createSiDef(lookupId) {\n    const typeDef = this.getTypeDef(lookupId);\n    const lookupIndex = lookupId.toNumber();\n    // Setup for a lookup on complex types\n    return [TypeDefInfo.DoNotConstruct, TypeDefInfo.Enum, TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName ? {\n      docs: typeDef.docs,\n      info: TypeDefInfo.Si,\n      lookupIndex,\n      lookupName: this.__internal__names[lookupIndex],\n      type: this.registry.createLookupType(lookupId)\n    } : typeDef;\n  }\n  /** @internal Converts a lookupId input to the actual lookup index */\n  __internal__getLookupId(lookupId) {\n    if (isString(lookupId)) {\n      if (!this.registry.isLookupType(lookupId)) {\n        throw new Error(\"PortableRegistry: Expected a lookup string type, found \".concat(lookupId));\n      }\n      return parseInt(lookupId.replace('Lookup', ''), 10);\n    } else if (isNumber(lookupId)) {\n      return lookupId;\n    }\n    return lookupId.toNumber();\n  }\n  /** @internal Converts a type into a TypeDef for Codec usage */\n  __internal__extract(type, lookupIndex) {\n    const namespace = type.path.join('::');\n    let typeDef;\n    const aliasType = this.__internal__alias[lookupIndex] || getAliasPath(type);\n    try {\n      if (aliasType) {\n        typeDef = this.__internal__extractAliasPath(lookupIndex, aliasType);\n      } else {\n        switch (type.def.type) {\n          case 'Array':\n            typeDef = this.__internal__extractArray(lookupIndex, type.def.asArray);\n            break;\n          case 'BitSequence':\n            typeDef = this.__internal__extractBitSequence(lookupIndex, type.def.asBitSequence);\n            break;\n          case 'Compact':\n            typeDef = this.__internal__extractCompact(lookupIndex, type.def.asCompact);\n            break;\n          case 'Composite':\n            typeDef = this.__internal__extractComposite(lookupIndex, type, type.def.asComposite);\n            break;\n          case 'HistoricMetaCompat':\n            typeDef = this.__internal__extractHistoric(lookupIndex, type.def.asHistoricMetaCompat);\n            break;\n          case 'Primitive':\n            typeDef = this.__internal__extractPrimitive(lookupIndex, type);\n            break;\n          case 'Sequence':\n            typeDef = this.__internal__extractSequence(lookupIndex, type.def.asSequence);\n            break;\n          case 'Tuple':\n            typeDef = this.__internal__extractTuple(lookupIndex, type.def.asTuple);\n            break;\n          case 'Variant':\n            typeDef = this.__internal__extractVariant(lookupIndex, type, type.def.asVariant);\n            break;\n          default:\n            assertUnreachable(type.def.type);\n        }\n      }\n    } catch (error) {\n      throw new Error(\"PortableRegistry: \".concat(lookupIndex).concat(namespace ? \" (\".concat(namespace, \")\") : '', \": Error extracting \").concat(stringify(type), \": \").concat(error.message));\n    }\n    return objectSpread({\n      docs: sanitizeDocs(type.docs),\n      namespace\n    }, typeDef);\n  }\n  /** @internal Extracts a ScaleInfo Array into TypeDef.VecFixed */\n  __internal__extractArray(_, _ref6) {\n    let {\n      len,\n      type\n    } = _ref6;\n    const length = len.toNumber();\n    if (length > 2048) {\n      throw new Error('Only support for [Type; <length>], where length <= 2048');\n    }\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.VecFixed,\n      length,\n      sub: this.__internal__createSiDef(type)\n    });\n  }\n  /** @internal Extracts a ScaleInfo BitSequence into TypeDef.Plain */\n  __internal__extractBitSequence(_, _ref7) {\n    let {\n      bitOrderType,\n      bitStoreType\n    } = _ref7;\n    // With the v3 of scale-info this swapped around, but obviously the decoder cannot determine\n    // the order. With that in-mind, we apply a detection for LSb0/Msb and set accordingly\n    const a = this.__internal__createSiDef(bitOrderType);\n    const b = this.__internal__createSiDef(bitStoreType);\n    const [bitOrder, bitStore] = BITVEC_NS.includes(a.namespace || '') ? [a, b] : [b, a];\n    if (!bitOrder.namespace || !BITVEC_NS.includes(bitOrder.namespace)) {\n      throw new Error(\"Unexpected bitOrder found as \".concat(bitOrder.namespace || '<unknown>'));\n    } else if (bitStore.info !== TypeDefInfo.Plain || bitStore.type !== 'u8') {\n      throw new Error(\"Only u8 bitStore is currently supported, found \".concat(bitStore.type));\n    }\n    const isLsb = BITVEC_NS_LSB.includes(bitOrder.namespace);\n    if (!isLsb) {\n      // TODO To remove this limitation, we need to pass an extra info flag\n      // through to the TypeDef (Here we could potentially re-use something\n      // like index (???) to indicate and ensure we use it to pass to the\n      // BitVec constructor - which does handle this type)\n      //\n      // See https://github.com/polkadot-js/api/issues/5588\n      // throw new Error(`Only LSB BitVec is currently supported, found ${bitOrder.namespace}`);\n    }\n    return {\n      info: TypeDefInfo.Plain,\n      type: 'BitVec'\n    };\n  }\n  /** @internal Extracts a ScaleInfo Compact into TypeDef.Compact */\n  __internal__extractCompact(_, _ref8) {\n    let {\n      type\n    } = _ref8;\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Compact,\n      sub: this.__internal__createSiDef(type)\n    });\n  }\n  /** @internal Extracts a ScaleInfo Composite into TypeDef.{BTree*, Range*, Wrapper*} */\n  __internal__extractComposite(lookupIndex, _ref9, _ref10) {\n    let {\n      params,\n      path\n    } = _ref9;\n    let {\n      fields\n    } = _ref10;\n    if (path.length) {\n      const pathFirst = path[0].toString();\n      const pathLast = path[path.length - 1].toString();\n      if (path.length === 1 && pathFirst === 'BTreeMap') {\n        if (params.length !== 2) {\n          throw new Error(\"BTreeMap requires 2 parameters, found \".concat(params.length));\n        }\n        return withTypeString(this.registry, {\n          info: TypeDefInfo.BTreeMap,\n          sub: params.map(_ref11 => {\n            let {\n              type\n            } = _ref11;\n            return this.__internal__createSiDef(type.unwrap());\n          })\n        });\n      } else if (path.length === 1 && pathFirst === 'BTreeSet') {\n        if (params.length !== 1) {\n          throw new Error(\"BTreeSet requires 1 parameter, found \".concat(params.length));\n        }\n        return withTypeString(this.registry, {\n          info: TypeDefInfo.BTreeSet,\n          sub: this.__internal__createSiDef(params[0].type.unwrap())\n        });\n      } else if (['Range', 'RangeInclusive'].includes(pathFirst)) {\n        if (params.length !== 1) {\n          throw new Error(\"Range requires 1 parameter, found \".concat(params.length));\n        }\n        return withTypeString(this.registry, {\n          info: pathFirst === 'Range' ? TypeDefInfo.Range : TypeDefInfo.RangeInclusive,\n          sub: this.__internal__createSiDef(params[0].type.unwrap()),\n          type: pathFirst\n        });\n      } else if (['WrapperKeepOpaque', 'WrapperOpaque'].includes(pathLast)) {\n        if (params.length !== 1) {\n          throw new Error(\"WrapperOpaque requires 1 parameter, found \".concat(params.length));\n        }\n        return withTypeString(this.registry, {\n          info: pathLast === 'WrapperKeepOpaque' ? TypeDefInfo.WrapperKeepOpaque : TypeDefInfo.WrapperOpaque,\n          sub: this.__internal__createSiDef(params[0].type.unwrap()),\n          type: pathLast\n        });\n      }\n    }\n    return PATHS_SET.some(p => matchParts(p, path)) ? this.__internal__extractCompositeSet(lookupIndex, params, fields) : this.__internal__extractFields(lookupIndex, fields);\n  }\n  /** @internal Extracts a ScaleInfo CompositeSet into TypeDef.Set */\n  __internal__extractCompositeSet(_, params, fields) {\n    if (params.length !== 1 || fields.length !== 1) {\n      throw new Error('Set handling expects param/field as single entries');\n    }\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Set,\n      length: this.registry.createTypeUnsafe(this.registry.createLookupType(fields[0].type), []).bitLength(),\n      sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(_ref12 => {\n        let {\n          index,\n          name\n        } = _ref12;\n        return {\n          // This will be an issue > 2^53 - 1 ... don't have those (yet)\n          index: index.toNumber(),\n          info: TypeDefInfo.Plain,\n          name: name.toString(),\n          type: 'Null'\n        };\n      })\n    });\n  }\n  /** @internal Extracts ScaleInfo enum/struct fields into TypeDef.{Struct, Tuple} */\n  __internal__extractFields(lookupIndex, fields) {\n    let isStruct = true;\n    let isTuple = true;\n    const count = fields.length;\n    for (let f = 0; f < count; f++) {\n      const {\n        name\n      } = fields[f];\n      isStruct = isStruct && name.isSome;\n      isTuple = isTuple && name.isNone;\n    }\n    if (!isTuple && !isStruct) {\n      throw new Error('Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)');\n    }\n    if (count === 0) {\n      return {\n        info: TypeDefInfo.Null,\n        type: 'Null'\n      };\n    } else if (isTuple && count === 1) {\n      const typeDef = this.__internal__createSiDef(fields[0].type);\n      return objectSpread({}, typeDef, lookupIndex === -1 ? null : {\n        lookupIndex,\n        lookupName: this.__internal__names[lookupIndex],\n        lookupNameRoot: typeDef.lookupName\n      }, fields[0].typeName.isSome ? {\n        typeName: sanitize(fields[0].typeName.unwrap())\n      } : null);\n    }\n    const [sub, alias] = this.__internal__extractFieldsAlias(fields);\n    return withTypeString(this.registry, objectSpread({\n      info: isTuple // Tuple check first\n      ? TypeDefInfo.Tuple : TypeDefInfo.Struct,\n      sub\n    }, alias.size ? {\n      alias\n    } : null, lookupIndex === -1 ? null : {\n      lookupIndex,\n      lookupName: this.__internal__names[lookupIndex]\n    }));\n  }\n  /** @internal Apply field aliassed (with no JS conflicts) */\n  __internal__extractFieldsAlias(fields) {\n    const alias = new Map();\n    const count = fields.length;\n    const sub = new Array(count);\n    for (let i = 0; i < count; i++) {\n      const {\n        docs,\n        name,\n        type,\n        typeName\n      } = fields[i];\n      const typeDef = this.__internal__createSiDef(type);\n      if (name.isNone) {\n        sub[i] = typeDef;\n      } else {\n        const [nameField, nameOrig] = this.sanitizeField(name);\n        if (nameField && nameOrig) {\n          alias.set(nameField, nameOrig);\n        }\n        sub[i] = objectSpread({\n          docs: sanitizeDocs(docs),\n          name: nameField\n        }, typeDef, typeName.isSome ? {\n          typeName: sanitize(typeName.unwrap())\n        } : null);\n      }\n    }\n    return [sub, alias];\n  }\n  /** @internal Extracts an internal Historic (pre V14) type  */\n  __internal__extractHistoric(_, type) {\n    return objectSpread({\n      displayName: type.toString(),\n      isFromSi: true\n    }, getTypeDef(type));\n  }\n  /** @internal Extracts a ScaleInfo Primitive into TypeDef.Plain */\n  __internal__extractPrimitive(_, type) {\n    const typeStr = type.def.asPrimitive.type.toString();\n    return {\n      info: TypeDefInfo.Plain,\n      type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()\n    };\n  }\n  /** @internal Applies an alias path onto the TypeDef */\n  __internal__extractAliasPath(_, type) {\n    return {\n      info: TypeDefInfo.Plain,\n      type\n    };\n  }\n  /** @internal Extracts a ScaleInfo Sequence into TypeDef.Vec (with Bytes shortcut) */\n  __internal__extractSequence(lookupIndex, _ref13) {\n    let {\n      type\n    } = _ref13;\n    const sub = this.__internal__createSiDef(type);\n    if (sub.type === 'u8') {\n      return {\n        info: TypeDefInfo.Plain,\n        type: 'Bytes'\n      };\n    }\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Vec,\n      lookupIndex,\n      lookupName: this.__internal__names[lookupIndex],\n      sub\n    });\n  }\n  /** @internal Extracts a ScaleInfo Tuple into TypeDef.Tuple */\n  __internal__extractTuple(lookupIndex, ids) {\n    if (ids.length === 0) {\n      return {\n        info: TypeDefInfo.Null,\n        type: 'Null'\n      };\n    } else if (ids.length === 1) {\n      return this.getTypeDef(ids[0]);\n    }\n    const sub = ids.map(t => this.__internal__createSiDef(t));\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Tuple,\n      lookupIndex,\n      lookupName: this.__internal__names[lookupIndex],\n      sub\n    });\n  }\n  /** @internal Extracts a ScaleInfo Variant into TypeDef.{Option, Result, Enum} */\n  __internal__extractVariant(lookupIndex, _ref14, _ref15) {\n    let {\n      params,\n      path\n    } = _ref14;\n    let {\n      variants\n    } = _ref15;\n    if (path.length) {\n      const specialVariant = path[0].toString();\n      if (specialVariant === 'Option') {\n        if (params.length !== 1) {\n          throw new Error(\"Option requires 1 parameter, found \".concat(params.length));\n        }\n        // NOTE This is opt-in (unhandled), not by default\n        // if (sub.type === 'bool') {\n        //   return withTypeString(this.registry, {\n        //     info: TypeDefInfo.Plain,\n        //     type: 'OptionBool'\n        //   });\n        // }\n        return withTypeString(this.registry, {\n          info: TypeDefInfo.Option,\n          sub: this.__internal__createSiDef(params[0].type.unwrap())\n        });\n      } else if (specialVariant === 'Result') {\n        if (params.length !== 2) {\n          throw new Error(\"Result requires 2 parameters, found \".concat(params.length));\n        }\n        return withTypeString(this.registry, {\n          info: TypeDefInfo.Result,\n          sub: params.map((_ref16, index) => {\n            let {\n              type\n            } = _ref16;\n            return objectSpread({\n              name: ['Ok', 'Error'][index]\n            }, this.__internal__createSiDef(type.unwrap()));\n          })\n        });\n      }\n    }\n    if (variants.length === 0) {\n      return {\n        info: TypeDefInfo.Null,\n        type: 'Null'\n      };\n    }\n    return this.__internal__extractVariantEnum(lookupIndex, variants);\n  }\n  /** @internal Extracts a ScaleInfo Variant into TypeDef.Enum */\n  __internal__extractVariantEnum(lookupIndex, variants) {\n    const sub = [];\n    // we may get entries out of order, arrange them first before creating with gaps filled\n    // NOTE: Since we mutate, use a copy of the array as an input\n    variants.slice().sort((a, b) => a.index.cmp(b.index)).forEach(_ref17 => {\n      let {\n        fields,\n        index: bnIndex,\n        name\n      } = _ref17;\n      const index = bnIndex.toNumber();\n      while (sub.length !== index) {\n        sub.push({\n          index: sub.length,\n          info: TypeDefInfo.Null,\n          name: \"__Unused\".concat(sub.length),\n          type: 'Null'\n        });\n      }\n      sub.push(objectSpread(this.__internal__extractFields(-1, fields), {\n        index,\n        name: name.toString()\n      }));\n    });\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Enum,\n      lookupIndex,\n      lookupName: this.__internal__names[lookupIndex],\n      sub\n    });\n  }\n}","map":{"version":3,"names":["sanitize","Struct","getTypeDef","TypeDefInfo","withTypeString","assertUnreachable","isNumber","isString","logger","objectSpread","stringCamelCase","stringify","stringPascalCase","l","TYPE_UNWRAP","toNumber","PRIMITIVE_ALIAS","Char","Str","PATHS_ALIAS","splitNamespace","PATHS_SET","BITVEC_NS_LSB","BITVEC_NS_MSB","BITVEC_NS","WRAPPERS","RESERVED","PATH_RM_INDEX_1","sanitizeDocs","docs","count","length","result","Array","i","toString","values","split","matchParts","first","second","every","a","index","b","includes","suba","subb","indexOf","slice","getAliasPath","_ref","def","path","join","isComposite","asComposite","fields","some","extractNameFlat","portable","lookupIndex","params","isInternal","arguments","undefined","camels","lowers","c","replace","toLowerCase","name","type","isSome","instanceType","unwrap","concat","extractName","_ref2","nextDupeMatches","startAt","names","v","push","rewriteDupes","input","rewrite","j","p","removeDupeNames","lookup","map","original","allSame","anyDiff","o","eq","unwrapOr","paramIdx","findIndex","_ref3","_ref4","aIndex","sameCount","adjusted","getSiType","isPrimitive","asPrimitive","flat","filter","n","_ref5","registerTypes","lookups","registry","register","SpRuntimeUncheckedExtrinsic","addrParam","sigParam","siAddress","siSignature","nsSignature","nsAccountId","isMultiAddress","idParam","AccountId","endsWith","Address","ExtrinsicSignature","extractAliases","isContract","hasParams","Object","keys","k","startsWith","alias","warn","FrameSystemEventRecord","extractTypeInfo","nameInfo","types","id","extracted","dedup","createLookupType","PortableRegistry","constructor","value","_defineProperty","__internal__alias","__internal__lookups","__internal__names","__internal__params","__internal__types","sort","paramTypes","getT","getName","lookupId","__internal__getLookupId","found","Error","__internal__typeDefs","lookupName","empty","info","DoNotConstruct","__internal__extract","forEach","Plain","lookupNameRoot","sanitizeField","nameField","nameOrig","__internal__createSiDef","typeDef","Enum","Si","isLookupType","parseInt","namespace","aliasType","__internal__extractAliasPath","__internal__extractArray","asArray","__internal__extractBitSequence","asBitSequence","__internal__extractCompact","asCompact","__internal__extractComposite","__internal__extractHistoric","asHistoricMetaCompat","__internal__extractPrimitive","__internal__extractSequence","asSequence","__internal__extractTuple","asTuple","__internal__extractVariant","asVariant","error","message","_","_ref6","len","VecFixed","sub","_ref7","bitOrderType","bitStoreType","bitOrder","bitStore","isLsb","_ref8","Compact","_ref9","_ref10","pathFirst","pathLast","BTreeMap","_ref11","BTreeSet","Range","RangeInclusive","WrapperKeepOpaque","WrapperOpaque","__internal__extractCompositeSet","__internal__extractFields","Set","createTypeUnsafe","bitLength","variants","_ref12","isStruct","isTuple","f","isNone","Null","typeName","__internal__extractFieldsAlias","Tuple","size","Map","set","displayName","isFromSi","typeStr","_ref13","Vec","ids","t","_ref14","_ref15","specialVariant","Option","Result","_ref16","__internal__extractVariantEnum","cmp","_ref17","bnIndex"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/metadata/PortableRegistry/PortableRegistry.js"],"sourcesContent":["import { sanitize, Struct } from '@polkadot/types-codec';\nimport { getTypeDef, TypeDefInfo, withTypeString } from '@polkadot/types-create';\nimport { assertUnreachable, isNumber, isString, logger, objectSpread, stringCamelCase, stringify, stringPascalCase } from '@polkadot/util';\nconst l = logger('PortableRegistry');\nconst TYPE_UNWRAP = { toNumber: () => -1 };\nconst PRIMITIVE_ALIAS = {\n    Char: 'u32', // Rust char is 4-bytes\n    Str: 'Text'\n};\nconst PATHS_ALIAS = splitNamespace([\n    // full matching on exact names...\n    // these are well-known types with additional encoding\n    'sp_core::crypto::AccountId32',\n    'sp_runtime::generic::era::Era',\n    'sp_runtime::multiaddress::MultiAddress',\n    // ethereum overrides (Frontier, Moonbeam, Polkadot claims)\n    'fp_account::AccountId20',\n    'account::AccountId20',\n    'polkadot_runtime_common::claims::EthereumAddress',\n    // weights 2 is a structure, however for 1.5. with a single field it\n    // should be flatenned (can appear in Compact<Weight> extrinsics)\n    'frame_support::weights::weight_v2::Weight',\n    'sp_weights::weight_v2::Weight',\n    // wildcard matching in place...\n    // these have a specific encoding or logic, use a wildcard for {pallet, darwinia}_democracy\n    '*_democracy::vote::Vote',\n    '*_conviction_voting::vote::Vote',\n    '*_identity::types::Data',\n    // these are opaque Vec<u8> wrappers\n    'sp_core::OpaqueMetadata',\n    'sp_core::OpaquePeerId',\n    'sp_core::offchain::OpaqueMultiaddr',\n    // shorten some well-known types\n    'primitive_types::*',\n    'sp_arithmetic::per_things::*',\n    // runtime\n    '*_runtime::RuntimeCall',\n    '*_runtime::RuntimeEvent',\n    // ink!\n    'ink::env::types::*',\n    'ink::primitives::types::*',\n    'ink_env::types::*',\n    'ink_primitives::types::*',\n    // noir\n    'np_runtime::accountname::AccountName',\n    'np_runtime::universaladdress::UniversalAddress'\n]);\nconst PATHS_SET = splitNamespace([\n    'pallet_identity::types::BitFlags'\n]);\nconst BITVEC_NS_LSB = ['bitvec::order::Lsb0', 'BitOrderLsb0'];\nconst BITVEC_NS_MSB = ['bitvec::order::Msb0', 'BitOrderMsb0'];\nconst BITVEC_NS = [...BITVEC_NS_LSB, ...BITVEC_NS_MSB];\nconst WRAPPERS = ['BoundedBTreeMap', 'BoundedBTreeSet', 'BoundedVec', 'Box', 'BTreeMap', 'BTreeSet', 'Cow', 'Option', 'Range', 'RangeInclusive', 'Result', 'WeakBoundedVec', 'WrapperKeepOpaque', 'WrapperOpaque'];\nconst RESERVED = [\n    // JS reserved words\n    'entries', 'keys', 'new', 'size',\n    // exposed by all Codec objects\n    'hash', 'registry'\n];\nconst PATH_RM_INDEX_1 = ['generic', 'misc', 'pallet', 'traits', 'types'];\n/** @internal Converts a Text[] into string[] (used as part of definitions) */\nfunction sanitizeDocs(docs) {\n    const count = docs.length;\n    const result = new Array(count);\n    for (let i = 0; i < count; i++) {\n        result[i] = docs[i].toString();\n    }\n    return result;\n}\n/** @internal Split a namespace with :: into individual parts */\nfunction splitNamespace(values) {\n    const count = values.length;\n    const result = new Array(count);\n    for (let i = 0; i < count; i++) {\n        result[i] = values[i].split('::');\n    }\n    return result;\n}\n/** @internal Match a namespace based on parts (alongside wildcards) */\nfunction matchParts(first, second) {\n    return first.length === second.length && first.every((a, index) => {\n        const b = second[index].toString();\n        if ((a === '*') || (a === b)) {\n            return true;\n        }\n        if (a.includes('*') && a.includes('_') && b.includes('_')) {\n            let suba = a.split('_');\n            let subb = b.split('_');\n            // match initial *'s to multiples if we have a match for the other\n            if (suba[0] === '*') {\n                const indexOf = subb.indexOf(suba[1]);\n                if (indexOf !== -1) {\n                    suba = suba.slice(1);\n                    subb = subb.slice(indexOf);\n                }\n            }\n            // check for * matches at the end, adjust accordingly\n            if ((suba.length === 2) && (suba[1] === '*') && (suba[0] === subb[0])) {\n                return true;\n            }\n            return matchParts(suba, subb);\n        }\n        return false;\n    });\n}\n/** @internal check if the path matches the PATHS_ALIAS (with wildcards) */\nfunction getAliasPath({ def, path }) {\n    // specific logic for weights - we override when non-complex struct\n    // (as applied in Weight 1.5 where we also have `Compact<{ refTime: u64 }>)\n    if (['frame_support::weights::weight_v2::Weight', 'sp_weights::weight_v2::Weight'].includes(path.join('::'))) {\n        return !def.isComposite || def.asComposite.fields.length === 1\n            ? 'WeightV1'\n            : null;\n    }\n    // TODO We need to handle ink! Balance in some way\n    return path.length && PATHS_ALIAS.some((a) => matchParts(a, path))\n        ? path[path.length - 1].toString()\n        : null;\n}\n/** @internal Converts a type name into a JS-API compatible name */\nfunction extractNameFlat(portable, lookupIndex, params, path, isInternal = false) {\n    const count = path.length;\n    // if we have no path or determined as a wrapper, we just skip it\n    if (count === 0 || WRAPPERS.includes(path[count - 1].toString())) {\n        return null;\n    }\n    const camels = new Array(count);\n    const lowers = new Array(count);\n    // initially just create arrays of the camelCase and lowercase path\n    // parts - we will check these to extract the final values. While\n    // we have 2 loops here, we also don't do the same operation twice\n    for (let i = 0; i < count; i++) {\n        const c = stringPascalCase(isInternal\n            ? path[i].replace('pallet_', '')\n            : path[i]);\n        const l = c.toLowerCase();\n        camels[i] = c;\n        lowers[i] = l;\n    }\n    let name = '';\n    for (let i = 0; i < count; i++) {\n        const l = lowers[i];\n        // Remove ::{generic, misc, pallet, traits, types}::\n        if (i !== 1 || !PATH_RM_INDEX_1.includes(l)) {\n            // sp_runtime::generic::digest::Digest -> sp_runtime::generic::Digest\n            // sp_runtime::multiaddress::MultiAddress -> sp_runtime::MultiAddress\n            if (l !== lowers[i + 1]) {\n                name += camels[i];\n            }\n        }\n    }\n    // do magic for RawOrigin lookup, e.g. pallet_collective::RawOrigin\n    if (camels[1] === 'RawOrigin' && count === 2 && params.length === 2 && params[1].type.isSome) {\n        const instanceType = portable[params[1].type.unwrap().toNumber()];\n        if (instanceType.type.path.length === 2) {\n            name = `${name}${instanceType.type.path[1].toString()}`;\n        }\n    }\n    return { lookupIndex, name, params };\n}\n/** @internal Alias for extractNameFlat with PortableType as a last parameter */\nfunction extractName(portable, lookupIndex, { type: { params, path } }) {\n    return extractNameFlat(portable, lookupIndex, params, path);\n}\n/** @internal Check for dupes from a specific index onwards */\nfunction nextDupeMatches(name, startAt, names) {\n    const result = [names[startAt]];\n    for (let i = startAt + 1, count = names.length; i < count; i++) {\n        const v = names[i];\n        if (v.name === name) {\n            result.push(v);\n        }\n    }\n    return result;\n}\n/** @internal Checks to see if a type is a full duplicate (with all params matching) */\nfunction rewriteDupes(input, rewrite) {\n    const count = input.length;\n    for (let i = 0; i < count; i++) {\n        const a = input[i];\n        for (let j = i + 1; j < count; j++) {\n            const b = input[j];\n            // if the indexes are not the same and the names match, we have a dupe\n            if (a.lookupIndex !== b.lookupIndex && a.name === b.name) {\n                return false;\n            }\n        }\n    }\n    // add all the adjusted values to the rewite map\n    for (let i = 0; i < count; i++) {\n        const p = input[i];\n        rewrite[p.lookupIndex] = p.name;\n    }\n    return true;\n}\n/** @internal Find duplicates and adjust the names based on parameters */\nfunction removeDupeNames(lookup, portable, names) {\n    const rewrite = {};\n    return names\n        .map((original, startAt) => {\n        const { lookupIndex, name, params } = original;\n        if (!name) {\n            // the name is empty (this is not expected, but have a failsafe)\n            return null;\n        }\n        else if (rewrite[lookupIndex]) {\n            // we have already rewritten this one, we can skip it\n            return original;\n        }\n        // those where the name is matching starting from this index\n        const allSame = nextDupeMatches(name, startAt, names);\n        // we only have one, so all ok\n        if (allSame.length === 1) {\n            return original;\n        }\n        // are there param differences between matching names\n        const anyDiff = allSame.some((o) => params.length !== o.params.length ||\n            params.some((p, index) => !p.name.eq(o.params[index].name) ||\n                p.type.unwrapOr(TYPE_UNWRAP).toNumber() !== o.params[index].type.unwrapOr(TYPE_UNWRAP).toNumber()));\n        // everything matches, we can combine these\n        if (!anyDiff) {\n            return original;\n        }\n        // TODO We probably want to attach all the indexes with differences,\n        // not just the first\n        // find the first parameter that yields differences\n        const paramIdx = params.findIndex(({ type }, index) => allSame.every(({ params }, aIndex) => params[index].type.isSome && (aIndex === 0 ||\n            !params[index].type.eq(type))));\n        // No param found that is different\n        if (paramIdx === -1) {\n            return original;\n        }\n        // see if using the param type helps\n        const sameCount = allSame.length;\n        const adjusted = new Array(sameCount);\n        // loop through all, specifically checking that index where the\n        // first param yields differences\n        for (let i = 0; i < sameCount; i++) {\n            const { lookupIndex, name, params } = allSame[i];\n            const { def, path } = lookup.getSiType(params[paramIdx].type.unwrap());\n            // if it is not a primitive and it doesn't have a path, we really cannot\n            // do anything at this point\n            if (!def.isPrimitive && !path.length) {\n                return null;\n            }\n            adjusted[i] = {\n                lookupIndex,\n                name: def.isPrimitive\n                    ? `${name}${def.asPrimitive.toString()}`\n                    : `${name}${path[path.length - 1].toString()}`\n            };\n        }\n        // check to see if the adjusted names have no issues\n        if (rewriteDupes(adjusted, rewrite)) {\n            return original;\n        }\n        // TODO This is duplicated from the section just above...\n        // ... we certainly need a better solution here\n        //\n        // Last-ditch effort to use the full type path - ugly\n        // loop through all, specifically checking that index where the\n        // first param yields differences\n        for (let i = 0; i < sameCount; i++) {\n            const { lookupIndex, name, params } = allSame[i];\n            const { def, path } = lookup.getSiType(params[paramIdx].type.unwrap());\n            const flat = extractNameFlat(portable, lookupIndex, params, path, true);\n            if (def.isPrimitive || !flat) {\n                return null;\n            }\n            adjusted[i] = {\n                lookupIndex,\n                name: `${name}${flat.name}`\n            };\n        }\n        // check to see if the adjusted names have no issues\n        if (rewriteDupes(adjusted, rewrite)) {\n            return original;\n        }\n        return null;\n    })\n        .filter((n) => !!n)\n        .map(({ lookupIndex, name, params }) => ({\n        lookupIndex,\n        name: rewrite[lookupIndex] || name,\n        params\n    }));\n}\n/** @internal Detect on-chain types (AccountId/Signature) as set as the default */\nfunction registerTypes(lookup, lookups, names, params) {\n    // Register the types we extracted\n    lookup.registry.register(lookups);\n    // Try and extract the AccountId/Address/Signature type from UncheckedExtrinsic\n    if (params.SpRuntimeUncheckedExtrinsic) {\n        // Address, Call, Signature, Extra\n        const [addrParam, , sigParam] = params.SpRuntimeUncheckedExtrinsic;\n        const siAddress = lookup.getSiType(addrParam.type.unwrap());\n        const siSignature = lookup.getSiType(sigParam.type.unwrap());\n        const nsSignature = siSignature.path.join('::');\n        let nsAccountId = siAddress.path.join('::');\n        const isMultiAddress = nsAccountId === 'sp_runtime::multiaddress::MultiAddress';\n        // With multiaddress, we check the first type param again\n        if (isMultiAddress) {\n            // AccountId, AccountIndex\n            const [idParam] = siAddress.params;\n            nsAccountId = lookup.getSiType(idParam.type.unwrap()).path.join('::');\n        }\n        lookup.registry.register({\n            // known: account::AccountId20, fp_account::AccountId20, primitive_types::H160\n            AccountId: nsAccountId.endsWith('::AccountId20') || nsAccountId.endsWith('::H160')\n                ? 'AccountId20'\n                : 'AccountId32',\n            Address: isMultiAddress\n                ? 'MultiAddress'\n                : 'AccountId',\n            ExtrinsicSignature: ['sp_runtime::MultiSignature'].includes(nsSignature)\n                ? 'MultiSignature'\n                : names[sigParam.type.unwrap().toNumber()] || 'MultiSignature'\n        });\n    }\n}\n/**\n * @internal Extracts aliases based on what we know the runtime config looks like in a\n * Substrate chain. Specifically we want to have access to the Call and Event params\n **/\nfunction extractAliases(params, isContract) {\n    const hasParams = Object.keys(params).some((k) => !k.startsWith('Pallet'));\n    const alias = {};\n    if (params.SpRuntimeUncheckedExtrinsic) {\n        // Address, Call, Signature, Extra\n        const [, { type }] = params.SpRuntimeUncheckedExtrinsic;\n        alias[type.unwrap().toNumber()] = 'Call';\n    }\n    else if (hasParams && !isContract) {\n        l.warn('Unable to determine runtime Call type, cannot inspect sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic');\n    }\n    if (params.FrameSystemEventRecord) {\n        // Event, Topic\n        const [{ type }] = params.FrameSystemEventRecord;\n        alias[type.unwrap().toNumber()] = 'Event';\n    }\n    else if (hasParams && !isContract) {\n        l.warn('Unable to determine runtime Event type, cannot inspect frame_system::EventRecord');\n    }\n    return alias;\n}\n/** @internal Extracts all the intreresting type information for this registry */\nfunction extractTypeInfo(lookup, portable) {\n    const nameInfo = [];\n    const types = {};\n    for (let i = 0, count = portable.length; i < count; i++) {\n        const type = portable[i];\n        const lookupIndex = type.id.toNumber();\n        const extracted = extractName(portable, lookupIndex, portable[i]);\n        if (extracted) {\n            nameInfo.push(extracted);\n        }\n        types[lookupIndex] = type;\n    }\n    const lookups = {};\n    const names = {};\n    const params = {};\n    const dedup = removeDupeNames(lookup, portable, nameInfo);\n    for (let i = 0, count = dedup.length; i < count; i++) {\n        const { lookupIndex, name, params: p } = dedup[i];\n        names[lookupIndex] = name;\n        lookups[name] = lookup.registry.createLookupType(lookupIndex);\n        params[name] = p;\n    }\n    return { lookups, names, params, types };\n}\nexport class PortableRegistry extends Struct {\n    __internal__alias;\n    __internal__lookups;\n    __internal__names;\n    __internal__params;\n    __internal__typeDefs = {};\n    __internal__types;\n    constructor(registry, value, isContract) {\n        // const timeStart = performance.now()\n        super(registry, {\n            types: 'Vec<PortableType>'\n        }, value);\n        const { lookups, names, params, types } = extractTypeInfo(this, this.types);\n        this.__internal__alias = extractAliases(params, isContract);\n        this.__internal__lookups = lookups;\n        this.__internal__names = names;\n        this.__internal__params = params;\n        this.__internal__types = types;\n        // console.log('PortableRegistry', `${(performance.now() - timeStart).toFixed(2)}ms`)\n    }\n    /**\n     * @description Returns all the available type names for this chain\n     **/\n    get names() {\n        return Object.values(this.__internal__names).sort();\n    }\n    /**\n     * @description Returns all the available parameterized types for this chain\n     **/\n    get paramTypes() {\n        return this.__internal__params;\n    }\n    /**\n     * @description The types of the registry\n     */\n    get types() {\n        return this.getT('types');\n    }\n    /**\n     * @description Register all available types into the registry (generally for internal usage)\n     */\n    register() {\n        registerTypes(this, this.__internal__lookups, this.__internal__names, this.__internal__params);\n    }\n    /**\n     * @description Returns the name for a specific lookup\n     */\n    getName(lookupId) {\n        return this.__internal__names[this.__internal__getLookupId(lookupId)];\n    }\n    /**\n     * @description Finds a specific type in the registry\n     */\n    getSiType(lookupId) {\n        // NOTE catch-22 - this may already be used as part of the constructor, so\n        // ensure that we have actually initialized it correctly\n        const found = (this.__internal__types || this.types)[this.__internal__getLookupId(lookupId)];\n        if (!found) {\n            throw new Error(`PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);\n        }\n        return found.type;\n    }\n    /**\n     * @description Lookup the type definition for the index\n     */\n    getTypeDef(lookupId) {\n        const lookupIndex = this.__internal__getLookupId(lookupId);\n        if (!this.__internal__typeDefs[lookupIndex]) {\n            const lookupName = this.__internal__names[lookupIndex];\n            const empty = {\n                info: TypeDefInfo.DoNotConstruct,\n                lookupIndex,\n                lookupName,\n                type: this.registry.createLookupType(lookupIndex)\n            };\n            // Set named items since we will get into circular lookups along the way\n            if (lookupName) {\n                this.__internal__typeDefs[lookupIndex] = empty;\n            }\n            const extracted = this.__internal__extract(this.getSiType(lookupId), lookupIndex);\n            // For non-named items, we only set this right at the end\n            if (!lookupName) {\n                this.__internal__typeDefs[lookupIndex] = empty;\n            }\n            Object.keys(extracted).forEach((k) => {\n                if (k !== 'lookupName' || extracted[k]) {\n                    // these are safe since we are looking through the keys as set\n                    this.__internal__typeDefs[lookupIndex][k] = extracted[k];\n                }\n            });\n            // don't set lookupName on lower-level, we want to always direct to the type\n            if (extracted.info === TypeDefInfo.Plain) {\n                this.__internal__typeDefs[lookupIndex].lookupNameRoot = this.__internal__typeDefs[lookupIndex].lookupName;\n                delete this.__internal__typeDefs[lookupIndex].lookupName;\n            }\n        }\n        return this.__internal__typeDefs[lookupIndex];\n    }\n    /**\n     * @description For a specific field, perform adjustments to not have built-in conflicts\n     */\n    sanitizeField(name) {\n        let nameField = null;\n        let nameOrig = null;\n        if (name.isSome) {\n            nameField = stringCamelCase(name.unwrap());\n            if (nameField.includes('#')) {\n                nameOrig = nameField;\n                nameField = nameOrig.replace(/#/g, '_');\n            }\n            else if (RESERVED.includes(nameField)) {\n                nameOrig = nameField;\n                nameField = `${nameField}_`;\n            }\n        }\n        return [nameField, nameOrig];\n    }\n    /** @internal Creates a TypeDef based on an internal lookupId */\n    __internal__createSiDef(lookupId) {\n        const typeDef = this.getTypeDef(lookupId);\n        const lookupIndex = lookupId.toNumber();\n        // Setup for a lookup on complex types\n        return [TypeDefInfo.DoNotConstruct, TypeDefInfo.Enum, TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName\n            ? {\n                docs: typeDef.docs,\n                info: TypeDefInfo.Si,\n                lookupIndex,\n                lookupName: this.__internal__names[lookupIndex],\n                type: this.registry.createLookupType(lookupId)\n            }\n            : typeDef;\n    }\n    /** @internal Converts a lookupId input to the actual lookup index */\n    __internal__getLookupId(lookupId) {\n        if (isString(lookupId)) {\n            if (!this.registry.isLookupType(lookupId)) {\n                throw new Error(`PortableRegistry: Expected a lookup string type, found ${lookupId}`);\n            }\n            return parseInt(lookupId.replace('Lookup', ''), 10);\n        }\n        else if (isNumber(lookupId)) {\n            return lookupId;\n        }\n        return lookupId.toNumber();\n    }\n    /** @internal Converts a type into a TypeDef for Codec usage */\n    __internal__extract(type, lookupIndex) {\n        const namespace = type.path.join('::');\n        let typeDef;\n        const aliasType = this.__internal__alias[lookupIndex] || getAliasPath(type);\n        try {\n            if (aliasType) {\n                typeDef = this.__internal__extractAliasPath(lookupIndex, aliasType);\n            }\n            else {\n                switch (type.def.type) {\n                    case 'Array':\n                        typeDef = this.__internal__extractArray(lookupIndex, type.def.asArray);\n                        break;\n                    case 'BitSequence':\n                        typeDef = this.__internal__extractBitSequence(lookupIndex, type.def.asBitSequence);\n                        break;\n                    case 'Compact':\n                        typeDef = this.__internal__extractCompact(lookupIndex, type.def.asCompact);\n                        break;\n                    case 'Composite':\n                        typeDef = this.__internal__extractComposite(lookupIndex, type, type.def.asComposite);\n                        break;\n                    case 'HistoricMetaCompat':\n                        typeDef = this.__internal__extractHistoric(lookupIndex, type.def.asHistoricMetaCompat);\n                        break;\n                    case 'Primitive':\n                        typeDef = this.__internal__extractPrimitive(lookupIndex, type);\n                        break;\n                    case 'Sequence':\n                        typeDef = this.__internal__extractSequence(lookupIndex, type.def.asSequence);\n                        break;\n                    case 'Tuple':\n                        typeDef = this.__internal__extractTuple(lookupIndex, type.def.asTuple);\n                        break;\n                    case 'Variant':\n                        typeDef = this.__internal__extractVariant(lookupIndex, type, type.def.asVariant);\n                        break;\n                    default: assertUnreachable(type.def.type);\n                }\n            }\n        }\n        catch (error) {\n            throw new Error(`PortableRegistry: ${lookupIndex}${namespace ? ` (${namespace})` : ''}: Error extracting ${stringify(type)}: ${error.message}`);\n        }\n        return objectSpread({\n            docs: sanitizeDocs(type.docs),\n            namespace\n        }, typeDef);\n    }\n    /** @internal Extracts a ScaleInfo Array into TypeDef.VecFixed */\n    __internal__extractArray(_, { len, type }) {\n        const length = len.toNumber();\n        if (length > 2048) {\n            throw new Error('Only support for [Type; <length>], where length <= 2048');\n        }\n        return withTypeString(this.registry, {\n            info: TypeDefInfo.VecFixed,\n            length,\n            sub: this.__internal__createSiDef(type)\n        });\n    }\n    /** @internal Extracts a ScaleInfo BitSequence into TypeDef.Plain */\n    __internal__extractBitSequence(_, { bitOrderType, bitStoreType }) {\n        // With the v3 of scale-info this swapped around, but obviously the decoder cannot determine\n        // the order. With that in-mind, we apply a detection for LSb0/Msb and set accordingly\n        const a = this.__internal__createSiDef(bitOrderType);\n        const b = this.__internal__createSiDef(bitStoreType);\n        const [bitOrder, bitStore] = BITVEC_NS.includes(a.namespace || '')\n            ? [a, b]\n            : [b, a];\n        if (!bitOrder.namespace || !BITVEC_NS.includes(bitOrder.namespace)) {\n            throw new Error(`Unexpected bitOrder found as ${bitOrder.namespace || '<unknown>'}`);\n        }\n        else if (bitStore.info !== TypeDefInfo.Plain || bitStore.type !== 'u8') {\n            throw new Error(`Only u8 bitStore is currently supported, found ${bitStore.type}`);\n        }\n        const isLsb = BITVEC_NS_LSB.includes(bitOrder.namespace);\n        if (!isLsb) {\n            // TODO To remove this limitation, we need to pass an extra info flag\n            // through to the TypeDef (Here we could potentially re-use something\n            // like index (???) to indicate and ensure we use it to pass to the\n            // BitVec constructor - which does handle this type)\n            //\n            // See https://github.com/polkadot-js/api/issues/5588\n            // throw new Error(`Only LSB BitVec is currently supported, found ${bitOrder.namespace}`);\n        }\n        return {\n            info: TypeDefInfo.Plain,\n            type: 'BitVec'\n        };\n    }\n    /** @internal Extracts a ScaleInfo Compact into TypeDef.Compact */\n    __internal__extractCompact(_, { type }) {\n        return withTypeString(this.registry, {\n            info: TypeDefInfo.Compact,\n            sub: this.__internal__createSiDef(type)\n        });\n    }\n    /** @internal Extracts a ScaleInfo Composite into TypeDef.{BTree*, Range*, Wrapper*} */\n    __internal__extractComposite(lookupIndex, { params, path }, { fields }) {\n        if (path.length) {\n            const pathFirst = path[0].toString();\n            const pathLast = path[path.length - 1].toString();\n            if (path.length === 1 && pathFirst === 'BTreeMap') {\n                if (params.length !== 2) {\n                    throw new Error(`BTreeMap requires 2 parameters, found ${params.length}`);\n                }\n                return withTypeString(this.registry, {\n                    info: TypeDefInfo.BTreeMap,\n                    sub: params.map(({ type }) => this.__internal__createSiDef(type.unwrap()))\n                });\n            }\n            else if (path.length === 1 && pathFirst === 'BTreeSet') {\n                if (params.length !== 1) {\n                    throw new Error(`BTreeSet requires 1 parameter, found ${params.length}`);\n                }\n                return withTypeString(this.registry, {\n                    info: TypeDefInfo.BTreeSet,\n                    sub: this.__internal__createSiDef(params[0].type.unwrap())\n                });\n            }\n            else if (['Range', 'RangeInclusive'].includes(pathFirst)) {\n                if (params.length !== 1) {\n                    throw new Error(`Range requires 1 parameter, found ${params.length}`);\n                }\n                return withTypeString(this.registry, {\n                    info: pathFirst === 'Range'\n                        ? TypeDefInfo.Range\n                        : TypeDefInfo.RangeInclusive,\n                    sub: this.__internal__createSiDef(params[0].type.unwrap()),\n                    type: pathFirst\n                });\n            }\n            else if (['WrapperKeepOpaque', 'WrapperOpaque'].includes(pathLast)) {\n                if (params.length !== 1) {\n                    throw new Error(`WrapperOpaque requires 1 parameter, found ${params.length}`);\n                }\n                return withTypeString(this.registry, {\n                    info: pathLast === 'WrapperKeepOpaque'\n                        ? TypeDefInfo.WrapperKeepOpaque\n                        : TypeDefInfo.WrapperOpaque,\n                    sub: this.__internal__createSiDef(params[0].type.unwrap()),\n                    type: pathLast\n                });\n            }\n        }\n        return PATHS_SET.some((p) => matchParts(p, path))\n            ? this.__internal__extractCompositeSet(lookupIndex, params, fields)\n            : this.__internal__extractFields(lookupIndex, fields);\n    }\n    /** @internal Extracts a ScaleInfo CompositeSet into TypeDef.Set */\n    __internal__extractCompositeSet(_, params, fields) {\n        if (params.length !== 1 || fields.length !== 1) {\n            throw new Error('Set handling expects param/field as single entries');\n        }\n        return withTypeString(this.registry, {\n            info: TypeDefInfo.Set,\n            length: this.registry.createTypeUnsafe(this.registry.createLookupType(fields[0].type), []).bitLength(),\n            sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(({ index, name }) => ({\n                // This will be an issue > 2^53 - 1 ... don't have those (yet)\n                index: index.toNumber(),\n                info: TypeDefInfo.Plain,\n                name: name.toString(),\n                type: 'Null'\n            }))\n        });\n    }\n    /** @internal Extracts ScaleInfo enum/struct fields into TypeDef.{Struct, Tuple} */\n    __internal__extractFields(lookupIndex, fields) {\n        let isStruct = true;\n        let isTuple = true;\n        const count = fields.length;\n        for (let f = 0; f < count; f++) {\n            const { name } = fields[f];\n            isStruct = isStruct && name.isSome;\n            isTuple = isTuple && name.isNone;\n        }\n        if (!isTuple && !isStruct) {\n            throw new Error('Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)');\n        }\n        if (count === 0) {\n            return {\n                info: TypeDefInfo.Null,\n                type: 'Null'\n            };\n        }\n        else if (isTuple && count === 1) {\n            const typeDef = this.__internal__createSiDef(fields[0].type);\n            return objectSpread({}, typeDef, lookupIndex === -1\n                ? null\n                : {\n                    lookupIndex,\n                    lookupName: this.__internal__names[lookupIndex],\n                    lookupNameRoot: typeDef.lookupName\n                }, fields[0].typeName.isSome\n                ? { typeName: sanitize(fields[0].typeName.unwrap()) }\n                : null);\n        }\n        const [sub, alias] = this.__internal__extractFieldsAlias(fields);\n        return withTypeString(this.registry, objectSpread({\n            info: isTuple // Tuple check first\n                ? TypeDefInfo.Tuple\n                : TypeDefInfo.Struct,\n            sub\n        }, alias.size\n            ? { alias }\n            : null, lookupIndex === -1\n            ? null\n            : {\n                lookupIndex,\n                lookupName: this.__internal__names[lookupIndex]\n            }));\n    }\n    /** @internal Apply field aliassed (with no JS conflicts) */\n    __internal__extractFieldsAlias(fields) {\n        const alias = new Map();\n        const count = fields.length;\n        const sub = new Array(count);\n        for (let i = 0; i < count; i++) {\n            const { docs, name, type, typeName } = fields[i];\n            const typeDef = this.__internal__createSiDef(type);\n            if (name.isNone) {\n                sub[i] = typeDef;\n            }\n            else {\n                const [nameField, nameOrig] = this.sanitizeField(name);\n                if (nameField && nameOrig) {\n                    alias.set(nameField, nameOrig);\n                }\n                sub[i] = objectSpread({\n                    docs: sanitizeDocs(docs),\n                    name: nameField\n                }, typeDef, typeName.isSome\n                    ? { typeName: sanitize(typeName.unwrap()) }\n                    : null);\n            }\n        }\n        return [sub, alias];\n    }\n    /** @internal Extracts an internal Historic (pre V14) type  */\n    __internal__extractHistoric(_, type) {\n        return objectSpread({\n            displayName: type.toString(),\n            isFromSi: true\n        }, getTypeDef(type));\n    }\n    /** @internal Extracts a ScaleInfo Primitive into TypeDef.Plain */\n    __internal__extractPrimitive(_, type) {\n        const typeStr = type.def.asPrimitive.type.toString();\n        return {\n            info: TypeDefInfo.Plain,\n            type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()\n        };\n    }\n    /** @internal Applies an alias path onto the TypeDef */\n    __internal__extractAliasPath(_, type) {\n        return {\n            info: TypeDefInfo.Plain,\n            type\n        };\n    }\n    /** @internal Extracts a ScaleInfo Sequence into TypeDef.Vec (with Bytes shortcut) */\n    __internal__extractSequence(lookupIndex, { type }) {\n        const sub = this.__internal__createSiDef(type);\n        if (sub.type === 'u8') {\n            return {\n                info: TypeDefInfo.Plain,\n                type: 'Bytes'\n            };\n        }\n        return withTypeString(this.registry, {\n            info: TypeDefInfo.Vec,\n            lookupIndex,\n            lookupName: this.__internal__names[lookupIndex],\n            sub\n        });\n    }\n    /** @internal Extracts a ScaleInfo Tuple into TypeDef.Tuple */\n    __internal__extractTuple(lookupIndex, ids) {\n        if (ids.length === 0) {\n            return {\n                info: TypeDefInfo.Null,\n                type: 'Null'\n            };\n        }\n        else if (ids.length === 1) {\n            return this.getTypeDef(ids[0]);\n        }\n        const sub = ids.map((t) => this.__internal__createSiDef(t));\n        return withTypeString(this.registry, {\n            info: TypeDefInfo.Tuple,\n            lookupIndex,\n            lookupName: this.__internal__names[lookupIndex],\n            sub\n        });\n    }\n    /** @internal Extracts a ScaleInfo Variant into TypeDef.{Option, Result, Enum} */\n    __internal__extractVariant(lookupIndex, { params, path }, { variants }) {\n        if (path.length) {\n            const specialVariant = path[0].toString();\n            if (specialVariant === 'Option') {\n                if (params.length !== 1) {\n                    throw new Error(`Option requires 1 parameter, found ${params.length}`);\n                }\n                // NOTE This is opt-in (unhandled), not by default\n                // if (sub.type === 'bool') {\n                //   return withTypeString(this.registry, {\n                //     info: TypeDefInfo.Plain,\n                //     type: 'OptionBool'\n                //   });\n                // }\n                return withTypeString(this.registry, {\n                    info: TypeDefInfo.Option,\n                    sub: this.__internal__createSiDef(params[0].type.unwrap())\n                });\n            }\n            else if (specialVariant === 'Result') {\n                if (params.length !== 2) {\n                    throw new Error(`Result requires 2 parameters, found ${params.length}`);\n                }\n                return withTypeString(this.registry, {\n                    info: TypeDefInfo.Result,\n                    sub: params.map(({ type }, index) => objectSpread({\n                        name: ['Ok', 'Error'][index]\n                    }, this.__internal__createSiDef(type.unwrap())))\n                });\n            }\n        }\n        if (variants.length === 0) {\n            return {\n                info: TypeDefInfo.Null,\n                type: 'Null'\n            };\n        }\n        return this.__internal__extractVariantEnum(lookupIndex, variants);\n    }\n    /** @internal Extracts a ScaleInfo Variant into TypeDef.Enum */\n    __internal__extractVariantEnum(lookupIndex, variants) {\n        const sub = [];\n        // we may get entries out of order, arrange them first before creating with gaps filled\n        // NOTE: Since we mutate, use a copy of the array as an input\n        variants\n            .slice()\n            .sort((a, b) => a.index.cmp(b.index))\n            .forEach(({ fields, index: bnIndex, name }) => {\n            const index = bnIndex.toNumber();\n            while (sub.length !== index) {\n                sub.push({\n                    index: sub.length,\n                    info: TypeDefInfo.Null,\n                    name: `__Unused${sub.length}`,\n                    type: 'Null'\n                });\n            }\n            sub.push(objectSpread(this.__internal__extractFields(-1, fields), {\n                index,\n                name: name.toString()\n            }));\n        });\n        return withTypeString(this.registry, {\n            info: TypeDefInfo.Enum,\n            lookupIndex,\n            lookupName: this.__internal__names[lookupIndex],\n            sub\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}