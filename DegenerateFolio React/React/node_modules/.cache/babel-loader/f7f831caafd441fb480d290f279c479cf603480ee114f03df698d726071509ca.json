{"ast":null,"code":"import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { firstMemo, memo } from '../util/index.js';\nfunction rewardDestinationCompat(rewardDestination) {\n  // We ensure the type is an Option by checking if isSome is a boolean. When isSome doesn't exist it will always return undefined.\n  return typeof rewardDestination.isSome === 'boolean' ? rewardDestination.unwrapOr(null) : rewardDestination;\n}\nfunction parseDetails(stashId, controllerIdOpt, nominatorsOpt, rewardDestinationOpts, validatorPrefs, exposure, stakingLedgerOpt) {\n  return {\n    accountId: stashId,\n    controllerId: (controllerIdOpt === null || controllerIdOpt === void 0 ? void 0 : controllerIdOpt.unwrapOr(null)) || null,\n    exposure,\n    nominators: nominatorsOpt.isSome ? nominatorsOpt.unwrap().targets : [],\n    rewardDestination: rewardDestinationCompat(rewardDestinationOpts),\n    stakingLedger: stakingLedgerOpt.unwrapOrDefault(),\n    stashId,\n    validatorPrefs\n  };\n}\nfunction getLedgers(api, optIds, _ref) {\n  let {\n    withLedger = false\n  } = _ref;\n  const ids = optIds.filter(o => withLedger && !!o && o.isSome).map(o => o.unwrap());\n  const emptyLed = api.registry.createType('Option<StakingLedger>');\n  return (ids.length ? combineLatest(ids.map(s => api.query.staking.ledger(s))) : of([])).pipe(map(optLedgers => {\n    let offset = -1;\n    return optIds.map(o => o && o.isSome ? optLedgers[++offset] || emptyLed : emptyLed);\n  }));\n}\nfunction getStashInfo(api, stashIds, activeEra, _ref2) {\n  let {\n    withController,\n    withDestination,\n    withExposure,\n    withLedger,\n    withNominations,\n    withPrefs\n  } = _ref2;\n  const emptyNoms = api.registry.createType('Option<Nominations>');\n  const emptyRewa = api.registry.createType('RewardDestination');\n  const emptyExpo = api.registry.createType('Exposure');\n  const emptyPrefs = api.registry.createType('ValidatorPrefs');\n  return combineLatest([withController || withLedger ? combineLatest(stashIds.map(s => api.query.staking.bonded(s))) : of(stashIds.map(() => null)), withNominations ? combineLatest(stashIds.map(s => api.query.staking.nominators(s))) : of(stashIds.map(() => emptyNoms)), withDestination ? combineLatest(stashIds.map(s => api.query.staking.payee(s))) : of(stashIds.map(() => emptyRewa)), withPrefs ? combineLatest(stashIds.map(s => api.query.staking.validators(s))) : of(stashIds.map(() => emptyPrefs)), withExposure ? combineLatest(stashIds.map(s => api.query.staking.erasStakers(activeEra, s))) : of(stashIds.map(() => emptyExpo))]);\n}\nfunction getBatch(api, activeEra, stashIds, flags) {\n  return getStashInfo(api, stashIds, activeEra, flags).pipe(switchMap(_ref3 => {\n    let [controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure] = _ref3;\n    return getLedgers(api, controllerIdOpt, flags).pipe(map(stakingLedgerOpts => stashIds.map((stashId, index) => parseDetails(stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index]))));\n  }));\n}\n/**\n * @description From a stash, retrieve the controllerId and all relevant details\n */\nexport const query = /*#__PURE__*/firstMemo((api, accountId, flags) => api.derive.staking.queryMulti([accountId], flags));\nexport function queryMulti(instanceId, api) {\n  return memo(instanceId, (accountIds, flags) => api.derive.session.indexes().pipe(switchMap(_ref4 => {\n    let {\n      activeEra\n    } = _ref4;\n    const stashIds = accountIds.map(a => api.registry.createType('AccountId', a));\n    return stashIds.length ? getBatch(api, activeEra, stashIds, flags) : of([]);\n  })));\n}","map":{"version":3,"names":["combineLatest","map","of","switchMap","firstMemo","memo","rewardDestinationCompat","rewardDestination","isSome","unwrapOr","parseDetails","stashId","controllerIdOpt","nominatorsOpt","rewardDestinationOpts","validatorPrefs","exposure","stakingLedgerOpt","accountId","controllerId","nominators","unwrap","targets","stakingLedger","unwrapOrDefault","getLedgers","api","optIds","_ref","withLedger","ids","filter","o","emptyLed","registry","createType","length","s","query","staking","ledger","pipe","optLedgers","offset","getStashInfo","stashIds","activeEra","_ref2","withController","withDestination","withExposure","withNominations","withPrefs","emptyNoms","emptyRewa","emptyExpo","emptyPrefs","bonded","payee","validators","erasStakers","getBatch","flags","_ref3","stakingLedgerOpts","index","derive","queryMulti","instanceId","accountIds","session","indexes","_ref4","a"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api-derive/staking/query.js"],"sourcesContent":["import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { firstMemo, memo } from '../util/index.js';\nfunction rewardDestinationCompat(rewardDestination) {\n    // We ensure the type is an Option by checking if isSome is a boolean. When isSome doesn't exist it will always return undefined.\n    return typeof rewardDestination.isSome === 'boolean'\n        ? rewardDestination.unwrapOr(null)\n        : rewardDestination;\n}\nfunction parseDetails(stashId, controllerIdOpt, nominatorsOpt, rewardDestinationOpts, validatorPrefs, exposure, stakingLedgerOpt) {\n    return {\n        accountId: stashId,\n        controllerId: controllerIdOpt?.unwrapOr(null) || null,\n        exposure,\n        nominators: nominatorsOpt.isSome\n            ? nominatorsOpt.unwrap().targets\n            : [],\n        rewardDestination: rewardDestinationCompat(rewardDestinationOpts),\n        stakingLedger: stakingLedgerOpt.unwrapOrDefault(),\n        stashId,\n        validatorPrefs\n    };\n}\nfunction getLedgers(api, optIds, { withLedger = false }) {\n    const ids = optIds\n        .filter((o) => withLedger && !!o && o.isSome)\n        .map((o) => o.unwrap());\n    const emptyLed = api.registry.createType('Option<StakingLedger>');\n    return (ids.length\n        ? combineLatest(ids.map((s) => api.query.staking.ledger(s)))\n        : of([])).pipe(map((optLedgers) => {\n        let offset = -1;\n        return optIds.map((o) => o && o.isSome\n            ? optLedgers[++offset] || emptyLed\n            : emptyLed);\n    }));\n}\nfunction getStashInfo(api, stashIds, activeEra, { withController, withDestination, withExposure, withLedger, withNominations, withPrefs }) {\n    const emptyNoms = api.registry.createType('Option<Nominations>');\n    const emptyRewa = api.registry.createType('RewardDestination');\n    const emptyExpo = api.registry.createType('Exposure');\n    const emptyPrefs = api.registry.createType('ValidatorPrefs');\n    return combineLatest([\n        withController || withLedger\n            ? combineLatest(stashIds.map((s) => api.query.staking.bonded(s)))\n            : of(stashIds.map(() => null)),\n        withNominations\n            ? combineLatest(stashIds.map((s) => api.query.staking.nominators(s)))\n            : of(stashIds.map(() => emptyNoms)),\n        withDestination\n            ? combineLatest(stashIds.map((s) => api.query.staking.payee(s)))\n            : of(stashIds.map(() => emptyRewa)),\n        withPrefs\n            ? combineLatest(stashIds.map((s) => api.query.staking.validators(s)))\n            : of(stashIds.map(() => emptyPrefs)),\n        withExposure\n            ? combineLatest(stashIds.map((s) => api.query.staking.erasStakers(activeEra, s)))\n            : of(stashIds.map(() => emptyExpo))\n    ]);\n}\nfunction getBatch(api, activeEra, stashIds, flags) {\n    return getStashInfo(api, stashIds, activeEra, flags).pipe(switchMap(([controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure]) => getLedgers(api, controllerIdOpt, flags).pipe(map((stakingLedgerOpts) => stashIds.map((stashId, index) => parseDetails(stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index]))))));\n}\n/**\n * @description From a stash, retrieve the controllerId and all relevant details\n */\nexport const query = /*#__PURE__*/ firstMemo((api, accountId, flags) => api.derive.staking.queryMulti([accountId], flags));\nexport function queryMulti(instanceId, api) {\n    return memo(instanceId, (accountIds, flags) => api.derive.session.indexes().pipe(switchMap(({ activeEra }) => {\n        const stashIds = accountIds.map((a) => api.registry.createType('AccountId', a));\n        return stashIds.length\n            ? getBatch(api, activeEra, stashIds, flags)\n            : of([]);\n    })));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}