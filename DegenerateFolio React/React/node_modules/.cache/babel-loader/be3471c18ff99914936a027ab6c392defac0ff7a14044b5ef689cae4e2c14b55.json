{"ast":null,"code":"\"use strict\";\n\nconst textureBatchBitGpuCache = {};\nfunction generateBindingSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n    src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n  } else {\n    let bindingIndex = 0;\n    for (let i = 0; i < maxTextures; i++) {\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n    }\n  }\n  return src.join(\"\\n\");\n}\nfunction generateSampleSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n  } else {\n    src.push(\"switch vTextureId {\");\n    for (let i = 0; i < maxTextures; i++) {\n      if (i === maxTextures - 1) {\n        src.push(`  default:{`);\n      } else {\n        src.push(`  case ${i}:{`);\n      }\n      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n      src.push(`      break;}`);\n    }\n    src.push(`}`);\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBit(maxTextures) {\n  if (!textureBatchBitGpuCache[maxTextures]) {\n    textureBatchBitGpuCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${generateBindingSrc(16)}\n            `,\n        main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${generateSampleSrc(16)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGpuCache[maxTextures];\n}\nconst textureBatchBitGlCache = {};\nfunction generateSampleGlSrc(maxTextures) {\n  const src = [];\n  for (let i = 0; i < maxTextures; i++) {\n    if (i > 0) {\n      src.push(\"else\");\n    }\n    if (i < maxTextures - 1) {\n      src.push(`if(vTextureId < ${i}.5)`);\n    }\n    src.push(\"{\");\n    src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n    src.push(\"}\");\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBitGl(maxTextures) {\n  if (!textureBatchBitGlCache[maxTextures]) {\n    textureBatchBitGlCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n        main: `\n    \n                ${generateSampleGlSrc(16)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGlCache[maxTextures];\n}\nexport { generateTextureBatchBit, generateTextureBatchBitGl };","map":{"version":3,"names":["textureBatchBitGpuCache","generateBindingSrc","maxTextures","src","push","bindingIndex","i","join","generateSampleSrc","generateTextureBatchBit","name","vertex","header","main","end","fragment","textureBatchBitGlCache","generateSampleGlSrc","generateTextureBatchBitGl"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts"],"sourcesContent":["import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${generateBindingSrc(16)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${generateSampleSrc(16)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n                main: `\n    \n                ${generateSampleGlSrc(16)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}