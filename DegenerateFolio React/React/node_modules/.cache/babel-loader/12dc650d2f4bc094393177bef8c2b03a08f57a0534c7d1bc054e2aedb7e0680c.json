{"ast":null,"code":"import { EventEmitter } from 'eventemitter3';\nimport { isError, isFunction, isObject, logger, noop, objectSpread } from '@polkadot/util';\nimport { RpcCoder } from '../coder/index.js';\nimport { healthChecker } from './Health.js';\nconst l = logger('api-substrate-connect');\nconst subscriptionUnsubscriptionMethods = new Map([['author_submitAndWatchExtrinsic', 'author_unwatchExtrinsic'], ['chain_subscribeAllHeads', 'chain_unsubscribeAllHeads'], ['chain_subscribeFinalizedHeads', 'chain_unsubscribeFinalizedHeads'], ['chain_subscribeFinalisedHeads', 'chain_subscribeFinalisedHeads'], ['chain_subscribeNewHeads', 'chain_unsubscribeNewHeads'], ['chain_subscribeNewHead', 'chain_unsubscribeNewHead'], ['chain_subscribeRuntimeVersion', 'chain_unsubscribeRuntimeVersion'], ['subscribe_newHead', 'unsubscribe_newHead'], ['state_subscribeRuntimeVersion', 'state_unsubscribeRuntimeVersion'], ['state_subscribeStorage', 'state_unsubscribeStorage']]);\nconst scClients = new WeakMap();\nexport class ScProvider {\n  __internal__Sc;\n  __internal__coder = new RpcCoder();\n  __internal__spec;\n  __internal__sharedSandbox;\n  __internal__subscriptions = new Map();\n  __internal__resubscribeMethods = new Map();\n  __internal__requests = new Map();\n  __internal__wellKnownChains;\n  __internal__eventemitter = new EventEmitter();\n  __internal__chain = null;\n  __internal__isChainReady = false;\n  constructor(Sc, spec, sharedSandbox) {\n    if (!isObject(Sc) || !isObject(Sc.WellKnownChain) || !isFunction(Sc.createScClient)) {\n      throw new Error('Expected an @substrate/connect interface as first parameter to ScProvider');\n    }\n    this.__internal__Sc = Sc;\n    this.__internal__spec = spec;\n    this.__internal__sharedSandbox = sharedSandbox;\n    this.__internal__wellKnownChains = new Set(Object.values(Sc.WellKnownChain));\n  }\n  get hasSubscriptions() {\n    // Indicates that subscriptions are supported\n    return !!true;\n  }\n  get isClonable() {\n    return !!false;\n  }\n  get isConnected() {\n    return !!this.__internal__chain && this.__internal__isChainReady;\n  }\n  clone() {\n    throw new Error('clone() is not supported.');\n  }\n  // Config details can be found in @substrate/connect repo following the link:\n  // https://github.com/paritytech/substrate-connect/blob/main/packages/connect/src/connector/index.ts\n  async connect(config, checkerFactory = healthChecker) {\n    if (this.isConnected) {\n      throw new Error('Already connected!');\n    }\n    // it could happen that after emitting `disconnected` due to the fact that\n    // smoldot is syncing, the consumer tries to reconnect after a certain amount\n    // of time... In which case we want to make sure that we don't create a new\n    // chain.\n    if (this.__internal__chain) {\n      await this.__internal__chain;\n      return;\n    }\n    if (this.__internal__sharedSandbox && !this.__internal__sharedSandbox.isConnected) {\n      await this.__internal__sharedSandbox.connect();\n    }\n    const client = this.__internal__sharedSandbox ? scClients.get(this.__internal__sharedSandbox) : this.__internal__Sc.createScClient(config);\n    if (!client) {\n      throw new Error('Unknown ScProvider!');\n    }\n    scClients.set(this, client);\n    const hc = checkerFactory();\n    const onResponse = res => {\n      const hcRes = hc.responsePassThrough(res);\n      if (!hcRes) {\n        return;\n      }\n      const response = JSON.parse(hcRes);\n      let decodedResponse;\n      try {\n        decodedResponse = this.__internal__coder.decodeResponse(response);\n      } catch (e) {\n        decodedResponse = e;\n      }\n      // It's not a subscription message, but rather a standar RPC response\n      if (response.params?.subscription === undefined || !response.method) {\n        return this.__internal__requests.get(response.id)?.(decodedResponse);\n      }\n      // We are dealing with a subscription message\n      const subscriptionId = `${response.method}::${response.params.subscription}`;\n      const callback = this.__internal__subscriptions.get(subscriptionId)?.[0];\n      callback?.(decodedResponse);\n    };\n    const addChain = this.__internal__sharedSandbox ? async (...args) => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const source = this.__internal__sharedSandbox;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return (await source.__internal__chain).addChain(...args);\n    } : this.__internal__wellKnownChains.has(this.__internal__spec) ? client.addWellKnownChain : client.addChain;\n    this.__internal__chain = addChain(this.__internal__spec, onResponse).then(chain => {\n      hc.setSendJsonRpc(chain.sendJsonRpc);\n      this.__internal__isChainReady = false;\n      const cleanup = () => {\n        // If there are any callbacks left, we have to reject/error them.\n        // Otherwise, that would cause a memory leak.\n        const disconnectionError = new Error('Disconnected');\n        this.__internal__requests.forEach(cb => cb(disconnectionError));\n        this.__internal__subscriptions.forEach(([cb]) => cb(disconnectionError));\n        this.__internal__subscriptions.clear();\n      };\n      const staleSubscriptions = [];\n      const killStaleSubscriptions = () => {\n        if (staleSubscriptions.length === 0) {\n          return;\n        }\n        const stale = staleSubscriptions.pop();\n        if (!stale) {\n          throw new Error('Unable to get stale subscription');\n        }\n        const {\n          id,\n          unsubscribeMethod\n        } = stale;\n        Promise.race([this.send(unsubscribeMethod, [id]).catch(noop), new Promise(resolve => setTimeout(resolve, 500))]).then(killStaleSubscriptions).catch(noop);\n      };\n      hc.start(health => {\n        const isReady = !health.isSyncing && (health.peers > 0 || !health.shouldHavePeers);\n        // if it's the same as before, then nothing has changed and we are done\n        if (this.__internal__isChainReady === isReady) {\n          return;\n        }\n        this.__internal__isChainReady = isReady;\n        if (!isReady) {\n          // If we've reached this point, that means that the chain used to be \"ready\"\n          // and now we are about to emit `disconnected`.\n          //\n          // This will cause the PolkadotJs API think that the connection is\n          // actually dead. In reality the smoldot chain is not dead, of course.\n          // However, we have to cleanup all the existing callbacks because when\n          // the smoldot chain stops syncing, then we will emit `connected` and\n          // the PolkadotJs API will try to re-create the previous\n          // subscriptions and requests. Although, now is not a good moment\n          // to be sending unsubscription messages to the smoldot chain, we\n          // should wait until is no longer syncing to send the unsubscription\n          // messages from the stale subscriptions of the previous connection.\n          //\n          // That's why -before we perform the cleanup of `this.__internal__subscriptions`-\n          // we keep the necessary information that we will need later on to\n          // kill the stale subscriptions.\n          [...this.__internal__subscriptions.values()].forEach(s => {\n            staleSubscriptions.push(s[1]);\n          });\n          cleanup();\n          this.__internal__eventemitter.emit('disconnected');\n        } else {\n          killStaleSubscriptions();\n          this.__internal__eventemitter.emit('connected');\n          if (this.__internal__resubscribeMethods.size) {\n            this.__internal__resubscribe();\n          }\n        }\n      });\n      return objectSpread({}, chain, {\n        remove: () => {\n          hc.stop();\n          chain.remove();\n          cleanup();\n        },\n        sendJsonRpc: hc.sendJsonRpc.bind(hc)\n      });\n    });\n    try {\n      await this.__internal__chain;\n    } catch (e) {\n      this.__internal__chain = null;\n      this.__internal__eventemitter.emit('error', e);\n      throw e;\n    }\n  }\n  __internal__resubscribe = () => {\n    const promises = [];\n    this.__internal__resubscribeMethods.forEach(subDetails => {\n      // only re-create subscriptions which are not in author (only area where\n      // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n      // are not included (and will not be re-broadcast)\n      if (subDetails.type.startsWith('author_')) {\n        return;\n      }\n      try {\n        const promise = new Promise(resolve => {\n          this.subscribe(subDetails.type, subDetails.method, subDetails.params, subDetails.callback).catch(error => console.log(error));\n          resolve();\n        });\n        promises.push(promise);\n      } catch (error) {\n        l.error(error);\n      }\n    });\n    Promise.all(promises).catch(err => l.log(err));\n  };\n  async disconnect() {\n    if (!this.__internal__chain) {\n      return;\n    }\n    const chain = await this.__internal__chain;\n    this.__internal__chain = null;\n    this.__internal__isChainReady = false;\n    try {\n      chain.remove();\n    } catch (_) {}\n    this.__internal__eventemitter.emit('disconnected');\n  }\n  on(type, sub) {\n    // It's possible. Although, quite unlikely, that by the time that polkadot\n    // subscribes to the `connected` event, the Provider is already connected.\n    // In that case, we must emit to let the consumer know that we are connected.\n    if (type === 'connected' && this.isConnected) {\n      sub();\n    }\n    this.__internal__eventemitter.on(type, sub);\n    return () => {\n      this.__internal__eventemitter.removeListener(type, sub);\n    };\n  }\n  async send(method, params) {\n    if (!this.isConnected || !this.__internal__chain) {\n      throw new Error('Provider is not connected');\n    }\n    const chain = await this.__internal__chain;\n    const [id, json] = this.__internal__coder.encodeJson(method, params);\n    const result = new Promise((resolve, reject) => {\n      this.__internal__requests.set(id, response => {\n        (isError(response) ? reject : resolve)(response);\n      });\n      try {\n        chain.sendJsonRpc(json);\n      } catch (e) {\n        this.__internal__chain = null;\n        try {\n          chain.remove();\n        } catch (_) {}\n        this.__internal__eventemitter.emit('error', e);\n      }\n    });\n    try {\n      return await result;\n    } finally {\n      // let's ensure that once the Promise is resolved/rejected, then we remove\n      // remove its entry from the internal #requests\n      this.__internal__requests.delete(id);\n    }\n  }\n  async subscribe(type, method, params, callback) {\n    if (!subscriptionUnsubscriptionMethods.has(method)) {\n      throw new Error(`Unsupported subscribe method: ${method}`);\n    }\n    const id = await this.send(method, params);\n    const subscriptionId = `${type}::${id}`;\n    const cb = response => {\n      if (response instanceof Error) {\n        callback(response, undefined);\n      } else {\n        callback(null, response);\n      }\n    };\n    const unsubscribeMethod = subscriptionUnsubscriptionMethods.get(method);\n    if (!unsubscribeMethod) {\n      throw new Error('Invalid unsubscribe method found');\n    }\n    this.__internal__resubscribeMethods.set(subscriptionId, {\n      callback,\n      method,\n      params,\n      type\n    });\n    this.__internal__subscriptions.set(subscriptionId, [cb, {\n      id,\n      unsubscribeMethod\n    }]);\n    return id;\n  }\n  unsubscribe(type, method, id) {\n    if (!this.isConnected) {\n      throw new Error('Provider is not connected');\n    }\n    const subscriptionId = `${type}::${id}`;\n    if (!this.__internal__subscriptions.has(subscriptionId)) {\n      return Promise.reject(new Error(`Unable to find active subscription=${subscriptionId}`));\n    }\n    this.__internal__resubscribeMethods.delete(subscriptionId);\n    this.__internal__subscriptions.delete(subscriptionId);\n    return this.send(method, [id]);\n  }\n}","map":{"version":3,"names":["EventEmitter","isError","isFunction","isObject","logger","noop","objectSpread","RpcCoder","healthChecker","l","subscriptionUnsubscriptionMethods","Map","scClients","WeakMap","ScProvider","__internal__Sc","__internal__coder","__internal__spec","__internal__sharedSandbox","__internal__subscriptions","__internal__resubscribeMethods","__internal__requests","__internal__wellKnownChains","__internal__eventemitter","__internal__chain","__internal__isChainReady","constructor","Sc","spec","sharedSandbox","WellKnownChain","createScClient","Error","Set","Object","values","hasSubscriptions","isClonable","isConnected","clone","connect","config","checkerFactory","client","get","set","hc","onResponse","res","hcRes","responsePassThrough","response","JSON","parse","decodedResponse","decodeResponse","e","params","subscription","undefined","method","id","subscriptionId","callback","addChain","args","source","has","addWellKnownChain","then","chain","setSendJsonRpc","sendJsonRpc","cleanup","disconnectionError","forEach","cb","clear","staleSubscriptions","killStaleSubscriptions","length","stale","pop","unsubscribeMethod","Promise","race","send","catch","resolve","setTimeout","start","health","isReady","isSyncing","peers","shouldHavePeers","s","push","emit","size","__internal__resubscribe","remove","stop","bind","promises","subDetails","type","startsWith","promise","subscribe","error","console","log","all","err","disconnect","_","on","sub","removeListener","json","encodeJson","result","reject","delete","unsubscribe"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/rpc-provider/substrate-connect/index.js"],"sourcesContent":["import { EventEmitter } from 'eventemitter3';\nimport { isError, isFunction, isObject, logger, noop, objectSpread } from '@polkadot/util';\nimport { RpcCoder } from '../coder/index.js';\nimport { healthChecker } from './Health.js';\nconst l = logger('api-substrate-connect');\nconst subscriptionUnsubscriptionMethods = new Map([\n    ['author_submitAndWatchExtrinsic', 'author_unwatchExtrinsic'],\n    ['chain_subscribeAllHeads', 'chain_unsubscribeAllHeads'],\n    ['chain_subscribeFinalizedHeads', 'chain_unsubscribeFinalizedHeads'],\n    ['chain_subscribeFinalisedHeads', 'chain_subscribeFinalisedHeads'],\n    ['chain_subscribeNewHeads', 'chain_unsubscribeNewHeads'],\n    ['chain_subscribeNewHead', 'chain_unsubscribeNewHead'],\n    ['chain_subscribeRuntimeVersion', 'chain_unsubscribeRuntimeVersion'],\n    ['subscribe_newHead', 'unsubscribe_newHead'],\n    ['state_subscribeRuntimeVersion', 'state_unsubscribeRuntimeVersion'],\n    ['state_subscribeStorage', 'state_unsubscribeStorage']\n]);\nconst scClients = new WeakMap();\nexport class ScProvider {\n    __internal__Sc;\n    __internal__coder = new RpcCoder();\n    __internal__spec;\n    __internal__sharedSandbox;\n    __internal__subscriptions = new Map();\n    __internal__resubscribeMethods = new Map();\n    __internal__requests = new Map();\n    __internal__wellKnownChains;\n    __internal__eventemitter = new EventEmitter();\n    __internal__chain = null;\n    __internal__isChainReady = false;\n    constructor(Sc, spec, sharedSandbox) {\n        if (!isObject(Sc) || !isObject(Sc.WellKnownChain) || !isFunction(Sc.createScClient)) {\n            throw new Error('Expected an @substrate/connect interface as first parameter to ScProvider');\n        }\n        this.__internal__Sc = Sc;\n        this.__internal__spec = spec;\n        this.__internal__sharedSandbox = sharedSandbox;\n        this.__internal__wellKnownChains = new Set(Object.values(Sc.WellKnownChain));\n    }\n    get hasSubscriptions() {\n        // Indicates that subscriptions are supported\n        return !!true;\n    }\n    get isClonable() {\n        return !!false;\n    }\n    get isConnected() {\n        return !!this.__internal__chain && this.__internal__isChainReady;\n    }\n    clone() {\n        throw new Error('clone() is not supported.');\n    }\n    // Config details can be found in @substrate/connect repo following the link:\n    // https://github.com/paritytech/substrate-connect/blob/main/packages/connect/src/connector/index.ts\n    async connect(config, checkerFactory = healthChecker) {\n        if (this.isConnected) {\n            throw new Error('Already connected!');\n        }\n        // it could happen that after emitting `disconnected` due to the fact that\n        // smoldot is syncing, the consumer tries to reconnect after a certain amount\n        // of time... In which case we want to make sure that we don't create a new\n        // chain.\n        if (this.__internal__chain) {\n            await this.__internal__chain;\n            return;\n        }\n        if (this.__internal__sharedSandbox && !this.__internal__sharedSandbox.isConnected) {\n            await this.__internal__sharedSandbox.connect();\n        }\n        const client = this.__internal__sharedSandbox\n            ? scClients.get(this.__internal__sharedSandbox)\n            : this.__internal__Sc.createScClient(config);\n        if (!client) {\n            throw new Error('Unknown ScProvider!');\n        }\n        scClients.set(this, client);\n        const hc = checkerFactory();\n        const onResponse = (res) => {\n            const hcRes = hc.responsePassThrough(res);\n            if (!hcRes) {\n                return;\n            }\n            const response = JSON.parse(hcRes);\n            let decodedResponse;\n            try {\n                decodedResponse = this.__internal__coder.decodeResponse(response);\n            }\n            catch (e) {\n                decodedResponse = e;\n            }\n            // It's not a subscription message, but rather a standar RPC response\n            if (response.params?.subscription === undefined || !response.method) {\n                return this.__internal__requests.get(response.id)?.(decodedResponse);\n            }\n            // We are dealing with a subscription message\n            const subscriptionId = `${response.method}::${response.params.subscription}`;\n            const callback = this.__internal__subscriptions.get(subscriptionId)?.[0];\n            callback?.(decodedResponse);\n        };\n        const addChain = this.__internal__sharedSandbox\n            ? (async (...args) => {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const source = this.__internal__sharedSandbox;\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                return (await source.__internal__chain).addChain(...args);\n            })\n            : this.__internal__wellKnownChains.has(this.__internal__spec)\n                ? client.addWellKnownChain\n                : client.addChain;\n        this.__internal__chain = addChain(this.__internal__spec, onResponse).then((chain) => {\n            hc.setSendJsonRpc(chain.sendJsonRpc);\n            this.__internal__isChainReady = false;\n            const cleanup = () => {\n                // If there are any callbacks left, we have to reject/error them.\n                // Otherwise, that would cause a memory leak.\n                const disconnectionError = new Error('Disconnected');\n                this.__internal__requests.forEach((cb) => cb(disconnectionError));\n                this.__internal__subscriptions.forEach(([cb]) => cb(disconnectionError));\n                this.__internal__subscriptions.clear();\n            };\n            const staleSubscriptions = [];\n            const killStaleSubscriptions = () => {\n                if (staleSubscriptions.length === 0) {\n                    return;\n                }\n                const stale = staleSubscriptions.pop();\n                if (!stale) {\n                    throw new Error('Unable to get stale subscription');\n                }\n                const { id, unsubscribeMethod } = stale;\n                Promise\n                    .race([\n                    this.send(unsubscribeMethod, [id]).catch(noop),\n                    new Promise((resolve) => setTimeout(resolve, 500))\n                ])\n                    .then(killStaleSubscriptions)\n                    .catch(noop);\n            };\n            hc.start((health) => {\n                const isReady = !health.isSyncing && (health.peers > 0 || !health.shouldHavePeers);\n                // if it's the same as before, then nothing has changed and we are done\n                if (this.__internal__isChainReady === isReady) {\n                    return;\n                }\n                this.__internal__isChainReady = isReady;\n                if (!isReady) {\n                    // If we've reached this point, that means that the chain used to be \"ready\"\n                    // and now we are about to emit `disconnected`.\n                    //\n                    // This will cause the PolkadotJs API think that the connection is\n                    // actually dead. In reality the smoldot chain is not dead, of course.\n                    // However, we have to cleanup all the existing callbacks because when\n                    // the smoldot chain stops syncing, then we will emit `connected` and\n                    // the PolkadotJs API will try to re-create the previous\n                    // subscriptions and requests. Although, now is not a good moment\n                    // to be sending unsubscription messages to the smoldot chain, we\n                    // should wait until is no longer syncing to send the unsubscription\n                    // messages from the stale subscriptions of the previous connection.\n                    //\n                    // That's why -before we perform the cleanup of `this.__internal__subscriptions`-\n                    // we keep the necessary information that we will need later on to\n                    // kill the stale subscriptions.\n                    [...this.__internal__subscriptions.values()].forEach((s) => {\n                        staleSubscriptions.push(s[1]);\n                    });\n                    cleanup();\n                    this.__internal__eventemitter.emit('disconnected');\n                }\n                else {\n                    killStaleSubscriptions();\n                    this.__internal__eventemitter.emit('connected');\n                    if (this.__internal__resubscribeMethods.size) {\n                        this.__internal__resubscribe();\n                    }\n                }\n            });\n            return objectSpread({}, chain, {\n                remove: () => {\n                    hc.stop();\n                    chain.remove();\n                    cleanup();\n                },\n                sendJsonRpc: hc.sendJsonRpc.bind(hc)\n            });\n        });\n        try {\n            await this.__internal__chain;\n        }\n        catch (e) {\n            this.__internal__chain = null;\n            this.__internal__eventemitter.emit('error', e);\n            throw e;\n        }\n    }\n    __internal__resubscribe = () => {\n        const promises = [];\n        this.__internal__resubscribeMethods.forEach((subDetails) => {\n            // only re-create subscriptions which are not in author (only area where\n            // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n            // are not included (and will not be re-broadcast)\n            if (subDetails.type.startsWith('author_')) {\n                return;\n            }\n            try {\n                const promise = new Promise((resolve) => {\n                    this.subscribe(subDetails.type, subDetails.method, subDetails.params, subDetails.callback).catch((error) => console.log(error));\n                    resolve();\n                });\n                promises.push(promise);\n            }\n            catch (error) {\n                l.error(error);\n            }\n        });\n        Promise.all(promises).catch((err) => l.log(err));\n    };\n    async disconnect() {\n        if (!this.__internal__chain) {\n            return;\n        }\n        const chain = await this.__internal__chain;\n        this.__internal__chain = null;\n        this.__internal__isChainReady = false;\n        try {\n            chain.remove();\n        }\n        catch (_) { }\n        this.__internal__eventemitter.emit('disconnected');\n    }\n    on(type, sub) {\n        // It's possible. Although, quite unlikely, that by the time that polkadot\n        // subscribes to the `connected` event, the Provider is already connected.\n        // In that case, we must emit to let the consumer know that we are connected.\n        if (type === 'connected' && this.isConnected) {\n            sub();\n        }\n        this.__internal__eventemitter.on(type, sub);\n        return () => {\n            this.__internal__eventemitter.removeListener(type, sub);\n        };\n    }\n    async send(method, params) {\n        if (!this.isConnected || !this.__internal__chain) {\n            throw new Error('Provider is not connected');\n        }\n        const chain = await this.__internal__chain;\n        const [id, json] = this.__internal__coder.encodeJson(method, params);\n        const result = new Promise((resolve, reject) => {\n            this.__internal__requests.set(id, (response) => {\n                (isError(response) ? reject : resolve)(response);\n            });\n            try {\n                chain.sendJsonRpc(json);\n            }\n            catch (e) {\n                this.__internal__chain = null;\n                try {\n                    chain.remove();\n                }\n                catch (_) { }\n                this.__internal__eventemitter.emit('error', e);\n            }\n        });\n        try {\n            return await result;\n        }\n        finally {\n            // let's ensure that once the Promise is resolved/rejected, then we remove\n            // remove its entry from the internal #requests\n            this.__internal__requests.delete(id);\n        }\n    }\n    async subscribe(type, method, params, callback) {\n        if (!subscriptionUnsubscriptionMethods.has(method)) {\n            throw new Error(`Unsupported subscribe method: ${method}`);\n        }\n        const id = await this.send(method, params);\n        const subscriptionId = `${type}::${id}`;\n        const cb = (response) => {\n            if (response instanceof Error) {\n                callback(response, undefined);\n            }\n            else {\n                callback(null, response);\n            }\n        };\n        const unsubscribeMethod = subscriptionUnsubscriptionMethods.get(method);\n        if (!unsubscribeMethod) {\n            throw new Error('Invalid unsubscribe method found');\n        }\n        this.__internal__resubscribeMethods.set(subscriptionId, { callback, method, params, type });\n        this.__internal__subscriptions.set(subscriptionId, [cb, { id, unsubscribeMethod }]);\n        return id;\n    }\n    unsubscribe(type, method, id) {\n        if (!this.isConnected) {\n            throw new Error('Provider is not connected');\n        }\n        const subscriptionId = `${type}::${id}`;\n        if (!this.__internal__subscriptions.has(subscriptionId)) {\n            return Promise.reject(new Error(`Unable to find active subscription=${subscriptionId}`));\n        }\n        this.__internal__resubscribeMethods.delete(subscriptionId);\n        this.__internal__subscriptions.delete(subscriptionId);\n        return this.send(method, [id]);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}