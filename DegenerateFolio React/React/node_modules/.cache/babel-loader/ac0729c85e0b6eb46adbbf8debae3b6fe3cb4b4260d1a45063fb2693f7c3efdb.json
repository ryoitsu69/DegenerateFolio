{"ast":null,"code":"import { isBoolean, isHex, isObject, isU8a, isUndefined, objectProperties, stringCamelCase, stringify, u8aConcatStrict, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { compareMap, decodeU8aStruct, mapToTypeMap, typesToMap } from '../utils/index.js';\nfunction noopSetDefinition(d) {\n  return d;\n}\n/** @internal */\nfunction decodeStructFromObject(registry, [Types, keys], value, jsonMap) {\n  let jsonObj;\n  const typeofArray = Array.isArray(value);\n  const typeofMap = value instanceof Map;\n  const count = keys.length;\n  if (!typeofArray && !typeofMap && !isObject(value)) {\n    throw new Error(`Struct: Cannot decode value ${stringify(value)} (typeof ${typeof value}), expected an input object, map or array`);\n  } else if (typeofArray && value.length !== count) {\n    throw new Error(`Struct: Unable to map ${stringify(value)} array to object with known keys ${keys.join(', ')}`);\n  }\n  const raw = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const key = keys[i];\n    const jsonKey = jsonMap.get(key) || key;\n    const Type = Types[i];\n    let assign;\n    try {\n      if (typeofArray) {\n        assign = value[i];\n      } else if (typeofMap) {\n        assign = jsonKey && value.get(jsonKey);\n      } else {\n        assign = jsonKey && value[jsonKey];\n        if (isUndefined(assign)) {\n          if (isUndefined(jsonObj)) {\n            const entries = Object.entries(value);\n            jsonObj = {};\n            for (let e = 0, ecount = entries.length; e < ecount; e++) {\n              jsonObj[stringCamelCase(entries[e][0])] = entries[e][1];\n            }\n          }\n          assign = jsonKey && jsonObj[jsonKey];\n        }\n      }\n      raw[i] = [key, assign instanceof Type ? assign : new Type(registry, assign)];\n    } catch (error) {\n      let type = Type.name;\n      try {\n        type = new Type(registry).toRawType();\n      } catch {\n        // ignore\n      }\n      throw new Error(`Struct: failed on ${jsonKey}: ${type}:: ${error.message}`);\n    }\n  }\n  return [raw, 0];\n}\n/**\n * @name Struct\n * @description\n * A Struct defines an Object with key-value pairs - where the values are Codec values. It removes\n * a lot of repetition from the actual coding, define a structure type, pass it the key/Codec\n * values in the constructor and it manages the decoding. It is important that the constructor\n * values matches 100% to the order in th Rust code, i.e. don't go crazy and make it alphabetical,\n * it needs to decoded in the specific defined order.\n * @noInheritDoc\n */\nexport class Struct extends Map {\n  registry;\n  createdAtHash;\n  initialU8aLength;\n  isStorageFallback;\n  __internal__jsonMap;\n  __internal__Types;\n  constructor(registry, Types, value, jsonMap = new Map(), {\n    definition,\n    setDefinition = noopSetDefinition\n  } = {}) {\n    const typeMap = definition || setDefinition(mapToTypeMap(registry, Types));\n    const [decoded, decodedLength] = isU8a(value) || isHex(value) ? decodeU8aStruct(registry, new Array(typeMap[0].length), u8aToU8a(value), typeMap) : value instanceof Struct ? [value, 0] : decodeStructFromObject(registry, typeMap, value || {}, jsonMap);\n    super(decoded);\n    this.initialU8aLength = decodedLength;\n    this.registry = registry;\n    this.__internal__jsonMap = jsonMap;\n    this.__internal__Types = typeMap;\n  }\n  static with(Types, jsonMap) {\n    let definition;\n    // eslint-disable-next-line no-return-assign\n    const setDefinition = d => definition = d;\n    return class extends Struct {\n      static {\n        const keys = Object.keys(Types);\n        objectProperties(this.prototype, keys, (k, _, self) => self.get(k));\n      }\n      constructor(registry, value) {\n        super(registry, Types, value, jsonMap, {\n          definition,\n          setDefinition\n        });\n      }\n    };\n  }\n  /**\n   * @description The available keys for this struct\n   */\n  get defKeys() {\n    return this.__internal__Types[1];\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n  get isEmpty() {\n    for (const v of this.values()) {\n      if (!v.isEmpty) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    let total = 0;\n    for (const v of this.values()) {\n      total += v.encodedLength;\n    }\n    return total;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Returns the Type description of the structure\n   */\n  get Type() {\n    const result = {};\n    const [Types, keys] = this.__internal__Types;\n    for (let i = 0, count = keys.length; i < count; i++) {\n      result[keys[i]] = new Types[i](this.registry).toRawType();\n    }\n    return result;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return compareMap(this, other);\n  }\n  /**\n   * @description Returns a specific names entry in the structure\n   * @param key The name of the entry to retrieve\n   */\n  get(key) {\n    return super.get(key);\n  }\n  /**\n   * @description Returns the values of a member at a specific index (Rather use get(name) for performance)\n   */\n  getAtIndex(index) {\n    return this.toArray()[index];\n  }\n  /**\n   * @description Returns the a types value by name\n   */\n  getT(key) {\n    return super.get(key);\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect(isBare) {\n    const inner = [];\n    for (const [k, v] of this.entries()) {\n      inner.push({\n        ...v.inspect(!isBare || isBoolean(isBare) ? isBare : isBare[k]),\n        name: stringCamelCase(k)\n      });\n    }\n    return {\n      inner\n    };\n  }\n  /**\n   * @description Converts the Object to an standard JavaScript Array\n   */\n  toArray() {\n    return [...this.values()];\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExtended, disableAscii) {\n    const json = {};\n    for (const [k, v] of this.entries()) {\n      json[k] = v.toHuman(isExtended, disableAscii);\n    }\n    return json;\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    const json = {};\n    for (const [k, v] of this.entries()) {\n      // Here we pull out the entry against the JSON mapping (if supplied)\n      // since this representation goes over RPC and needs to be correct\n      json[this.__internal__jsonMap.get(k) || k] = v.toJSON();\n    }\n    return json;\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive(disableAscii) {\n    const json = {};\n    for (const [k, v] of this.entries()) {\n      json[k] = v.toPrimitive(disableAscii);\n    }\n    return json;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return stringify(typesToMap(this.registry, this.__internal__Types));\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    const encoded = [];\n    for (const [k, v] of this.entries()) {\n      encoded.push(v.toU8a(!isBare || isBoolean(isBare) ? isBare : isBare[k]));\n    }\n    return u8aConcatStrict(encoded);\n  }\n}","map":{"version":3,"names":["isBoolean","isHex","isObject","isU8a","isUndefined","objectProperties","stringCamelCase","stringify","u8aConcatStrict","u8aToHex","u8aToU8a","compareMap","decodeU8aStruct","mapToTypeMap","typesToMap","noopSetDefinition","d","decodeStructFromObject","registry","Types","keys","value","jsonMap","jsonObj","typeofArray","Array","isArray","typeofMap","Map","count","length","Error","join","raw","i","key","jsonKey","get","Type","assign","entries","Object","e","ecount","error","type","name","toRawType","message","Struct","createdAtHash","initialU8aLength","isStorageFallback","__internal__jsonMap","__internal__Types","constructor","definition","setDefinition","typeMap","decoded","decodedLength","with","prototype","k","_","self","defKeys","isEmpty","v","values","encodedLength","total","hash","toU8a","result","eq","other","getAtIndex","index","toArray","getT","inspect","isBare","inner","push","toHex","toHuman","isExtended","disableAscii","json","toJSON","toPrimitive","toString","encoded"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/native/Struct.js"],"sourcesContent":["import { isBoolean, isHex, isObject, isU8a, isUndefined, objectProperties, stringCamelCase, stringify, u8aConcatStrict, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { compareMap, decodeU8aStruct, mapToTypeMap, typesToMap } from '../utils/index.js';\nfunction noopSetDefinition(d) {\n    return d;\n}\n/** @internal */\nfunction decodeStructFromObject(registry, [Types, keys], value, jsonMap) {\n    let jsonObj;\n    const typeofArray = Array.isArray(value);\n    const typeofMap = value instanceof Map;\n    const count = keys.length;\n    if (!typeofArray && !typeofMap && !isObject(value)) {\n        throw new Error(`Struct: Cannot decode value ${stringify(value)} (typeof ${typeof value}), expected an input object, map or array`);\n    }\n    else if (typeofArray && value.length !== count) {\n        throw new Error(`Struct: Unable to map ${stringify(value)} array to object with known keys ${keys.join(', ')}`);\n    }\n    const raw = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const key = keys[i];\n        const jsonKey = jsonMap.get(key) || key;\n        const Type = Types[i];\n        let assign;\n        try {\n            if (typeofArray) {\n                assign = value[i];\n            }\n            else if (typeofMap) {\n                assign = jsonKey && value.get(jsonKey);\n            }\n            else {\n                assign = jsonKey && value[jsonKey];\n                if (isUndefined(assign)) {\n                    if (isUndefined(jsonObj)) {\n                        const entries = Object.entries(value);\n                        jsonObj = {};\n                        for (let e = 0, ecount = entries.length; e < ecount; e++) {\n                            jsonObj[stringCamelCase(entries[e][0])] = entries[e][1];\n                        }\n                    }\n                    assign = jsonKey && jsonObj[jsonKey];\n                }\n            }\n            raw[i] = [\n                key,\n                assign instanceof Type\n                    ? assign\n                    : new Type(registry, assign)\n            ];\n        }\n        catch (error) {\n            let type = Type.name;\n            try {\n                type = new Type(registry).toRawType();\n            }\n            catch {\n                // ignore\n            }\n            throw new Error(`Struct: failed on ${jsonKey}: ${type}:: ${error.message}`);\n        }\n    }\n    return [raw, 0];\n}\n/**\n * @name Struct\n * @description\n * A Struct defines an Object with key-value pairs - where the values are Codec values. It removes\n * a lot of repetition from the actual coding, define a structure type, pass it the key/Codec\n * values in the constructor and it manages the decoding. It is important that the constructor\n * values matches 100% to the order in th Rust code, i.e. don't go crazy and make it alphabetical,\n * it needs to decoded in the specific defined order.\n * @noInheritDoc\n */\nexport class Struct extends Map {\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    __internal__jsonMap;\n    __internal__Types;\n    constructor(registry, Types, value, jsonMap = new Map(), { definition, setDefinition = noopSetDefinition } = {}) {\n        const typeMap = definition || setDefinition(mapToTypeMap(registry, Types));\n        const [decoded, decodedLength] = isU8a(value) || isHex(value)\n            ? decodeU8aStruct(registry, new Array(typeMap[0].length), u8aToU8a(value), typeMap)\n            : value instanceof Struct\n                ? [value, 0]\n                : decodeStructFromObject(registry, typeMap, value || {}, jsonMap);\n        super(decoded);\n        this.initialU8aLength = decodedLength;\n        this.registry = registry;\n        this.__internal__jsonMap = jsonMap;\n        this.__internal__Types = typeMap;\n    }\n    static with(Types, jsonMap) {\n        let definition;\n        // eslint-disable-next-line no-return-assign\n        const setDefinition = (d) => definition = d;\n        return class extends Struct {\n            static {\n                const keys = Object.keys(Types);\n                objectProperties(this.prototype, keys, (k, _, self) => self.get(k));\n            }\n            constructor(registry, value) {\n                super(registry, Types, value, jsonMap, { definition, setDefinition });\n            }\n        };\n    }\n    /**\n     * @description The available keys for this struct\n     */\n    get defKeys() {\n        return this.__internal__Types[1];\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        for (const v of this.values()) {\n            if (!v.isEmpty) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        let total = 0;\n        for (const v of this.values()) {\n            total += v.encodedLength;\n        }\n        return total;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Returns the Type description of the structure\n     */\n    get Type() {\n        const result = {};\n        const [Types, keys] = this.__internal__Types;\n        for (let i = 0, count = keys.length; i < count; i++) {\n            result[keys[i]] = new Types[i](this.registry).toRawType();\n        }\n        return result;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return compareMap(this, other);\n    }\n    /**\n     * @description Returns a specific names entry in the structure\n     * @param key The name of the entry to retrieve\n     */\n    get(key) {\n        return super.get(key);\n    }\n    /**\n     * @description Returns the values of a member at a specific index (Rather use get(name) for performance)\n     */\n    getAtIndex(index) {\n        return this.toArray()[index];\n    }\n    /**\n     * @description Returns the a types value by name\n     */\n    getT(key) {\n        return super.get(key);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect(isBare) {\n        const inner = [];\n        for (const [k, v] of this.entries()) {\n            inner.push({\n                ...v.inspect(!isBare || isBoolean(isBare)\n                    ? isBare\n                    : isBare[k]),\n                name: stringCamelCase(k)\n            });\n        }\n        return {\n            inner\n        };\n    }\n    /**\n     * @description Converts the Object to an standard JavaScript Array\n     */\n    toArray() {\n        return [...this.values()];\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExtended, disableAscii) {\n        const json = {};\n        for (const [k, v] of this.entries()) {\n            json[k] = v.toHuman(isExtended, disableAscii);\n        }\n        return json;\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        const json = {};\n        for (const [k, v] of this.entries()) {\n            // Here we pull out the entry against the JSON mapping (if supplied)\n            // since this representation goes over RPC and needs to be correct\n            json[(this.__internal__jsonMap.get(k) || k)] = v.toJSON();\n        }\n        return json;\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive(disableAscii) {\n        const json = {};\n        for (const [k, v] of this.entries()) {\n            json[k] = v.toPrimitive(disableAscii);\n        }\n        return json;\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return stringify(typesToMap(this.registry, this.__internal__Types));\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return stringify(this.toJSON());\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        const encoded = [];\n        for (const [k, v] of this.entries()) {\n            encoded.push(v.toU8a(!isBare || isBoolean(isBare)\n                ? isBare\n                : isBare[k]));\n        }\n        return u8aConcatStrict(encoded);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}