{"ast":null,"code":"import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform.mjs';\nimport { BatchableMesh } from './BatchableMesh.mjs';\n\"use strict\";\nclass MeshPipe {\n  constructor(renderer, adaptor) {\n    this.localUniforms = new UniformGroup({\n      uTransformMatrix: {\n        value: new Matrix(),\n        type: \"mat3x3<f32>\"\n      },\n      uColor: {\n        value: new Float32Array([1, 1, 1, 1]),\n        type: \"vec4<f32>\"\n      },\n      uRound: {\n        value: 0,\n        type: \"f32\"\n      }\n    });\n    this.localUniformsBindGroup = new BindGroup({\n      0: this.localUniforms\n    });\n    this._meshDataHash = /* @__PURE__ */Object.create(null);\n    this._gpuBatchableMeshHash = /* @__PURE__ */Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(mesh) {\n    const meshData = this._getMeshData(mesh);\n    const wasBatched = meshData.batched;\n    const isBatched = mesh.batched;\n    meshData.batched = isBatched;\n    if (wasBatched !== isBatched) {\n      return true;\n    } else if (isBatched) {\n      const geometry = mesh._geometry;\n      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n        meshData.indexSize = geometry.indices.length;\n        meshData.vertexSize = geometry.positions.length;\n        return true;\n      }\n      const batchableMesh = this._getBatchableMesh(mesh);\n      const texture = mesh.texture;\n      if (batchableMesh.texture._source !== texture._source) {\n        if (batchableMesh.texture._source !== texture._source) {\n          return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);\n        }\n      }\n    }\n    return false;\n  }\n  addRenderable(mesh, instructionSet) {\n    const batcher = this.renderer.renderPipes.batch;\n    const {\n      batched\n    } = this._getMeshData(mesh);\n    if (batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.texture = mesh._texture;\n      gpuBatchableMesh.geometry = mesh._geometry;\n      batcher.addToBatch(gpuBatchableMesh);\n    } else {\n      batcher.break(instructionSet);\n      instructionSet.add({\n        renderPipeId: \"mesh\",\n        mesh\n      });\n    }\n  }\n  updateRenderable(mesh) {\n    if (mesh.batched) {\n      const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n      gpuBatchableMesh.texture = mesh._texture;\n      gpuBatchableMesh.geometry = mesh._geometry;\n      gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);\n    }\n  }\n  destroyRenderable(mesh) {\n    this._meshDataHash[mesh.uid] = null;\n    const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n    if (gpuMesh) {\n      BigPool.return(gpuMesh);\n      this._gpuBatchableMeshHash[mesh.uid] = null;\n    }\n  }\n  execute({\n    mesh\n  }) {\n    if (!mesh.isRenderable) return;\n    mesh.state.blendMode = mesh.groupBlendMode;\n    const localUniforms = this.localUniforms;\n    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n    localUniforms.update();\n    color32BitToUniform(mesh.groupColorAlpha, localUniforms.uniforms.uColor, 0);\n    this._adaptor.execute(this, mesh);\n  }\n  _getMeshData(mesh) {\n    return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n  }\n  _initMeshData(mesh) {\n    this._meshDataHash[mesh.uid] = {\n      batched: mesh.batched,\n      indexSize: mesh._geometry.indices?.length,\n      vertexSize: mesh._geometry.positions?.length\n    };\n    mesh.on(\"destroyed\", () => {\n      this.destroyRenderable(mesh);\n    });\n    return this._meshDataHash[mesh.uid];\n  }\n  _getBatchableMesh(mesh) {\n    return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n  }\n  _initBatchableMesh(mesh) {\n    const gpuMesh = BigPool.get(BatchableMesh);\n    gpuMesh.mesh = mesh;\n    gpuMesh.texture = mesh._texture;\n    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n    this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n    gpuMesh.mesh = mesh;\n    return gpuMesh;\n  }\n  destroy() {\n    for (const i in this._gpuBatchableMeshHash) {\n      if (this._gpuBatchableMeshHash[i]) {\n        BigPool.return(this._gpuBatchableMeshHash[i]);\n      }\n    }\n    this._gpuBatchableMeshHash = null;\n    this._meshDataHash = null;\n    this.localUniforms = null;\n    this.localUniformsBindGroup = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.renderer = null;\n  }\n}\n/** @ignore */\nMeshPipe.extension = {\n  type: [ExtensionType.WebGLPipes, ExtensionType.WebGPUPipes, ExtensionType.CanvasPipes],\n  name: \"mesh\"\n};\nexport { MeshPipe };","map":{"version":3,"names":["MeshPipe","constructor","renderer","adaptor","localUniforms","UniformGroup","uTransformMatrix","value","Matrix","type","uColor","Float32Array","uRound","localUniformsBindGroup","BindGroup","_meshDataHash","Object","create","_gpuBatchableMeshHash","_adaptor","init","validateRenderable","mesh","meshData","_getMeshData","wasBatched","batched","isBatched","geometry","_geometry","indices","length","indexSize","positions","vertexSize","batchableMesh","_getBatchableMesh","texture","_source","batcher","checkAndUpdateTexture","addRenderable","instructionSet","renderPipes","batch","gpuBatchableMesh","_texture","addToBatch","break","add","renderPipeId","updateRenderable","uid","updateElement","destroyRenderable","gpuMesh","BigPool","return","execute","isRenderable","state","blendMode","groupBlendMode","uniforms","groupTransform","_roundPixels","update","color32BitToUniform","groupColorAlpha","_initMeshData","on","_initBatchableMesh","get","BatchableMesh","roundPixels","destroy","i","extension","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","name"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/mesh/shared/MeshPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\ninterface MeshData\n{\n    batched: boolean;\n    indexSize: number;\n    vertexSize: number;\n}\n\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\nexport interface MeshInstruction extends Instruction\n{\n    renderPipeId: 'mesh';\n    mesh: Mesh;\n}\n\n// eslint-disable-next-line max-len\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<MeshInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _meshDataHash: Record<number, MeshData> = Object.create(null);\n    private _gpuBatchableMeshHash: Record<number, BatchableMesh> = Object.create(null);\n    private _adaptor: MeshAdaptor;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            const texture = mesh.texture;\n\n            if (batchableMesh.texture._source !== texture._source)\n            {\n                if (batchableMesh.texture._source !== texture._source)\n                {\n                    return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const { batched } = this._getMeshData(mesh);\n\n        if (batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add({\n                renderPipeId: 'mesh',\n                mesh\n            } as MeshInstruction);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public destroyRenderable(mesh: Mesh)\n    {\n        this._meshDataHash[mesh.uid] = null;\n\n        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n        if (gpuMesh)\n        {\n            BigPool.return(gpuMesh as PoolItem);\n            this._gpuBatchableMeshHash[mesh.uid] = null;\n        }\n    }\n\n    public execute({ mesh }: MeshInstruction)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = mesh.groupBlendMode;\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        this._meshDataHash[mesh.uid] = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length,\n        };\n\n        mesh.on('destroyed', () =>\n        {\n            this.destroyRenderable(mesh);\n        });\n\n        return this._meshDataHash[mesh.uid];\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = BigPool.get(BatchableMesh);\n\n        gpuMesh.mesh = mesh;\n        gpuMesh.texture = mesh._texture;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n\n        gpuMesh.mesh = mesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuBatchableMeshHash)\n        {\n            if (this._gpuBatchableMeshHash[i])\n            {\n                BigPool.return(this._gpuBatchableMeshHash[i] as PoolItem);\n            }\n        }\n\n        this._gpuBatchableMeshHash = null;\n        this._meshDataHash = null;\n\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}