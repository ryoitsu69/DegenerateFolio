{"ast":null,"code":"import _defineProperty from \"/home/ryoitsu/Documents/test/react-todo-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { Observable, publishReplay, refCount } from 'rxjs';\nimport { rpcDefinitions } from '@polkadot/types';\nimport { hexToU8a, isFunction, isNull, isUndefined, lazyMethod, logger, memoize, objectSpread, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { drr, refCountDelay } from './util/index.js';\nexport { packageInfo } from './packageInfo.js';\nexport * from './util/index.js';\nconst l = logger('rpc-core');\nconst EMPTY_META = {\n  fallback: undefined,\n  modifier: {\n    isOptional: true\n  },\n  type: {\n    asMap: {\n      linked: {\n        isTrue: false\n      }\n    },\n    isMap: false\n  }\n};\n/** @internal */\nfunction logErrorMessage(method, _ref, error) {\n  let {\n    noErrorLog,\n    params,\n    type\n  } = _ref;\n  if (noErrorLog) {\n    return;\n  }\n  l.error(\"\".concat(method, \"(\").concat(params.map(_ref2 => {\n    let {\n      isOptional,\n      name,\n      type\n    } = _ref2;\n    return \"\".concat(name).concat(isOptional ? '?' : '', \": \").concat(type);\n  }).join(', '), \"): \").concat(type, \":: \").concat(error.message));\n}\nfunction isTreatAsHex(key) {\n  // :code is problematic - it does not have the length attached, which is\n  // unlike all other storage entries where it is indeed properly encoded\n  return ['0x3a636f6465'].includes(key.toHex());\n}\n/**\n * @name Rpc\n * @summary The API may use a HTTP or WebSockets provider.\n * @description It allows for querying a Polkadot Client Node.\n * WebSockets provider is recommended since HTTP provider only supports basic querying.\n *\n * ```mermaid\n * graph LR;\n *   A[Api] --> |WebSockets| B[WsProvider];\n *   B --> |endpoint| C[ws://127.0.0.1:9944]\n * ```\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Rpc from '@polkadot/rpc-core';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const rpc = new Rpc(provider);\n * ```\n */\nexport class RpcCore {\n  /**\n   * @constructor\n   * Default constructor for the core RPC handler\n   * @param  {ProviderInterface} provider An API provider using any of the supported providers (HTTP, SC or WebSocket)\n   */\n  constructor(instanceId, registry, _ref3) {\n    let {\n      isPedantic = true,\n      provider,\n      userRpc = {}\n    } = _ref3;\n    _defineProperty(this, \"__internal__instanceId\", void 0);\n    _defineProperty(this, \"__internal__isPedantic\", void 0);\n    _defineProperty(this, \"__internal__registryDefault\", void 0);\n    _defineProperty(this, \"__internal__storageCache\", new Map());\n    _defineProperty(this, \"__internal__storageCacheHits\", 0);\n    _defineProperty(this, \"__internal__storageCacheSize\", 0);\n    _defineProperty(this, \"__internal__getBlockRegistry\", void 0);\n    _defineProperty(this, \"__internal__getBlockHash\", void 0);\n    _defineProperty(this, \"mapping\", new Map());\n    _defineProperty(this, \"provider\", void 0);\n    _defineProperty(this, \"sections\", []);\n    if (!provider || !isFunction(provider.send)) {\n      throw new Error('Expected Provider to API create');\n    }\n    this.__internal__instanceId = instanceId;\n    this.__internal__isPedantic = isPedantic;\n    this.__internal__registryDefault = registry;\n    this.provider = provider;\n    const sectionNames = Object.keys(rpcDefinitions);\n    // these are the base keys (i.e. part of jsonrpc)\n    this.sections.push(...sectionNames);\n    // decorate all interfaces, defined and user on this instance\n    this.addUserInterfaces(userRpc);\n  }\n  /**\n   * @description Returns the connected status of a provider\n   */\n  get isConnected() {\n    return this.provider.isConnected;\n  }\n  /**\n   * @description Manually connect from the attached provider\n   */\n  connect() {\n    return this.provider.connect();\n  }\n  /**\n   * @description Manually disconnect from the attached provider\n   */\n  disconnect() {\n    return this.provider.disconnect();\n  }\n  /**\n   * @description Returns the underlying core stats, including those from teh provider\n   */\n  get stats() {\n    const stats = this.provider.stats;\n    return stats ? {\n      ...stats,\n      core: {\n        cacheHits: this.__internal__storageCacheHits,\n        cacheSize: this.__internal__storageCacheSize\n      }\n    } : undefined;\n  }\n  /**\n   * @description Sets a registry swap (typically from Api)\n   */\n  setRegistrySwap(registrySwap) {\n    this.__internal__getBlockRegistry = memoize(registrySwap, {\n      getInstanceId: () => this.__internal__instanceId\n    });\n  }\n  /**\n   * @description Sets a function to resolve block hash from block number\n   */\n  setResolveBlockHash(resolveBlockHash) {\n    this.__internal__getBlockHash = memoize(resolveBlockHash, {\n      getInstanceId: () => this.__internal__instanceId\n    });\n  }\n  addUserInterfaces(userRpc) {\n    // add any extra user-defined sections\n    this.sections.push(...Object.keys(userRpc).filter(k => !this.sections.includes(k)));\n    for (let s = 0, scount = this.sections.length; s < scount; s++) {\n      const section = this.sections[s];\n      const defs = objectSpread({}, rpcDefinitions[section], userRpc[section]);\n      const methods = Object.keys(defs);\n      for (let m = 0, mcount = methods.length; m < mcount; m++) {\n        const method = methods[m];\n        const def = defs[method];\n        const jsonrpc = def.endpoint || \"\".concat(section, \"_\").concat(method);\n        if (!this.mapping.has(jsonrpc)) {\n          const isSubscription = !!def.pubsub;\n          if (!this[section]) {\n            this[section] = {};\n          }\n          this.mapping.set(jsonrpc, objectSpread({}, def, {\n            isSubscription,\n            jsonrpc,\n            method,\n            section\n          }));\n          lazyMethod(this[section], method, () => isSubscription ? this._createMethodSubscribe(section, method, def) : this._createMethodSend(section, method, def));\n        }\n      }\n    }\n  }\n  _memomize(creator, def) {\n    const memoOpts = {\n      getInstanceId: () => this.__internal__instanceId\n    };\n    const memoized = memoize(creator(true), memoOpts);\n    memoized.raw = memoize(creator(false), memoOpts);\n    memoized.meta = def;\n    return memoized;\n  }\n  _formatResult(isScale, registry, blockHash, method, def, params, result) {\n    return isScale ? this._formatOutput(registry, blockHash, method, def, params, result) : result;\n  }\n  _createMethodSend(section, method, def) {\n    const rpcName = def.endpoint || \"\".concat(section, \"_\").concat(method);\n    const hashIndex = def.params.findIndex(_ref4 => {\n      let {\n        isHistoric\n      } = _ref4;\n      return isHistoric;\n    });\n    let memoized = null;\n    // execute the RPC call, doing a registry swap for historic as applicable\n    const callWithRegistry = async (isScale, values) => {\n      var _this$__internal__get;\n      const blockId = hashIndex === -1 ? null : values[hashIndex];\n      const blockHash = blockId && def.params[hashIndex].type === 'BlockNumber' ? await ((_this$__internal__get = this.__internal__getBlockHash) === null || _this$__internal__get === void 0 ? void 0 : _this$__internal__get.call(this, blockId)) : blockId;\n      const {\n        registry\n      } = isScale && blockHash && this.__internal__getBlockRegistry ? await this.__internal__getBlockRegistry(u8aToU8a(blockHash)) : {\n        registry: this.__internal__registryDefault\n      };\n      const params = this._formatParams(registry, null, def, values);\n      // only cache .at(<blockHash>) queries, e.g. where valid blockHash was supplied\n      const result = await this.provider.send(rpcName, params.map(p => p.toJSON()), !!blockHash);\n      return this._formatResult(isScale, registry, blockHash, method, def, params, result);\n    };\n    const creator = isScale => function () {\n      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n        values[_key] = arguments[_key];\n      }\n      const isDelayed = isScale && hashIndex !== -1 && !!values[hashIndex];\n      return new Observable(observer => {\n        callWithRegistry(isScale, values).then(value => {\n          observer.next(value);\n          observer.complete();\n        }).catch(error => {\n          logErrorMessage(method, def, error);\n          observer.error(error);\n          observer.complete();\n        });\n        return () => {\n          // delete old results from cache\n          if (isScale) {\n            var _memoized;\n            (_memoized = memoized) === null || _memoized === void 0 || _memoized.unmemoize(...values);\n          } else {\n            var _memoized2;\n            (_memoized2 = memoized) === null || _memoized2 === void 0 || _memoized2.raw.unmemoize(...values);\n          }\n        };\n      }).pipe(\n      // eslint-disable-next-line deprecation/deprecation\n      publishReplay(1),\n      // create a Replay(1)\n      isDelayed ? refCountDelay() // Unsubscribe after delay\n      // eslint-disable-next-line deprecation/deprecation\n      : refCount());\n    };\n    memoized = this._memomize(creator, def);\n    return memoized;\n  }\n  // create a subscriptor, it subscribes once and resolves with the id as subscribe\n  _createSubscriber(_ref5, errorHandler) {\n    let {\n      paramsJson,\n      subName,\n      subType,\n      update\n    } = _ref5;\n    return new Promise((resolve, reject) => {\n      this.provider.subscribe(subType, subName, paramsJson, update).then(resolve).catch(error => {\n        errorHandler(error);\n        reject(error);\n      });\n    });\n  }\n  _createMethodSubscribe(section, method, def) {\n    var _this = this;\n    const [updateType, subMethod, unsubMethod] = def.pubsub;\n    const subName = \"\".concat(section, \"_\").concat(subMethod);\n    const unsubName = \"\".concat(section, \"_\").concat(unsubMethod);\n    const subType = \"\".concat(section, \"_\").concat(updateType);\n    let memoized = null;\n    const creator = isScale => function () {\n      for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        values[_key2] = arguments[_key2];\n      }\n      return new Observable(observer => {\n        // Have at least an empty promise, as used in the unsubscribe\n        let subscriptionPromise = Promise.resolve(null);\n        const registry = _this.__internal__registryDefault;\n        const errorHandler = error => {\n          logErrorMessage(method, def, error);\n          observer.error(error);\n        };\n        try {\n          const params = _this._formatParams(registry, null, def, values);\n          const update = (error, result) => {\n            if (error) {\n              logErrorMessage(method, def, error);\n              return;\n            }\n            try {\n              observer.next(_this._formatResult(isScale, registry, null, method, def, params, result));\n            } catch (error) {\n              observer.error(error);\n            }\n          };\n          subscriptionPromise = _this._createSubscriber({\n            paramsJson: params.map(p => p.toJSON()),\n            subName,\n            subType,\n            update\n          }, errorHandler);\n        } catch (error) {\n          errorHandler(error);\n        }\n        // Teardown logic\n        return () => {\n          // Delete from cache, so old results don't hang around\n          if (isScale) {\n            var _memoized3;\n            (_memoized3 = memoized) === null || _memoized3 === void 0 || _memoized3.unmemoize(...values);\n          } else {\n            var _memoized4;\n            (_memoized4 = memoized) === null || _memoized4 === void 0 || _memoized4.raw.unmemoize(...values);\n          }\n          // Unsubscribe from provider\n          subscriptionPromise.then(subscriptionId => isNull(subscriptionId) ? Promise.resolve(false) : _this.provider.unsubscribe(subType, unsubName, subscriptionId)).catch(error => logErrorMessage(method, def, error));\n        };\n      }).pipe(drr());\n    };\n    memoized = this._memomize(creator, def);\n    return memoized;\n  }\n  _formatParams(registry, blockHash, def, inputs) {\n    const count = inputs.length;\n    const reqCount = def.params.filter(_ref6 => {\n      let {\n        isOptional\n      } = _ref6;\n      return !isOptional;\n    }).length;\n    if (count < reqCount || count > def.params.length) {\n      throw new Error(\"Expected \".concat(def.params.length, \" parameters\").concat(reqCount === def.params.length ? '' : \" (\".concat(def.params.length - reqCount, \" optional)\"), \", \").concat(count, \" found instead\"));\n    }\n    const params = new Array(count);\n    for (let i = 0; i < count; i++) {\n      params[i] = registry.createTypeUnsafe(def.params[i].type, [inputs[i]], {\n        blockHash\n      });\n    }\n    return params;\n  }\n  _formatOutput(registry, blockHash, method, rpc, params, result) {\n    if (rpc.type === 'StorageData') {\n      const key = params[0];\n      return this._formatStorageData(registry, blockHash, key, result);\n    } else if (rpc.type === 'StorageChangeSet') {\n      const keys = params[0];\n      return keys ? this._formatStorageSet(registry, result.block, keys, result.changes) : registry.createType('StorageChangeSet', result);\n    } else if (rpc.type === 'Vec<StorageChangeSet>') {\n      const jsonSet = result;\n      const count = jsonSet.length;\n      const mapped = new Array(count);\n      for (let i = 0; i < count; i++) {\n        const {\n          block,\n          changes\n        } = jsonSet[i];\n        mapped[i] = [registry.createType('BlockHash', block), this._formatStorageSet(registry, block, params[0], changes)];\n      }\n      // we only query at a specific block, not a range - flatten\n      return method === 'queryStorageAt' ? mapped[0][1] : mapped;\n    }\n    return registry.createTypeUnsafe(rpc.type, [result], {\n      blockHash\n    });\n  }\n  _formatStorageData(registry, blockHash, key, value) {\n    const isEmpty = isNull(value);\n    // we convert to Uint8Array since it maps to the raw encoding, all\n    // data will be correctly encoded (incl. numbers, excl. :code)\n    const input = isEmpty ? null : isTreatAsHex(key) ? value : u8aToU8a(value);\n    return this._newType(registry, blockHash, key, input, isEmpty);\n  }\n  _formatStorageSet(registry, blockHash, keys, changes) {\n    // For StorageChangeSet, the changes has the [key, value] mappings\n    const count = keys.length;\n    const withCache = count !== 1;\n    const values = new Array(count);\n    // multiple return values (via state.storage subscription), decode the\n    // values one at a time, all based on the supplied query types\n    for (let i = 0; i < count; i++) {\n      values[i] = this._formatStorageSetEntry(registry, blockHash, keys[i], changes, withCache, i);\n    }\n    return values;\n  }\n  _formatStorageSetEntry(registry, blockHash, key, changes, withCache, entryIndex) {\n    const hexKey = key.toHex();\n    const found = changes.find(_ref7 => {\n      let [key] = _ref7;\n      return key === hexKey;\n    });\n    const isNotFound = isUndefined(found);\n    // if we don't find the value, this is our fallback\n    //   - in the case of an array of values, fill the hole from the cache\n    //   - if a single result value, don't fill - it is not an update hole\n    //   - fallback to an empty option in all cases\n    if (isNotFound && withCache) {\n      const cached = this.__internal__storageCache.get(hexKey);\n      if (cached) {\n        this.__internal__storageCacheHits++;\n        return cached;\n      }\n    }\n    const value = isNotFound ? null : found[1];\n    const isEmpty = isNull(value);\n    const input = isEmpty || isTreatAsHex(key) ? value : u8aToU8a(value);\n    const codec = this._newType(registry, blockHash, key, input, isEmpty, entryIndex);\n    // store the retrieved result - the only issue with this cache is that there is no\n    // clearing of it, so very long running processes (not just a couple of hours, longer)\n    // will increase memory beyond what is allowed.\n    this.__internal__storageCache.set(hexKey, codec);\n    this.__internal__storageCacheSize++;\n    return codec;\n  }\n  _newType(registry, blockHash, key, input, isEmpty) {\n    let entryIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : -1;\n    // single return value (via state.getStorage), decode the value based on the\n    // outputType that we have specified. Fallback to Raw on nothing\n    const type = key.outputType || 'Raw';\n    const meta = key.meta || EMPTY_META;\n    const entryNum = entryIndex === -1 ? '' : \" entry \".concat(entryIndex, \":\");\n    try {\n      return registry.createTypeUnsafe(type, [isEmpty ? meta.fallback\n      // For old-style Linkage, we add an empty linkage at the end\n      ? type.includes('Linkage<') ? u8aConcat(hexToU8a(meta.fallback.toHex()), new Uint8Array(2)) : hexToU8a(meta.fallback.toHex()) : undefined : meta.modifier.isOptional ? registry.createTypeUnsafe(type, [input], {\n        blockHash,\n        isPedantic: this.__internal__isPedantic\n      }) : input], {\n        blockHash,\n        isFallback: isEmpty && !!meta.fallback,\n        isOptional: meta.modifier.isOptional,\n        isPedantic: this.__internal__isPedantic && !meta.modifier.isOptional\n      });\n    } catch (error) {\n      throw new Error(\"Unable to decode storage \".concat(key.section || 'unknown', \".\").concat(key.method || 'unknown', \":\").concat(entryNum, \": \").concat(error.message));\n    }\n  }\n}","map":{"version":3,"names":["Observable","publishReplay","refCount","rpcDefinitions","hexToU8a","isFunction","isNull","isUndefined","lazyMethod","logger","memoize","objectSpread","u8aConcat","u8aToU8a","drr","refCountDelay","packageInfo","l","EMPTY_META","fallback","undefined","modifier","isOptional","type","asMap","linked","isTrue","isMap","logErrorMessage","method","_ref","error","noErrorLog","params","concat","map","_ref2","name","join","message","isTreatAsHex","key","includes","toHex","RpcCore","constructor","instanceId","registry","_ref3","isPedantic","provider","userRpc","_defineProperty","Map","send","Error","__internal__instanceId","__internal__isPedantic","__internal__registryDefault","sectionNames","Object","keys","sections","push","addUserInterfaces","isConnected","connect","disconnect","stats","core","cacheHits","__internal__storageCacheHits","cacheSize","__internal__storageCacheSize","setRegistrySwap","registrySwap","__internal__getBlockRegistry","getInstanceId","setResolveBlockHash","resolveBlockHash","__internal__getBlockHash","filter","k","s","scount","length","section","defs","methods","m","mcount","def","jsonrpc","endpoint","mapping","has","isSubscription","pubsub","set","_createMethodSubscribe","_createMethodSend","_memomize","creator","memoOpts","memoized","raw","meta","_formatResult","isScale","blockHash","result","_formatOutput","rpcName","hashIndex","findIndex","_ref4","isHistoric","callWithRegistry","values","_this$__internal__get","blockId","call","_formatParams","p","toJSON","_len","arguments","Array","_key","isDelayed","observer","then","value","next","complete","catch","_memoized","unmemoize","_memoized2","pipe","_createSubscriber","_ref5","errorHandler","paramsJson","subName","subType","update","Promise","resolve","reject","subscribe","_this","updateType","subMethod","unsubMethod","unsubName","_len2","_key2","subscriptionPromise","_memoized3","_memoized4","subscriptionId","unsubscribe","inputs","count","reqCount","_ref6","i","createTypeUnsafe","rpc","_formatStorageData","_formatStorageSet","block","changes","createType","jsonSet","mapped","isEmpty","input","_newType","withCache","_formatStorageSetEntry","entryIndex","hexKey","found","find","_ref7","isNotFound","cached","__internal__storageCache","get","codec","outputType","entryNum","Uint8Array","isFallback"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/rpc-core/bundle.js"],"sourcesContent":["import { Observable, publishReplay, refCount } from 'rxjs';\nimport { rpcDefinitions } from '@polkadot/types';\nimport { hexToU8a, isFunction, isNull, isUndefined, lazyMethod, logger, memoize, objectSpread, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { drr, refCountDelay } from './util/index.js';\nexport { packageInfo } from './packageInfo.js';\nexport * from './util/index.js';\nconst l = logger('rpc-core');\nconst EMPTY_META = {\n    fallback: undefined,\n    modifier: { isOptional: true },\n    type: {\n        asMap: { linked: { isTrue: false } },\n        isMap: false\n    }\n};\n/** @internal */\nfunction logErrorMessage(method, { noErrorLog, params, type }, error) {\n    if (noErrorLog) {\n        return;\n    }\n    l.error(`${method}(${params.map(({ isOptional, name, type }) => `${name}${isOptional ? '?' : ''}: ${type}`).join(', ')}): ${type}:: ${error.message}`);\n}\nfunction isTreatAsHex(key) {\n    // :code is problematic - it does not have the length attached, which is\n    // unlike all other storage entries where it is indeed properly encoded\n    return ['0x3a636f6465'].includes(key.toHex());\n}\n/**\n * @name Rpc\n * @summary The API may use a HTTP or WebSockets provider.\n * @description It allows for querying a Polkadot Client Node.\n * WebSockets provider is recommended since HTTP provider only supports basic querying.\n *\n * ```mermaid\n * graph LR;\n *   A[Api] --> |WebSockets| B[WsProvider];\n *   B --> |endpoint| C[ws://127.0.0.1:9944]\n * ```\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Rpc from '@polkadot/rpc-core';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const rpc = new Rpc(provider);\n * ```\n */\nexport class RpcCore {\n    __internal__instanceId;\n    __internal__isPedantic;\n    __internal__registryDefault;\n    __internal__storageCache = new Map();\n    __internal__storageCacheHits = 0;\n    __internal__storageCacheSize = 0;\n    __internal__getBlockRegistry;\n    __internal__getBlockHash;\n    mapping = new Map();\n    provider;\n    sections = [];\n    /**\n     * @constructor\n     * Default constructor for the core RPC handler\n     * @param  {ProviderInterface} provider An API provider using any of the supported providers (HTTP, SC or WebSocket)\n     */\n    constructor(instanceId, registry, { isPedantic = true, provider, userRpc = {} }) {\n        if (!provider || !isFunction(provider.send)) {\n            throw new Error('Expected Provider to API create');\n        }\n        this.__internal__instanceId = instanceId;\n        this.__internal__isPedantic = isPedantic;\n        this.__internal__registryDefault = registry;\n        this.provider = provider;\n        const sectionNames = Object.keys(rpcDefinitions);\n        // these are the base keys (i.e. part of jsonrpc)\n        this.sections.push(...sectionNames);\n        // decorate all interfaces, defined and user on this instance\n        this.addUserInterfaces(userRpc);\n    }\n    /**\n     * @description Returns the connected status of a provider\n     */\n    get isConnected() {\n        return this.provider.isConnected;\n    }\n    /**\n     * @description Manually connect from the attached provider\n     */\n    connect() {\n        return this.provider.connect();\n    }\n    /**\n     * @description Manually disconnect from the attached provider\n     */\n    disconnect() {\n        return this.provider.disconnect();\n    }\n    /**\n     * @description Returns the underlying core stats, including those from teh provider\n     */\n    get stats() {\n        const stats = this.provider.stats;\n        return stats\n            ? {\n                ...stats,\n                core: {\n                    cacheHits: this.__internal__storageCacheHits,\n                    cacheSize: this.__internal__storageCacheSize\n                }\n            }\n            : undefined;\n    }\n    /**\n     * @description Sets a registry swap (typically from Api)\n     */\n    setRegistrySwap(registrySwap) {\n        this.__internal__getBlockRegistry = memoize(registrySwap, {\n            getInstanceId: () => this.__internal__instanceId\n        });\n    }\n    /**\n     * @description Sets a function to resolve block hash from block number\n     */\n    setResolveBlockHash(resolveBlockHash) {\n        this.__internal__getBlockHash = memoize(resolveBlockHash, {\n            getInstanceId: () => this.__internal__instanceId\n        });\n    }\n    addUserInterfaces(userRpc) {\n        // add any extra user-defined sections\n        this.sections.push(...Object.keys(userRpc).filter((k) => !this.sections.includes(k)));\n        for (let s = 0, scount = this.sections.length; s < scount; s++) {\n            const section = this.sections[s];\n            const defs = objectSpread({}, rpcDefinitions[section], userRpc[section]);\n            const methods = Object.keys(defs);\n            for (let m = 0, mcount = methods.length; m < mcount; m++) {\n                const method = methods[m];\n                const def = defs[method];\n                const jsonrpc = def.endpoint || `${section}_${method}`;\n                if (!this.mapping.has(jsonrpc)) {\n                    const isSubscription = !!def.pubsub;\n                    if (!this[section]) {\n                        this[section] = {};\n                    }\n                    this.mapping.set(jsonrpc, objectSpread({}, def, { isSubscription, jsonrpc, method, section }));\n                    lazyMethod(this[section], method, () => isSubscription\n                        ? this._createMethodSubscribe(section, method, def)\n                        : this._createMethodSend(section, method, def));\n                }\n            }\n        }\n    }\n    _memomize(creator, def) {\n        const memoOpts = { getInstanceId: () => this.__internal__instanceId };\n        const memoized = memoize(creator(true), memoOpts);\n        memoized.raw = memoize(creator(false), memoOpts);\n        memoized.meta = def;\n        return memoized;\n    }\n    _formatResult(isScale, registry, blockHash, method, def, params, result) {\n        return isScale\n            ? this._formatOutput(registry, blockHash, method, def, params, result)\n            : result;\n    }\n    _createMethodSend(section, method, def) {\n        const rpcName = def.endpoint || `${section}_${method}`;\n        const hashIndex = def.params.findIndex(({ isHistoric }) => isHistoric);\n        let memoized = null;\n        // execute the RPC call, doing a registry swap for historic as applicable\n        const callWithRegistry = async (isScale, values) => {\n            const blockId = hashIndex === -1\n                ? null\n                : values[hashIndex];\n            const blockHash = blockId && def.params[hashIndex].type === 'BlockNumber'\n                ? await this.__internal__getBlockHash?.(blockId)\n                : blockId;\n            const { registry } = isScale && blockHash && this.__internal__getBlockRegistry\n                ? await this.__internal__getBlockRegistry(u8aToU8a(blockHash))\n                : { registry: this.__internal__registryDefault };\n            const params = this._formatParams(registry, null, def, values);\n            // only cache .at(<blockHash>) queries, e.g. where valid blockHash was supplied\n            const result = await this.provider.send(rpcName, params.map((p) => p.toJSON()), !!blockHash);\n            return this._formatResult(isScale, registry, blockHash, method, def, params, result);\n        };\n        const creator = (isScale) => (...values) => {\n            const isDelayed = isScale && hashIndex !== -1 && !!values[hashIndex];\n            return new Observable((observer) => {\n                callWithRegistry(isScale, values)\n                    .then((value) => {\n                    observer.next(value);\n                    observer.complete();\n                })\n                    .catch((error) => {\n                    logErrorMessage(method, def, error);\n                    observer.error(error);\n                    observer.complete();\n                });\n                return () => {\n                    // delete old results from cache\n                    if (isScale) {\n                        memoized?.unmemoize(...values);\n                    }\n                    else {\n                        memoized?.raw.unmemoize(...values);\n                    }\n                };\n            }).pipe(\n            // eslint-disable-next-line deprecation/deprecation\n            publishReplay(1), // create a Replay(1)\n            isDelayed\n                ? refCountDelay() // Unsubscribe after delay\n                // eslint-disable-next-line deprecation/deprecation\n                : refCount());\n        };\n        memoized = this._memomize(creator, def);\n        return memoized;\n    }\n    // create a subscriptor, it subscribes once and resolves with the id as subscribe\n    _createSubscriber({ paramsJson, subName, subType, update }, errorHandler) {\n        return new Promise((resolve, reject) => {\n            this.provider\n                .subscribe(subType, subName, paramsJson, update)\n                .then(resolve)\n                .catch((error) => {\n                errorHandler(error);\n                reject(error);\n            });\n        });\n    }\n    _createMethodSubscribe(section, method, def) {\n        const [updateType, subMethod, unsubMethod] = def.pubsub;\n        const subName = `${section}_${subMethod}`;\n        const unsubName = `${section}_${unsubMethod}`;\n        const subType = `${section}_${updateType}`;\n        let memoized = null;\n        const creator = (isScale) => (...values) => {\n            return new Observable((observer) => {\n                // Have at least an empty promise, as used in the unsubscribe\n                let subscriptionPromise = Promise.resolve(null);\n                const registry = this.__internal__registryDefault;\n                const errorHandler = (error) => {\n                    logErrorMessage(method, def, error);\n                    observer.error(error);\n                };\n                try {\n                    const params = this._formatParams(registry, null, def, values);\n                    const update = (error, result) => {\n                        if (error) {\n                            logErrorMessage(method, def, error);\n                            return;\n                        }\n                        try {\n                            observer.next(this._formatResult(isScale, registry, null, method, def, params, result));\n                        }\n                        catch (error) {\n                            observer.error(error);\n                        }\n                    };\n                    subscriptionPromise = this._createSubscriber({ paramsJson: params.map((p) => p.toJSON()), subName, subType, update }, errorHandler);\n                }\n                catch (error) {\n                    errorHandler(error);\n                }\n                // Teardown logic\n                return () => {\n                    // Delete from cache, so old results don't hang around\n                    if (isScale) {\n                        memoized?.unmemoize(...values);\n                    }\n                    else {\n                        memoized?.raw.unmemoize(...values);\n                    }\n                    // Unsubscribe from provider\n                    subscriptionPromise\n                        .then((subscriptionId) => isNull(subscriptionId)\n                        ? Promise.resolve(false)\n                        : this.provider.unsubscribe(subType, unsubName, subscriptionId))\n                        .catch((error) => logErrorMessage(method, def, error));\n                };\n            }).pipe(drr());\n        };\n        memoized = this._memomize(creator, def);\n        return memoized;\n    }\n    _formatParams(registry, blockHash, def, inputs) {\n        const count = inputs.length;\n        const reqCount = def.params.filter(({ isOptional }) => !isOptional).length;\n        if (count < reqCount || count > def.params.length) {\n            throw new Error(`Expected ${def.params.length} parameters${reqCount === def.params.length ? '' : ` (${def.params.length - reqCount} optional)`}, ${count} found instead`);\n        }\n        const params = new Array(count);\n        for (let i = 0; i < count; i++) {\n            params[i] = registry.createTypeUnsafe(def.params[i].type, [inputs[i]], { blockHash });\n        }\n        return params;\n    }\n    _formatOutput(registry, blockHash, method, rpc, params, result) {\n        if (rpc.type === 'StorageData') {\n            const key = params[0];\n            return this._formatStorageData(registry, blockHash, key, result);\n        }\n        else if (rpc.type === 'StorageChangeSet') {\n            const keys = params[0];\n            return keys\n                ? this._formatStorageSet(registry, result.block, keys, result.changes)\n                : registry.createType('StorageChangeSet', result);\n        }\n        else if (rpc.type === 'Vec<StorageChangeSet>') {\n            const jsonSet = result;\n            const count = jsonSet.length;\n            const mapped = new Array(count);\n            for (let i = 0; i < count; i++) {\n                const { block, changes } = jsonSet[i];\n                mapped[i] = [\n                    registry.createType('BlockHash', block),\n                    this._formatStorageSet(registry, block, params[0], changes)\n                ];\n            }\n            // we only query at a specific block, not a range - flatten\n            return method === 'queryStorageAt'\n                ? mapped[0][1]\n                : mapped;\n        }\n        return registry.createTypeUnsafe(rpc.type, [result], { blockHash });\n    }\n    _formatStorageData(registry, blockHash, key, value) {\n        const isEmpty = isNull(value);\n        // we convert to Uint8Array since it maps to the raw encoding, all\n        // data will be correctly encoded (incl. numbers, excl. :code)\n        const input = isEmpty\n            ? null\n            : isTreatAsHex(key)\n                ? value\n                : u8aToU8a(value);\n        return this._newType(registry, blockHash, key, input, isEmpty);\n    }\n    _formatStorageSet(registry, blockHash, keys, changes) {\n        // For StorageChangeSet, the changes has the [key, value] mappings\n        const count = keys.length;\n        const withCache = count !== 1;\n        const values = new Array(count);\n        // multiple return values (via state.storage subscription), decode the\n        // values one at a time, all based on the supplied query types\n        for (let i = 0; i < count; i++) {\n            values[i] = this._formatStorageSetEntry(registry, blockHash, keys[i], changes, withCache, i);\n        }\n        return values;\n    }\n    _formatStorageSetEntry(registry, blockHash, key, changes, withCache, entryIndex) {\n        const hexKey = key.toHex();\n        const found = changes.find(([key]) => key === hexKey);\n        const isNotFound = isUndefined(found);\n        // if we don't find the value, this is our fallback\n        //   - in the case of an array of values, fill the hole from the cache\n        //   - if a single result value, don't fill - it is not an update hole\n        //   - fallback to an empty option in all cases\n        if (isNotFound && withCache) {\n            const cached = this.__internal__storageCache.get(hexKey);\n            if (cached) {\n                this.__internal__storageCacheHits++;\n                return cached;\n            }\n        }\n        const value = isNotFound\n            ? null\n            : found[1];\n        const isEmpty = isNull(value);\n        const input = isEmpty || isTreatAsHex(key)\n            ? value\n            : u8aToU8a(value);\n        const codec = this._newType(registry, blockHash, key, input, isEmpty, entryIndex);\n        // store the retrieved result - the only issue with this cache is that there is no\n        // clearing of it, so very long running processes (not just a couple of hours, longer)\n        // will increase memory beyond what is allowed.\n        this.__internal__storageCache.set(hexKey, codec);\n        this.__internal__storageCacheSize++;\n        return codec;\n    }\n    _newType(registry, blockHash, key, input, isEmpty, entryIndex = -1) {\n        // single return value (via state.getStorage), decode the value based on the\n        // outputType that we have specified. Fallback to Raw on nothing\n        const type = key.outputType || 'Raw';\n        const meta = key.meta || EMPTY_META;\n        const entryNum = entryIndex === -1\n            ? ''\n            : ` entry ${entryIndex}:`;\n        try {\n            return registry.createTypeUnsafe(type, [\n                isEmpty\n                    ? meta.fallback\n                        // For old-style Linkage, we add an empty linkage at the end\n                        ? type.includes('Linkage<')\n                            ? u8aConcat(hexToU8a(meta.fallback.toHex()), new Uint8Array(2))\n                            : hexToU8a(meta.fallback.toHex())\n                        : undefined\n                    : meta.modifier.isOptional\n                        ? registry.createTypeUnsafe(type, [input], { blockHash, isPedantic: this.__internal__isPedantic })\n                        : input\n            ], { blockHash, isFallback: isEmpty && !!meta.fallback, isOptional: meta.modifier.isOptional, isPedantic: this.__internal__isPedantic && !meta.modifier.isOptional });\n        }\n        catch (error) {\n            throw new Error(`Unable to decode storage ${key.section || 'unknown'}.${key.method || 'unknown'}:${entryNum}: ${error.message}`);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}