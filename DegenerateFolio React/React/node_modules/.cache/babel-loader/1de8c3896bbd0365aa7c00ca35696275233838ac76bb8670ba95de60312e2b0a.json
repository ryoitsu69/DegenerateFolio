{"ast":null,"code":"import { Struct, U8aFixed } from '@polkadot/types-codec';\nimport { isHex, isObject, isU8a, objectSpread, u8aToU8a } from '@polkadot/util';\n/**\n * Get a mapping of `argument name -> argument type` for the function, from\n * its metadata.\n *\n * @param meta - The function metadata used to get the definition.\n * @internal\n */\nfunction getArgsDef(registry, meta) {\n  return meta.fields.reduce((result, {\n    name,\n    type\n  }, index) => {\n    result[name.unwrapOr(`param${index}`).toString()] = registry.createLookupType(type);\n    return result;\n  }, {});\n}\n/** @internal */\nfunction decodeCallViaObject(registry, value, _meta) {\n  // we only pass args/methodsIndex out\n  const {\n    args,\n    callIndex\n  } = value;\n  // Get the correct lookupIndex\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  const lookupIndex = callIndex instanceof GenericCallIndex ? callIndex.toU8a() : callIndex;\n  // Find metadata with callIndex\n  const meta = _meta || registry.findMetaCall(lookupIndex).meta;\n  return {\n    args,\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/** @internal */\nfunction decodeCallViaU8a(registry, value, _meta) {\n  // We need 2 bytes for the callIndex\n  const callIndex = registry.firstCallIndex.slice();\n  callIndex.set(value.subarray(0, 2), 0);\n  // Find metadata with callIndex\n  const meta = _meta || registry.findMetaCall(callIndex).meta;\n  return {\n    args: value.subarray(2),\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param value - Value to decode, one of:\n * - hex\n * - Uint8Array\n * - {@see DecodeMethodInput}\n * @param _meta - Metadata to use, so that `injectMethods` lookup is not\n * necessary.\n * @internal\n */\nfunction decodeCall(registry, value = new Uint8Array(), _meta) {\n  if (isU8a(value) || isHex(value)) {\n    return decodeCallViaU8a(registry, u8aToU8a(value), _meta);\n  } else if (isObject(value) && value.callIndex && value.args) {\n    return decodeCallViaObject(registry, value, _meta);\n  }\n  throw new Error(`Call: Cannot decode value '${value}' of type ${typeof value}`);\n}\n/**\n * @name GenericCallIndex\n * @description\n * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method\n */\nexport class GenericCallIndex extends U8aFixed {\n  constructor(registry, value) {\n    super(registry, value, 16);\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive() {\n    return this.toHex();\n  }\n}\n/**\n * @name GenericCall\n * @description\n * Extrinsic function descriptor\n */\nexport class GenericCall extends Struct {\n  _meta;\n  constructor(registry, value, meta) {\n    const decoded = decodeCall(registry, value, meta);\n    try {\n      super(registry, {\n        callIndex: GenericCallIndex,\n        // eslint-disable-next-line sort-keys\n        args: Struct.with(decoded.argsDef)\n      }, decoded);\n    } catch (error) {\n      let method = 'unknown.unknown';\n      try {\n        const c = registry.findMetaCall(decoded.callIndex);\n        method = `${c.section}.${c.method}`;\n      } catch {\n        // ignore\n      }\n      throw new Error(`Call: failed decoding ${method}:: ${error.message}`);\n    }\n    this._meta = decoded.meta;\n  }\n  /**\n   * @description The arguments for the function call\n   */\n  get args() {\n    return [...this.getT('args').values()];\n  }\n  /**\n   * @description The argument definitions\n   */\n  get argsDef() {\n    return getArgsDef(this.registry, this.meta);\n  }\n  /**\n   * @description The argument entries\n   */\n  get argsEntries() {\n    return [...this.getT('args').entries()];\n  }\n  /**\n   * @description The encoded `[sectionIndex, methodIndex]` identifier\n   */\n  get callIndex() {\n    return this.getT('callIndex').toU8a();\n  }\n  /**\n   * @description The encoded data\n   */\n  get data() {\n    return this.getT('args').toU8a();\n  }\n  /**\n   * @description The [[FunctionMetadata]]\n   */\n  get meta() {\n    return this._meta;\n  }\n  /**\n   * @description Returns the name of the method\n   */\n  get method() {\n    return this.registry.findMetaCall(this.callIndex).method;\n  }\n  /**\n   * @description Returns the module containing the method\n   */\n  get section() {\n    return this.registry.findMetaCall(this.callIndex).section;\n  }\n  /**\n   * @description Checks if the source matches this in type\n   */\n  is(other) {\n    return other.callIndex[0] === this.callIndex[0] && other.callIndex[1] === this.callIndex[1];\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExpanded, disableAscii) {\n    let call;\n    try {\n      call = this.registry.findMetaCall(this.callIndex);\n    } catch {\n      // swallow\n    }\n    return objectSpread({\n      args: this.argsEntries.reduce((args, [n, a]) => objectSpread(args, {\n        [n]: a.toHuman(isExpanded, disableAscii)\n      }), {}),\n      method: call?.method,\n      section: call?.section\n    }, isExpanded && call ? {\n      docs: call.meta.docs.map(d => d.toString())\n    } : null);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'Call';\n  }\n}","map":{"version":3,"names":["Struct","U8aFixed","isHex","isObject","isU8a","objectSpread","u8aToU8a","getArgsDef","registry","meta","fields","reduce","result","name","type","index","unwrapOr","toString","createLookupType","decodeCallViaObject","value","_meta","args","callIndex","lookupIndex","GenericCallIndex","toU8a","findMetaCall","argsDef","decodeCallViaU8a","firstCallIndex","slice","set","subarray","decodeCall","Uint8Array","Error","constructor","toPrimitive","toHex","GenericCall","decoded","with","error","method","c","section","message","getT","values","argsEntries","entries","data","is","other","toHuman","isExpanded","disableAscii","call","n","a","docs","map","d","toRawType"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/generic/Call.js"],"sourcesContent":["import { Struct, U8aFixed } from '@polkadot/types-codec';\nimport { isHex, isObject, isU8a, objectSpread, u8aToU8a } from '@polkadot/util';\n/**\n * Get a mapping of `argument name -> argument type` for the function, from\n * its metadata.\n *\n * @param meta - The function metadata used to get the definition.\n * @internal\n */\nfunction getArgsDef(registry, meta) {\n    return meta.fields.reduce((result, { name, type }, index) => {\n        result[name.unwrapOr(`param${index}`).toString()] = registry.createLookupType(type);\n        return result;\n    }, {});\n}\n/** @internal */\nfunction decodeCallViaObject(registry, value, _meta) {\n    // we only pass args/methodsIndex out\n    const { args, callIndex } = value;\n    // Get the correct lookupIndex\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const lookupIndex = callIndex instanceof GenericCallIndex\n        ? callIndex.toU8a()\n        : callIndex;\n    // Find metadata with callIndex\n    const meta = _meta || registry.findMetaCall(lookupIndex).meta;\n    return {\n        args,\n        argsDef: getArgsDef(registry, meta),\n        callIndex,\n        meta\n    };\n}\n/** @internal */\nfunction decodeCallViaU8a(registry, value, _meta) {\n    // We need 2 bytes for the callIndex\n    const callIndex = registry.firstCallIndex.slice();\n    callIndex.set(value.subarray(0, 2), 0);\n    // Find metadata with callIndex\n    const meta = _meta || registry.findMetaCall(callIndex).meta;\n    return {\n        args: value.subarray(2),\n        argsDef: getArgsDef(registry, meta),\n        callIndex,\n        meta\n    };\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param value - Value to decode, one of:\n * - hex\n * - Uint8Array\n * - {@see DecodeMethodInput}\n * @param _meta - Metadata to use, so that `injectMethods` lookup is not\n * necessary.\n * @internal\n */\nfunction decodeCall(registry, value = new Uint8Array(), _meta) {\n    if (isU8a(value) || isHex(value)) {\n        return decodeCallViaU8a(registry, u8aToU8a(value), _meta);\n    }\n    else if (isObject(value) && value.callIndex && value.args) {\n        return decodeCallViaObject(registry, value, _meta);\n    }\n    throw new Error(`Call: Cannot decode value '${value}' of type ${typeof value}`);\n}\n/**\n * @name GenericCallIndex\n * @description\n * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method\n */\nexport class GenericCallIndex extends U8aFixed {\n    constructor(registry, value) {\n        super(registry, value, 16);\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive() {\n        return this.toHex();\n    }\n}\n/**\n * @name GenericCall\n * @description\n * Extrinsic function descriptor\n */\nexport class GenericCall extends Struct {\n    _meta;\n    constructor(registry, value, meta) {\n        const decoded = decodeCall(registry, value, meta);\n        try {\n            super(registry, {\n                callIndex: GenericCallIndex,\n                // eslint-disable-next-line sort-keys\n                args: Struct.with(decoded.argsDef)\n            }, decoded);\n        }\n        catch (error) {\n            let method = 'unknown.unknown';\n            try {\n                const c = registry.findMetaCall(decoded.callIndex);\n                method = `${c.section}.${c.method}`;\n            }\n            catch {\n                // ignore\n            }\n            throw new Error(`Call: failed decoding ${method}:: ${error.message}`);\n        }\n        this._meta = decoded.meta;\n    }\n    /**\n     * @description The arguments for the function call\n     */\n    get args() {\n        return [...this.getT('args').values()];\n    }\n    /**\n     * @description The argument definitions\n     */\n    get argsDef() {\n        return getArgsDef(this.registry, this.meta);\n    }\n    /**\n     * @description The argument entries\n     */\n    get argsEntries() {\n        return [...this.getT('args').entries()];\n    }\n    /**\n     * @description The encoded `[sectionIndex, methodIndex]` identifier\n     */\n    get callIndex() {\n        return this.getT('callIndex').toU8a();\n    }\n    /**\n     * @description The encoded data\n     */\n    get data() {\n        return this.getT('args').toU8a();\n    }\n    /**\n     * @description The [[FunctionMetadata]]\n     */\n    get meta() {\n        return this._meta;\n    }\n    /**\n     * @description Returns the name of the method\n     */\n    get method() {\n        return this.registry.findMetaCall(this.callIndex).method;\n    }\n    /**\n     * @description Returns the module containing the method\n     */\n    get section() {\n        return this.registry.findMetaCall(this.callIndex).section;\n    }\n    /**\n     * @description Checks if the source matches this in type\n     */\n    is(other) {\n        return other.callIndex[0] === this.callIndex[0] && other.callIndex[1] === this.callIndex[1];\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExpanded, disableAscii) {\n        let call;\n        try {\n            call = this.registry.findMetaCall(this.callIndex);\n        }\n        catch {\n            // swallow\n        }\n        return objectSpread({\n            args: this.argsEntries.reduce((args, [n, a]) => objectSpread(args, { [n]: a.toHuman(isExpanded, disableAscii) }), {}),\n            method: call?.method,\n            section: call?.section\n        }, isExpanded && call\n            ? { docs: call.meta.docs.map((d) => d.toString()) }\n            : null);\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'Call';\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}