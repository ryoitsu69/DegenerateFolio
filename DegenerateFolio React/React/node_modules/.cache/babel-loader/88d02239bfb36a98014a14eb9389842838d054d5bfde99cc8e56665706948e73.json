{"ast":null,"code":"import { compactAddLength, compactFromU8aLim, compactToU8a, isString, isU8a, u8aToU8a } from '@polkadot/util';\nimport { Raw } from '../native/Raw.js';\nconst MAX_LENGTH = 10 * 1024 * 1024;\n/** @internal */\nfunction decodeBytesU8a(value) {\n  if (!value.length) {\n    return [new Uint8Array(), 0];\n  }\n  // handle all other Uint8Array inputs, these do have a length prefix\n  const [offset, length] = compactFromU8aLim(value);\n  const total = offset + length;\n  if (length > MAX_LENGTH) {\n    throw new Error(\"Bytes length \".concat(length.toString(), \" exceeds \").concat(MAX_LENGTH));\n  } else if (total > value.length) {\n    throw new Error(\"Bytes: required length less than remainder, expected at least \".concat(total, \", found \").concat(value.length));\n  }\n  return [value.subarray(offset, total), total];\n}\n/**\n * @name Bytes\n * @description\n * A Bytes wrapper for Vec<u8>. The significant difference between this and a normal Uint8Array\n * is that this version allows for length-encoding. (i.e. it is a variable-item codec, the same\n * as what is found in [[Text]] and [[Vec]])\n */\nexport class Bytes extends Raw {\n  constructor(registry, value) {\n    const [u8a, decodedLength] = isU8a(value) && !(value instanceof Raw) ? decodeBytesU8a(value) : Array.isArray(value) || isString(value) ? [u8aToU8a(value), 0] : [value, 0];\n    super(registry, u8a, decodedLength);\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    return this.length + compactToU8a(this.length).length;\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect(isBare) {\n    const clength = compactToU8a(this.length);\n    return {\n      outer: isBare ? [super.toU8a()] : this.length ? [clength, super.toU8a()] : [clength]\n    };\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'Bytes';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    return isBare ? super.toU8a(isBare) : compactAddLength(this);\n  }\n}","map":{"version":3,"names":["compactAddLength","compactFromU8aLim","compactToU8a","isString","isU8a","u8aToU8a","Raw","MAX_LENGTH","decodeBytesU8a","value","length","Uint8Array","offset","total","Error","concat","toString","subarray","Bytes","constructor","registry","u8a","decodedLength","Array","isArray","encodedLength","inspect","isBare","clength","outer","toU8a","toRawType"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/extended/Bytes.js"],"sourcesContent":["import { compactAddLength, compactFromU8aLim, compactToU8a, isString, isU8a, u8aToU8a } from '@polkadot/util';\nimport { Raw } from '../native/Raw.js';\nconst MAX_LENGTH = 10 * 1024 * 1024;\n/** @internal */\nfunction decodeBytesU8a(value) {\n    if (!value.length) {\n        return [new Uint8Array(), 0];\n    }\n    // handle all other Uint8Array inputs, these do have a length prefix\n    const [offset, length] = compactFromU8aLim(value);\n    const total = offset + length;\n    if (length > MAX_LENGTH) {\n        throw new Error(`Bytes length ${length.toString()} exceeds ${MAX_LENGTH}`);\n    }\n    else if (total > value.length) {\n        throw new Error(`Bytes: required length less than remainder, expected at least ${total}, found ${value.length}`);\n    }\n    return [value.subarray(offset, total), total];\n}\n/**\n * @name Bytes\n * @description\n * A Bytes wrapper for Vec<u8>. The significant difference between this and a normal Uint8Array\n * is that this version allows for length-encoding. (i.e. it is a variable-item codec, the same\n * as what is found in [[Text]] and [[Vec]])\n */\nexport class Bytes extends Raw {\n    constructor(registry, value) {\n        const [u8a, decodedLength] = isU8a(value) && !(value instanceof Raw)\n            ? decodeBytesU8a(value)\n            : Array.isArray(value) || isString(value)\n                ? [u8aToU8a(value), 0]\n                : [value, 0];\n        super(registry, u8a, decodedLength);\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return this.length + compactToU8a(this.length).length;\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect(isBare) {\n        const clength = compactToU8a(this.length);\n        return {\n            outer: isBare\n                ? [super.toU8a()]\n                : this.length\n                    ? [clength, super.toU8a()]\n                    : [clength]\n        };\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'Bytes';\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        return isBare\n            ? super.toU8a(isBare)\n            : compactAddLength(this);\n    }\n}\n"],"mappings":"AAAA,SAASA,gBAAgB,EAAEC,iBAAiB,EAAEC,YAAY,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,QAAQ,QAAQ,gBAAgB;AAC7G,SAASC,GAAG,QAAQ,kBAAkB;AACtC,MAAMC,UAAU,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI;AACnC;AACA,SAASC,cAAcA,CAACC,KAAK,EAAE;EAC3B,IAAI,CAACA,KAAK,CAACC,MAAM,EAAE;IACf,OAAO,CAAC,IAAIC,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC;EAChC;EACA;EACA,MAAM,CAACC,MAAM,EAAEF,MAAM,CAAC,GAAGT,iBAAiB,CAACQ,KAAK,CAAC;EACjD,MAAMI,KAAK,GAAGD,MAAM,GAAGF,MAAM;EAC7B,IAAIA,MAAM,GAAGH,UAAU,EAAE;IACrB,MAAM,IAAIO,KAAK,iBAAAC,MAAA,CAAiBL,MAAM,CAACM,QAAQ,CAAC,CAAC,eAAAD,MAAA,CAAYR,UAAU,CAAE,CAAC;EAC9E,CAAC,MACI,IAAIM,KAAK,GAAGJ,KAAK,CAACC,MAAM,EAAE;IAC3B,MAAM,IAAII,KAAK,kEAAAC,MAAA,CAAkEF,KAAK,cAAAE,MAAA,CAAWN,KAAK,CAACC,MAAM,CAAE,CAAC;EACpH;EACA,OAAO,CAACD,KAAK,CAACQ,QAAQ,CAACL,MAAM,EAAEC,KAAK,CAAC,EAAEA,KAAK,CAAC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMK,KAAK,SAASZ,GAAG,CAAC;EAC3Ba,WAAWA,CAACC,QAAQ,EAAEX,KAAK,EAAE;IACzB,MAAM,CAACY,GAAG,EAAEC,aAAa,CAAC,GAAGlB,KAAK,CAACK,KAAK,CAAC,IAAI,EAAEA,KAAK,YAAYH,GAAG,CAAC,GAC9DE,cAAc,CAACC,KAAK,CAAC,GACrBc,KAAK,CAACC,OAAO,CAACf,KAAK,CAAC,IAAIN,QAAQ,CAACM,KAAK,CAAC,GACnC,CAACJ,QAAQ,CAACI,KAAK,CAAC,EAAE,CAAC,CAAC,GACpB,CAACA,KAAK,EAAE,CAAC,CAAC;IACpB,KAAK,CAACW,QAAQ,EAAEC,GAAG,EAAEC,aAAa,CAAC;EACvC;EACA;AACJ;AACA;EACI,IAAIG,aAAaA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACf,MAAM,GAAGR,YAAY,CAAC,IAAI,CAACQ,MAAM,CAAC,CAACA,MAAM;EACzD;EACA;AACJ;AACA;EACIgB,OAAOA,CAACC,MAAM,EAAE;IACZ,MAAMC,OAAO,GAAG1B,YAAY,CAAC,IAAI,CAACQ,MAAM,CAAC;IACzC,OAAO;MACHmB,KAAK,EAAEF,MAAM,GACP,CAAC,KAAK,CAACG,KAAK,CAAC,CAAC,CAAC,GACf,IAAI,CAACpB,MAAM,GACP,CAACkB,OAAO,EAAE,KAAK,CAACE,KAAK,CAAC,CAAC,CAAC,GACxB,CAACF,OAAO;IACtB,CAAC;EACL;EACA;AACJ;AACA;EACIG,SAASA,CAAA,EAAG;IACR,OAAO,OAAO;EAClB;EACA;AACJ;AACA;AACA;EACID,KAAKA,CAACH,MAAM,EAAE;IACV,OAAOA,MAAM,GACP,KAAK,CAACG,KAAK,CAACH,MAAM,CAAC,GACnB3B,gBAAgB,CAAC,IAAI,CAAC;EAChC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}