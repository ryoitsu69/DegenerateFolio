{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ensureLeftNeighbor = exports.ensureSpec = exports.calculateExistenceRoot = exports.verifyNonExistence = exports.verifyExistence = exports.smtSpec = exports.tendermintSpec = exports.iavlSpec = void 0;\nconst codecimpl_1 = require(\"./generated/codecimpl\");\nconst ops_1 = require(\"./ops\");\nconst specs_1 = require(\"./specs\");\nexports.iavlSpec = {\n  leafSpec: {\n    prefix: Uint8Array.from([0]),\n    hash: codecimpl_1.ics23.HashOp.SHA256,\n    prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n    prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n    length: codecimpl_1.ics23.LengthOp.VAR_PROTO\n  },\n  innerSpec: {\n    childOrder: [0, 1],\n    minPrefixLength: 4,\n    maxPrefixLength: 12,\n    childSize: 33,\n    hash: codecimpl_1.ics23.HashOp.SHA256\n  }\n};\nexports.tendermintSpec = {\n  leafSpec: {\n    prefix: Uint8Array.from([0]),\n    hash: codecimpl_1.ics23.HashOp.SHA256,\n    prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n    prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n    length: codecimpl_1.ics23.LengthOp.VAR_PROTO\n  },\n  innerSpec: {\n    childOrder: [0, 1],\n    minPrefixLength: 1,\n    maxPrefixLength: 1,\n    childSize: 32,\n    hash: codecimpl_1.ics23.HashOp.SHA256\n  }\n};\nexports.smtSpec = {\n  leafSpec: {\n    hash: codecimpl_1.ics23.HashOp.SHA256,\n    prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n    prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n    length: codecimpl_1.ics23.LengthOp.NO_PREFIX,\n    prefix: Uint8Array.from([0])\n  },\n  innerSpec: {\n    childOrder: [0, 1],\n    childSize: 32,\n    minPrefixLength: 1,\n    maxPrefixLength: 1,\n    emptyChild: new Uint8Array(32),\n    hash: codecimpl_1.ics23.HashOp.SHA256\n  },\n  maxDepth: 256\n};\n// verifyExistence will throw an error if the proof doesn't link key, value -> root\n// or if it doesn't fulfill the spec\nfunction verifyExistence(proof, spec, root, key, value) {\n  ensureSpec(proof, spec);\n  const calc = calculateExistenceRoot(proof);\n  (0, specs_1.ensureBytesEqual)(calc, root);\n  (0, specs_1.ensureBytesEqual)(key, proof.key);\n  (0, specs_1.ensureBytesEqual)(value, proof.value);\n}\nexports.verifyExistence = verifyExistence;\n// Verify does all checks to ensure the proof has valid non-existence proofs,\n// and they ensure the given key is not in the CommitmentState,\n// throwing an error if there is an issue\nfunction verifyNonExistence(proof, spec, root, key) {\n  let leftKey;\n  let rightKey;\n  if (proof.left) {\n    verifyExistence(proof.left, spec, root, proof.left.key, proof.left.value);\n    leftKey = proof.left.key;\n  }\n  if (proof.right) {\n    verifyExistence(proof.right, spec, root, proof.right.key, proof.right.value);\n    rightKey = proof.right.key;\n  }\n  if (!leftKey && !rightKey) {\n    throw new Error(\"neither left nor right proof defined\");\n  }\n  if (leftKey) {\n    (0, specs_1.ensureBytesBefore)(leftKey, key);\n  }\n  if (rightKey) {\n    (0, specs_1.ensureBytesBefore)(key, rightKey);\n  }\n  if (!spec.innerSpec) {\n    throw new Error(\"no inner spec\");\n  }\n  if (!leftKey) {\n    ensureLeftMost(spec.innerSpec, proof.right.path);\n  } else if (!rightKey) {\n    ensureRightMost(spec.innerSpec, proof.left.path);\n  } else {\n    ensureLeftNeighbor(spec.innerSpec, proof.left.path, proof.right.path);\n  }\n  return;\n}\nexports.verifyNonExistence = verifyNonExistence;\n// Calculate determines the root hash that matches the given proof.\n// You must validate the result is what you have in a header.\n// Returns error if the calculations cannot be performed.\nfunction calculateExistenceRoot(proof) {\n  if (!proof.key || !proof.value) {\n    throw new Error(\"Existence proof needs key and value set\");\n  }\n  if (!proof.leaf) {\n    throw new Error(\"Existence proof must start with a leaf operation\");\n  }\n  const path = proof.path || [];\n  let res = (0, ops_1.applyLeaf)(proof.leaf, proof.key, proof.value);\n  for (const inner of path) {\n    res = (0, ops_1.applyInner)(inner, res);\n  }\n  return res;\n}\nexports.calculateExistenceRoot = calculateExistenceRoot;\n// ensureSpec throws an Error if proof doesn't fulfill spec\nfunction ensureSpec(proof, spec) {\n  if (!proof.leaf) {\n    throw new Error(\"Existence proof must start with a leaf operation\");\n  }\n  if (!spec.leafSpec) {\n    throw new Error(\"Spec must include leafSpec\");\n  }\n  if (!spec.innerSpec) {\n    throw new Error(\"Spec must include innerSpec\");\n  }\n  (0, specs_1.ensureLeaf)(proof.leaf, spec.leafSpec);\n  const path = proof.path || [];\n  if (spec.minDepth && path.length < spec.minDepth) {\n    throw new Error(`Too few inner nodes ${path.length}`);\n  }\n  if (spec.maxDepth && path.length > spec.maxDepth) {\n    throw new Error(`Too many inner nodes ${path.length}`);\n  }\n  for (const inner of path) {\n    (0, specs_1.ensureInner)(inner, spec.leafSpec.prefix, spec.innerSpec);\n  }\n}\nexports.ensureSpec = ensureSpec;\nfunction ensureLeftMost(spec, path) {\n  const {\n    minPrefix,\n    maxPrefix,\n    suffix\n  } = getPadding(spec, 0);\n  // ensure every step has a prefix and suffix defined to be leftmost\n  for (const step of path) {\n    if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n      throw new Error(\"Step not leftmost\");\n    }\n  }\n}\nfunction ensureRightMost(spec, path) {\n  const len = spec.childOrder.length - 1;\n  const {\n    minPrefix,\n    maxPrefix,\n    suffix\n  } = getPadding(spec, len);\n  // ensure every step has a prefix and suffix defined to be leftmost\n  for (const step of path) {\n    if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n      throw new Error(\"Step not leftmost\");\n    }\n  }\n}\nfunction ensureLeftNeighbor(spec, left, right) {\n  const mutleft = [...left];\n  const mutright = [...right];\n  let topleft = mutleft.pop();\n  let topright = mutright.pop();\n  while ((0, specs_1.bytesEqual)(topleft.prefix, topright.prefix) && (0, specs_1.bytesEqual)(topleft.suffix, topright.suffix)) {\n    topleft = mutleft.pop();\n    topright = mutright.pop();\n  }\n  // now topleft and topright are the first divergent nodes\n  // make sure they are left and right of each other\n  if (!isLeftStep(spec, topleft, topright)) {\n    throw new Error(`Not left neightbor at first divergent step`);\n  }\n  // make sure the paths are left and right most possibilities respectively\n  ensureRightMost(spec, mutleft);\n  ensureLeftMost(spec, mutright);\n}\nexports.ensureLeftNeighbor = ensureLeftNeighbor;\n// isLeftStep assumes left and right have common parents\n// checks if left is exactly one slot to the left of right\nfunction isLeftStep(spec, left, right) {\n  const leftidx = orderFromPadding(spec, left);\n  const rightidx = orderFromPadding(spec, right);\n  return rightidx === leftidx + 1;\n}\nfunction orderFromPadding(spec, inner) {\n  for (let branch = 0; branch < spec.childOrder.length; branch++) {\n    const {\n      minPrefix,\n      maxPrefix,\n      suffix\n    } = getPadding(spec, branch);\n    if (hasPadding(inner, minPrefix, maxPrefix, suffix)) {\n      return branch;\n    }\n  }\n  throw new Error(`Cannot find any valid spacing for this node`);\n}\nfunction hasPadding(op, minPrefix, maxPrefix, suffix) {\n  if ((op.prefix || []).length < minPrefix) {\n    return false;\n  }\n  if ((op.prefix || []).length > maxPrefix) {\n    return false;\n  }\n  return (op.suffix || []).length === suffix;\n}\nfunction getPadding(spec, branch) {\n  const idx = getPosition(spec.childOrder, branch);\n  // count how many children are in the prefix\n  const prefix = idx * spec.childSize;\n  const minPrefix = prefix + spec.minPrefixLength;\n  const maxPrefix = prefix + spec.maxPrefixLength;\n  // count how many children are in the suffix\n  const suffix = (spec.childOrder.length - 1 - idx) * spec.childSize;\n  return {\n    minPrefix,\n    maxPrefix,\n    suffix\n  };\n}\nfunction getPosition(order, branch) {\n  if (branch < 0 || branch >= order.length) {\n    throw new Error(`Invalid branch: ${branch}`);\n  }\n  return order.findIndex(val => val === branch);\n}","map":{"version":3,"names":["codecimpl_1","require","ops_1","specs_1","exports","iavlSpec","leafSpec","prefix","Uint8Array","from","hash","ics23","HashOp","SHA256","prehashValue","prehashKey","NO_HASH","length","LengthOp","VAR_PROTO","innerSpec","childOrder","minPrefixLength","maxPrefixLength","childSize","tendermintSpec","smtSpec","NO_PREFIX","emptyChild","maxDepth","verifyExistence","proof","spec","root","key","value","ensureSpec","calc","calculateExistenceRoot","ensureBytesEqual","verifyNonExistence","leftKey","rightKey","left","right","Error","ensureBytesBefore","ensureLeftMost","path","ensureRightMost","ensureLeftNeighbor","leaf","res","applyLeaf","inner","applyInner","ensureLeaf","minDepth","ensureInner","minPrefix","maxPrefix","suffix","getPadding","step","hasPadding","len","mutleft","mutright","topleft","pop","topright","bytesEqual","isLeftStep","leftidx","orderFromPadding","rightidx","branch","op","idx","getPosition","order","findIndex","val"],"sources":["../src/proofs.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}