{"ast":null,"code":"import { catchError, combineLatest, map, of, switchMap } from 'rxjs';\nimport { isNumber, isUndefined } from '@polkadot/util';\nimport { unwrapBlockNumber } from '../util/index.js';\nimport { FALLBACK_MAX_HASH_COUNT, FALLBACK_PERIOD, MAX_FINALITY_LAG, MORTAL_PERIOD } from './constants.js';\nfunction latestNonce(api, address) {\n  return api.derive.balances.account(address).pipe(map(_ref => {\n    let {\n      accountNonce\n    } = _ref;\n    return accountNonce;\n  }));\n}\nfunction nextNonce(api, address) {\n  var _api$rpc$system;\n  return (_api$rpc$system = api.rpc.system) !== null && _api$rpc$system !== void 0 && _api$rpc$system.accountNextIndex ? api.rpc.system.accountNextIndex(address) : latestNonce(api, address);\n}\nfunction signingHeader(api) {\n  return combineLatest([api.rpc.chain.getHeader().pipe(switchMap(header =>\n  // check for chains at genesis (until block 1 is produced, e.g. 6s), since\n  // we do need to allow transactions at chain start (also dev/seal chains)\n  header.parentHash.isEmpty ? of(header)\n  // in the case of the current block, we use the parent to minimize the\n  // impact of forks on the system, but not completely remove it\n  : api.rpc.chain.getHeader(header.parentHash).pipe(catchError(() => of(header))))), api.rpc.chain.getFinalizedHead().pipe(switchMap(hash => api.rpc.chain.getHeader(hash).pipe(catchError(() => of(null)))))]).pipe(map(_ref2 => {\n    let [current, finalized] = _ref2;\n    return (\n      // determine the hash to use, current when lag > max, else finalized\n      !finalized || unwrapBlockNumber(current).sub(unwrapBlockNumber(finalized)).gt(MAX_FINALITY_LAG) ? current : finalized\n    );\n  }));\n}\nfunction babeOrAuraPeriod(api) {\n  var _api$consts$babe, _api$consts$aura, _api$consts$timestamp;\n  const period = ((_api$consts$babe = api.consts.babe) === null || _api$consts$babe === void 0 ? void 0 : _api$consts$babe.expectedBlockTime) || ( // this will be present ones https://github.com/paritytech/polkadot-sdk/pull/3732 is merged\n  (_api$consts$aura = api.consts['aura']) === null || _api$consts$aura === void 0 ? void 0 : _api$consts$aura.slotDuration) || ((_api$consts$timestamp = api.consts.timestamp) === null || _api$consts$timestamp === void 0 ? void 0 : _api$consts$timestamp.minimumPeriod.muln(2));\n  return !period.isZero() ? period : undefined;\n}\nexport function signingInfo(_instanceId, api) {\n  // no memo, we want to do this fresh on each run\n  return (address, nonce, era) => combineLatest([\n  // retrieve nonce if none was specified\n  isUndefined(nonce) ? latestNonce(api, address) : nonce === -1 ? nextNonce(api, address) : of(api.registry.createType('Index', nonce)),\n  // if no era (create) or era > 0 (mortal), do block retrieval\n  isUndefined(era) || isNumber(era) && era > 0 ? signingHeader(api) : of(null)]).pipe(map(_ref3 => {\n    var _api$consts$system;\n    let [nonce, header] = _ref3;\n    return {\n      header,\n      mortalLength: Math.min(((_api$consts$system = api.consts.system) === null || _api$consts$system === void 0 || (_api$consts$system = _api$consts$system.blockHashCount) === null || _api$consts$system === void 0 ? void 0 : _api$consts$system.toNumber()) || FALLBACK_MAX_HASH_COUNT, MORTAL_PERIOD.div(babeOrAuraPeriod(api) || FALLBACK_PERIOD).iadd(MAX_FINALITY_LAG).toNumber()),\n      nonce\n    };\n  }));\n}","map":{"version":3,"names":["catchError","combineLatest","map","of","switchMap","isNumber","isUndefined","unwrapBlockNumber","FALLBACK_MAX_HASH_COUNT","FALLBACK_PERIOD","MAX_FINALITY_LAG","MORTAL_PERIOD","latestNonce","api","address","derive","balances","account","pipe","_ref","accountNonce","nextNonce","_api$rpc$system","rpc","system","accountNextIndex","signingHeader","chain","getHeader","header","parentHash","isEmpty","getFinalizedHead","hash","_ref2","current","finalized","sub","gt","babeOrAuraPeriod","_api$consts$babe","_api$consts$aura","_api$consts$timestamp","period","consts","babe","expectedBlockTime","slotDuration","timestamp","minimumPeriod","muln","isZero","undefined","signingInfo","_instanceId","nonce","era","registry","createType","_ref3","_api$consts$system","mortalLength","Math","min","blockHashCount","toNumber","div","iadd"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api-derive/tx/signingInfo.js"],"sourcesContent":["import { catchError, combineLatest, map, of, switchMap } from 'rxjs';\nimport { isNumber, isUndefined } from '@polkadot/util';\nimport { unwrapBlockNumber } from '../util/index.js';\nimport { FALLBACK_MAX_HASH_COUNT, FALLBACK_PERIOD, MAX_FINALITY_LAG, MORTAL_PERIOD } from './constants.js';\nfunction latestNonce(api, address) {\n    return api.derive.balances.account(address).pipe(map(({ accountNonce }) => accountNonce));\n}\nfunction nextNonce(api, address) {\n    return api.rpc.system?.accountNextIndex\n        ? api.rpc.system.accountNextIndex(address)\n        : latestNonce(api, address);\n}\nfunction signingHeader(api) {\n    return combineLatest([\n        api.rpc.chain.getHeader().pipe(switchMap((header) => \n        // check for chains at genesis (until block 1 is produced, e.g. 6s), since\n        // we do need to allow transactions at chain start (also dev/seal chains)\n        header.parentHash.isEmpty\n            ? of(header)\n            // in the case of the current block, we use the parent to minimize the\n            // impact of forks on the system, but not completely remove it\n            : api.rpc.chain.getHeader(header.parentHash).pipe(catchError(() => of(header))))),\n        api.rpc.chain.getFinalizedHead().pipe(switchMap((hash) => api.rpc.chain.getHeader(hash).pipe(catchError(() => of(null)))))\n    ]).pipe(map(([current, finalized]) => \n    // determine the hash to use, current when lag > max, else finalized\n    !finalized || unwrapBlockNumber(current).sub(unwrapBlockNumber(finalized)).gt(MAX_FINALITY_LAG)\n        ? current\n        : finalized));\n}\nfunction babeOrAuraPeriod(api) {\n    const period = api.consts.babe?.expectedBlockTime ||\n        // this will be present ones https://github.com/paritytech/polkadot-sdk/pull/3732 is merged\n        api.consts['aura']?.slotDuration ||\n        api.consts.timestamp?.minimumPeriod.muln(2);\n    return !period.isZero() ? period : undefined;\n}\nexport function signingInfo(_instanceId, api) {\n    // no memo, we want to do this fresh on each run\n    return (address, nonce, era) => combineLatest([\n        // retrieve nonce if none was specified\n        isUndefined(nonce)\n            ? latestNonce(api, address)\n            : nonce === -1\n                ? nextNonce(api, address)\n                : of(api.registry.createType('Index', nonce)),\n        // if no era (create) or era > 0 (mortal), do block retrieval\n        (isUndefined(era) || (isNumber(era) && era > 0))\n            ? signingHeader(api)\n            : of(null)\n    ]).pipe(map(([nonce, header]) => ({\n        header,\n        mortalLength: Math.min(api.consts.system?.blockHashCount?.toNumber() || FALLBACK_MAX_HASH_COUNT, MORTAL_PERIOD\n            .div(babeOrAuraPeriod(api) || FALLBACK_PERIOD)\n            .iadd(MAX_FINALITY_LAG)\n            .toNumber()),\n        nonce\n    })));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}