{"ast":null,"code":"import _defineProperty from \"/home/ryoitsu/Documents/test/react-todo-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { EventEmitter } from 'eventemitter3';\nimport { isChildClass, isNull, isUndefined, logger, noop, objectSpread, stringify } from '@polkadot/util';\nimport { xglobal } from '@polkadot/x-global';\nimport { WebSocket } from '@polkadot/x-ws';\nimport { RpcCoder } from '../coder/index.js';\nimport defaults from '../defaults.js';\nimport { DEFAULT_CAPACITY, LRUCache } from '../lru.js';\nimport { getWSErrorString } from './errors.js';\nconst ALIASES = {\n  chain_finalisedHead: 'chain_finalizedHead',\n  chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',\n  chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'\n};\nconst RETRY_DELAY = 2500;\nconst DEFAULT_TIMEOUT_MS = 60 * 1000;\nconst TIMEOUT_INTERVAL = 5000;\nconst l = logger('api-ws');\n/** @internal Clears a Record<*> of all keys, optionally with all callback on clear */\nfunction eraseRecord(record, cb) {\n  Object.keys(record).forEach(key => {\n    if (cb) {\n      cb(record[key]);\n    }\n    delete record[key];\n  });\n}\n/** @internal Creates a default/empty stats object */\nfunction defaultEndpointStats() {\n  return {\n    bytesRecv: 0,\n    bytesSent: 0,\n    cached: 0,\n    errors: 0,\n    requests: 0,\n    subscriptions: 0,\n    timeout: 0\n  };\n}\n/**\n * # @polkadot/rpc-provider/ws\n *\n * @name WsProvider\n *\n * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Api from '@polkadot/api/promise';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const api = new Api(provider);\n * ```\n *\n * @see [[HttpProvider]]\n */\nexport class WsProvider {\n  /**\n   * @param {string | string[]}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.\n   * @param {number | false} autoConnectMs Whether to connect automatically or not (default). Provided value is used as a delay between retries.\n   * @param {Record<string, string>} headers The headers provided to the underlying WebSocket\n   * @param {number} [timeout] Custom timeout value used per request . Defaults to `DEFAULT_TIMEOUT_MS`\n   */\n  constructor() {\n    var _this = this;\n    let endpoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaults.WS_URL;\n    let autoConnectMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : RETRY_DELAY;\n    let headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let timeout = arguments.length > 3 ? arguments[3] : undefined;\n    let cacheCapacity = arguments.length > 4 ? arguments[4] : undefined;\n    _defineProperty(this, \"__internal__callCache\", void 0);\n    _defineProperty(this, \"__internal__coder\", void 0);\n    _defineProperty(this, \"__internal__endpoints\", void 0);\n    _defineProperty(this, \"__internal__headers\", void 0);\n    _defineProperty(this, \"__internal__eventemitter\", void 0);\n    _defineProperty(this, \"__internal__handlers\", {});\n    _defineProperty(this, \"__internal__isReadyPromise\", void 0);\n    _defineProperty(this, \"__internal__stats\", void 0);\n    _defineProperty(this, \"__internal__waitingForId\", {});\n    _defineProperty(this, \"__internal__autoConnectMs\", void 0);\n    _defineProperty(this, \"__internal__endpointIndex\", void 0);\n    _defineProperty(this, \"__internal__endpointStats\", void 0);\n    _defineProperty(this, \"__internal__isConnected\", false);\n    _defineProperty(this, \"__internal__subscriptions\", {});\n    _defineProperty(this, \"__internal__timeoutId\", null);\n    _defineProperty(this, \"__internal__websocket\", void 0);\n    _defineProperty(this, \"__internal__timeout\", void 0);\n    _defineProperty(this, \"__internal__emit\", function (type) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      _this.__internal__eventemitter.emit(type, ...args);\n    });\n    _defineProperty(this, \"__internal__onSocketClose\", event => {\n      const error = new Error(\"disconnected from \".concat(this.endpoint, \": \").concat(event.code, \":: \").concat(event.reason || getWSErrorString(event.code)));\n      if (this.__internal__autoConnectMs > 0) {\n        l.error(error.message);\n      }\n      this.__internal__isConnected = false;\n      if (this.__internal__websocket) {\n        this.__internal__websocket.onclose = null;\n        this.__internal__websocket.onerror = null;\n        this.__internal__websocket.onmessage = null;\n        this.__internal__websocket.onopen = null;\n        this.__internal__websocket = null;\n      }\n      if (this.__internal__timeoutId) {\n        clearInterval(this.__internal__timeoutId);\n        this.__internal__timeoutId = null;\n      }\n      // reject all hanging requests\n      eraseRecord(this.__internal__handlers, h => {\n        try {\n          h.callback(error, undefined);\n        } catch (err) {\n          // does not throw\n          l.error(err);\n        }\n      });\n      eraseRecord(this.__internal__waitingForId);\n      // Reset stats for active endpoint\n      this.__internal__endpointStats = defaultEndpointStats();\n      this.__internal__emit('disconnected');\n      if (this.__internal__autoConnectMs > 0) {\n        setTimeout(() => {\n          this.connectWithRetry().catch(noop);\n        }, this.__internal__autoConnectMs);\n      }\n    });\n    _defineProperty(this, \"__internal__onSocketError\", error => {\n      l.debug(() => ['socket error', error]);\n      this.__internal__emit('error', error);\n    });\n    _defineProperty(this, \"__internal__onSocketMessage\", message => {\n      l.debug(() => ['received', message.data]);\n      const bytesRecv = message.data.length;\n      this.__internal__endpointStats.bytesRecv += bytesRecv;\n      this.__internal__stats.total.bytesRecv += bytesRecv;\n      const response = JSON.parse(message.data);\n      return isUndefined(response.method) ? this.__internal__onSocketMessageResult(response) : this.__internal__onSocketMessageSubscribe(response);\n    });\n    _defineProperty(this, \"__internal__onSocketMessageResult\", response => {\n      const handler = this.__internal__handlers[response.id];\n      if (!handler) {\n        l.debug(() => \"Unable to find handler for id=\".concat(response.id));\n        return;\n      }\n      try {\n        const {\n          method,\n          params,\n          subscription\n        } = handler;\n        const result = this.__internal__coder.decodeResponse(response);\n        // first send the result - in case of subs, we may have an update\n        // immediately if we have some queued results already\n        handler.callback(null, result);\n        if (subscription) {\n          const subId = \"\".concat(subscription.type, \"::\").concat(result);\n          this.__internal__subscriptions[subId] = objectSpread({}, subscription, {\n            method,\n            params\n          });\n          // if we have a result waiting for this subscription already\n          if (this.__internal__waitingForId[subId]) {\n            this.__internal__onSocketMessageSubscribe(this.__internal__waitingForId[subId]);\n          }\n        }\n      } catch (error) {\n        this.__internal__endpointStats.errors++;\n        this.__internal__stats.total.errors++;\n        handler.callback(error, undefined);\n      }\n      delete this.__internal__handlers[response.id];\n    });\n    _defineProperty(this, \"__internal__onSocketMessageSubscribe\", response => {\n      if (!response.method) {\n        throw new Error('No method found in JSONRPC response');\n      }\n      const method = ALIASES[response.method] || response.method;\n      const subId = \"\".concat(method, \"::\").concat(response.params.subscription);\n      const handler = this.__internal__subscriptions[subId];\n      if (!handler) {\n        // store the JSON, we could have out-of-order subid coming in\n        this.__internal__waitingForId[subId] = response;\n        l.debug(() => \"Unable to find handler for subscription=\".concat(subId));\n        return;\n      }\n      // housekeeping\n      delete this.__internal__waitingForId[subId];\n      try {\n        const result = this.__internal__coder.decodeResponse(response);\n        handler.callback(null, result);\n      } catch (error) {\n        this.__internal__endpointStats.errors++;\n        this.__internal__stats.total.errors++;\n        handler.callback(error, undefined);\n      }\n    });\n    _defineProperty(this, \"__internal__onSocketOpen\", () => {\n      if (this.__internal__websocket === null) {\n        throw new Error('WebSocket cannot be null in onOpen');\n      }\n      l.debug(() => ['connected to', this.endpoint]);\n      this.__internal__isConnected = true;\n      this.__internal__resubscribe();\n      this.__internal__emit('connected');\n      return true;\n    });\n    _defineProperty(this, \"__internal__resubscribe\", () => {\n      const subscriptions = this.__internal__subscriptions;\n      this.__internal__subscriptions = {};\n      Promise.all(Object.keys(subscriptions).map(async id => {\n        const {\n          callback,\n          method,\n          params,\n          type\n        } = subscriptions[id];\n        // only re-create subscriptions which are not in author (only area where\n        // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n        // are not included (and will not be re-broadcast)\n        if (type.startsWith('author_')) {\n          return;\n        }\n        try {\n          await this.subscribe(type, method, params, callback);\n        } catch (error) {\n          l.error(error);\n        }\n      })).catch(l.error);\n    });\n    _defineProperty(this, \"__internal__timeoutHandlers\", () => {\n      const now = Date.now();\n      const ids = Object.keys(this.__internal__handlers);\n      for (let i = 0, count = ids.length; i < count; i++) {\n        const handler = this.__internal__handlers[ids[i]];\n        if (now - handler.start > this.__internal__timeout) {\n          try {\n            handler.callback(new Error(\"No response received from RPC endpoint in \".concat(this.__internal__timeout / 1000, \"s\")), undefined);\n          } catch {\n            // ignore\n          }\n          this.__internal__endpointStats.timeout++;\n          this.__internal__stats.total.timeout++;\n          delete this.__internal__handlers[ids[i]];\n        }\n      }\n    });\n    const endpoints = Array.isArray(endpoint) ? endpoint : [endpoint];\n    if (endpoints.length === 0) {\n      throw new Error('WsProvider requires at least one Endpoint');\n    }\n    endpoints.forEach(endpoint => {\n      if (!/^(wss|ws):\\/\\//.test(endpoint)) {\n        throw new Error(\"Endpoint should start with 'ws://', received '\".concat(endpoint, \"'\"));\n      }\n    });\n    this.__internal__callCache = new LRUCache(cacheCapacity || DEFAULT_CAPACITY);\n    this.__internal__eventemitter = new EventEmitter();\n    this.__internal__autoConnectMs = autoConnectMs || 0;\n    this.__internal__coder = new RpcCoder();\n    this.__internal__endpointIndex = -1;\n    this.__internal__endpoints = endpoints;\n    this.__internal__headers = headers;\n    this.__internal__websocket = null;\n    this.__internal__stats = {\n      active: {\n        requests: 0,\n        subscriptions: 0\n      },\n      total: defaultEndpointStats()\n    };\n    this.__internal__endpointStats = defaultEndpointStats();\n    this.__internal__timeout = timeout || DEFAULT_TIMEOUT_MS;\n    if (autoConnectMs && autoConnectMs > 0) {\n      this.connectWithRetry().catch(noop);\n    }\n    this.__internal__isReadyPromise = new Promise(resolve => {\n      this.__internal__eventemitter.once('connected', () => {\n        resolve(this);\n      });\n    });\n  }\n  /**\n   * @summary `true` when this provider supports subscriptions\n   */\n  get hasSubscriptions() {\n    return !!true;\n  }\n  /**\n   * @summary `true` when this provider supports clone()\n   */\n  get isClonable() {\n    return !!true;\n  }\n  /**\n   * @summary Whether the node is connected or not.\n   * @return {boolean} true if connected\n   */\n  get isConnected() {\n    return this.__internal__isConnected;\n  }\n  /**\n   * @description Promise that resolves the first time we are connected and loaded\n   */\n  get isReady() {\n    return this.__internal__isReadyPromise;\n  }\n  get endpoint() {\n    return this.__internal__endpoints[this.__internal__endpointIndex];\n  }\n  /**\n   * @description Returns a clone of the object\n   */\n  clone() {\n    return new WsProvider(this.__internal__endpoints);\n  }\n  selectEndpointIndex(endpoints) {\n    return (this.__internal__endpointIndex + 1) % endpoints.length;\n  }\n  /**\n   * @summary Manually connect\n   * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may\n   * connect manually using this method.\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async connect() {\n    if (this.__internal__websocket) {\n      throw new Error('WebSocket is already connected');\n    }\n    try {\n      this.__internal__endpointIndex = this.selectEndpointIndex(this.__internal__endpoints);\n      // the as here is Deno-specific - not available on the globalThis\n      this.__internal__websocket = typeof xglobal.WebSocket !== 'undefined' && isChildClass(xglobal.WebSocket, WebSocket) ? new WebSocket(this.endpoint)\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore - WS may be an instance of ws, which supports options\n      : new WebSocket(this.endpoint, undefined, {\n        headers: this.__internal__headers\n      });\n      if (this.__internal__websocket) {\n        this.__internal__websocket.onclose = this.__internal__onSocketClose;\n        this.__internal__websocket.onerror = this.__internal__onSocketError;\n        this.__internal__websocket.onmessage = this.__internal__onSocketMessage;\n        this.__internal__websocket.onopen = this.__internal__onSocketOpen;\n      }\n      // timeout any handlers that have not had a response\n      this.__internal__timeoutId = setInterval(() => this.__internal__timeoutHandlers(), TIMEOUT_INTERVAL);\n    } catch (error) {\n      l.error(error);\n      this.__internal__emit('error', error);\n      throw error;\n    }\n  }\n  /**\n   * @description Connect, never throwing an error, but rather forcing a retry\n   */\n  async connectWithRetry() {\n    if (this.__internal__autoConnectMs > 0) {\n      try {\n        await this.connect();\n      } catch {\n        setTimeout(() => {\n          this.connectWithRetry().catch(noop);\n        }, this.__internal__autoConnectMs);\n      }\n    }\n  }\n  /**\n   * @description Manually disconnect from the connection, clearing auto-connect logic\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async disconnect() {\n    // switch off autoConnect, we are in manual mode now\n    this.__internal__autoConnectMs = 0;\n    try {\n      if (this.__internal__websocket) {\n        // 1000 - Normal closure; the connection successfully completed\n        this.__internal__websocket.close(1000);\n      }\n    } catch (error) {\n      l.error(error);\n      this.__internal__emit('error', error);\n      throw error;\n    }\n  }\n  /**\n   * @description Returns the connection stats\n   */\n  get stats() {\n    return {\n      active: {\n        requests: Object.keys(this.__internal__handlers).length,\n        subscriptions: Object.keys(this.__internal__subscriptions).length\n      },\n      total: this.__internal__stats.total\n    };\n  }\n  get endpointStats() {\n    return this.__internal__endpointStats;\n  }\n  /**\n   * @summary Listens on events after having subscribed using the [[subscribe]] function.\n   * @param  {ProviderInterfaceEmitted} type Event\n   * @param  {ProviderInterfaceEmitCb}  sub  Callback\n   * @return unsubscribe function\n   */\n  on(type, sub) {\n    this.__internal__eventemitter.on(type, sub);\n    return () => {\n      this.__internal__eventemitter.removeListener(type, sub);\n    };\n  }\n  /**\n   * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.\n   * @param method The RPC methods to execute\n   * @param params Encoded parameters as applicable for the method\n   * @param subscription Subscription details (internally used)\n   */\n  send(method, params, isCacheable, subscription) {\n    this.__internal__endpointStats.requests++;\n    this.__internal__stats.total.requests++;\n    const [id, body] = this.__internal__coder.encodeJson(method, params);\n    const cacheKey = isCacheable ? \"\".concat(method, \"::\").concat(stringify(params)) : '';\n    let resultPromise = isCacheable ? this.__internal__callCache.get(cacheKey) : null;\n    if (!resultPromise) {\n      resultPromise = this.__internal__send(id, body, method, params, subscription);\n      if (isCacheable) {\n        this.__internal__callCache.set(cacheKey, resultPromise);\n      }\n    } else {\n      this.__internal__endpointStats.cached++;\n      this.__internal__stats.total.cached++;\n    }\n    return resultPromise;\n  }\n  async __internal__send(id, body, method, params, subscription) {\n    return new Promise((resolve, reject) => {\n      try {\n        if (!this.isConnected || this.__internal__websocket === null) {\n          throw new Error('WebSocket is not connected');\n        }\n        const callback = (error, result) => {\n          error ? reject(error) : resolve(result);\n        };\n        l.debug(() => ['calling', method, body]);\n        this.__internal__handlers[id] = {\n          callback,\n          method,\n          params,\n          start: Date.now(),\n          subscription\n        };\n        const bytesSent = body.length;\n        this.__internal__endpointStats.bytesSent += bytesSent;\n        this.__internal__stats.total.bytesSent += bytesSent;\n        this.__internal__websocket.send(body);\n      } catch (error) {\n        this.__internal__endpointStats.errors++;\n        this.__internal__stats.total.errors++;\n        reject(error);\n      }\n    });\n  }\n  /**\n   * @name subscribe\n   * @summary Allows subscribing to a specific event.\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * const provider = new WsProvider('ws://127.0.0.1:9944');\n   * const rpc = new Rpc(provider);\n   *\n   * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {\n   *   console.log(values)\n   * }).then((subscriptionId) => {\n   *   console.log('balance changes subscription id: ', subscriptionId)\n   * })\n   * ```\n   */\n  subscribe(type, method, params, callback) {\n    this.__internal__endpointStats.subscriptions++;\n    this.__internal__stats.total.subscriptions++;\n    // subscriptions are not cached, LRU applies to .at(<blockHash>) only\n    return this.send(method, params, false, {\n      callback,\n      type\n    });\n  }\n  /**\n   * @summary Allows unsubscribing to subscriptions made with [[subscribe]].\n   */\n  async unsubscribe(type, method, id) {\n    const subscription = \"\".concat(type, \"::\").concat(id);\n    // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub\n    // the assigned id now does not match what the API user originally received. It has\n    // a slight complication in solving - since we cannot rely on the send id, but rather\n    // need to find the actual subscription id to map it\n    if (isUndefined(this.__internal__subscriptions[subscription])) {\n      l.debug(() => \"Unable to find active subscription=\".concat(subscription));\n      return false;\n    }\n    delete this.__internal__subscriptions[subscription];\n    try {\n      return this.isConnected && !isNull(this.__internal__websocket) ? this.send(method, [id]) : true;\n    } catch {\n      return false;\n    }\n  }\n}","map":{"version":3,"names":["EventEmitter","isChildClass","isNull","isUndefined","logger","noop","objectSpread","stringify","xglobal","WebSocket","RpcCoder","defaults","DEFAULT_CAPACITY","LRUCache","getWSErrorString","ALIASES","chain_finalisedHead","chain_subscribeFinalisedHeads","chain_unsubscribeFinalisedHeads","RETRY_DELAY","DEFAULT_TIMEOUT_MS","TIMEOUT_INTERVAL","l","eraseRecord","record","cb","Object","keys","forEach","key","defaultEndpointStats","bytesRecv","bytesSent","cached","errors","requests","subscriptions","timeout","WsProvider","constructor","_this","endpoint","arguments","length","undefined","WS_URL","autoConnectMs","headers","cacheCapacity","_defineProperty","type","_len","args","Array","_key","__internal__eventemitter","emit","event","error","Error","concat","code","reason","__internal__autoConnectMs","message","__internal__isConnected","__internal__websocket","onclose","onerror","onmessage","onopen","__internal__timeoutId","clearInterval","__internal__handlers","h","callback","err","__internal__waitingForId","__internal__endpointStats","__internal__emit","setTimeout","connectWithRetry","catch","debug","data","__internal__stats","total","response","JSON","parse","method","__internal__onSocketMessageResult","__internal__onSocketMessageSubscribe","handler","id","params","subscription","result","__internal__coder","decodeResponse","subId","__internal__subscriptions","__internal__resubscribe","Promise","all","map","startsWith","subscribe","now","Date","ids","i","count","start","__internal__timeout","endpoints","isArray","test","__internal__callCache","__internal__endpointIndex","__internal__endpoints","__internal__headers","active","__internal__isReadyPromise","resolve","once","hasSubscriptions","isClonable","isConnected","isReady","clone","selectEndpointIndex","connect","__internal__onSocketClose","__internal__onSocketError","__internal__onSocketMessage","__internal__onSocketOpen","setInterval","__internal__timeoutHandlers","disconnect","close","stats","endpointStats","on","sub","removeListener","send","isCacheable","body","encodeJson","cacheKey","resultPromise","get","__internal__send","set","reject","unsubscribe"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/rpc-provider/ws/index.js"],"sourcesContent":["import { EventEmitter } from 'eventemitter3';\nimport { isChildClass, isNull, isUndefined, logger, noop, objectSpread, stringify } from '@polkadot/util';\nimport { xglobal } from '@polkadot/x-global';\nimport { WebSocket } from '@polkadot/x-ws';\nimport { RpcCoder } from '../coder/index.js';\nimport defaults from '../defaults.js';\nimport { DEFAULT_CAPACITY, LRUCache } from '../lru.js';\nimport { getWSErrorString } from './errors.js';\nconst ALIASES = {\n    chain_finalisedHead: 'chain_finalizedHead',\n    chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',\n    chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'\n};\nconst RETRY_DELAY = 2500;\nconst DEFAULT_TIMEOUT_MS = 60 * 1000;\nconst TIMEOUT_INTERVAL = 5000;\nconst l = logger('api-ws');\n/** @internal Clears a Record<*> of all keys, optionally with all callback on clear */\nfunction eraseRecord(record, cb) {\n    Object.keys(record).forEach((key) => {\n        if (cb) {\n            cb(record[key]);\n        }\n        delete record[key];\n    });\n}\n/** @internal Creates a default/empty stats object */\nfunction defaultEndpointStats() {\n    return { bytesRecv: 0, bytesSent: 0, cached: 0, errors: 0, requests: 0, subscriptions: 0, timeout: 0 };\n}\n/**\n * # @polkadot/rpc-provider/ws\n *\n * @name WsProvider\n *\n * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Api from '@polkadot/api/promise';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const api = new Api(provider);\n * ```\n *\n * @see [[HttpProvider]]\n */\nexport class WsProvider {\n    __internal__callCache;\n    __internal__coder;\n    __internal__endpoints;\n    __internal__headers;\n    __internal__eventemitter;\n    __internal__handlers = {};\n    __internal__isReadyPromise;\n    __internal__stats;\n    __internal__waitingForId = {};\n    __internal__autoConnectMs;\n    __internal__endpointIndex;\n    __internal__endpointStats;\n    __internal__isConnected = false;\n    __internal__subscriptions = {};\n    __internal__timeoutId = null;\n    __internal__websocket;\n    __internal__timeout;\n    /**\n     * @param {string | string[]}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.\n     * @param {number | false} autoConnectMs Whether to connect automatically or not (default). Provided value is used as a delay between retries.\n     * @param {Record<string, string>} headers The headers provided to the underlying WebSocket\n     * @param {number} [timeout] Custom timeout value used per request . Defaults to `DEFAULT_TIMEOUT_MS`\n     */\n    constructor(endpoint = defaults.WS_URL, autoConnectMs = RETRY_DELAY, headers = {}, timeout, cacheCapacity) {\n        const endpoints = Array.isArray(endpoint)\n            ? endpoint\n            : [endpoint];\n        if (endpoints.length === 0) {\n            throw new Error('WsProvider requires at least one Endpoint');\n        }\n        endpoints.forEach((endpoint) => {\n            if (!/^(wss|ws):\\/\\//.test(endpoint)) {\n                throw new Error(`Endpoint should start with 'ws://', received '${endpoint}'`);\n            }\n        });\n        this.__internal__callCache = new LRUCache(cacheCapacity || DEFAULT_CAPACITY);\n        this.__internal__eventemitter = new EventEmitter();\n        this.__internal__autoConnectMs = autoConnectMs || 0;\n        this.__internal__coder = new RpcCoder();\n        this.__internal__endpointIndex = -1;\n        this.__internal__endpoints = endpoints;\n        this.__internal__headers = headers;\n        this.__internal__websocket = null;\n        this.__internal__stats = {\n            active: { requests: 0, subscriptions: 0 },\n            total: defaultEndpointStats()\n        };\n        this.__internal__endpointStats = defaultEndpointStats();\n        this.__internal__timeout = timeout || DEFAULT_TIMEOUT_MS;\n        if (autoConnectMs && autoConnectMs > 0) {\n            this.connectWithRetry().catch(noop);\n        }\n        this.__internal__isReadyPromise = new Promise((resolve) => {\n            this.__internal__eventemitter.once('connected', () => {\n                resolve(this);\n            });\n        });\n    }\n    /**\n     * @summary `true` when this provider supports subscriptions\n     */\n    get hasSubscriptions() {\n        return !!true;\n    }\n    /**\n     * @summary `true` when this provider supports clone()\n     */\n    get isClonable() {\n        return !!true;\n    }\n    /**\n     * @summary Whether the node is connected or not.\n     * @return {boolean} true if connected\n     */\n    get isConnected() {\n        return this.__internal__isConnected;\n    }\n    /**\n     * @description Promise that resolves the first time we are connected and loaded\n     */\n    get isReady() {\n        return this.__internal__isReadyPromise;\n    }\n    get endpoint() {\n        return this.__internal__endpoints[this.__internal__endpointIndex];\n    }\n    /**\n     * @description Returns a clone of the object\n     */\n    clone() {\n        return new WsProvider(this.__internal__endpoints);\n    }\n    selectEndpointIndex(endpoints) {\n        return (this.__internal__endpointIndex + 1) % endpoints.length;\n    }\n    /**\n     * @summary Manually connect\n     * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may\n     * connect manually using this method.\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async connect() {\n        if (this.__internal__websocket) {\n            throw new Error('WebSocket is already connected');\n        }\n        try {\n            this.__internal__endpointIndex = this.selectEndpointIndex(this.__internal__endpoints);\n            // the as here is Deno-specific - not available on the globalThis\n            this.__internal__websocket = typeof xglobal.WebSocket !== 'undefined' && isChildClass(xglobal.WebSocket, WebSocket)\n                ? new WebSocket(this.endpoint)\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore - WS may be an instance of ws, which supports options\n                : new WebSocket(this.endpoint, undefined, {\n                    headers: this.__internal__headers\n                });\n            if (this.__internal__websocket) {\n                this.__internal__websocket.onclose = this.__internal__onSocketClose;\n                this.__internal__websocket.onerror = this.__internal__onSocketError;\n                this.__internal__websocket.onmessage = this.__internal__onSocketMessage;\n                this.__internal__websocket.onopen = this.__internal__onSocketOpen;\n            }\n            // timeout any handlers that have not had a response\n            this.__internal__timeoutId = setInterval(() => this.__internal__timeoutHandlers(), TIMEOUT_INTERVAL);\n        }\n        catch (error) {\n            l.error(error);\n            this.__internal__emit('error', error);\n            throw error;\n        }\n    }\n    /**\n     * @description Connect, never throwing an error, but rather forcing a retry\n     */\n    async connectWithRetry() {\n        if (this.__internal__autoConnectMs > 0) {\n            try {\n                await this.connect();\n            }\n            catch {\n                setTimeout(() => {\n                    this.connectWithRetry().catch(noop);\n                }, this.__internal__autoConnectMs);\n            }\n        }\n    }\n    /**\n     * @description Manually disconnect from the connection, clearing auto-connect logic\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async disconnect() {\n        // switch off autoConnect, we are in manual mode now\n        this.__internal__autoConnectMs = 0;\n        try {\n            if (this.__internal__websocket) {\n                // 1000 - Normal closure; the connection successfully completed\n                this.__internal__websocket.close(1000);\n            }\n        }\n        catch (error) {\n            l.error(error);\n            this.__internal__emit('error', error);\n            throw error;\n        }\n    }\n    /**\n     * @description Returns the connection stats\n     */\n    get stats() {\n        return {\n            active: {\n                requests: Object.keys(this.__internal__handlers).length,\n                subscriptions: Object.keys(this.__internal__subscriptions).length\n            },\n            total: this.__internal__stats.total\n        };\n    }\n    get endpointStats() {\n        return this.__internal__endpointStats;\n    }\n    /**\n     * @summary Listens on events after having subscribed using the [[subscribe]] function.\n     * @param  {ProviderInterfaceEmitted} type Event\n     * @param  {ProviderInterfaceEmitCb}  sub  Callback\n     * @return unsubscribe function\n     */\n    on(type, sub) {\n        this.__internal__eventemitter.on(type, sub);\n        return () => {\n            this.__internal__eventemitter.removeListener(type, sub);\n        };\n    }\n    /**\n     * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.\n     * @param method The RPC methods to execute\n     * @param params Encoded parameters as applicable for the method\n     * @param subscription Subscription details (internally used)\n     */\n    send(method, params, isCacheable, subscription) {\n        this.__internal__endpointStats.requests++;\n        this.__internal__stats.total.requests++;\n        const [id, body] = this.__internal__coder.encodeJson(method, params);\n        const cacheKey = isCacheable ? `${method}::${stringify(params)}` : '';\n        let resultPromise = isCacheable\n            ? this.__internal__callCache.get(cacheKey)\n            : null;\n        if (!resultPromise) {\n            resultPromise = this.__internal__send(id, body, method, params, subscription);\n            if (isCacheable) {\n                this.__internal__callCache.set(cacheKey, resultPromise);\n            }\n        }\n        else {\n            this.__internal__endpointStats.cached++;\n            this.__internal__stats.total.cached++;\n        }\n        return resultPromise;\n    }\n    async __internal__send(id, body, method, params, subscription) {\n        return new Promise((resolve, reject) => {\n            try {\n                if (!this.isConnected || this.__internal__websocket === null) {\n                    throw new Error('WebSocket is not connected');\n                }\n                const callback = (error, result) => {\n                    error\n                        ? reject(error)\n                        : resolve(result);\n                };\n                l.debug(() => ['calling', method, body]);\n                this.__internal__handlers[id] = {\n                    callback,\n                    method,\n                    params,\n                    start: Date.now(),\n                    subscription\n                };\n                const bytesSent = body.length;\n                this.__internal__endpointStats.bytesSent += bytesSent;\n                this.__internal__stats.total.bytesSent += bytesSent;\n                this.__internal__websocket.send(body);\n            }\n            catch (error) {\n                this.__internal__endpointStats.errors++;\n                this.__internal__stats.total.errors++;\n                reject(error);\n            }\n        });\n    }\n    /**\n     * @name subscribe\n     * @summary Allows subscribing to a specific event.\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * const provider = new WsProvider('ws://127.0.0.1:9944');\n     * const rpc = new Rpc(provider);\n     *\n     * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {\n     *   console.log(values)\n     * }).then((subscriptionId) => {\n     *   console.log('balance changes subscription id: ', subscriptionId)\n     * })\n     * ```\n     */\n    subscribe(type, method, params, callback) {\n        this.__internal__endpointStats.subscriptions++;\n        this.__internal__stats.total.subscriptions++;\n        // subscriptions are not cached, LRU applies to .at(<blockHash>) only\n        return this.send(method, params, false, { callback, type });\n    }\n    /**\n     * @summary Allows unsubscribing to subscriptions made with [[subscribe]].\n     */\n    async unsubscribe(type, method, id) {\n        const subscription = `${type}::${id}`;\n        // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub\n        // the assigned id now does not match what the API user originally received. It has\n        // a slight complication in solving - since we cannot rely on the send id, but rather\n        // need to find the actual subscription id to map it\n        if (isUndefined(this.__internal__subscriptions[subscription])) {\n            l.debug(() => `Unable to find active subscription=${subscription}`);\n            return false;\n        }\n        delete this.__internal__subscriptions[subscription];\n        try {\n            return this.isConnected && !isNull(this.__internal__websocket)\n                ? this.send(method, [id])\n                : true;\n        }\n        catch {\n            return false;\n        }\n    }\n    __internal__emit = (type, ...args) => {\n        this.__internal__eventemitter.emit(type, ...args);\n    };\n    __internal__onSocketClose = (event) => {\n        const error = new Error(`disconnected from ${this.endpoint}: ${event.code}:: ${event.reason || getWSErrorString(event.code)}`);\n        if (this.__internal__autoConnectMs > 0) {\n            l.error(error.message);\n        }\n        this.__internal__isConnected = false;\n        if (this.__internal__websocket) {\n            this.__internal__websocket.onclose = null;\n            this.__internal__websocket.onerror = null;\n            this.__internal__websocket.onmessage = null;\n            this.__internal__websocket.onopen = null;\n            this.__internal__websocket = null;\n        }\n        if (this.__internal__timeoutId) {\n            clearInterval(this.__internal__timeoutId);\n            this.__internal__timeoutId = null;\n        }\n        // reject all hanging requests\n        eraseRecord(this.__internal__handlers, (h) => {\n            try {\n                h.callback(error, undefined);\n            }\n            catch (err) {\n                // does not throw\n                l.error(err);\n            }\n        });\n        eraseRecord(this.__internal__waitingForId);\n        // Reset stats for active endpoint\n        this.__internal__endpointStats = defaultEndpointStats();\n        this.__internal__emit('disconnected');\n        if (this.__internal__autoConnectMs > 0) {\n            setTimeout(() => {\n                this.connectWithRetry().catch(noop);\n            }, this.__internal__autoConnectMs);\n        }\n    };\n    __internal__onSocketError = (error) => {\n        l.debug(() => ['socket error', error]);\n        this.__internal__emit('error', error);\n    };\n    __internal__onSocketMessage = (message) => {\n        l.debug(() => ['received', message.data]);\n        const bytesRecv = message.data.length;\n        this.__internal__endpointStats.bytesRecv += bytesRecv;\n        this.__internal__stats.total.bytesRecv += bytesRecv;\n        const response = JSON.parse(message.data);\n        return isUndefined(response.method)\n            ? this.__internal__onSocketMessageResult(response)\n            : this.__internal__onSocketMessageSubscribe(response);\n    };\n    __internal__onSocketMessageResult = (response) => {\n        const handler = this.__internal__handlers[response.id];\n        if (!handler) {\n            l.debug(() => `Unable to find handler for id=${response.id}`);\n            return;\n        }\n        try {\n            const { method, params, subscription } = handler;\n            const result = this.__internal__coder.decodeResponse(response);\n            // first send the result - in case of subs, we may have an update\n            // immediately if we have some queued results already\n            handler.callback(null, result);\n            if (subscription) {\n                const subId = `${subscription.type}::${result}`;\n                this.__internal__subscriptions[subId] = objectSpread({}, subscription, {\n                    method,\n                    params\n                });\n                // if we have a result waiting for this subscription already\n                if (this.__internal__waitingForId[subId]) {\n                    this.__internal__onSocketMessageSubscribe(this.__internal__waitingForId[subId]);\n                }\n            }\n        }\n        catch (error) {\n            this.__internal__endpointStats.errors++;\n            this.__internal__stats.total.errors++;\n            handler.callback(error, undefined);\n        }\n        delete this.__internal__handlers[response.id];\n    };\n    __internal__onSocketMessageSubscribe = (response) => {\n        if (!response.method) {\n            throw new Error('No method found in JSONRPC response');\n        }\n        const method = ALIASES[response.method] || response.method;\n        const subId = `${method}::${response.params.subscription}`;\n        const handler = this.__internal__subscriptions[subId];\n        if (!handler) {\n            // store the JSON, we could have out-of-order subid coming in\n            this.__internal__waitingForId[subId] = response;\n            l.debug(() => `Unable to find handler for subscription=${subId}`);\n            return;\n        }\n        // housekeeping\n        delete this.__internal__waitingForId[subId];\n        try {\n            const result = this.__internal__coder.decodeResponse(response);\n            handler.callback(null, result);\n        }\n        catch (error) {\n            this.__internal__endpointStats.errors++;\n            this.__internal__stats.total.errors++;\n            handler.callback(error, undefined);\n        }\n    };\n    __internal__onSocketOpen = () => {\n        if (this.__internal__websocket === null) {\n            throw new Error('WebSocket cannot be null in onOpen');\n        }\n        l.debug(() => ['connected to', this.endpoint]);\n        this.__internal__isConnected = true;\n        this.__internal__resubscribe();\n        this.__internal__emit('connected');\n        return true;\n    };\n    __internal__resubscribe = () => {\n        const subscriptions = this.__internal__subscriptions;\n        this.__internal__subscriptions = {};\n        Promise.all(Object.keys(subscriptions).map(async (id) => {\n            const { callback, method, params, type } = subscriptions[id];\n            // only re-create subscriptions which are not in author (only area where\n            // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n            // are not included (and will not be re-broadcast)\n            if (type.startsWith('author_')) {\n                return;\n            }\n            try {\n                await this.subscribe(type, method, params, callback);\n            }\n            catch (error) {\n                l.error(error);\n            }\n        })).catch(l.error);\n    };\n    __internal__timeoutHandlers = () => {\n        const now = Date.now();\n        const ids = Object.keys(this.__internal__handlers);\n        for (let i = 0, count = ids.length; i < count; i++) {\n            const handler = this.__internal__handlers[ids[i]];\n            if ((now - handler.start) > this.__internal__timeout) {\n                try {\n                    handler.callback(new Error(`No response received from RPC endpoint in ${this.__internal__timeout / 1000}s`), undefined);\n                }\n                catch {\n                    // ignore\n                }\n                this.__internal__endpointStats.timeout++;\n                this.__internal__stats.total.timeout++;\n                delete this.__internal__handlers[ids[i]];\n            }\n        }\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}