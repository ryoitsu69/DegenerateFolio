{"ast":null,"code":"import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { EventBoundary } from './EventBoundary.mjs';\nimport { EventsTicker } from './EventTicker.mjs';\nimport { FederatedPointerEvent } from './FederatedPointerEvent.mjs';\nimport { FederatedWheelEvent } from './FederatedWheelEvent.mjs';\n\"use strict\";\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER = {\n  touchstart: \"pointerdown\",\n  touchend: \"pointerup\",\n  touchendoutside: \"pointerupoutside\",\n  touchmove: \"pointermove\",\n  touchcancel: \"pointercancel\"\n};\nconst _EventSystem = class _EventSystem {\n  /**\n   * @param {Renderer} renderer\n   */\n  constructor(renderer) {\n    /** Does the device support touch events https://www.w3.org/TR/touch-events/ */\n    this.supportsTouchEvents = \"ontouchstart\" in globalThis;\n    /** Does the device support pointer events https://www.w3.org/Submission/pointer-events/ */\n    this.supportsPointerEvents = !!globalThis.PointerEvent;\n    /**\n     * The DOM element to which the root event listeners are bound. This is automatically set to\n     * the renderer's {@link Renderer#view view}.\n     */\n    this.domElement = null;\n    /** The resolution used to convert between the DOM client space into world space. */\n    this.resolution = 1;\n    this.renderer = renderer;\n    this.rootBoundary = new EventBoundary(null);\n    EventsTicker.init(this);\n    this.autoPreventDefault = true;\n    this._eventsAdded = false;\n    this._rootPointerEvent = new FederatedPointerEvent(null);\n    this._rootWheelEvent = new FederatedWheelEvent(null);\n    this.cursorStyles = {\n      default: \"inherit\",\n      pointer: \"pointer\"\n    };\n    this.features = new Proxy({\n      ..._EventSystem.defaultEventFeatures\n    }, {\n      set: (target, key, value) => {\n        if (key === \"globalMove\") {\n          this.rootBoundary.enableGlobalMoveEvents = value;\n        }\n        target[key] = value;\n        return true;\n      }\n    });\n    this._onPointerDown = this._onPointerDown.bind(this);\n    this._onPointerMove = this._onPointerMove.bind(this);\n    this._onPointerUp = this._onPointerUp.bind(this);\n    this._onPointerOverOut = this._onPointerOverOut.bind(this);\n    this.onWheel = this.onWheel.bind(this);\n  }\n  /**\n   * The default interaction mode for all display objects.\n   * @see Container.eventMode\n   * @type {EventMode}\n   * @readonly\n   * @since 7.2.0\n   */\n  static get defaultEventMode() {\n    return this._defaultEventMode;\n  }\n  /**\n   * Runner init called, view is available at this point.\n   * @ignore\n   */\n  init(options) {\n    const {\n      canvas,\n      resolution\n    } = this.renderer;\n    this.setTargetElement(canvas);\n    this.resolution = resolution;\n    _EventSystem._defaultEventMode = options.eventMode ?? \"passive\";\n    Object.assign(this.features, options.eventFeatures ?? {});\n    this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;\n  }\n  /**\n   * Handle changing resolution.\n   * @ignore\n   */\n  resolutionChange(resolution) {\n    this.resolution = resolution;\n  }\n  /** Destroys all event listeners and detaches the renderer. */\n  destroy() {\n    this.setTargetElement(null);\n    this.renderer = null;\n    this._currentCursor = null;\n  }\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   * @param mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  setCursor(mode) {\n    mode = mode || \"default\";\n    let applyStyles = true;\n    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {\n      applyStyles = false;\n    }\n    if (this._currentCursor === mode) {\n      return;\n    }\n    this._currentCursor = mode;\n    const style = this.cursorStyles[mode];\n    if (style) {\n      switch (typeof style) {\n        case \"string\":\n          if (applyStyles) {\n            this.domElement.style.cursor = style;\n          }\n          break;\n        case \"function\":\n          style(mode);\n          break;\n        case \"object\":\n          if (applyStyles) {\n            Object.assign(this.domElement.style, style);\n          }\n          break;\n      }\n    } else if (applyStyles && typeof mode === \"string\" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      this.domElement.style.cursor = mode;\n    }\n  }\n  /**\n   * The global pointer event.\n   * Useful for getting the pointer position without listening to events.\n   * @since 7.2.0\n   */\n  get pointer() {\n    return this._rootPointerEvent;\n  }\n  /**\n   * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */\n  _onPointerDown(nativeEvent) {\n    if (!this.features.click) return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    const events = this._normalizeToPointerData(nativeEvent);\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      const cancelable = nativeEvent.cancelable || !(\"cancelable\" in nativeEvent);\n      if (cancelable) {\n        nativeEvent.preventDefault();\n      }\n    }\n    for (let i = 0, j = events.length; i < j; i++) {\n      const nativeEvent2 = events[i];\n      const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);\n      this.rootBoundary.mapEvent(federatedEvent);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch events.\n   */\n  _onPointerMove(nativeEvent) {\n    if (!this.features.move) return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    EventsTicker.pointerMoved();\n    const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */\n  _onPointerUp(nativeEvent) {\n    if (!this.features.click) return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    let target = nativeEvent.target;\n    if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {\n      target = nativeEvent.composedPath()[0];\n    }\n    const outside = target !== this.domElement ? \"outside\" : \"\";\n    const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n      event.type += outside;\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */\n  _onPointerOverOut(nativeEvent) {\n    if (!this.features.click) return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n   * @param nativeEvent - The native wheel event.\n   */\n  onWheel(nativeEvent) {\n    if (!this.features.wheel) return;\n    const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    this.rootBoundary.mapEvent(wheelEvent);\n  }\n  /**\n   * Sets the {@link EventSystem#domElement domElement} and binds event listeners.\n   *\n   * To deregister the current DOM element without setting a new one, pass {@code null}.\n   * @param element - The new DOM element.\n   */\n  setTargetElement(element) {\n    this._removeEvents();\n    this.domElement = element;\n    EventsTicker.domElement = element;\n    this._addEvents();\n  }\n  /** Register event listeners on {@link Renderer#domElement this.domElement}. */\n  _addEvents() {\n    if (this._eventsAdded || !this.domElement) {\n      return;\n    }\n    EventsTicker.addTickerListener();\n    const style = this.domElement.style;\n    if (style) {\n      if (globalThis.navigator.msPointerEnabled) {\n        style.msContentZooming = \"none\";\n        style.msTouchAction = \"none\";\n      } else if (this.supportsPointerEvents) {\n        style.touchAction = \"none\";\n      }\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.addEventListener(\"pointermove\", this._onPointerMove, true);\n      this.domElement.addEventListener(\"pointerdown\", this._onPointerDown, true);\n      this.domElement.addEventListener(\"pointerleave\", this._onPointerOverOut, true);\n      this.domElement.addEventListener(\"pointerover\", this._onPointerOverOut, true);\n      globalThis.addEventListener(\"pointerup\", this._onPointerUp, true);\n    } else {\n      globalThis.document.addEventListener(\"mousemove\", this._onPointerMove, true);\n      this.domElement.addEventListener(\"mousedown\", this._onPointerDown, true);\n      this.domElement.addEventListener(\"mouseout\", this._onPointerOverOut, true);\n      this.domElement.addEventListener(\"mouseover\", this._onPointerOverOut, true);\n      globalThis.addEventListener(\"mouseup\", this._onPointerUp, true);\n      if (this.supportsTouchEvents) {\n        this.domElement.addEventListener(\"touchstart\", this._onPointerDown, true);\n        this.domElement.addEventListener(\"touchend\", this._onPointerUp, true);\n        this.domElement.addEventListener(\"touchmove\", this._onPointerMove, true);\n      }\n    }\n    this.domElement.addEventListener(\"wheel\", this.onWheel, {\n      passive: true,\n      capture: true\n    });\n    this._eventsAdded = true;\n  }\n  /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */\n  _removeEvents() {\n    if (!this._eventsAdded || !this.domElement) {\n      return;\n    }\n    EventsTicker.removeTickerListener();\n    const style = this.domElement.style;\n    if (style) {\n      if (globalThis.navigator.msPointerEnabled) {\n        style.msContentZooming = \"\";\n        style.msTouchAction = \"\";\n      } else if (this.supportsPointerEvents) {\n        style.touchAction = \"\";\n      }\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.removeEventListener(\"pointermove\", this._onPointerMove, true);\n      this.domElement.removeEventListener(\"pointerdown\", this._onPointerDown, true);\n      this.domElement.removeEventListener(\"pointerleave\", this._onPointerOverOut, true);\n      this.domElement.removeEventListener(\"pointerover\", this._onPointerOverOut, true);\n      globalThis.removeEventListener(\"pointerup\", this._onPointerUp, true);\n    } else {\n      globalThis.document.removeEventListener(\"mousemove\", this._onPointerMove, true);\n      this.domElement.removeEventListener(\"mousedown\", this._onPointerDown, true);\n      this.domElement.removeEventListener(\"mouseout\", this._onPointerOverOut, true);\n      this.domElement.removeEventListener(\"mouseover\", this._onPointerOverOut, true);\n      globalThis.removeEventListener(\"mouseup\", this._onPointerUp, true);\n      if (this.supportsTouchEvents) {\n        this.domElement.removeEventListener(\"touchstart\", this._onPointerDown, true);\n        this.domElement.removeEventListener(\"touchend\", this._onPointerUp, true);\n        this.domElement.removeEventListener(\"touchmove\", this._onPointerMove, true);\n      }\n    }\n    this.domElement.removeEventListener(\"wheel\", this.onWheel, true);\n    this.domElement = null;\n    this._eventsAdded = false;\n  }\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   * @param  {PointData} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n  mapPositionToPoint(point, x, y) {\n    const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {\n      x: 0,\n      y: 0,\n      width: this.domElement.width,\n      height: this.domElement.height,\n      left: 0,\n      top: 0\n    };\n    const resolutionMultiplier = 1 / this.resolution;\n    point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;\n    point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;\n  }\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   * @param event - The original event data from a touch or mouse event\n   * @returns An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  _normalizeToPointerData(event) {\n    const normalizedEvents = [];\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n        if (typeof touch.button === \"undefined\") touch.button = 0;\n        if (typeof touch.buttons === \"undefined\") touch.buttons = 1;\n        if (typeof touch.isPrimary === \"undefined\") {\n          touch.isPrimary = event.touches.length === 1 && event.type === \"touchstart\";\n        }\n        if (typeof touch.width === \"undefined\") touch.width = touch.radiusX || 1;\n        if (typeof touch.height === \"undefined\") touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === \"undefined\") touch.tiltX = 0;\n        if (typeof touch.tiltY === \"undefined\") touch.tiltY = 0;\n        if (typeof touch.pointerType === \"undefined\") touch.pointerType = \"touch\";\n        if (typeof touch.pointerId === \"undefined\") touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === \"undefined\") touch.pressure = touch.force || 0.5;\n        if (typeof touch.twist === \"undefined\") touch.twist = 0;\n        if (typeof touch.tangentialPressure === \"undefined\") touch.tangentialPressure = 0;\n        if (typeof touch.layerX === \"undefined\") touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === \"undefined\") touch.layerY = touch.offsetY = touch.clientY;\n        touch.isNormalized = true;\n        touch.type = event.type;\n        normalizedEvents.push(touch);\n      }\n    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {\n      const tempEvent = event;\n      if (typeof tempEvent.isPrimary === \"undefined\") tempEvent.isPrimary = true;\n      if (typeof tempEvent.width === \"undefined\") tempEvent.width = 1;\n      if (typeof tempEvent.height === \"undefined\") tempEvent.height = 1;\n      if (typeof tempEvent.tiltX === \"undefined\") tempEvent.tiltX = 0;\n      if (typeof tempEvent.tiltY === \"undefined\") tempEvent.tiltY = 0;\n      if (typeof tempEvent.pointerType === \"undefined\") tempEvent.pointerType = \"mouse\";\n      if (typeof tempEvent.pointerId === \"undefined\") tempEvent.pointerId = MOUSE_POINTER_ID;\n      if (typeof tempEvent.pressure === \"undefined\") tempEvent.pressure = 0.5;\n      if (typeof tempEvent.twist === \"undefined\") tempEvent.twist = 0;\n      if (typeof tempEvent.tangentialPressure === \"undefined\") tempEvent.tangentialPressure = 0;\n      tempEvent.isNormalized = true;\n      normalizedEvents.push(tempEvent);\n    } else {\n      normalizedEvents.push(event);\n    }\n    return normalizedEvents;\n  }\n  /**\n   * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n   *\n   * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across\n   * multiple native wheel events.\n   * @param nativeEvent - The native wheel event that occurred on the canvas.\n   * @returns A federated wheel event.\n   */\n  normalizeWheelEvent(nativeEvent) {\n    const event = this._rootWheelEvent;\n    this._transferMouseData(event, nativeEvent);\n    event.deltaX = nativeEvent.deltaX;\n    event.deltaY = nativeEvent.deltaY;\n    event.deltaZ = nativeEvent.deltaZ;\n    event.deltaMode = nativeEvent.deltaMode;\n    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n    event.global.copyFrom(event.screen);\n    event.offset.copyFrom(event.screen);\n    event.nativeEvent = nativeEvent;\n    event.type = nativeEvent.type;\n    return event;\n  }\n  /**\n   * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.\n   * @param event\n   * @param nativeEvent\n   */\n  _bootstrapEvent(event, nativeEvent) {\n    event.originalEvent = null;\n    event.nativeEvent = nativeEvent;\n    event.pointerId = nativeEvent.pointerId;\n    event.width = nativeEvent.width;\n    event.height = nativeEvent.height;\n    event.isPrimary = nativeEvent.isPrimary;\n    event.pointerType = nativeEvent.pointerType;\n    event.pressure = nativeEvent.pressure;\n    event.tangentialPressure = nativeEvent.tangentialPressure;\n    event.tiltX = nativeEvent.tiltX;\n    event.tiltY = nativeEvent.tiltY;\n    event.twist = nativeEvent.twist;\n    this._transferMouseData(event, nativeEvent);\n    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n    event.global.copyFrom(event.screen);\n    event.offset.copyFrom(event.screen);\n    event.isTrusted = nativeEvent.isTrusted;\n    if (event.type === \"pointerleave\") {\n      event.type = \"pointerout\";\n    }\n    if (event.type.startsWith(\"mouse\")) {\n      event.type = event.type.replace(\"mouse\", \"pointer\");\n    }\n    if (event.type.startsWith(\"touch\")) {\n      event.type = TOUCH_TO_POINTER[event.type] || event.type;\n    }\n    return event;\n  }\n  /**\n   * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.\n   * @param event\n   * @param nativeEvent\n   */\n  _transferMouseData(event, nativeEvent) {\n    event.isTrusted = nativeEvent.isTrusted;\n    event.srcElement = nativeEvent.srcElement;\n    event.timeStamp = performance.now();\n    event.type = nativeEvent.type;\n    event.altKey = nativeEvent.altKey;\n    event.button = nativeEvent.button;\n    event.buttons = nativeEvent.buttons;\n    event.client.x = nativeEvent.clientX;\n    event.client.y = nativeEvent.clientY;\n    event.ctrlKey = nativeEvent.ctrlKey;\n    event.metaKey = nativeEvent.metaKey;\n    event.movement.x = nativeEvent.movementX;\n    event.movement.y = nativeEvent.movementY;\n    event.page.x = nativeEvent.pageX;\n    event.page.y = nativeEvent.pageY;\n    event.relatedTarget = null;\n    event.shiftKey = nativeEvent.shiftKey;\n  }\n};\n/** @ignore */\n_EventSystem.extension = {\n  name: \"events\",\n  type: [ExtensionType.WebGLSystem, ExtensionType.CanvasSystem, ExtensionType.WebGPUSystem],\n  priority: -1\n};\n/**\n * The event features that are enabled by the EventSystem\n * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n * @since 7.2.0\n */\n_EventSystem.defaultEventFeatures = {\n  /** Enables pointer events associated with pointer movement. */\n  move: true,\n  /** Enables global pointer move events. */\n  globalMove: true,\n  /** Enables pointer events associated with clicking. */\n  click: true,\n  /** Enables wheel events. */\n  wheel: true\n};\nlet EventSystem = _EventSystem;\nexport { EventSystem };","map":{"version":3,"names":["MOUSE_POINTER_ID","TOUCH_TO_POINTER","touchstart","touchend","touchendoutside","touchmove","touchcancel","_EventSystem","constructor","renderer","supportsTouchEvents","globalThis","supportsPointerEvents","PointerEvent","domElement","resolution","rootBoundary","EventBoundary","EventsTicker","init","autoPreventDefault","_eventsAdded","_rootPointerEvent","FederatedPointerEvent","_rootWheelEvent","FederatedWheelEvent","cursorStyles","default","pointer","features","Proxy","defaultEventFeatures","set","target","key","value","enableGlobalMoveEvents","_onPointerDown","bind","_onPointerMove","_onPointerUp","_onPointerOverOut","onWheel","defaultEventMode","_defaultEventMode","options","canvas","setTargetElement","eventMode","Object","assign","eventFeatures","globalMove","resolutionChange","destroy","_currentCursor","setCursor","mode","applyStyles","OffscreenCanvas","style","cursor","prototype","hasOwnProperty","call","nativeEvent","click","rootTarget","lastObjectRendered","events","_normalizeToPointerData","isNormalized","cancelable","preventDefault","i","j","length","nativeEvent2","federatedEvent","_bootstrapEvent","mapEvent","move","pointerMoved","normalizedEvents","event","composedPath","outside","type","wheel","wheelEvent","normalizeWheelEvent","element","_removeEvents","_addEvents","addTickerListener","navigator","msPointerEnabled","msContentZooming","msTouchAction","touchAction","document","addEventListener","passive","capture","removeTickerListener","removeEventListener","mapPositionToPoint","point","x","y","rect","isConnected","getBoundingClientRect","width","height","left","top","resolutionMultiplier","TouchEvent","li","changedTouches","touch","button","buttons","isPrimary","touches","radiusX","radiusY","tiltX","tiltY","pointerType","pointerId","identifier","pressure","force","twist","tangentialPressure","layerX","offsetX","clientX","layerY","offsetY","clientY","push","MouseEvent","tempEvent","_transferMouseData","deltaX","deltaY","deltaZ","deltaMode","screen","global","copyFrom","offset","originalEvent","isTrusted","startsWith","replace","srcElement","timeStamp","performance","now","altKey","client","ctrlKey","metaKey","movement","movementX","movementY","page","pageX","pageY","relatedTarget","shiftKey","extension","name","ExtensionType","WebGLSystem","CanvasSystem","WebGPUSystem","priority","EventSystem"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/events/EventSystem.ts"],"sourcesContent":["import { ExtensionType } from '../extensions/Extensions';\nimport { EventBoundary } from './EventBoundary';\nimport { EventsTicker } from './EventTicker';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { PointData } from '../maths/point/PointData';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { PixiTouch } from './FederatedEvent';\nimport type { EventMode } from './FederatedEventTarget';\nimport type { FederatedMouseEvent } from './FederatedMouseEvent';\n\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER: Record<string, string> = {\n    touchstart: 'pointerdown',\n    touchend: 'pointerup',\n    touchendoutside: 'pointerupoutside',\n    touchmove: 'pointermove',\n    touchcancel: 'pointercancel',\n};\n\n/** @ignore */\nexport interface EventSystemOptions\n{\n    /**\n     * The default event mode mode for all display objects.\n     * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n     */\n    eventMode?: EventMode;\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n     * @example\n     * const app = new Application({\n     *   view: canvas,\n     *   events: {\n     *     move: true,\n     *     globalMove: false,\n     *     click: true,\n     *     wheel: true,\n     *   },\n     * });\n     */\n    eventFeatures?: Partial<EventSystemFeatures>\n}\n\n/**\n * The event features that are enabled by the EventSystem\n * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n * @since 7.2.0\n * @memberof events\n */\ninterface EventSystemFeatures\n{\n    /**\n     * Enables pointer events associated with pointer movement:\n     * - `pointermove` / `mousemove` / `touchmove`\n     * - `pointerout` / `mouseout`\n     * - `pointerover` / `mouseover`\n     */\n    move: boolean;\n    // eslint-disable-next-line jsdoc/multiline-blocks\n    /**\n     * Enables global pointer move events:\n     * - `globalpointermove`\n     * - `globalmousemove`\n     * - `globaltouchemove`\n     */\n    globalMove: boolean;\n    /**\n     * Enables pointer events associated with clicking:\n     * - `pointerup` / `mouseup` / `touchend` / 'rightup'\n     * - `pointerupoutside` / `mouseupoutside` / `touchendoutside` / 'rightupoutside'\n     * - `pointerdown` / 'mousedown' / `touchstart` / 'rightdown'\n     * - `click` / `tap`\n     */\n    click: boolean;\n    /** - Enables wheel events. */\n    wheel: boolean;\n}\n\n/**\n * The system for handling UI events.\n * @memberof events\n */\nexport class EventSystem implements System<EventSystemOptions>\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'events',\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.CanvasSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        priority: -1,\n    };\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n     * @since 7.2.0\n     */\n    public static defaultEventFeatures: EventSystemFeatures = {\n        /** Enables pointer events associated with pointer movement. */\n        move: true,\n        /** Enables global pointer move events. */\n        globalMove: true,\n        /** Enables pointer events associated with clicking. */\n        click: true,\n        /** Enables wheel events. */\n        wheel: true,\n    };\n\n    private static _defaultEventMode: EventMode;\n\n    /**\n     * The default interaction mode for all display objects.\n     * @see Container.eventMode\n     * @type {EventMode}\n     * @readonly\n     * @since 7.2.0\n     */\n    public static get defaultEventMode()\n    {\n        return this._defaultEventMode;\n    }\n\n    /**\n     * The {@link EventBoundary} for the stage.\n     *\n     * The {@link EventBoundary#rootTarget rootTarget} of this root boundary is automatically set to\n     * the last rendered object before any event processing is initiated. This means the main scene\n     * needs to be rendered atleast once before UI events will start propagating.\n     *\n     * The root boundary should only be changed during initialization. Otherwise, any state held by the\n     * event boundary may be lost (like hovered & pressed Containers).\n     */\n    public readonly rootBoundary: EventBoundary;\n\n    /** Does the device support touch events https://www.w3.org/TR/touch-events/ */\n    public readonly supportsTouchEvents = 'ontouchstart' in globalThis;\n\n    /** Does the device support pointer events https://www.w3.org/Submission/pointer-events/ */\n    public readonly supportsPointerEvents = !!globalThis.PointerEvent;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     * @default true\n     */\n    public autoPreventDefault: boolean;\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for {@code domElement},\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     */\n    public cursorStyles: Record<string, string | ((mode: string) => void) | CSSStyleDeclaration>;\n\n    /**\n     * The DOM element to which the root event listeners are bound. This is automatically set to\n     * the renderer's {@link Renderer#view view}.\n     */\n    public domElement: HTMLElement = null;\n\n    /** The resolution used to convert between the DOM client space into world space. */\n    public resolution = 1;\n\n    /** The renderer managing this {@link EventSystem}. */\n    public renderer: Renderer;\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n     * @since 7.2.0\n     * @example\n     * const app = new Application()\n     * app.renderer.events.features.globalMove = false\n     *\n     * // to override all features use Object.assign\n     * Object.assign(app.renderer.events.features, {\n     *  move: false,\n     *  globalMove: false,\n     *  click: false,\n     *  wheel: false,\n     * })\n     */\n    public readonly features: EventSystemFeatures;\n\n    private _currentCursor: string;\n    private readonly _rootPointerEvent: FederatedPointerEvent;\n    private readonly _rootWheelEvent: FederatedWheelEvent;\n    private _eventsAdded: boolean;\n\n    /**\n     * @param {Renderer} renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this.rootBoundary = new EventBoundary(null);\n        EventsTicker.init(this);\n\n        this.autoPreventDefault = true;\n        this._eventsAdded = false;\n\n        this._rootPointerEvent = new FederatedPointerEvent(null);\n        this._rootWheelEvent = new FederatedWheelEvent(null);\n\n        this.cursorStyles = {\n            default: 'inherit',\n            pointer: 'pointer',\n        };\n\n        this.features = new Proxy({ ...EventSystem.defaultEventFeatures }, {\n            set: (target, key, value) =>\n            {\n                if (key === 'globalMove')\n                {\n                    this.rootBoundary.enableGlobalMoveEvents = value;\n                }\n                target[key as keyof EventSystemFeatures] = value;\n\n                return true;\n            }\n        });\n\n        this._onPointerDown = this._onPointerDown.bind(this);\n        this._onPointerMove = this._onPointerMove.bind(this);\n        this._onPointerUp = this._onPointerUp.bind(this);\n        this._onPointerOverOut = this._onPointerOverOut.bind(this);\n        this.onWheel = this.onWheel.bind(this);\n    }\n\n    /**\n     * Runner init called, view is available at this point.\n     * @ignore\n     */\n    public init(options: EventSystemOptions): void\n    {\n        const { canvas, resolution } = this.renderer;\n\n        this.setTargetElement(canvas as HTMLCanvasElement);\n        this.resolution = resolution;\n        EventSystem._defaultEventMode = options.eventMode ?? 'passive';\n        Object.assign(this.features, options.eventFeatures ?? {});\n        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;\n    }\n\n    /**\n     * Handle changing resolution.\n     * @ignore\n     */\n    public resolutionChange(resolution: number): void\n    {\n        this.resolution = resolution;\n    }\n\n    /** Destroys all event listeners and detaches the renderer. */\n    public destroy(): void\n    {\n        this.setTargetElement(null);\n        this.renderer = null;\n        this._currentCursor = null;\n    }\n\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     * @param mode - cursor mode, a key from the cursorStyles dictionary\n     */\n    public setCursor(mode: string): void\n    {\n        mode = mode || 'default';\n        let applyStyles = true;\n\n        // offscreen canvas does not support setting styles, but cursor modes can be functions,\n        // in order to handle pixi rendered cursors, so we can't bail\n        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas)\n        {\n            applyStyles = false;\n        }\n        // if the mode didn't actually change, bail early\n        if (this._currentCursor === mode)\n        {\n            return;\n        }\n        this._currentCursor = mode;\n        const style = this.cursorStyles[mode];\n\n        // only do things if there is a cursor style for it\n        if (style)\n        {\n            switch (typeof style)\n            {\n                case 'string':\n                    // string styles are handled as cursor CSS\n                    if (applyStyles)\n                    {\n                        this.domElement.style.cursor = style;\n                    }\n                    break;\n                case 'function':\n                    // functions are just called, and passed the cursor mode\n                    style(mode);\n                    break;\n                case 'object':\n                    // if it is an object, assume that it is a dictionary of CSS styles,\n                    // apply it to the interactionDOMElement\n                    if (applyStyles)\n                    {\n                        Object.assign(this.domElement.style, style);\n                    }\n                    break;\n            }\n        }\n        else if (applyStyles && typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode))\n        {\n            // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n            // for the mode, then assume that the dev wants it to be CSS for the cursor.\n            this.domElement.style.cursor = mode;\n        }\n    }\n\n    /**\n     * The global pointer event.\n     * Useful for getting the pointer position without listening to events.\n     * @since 7.2.0\n     */\n    public get pointer(): Readonly<FederatedPointerEvent>\n    {\n        return this._rootPointerEvent;\n    }\n\n    /**\n     * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerDown(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        const events = this._normalizeToPointerData(nativeEvent);\n\n        /*\n         * No need to prevent default on natural pointer events, as there are no side effects\n         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n         * so still need to be prevented.\n         */\n\n        // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n        if (this.autoPreventDefault && (events[0] as any).isNormalized)\n        {\n            const cancelable = nativeEvent.cancelable || !('cancelable' in nativeEvent);\n\n            if (cancelable)\n            {\n                nativeEvent.preventDefault();\n            }\n        }\n\n        for (let i = 0, j = events.length; i < j; i++)\n        {\n            const nativeEvent = events[i];\n            const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent);\n\n            this.rootBoundary.mapEvent(federatedEvent);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch events.\n     */\n    private _onPointerMove(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.move) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        EventsTicker.pointerMoved();\n\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerUp(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        let target = nativeEvent.target;\n\n        // if in shadow DOM use composedPath to access target\n        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0)\n        {\n            target = nativeEvent.composedPath()[0];\n        }\n\n        const outside = target !== this.domElement ? 'outside' : '';\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            event.type += outside;\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerOverOut(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n     * @param nativeEvent - The native wheel event.\n     */\n    protected onWheel(nativeEvent: WheelEvent): void\n    {\n        if (!this.features.wheel) return;\n        const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n        this.rootBoundary.mapEvent(wheelEvent);\n    }\n\n    /**\n     * Sets the {@link EventSystem#domElement domElement} and binds event listeners.\n     *\n     * To deregister the current DOM element without setting a new one, pass {@code null}.\n     * @param element - The new DOM element.\n     */\n    public setTargetElement(element: HTMLElement): void\n    {\n        this._removeEvents();\n        this.domElement = element;\n        EventsTicker.domElement = element;\n        this._addEvents();\n    }\n\n    /** Register event listeners on {@link Renderer#domElement this.domElement}. */\n    private _addEvents(): void\n    {\n        if (this._eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        EventsTicker.addTickerListener();\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        if (style)\n        {\n            if ((globalThis.navigator as any).msPointerEnabled)\n            {\n                style.msContentZooming = 'none';\n                style.msTouchAction = 'none';\n            }\n            else if (this.supportsPointerEvents)\n            {\n                style.touchAction = 'none';\n            }\n        }\n\n        /*\n         * These events are added first, so that if pointer events are normalized, they are fired\n         * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd\n         */\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.addEventListener('pointermove', this._onPointerMove, true);\n            this.domElement.addEventListener('pointerdown', this._onPointerDown, true);\n            // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n            // we already handle those, so for the purposes of what we do in onPointerOut, we only\n            // care about the pointerleave event\n            this.domElement.addEventListener('pointerleave', this._onPointerOverOut, true);\n            this.domElement.addEventListener('pointerover', this._onPointerOverOut, true);\n            // globalThis.addEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.addEventListener('pointerup', this._onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.addEventListener('mousemove', this._onPointerMove, true);\n            this.domElement.addEventListener('mousedown', this._onPointerDown, true);\n            this.domElement.addEventListener('mouseout', this._onPointerOverOut, true);\n            this.domElement.addEventListener('mouseover', this._onPointerOverOut, true);\n            globalThis.addEventListener('mouseup', this._onPointerUp, true);\n\n            if (this.supportsTouchEvents)\n            {\n                this.domElement.addEventListener('touchstart', this._onPointerDown, true);\n                // this.domElement.addEventListener('touchcancel', this.onPointerCancel, true);\n                this.domElement.addEventListener('touchend', this._onPointerUp, true);\n                this.domElement.addEventListener('touchmove', this._onPointerMove, true);\n            }\n        }\n\n        this.domElement.addEventListener('wheel', this.onWheel, {\n            passive: true,\n            capture: true,\n        });\n\n        this._eventsAdded = true;\n    }\n\n    /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */\n    private _removeEvents(): void\n    {\n        if (!this._eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        EventsTicker.removeTickerListener();\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        // offscreen canvas does not have style, so check first\n        if (style)\n        {\n            if ((globalThis.navigator as any).msPointerEnabled)\n            {\n                style.msContentZooming = '';\n                style.msTouchAction = '';\n            }\n            else if (this.supportsPointerEvents)\n            {\n                style.touchAction = '';\n            }\n        }\n\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.removeEventListener('pointermove', this._onPointerMove, true);\n            this.domElement.removeEventListener('pointerdown', this._onPointerDown, true);\n            this.domElement.removeEventListener('pointerleave', this._onPointerOverOut, true);\n            this.domElement.removeEventListener('pointerover', this._onPointerOverOut, true);\n            // globalThis.removeEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.removeEventListener('pointerup', this._onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.removeEventListener('mousemove', this._onPointerMove, true);\n            this.domElement.removeEventListener('mousedown', this._onPointerDown, true);\n            this.domElement.removeEventListener('mouseout', this._onPointerOverOut, true);\n            this.domElement.removeEventListener('mouseover', this._onPointerOverOut, true);\n            globalThis.removeEventListener('mouseup', this._onPointerUp, true);\n\n            if (this.supportsTouchEvents)\n            {\n                this.domElement.removeEventListener('touchstart', this._onPointerDown, true);\n                // this.domElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n                this.domElement.removeEventListener('touchend', this._onPointerUp, true);\n                this.domElement.removeEventListener('touchmove', this._onPointerMove, true);\n            }\n        }\n\n        this.domElement.removeEventListener('wheel', this.onWheel, true);\n\n        this.domElement = null;\n        this._eventsAdded = false;\n    }\n\n    /**\n     * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The\n     * resulting value is stored in the point. This takes into account the fact that the DOM\n     * element could be scaled and positioned anywhere on the screen.\n     * @param  {PointData} point - the point that the result will be stored in\n     * @param  {number} x - the x coord of the position to map\n     * @param  {number} y - the y coord of the position to map\n     */\n    public mapPositionToPoint(point: PointData, x: number, y: number): void\n    {\n        const rect = this.domElement.isConnected\n            ? this.domElement.getBoundingClientRect()\n            : {\n                x: 0,\n                y: 0,\n                width: (this.domElement as any).width,\n                height: (this.domElement as any).height,\n                left: 0,\n                top: 0\n            };\n\n        const resolutionMultiplier = 1.0 / this.resolution;\n\n        point.x = ((x - rect.left) * ((this.domElement as any).width / rect.width)) * resolutionMultiplier;\n        point.y = ((y - rect.top) * ((this.domElement as any).height / rect.height)) * resolutionMultiplier;\n    }\n\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     * @param event - The original event data from a touch or mouse event\n     * @returns An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n    private _normalizeToPointerData(event: TouchEvent | MouseEvent | PointerEvent): PointerEvent[]\n    {\n        const normalizedEvents = [];\n\n        if (this.supportsTouchEvents && event instanceof TouchEvent)\n        {\n            for (let i = 0, li = event.changedTouches.length; i < li; i++)\n            {\n                const touch = event.changedTouches[i] as PixiTouch;\n\n                if (typeof touch.button === 'undefined') touch.button = 0;\n                if (typeof touch.buttons === 'undefined') touch.buttons = 1;\n                if (typeof touch.isPrimary === 'undefined')\n                {\n                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n                }\n                if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n                if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n                if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n                if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n                if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n                if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n                if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n                if (typeof touch.twist === 'undefined') touch.twist = 0;\n                if (typeof touch.tangentialPressure === 'undefined') touch.tangentialPressure = 0;\n                // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n                // support, and the fill ins are not quite the same\n                // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n                // left is not 0,0 on the page\n                if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n                if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n                // mark the touch as normalized, just so that we know we did it\n                touch.isNormalized = true;\n                touch.type = event.type;\n\n                normalizedEvents.push(touch);\n            }\n        }\n        // apparently PointerEvent subclasses MouseEvent, so yay\n        else if (!globalThis.MouseEvent\n            || (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))))\n        {\n            const tempEvent = event as PixiPointerEvent;\n\n            if (typeof tempEvent.isPrimary === 'undefined') tempEvent.isPrimary = true;\n            if (typeof tempEvent.width === 'undefined') tempEvent.width = 1;\n            if (typeof tempEvent.height === 'undefined') tempEvent.height = 1;\n            if (typeof tempEvent.tiltX === 'undefined') tempEvent.tiltX = 0;\n            if (typeof tempEvent.tiltY === 'undefined') tempEvent.tiltY = 0;\n            if (typeof tempEvent.pointerType === 'undefined') tempEvent.pointerType = 'mouse';\n            if (typeof tempEvent.pointerId === 'undefined') tempEvent.pointerId = MOUSE_POINTER_ID;\n            if (typeof tempEvent.pressure === 'undefined') tempEvent.pressure = 0.5;\n            if (typeof tempEvent.twist === 'undefined') tempEvent.twist = 0;\n            if (typeof tempEvent.tangentialPressure === 'undefined') tempEvent.tangentialPressure = 0;\n\n            // mark the mouse event as normalized, just so that we know we did it\n            tempEvent.isNormalized = true;\n\n            normalizedEvents.push(tempEvent);\n        }\n        else\n        {\n            normalizedEvents.push(event);\n        }\n\n        return normalizedEvents as PointerEvent[];\n    }\n\n    /**\n     * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n     *\n     * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across\n     * multiple native wheel events.\n     * @param nativeEvent - The native wheel event that occurred on the canvas.\n     * @returns A federated wheel event.\n     */\n    protected normalizeWheelEvent(nativeEvent: WheelEvent): FederatedWheelEvent\n    {\n        const event = this._rootWheelEvent;\n\n        this._transferMouseData(event, nativeEvent);\n\n        // When WheelEvent is triggered by scrolling with mouse wheel, reading WheelEvent.deltaMode\n        // before deltaX/deltaY/deltaZ on Firefox will result in WheelEvent.DOM_DELTA_LINE (1),\n        // while reading WheelEvent.deltaMode after deltaX/deltaY/deltaZ on Firefox or reading\n        // in any order on other browsers will result in WheelEvent.DOM_DELTA_PIXEL (0).\n        // Therefore, we need to read WheelEvent.deltaMode after deltaX/deltaY/deltaZ in order to\n        // make its behavior more consistent across browsers.\n        // @see https://github.com/pixijs/pixijs/issues/8970\n        event.deltaX = nativeEvent.deltaX;\n        event.deltaY = nativeEvent.deltaY;\n        event.deltaZ = nativeEvent.deltaZ;\n        event.deltaMode = nativeEvent.deltaMode;\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);\n        event.offset.copyFrom(event.screen);\n\n        event.nativeEvent = nativeEvent;\n        event.type = nativeEvent.type;\n\n        return event;\n    }\n\n    /**\n     * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.\n     * @param event\n     * @param nativeEvent\n     */\n    private _bootstrapEvent(event: FederatedPointerEvent, nativeEvent: PointerEvent): FederatedPointerEvent\n    {\n        event.originalEvent = null;\n        event.nativeEvent = nativeEvent;\n\n        event.pointerId = nativeEvent.pointerId;\n        event.width = nativeEvent.width;\n        event.height = nativeEvent.height;\n        event.isPrimary = nativeEvent.isPrimary;\n        event.pointerType = nativeEvent.pointerType;\n        event.pressure = nativeEvent.pressure;\n        event.tangentialPressure = nativeEvent.tangentialPressure;\n        event.tiltX = nativeEvent.tiltX;\n        event.tiltY = nativeEvent.tiltY;\n        event.twist = nativeEvent.twist;\n        this._transferMouseData(event, nativeEvent);\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);// global = screen for top-level\n        event.offset.copyFrom(event.screen);// EventBoundary recalculates using its rootTarget\n\n        event.isTrusted = nativeEvent.isTrusted;\n        if (event.type === 'pointerleave')\n        {\n            event.type = 'pointerout';\n        }\n        if (event.type.startsWith('mouse'))\n        {\n            event.type = event.type.replace('mouse', 'pointer');\n        }\n        if (event.type.startsWith('touch'))\n        {\n            event.type = TOUCH_TO_POINTER[event.type] || event.type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.\n     * @param event\n     * @param nativeEvent\n     */\n    private _transferMouseData(event: FederatedMouseEvent, nativeEvent: MouseEvent): void\n    {\n        event.isTrusted = nativeEvent.isTrusted;\n        event.srcElement = nativeEvent.srcElement;\n        event.timeStamp = performance.now();\n        event.type = nativeEvent.type;\n\n        event.altKey = nativeEvent.altKey;\n        event.button = nativeEvent.button;\n        event.buttons = nativeEvent.buttons;\n        event.client.x = nativeEvent.clientX;\n        event.client.y = nativeEvent.clientY;\n        event.ctrlKey = nativeEvent.ctrlKey;\n        event.metaKey = nativeEvent.metaKey;\n        event.movement.x = nativeEvent.movementX;\n        event.movement.y = nativeEvent.movementY;\n        event.page.x = nativeEvent.pageX;\n        event.page.y = nativeEvent.pageY;\n        event.relatedTarget = null;\n        event.shiftKey = nativeEvent.shiftKey;\n    }\n}\n\ninterface CrossCSSStyleDeclaration extends CSSStyleDeclaration\n{\n    msContentZooming: string;\n    msTouchAction: string;\n}\n\ninterface PixiPointerEvent extends PointerEvent\n{\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    isNormalized: boolean;\n    type: string;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}