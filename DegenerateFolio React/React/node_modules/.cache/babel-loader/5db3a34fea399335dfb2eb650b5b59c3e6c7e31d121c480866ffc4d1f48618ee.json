{"ast":null,"code":"import EventEmitter from 'eventemitter3';\nimport { Color } from '../../../color/Color.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../maths/point/Point.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { uid } from '../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { Bounds } from '../../container/bounds/Bounds.mjs';\nimport { GraphicsPath } from './path/GraphicsPath.mjs';\nimport { SVGParser } from './svg/SVGParser.mjs';\nimport { convertFillInputToFillStyle } from './utils/convertFillInputToFillStyle.mjs';\n\"use strict\";\nconst tmpPoint = new Point();\nconst tempMatrix = new Matrix();\nconst _GraphicsContext = class _GraphicsContext extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    this.uid = uid(\"graphicsContext\");\n    this.dirty = true;\n    this.batchMode = \"auto\";\n    this.instructions = [];\n    this._activePath = new GraphicsPath();\n    this._transform = new Matrix();\n    this._fillStyle = {\n      ..._GraphicsContext.defaultFillStyle\n    };\n    this._strokeStyle = {\n      ..._GraphicsContext.defaultStrokeStyle\n    };\n    this._stateStack = [];\n    this._tick = 0;\n    this._bounds = new Bounds();\n    this._boundsDirty = true;\n  }\n  /**\n   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n   * including the current drawing state, transformations, styles, and instructions.\n   * @returns A new GraphicsContext instance with the same properties and state as this one.\n   */\n  clone() {\n    const clone = new _GraphicsContext();\n    clone.batchMode = this.batchMode;\n    clone.instructions = this.instructions.slice();\n    clone._activePath = this._activePath.clone();\n    clone._transform = this._transform.clone();\n    clone._fillStyle = {\n      ...this._fillStyle\n    };\n    clone._strokeStyle = {\n      ...this._strokeStyle\n    };\n    clone._stateStack = this._stateStack.slice();\n    clone._bounds = this._bounds.clone();\n    clone._boundsDirty = true;\n    return clone;\n  }\n  /**\n   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n   */\n  get fillStyle() {\n    return this._fillStyle;\n  }\n  set fillStyle(value) {\n    this._fillStyle = convertFillInputToFillStyle(value, _GraphicsContext.defaultFillStyle);\n  }\n  /**\n   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   */\n  get strokeStyle() {\n    return this._strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._strokeStyle = convertFillInputToFillStyle(value, _GraphicsContext.defaultStrokeStyle);\n  }\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n   *                or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(style) {\n    this._fillStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultFillStyle);\n    return this;\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   *                or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(style) {\n    this._strokeStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultStrokeStyle);\n    return this;\n  }\n  texture(texture, tint, dx, dy, dw, dh) {\n    this.instructions.push({\n      action: \"texture\",\n      data: {\n        image: texture,\n        dx: dx || 0,\n        dy: dy || 0,\n        dw: dw || texture.frame.width,\n        dh: dh || texture.frame.height,\n        transform: this._transform.clone(),\n        alpha: this._fillStyle.alpha,\n        style: tint ? Color.shared.setValue(tint).toNumber() : 16777215\n      }\n    });\n    this.onUpdate();\n    return this;\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    this._activePath = new GraphicsPath();\n    return this;\n  }\n  fill(style, alpha) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === \"stroke\") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path) return this;\n    if (style != null) {\n      if (alpha !== void 0 && typeof style === \"number\") {\n        deprecation(v8_0_0, \"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead\");\n        style = {\n          color: style,\n          alpha\n        };\n      }\n      this._fillStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultFillStyle);\n    }\n    this.instructions.push({\n      action: \"fill\",\n      // TODO copy fill style!\n      data: {\n        style: this.fillStyle,\n        path\n      }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  _initNextPathLocation() {\n    const {\n      x,\n      y\n    } = this._activePath.getLastPoint(Point.shared);\n    this._activePath.clear();\n    this._activePath.moveTo(x, y);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(style) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === \"fill\") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path) return this;\n    if (style != null) {\n      this._strokeStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultStrokeStyle);\n    }\n    this.instructions.push({\n      action: \"stroke\",\n      // TODO copy fill style!\n      data: {\n        style: this.strokeStyle,\n        path\n      }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  cut() {\n    for (let i = 0; i < 2; i++) {\n      const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n      const holePath = this._activePath.clone();\n      if (lastInstruction) {\n        if (lastInstruction.action === \"stroke\" || lastInstruction.action === \"fill\") {\n          if (lastInstruction.data.hole) {\n            lastInstruction.data.hole.addPath(holePath);\n          } else {\n            lastInstruction.data.hole = holePath;\n            break;\n          }\n        }\n      }\n    }\n    this._initNextPathLocation();\n    return this;\n  }\n  /**\n   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n   * starting and ending angles, and direction.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The arc's radius.\n   * @param startAngle - The starting angle, in radians.\n   * @param endAngle - The ending angle, in radians.\n   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arc(t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, radius, startAngle, endAngle, counterclockwise);\n    return this;\n  }\n  /**\n   * Adds an arc to the current path with the given control points and radius, connected to the previous point\n   * by a straight line if necessary.\n   * @param x1 - The x-coordinate of the first control point.\n   * @param y1 - The y-coordinate of the first control point.\n   * @param x2 - The x-coordinate of the second control point.\n   * @param y2 - The y-coordinate of the second control point.\n   * @param radius - The arc's radius.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcTo(t.a * x1 + t.c * y1 + t.tx, t.b * x1 + t.d * y1 + t.ty, t.a * x2 + t.c * y2 + t.tx, t.b * x2 + t.d * y2 + t.ty, radius);\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcToSvg(rx, ry, xAxisRotation,\n    // should we rotate this with transform??\n    largeArcFlag, sweepFlag, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty);\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.bezierCurveTo(t.a * cp1x + t.c * cp1y + t.tx, t.b * cp1x + t.d * cp1y + t.ty, t.a * cp2x + t.c * cp2y + t.tx, t.b * cp2x + t.d * cp2y + t.ty, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, smoothness);\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this._tick++;\n    this._activePath?.closePath();\n    return this;\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY) {\n    this._tick++;\n    this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius) {\n    this._tick++;\n    this._activePath.circle(x, y, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @returns The instance of the current object for chaining.\n   */\n  path(path) {\n    this._tick++;\n    this._activePath.addPath(path, this._transform.clone());\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.lineTo(t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty);\n    return this;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    const instructions = this._activePath.instructions;\n    const transformedX = t.a * x + t.c * y + t.tx;\n    const transformedY = t.b * x + t.d * y + t.ty;\n    if (instructions.length === 1 && instructions[0].action === \"moveTo\") {\n      instructions[0].data[0] = transformedX;\n      instructions[0].data[1] = transformedY;\n      return this;\n    }\n    this._activePath.moveTo(transformedX, transformedY);\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cpx - The x-coordinate of the control point.\n   * @param cpy - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cpx, cpy, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.quadraticCurveTo(t.a * cpx + t.c * cpy + t.tx, t.b * cpx + t.d * cpy + t.ty, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, smoothness);\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h) {\n    this._tick++;\n    this._activePath.rect(x, y, w, h, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius) {\n    this._tick++;\n    this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n   * rotated, or translated as needed.\n   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates, of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   */\n  poly(points, close) {\n    this._tick++;\n    this._activePath.poly(points, close, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    this._tick++;\n    this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation) {\n    this._tick++;\n    this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n    return this;\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic, smoothness) {\n    this._tick++;\n    this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n    return this;\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    this._tick++;\n    this._activePath.filletRect(x, y, width, height, fillet);\n    return this;\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    this._tick++;\n    this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  star(x, y, points, radius, innerRadius = 0, rotation = 0) {\n    this._tick++;\n    this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n    return this;\n  }\n  /**\n   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n   * defined in SVG format to be drawn within the graphics context.\n   * @param svg - The SVG string to be parsed and rendered.\n   */\n  svg(svg) {\n    this._tick++;\n    SVGParser(svg, this);\n    return this;\n  }\n  /**\n   * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n   * This includes transformations, fill styles, and stroke styles.\n   */\n  restore() {\n    const state = this._stateStack.pop();\n    if (state) {\n      this._transform = state.transform;\n      this._fillStyle = state.fillStyle;\n      this._strokeStyle = state.strokeStyle;\n    }\n    return this;\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    this._stateStack.push({\n      transform: this._transform.clone(),\n      fillStyle: {\n        ...this._fillStyle\n      },\n      strokeStyle: {\n        ...this._strokeStyle\n      }\n    });\n    return this;\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this._transform;\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    this._transform.identity();\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the graphics context around the current origin.\n   * @param angle - The angle of rotation in radians.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  rotate(angle) {\n    this._transform.rotate(angle);\n    return this;\n  }\n  /**\n   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n   * @param x - The scale factor in the horizontal direction.\n   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  scale(x, y = x) {\n    this._transform.scale(x, y);\n    return this;\n  }\n  setTransform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix) {\n      this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n      return this;\n    }\n    this._transform.set(a, b, c, d, dx, dy);\n    return this;\n  }\n  transform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix) {\n      this._transform.append(a);\n      return this;\n    }\n    tempMatrix.set(a, b, c, d, dx, dy);\n    this._transform.append(tempMatrix);\n    return this;\n  }\n  /**\n   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n   * @param x - The amount to translate in the horizontal direction.\n   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  translate(x, y = x) {\n    this._transform.translate(x, y);\n    return this;\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    this.instructions.length = 0;\n    this.resetTransform();\n    this.onUpdate();\n    return this;\n  }\n  onUpdate() {\n    if (this.dirty) return;\n    this.emit(\"update\", this, 16);\n    this.dirty = true;\n    this._boundsDirty = true;\n  }\n  /** The bounds of the graphic shape. */\n  get bounds() {\n    if (!this._boundsDirty) return this._bounds;\n    const bounds = this._bounds;\n    bounds.clear();\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const action = instruction.action;\n      if (action === \"fill\") {\n        const data = instruction.data;\n        bounds.addBounds(data.path.bounds);\n      } else if (action === \"texture\") {\n        const data = instruction.data;\n        bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n      }\n      if (action === \"stroke\") {\n        const data = instruction.data;\n        const padding = data.style.width / 2;\n        const _bounds = data.path.bounds;\n        bounds.addFrame(_bounds.minX - padding, _bounds.minY - padding, _bounds.maxX + padding, _bounds.maxY + padding);\n      }\n    }\n    return bounds;\n  }\n  /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it's contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */\n  containsPoint(point) {\n    if (!this.bounds.containsPoint(point.x, point.y)) return false;\n    const instructions = this.instructions;\n    let hasHit = false;\n    for (let k = 0; k < instructions.length; k++) {\n      const instruction = instructions[k];\n      const data = instruction.data;\n      const path = data.path;\n      if (!instruction.action || !path) continue;\n      const style = data.style;\n      const shapes = path.shapePath.shapePrimitives;\n      for (let i = 0; i < shapes.length; i++) {\n        const shape = shapes[i].shape;\n        if (!style || !shape) continue;\n        const transform = shapes[i].transform;\n        const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n        if (instruction.action === \"fill\") {\n          hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n        } else {\n          hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, style.width);\n        }\n        const holes = data.hole;\n        if (holes) {\n          const holeShapes = holes.shapePath?.shapePrimitives;\n          if (holeShapes) {\n            for (let j = 0; j < holeShapes.length; j++) {\n              if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) {\n                hasHit = false;\n              }\n            }\n          }\n        }\n        if (hasHit) {\n          return true;\n        }\n      }\n    }\n    return hasHit;\n  }\n  /**\n   * Destroys the GraphicsData object.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n   */\n  destroy(options = false) {\n    this._stateStack.length = 0;\n    this._transform = null;\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      if (this._fillStyle.texture) {\n        this._fillStyle.texture.destroy(destroyTextureSource);\n      }\n      if (this._strokeStyle.texture) {\n        this._strokeStyle.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fillStyle = null;\n    this._strokeStyle = null;\n    this.instructions = null;\n    this._activePath = null;\n    this._bounds = null;\n    this._stateStack = null;\n    this.customShader = null;\n    this._transform = null;\n  }\n};\n/** The default fill style to use when none is provided. */\n_GraphicsContext.defaultFillStyle = {\n  /** The color to use for the fill. */\n  color: 16777215,\n  /** The alpha value to use for the fill. */\n  alpha: 1,\n  /** The texture to use for the fill. */\n  texture: Texture.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\n/** The default stroke style to use when none is provided. */\n_GraphicsContext.defaultStrokeStyle = {\n  /** The width of the stroke. */\n  width: 1,\n  /** The color to use for the stroke. */\n  color: 16777215,\n  /** The alpha value to use for the stroke. */\n  alpha: 1,\n  /** The alignment of the stroke. */\n  alignment: 0.5,\n  /** The miter limit to use. */\n  miterLimit: 10,\n  /** The line cap style to use. */\n  cap: \"butt\",\n  /** The line join style to use. */\n  join: \"miter\",\n  /** The texture to use for the fill. */\n  texture: Texture.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\nlet GraphicsContext = _GraphicsContext;\nexport { GraphicsContext };","map":{"version":3,"names":["tmpPoint","Point","tempMatrix","Matrix","_GraphicsContext","EventEmitter","constructor","arguments","uid","dirty","batchMode","instructions","_activePath","GraphicsPath","_transform","_fillStyle","defaultFillStyle","_strokeStyle","defaultStrokeStyle","_stateStack","_tick","_bounds","Bounds","_boundsDirty","clone","slice","fillStyle","value","convertFillInputToFillStyle","strokeStyle","setFillStyle","style","setStrokeStyle","texture","tint","dx","dy","dw","dh","push","action","data","image","frame","width","height","transform","alpha","Color","shared","setValue","toNumber","onUpdate","beginPath","fill","path","lastInstruction","length","deprecation","v8_0_0","color","_initNextPathLocation","x","y","getLastPoint","clear","moveTo","stroke","cut","i","holePath","hole","addPath","arc","radius","startAngle","endAngle","counterclockwise","t","a","c","tx","b","d","ty","arcTo","x1","y1","x2","y2","arcToSvg","rx","ry","xAxisRotation","largeArcFlag","sweepFlag","bezierCurveTo","cp1x","cp1y","cp2x","cp2y","smoothness","closePath","ellipse","radiusX","radiusY","circle","lineTo","transformedX","transformedY","quadraticCurveTo","cpx","cpy","rect","w","h","roundRect","poly","points","close","regularPoly","sides","rotation","roundPoly","corner","roundShape","useQuadratic","filletRect","fillet","chamferRect","chamfer","star","innerRadius","svg","SVGParser","restore","state","pop","save","getTransform","resetTransform","identity","rotate","angle","scale","setTransform","set","append","translate","emit","bounds","instruction","addBounds","addFrame","padding","minX","minY","maxX","maxY","containsPoint","point","hasHit","k","shapes","shapePath","shapePrimitives","shape","transformedPoint","applyInverse","contains","strokeContains","holes","holeShapes","j","destroy","options","removeAllListeners","destroyTexture","destroyTextureSource","textureSource","customShader","Texture","WHITE","matrix","alignment","miterLimit","cap","join","GraphicsContext"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/graphics/shared/GraphicsContext.ts"],"sourcesContent":["/* eslint-disable max-len */\nimport EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../../color/Color';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Bounds } from '../../container/bounds/Bounds';\nimport { GraphicsPath } from './path/GraphicsPath';\nimport { SVGParser } from './svg/SVGParser';\nimport { convertFillInputToFillStyle } from './utils/convertFillInputToFillStyle';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { TextureDestroyOptions, TypeOrBool } from '../../container/destroyTypes';\nimport type { LineCap, LineJoin } from './const';\nimport type { FillGradient } from './fill/FillGradient';\nimport type { FillPattern } from './fill/FillPattern';\nimport type { RoundedPoint } from './path/roundShape';\n\n/**\n * A fill style object.\n * @memberof scene\n */\nexport interface FillStyle\n{\n    /** The color to use for the fill. */\n    color?: ColorSource;\n    /** The alpha value to use for the fill. */\n    alpha?: number;\n    /** The texture to use for the fill. */\n    texture?: Texture | null;\n    /** The matrix to apply. */\n    matrix?: Matrix | null;\n    /** The fill pattern to use. */\n    fill?: FillPattern | FillGradient | null;\n}\n\nexport type ConvertedFillStyle = Omit<Required<FillStyle>, 'color'> & { color: number };\n\nexport interface PatternFillStyle\n{\n    fill?: FillPattern | FillGradient;\n    color?: number;\n    alpha?: number;\n}\n\n/**\n * A stroke style object.\n * @memberof scene\n */\nexport interface StrokeStyle extends FillStyle\n{\n    /** The width of the stroke. */\n    width?: number;\n    /** The alignment of the stroke. */\n    alignment?: number;\n    // native?: boolean;\n    /** The line cap style to use. */\n    cap?: LineCap;\n    /** The line join style to use. */\n    join?: LineJoin;\n    /** The miter limit to use. */\n    miterLimit?: number;\n}\n\nexport type ConvertedStrokeStyle = Omit<StrokeStyle, 'color'> & ConvertedFillStyle;\n\nconst tmpPoint = new Point();\n\nexport type BatchMode = 'auto' | 'batch' | 'no-batch';\n\nexport type FillStyleInputs = ColorSource | FillGradient | CanvasPattern | PatternFillStyle | FillStyle | ConvertedFillStyle | StrokeStyle | ConvertedStrokeStyle;\n\nexport interface FillInstruction\n{\n    action: 'fill' | 'cut'\n    data: { style: ConvertedFillStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\nexport interface StrokeInstruction\n{\n    action: 'stroke'\n    data: { style: ConvertedStrokeStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\nexport interface TextureInstruction\n{\n    action: 'texture'\n    data: {\n        image: Texture,\n\n        dx: number\n        dy: number\n\n        dw: number\n        dh: number\n\n        transform: Matrix\n        alpha: number\n        style: number,\n    }\n}\n\nexport type GraphicsInstructions = FillInstruction | StrokeInstruction | TextureInstruction;\n\nconst tempMatrix = new Matrix();\n\n/**\n * The GraphicsContext class allows for the creation of lightweight objects that contain instructions for drawing shapes and paths.\n * It is used internally by the Graphics class to draw shapes and paths, and can be used directly and shared between Graphics objects,\n *\n * This sharing of a `GraphicsContext` means that the intensive task of converting graphics instructions into GPU-ready geometry is done once, and the results are reused,\n * much like sprites reusing textures.\n * @memberof scene\n */\nexport class GraphicsContext extends EventEmitter<{\n    update: GraphicsContext\n    destroy: GraphicsContext\n}>\n{\n    /** The default fill style to use when none is provided. */\n    public static defaultFillStyle: ConvertedFillStyle = {\n        /** The color to use for the fill. */\n        color: 0xffffff,\n        /** The alpha value to use for the fill. */\n        alpha: 1,\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n    };\n\n    /** The default stroke style to use when none is provided. */\n    public static defaultStrokeStyle: ConvertedStrokeStyle = {\n        /** The width of the stroke. */\n        width: 1,\n        /** The color to use for the stroke. */\n        color: 0xffffff,\n        /** The alpha value to use for the stroke. */\n        alpha: 1,\n        /** The alignment of the stroke. */\n        alignment: 0.5,\n        /** The miter limit to use. */\n        miterLimit: 10,\n        /** The line cap style to use. */\n        cap: 'butt',\n        /** The line join style to use. */\n        join: 'miter',\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n    };\n\n    public uid = uid('graphicsContext');\n    public dirty = true;\n    public batchMode: BatchMode = 'auto';\n    public instructions: GraphicsInstructions[] = [];\n    public customShader?: Shader;\n\n    private _activePath: GraphicsPath = new GraphicsPath();\n    private _transform: Matrix = new Matrix();\n\n    private _fillStyle: ConvertedFillStyle = { ...GraphicsContext.defaultFillStyle };\n    private _strokeStyle: ConvertedStrokeStyle = { ...GraphicsContext.defaultStrokeStyle };\n    private _stateStack: { fillStyle: ConvertedFillStyle; strokeStyle: ConvertedStrokeStyle, transform: Matrix }[] = [];\n\n    private _tick = 0;\n\n    private _bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n     * including the current drawing state, transformations, styles, and instructions.\n     * @returns A new GraphicsContext instance with the same properties and state as this one.\n     */\n    public clone(): GraphicsContext\n    {\n        const clone = new GraphicsContext();\n\n        clone.batchMode = this.batchMode;\n        clone.instructions = this.instructions.slice();\n        clone._activePath = this._activePath.clone();\n        clone._transform = this._transform.clone();\n        clone._fillStyle = { ...this._fillStyle };\n        clone._strokeStyle = { ...this._strokeStyle };\n        clone._stateStack = this._stateStack.slice();\n        clone._bounds = this._bounds.clone();\n        clone._boundsDirty = true;\n\n        return clone;\n    }\n\n    /**\n     * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n     */\n    get fillStyle(): ConvertedFillStyle\n    {\n        return this._fillStyle;\n    }\n\n    set fillStyle(value: FillStyleInputs)\n    {\n        this._fillStyle = convertFillInputToFillStyle(value, GraphicsContext.defaultFillStyle);\n    }\n\n    /**\n     * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     */\n    get strokeStyle(): ConvertedStrokeStyle\n    {\n        return this._strokeStyle;\n    }\n\n    set strokeStyle(value: FillStyleInputs)\n    {\n        this._strokeStyle = convertFillInputToFillStyle(value, GraphicsContext.defaultStrokeStyle) as ConvertedStrokeStyle;\n    }\n\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n     *                or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(style: FillStyleInputs): this\n    {\n        this._fillStyle = convertFillInputToFillStyle(style, GraphicsContext.defaultFillStyle);\n\n        return this;\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     *                or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(style: FillStyleInputs): this\n    {\n        this._strokeStyle = convertFillInputToFillStyle(style, GraphicsContext.defaultStrokeStyle) as ConvertedStrokeStyle;\n\n        return this;\n    }\n\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture, tint, and dimensions.\n     * If only a texture is provided, it uses the texture's width and height for drawing. Additional parameters allow for specifying\n     * a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas. If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas. If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture): this;\n    public texture(texture: Texture, tint: ColorSource): this;\n    public texture(texture: Texture, tint: ColorSource, dx: number, dy: number): this;\n    public texture(texture: Texture, tint: ColorSource, dx: number, dy: number, dw: number, dh: number): this;\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this\n    {\n        this.instructions.push({\n            action: 'texture',\n            data: {\n                image: texture,\n\n                dx: dx || 0,\n                dy: dy || 0,\n\n                dw: dw || texture.frame.width,\n                dh: dh || texture.frame.height,\n\n                transform: this._transform.clone(),\n                alpha: this._fillStyle.alpha,\n                style: tint ? Color.shared.setValue(tint).toNumber() : 0xFFFFFF,\n            }\n        });\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        this._activePath = new GraphicsPath();\n\n        return this;\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillStyleInputs object for advanced fills.\n     * @param style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillStyleInputs): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha: number): this;\n    public fill(style?: FillStyleInputs, alpha?: number): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'stroke')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            if (alpha !== undefined && typeof style === 'number')\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead');\n                // #endif\n\n                style = { color: style, alpha };\n            }\n            this._fillStyle = convertFillInputToFillStyle(style, GraphicsContext.defaultFillStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'fill',\n            // TODO copy fill style!\n            data: { style: this.fillStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    private _initNextPathLocation()\n    {\n        // Reset the _activePath with the last point of the current path\n        const { x, y } = this._activePath.getLastPoint(Point.shared);\n\n        this._activePath.clear();\n        this._activePath.moveTo(x, y);\n    }\n\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(style?: FillStyleInputs): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'fill')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            this._strokeStyle = convertFillInputToFillStyle(style, GraphicsContext.defaultStrokeStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'stroke',\n            // TODO copy fill style!\n            data: { style: this.strokeStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public cut(): this\n    {\n        for (let i = 0; i < 2; i++)\n        {\n            const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n\n            const holePath = this._activePath.clone();\n\n            if (lastInstruction)\n            {\n                if (lastInstruction.action === 'stroke' || lastInstruction.action === 'fill')\n                {\n                    if (lastInstruction.data.hole)\n                    {\n                        lastInstruction.data.hole.addPath(holePath);\n                    }\n                    else\n                    {\n                        lastInstruction.data.hole = holePath;\n                        break;\n                    }\n                }\n            }\n        }\n\n        this._initNextPathLocation();\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arc(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            radius,\n            startAngle,\n            endAngle,\n            counterclockwise,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcTo(\n            (t.a * x1) + (t.c * y1) + t.tx,\n            (t.b * x1) + (t.d * y1) + t.ty,\n            (t.a * x2) + (t.c * y2) + t.tx,\n            (t.b * x2) + (t.d * y2) + t.ty,\n            radius,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number,\n        largeArcFlag: number,\n        sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcToSvg(\n            rx, ry,\n            xAxisRotation, // should we rotate this with transform??\n            largeArcFlag,\n            sweepFlag,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        // TODO optimize for no transform\n        const t = this._transform;\n\n        this._activePath.bezierCurveTo(\n            (t.a * cp1x) + (t.c * cp1y) + t.tx,\n            (t.b * cp1x) + (t.d * cp1y) + t.ty,\n            (t.a * cp2x) + (t.c * cp2y) + t.tx,\n            (t.b * cp2x) + (t.d * cp2y) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this._tick++;\n\n        this._activePath?.closePath();\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this\n    {\n        this._tick++;\n\n        this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this\n    {\n        this._tick++;\n\n        this._activePath.circle(x, y, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this\n    {\n        this._tick++;\n\n        this._activePath.addPath(path, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.lineTo(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty\n        );\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        const instructions = this._activePath.instructions;\n\n        const transformedX = (t.a * x) + (t.c * y) + t.tx;\n        const transformedY = (t.b * x) + (t.d * y) + t.ty;\n\n        if (instructions.length === 1 && instructions[0].action === 'moveTo')\n        {\n            instructions[0].data[0] = transformedX;\n            instructions[0].data[1] = transformedY;\n\n            return this;\n        }\n        this._activePath.moveTo(\n            transformedX,\n            transformedY\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.quadraticCurveTo(\n            (t.a * cpx) + (t.c * cpy) + t.tx,\n            (t.b * cpx) + (t.d * cpy) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this\n    {\n        this._tick++;\n\n        this._activePath.rect(x, y, w, h, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this\n    {\n        this._tick++;\n\n        this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this\n    {\n        this._tick++;\n\n        this._activePath.poly(points, close, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this\n    {\n        this._tick++;\n        this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this\n    {\n        this._tick++;\n        this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        this._tick++;\n        this._activePath.filletRect(x, y, width, height, fillet);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius = 0, rotation = 0): this\n    {\n        this._tick++;\n\n        this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this\n    {\n        this._tick++;\n\n        SVGParser(svg, this);\n\n        return this;\n    }\n\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this\n    {\n        const state = this._stateStack.pop();\n\n        if (state)\n        {\n            this._transform = state.transform;\n            this._fillStyle = state.fillStyle;\n            this._strokeStyle = state.strokeStyle;\n        }\n\n        return this;\n    }\n\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        this._stateStack.push({\n            transform: this._transform.clone(),\n            fillStyle: { ...this._fillStyle },\n            strokeStyle: { ...this._strokeStyle },\n        });\n\n        return this;\n    }\n\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this._transform;\n    }\n\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        this._transform.identity();\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotate(angle: number): this\n    {\n        this._transform.rotate(angle);\n\n        return this;\n    }\n\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this._transform.scale(x, y);\n\n        return this;\n    }\n\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n\n            return this;\n        }\n\n        this._transform.set(a, b, c, d, dx, dy);\n\n        return this;\n    }\n\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.append(a);\n\n            return this;\n        }\n\n        tempMatrix.set(a, b, c, d, dx, dy);\n        this._transform.append(tempMatrix);\n\n        return this;\n    }\n\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translate(x: number, y: number = x): this\n    {\n        this._transform.translate(x, y);\n\n        return this;\n    }\n\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        this.instructions.length = 0;\n        this.resetTransform();\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    protected onUpdate(): void\n    {\n        if (this.dirty) return;\n\n        this.emit('update', this, 0x10);\n        this.dirty = true;\n        this._boundsDirty = true;\n    }\n\n    /** The bounds of the graphic shape. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        // TODO switch to idy dirty with tick..\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const action = instruction.action;\n\n            if (action === 'fill')\n            {\n                const data = instruction.data as FillInstruction['data'];\n\n                bounds.addBounds(data.path.bounds);\n            }\n            else if (action === 'texture')\n            {\n                const data = instruction.data as TextureInstruction['data'];\n\n                bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n            }\n            if (action === 'stroke')\n            {\n                const data = instruction.data as StrokeInstruction['data'];\n\n                const padding = data.style.width / 2;\n\n                const _bounds = data.path.bounds;\n\n                bounds.addFrame(\n                    _bounds.minX - padding,\n                    _bounds.minY - padding,\n                    _bounds.maxX + padding,\n                    _bounds.maxY + padding\n                );\n            }\n        }\n\n        return bounds;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: PointData): boolean\n    {\n        // early out if the bounding box is not hit\n        if (!this.bounds.containsPoint(point.x, point.y)) return false;\n\n        const instructions = this.instructions;\n        let hasHit = false;\n\n        for (let k = 0; k < instructions.length; k++)\n        {\n            const instruction = instructions[k];\n\n            const data = instruction.data as FillInstruction['data'];\n            const path = data.path;\n\n            if (!instruction.action || !path) continue;\n\n            const style = data.style;\n            const shapes = path.shapePath.shapePrimitives;\n\n            for (let i = 0; i < shapes.length; i++)\n            {\n                const shape = shapes[i].shape;\n\n                if (!style || !shape) continue;\n\n                const transform = shapes[i].transform;\n\n                const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n\n                if (instruction.action === 'fill')\n                {\n                    hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n                }\n                else\n                {\n                    hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, (style as ConvertedStrokeStyle).width);\n                }\n\n                const holes = data.hole;\n\n                if (holes)\n                {\n                    const holeShapes = holes.shapePath?.shapePrimitives;\n\n                    if (holeShapes)\n                    {\n                        for (let j = 0; j < holeShapes.length; j++)\n                        {\n                            if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y))\n                            {\n                                hasHit = false;\n                            }\n                        }\n                    }\n                }\n\n                if (hasHit)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return hasHit;\n    }\n\n    /**\n     * Destroys the GraphicsData object.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n     * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false): void\n    {\n        this._stateStack.length = 0;\n        this._transform = null;\n\n        this.emit('destroy', this);\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fillStyle.texture)\n            {\n                this._fillStyle.texture.destroy(destroyTextureSource);\n            }\n\n            if (this._strokeStyle.texture)\n            {\n                this._strokeStyle.texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fillStyle = null;\n        this._strokeStyle = null;\n\n        this.instructions = null;\n        this._activePath = null;\n        this._bounds = null;\n        this._stateStack = null;\n        this.customShader = null;\n        this._transform = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}