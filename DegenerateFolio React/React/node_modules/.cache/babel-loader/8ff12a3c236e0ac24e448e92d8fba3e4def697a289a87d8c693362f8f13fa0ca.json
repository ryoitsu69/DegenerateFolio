{"ast":null,"code":"import { isString, objectSpread, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { Getters } from './Getters.js';\nexport class ApiBase extends Getters {\n  /**\n   * @description Create an instance of the class\n   *\n   * @param options Options object to create API instance or a Provider instance\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * import Api from '@polkadot/api/promise';\n   *\n   * const api = new Api().isReady();\n   *\n   * api.rpc.subscribeNewHeads((header) => {\n   *   console.log(`new block #${header.number.toNumber()}`);\n   * });\n   * ```\n   */\n  constructor(options = {}, type, decorateMethod) {\n    super(options, type, decorateMethod);\n  }\n  /**\n   * @description Connect from the underlying provider, halting all network traffic\n   */\n  connect() {\n    return this._rpcCore.connect();\n  }\n  /**\n   * @description Disconnect from the underlying provider, halting all network traffic\n   */\n  disconnect() {\n    this._unsubscribe();\n    return this._rpcCore.disconnect();\n  }\n  /**\n   * @description Set an external signer which will be used to sign extrinsic when account passed in is not KeyringPair\n   */\n  setSigner(signer) {\n    this._rx.signer = signer;\n  }\n  /**\n   * @description Signs a raw signer payload, string or Uint8Array\n   */\n  async sign(address, data, {\n    signer\n  } = {}) {\n    if (isString(address)) {\n      const _signer = signer || this._rx.signer;\n      if (!_signer?.signRaw) {\n        throw new Error('No signer exists with a signRaw interface. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.');\n      }\n      return (await _signer.signRaw(objectSpread({\n        type: 'bytes'\n      }, data, {\n        address\n      }))).signature;\n    }\n    return u8aToHex(address.sign(u8aToU8a(data.data)));\n  }\n}","map":{"version":3,"names":["isString","objectSpread","u8aToHex","u8aToU8a","Getters","ApiBase","constructor","options","type","decorateMethod","connect","_rpcCore","disconnect","_unsubscribe","setSigner","signer","_rx","sign","address","data","_signer","signRaw","Error","signature"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api/base/index.js"],"sourcesContent":["import { isString, objectSpread, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { Getters } from './Getters.js';\nexport class ApiBase extends Getters {\n    /**\n     * @description Create an instance of the class\n     *\n     * @param options Options object to create API instance or a Provider instance\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * import Api from '@polkadot/api/promise';\n     *\n     * const api = new Api().isReady();\n     *\n     * api.rpc.subscribeNewHeads((header) => {\n     *   console.log(`new block #${header.number.toNumber()}`);\n     * });\n     * ```\n     */\n    constructor(options = {}, type, decorateMethod) {\n        super(options, type, decorateMethod);\n    }\n    /**\n     * @description Connect from the underlying provider, halting all network traffic\n     */\n    connect() {\n        return this._rpcCore.connect();\n    }\n    /**\n     * @description Disconnect from the underlying provider, halting all network traffic\n     */\n    disconnect() {\n        this._unsubscribe();\n        return this._rpcCore.disconnect();\n    }\n    /**\n     * @description Set an external signer which will be used to sign extrinsic when account passed in is not KeyringPair\n     */\n    setSigner(signer) {\n        this._rx.signer = signer;\n    }\n    /**\n     * @description Signs a raw signer payload, string or Uint8Array\n     */\n    async sign(address, data, { signer } = {}) {\n        if (isString(address)) {\n            const _signer = signer || this._rx.signer;\n            if (!_signer?.signRaw) {\n                throw new Error('No signer exists with a signRaw interface. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.');\n            }\n            return (await _signer.signRaw(objectSpread({ type: 'bytes' }, data, { address }))).signature;\n        }\n        return u8aToHex(address.sign(u8aToU8a(data.data)));\n    }\n}\n"],"mappings":"AAAA,SAASA,QAAQ,EAAEC,YAAY,EAAEC,QAAQ,EAAEC,QAAQ,QAAQ,gBAAgB;AAC3E,SAASC,OAAO,QAAQ,cAAc;AACtC,OAAO,MAAMC,OAAO,SAASD,OAAO,CAAC;EACjC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,WAAWA,CAACC,OAAO,GAAG,CAAC,CAAC,EAAEC,IAAI,EAAEC,cAAc,EAAE;IAC5C,KAAK,CAACF,OAAO,EAAEC,IAAI,EAAEC,cAAc,CAAC;EACxC;EACA;AACJ;AACA;EACIC,OAAOA,CAAA,EAAG;IACN,OAAO,IAAI,CAACC,QAAQ,CAACD,OAAO,CAAC,CAAC;EAClC;EACA;AACJ;AACA;EACIE,UAAUA,CAAA,EAAG;IACT,IAAI,CAACC,YAAY,CAAC,CAAC;IACnB,OAAO,IAAI,CAACF,QAAQ,CAACC,UAAU,CAAC,CAAC;EACrC;EACA;AACJ;AACA;EACIE,SAASA,CAACC,MAAM,EAAE;IACd,IAAI,CAACC,GAAG,CAACD,MAAM,GAAGA,MAAM;EAC5B;EACA;AACJ;AACA;EACI,MAAME,IAAIA,CAACC,OAAO,EAAEC,IAAI,EAAE;IAAEJ;EAAO,CAAC,GAAG,CAAC,CAAC,EAAE;IACvC,IAAIf,QAAQ,CAACkB,OAAO,CAAC,EAAE;MACnB,MAAME,OAAO,GAAGL,MAAM,IAAI,IAAI,CAACC,GAAG,CAACD,MAAM;MACzC,IAAI,CAACK,OAAO,EAAEC,OAAO,EAAE;QACnB,MAAM,IAAIC,KAAK,CAAC,gJAAgJ,CAAC;MACrK;MACA,OAAO,CAAC,MAAMF,OAAO,CAACC,OAAO,CAACpB,YAAY,CAAC;QAAEO,IAAI,EAAE;MAAQ,CAAC,EAAEW,IAAI,EAAE;QAAED;MAAQ,CAAC,CAAC,CAAC,EAAEK,SAAS;IAChG;IACA,OAAOrB,QAAQ,CAACgB,OAAO,CAACD,IAAI,CAACd,QAAQ,CAACgB,IAAI,CAACA,IAAI,CAAC,CAAC,CAAC;EACtD;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}