{"ast":null,"code":"import { BN } from '../bn/bn.js';\n/**\n * @name u8aToBn\n * @summary Creates a BN from a Uint8Array object.\n * @description\n * `UInt8Array` input values return the actual BN. `null` or `undefined` values returns an `0x0` value.\n * @param value The value to convert\n * @param options Options to pass while converting\n * @param options.isLe Convert using Little Endian (default)\n * @param options.isNegative Convert using two's complement\n * @example\n * <BR>\n *\n * ```javascript\n * import { u8aToBn } from '@polkadot/util';\n *\n * u8aToHex(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0xf])); // 0x68656c0f\n * ```\n */\nexport function u8aToBn(value) {\n  let {\n    isLe = true,\n    isNegative = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // slice + reverse is expensive, however SCALE is LE by default so this is the path\n  // we are most interested in (the BE is added for the sake of being comprehensive)\n  if (!isLe) {\n    value = value.slice().reverse();\n  }\n  const count = value.length;\n  // shortcut for <= u48 values - in this case the manual conversion\n  // here seems to be more efficient than passing the full array\n  if (isNegative && count && value[count - 1] & 0x80) {\n    // Most common case i{8, 16, 32} default LE SCALE-encoded\n    // For <= 32, we also optimize the xor to a single op\n    switch (count) {\n      case 0:\n        return new BN(0);\n      case 1:\n        return new BN((value[0] ^ 255) * -1 - 1);\n      case 2:\n        return new BN((value[0] + (value[1] << 8) ^ 65535) * -1 - 1);\n      case 3:\n        return new BN((value[0] + (value[1] << 8) + (value[2] << 16) ^ 16777215) * -1 - 1);\n      case 4:\n        // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n        // 32-bit, in the case where the top-most bit is set this yields a negative value\n        return new BN((value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) * -1 - 1);\n      case 5:\n        return new BN(((value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) + (value[4] ^ 0xff) * 4294967296) * -1 - 1);\n      case 6:\n        return new BN(((value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) + (value[4] + (value[5] << 8) ^ 65535) * 4294967296) * -1 - 1);\n      default:\n        return new BN(value, 'le').fromTwos(count * 8);\n    }\n  }\n  // Most common case - u{8, 16, 32} default LE SCALE-encoded\n  //\n  // There are some slight benefits in unrolling this specific loop,\n  // however it comes with diminishing returns since here the actual\n  // `new BN` does seem to take up the bulk of the time\n  switch (count) {\n    case 0:\n      return new BN(0);\n    case 1:\n      return new BN(value[0]);\n    case 2:\n      return new BN(value[0] + (value[1] << 8));\n    case 3:\n      return new BN(value[0] + (value[1] << 8) + (value[2] << 16));\n    case 4:\n      // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n      // 32-bit, in the case where the top-most bit is set this yields a negative value\n      return new BN(value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216);\n    case 5:\n      return new BN(value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8)) * 16777216);\n    case 6:\n      return new BN(value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8) + (value[5] << 16)) * 16777216);\n    default:\n      return new BN(value, 'le');\n  }\n}","map":{"version":3,"names":["BN","u8aToBn","value","isLe","isNegative","arguments","length","undefined","slice","reverse","count","fromTwos"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util/u8a/toBn.js"],"sourcesContent":["import { BN } from '../bn/bn.js';\n/**\n * @name u8aToBn\n * @summary Creates a BN from a Uint8Array object.\n * @description\n * `UInt8Array` input values return the actual BN. `null` or `undefined` values returns an `0x0` value.\n * @param value The value to convert\n * @param options Options to pass while converting\n * @param options.isLe Convert using Little Endian (default)\n * @param options.isNegative Convert using two's complement\n * @example\n * <BR>\n *\n * ```javascript\n * import { u8aToBn } from '@polkadot/util';\n *\n * u8aToHex(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0xf])); // 0x68656c0f\n * ```\n */\nexport function u8aToBn(value, { isLe = true, isNegative = false } = {}) {\n    // slice + reverse is expensive, however SCALE is LE by default so this is the path\n    // we are most interested in (the BE is added for the sake of being comprehensive)\n    if (!isLe) {\n        value = value.slice().reverse();\n    }\n    const count = value.length;\n    // shortcut for <= u48 values - in this case the manual conversion\n    // here seems to be more efficient than passing the full array\n    if (isNegative && count && (value[count - 1] & 0x80)) {\n        // Most common case i{8, 16, 32} default LE SCALE-encoded\n        // For <= 32, we also optimize the xor to a single op\n        switch (count) {\n            case 0:\n                return new BN(0);\n            case 1:\n                return new BN(((value[0] ^ 255) * -1) - 1);\n            case 2:\n                return new BN((((value[0] + (value[1] << 8)) ^ 65535) * -1) - 1);\n            case 3:\n                return new BN((((value[0] + (value[1] << 8) + (value[2] << 16)) ^ 16777215) * -1) - 1);\n            case 4:\n                // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n                // 32-bit, in the case where the top-most bit is set this yields a negative value\n                return new BN((((value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216)) ^ 4294967295) * -1) - 1);\n            case 5:\n                return new BN(((((value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216)) ^ 4294967295) + ((value[4] ^ 0xff) * 4294967296)) * -1) - 1);\n            case 6:\n                return new BN(((((value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216)) ^ 4294967295) + (((value[4] + (value[5] << 8)) ^ 65535) * 4294967296)) * -1) - 1);\n            default:\n                return new BN(value, 'le').fromTwos(count * 8);\n        }\n    }\n    // Most common case - u{8, 16, 32} default LE SCALE-encoded\n    //\n    // There are some slight benefits in unrolling this specific loop,\n    // however it comes with diminishing returns since here the actual\n    // `new BN` does seem to take up the bulk of the time\n    switch (count) {\n        case 0:\n            return new BN(0);\n        case 1:\n            return new BN(value[0]);\n        case 2:\n            return new BN(value[0] + (value[1] << 8));\n        case 3:\n            return new BN(value[0] + (value[1] << 8) + (value[2] << 16));\n        case 4:\n            // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n            // 32-bit, in the case where the top-most bit is set this yields a negative value\n            return new BN(value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216));\n        case 5:\n            return new BN(value[0] + (value[1] << 8) + (value[2] << 16) + ((value[3] + (value[4] << 8)) * 16777216));\n        case 6:\n            return new BN(value[0] + (value[1] << 8) + (value[2] << 16) + ((value[3] + (value[4] << 8) + (value[5] << 16)) * 16777216));\n        default:\n            return new BN(value, 'le');\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}