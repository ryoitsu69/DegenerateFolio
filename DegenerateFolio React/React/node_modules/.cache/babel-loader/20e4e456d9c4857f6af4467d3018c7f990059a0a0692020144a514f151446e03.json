{"ast":null,"code":"import { BitmapFontData } from \"../BitmapFontData.mjs\";\nclass XMLFormat {\n  /**\n   * Check if resource refers to xml font data.\n   * @param data\n   * @returns - True if resource could be treated as font data, false otherwise.\n   */\n  static test(data) {\n    const xml = data;\n    return typeof data != \"string\" && \"getElementsByTagName\" in data && xml.getElementsByTagName(\"page\").length && xml.getElementsByTagName(\"info\")[0].getAttribute(\"face\") !== null;\n  }\n  /**\n   * Convert the XML into BitmapFontData that we can use.\n   * @param xml\n   * @returns - Data to use for BitmapFont\n   */\n  static parse(xml) {\n    const data = new BitmapFontData(),\n      info = xml.getElementsByTagName(\"info\"),\n      common = xml.getElementsByTagName(\"common\"),\n      page = xml.getElementsByTagName(\"page\"),\n      char = xml.getElementsByTagName(\"char\"),\n      kerning = xml.getElementsByTagName(\"kerning\"),\n      distanceField = xml.getElementsByTagName(\"distanceField\");\n    for (let i = 0; i < info.length; i++) data.info.push({\n      face: info[i].getAttribute(\"face\"),\n      size: parseInt(info[i].getAttribute(\"size\"), 10)\n    });\n    for (let i = 0; i < common.length; i++) data.common.push({\n      lineHeight: parseInt(common[i].getAttribute(\"lineHeight\"), 10)\n    });\n    for (let i = 0; i < page.length; i++) data.page.push({\n      id: parseInt(page[i].getAttribute(\"id\"), 10) || 0,\n      file: page[i].getAttribute(\"file\")\n    });\n    for (let i = 0; i < char.length; i++) {\n      const letter = char[i];\n      data.char.push({\n        id: parseInt(letter.getAttribute(\"id\"), 10),\n        page: parseInt(letter.getAttribute(\"page\"), 10) || 0,\n        x: parseInt(letter.getAttribute(\"x\"), 10),\n        y: parseInt(letter.getAttribute(\"y\"), 10),\n        width: parseInt(letter.getAttribute(\"width\"), 10),\n        height: parseInt(letter.getAttribute(\"height\"), 10),\n        xoffset: parseInt(letter.getAttribute(\"xoffset\"), 10),\n        yoffset: parseInt(letter.getAttribute(\"yoffset\"), 10),\n        xadvance: parseInt(letter.getAttribute(\"xadvance\"), 10)\n      });\n    }\n    for (let i = 0; i < kerning.length; i++) data.kerning.push({\n      first: parseInt(kerning[i].getAttribute(\"first\"), 10),\n      second: parseInt(kerning[i].getAttribute(\"second\"), 10),\n      amount: parseInt(kerning[i].getAttribute(\"amount\"), 10)\n    });\n    for (let i = 0; i < distanceField.length; i++) data.distanceField.push({\n      fieldType: distanceField[i].getAttribute(\"fieldType\"),\n      distanceRange: parseInt(distanceField[i].getAttribute(\"distanceRange\"), 10)\n    });\n    return data;\n  }\n}\nexport { XMLFormat };","map":{"version":3,"names":["XMLFormat","test","data","xml","getElementsByTagName","length","getAttribute","parse","BitmapFontData","info","common","page","char","kerning","distanceField","i","push","face","size","parseInt","lineHeight","id","file","letter","x","y","width","height","xoffset","yoffset","xadvance","first","second","amount","fieldType","distanceRange"],"sources":["/home/ryoitsu/node_modules/@pixi/text-bitmap/src/formats/XMLFormat.ts"],"sourcesContent":["import { BitmapFontData } from '../BitmapFontData';\n\n/**\n * BitmapFont format that's XML-based.\n * @private\n */\nexport class XMLFormat\n{\n    /**\n     * Check if resource refers to xml font data.\n     * @param data\n     * @returns - True if resource could be treated as font data, false otherwise.\n     */\n    static test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        const xml = data as Document;\n\n        return typeof data !== 'string'\n            && 'getElementsByTagName' in data\n            && xml.getElementsByTagName('page').length\n            && xml.getElementsByTagName('info')[0].getAttribute('face') !== null;\n    }\n\n    /**\n     * Convert the XML into BitmapFontData that we can use.\n     * @param xml\n     * @returns - Data to use for BitmapFont\n     */\n    static parse(xml: Document): BitmapFontData\n    {\n        const data = new BitmapFontData();\n        const info = xml.getElementsByTagName('info');\n        const common = xml.getElementsByTagName('common');\n        const page = xml.getElementsByTagName('page');\n        const char = xml.getElementsByTagName('char');\n        const kerning = xml.getElementsByTagName('kerning');\n        const distanceField = xml.getElementsByTagName('distanceField');\n\n        for (let i = 0; i < info.length; i++)\n        {\n            data.info.push({\n                face: info[i].getAttribute('face'),\n                size: parseInt(info[i].getAttribute('size'), 10),\n            });\n        }\n\n        for (let i = 0; i < common.length; i++)\n        {\n            data.common.push({\n                lineHeight: parseInt(common[i].getAttribute('lineHeight'), 10),\n            });\n        }\n\n        for (let i = 0; i < page.length; i++)\n        {\n            data.page.push({\n                id: parseInt(page[i].getAttribute('id'), 10) || 0,\n                file: page[i].getAttribute('file'),\n            });\n        }\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const letter = char[i];\n\n            data.char.push({\n                id: parseInt(letter.getAttribute('id'), 10),\n                page: parseInt(letter.getAttribute('page'), 10) || 0,\n                x: parseInt(letter.getAttribute('x'), 10),\n                y: parseInt(letter.getAttribute('y'), 10),\n                width: parseInt(letter.getAttribute('width'), 10),\n                height: parseInt(letter.getAttribute('height'), 10),\n                xoffset: parseInt(letter.getAttribute('xoffset'), 10),\n                yoffset: parseInt(letter.getAttribute('yoffset'), 10),\n                xadvance: parseInt(letter.getAttribute('xadvance'), 10),\n            });\n        }\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            data.kerning.push({\n                first: parseInt(kerning[i].getAttribute('first'), 10),\n                second: parseInt(kerning[i].getAttribute('second'), 10),\n                amount: parseInt(kerning[i].getAttribute('amount'), 10),\n            });\n        }\n\n        for (let i = 0; i < distanceField.length; i++)\n        {\n            data.distanceField.push({\n                fieldType: distanceField[i].getAttribute('fieldType'),\n                distanceRange: parseInt(distanceField[i].getAttribute('distanceRange'), 10),\n            });\n        }\n\n        return data;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}