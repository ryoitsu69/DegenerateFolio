{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = void 0;\nconst errors_1 = require(\"../errors\");\nconst en_1 = __importDefault(require(\"../locales/en\"));\nconst makeIssue = params => {\n  const {\n    data,\n    path,\n    errorMaps,\n    issueData\n  } = params;\n  const fullPath = [...path, ...(issueData.path || [])];\n  const fullIssue = {\n    ...issueData,\n    path: fullPath\n  };\n  if (issueData.message !== undefined) {\n    return {\n      ...issueData,\n      path: fullPath,\n      message: issueData.message\n    };\n  }\n  let errorMessage = \"\";\n  const maps = errorMaps.filter(m => !!m).slice().reverse();\n  for (const map of maps) {\n    errorMessage = map(fullIssue, {\n      data,\n      defaultError: errorMessage\n    }).message;\n  }\n  return {\n    ...issueData,\n    path: fullPath,\n    message: errorMessage\n  };\n};\nexports.makeIssue = makeIssue;\nexports.EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n  const overrideMap = (0, errors_1.getErrorMap)();\n  const issue = (0, exports.makeIssue)({\n    issueData: issueData,\n    data: ctx.data,\n    path: ctx.path,\n    errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, overrideMap, overrideMap === en_1.default ? undefined : en_1.default // then global default map\n    ].filter(x => !!x)\n  });\n  ctx.common.issues.push(issue);\n}\nexports.addIssueToContext = addIssueToContext;\nclass ParseStatus {\n  constructor() {\n    this.value = \"valid\";\n  }\n  dirty() {\n    if (this.value === \"valid\") this.value = \"dirty\";\n  }\n  abort() {\n    if (this.value !== \"aborted\") this.value = \"aborted\";\n  }\n  static mergeArray(status, results) {\n    const arrayValue = [];\n    for (const s of results) {\n      if (s.status === \"aborted\") return exports.INVALID;\n      if (s.status === \"dirty\") status.dirty();\n      arrayValue.push(s.value);\n    }\n    return {\n      status: status.value,\n      value: arrayValue\n    };\n  }\n  static async mergeObjectAsync(status, pairs) {\n    const syncPairs = [];\n    for (const pair of pairs) {\n      const key = await pair.key;\n      const value = await pair.value;\n      syncPairs.push({\n        key,\n        value\n      });\n    }\n    return ParseStatus.mergeObjectSync(status, syncPairs);\n  }\n  static mergeObjectSync(status, pairs) {\n    const finalObject = {};\n    for (const pair of pairs) {\n      const {\n        key,\n        value\n      } = pair;\n      if (key.status === \"aborted\") return exports.INVALID;\n      if (value.status === \"aborted\") return exports.INVALID;\n      if (key.status === \"dirty\") status.dirty();\n      if (value.status === \"dirty\") status.dirty();\n      if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n        finalObject[key.value] = value.value;\n      }\n    }\n    return {\n      status: status.value,\n      value: finalObject\n    };\n  }\n}\nexports.ParseStatus = ParseStatus;\nexports.INVALID = Object.freeze({\n  status: \"aborted\"\n});\nconst DIRTY = value => ({\n  status: \"dirty\",\n  value\n});\nexports.DIRTY = DIRTY;\nconst OK = value => ({\n  status: \"valid\",\n  value\n});\nexports.OK = OK;\nconst isAborted = x => x.status === \"aborted\";\nexports.isAborted = isAborted;\nconst isDirty = x => x.status === \"dirty\";\nexports.isDirty = isDirty;\nconst isValid = x => x.status === \"valid\";\nexports.isValid = isValid;\nconst isAsync = x => typeof Promise !== \"undefined\" && x instanceof Promise;\nexports.isAsync = isAsync;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","isAsync","isValid","isDirty","isAborted","OK","DIRTY","INVALID","ParseStatus","addIssueToContext","EMPTY_PATH","makeIssue","errors_1","require","en_1","params","data","path","errorMaps","issueData","fullPath","fullIssue","message","undefined","errorMessage","maps","filter","m","slice","reverse","map","defaultError","ctx","overrideMap","getErrorMap","issue","common","contextualErrorMap","schemaErrorMap","default","x","issues","push","constructor","dirty","abort","mergeArray","status","results","arrayValue","s","mergeObjectAsync","pairs","syncPairs","pair","key","mergeObjectSync","finalObject","alwaysSet","freeze","Promise"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/zod/lib/helpers/parseUtil.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = void 0;\nconst errors_1 = require(\"../errors\");\nconst en_1 = __importDefault(require(\"../locales/en\"));\nconst makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message,\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage,\n    };\n};\nexports.makeIssue = makeIssue;\nexports.EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const overrideMap = (0, errors_1.getErrorMap)();\n    const issue = (0, exports.makeIssue)({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap,\n            ctx.schemaErrorMap,\n            overrideMap,\n            overrideMap === en_1.default ? undefined : en_1.default, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nexports.addIssueToContext = addIssueToContext;\nclass ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return exports.INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return exports.INVALID;\n            if (value.status === \"aborted\")\n                return exports.INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" &&\n                (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nexports.ParseStatus = ParseStatus;\nexports.INVALID = Object.freeze({\n    status: \"aborted\",\n});\nconst DIRTY = (value) => ({ status: \"dirty\", value });\nexports.DIRTY = DIRTY;\nconst OK = (value) => ({ status: \"valid\", value });\nexports.OK = OK;\nconst isAborted = (x) => x.status === \"aborted\";\nexports.isAborted = isAborted;\nconst isDirty = (x) => x.status === \"dirty\";\nexports.isDirty = isDirty;\nconst isValid = (x) => x.status === \"valid\";\nexports.isValid = isValid;\nconst isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\nexports.isAsync = isAsync;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}