{"ast":null,"code":"import { Point, SHAPES } from \"@pixi/core\";\nimport { LINE_CAP, LINE_JOIN, curves } from \"../const.mjs\";\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight,\n    iy = y - ny * innerWeight,\n    ox = x + nx * outerWeight,\n    oy = y + ny * outerWeight;\n  let exx, eyy;\n  clockwise ? (exx = ny, eyy = -nx) : (exx = -ny, eyy = nx);\n  const eix = ix + exx,\n    eiy = iy + eyy,\n    eox = ox + exx,\n    eoy = oy + eyy;\n  return verts.push(eix, eiy, eox, eoy), 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx,\n    cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y),\n    angle1 = Math.atan2(ex - cx, ey - cy);\n  clockwise && angle0 < angle1 ? angle0 += Math.PI * 2 : !clockwise && angle0 > angle1 && (angle1 += Math.PI * 2);\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0,\n    absAngleDiff = Math.abs(angleDiff),\n    radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y),\n    segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1,\n    angleInc = angleDiff / segCount;\n  if (startAngle += angleInc, clockwise) {\n    verts.push(cx, cy, sx, sy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) verts.push(cx, cy, cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n    verts.push(cx, cy, ex, ey);\n  } else {\n    verts.push(sx, sy, cx, cy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius, cx, cy);\n    verts.push(ex, ey, cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildNonNativeLine(graphicsData, graphicsGeometry) {\n  const shape = graphicsData.shape;\n  let points = graphicsData.points || shape.points.slice();\n  const eps = graphicsGeometry.closePointEps;\n  if (points.length === 0) return;\n  const style = graphicsData.lineStyle,\n    firstPoint = new Point(points[0], points[1]),\n    lastPoint = new Point(points[points.length - 2], points[points.length - 1]),\n    closedShape = shape.type !== SHAPES.POLY || shape.closeStroke,\n    closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice(), closedPath && (points.pop(), points.pop(), lastPoint.set(points[points.length - 2], points[points.length - 1]));\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5,\n      midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY), points.push(midPointX, midPointY);\n  }\n  const verts = graphicsGeometry.points,\n    length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2,\n    width = style.width / 2,\n    widthSquared = width * width,\n    miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0],\n    y0 = points[1],\n    x1 = points[2],\n    y1 = points[3],\n    x2 = 0,\n    y2 = 0,\n    perpx = -(y0 - y1),\n    perpy = x0 - x1,\n    perp1x = 0,\n    perp1y = 0,\n    dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist, perpy /= dist, perpx *= width, perpy *= width;\n  const ratio = style.alignment,\n    innerWeight = (1 - ratio) * 2,\n    outerWeight = ratio * 2;\n  closedShape || (style.cap === LINE_CAP.ROUND ? indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, !0) + 2 : style.cap === LINE_CAP.SQUARE && (indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, !0, verts))), verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight);\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2], y0 = points[(i - 1) * 2 + 1], x1 = points[i * 2], y1 = points[i * 2 + 1], x2 = points[(i + 1) * 2], y2 = points[(i + 1) * 2 + 1], perpx = -(y0 - y1), perpy = x0 - x1, dist = Math.sqrt(perpx * perpx + perpy * perpy), perpx /= dist, perpy /= dist, perpx *= width, perpy *= width, perp1x = -(y1 - y2), perp1y = x1 - x2, dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y), perp1x /= dist, perp1y /= dist, perp1x *= width, perp1y *= width;\n    const dx0 = x1 - x0,\n      dy0 = y0 - y1,\n      dx1 = x1 - x2,\n      dy1 = y2 - y1,\n      dot = dx0 * dx1 + dy0 * dy1,\n      cross = dy0 * dx1 - dy1 * dx0,\n      clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight), dot >= 0 && (style.join === LINE_JOIN.ROUND ? indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, !1) + 4 : indexCount += 2, verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight, x1 + perp1x * innerWeight, y1 + perp1y * innerWeight));\n      continue;\n    }\n    const c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0),\n      c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2),\n      px = (dx0 * c2 - dx1 * c1) / cross,\n      py = (dy1 * c1 - dy0 * c2) / cross,\n      pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1),\n      imx = x1 + (px - x1) * innerWeight,\n      imy = y1 + (py - y1) * innerWeight,\n      omx = x1 - (px - x1) * outerWeight,\n      omy = y1 - (py - y1) * outerWeight,\n      smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1),\n      insideWeight = clockwise ? innerWeight : outerWeight,\n      smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared,\n      insideMiterOk = pdist <= smallerInsideDiagonalSq;\n    let join = style.join;\n    if (join === LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared && (join = LINE_JOIN.BEVEL), insideMiterOk) switch (join) {\n      case LINE_JOIN.MITER:\n        {\n          verts.push(imx, imy, omx, omy);\n          break;\n        }\n      case LINE_JOIN.BEVEL:\n        {\n          clockwise ? verts.push(imx, imy,\n          // inner miter point\n          x1 + perpx * outerWeight, y1 + perpy * outerWeight,\n          // first segment's outer vertex\n          imx, imy,\n          // inner miter point\n          x1 + perp1x * outerWeight, y1 + perp1y * outerWeight) : verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight,\n          // first segment's inner vertex\n          omx, omy,\n          // outer miter point\n          x1 - perp1x * innerWeight, y1 - perp1y * innerWeight,\n          // second segment's outer vertex\n          omx, omy), indexCount += 2;\n          break;\n        }\n      case LINE_JOIN.ROUND:\n        {\n          clockwise ? (verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight), indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, !0) + 4, verts.push(imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight)) : (verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy), indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, !1) + 4, verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy));\n          break;\n        }\n    } else {\n      switch (verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight,\n      // first segment's inner vertex\n      x1 + perpx * outerWeight, y1 + perpy * outerWeight), join) {\n        case LINE_JOIN.MITER:\n          {\n            clockwise ? verts.push(omx, omy,\n            // inner miter point\n            omx, omy) : verts.push(imx, imy,\n            // outer miter point\n            imx, imy), indexCount += 2;\n            break;\n          }\n        case LINE_JOIN.ROUND:\n          {\n            clockwise ? indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, !0) + 2 : indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, !1) + 2;\n            break;\n          }\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight,\n      // second segment's inner vertex\n      x1 + perp1x * outerWeight, y1 + perp1y * outerWeight), indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2], y0 = points[(length - 2) * 2 + 1], x1 = points[(length - 1) * 2], y1 = points[(length - 1) * 2 + 1], perpx = -(y0 - y1), perpy = x0 - x1, dist = Math.sqrt(perpx * perpx + perpy * perpy), perpx /= dist, perpy /= dist, perpx *= width, perpy *= width, verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight), closedShape || (style.cap === LINE_CAP.ROUND ? indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, !1) + 2 : style.cap === LINE_CAP.SQUARE && (indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, !1, verts)));\n  const indices = graphicsGeometry.indices,\n    eps2 = curves.epsilon * curves.epsilon;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) x0 = verts[i * 2], y0 = verts[i * 2 + 1], x1 = verts[(i + 1) * 2], y1 = verts[(i + 1) * 2 + 1], x2 = verts[(i + 2) * 2], y2 = verts[(i + 2) * 2 + 1], !(Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) && indices.push(i, i + 1, i + 2);\n}\nfunction buildNativeLine(graphicsData, graphicsGeometry) {\n  let i = 0;\n  const shape = graphicsData.shape,\n    points = graphicsData.points || shape.points,\n    closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n  if (points.length === 0) return;\n  const verts = graphicsGeometry.points,\n    indices = graphicsGeometry.indices,\n    length = points.length / 2,\n    startIndex = verts.length / 2;\n  let currentIndex = startIndex;\n  for (verts.push(points[0], points[1]), i = 1; i < length; i++) verts.push(points[i * 2], points[i * 2 + 1]), indices.push(currentIndex, currentIndex + 1), currentIndex++;\n  closedShape && indices.push(currentIndex, startIndex);\n}\nfunction buildLine(graphicsData, graphicsGeometry) {\n  graphicsData.lineStyle.native ? buildNativeLine(graphicsData, graphicsGeometry) : buildNonNativeLine(graphicsData, graphicsGeometry);\n}\nexport { buildLine };","map":{"version":3,"names":["square","x","y","nx","ny","innerWeight","outerWeight","clockwise","verts","ix","iy","ox","oy","exx","eyy","eix","eiy","eox","eoy","push","round","cx","cy","sx","sy","ex","ey","cx2p0x","cy2p0y","angle0","Math","atan2","angle1","PI","startAngle","angleDiff","absAngleDiff","abs","radius","sqrt","segCount","angleInc","i","angle","sin","cos","buildNonNativeLine","graphicsData","graphicsGeometry","shape","points","slice","eps","closePointEps","length","style","lineStyle","firstPoint","Point","lastPoint","closedShape","type","SHAPES","POLY","closeStroke","closedPath","pop","set","midPointX","midPointY","unshift","indexCount","indexStart","width","widthSquared","miterLimitSquared","miterLimit","x0","y0","x1","y1","x2","y2","perpx","perpy","perp1x","perp1y","dist","ratio","alignment","cap","LINE_CAP","ROUND","SQUARE","dx0","dy0","dx1","dy1","dot","cross","join","LINE_JOIN","c1","c2","px","py","pdist","imx","imy","omx","omy","smallerInsideSegmentSq","min","insideWeight","smallerInsideDiagonalSq","insideMiterOk","MITER","BEVEL","indices","eps2","curves","epsilon","buildNativeLine","startIndex","currentIndex","buildLine","native"],"sources":["/home/ryoitsu/node_modules/@pixi/graphics/src/utils/buildLine.ts"],"sourcesContent":["import { Point, SHAPES } from '@pixi/core';\nimport { curves, LINE_CAP, LINE_JOIN } from '../const';\n\nimport type { Polygon } from '@pixi/core';\nimport type { GraphicsData } from '../GraphicsData';\nimport type { GraphicsGeometry } from '../GraphicsGeometry';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(\n        eix, eiy,\n        eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array<number>} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: Array<number>,\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    /* if (absAngleDiff >= PI_LBOUND && absAngleDiff <= PI_UBOUND)\n    {\n        const r1x = cx - nxtPx;\n        const r1y = cy - nxtPy;\n\n        if (r1x === 0)\n        {\n            if (r1y > 0)\n            {\n                angleDiff = -angleDiff;\n            }\n        }\n        else if (r1x >= -curves.epsilon)\n        {\n            angleDiff = -angleDiff;\n        }\n    }*/\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(\n            cx, cy,\n            sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(\n                cx, cy,\n                cx + ((Math.sin(angle) * radius)), cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(\n            cx, cy,\n            ex, ey);\n    }\n    else\n    {\n        verts.push(\n            sx, sy,\n            cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(\n                cx + ((Math.sin(angle) * radius)), cy + ((Math.cos(angle) * radius)),\n                cx, cy);\n        }\n\n        verts.push(\n            ex, ey,\n            cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNonNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    const shape = graphicsData.shape as Polygon;\n    let points = graphicsData.points || shape.points.slice();\n    const eps = graphicsGeometry.closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    // commenting this out fixes #711 and #1620\n    // if (graphicsData.lineWidth%2)\n    // {\n    //     for (i = 0; i < points.length; i++)\n    //     {\n    //         points[i] += 0.5;\n    //     }\n    // }\n\n    const style = graphicsData.lineStyle;\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = graphicsGeometry.points;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpx = -(y0 - y1);\n    let perpy = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    const ratio = style.alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x0 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpx * innerWeight),\n                y0 - (perpy * innerWeight),\n                x0 + (perpx * outerWeight),\n                y0 + (perpy * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpx * innerWeight), y0 - (perpy * innerWeight),\n        x0 + (perpx * outerWeight), y0 + (perpy * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpx = -(y0 - y1);\n        perpy = x0 - x1;\n\n        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === LINE_JOIN.ROUND)\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight), y1 - (perp1y * outerWeight),\n                    x1 + (perp1x * innerWeight), y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pdist is the distance between miter point and p1. */\n        const c1 = ((-perpx + x0) * (-perpy + y1)) - ((-perpx + x1) * (-perpy + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pdist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pdist <= smallerInsideDiagonalSq;\n\n        let join = style.join;\n\n        if (join === LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared)\n        {\n            join = LINE_JOIN.BEVEL;\n        }\n\n        if (insideMiterOk)\n        {\n            switch (join)\n            {\n                case LINE_JOIN.MITER:\n                {\n                    verts.push(\n                        imx, imy,\n                        omx, omy);\n                    break;\n                }\n                case LINE_JOIN.BEVEL:\n                {\n                    if (clockwise) /* rotating at inner angle */\n                    {\n                        verts.push(\n                            imx, imy, // inner miter point\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight), // first segment's outer vertex\n                            imx, imy, // inner miter point\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                    }\n                    else /* rotating at outer angle */\n                    {\n                        verts.push(\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight), // first segment's inner vertex\n                            omx, omy, // outer miter point\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight), // second segment's outer vertex\n                            omx, omy); // outer miter point\n                    }\n\n                    indexCount += 2;\n                    break;\n                }\n                case LINE_JOIN.ROUND:\n                {\n                    if (clockwise) /* arc is outside */\n                    {\n                        verts.push(\n                            imx, imy,\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n                        indexCount += round(\n                            x1, y1,\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                            verts, true\n                        ) + 4;\n\n                        verts.push(\n                            imx, imy,\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                    }\n                    else /* arc is inside */\n                    {\n                        verts.push(\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                            omx, omy);\n\n                        indexCount += round(\n                            x1, y1,\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                            verts, false\n                        ) + 4;\n\n                        verts.push(\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                            omx, omy);\n                    }\n                    break;\n                }\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(\n                x1 - (perpx * innerWeight), y1 - (perpy * innerWeight), // first segment's inner vertex\n                x1 + (perpx * outerWeight), y1 + (perpy * outerWeight)); // first segment's outer vertex\n            switch (join)\n            {\n                case LINE_JOIN.MITER:\n                {\n                    if (clockwise)\n                    {\n                        verts.push(\n                            omx, omy, // inner miter point\n                            omx, omy); // inner miter point\n                    }\n                    else\n                    {\n                        verts.push(\n                            imx, imy, // outer miter point\n                            imx, imy); // outer miter point\n                    }\n                    indexCount += 2;\n                    break;\n                }\n                case LINE_JOIN.ROUND:\n                {\n                    if (clockwise) /* arc is outside */\n                    {\n                        indexCount += round(\n                            x1, y1,\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                            verts, true\n                        ) + 2;\n                    }\n                    else /* arc is inside */\n                    {\n                        indexCount += round(\n                            x1, y1,\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                            verts, false\n                        ) + 2;\n                    }\n                    break;\n                }\n            }\n            verts.push(\n                x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight), // second segment's inner vertex\n                x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n\n    dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(\n        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n        x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x1 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpx * innerWeight),\n                y1 - (perpy * innerWeight),\n                x1 + (perpx * outerWeight),\n                y1 + (perpy * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    const indices = graphicsGeometry.indices;\n    const eps2 = curves.epsilon * curves.epsilon;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    let i = 0;\n\n    const shape = graphicsData.shape as Polygon;\n    const points = graphicsData.points || shape.points;\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n\n    if (points.length === 0) return;\n\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    const length = points.length / 2;\n\n    const startIndex = verts.length / 2;\n    let currentIndex = startIndex;\n\n    verts.push(points[0], points[1]);\n\n    for (i = 1; i < length; i++)\n    {\n        verts.push(points[i * 2], points[(i * 2) + 1]);\n        indices.push(currentIndex, currentIndex + 1);\n\n        currentIndex++;\n    }\n\n    if (closedShape)\n    {\n        indices.push(currentIndex, startIndex);\n    }\n}\n\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nexport function buildLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    if (graphicsData.lineStyle.native)\n    {\n        buildNativeLine(graphicsData, graphicsGeometry);\n    }\n    else\n    {\n        buildNonNativeLine(graphicsData, graphicsGeometry);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}