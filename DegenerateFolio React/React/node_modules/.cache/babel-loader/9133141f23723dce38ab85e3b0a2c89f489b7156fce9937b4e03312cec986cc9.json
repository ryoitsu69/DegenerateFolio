{"ast":null,"code":"import { Point, Polygon, State, settings, DRAW_MODES } from \"@pixi/core\";\nimport { Container } from \"@pixi/display\";\nimport { MeshBatchUvs } from \"./MeshBatchUvs.mjs\";\nconst tempPoint = new Point(),\n  tempPolygon = new Polygon(),\n  _Mesh = class _Mesh2 extends Container {\n    /**\n     * @param geometry - The geometry the mesh will use.\n     * @param {PIXI.MeshMaterial} shader - The shader the mesh will use.\n     * @param state - The state that the WebGL context is required to be in to render the mesh\n     *        if no state is provided, uses {@link PIXI.State.for2d} to create a 2D state for PixiJS.\n     * @param drawMode - The drawMode, can be any of the {@link PIXI.DRAW_MODES} constants.\n     */\n    constructor(geometry, shader, state, drawMode = DRAW_MODES.TRIANGLES) {\n      super(), this.geometry = geometry, this.shader = shader, this.state = state || State.for2d(), this.drawMode = drawMode, this.start = 0, this.size = 0, this.uvs = null, this.indices = null, this.vertexData = new Float32Array(1), this.vertexDirty = -1, this._transformID = -1, this._roundPixels = settings.ROUND_PIXELS, this.batchUvs = null;\n    }\n    /**\n     * Includes vertex positions, face indices, normals, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh objects.\n     */\n    get geometry() {\n      return this._geometry;\n    }\n    set geometry(value) {\n      this._geometry !== value && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = value, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);\n    }\n    /**\n     * To change mesh uv's, change its uvBuffer data and increment its _updateID.\n     * @readonly\n     */\n    get uvBuffer() {\n      return this.geometry.buffers[1];\n    }\n    /**\n     * To change mesh vertices, change its uvBuffer data and increment its _updateID.\n     * Incrementing _updateID is optional because most of Mesh objects do it anyway.\n     * @readonly\n     */\n    get verticesBuffer() {\n      return this.geometry.buffers[0];\n    }\n    /** Alias for {@link PIXI.Mesh#shader}. */\n    set material(value) {\n      this.shader = value;\n    }\n    get material() {\n      return this.shader;\n    }\n    /**\n     * The blend mode to be applied to the Mesh. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     * @default PIXI.BLEND_MODES.NORMAL;\n     */\n    set blendMode(value) {\n      this.state.blendMode = value;\n    }\n    get blendMode() {\n      return this.state.blendMode;\n    }\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n     * @default false\n     */\n    set roundPixels(value) {\n      this._roundPixels !== value && (this._transformID = -1), this._roundPixels = value;\n    }\n    get roundPixels() {\n      return this._roundPixels;\n    }\n    /**\n     * The multiply tint applied to the Mesh. This is a hex value. A value of\n     * `0xFFFFFF` will remove any tint effect.\n     *\n     * Null for non-MeshMaterial shaders\n     * @default 0xFFFFFF\n     */\n    get tint() {\n      return \"tint\" in this.shader ? this.shader.tint : null;\n    }\n    set tint(value) {\n      this.shader.tint = value;\n    }\n    /**\n     * The tint color as a RGB integer\n     * @ignore\n     */\n    get tintValue() {\n      return this.shader.tintValue;\n    }\n    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n    get texture() {\n      return \"texture\" in this.shader ? this.shader.texture : null;\n    }\n    set texture(value) {\n      this.shader.texture = value;\n    }\n    /**\n     * Standard renderer draw.\n     * @param renderer - Instance to renderer.\n     */\n    _render(renderer) {\n      const vertices = this.geometry.buffers[0].data;\n      this.shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < _Mesh2.BATCHABLE_SIZE * 2 ? this._renderToBatch(renderer) : this._renderDefault(renderer);\n    }\n    /**\n     * Standard non-batching way of rendering.\n     * @param renderer - Instance to renderer.\n     */\n    _renderDefault(renderer) {\n      const shader = this.shader;\n      shader.alpha = this.worldAlpha, shader.update && shader.update(), renderer.batch.flush(), shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), renderer.shader.bind(shader), renderer.state.set(this.state), renderer.geometry.bind(this.geometry, shader), renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n    }\n    /**\n     * Rendering by using the Batch system.\n     * @param renderer - Instance to renderer.\n     */\n    _renderToBatch(renderer) {\n      const geometry = this.geometry,\n        shader = this.shader;\n      shader.uvMatrix && (shader.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = geometry.indexBuffer.data, this._tintRGB = shader._tintRGB, this._texture = shader.texture;\n      const pluginName = this.material.pluginName;\n      renderer.batch.setObjectRenderer(renderer.plugins[pluginName]), renderer.plugins[pluginName].render(this);\n    }\n    /** Updates vertexData field based on transform and vertices. */\n    calculateVertices() {\n      const verticesBuffer = this.geometry.buffers[0],\n        vertices = verticesBuffer.data,\n        vertexDirtyId = verticesBuffer._updateID;\n      if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) return;\n      this._transformID = this.transform._worldID, this.vertexData.length !== vertices.length && (this.vertexData = new Float32Array(vertices.length));\n      const wt = this.transform.worldTransform,\n        a = wt.a,\n        b = wt.b,\n        c = wt.c,\n        d = wt.d,\n        tx = wt.tx,\n        ty = wt.ty,\n        vertexData = this.vertexData;\n      for (let i = 0; i < vertexData.length / 2; i++) {\n        const x = vertices[i * 2],\n          y = vertices[i * 2 + 1];\n        vertexData[i * 2] = a * x + c * y + tx, vertexData[i * 2 + 1] = b * x + d * y + ty;\n      }\n      if (this._roundPixels) {\n        const resolution = settings.RESOLUTION;\n        for (let i = 0; i < vertexData.length; ++i) vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;\n      }\n      this.vertexDirty = vertexDirtyId;\n    }\n    /** Updates uv field based on from geometry uv's or batchUvs. */\n    calculateUvs() {\n      const geomUvs = this.geometry.buffers[1],\n        shader = this.shader;\n      shader.uvMatrix.isSimple ? this.uvs = geomUvs.data : (this.batchUvs || (this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);\n    }\n    /**\n     * Updates the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n     * there must be a aVertexPosition attribute present in the geometry for bounds to be calculated correctly.\n     */\n    _calculateBounds() {\n      this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n    }\n    /**\n     * Tests if a point is inside this mesh. Works only for PIXI.DRAW_MODES.TRIANGLES.\n     * @param point - The point to test.\n     * @returns - The result of the test.\n     */\n    containsPoint(point) {\n      if (!this.getBounds().contains(point.x, point.y)) return !1;\n      this.worldTransform.applyInverse(point, tempPoint);\n      const vertices = this.geometry.getBuffer(\"aVertexPosition\").data,\n        points = tempPolygon.points,\n        indices = this.geometry.getIndex().data,\n        len = indices.length,\n        step = this.drawMode === 4 ? 3 : 1;\n      for (let i = 0; i + 2 < len; i += step) {\n        const ind0 = indices[i] * 2,\n          ind1 = indices[i + 1] * 2,\n          ind2 = indices[i + 2] * 2;\n        if (points[0] = vertices[ind0], points[1] = vertices[ind0 + 1], points[2] = vertices[ind1], points[3] = vertices[ind1 + 1], points[4] = vertices[ind2], points[5] = vertices[ind2 + 1], tempPolygon.contains(tempPoint.x, tempPoint.y)) return !0;\n      }\n      return !1;\n    }\n    destroy(options) {\n      super.destroy(options), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;\n    }\n  };\n_Mesh.BATCHABLE_SIZE = 100;\nlet Mesh = _Mesh;\nexport { Mesh };","map":{"version":3,"names":["tempPoint","Point","tempPolygon","Polygon","_Mesh","_Mesh2","Container","constructor","geometry","shader","state","drawMode","DRAW_MODES","TRIANGLES","State","for2d","start","size","uvs","indices","vertexData","Float32Array","vertexDirty","_transformID","_roundPixels","settings","ROUND_PIXELS","batchUvs","_geometry","value","refCount","dispose","uvBuffer","buffers","verticesBuffer","material","blendMode","roundPixels","tint","tintValue","texture","_render","renderer","vertices","data","batchable","length","BATCHABLE_SIZE","_renderToBatch","_renderDefault","alpha","worldAlpha","update","batch","flush","uniforms","translationMatrix","transform","worldTransform","toArray","bind","set","draw","instanceCount","uvMatrix","calculateUvs","calculateVertices","indexBuffer","_tintRGB","_texture","pluginName","setObjectRenderer","plugins","render","vertexDirtyId","_updateID","_worldID","wt","a","b","c","d","tx","ty","i","x","y","resolution","RESOLUTION","Math","round","geomUvs","isSimple","MeshBatchUvs","_calculateBounds","_bounds","addVertexData","containsPoint","point","getBounds","contains","applyInverse","getBuffer","points","getIndex","len","step","ind0","ind1","ind2","destroy","options","_cachedTexture","Mesh"],"sources":["/home/ryoitsu/node_modules/@pixi/mesh/src/Mesh.ts"],"sourcesContent":["import { DRAW_MODES, Point, Polygon, settings, State } from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { MeshBatchUvs } from './MeshBatchUvs';\n\nimport type { BLEND_MODES, Buffer, ColorSource, Geometry, IPointData, Renderer, Shader, Texture } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { MeshMaterial } from './MeshMaterial';\n\nconst tempPoint = new Point();\nconst tempPolygon = new Polygon();\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Mesh extends GlobalMixins.Mesh {}\n\n/**\n * Base mesh class.\n *\n * This class empowers you to have maximum flexibility to render any kind of WebGL visuals you can think of.\n * This class assumes a certain level of WebGL knowledge.\n * If you know a bit this should abstract enough away to make your life easier!\n *\n * Pretty much ALL WebGL can be broken down into the following:\n * - Geometry - The structure and data for the mesh. This can include anything from positions, uvs, normals, colors etc..\n * - Shader - This is the shader that PixiJS will render the geometry with (attributes in the shader must match the geometry)\n * - State - This is the state of WebGL required to render the mesh.\n *\n * Through a combination of the above elements you can render anything you want, 2D or 3D!\n * @memberof PIXI\n */\nexport class Mesh<T extends Shader = MeshMaterial> extends Container\n{\n    /**\n     * Used by the @pixi/canvas-mesh package to draw meshes using canvas.\n     * Added here because we cannot mixin a static property to Mesh type.\n     * @ignore\n     */\n    public static defaultCanvasPadding: number;\n\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Mesh objects.\n     * @type {PIXI.Shader|PIXI.MeshMaterial}\n     */\n    public shader: T;\n\n    /**\n     * Represents the WebGL state the Mesh required to render, excludes shader and geometry. E.g.,\n     * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n     */\n    public state: State;\n\n    /** The way the Mesh should be drawn, can be any of the {@link PIXI.DRAW_MODES} constants. */\n    public drawMode: DRAW_MODES;\n\n    /**\n     * Typically the index of the IndexBuffer where to start drawing.\n     * @default 0\n     */\n    public start: number;\n\n    /**\n     * How much of the geometry to draw, by default `0` renders everything.\n     * @default 0\n     */\n    public size: number;\n\n    private _geometry: Geometry;\n\n    /** This is the caching layer used by the batcher. */\n    private vertexData: Float32Array;\n\n    /** If geometry is changed used to decide to re-transform the vertexData. */\n    private vertexDirty: number;\n    private _transformID: number;\n\n    /** Internal roundPixels field. */\n    private _roundPixels: boolean;\n\n    /** Batched UV's are cached for atlas textures. */\n    private batchUvs: MeshBatchUvs;\n\n    // Internal-only properties\n    /**\n     * These are used as easy access for batching.\n     * @private\n     */\n    uvs: Float32Array;\n\n    /**\n     * These are used as easy access for batching.\n     * @private\n     */\n    indices: Uint16Array;\n    _tintRGB: number;\n    _texture: Texture;\n\n    /**\n     * @param geometry - The geometry the mesh will use.\n     * @param {PIXI.MeshMaterial} shader - The shader the mesh will use.\n     * @param state - The state that the WebGL context is required to be in to render the mesh\n     *        if no state is provided, uses {@link PIXI.State.for2d} to create a 2D state for PixiJS.\n     * @param drawMode - The drawMode, can be any of the {@link PIXI.DRAW_MODES} constants.\n     */\n    constructor(geometry: Geometry, shader: T, state?: State, drawMode: DRAW_MODES = DRAW_MODES.TRIANGLES)\n    {\n        super();\n\n        this.geometry = geometry;\n        this.shader = shader;\n        this.state = state || State.for2d();\n        this.drawMode = drawMode;\n        this.start = 0;\n        this.size = 0;\n\n        this.uvs = null;\n        this.indices = null;\n        this.vertexData = new Float32Array(1);\n        this.vertexDirty = -1;\n\n        this._transformID = -1;\n        this._roundPixels = settings.ROUND_PIXELS;\n        this.batchUvs = null;\n    }\n\n    /**\n     * Includes vertex positions, face indices, normals, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh objects.\n     */\n    get geometry(): Geometry\n    {\n        return this._geometry;\n    }\n\n    set geometry(value: Geometry)\n    {\n        if (this._geometry === value)\n        {\n            return;\n        }\n\n        if (this._geometry)\n        {\n            this._geometry.refCount--;\n\n            if (this._geometry.refCount === 0)\n            {\n                this._geometry.dispose();\n            }\n        }\n\n        this._geometry = value;\n\n        if (this._geometry)\n        {\n            this._geometry.refCount++;\n        }\n\n        this.vertexDirty = -1;\n    }\n\n    /**\n     * To change mesh uv's, change its uvBuffer data and increment its _updateID.\n     * @readonly\n     */\n    get uvBuffer(): Buffer\n    {\n        return this.geometry.buffers[1];\n    }\n\n    /**\n     * To change mesh vertices, change its uvBuffer data and increment its _updateID.\n     * Incrementing _updateID is optional because most of Mesh objects do it anyway.\n     * @readonly\n     */\n    get verticesBuffer(): Buffer\n    {\n        return this.geometry.buffers[0];\n    }\n\n    /** Alias for {@link PIXI.Mesh#shader}. */\n    set material(value: T)\n    {\n        this.shader = value;\n    }\n\n    get material(): T\n    {\n        return this.shader;\n    }\n\n    /**\n     * The blend mode to be applied to the Mesh. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     * @default PIXI.BLEND_MODES.NORMAL;\n     */\n    set blendMode(value: BLEND_MODES)\n    {\n        this.state.blendMode = value;\n    }\n\n    get blendMode(): BLEND_MODES\n    {\n        return this.state.blendMode;\n    }\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n     * @default false\n     */\n    set roundPixels(value: boolean)\n    {\n        if (this._roundPixels !== value)\n        {\n            this._transformID = -1;\n        }\n        this._roundPixels = value;\n    }\n\n    get roundPixels(): boolean\n    {\n        return this._roundPixels;\n    }\n\n    /**\n     * The multiply tint applied to the Mesh. This is a hex value. A value of\n     * `0xFFFFFF` will remove any tint effect.\n     *\n     * Null for non-MeshMaterial shaders\n     * @default 0xFFFFFF\n     */\n    get tint(): ColorSource\n    {\n        return 'tint' in this.shader ? (this.shader as unknown as MeshMaterial).tint : null;\n    }\n\n    set tint(value: ColorSource)\n    {\n        (this.shader as unknown as MeshMaterial).tint = value;\n    }\n\n    /**\n     * The tint color as a RGB integer\n     * @ignore\n     */\n    get tintValue(): number\n    {\n        return (this.shader as unknown as MeshMaterial).tintValue;\n    }\n\n    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n    get texture(): Texture\n    {\n        return 'texture' in this.shader ? (this.shader as unknown as MeshMaterial).texture : null;\n    }\n\n    set texture(value: Texture)\n    {\n        (this.shader as unknown as MeshMaterial).texture = value;\n    }\n\n    /**\n     * Standard renderer draw.\n     * @param renderer - Instance to renderer.\n     */\n    protected _render(renderer: Renderer): void\n    {\n        // set properties for batching..\n        // TODO could use a different way to grab verts?\n        const vertices = this.geometry.buffers[0].data;\n        const shader = this.shader as unknown as MeshMaterial;\n\n        // TODO benchmark check for attribute size..\n        if (\n            shader.batchable\n            && this.drawMode === DRAW_MODES.TRIANGLES\n            && vertices.length < Mesh.BATCHABLE_SIZE * 2\n        )\n        {\n            this._renderToBatch(renderer);\n        }\n        else\n        {\n            this._renderDefault(renderer);\n        }\n    }\n\n    /**\n     * Standard non-batching way of rendering.\n     * @param renderer - Instance to renderer.\n     */\n    protected _renderDefault(renderer: Renderer): void\n    {\n        const shader = this.shader as unknown as MeshMaterial;\n\n        shader.alpha = this.worldAlpha;\n        if (shader.update)\n        {\n            shader.update();\n        }\n\n        renderer.batch.flush();\n\n        // bind and sync uniforms..\n        shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);\n        renderer.shader.bind(shader);\n\n        // set state..\n        renderer.state.set(this.state);\n\n        // bind the geometry...\n        renderer.geometry.bind(this.geometry, shader);\n\n        // then render it\n        renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n    }\n\n    /**\n     * Rendering by using the Batch system.\n     * @param renderer - Instance to renderer.\n     */\n    protected _renderToBatch(renderer: Renderer): void\n    {\n        const geometry = this.geometry;\n        const shader = this.shader as unknown as MeshMaterial;\n\n        if (shader.uvMatrix)\n        {\n            shader.uvMatrix.update();\n            this.calculateUvs();\n        }\n\n        // set properties for batching..\n        this.calculateVertices();\n        this.indices = geometry.indexBuffer.data as Uint16Array;\n        this._tintRGB = shader._tintRGB;\n        this._texture = shader.texture;\n\n        const pluginName = (this.material as unknown as MeshMaterial).pluginName;\n\n        renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);\n        renderer.plugins[pluginName].render(this);\n    }\n\n    /** Updates vertexData field based on transform and vertices. */\n    public calculateVertices(): void\n    {\n        const geometry = this.geometry;\n        const verticesBuffer = geometry.buffers[0];\n        const vertices = verticesBuffer.data;\n        const vertexDirtyId = verticesBuffer._updateID;\n\n        if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID)\n        {\n            return;\n        }\n\n        this._transformID = this.transform._worldID;\n\n        if (this.vertexData.length !== vertices.length)\n        {\n            this.vertexData = new Float32Array(vertices.length);\n        }\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const vertexData = this.vertexData;\n\n        for (let i = 0; i < vertexData.length / 2; i++)\n        {\n            const x = vertices[(i * 2)];\n            const y = vertices[(i * 2) + 1];\n\n            vertexData[(i * 2)] = (a * x) + (c * y) + tx;\n            vertexData[(i * 2) + 1] = (b * x) + (d * y) + ty;\n        }\n\n        if (this._roundPixels)\n        {\n            const resolution = settings.RESOLUTION;\n\n            for (let i = 0; i < vertexData.length; ++i)\n            {\n                vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;\n            }\n        }\n\n        this.vertexDirty = vertexDirtyId;\n    }\n\n    /** Updates uv field based on from geometry uv's or batchUvs. */\n    public calculateUvs(): void\n    {\n        const geomUvs = this.geometry.buffers[1];\n        const shader = this.shader as unknown as MeshMaterial;\n\n        if (!shader.uvMatrix.isSimple)\n        {\n            if (!this.batchUvs)\n            {\n                this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);\n            }\n            this.batchUvs.update();\n            this.uvs = this.batchUvs.data;\n        }\n        else\n        {\n            this.uvs = geomUvs.data as Float32Array;\n        }\n    }\n\n    /**\n     * Updates the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n     * there must be a aVertexPosition attribute present in the geometry for bounds to be calculated correctly.\n     */\n    protected _calculateBounds(): void\n    {\n        this.calculateVertices();\n\n        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n    }\n\n    /**\n     * Tests if a point is inside this mesh. Works only for PIXI.DRAW_MODES.TRIANGLES.\n     * @param point - The point to test.\n     * @returns - The result of the test.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        if (!this.getBounds().contains(point.x, point.y))\n        {\n            return false;\n        }\n\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const vertices = this.geometry.getBuffer('aVertexPosition').data;\n\n        const points = tempPolygon.points;\n        const indices = this.geometry.getIndex().data;\n        const len = indices.length;\n        const step = this.drawMode === 4 ? 3 : 1;\n\n        for (let i = 0; i + 2 < len; i += step)\n        {\n            const ind0 = indices[i] * 2;\n            const ind1 = indices[i + 1] * 2;\n            const ind2 = indices[i + 2] * 2;\n\n            points[0] = vertices[ind0];\n            points[1] = vertices[ind0 + 1];\n            points[2] = vertices[ind1];\n            points[3] = vertices[ind1 + 1];\n            points[4] = vertices[ind2];\n            points[5] = vertices[ind2 + 1];\n\n            if (tempPolygon.contains(tempPoint.x, tempPoint.y))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        super.destroy(options);\n\n        if (this._cachedTexture)\n        {\n            this._cachedTexture.destroy();\n            this._cachedTexture = null;\n        }\n\n        this.geometry = null;\n        this.shader = null;\n        this.state = null;\n        this.uvs = null;\n        this.indices = null;\n        this.vertexData = null;\n    }\n\n    /** The maximum number of vertices to consider batchable. Generally, the complexity of the geometry. */\n    public static BATCHABLE_SIZE = 100;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}