{"ast":null,"code":"import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { getAttributeInfoFromFormat } from '../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\nimport { ensureAttributes } from '../shader/program/ensureAttributes.mjs';\nimport { getGlTypeFromFormat } from './utils/getGlTypeFromFormat.mjs';\n\"use strict\";\nconst topologyToGlMap = {\n  \"point-list\": 0,\n  \"line-list\": 1,\n  \"line-strip\": 3,\n  \"triangle-list\": 4,\n  \"triangle-strip\": 5\n};\nclass GlGeometrySystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._geometryVaoHash = /* @__PURE__ */Object.create(null);\n    this._renderer = renderer;\n    this._activeGeometry = null;\n    this._activeVao = null;\n    this.hasVao = true;\n    this.hasInstance = true;\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    const gl = this.gl = this._renderer.gl;\n    if (!this._renderer.context.supports.vertexArrayObject) {\n      throw new Error(\"[PixiJS] Vertex Array Objects are not supported on this device\");\n    }\n    const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;\n    if (nativeVaoExtension) {\n      gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();\n      gl.bindVertexArray = vao => nativeVaoExtension.bindVertexArrayOES(vao);\n      gl.deleteVertexArray = vao => nativeVaoExtension.deleteVertexArrayOES(vao);\n    }\n    const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;\n    if (nativeInstancedExtension) {\n      gl.drawArraysInstanced = (a, b, c, d) => {\n        nativeInstancedExtension.drawArraysInstancedANGLE(a, b, c, d);\n      };\n      gl.drawElementsInstanced = (a, b, c, d, e) => {\n        nativeInstancedExtension.drawElementsInstancedANGLE(a, b, c, d, e);\n      };\n      gl.vertexAttribDivisor = (a, b) => nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);\n    }\n    this._activeGeometry = null;\n    this._activeVao = null;\n    this._geometryVaoHash = /* @__PURE__ */Object.create(null);\n  }\n  /**\n   * Binds geometry so that is can be drawn. Creating a Vao if required\n   * @param geometry - Instance of geometry to bind.\n   * @param program - Instance of program to use vao for.\n   */\n  bind(geometry, program) {\n    const gl = this.gl;\n    this._activeGeometry = geometry;\n    const vao = this.getVao(geometry, program);\n    if (this._activeVao !== vao) {\n      this._activeVao = vao;\n      gl.bindVertexArray(vao);\n    }\n    this.updateBuffers();\n  }\n  /** Reset and unbind any active VAO and geometry. */\n  reset() {\n    this.unbind();\n  }\n  /** Update buffers of the currently bound geometry. */\n  updateBuffers() {\n    const geometry = this._activeGeometry;\n    const bufferSystem = this._renderer.buffer;\n    for (let i = 0; i < geometry.buffers.length; i++) {\n      const buffer = geometry.buffers[i];\n      bufferSystem.updateBuffer(buffer);\n    }\n  }\n  /**\n   * Check compatibility between a geometry and a program\n   * @param geometry - Geometry instance.\n   * @param program - Program instance.\n   */\n  checkCompatibility(geometry, program) {\n    const geometryAttributes = geometry.attributes;\n    const shaderAttributes = program._attributeData;\n    for (const j in shaderAttributes) {\n      if (!geometryAttributes[j]) {\n        throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n      }\n    }\n  }\n  /**\n   * Takes a geometry and program and generates a unique signature for them.\n   * @param geometry - To get signature from.\n   * @param program - To test geometry against.\n   * @returns - Unique signature of the geometry and program\n   */\n  getSignature(geometry, program) {\n    const attribs = geometry.attributes;\n    const shaderAttributes = program._attributeData;\n    const strings = [\"g\", geometry.uid];\n    for (const i in attribs) {\n      if (shaderAttributes[i]) {\n        strings.push(i, shaderAttributes[i].location);\n      }\n    }\n    return strings.join(\"-\");\n  }\n  getVao(geometry, program) {\n    return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);\n  }\n  /**\n   * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n   * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n   * attribute locations.\n   * @param geometry - Instance of geometry to to generate Vao for.\n   * @param program\n   * @param _incRefCount - Increment refCount of all geometry buffers.\n   */\n  initGeometryVao(geometry, program, _incRefCount = true) {\n    const gl = this._renderer.gl;\n    const bufferSystem = this._renderer.buffer;\n    this._renderer.shader._getProgramData(program);\n    this.checkCompatibility(geometry, program);\n    const signature = this.getSignature(geometry, program);\n    if (!this._geometryVaoHash[geometry.uid]) {\n      this._geometryVaoHash[geometry.uid] = /* @__PURE__ */Object.create(null);\n      geometry.on(\"destroy\", this.onGeometryDestroy, this);\n    }\n    const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n    let vao = vaoObjectHash[signature];\n    if (vao) {\n      vaoObjectHash[program._key] = vao;\n      return vao;\n    }\n    ensureAttributes(geometry, program._attributeData);\n    const buffers = geometry.buffers;\n    vao = gl.createVertexArray();\n    gl.bindVertexArray(vao);\n    for (let i = 0; i < buffers.length; i++) {\n      const buffer = buffers[i];\n      bufferSystem.bind(buffer);\n    }\n    this.activateVao(geometry, program);\n    vaoObjectHash[program._key] = vao;\n    vaoObjectHash[signature] = vao;\n    gl.bindVertexArray(null);\n    return vao;\n  }\n  /**\n   * Disposes geometry.\n   * @param geometry - Geometry with buffers. Only VAO will be disposed\n   * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n   */\n  onGeometryDestroy(geometry, contextLost) {\n    const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n    const gl = this.gl;\n    if (vaoObjectHash) {\n      if (contextLost) {\n        for (const i in vaoObjectHash) {\n          if (this._activeVao !== vaoObjectHash[i]) {\n            this.unbind();\n          }\n          gl.deleteVertexArray(vaoObjectHash[i]);\n        }\n      }\n      this._geometryVaoHash[geometry.uid] = null;\n    }\n  }\n  /**\n   * Dispose all WebGL resources of all managed geometries.\n   * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n   */\n  destroyAll(contextLost = false) {\n    const gl = this.gl;\n    for (const i in this._geometryVaoHash) {\n      if (contextLost) {\n        for (const j in this._geometryVaoHash[i]) {\n          const vaoObjectHash = this._geometryVaoHash[i];\n          if (this._activeVao !== vaoObjectHash) {\n            this.unbind();\n          }\n          gl.deleteVertexArray(vaoObjectHash[j]);\n        }\n      }\n      this._geometryVaoHash[i] = null;\n    }\n  }\n  /**\n   * Activate vertex array object.\n   * @param geometry - Geometry instance.\n   * @param program - Shader program instance.\n   */\n  activateVao(geometry, program) {\n    const gl = this._renderer.gl;\n    const bufferSystem = this._renderer.buffer;\n    const attributes = geometry.attributes;\n    if (geometry.indexBuffer) {\n      bufferSystem.bind(geometry.indexBuffer);\n    }\n    let lastBuffer = null;\n    for (const j in attributes) {\n      const attribute = attributes[j];\n      const buffer = attribute.buffer;\n      const glBuffer = bufferSystem.getGlBuffer(buffer);\n      const programAttrib = program._attributeData[j];\n      if (programAttrib) {\n        if (lastBuffer !== glBuffer) {\n          bufferSystem.bind(buffer);\n          lastBuffer = glBuffer;\n        }\n        const location = attribute.location;\n        gl.enableVertexAttribArray(location);\n        const attributeInfo = getAttributeInfoFromFormat(attribute.format);\n        const type = getGlTypeFromFormat(attribute.format);\n        if (programAttrib.format?.substring(1, 4) === \"int\") {\n          gl.vertexAttribIPointer(location, attributeInfo.size, type, attribute.stride, attribute.offset);\n        } else {\n          gl.vertexAttribPointer(location, attributeInfo.size, type, attributeInfo.normalised, attribute.stride, attribute.offset);\n        }\n        if (attribute.instance) {\n          if (this.hasInstance) {\n            gl.vertexAttribDivisor(location, 1);\n          } else {\n            throw new Error(\"geometry error, GPU Instancing is not supported on this device\");\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Draws the currently bound geometry.\n   * @param topology - The type primitive to render.\n   * @param size - The number of elements to be rendered. If not specified, all vertices after the\n   *  starting vertex will be drawn.\n   * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n   *  drawing will start from the first vertex.\n   * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n   *  all instances will be drawn.\n   */\n  draw(topology, size, start, instanceCount) {\n    const {\n      gl\n    } = this._renderer;\n    const geometry = this._activeGeometry;\n    const glTopology = topologyToGlMap[geometry.topology || topology];\n    instanceCount || (instanceCount = geometry.instanceCount);\n    if (geometry.indexBuffer) {\n      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n      if (instanceCount > 1) {\n        gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);\n      } else {\n        gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n      }\n    } else if (instanceCount > 1) {\n      gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);\n    } else {\n      gl.drawArrays(glTopology, start || 0, size || geometry.getSize());\n    }\n    return this;\n  }\n  /** Unbind/reset everything. */\n  unbind() {\n    this.gl.bindVertexArray(null);\n    this._activeVao = null;\n    this._activeGeometry = null;\n  }\n  destroy() {\n    this._renderer = null;\n    this.gl = null;\n    this._activeVao = null;\n    this._activeGeometry = null;\n  }\n}\n/** @ignore */\nGlGeometrySystem.extension = {\n  type: [ExtensionType.WebGLSystem],\n  name: \"geometry\"\n};\nexport { GlGeometrySystem };","map":{"version":3,"names":["topologyToGlMap","GlGeometrySystem","constructor","renderer","_geometryVaoHash","Object","create","_renderer","_activeGeometry","_activeVao","hasVao","hasInstance","contextChange","gl","context","supports","vertexArrayObject","Error","nativeVaoExtension","extensions","createVertexArray","createVertexArrayOES","bindVertexArray","vao","bindVertexArrayOES","deleteVertexArray","deleteVertexArrayOES","nativeInstancedExtension","vertexAttribDivisorANGLE","drawArraysInstanced","a","b","c","d","drawArraysInstancedANGLE","drawElementsInstanced","e","drawElementsInstancedANGLE","vertexAttribDivisor","bind","geometry","program","getVao","updateBuffers","reset","unbind","bufferSystem","buffer","i","buffers","length","updateBuffer","checkCompatibility","geometryAttributes","attributes","shaderAttributes","_attributeData","j","getSignature","attribs","strings","uid","push","location","join","_key","initGeometryVao","_incRefCount","shader","_getProgramData","signature","on","onGeometryDestroy","vaoObjectHash","ensureAttributes","activateVao","contextLost","destroyAll","indexBuffer","lastBuffer","attribute","glBuffer","getGlBuffer","programAttrib","enableVertexAttribArray","attributeInfo","getAttributeInfoFromFormat","format","type","getGlTypeFromFormat","substring","vertexAttribIPointer","size","stride","offset","vertexAttribPointer","normalised","instance","draw","topology","start","instanceCount","glTopology","byteSize","data","BYTES_PER_ELEMENT","glType","UNSIGNED_SHORT","UNSIGNED_INT","drawElements","getSize","drawArrays","destroy","extension","ExtensionType","WebGLSystem","name"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gl/geometry/GlGeometrySystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { getAttributeInfoFromFormat } from '../../shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ensureAttributes } from '../shader/program/ensureAttributes';\nimport { getGlTypeFromFormat } from './utils/getGlTypeFromFormat';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { GlProgram } from '../shader/GlProgram';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\nconst topologyToGlMap = {\n    'point-list': 0x0000,\n    'line-list': 0x0001,\n    'line-strip': 0x0003,\n    'triangle-list': 0x0004,\n    'triangle-strip': 0x0005\n};\n\n/**\n * System plugin to the renderer to manage geometry.\n * @memberof rendering\n */\nexport class GlGeometrySystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'geometry',\n    } as const;\n\n    /**\n     * `true` if we has `*_vertex_array_object` extension.\n     * @readonly\n     */\n    public hasVao: boolean;\n\n    /**\n     * `true` if has `ANGLE_instanced_arrays` extension.\n     * @readonly\n     */\n    public hasInstance: boolean;\n\n    protected gl: GlRenderingContext;\n    protected _activeGeometry: Geometry;\n    protected _activeVao: WebGLVertexArrayObject;\n\n    protected _geometryVaoHash: Record<number, Record<string, WebGLVertexArrayObject>> = Object.create(null);\n\n    /** Renderer that owns this {@link GeometrySystem}. */\n    private _renderer: WebGLRenderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._activeGeometry = null;\n        this._activeVao = null;\n\n        this.hasVao = true;\n        this.hasInstance = true;\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        const gl = this.gl = this._renderer.gl;\n\n        if (!this._renderer.context.supports.vertexArrayObject)\n        {\n            throw new Error('[PixiJS] Vertex Array Objects are not supported on this device');\n        }\n\n        const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;\n\n        if (nativeVaoExtension)\n        {\n            gl.createVertexArray = (): WebGLVertexArrayObject =>\n                nativeVaoExtension.createVertexArrayOES();\n\n            gl.bindVertexArray = (vao): void =>\n                nativeVaoExtension.bindVertexArrayOES(vao);\n\n            gl.deleteVertexArray = (vao): void =>\n                nativeVaoExtension.deleteVertexArrayOES(vao);\n        }\n\n        const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;\n\n        if (nativeInstancedExtension)\n        {\n            gl.drawArraysInstanced = (a, b, c, d): void =>\n            {\n                nativeInstancedExtension.drawArraysInstancedANGLE(a, b, c, d);\n            };\n\n            gl.drawElementsInstanced = (a, b, c, d, e): void =>\n            {\n                nativeInstancedExtension.drawElementsInstancedANGLE(a, b, c, d, e);\n            };\n\n            gl.vertexAttribDivisor = (a, b): void =>\n                nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);\n        }\n\n        this._activeGeometry = null;\n        this._activeVao = null;\n        this._geometryVaoHash = Object.create(null);\n    }\n\n    /**\n     * Binds geometry so that is can be drawn. Creating a Vao if required\n     * @param geometry - Instance of geometry to bind.\n     * @param program - Instance of program to use vao for.\n     */\n    public bind(geometry?: Geometry, program?: GlProgram): void\n    {\n        // shader = shader || this.renderer.shader.shader;\n\n        const gl = this.gl;\n\n        this._activeGeometry = geometry;\n\n        const vao = this.getVao(geometry, program);\n\n        if (this._activeVao !== vao)\n        {\n            this._activeVao = vao;\n\n            gl.bindVertexArray(vao);\n        }\n\n        this.updateBuffers();\n    }\n\n    /** Reset and unbind any active VAO and geometry. */\n    public reset(): void\n    {\n        this.unbind();\n    }\n\n    /** Update buffers of the currently bound geometry. */\n    public updateBuffers(): void\n    {\n        const geometry = this._activeGeometry;\n\n        const bufferSystem = this._renderer.buffer;\n\n        for (let i = 0; i < geometry.buffers.length; i++)\n        {\n            const buffer = geometry.buffers[i];\n\n            bufferSystem.updateBuffer(buffer);\n        }\n    }\n\n    /**\n     * Check compatibility between a geometry and a program\n     * @param geometry - Geometry instance.\n     * @param program - Program instance.\n     */\n    protected checkCompatibility(geometry: Geometry, program: GlProgram): void\n    {\n        // geometry must have at least all the attributes that the shader requires.\n        const geometryAttributes = geometry.attributes;\n        const shaderAttributes = program._attributeData;\n\n        for (const j in shaderAttributes)\n        {\n            if (!geometryAttributes[j])\n            {\n                throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n            }\n        }\n    }\n\n    /**\n     * Takes a geometry and program and generates a unique signature for them.\n     * @param geometry - To get signature from.\n     * @param program - To test geometry against.\n     * @returns - Unique signature of the geometry and program\n     */\n    protected getSignature(geometry: Geometry, program: GlProgram): string\n    {\n        const attribs = geometry.attributes;\n        const shaderAttributes = program._attributeData;\n\n        const strings = ['g', geometry.uid];\n\n        for (const i in attribs)\n        {\n            if (shaderAttributes[i])\n            {\n                strings.push(i, shaderAttributes[i].location);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    protected getVao(geometry: Geometry, program: GlProgram): WebGLVertexArrayObject\n    {\n        return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);\n    }\n\n    /**\n     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n     * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n     * attribute locations.\n     * @param geometry - Instance of geometry to to generate Vao for.\n     * @param program\n     * @param _incRefCount - Increment refCount of all geometry buffers.\n     */\n    protected initGeometryVao(geometry: Geometry, program: GlProgram, _incRefCount = true): WebGLVertexArrayObject\n    {\n        const gl = this._renderer.gl;\n        // const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this._renderer.buffer;\n\n        this._renderer.shader._getProgramData(program);\n\n        this.checkCompatibility(geometry, program);\n\n        const signature = this.getSignature(geometry, program);\n\n        if (!this._geometryVaoHash[geometry.uid])\n        {\n            this._geometryVaoHash[geometry.uid] = Object.create(null);\n\n            geometry.on('destroy', this.onGeometryDestroy, this);\n        }\n\n        const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n\n        let vao = vaoObjectHash[signature];\n\n        if (vao)\n        {\n            // this will give us easy access to the vao\n            vaoObjectHash[program._key] = vao;\n\n            return vao;\n        }\n\n        ensureAttributes(geometry, program._attributeData);\n\n        const buffers = geometry.buffers;\n\n        // @TODO: We don't know if VAO is supported.\n        vao = gl.createVertexArray();\n\n        gl.bindVertexArray(vao);\n\n        // first update - and create the buffers!\n        // only create a gl buffer if it actually gets\n        for (let i = 0; i < buffers.length; i++)\n        {\n            const buffer = buffers[i];\n\n            bufferSystem.bind(buffer);\n        }\n\n        // TODO - maybe make this a data object?\n        // lets wait to see if we need to first!\n\n        this.activateVao(geometry, program);\n\n        // add it to the cache!\n        vaoObjectHash[program._key] = vao;\n        vaoObjectHash[signature] = vao;\n\n        gl.bindVertexArray(null);\n\n        return vao;\n    }\n\n    /**\n     * Disposes geometry.\n     * @param geometry - Geometry with buffers. Only VAO will be disposed\n     * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    protected onGeometryDestroy(geometry: Geometry, contextLost?: boolean): void\n    {\n        const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n\n        const gl = this.gl;\n\n        if (vaoObjectHash)\n        {\n            if (contextLost)\n            {\n                for (const i in vaoObjectHash)\n                {\n                    if (this._activeVao !== vaoObjectHash[i])\n                    {\n                        this.unbind();\n                    }\n\n                    gl.deleteVertexArray(vaoObjectHash[i]);\n                }\n            }\n\n            this._geometryVaoHash[geometry.uid] = null;\n        }\n    }\n\n    /**\n     * Dispose all WebGL resources of all managed geometries.\n     * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n     */\n    public destroyAll(contextLost = false): void\n    {\n        const gl = this.gl;\n\n        for (const i in this._geometryVaoHash)\n        {\n            if (contextLost)\n            {\n                for (const j in this._geometryVaoHash[i])\n                {\n                    const vaoObjectHash = this._geometryVaoHash[i];\n\n                    if (this._activeVao !== vaoObjectHash)\n                    {\n                        this.unbind();\n                    }\n\n                    gl.deleteVertexArray(vaoObjectHash[j]);\n                }\n            }\n\n            this._geometryVaoHash[i] = null;\n        }\n    }\n\n    /**\n     * Activate vertex array object.\n     * @param geometry - Geometry instance.\n     * @param program - Shader program instance.\n     */\n    protected activateVao(geometry: Geometry, program: GlProgram): void\n    {\n        const gl = this._renderer.gl;\n\n        const bufferSystem = this._renderer.buffer;\n        const attributes = geometry.attributes;\n\n        if (geometry.indexBuffer)\n        {\n            // first update the index buffer if we have one..\n            bufferSystem.bind(geometry.indexBuffer);\n        }\n\n        let lastBuffer = null;\n\n        // add a new one!\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const buffer = attribute.buffer;\n            const glBuffer = bufferSystem.getGlBuffer(buffer);\n            const programAttrib = program._attributeData[j];\n\n            if (programAttrib)\n            {\n                if (lastBuffer !== glBuffer)\n                {\n                    bufferSystem.bind(buffer);\n\n                    lastBuffer = glBuffer;\n                }\n\n                const location = attribute.location;\n\n                // TODO introduce state again\n                // we can optimise this for older devices that have no VAOs\n                gl.enableVertexAttribArray(location);\n\n                const attributeInfo = getAttributeInfoFromFormat(attribute.format);\n\n                const type = getGlTypeFromFormat(attribute.format);\n\n                if (programAttrib.format?.substring(1, 4) === 'int')\n                {\n                    gl.vertexAttribIPointer(location,\n                        attributeInfo.size,\n                        type,\n                        attribute.stride,\n                        attribute.offset);\n                }\n                else\n                {\n                    gl.vertexAttribPointer(location,\n                        attributeInfo.size,\n                        type,\n                        attributeInfo.normalised,\n                        attribute.stride,\n                        attribute.offset);\n                }\n\n                if (attribute.instance)\n                {\n                    // TODO calculate instance count based of this...\n                    if (this.hasInstance)\n                    {\n                        gl.vertexAttribDivisor(location, 1);// attribute.divisor);\n                    }\n                    else\n                    {\n                        throw new Error('geometry error, GPU Instancing is not supported on this device');\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the currently bound geometry.\n     * @param topology - The type primitive to render.\n     * @param size - The number of elements to be rendered. If not specified, all vertices after the\n     *  starting vertex will be drawn.\n     * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n     *  all instances will be drawn.\n     */\n    public draw(topology?: Topology, size?: number, start?: number, instanceCount?: number): this\n    {\n        const { gl } = this._renderer;\n        const geometry = this._activeGeometry;\n\n        const glTopology = topologyToGlMap[geometry.topology || topology];\n\n        instanceCount ||= geometry.instanceCount;\n\n        if (geometry.indexBuffer)\n        {\n            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n            if (instanceCount > 1)\n            {\n                /* eslint-disable max-len */\n                gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);\n                /* eslint-enable max-len */\n            }\n            else\n            {\n                /* eslint-disable max-len */\n                gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n                /* eslint-enable max-len */\n            }\n        }\n        else if (instanceCount > 1)\n        {\n            // TODO need a better way to calculate size..\n            gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);\n        }\n        else\n        {\n            gl.drawArrays(glTopology, start || 0, size || geometry.getSize());\n        }\n\n        return this;\n    }\n\n    /** Unbind/reset everything. */\n    protected unbind(): void\n    {\n        this.gl.bindVertexArray(null);\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this.gl = null;\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}