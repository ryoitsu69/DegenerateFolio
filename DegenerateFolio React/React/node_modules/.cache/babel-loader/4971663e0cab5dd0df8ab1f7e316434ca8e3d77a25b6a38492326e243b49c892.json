{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nconst logging = require('../lib/logging');\nconst RESPONSE_TIMEOUT = 1000 * 30;\nclass CDPConnection {\n  constructor(wsConnection) {\n    this._wsConnection = wsConnection;\n    this.cmd_id = 0;\n    this.targetID = null;\n    this.sessionId = null;\n  }\n  execute(method, params, callback) {\n    let message = {\n      method,\n      id: this.cmd_id++\n    };\n    if (this.sessionId) {\n      message['sessionId'] = this.sessionId;\n    }\n    const mergedMessage = Object.assign({\n      params: params\n    }, message);\n    this._wsConnection.send(JSON.stringify(mergedMessage), callback);\n  }\n  async send(method, params) {\n    let cdp_id = this.cmd_id++;\n    let message = {\n      method,\n      id: cdp_id\n    };\n    if (this.sessionId) {\n      message['sessionId'] = this.sessionId;\n    }\n    const mergedMessage = Object.assign({\n      params: params\n    }, message);\n    this._wsConnection.send(JSON.stringify(mergedMessage));\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new Error(`Request with id ${cdp_id} timed out`));\n        handler.off('message', listener);\n      }, RESPONSE_TIMEOUT);\n      const listener = data => {\n        try {\n          const payload = JSON.parse(data.toString());\n          if (payload.id === cdp_id) {\n            clearTimeout(timeoutId);\n            handler.off('message', listener);\n            resolve(payload);\n          }\n        } catch (err) {\n          logging.getLogger(logging.Type.BROWSER).severe(`Failed parse message: ${err.message}`);\n        }\n      };\n      const handler = this._wsConnection.on('message', listener);\n    });\n  }\n}\nexports.CdpConnection = CDPConnection;","map":{"version":3,"names":["logging","require","RESPONSE_TIMEOUT","CDPConnection","constructor","wsConnection","_wsConnection","cmd_id","targetID","sessionId","execute","method","params","callback","message","id","mergedMessage","Object","assign","send","JSON","stringify","cdp_id","Promise","resolve","reject","timeoutId","setTimeout","Error","handler","off","listener","data","payload","parse","toString","clearTimeout","err","getLogger","Type","BROWSER","severe","on","exports","CdpConnection"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/selenium-webdriver/devtools/CDPConnection.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nconst logging = require('../lib/logging')\n\nconst RESPONSE_TIMEOUT = 1000 * 30\n\nclass CDPConnection {\n  constructor(wsConnection) {\n    this._wsConnection = wsConnection\n    this.cmd_id = 0\n    this.targetID = null\n    this.sessionId = null\n  }\n\n  execute(method, params, callback) {\n    let message = {\n      method,\n      id: this.cmd_id++,\n    }\n    if (this.sessionId) {\n      message['sessionId'] = this.sessionId\n    }\n\n    const mergedMessage = Object.assign({ params: params }, message)\n    this._wsConnection.send(JSON.stringify(mergedMessage), callback)\n  }\n\n  async send(method, params) {\n    let cdp_id = this.cmd_id++\n    let message = {\n      method,\n      id: cdp_id,\n    }\n    if (this.sessionId) {\n      message['sessionId'] = this.sessionId\n    }\n\n    const mergedMessage = Object.assign({ params: params }, message)\n    this._wsConnection.send(JSON.stringify(mergedMessage))\n\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new Error(`Request with id ${cdp_id} timed out`))\n        handler.off('message', listener)\n      }, RESPONSE_TIMEOUT)\n\n      const listener = (data) => {\n        try {\n          const payload = JSON.parse(data.toString())\n          if (payload.id === cdp_id) {\n            clearTimeout(timeoutId)\n            handler.off('message', listener)\n            resolve(payload)\n          }\n        } catch (err) {\n          logging.getLogger(logging.Type.BROWSER).severe(`Failed parse message: ${err.message}`)\n        }\n      }\n\n      const handler = this._wsConnection.on('message', listener)\n    })\n  }\n}\n\nexports.CdpConnection = CDPConnection\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AAEzC,MAAMC,gBAAgB,GAAG,IAAI,GAAG,EAAE;AAElC,MAAMC,aAAa,CAAC;EAClBC,WAAWA,CAACC,YAAY,EAAE;IACxB,IAAI,CAACC,aAAa,GAAGD,YAAY;IACjC,IAAI,CAACE,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,SAAS,GAAG,IAAI;EACvB;EAEAC,OAAOA,CAACC,MAAM,EAAEC,MAAM,EAAEC,QAAQ,EAAE;IAChC,IAAIC,OAAO,GAAG;MACZH,MAAM;MACNI,EAAE,EAAE,IAAI,CAACR,MAAM;IACjB,CAAC;IACD,IAAI,IAAI,CAACE,SAAS,EAAE;MAClBK,OAAO,CAAC,WAAW,CAAC,GAAG,IAAI,CAACL,SAAS;IACvC;IAEA,MAAMO,aAAa,GAAGC,MAAM,CAACC,MAAM,CAAC;MAAEN,MAAM,EAAEA;IAAO,CAAC,EAAEE,OAAO,CAAC;IAChE,IAAI,CAACR,aAAa,CAACa,IAAI,CAACC,IAAI,CAACC,SAAS,CAACL,aAAa,CAAC,EAAEH,QAAQ,CAAC;EAClE;EAEA,MAAMM,IAAIA,CAACR,MAAM,EAAEC,MAAM,EAAE;IACzB,IAAIU,MAAM,GAAG,IAAI,CAACf,MAAM,EAAE;IAC1B,IAAIO,OAAO,GAAG;MACZH,MAAM;MACNI,EAAE,EAAEO;IACN,CAAC;IACD,IAAI,IAAI,CAACb,SAAS,EAAE;MAClBK,OAAO,CAAC,WAAW,CAAC,GAAG,IAAI,CAACL,SAAS;IACvC;IAEA,MAAMO,aAAa,GAAGC,MAAM,CAACC,MAAM,CAAC;MAAEN,MAAM,EAAEA;IAAO,CAAC,EAAEE,OAAO,CAAC;IAChE,IAAI,CAACR,aAAa,CAACa,IAAI,CAACC,IAAI,CAACC,SAAS,CAACL,aAAa,CAAC,CAAC;IAEtD,OAAO,IAAIO,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,MAAMC,SAAS,GAAGC,UAAU,CAAC,MAAM;QACjCF,MAAM,CAAC,IAAIG,KAAK,CAAE,mBAAkBN,MAAO,YAAW,CAAC,CAAC;QACxDO,OAAO,CAACC,GAAG,CAAC,SAAS,EAAEC,QAAQ,CAAC;MAClC,CAAC,EAAE7B,gBAAgB,CAAC;MAEpB,MAAM6B,QAAQ,GAAIC,IAAI,IAAK;QACzB,IAAI;UACF,MAAMC,OAAO,GAAGb,IAAI,CAACc,KAAK,CAACF,IAAI,CAACG,QAAQ,CAAC,CAAC,CAAC;UAC3C,IAAIF,OAAO,CAAClB,EAAE,KAAKO,MAAM,EAAE;YACzBc,YAAY,CAACV,SAAS,CAAC;YACvBG,OAAO,CAACC,GAAG,CAAC,SAAS,EAAEC,QAAQ,CAAC;YAChCP,OAAO,CAACS,OAAO,CAAC;UAClB;QACF,CAAC,CAAC,OAAOI,GAAG,EAAE;UACZrC,OAAO,CAACsC,SAAS,CAACtC,OAAO,CAACuC,IAAI,CAACC,OAAO,CAAC,CAACC,MAAM,CAAE,yBAAwBJ,GAAG,CAACvB,OAAQ,EAAC,CAAC;QACxF;MACF,CAAC;MAED,MAAMe,OAAO,GAAG,IAAI,CAACvB,aAAa,CAACoC,EAAE,CAAC,SAAS,EAAEX,QAAQ,CAAC;IAC5D,CAAC,CAAC;EACJ;AACF;AAEAY,OAAO,CAACC,aAAa,GAAGzC,aAAa","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}