{"ast":null,"code":"import { AbstractBase } from '@polkadot/types-codec';\nimport { isBigInt, isBn, isHex, isNumber, isU8a, u8aConcat, u8aToBn, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { decodeAddress } from '@polkadot/util-crypto';\nimport { GenericAccountIndex } from '../generic/AccountIndex.js';\nimport { GenericEthereumAccountId } from './AccountId.js';\nexport const ACCOUNT_ID_PREFIX = new Uint8Array([0xff]);\n/** @internal */\nfunction decodeString(registry, value) {\n  const decoded = decodeAddress(value);\n  return decoded.length === 20 ? registry.createTypeUnsafe('EthereumAccountId', [decoded]) : registry.createTypeUnsafe('AccountIndex', [u8aToBn(decoded)]);\n}\n/** @internal */\nfunction decodeU8a(registry, value) {\n  // This allows us to instantiate an address with a raw publicKey. Do this first before\n  // we checking the first byte, otherwise we may split an already-existent valid address\n  if (value.length === 20) {\n    return registry.createTypeUnsafe('EthereumAccountId', [value]);\n  } else if (value[0] === 0xff) {\n    return registry.createTypeUnsafe('EthereumAccountId', [value.subarray(1)]);\n  }\n  const [offset, length] = GenericAccountIndex.readLength(value);\n  return registry.createTypeUnsafe('AccountIndex', [u8aToBn(value.subarray(offset, offset + length))]);\n}\nfunction decodeAddressOrIndex(registry, value) {\n  return value instanceof GenericEthereumLookupSource ? value.inner : value instanceof GenericEthereumAccountId || value instanceof GenericAccountIndex ? value : isU8a(value) || Array.isArray(value) || isHex(value) ? decodeU8a(registry, u8aToU8a(value)) : isBn(value) || isNumber(value) || isBigInt(value) ? registry.createTypeUnsafe('AccountIndex', [value]) : decodeString(registry, value);\n}\n/**\n * @name GenericEthereumLookupSource\n * @description\n * A wrapper around an EthereumAccountId and/or AccountIndex that is encoded with a prefix.\n * Since we are dealing with underlying publicKeys (or shorter encoded addresses),\n * we extend from Base with an AccountId/AccountIndex wrapper. Basically the Address\n * is encoded as `[ <prefix-byte>, ...publicKey/...bytes ]` as per spec\n */\nexport class GenericEthereumLookupSource extends AbstractBase {\n  constructor(registry, value = new Uint8Array()) {\n    super(registry, decodeAddressOrIndex(registry, value));\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    const rawLength = this._rawLength;\n    return rawLength + (\n    // for 1 byte AccountIndexes, we are not adding a specific prefix\n    rawLength > 1 ? 1 : 0);\n  }\n  /**\n   * @description The length of the raw value, either AccountIndex or AccountId\n   */\n  get _rawLength() {\n    return this.inner instanceof GenericAccountIndex ? GenericAccountIndex.calcLength(this.inner) : this.inner.encodedLength;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'Address';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    const encoded = this.inner.toU8a().subarray(0, this._rawLength);\n    return isBare ? encoded : u8aConcat(this.inner instanceof GenericAccountIndex ? GenericAccountIndex.writeLength(encoded) : ACCOUNT_ID_PREFIX, encoded);\n  }\n}","map":{"version":3,"names":["AbstractBase","isBigInt","isBn","isHex","isNumber","isU8a","u8aConcat","u8aToBn","u8aToHex","u8aToU8a","decodeAddress","GenericAccountIndex","GenericEthereumAccountId","ACCOUNT_ID_PREFIX","Uint8Array","decodeString","registry","value","decoded","length","createTypeUnsafe","decodeU8a","subarray","offset","readLength","decodeAddressOrIndex","GenericEthereumLookupSource","inner","Array","isArray","constructor","encodedLength","rawLength","_rawLength","calcLength","toHex","toU8a","toRawType","isBare","encoded","writeLength"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/ethereum/LookupSource.js"],"sourcesContent":["import { AbstractBase } from '@polkadot/types-codec';\nimport { isBigInt, isBn, isHex, isNumber, isU8a, u8aConcat, u8aToBn, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { decodeAddress } from '@polkadot/util-crypto';\nimport { GenericAccountIndex } from '../generic/AccountIndex.js';\nimport { GenericEthereumAccountId } from './AccountId.js';\nexport const ACCOUNT_ID_PREFIX = new Uint8Array([0xff]);\n/** @internal */\nfunction decodeString(registry, value) {\n    const decoded = decodeAddress(value);\n    return decoded.length === 20\n        ? registry.createTypeUnsafe('EthereumAccountId', [decoded])\n        : registry.createTypeUnsafe('AccountIndex', [u8aToBn(decoded)]);\n}\n/** @internal */\nfunction decodeU8a(registry, value) {\n    // This allows us to instantiate an address with a raw publicKey. Do this first before\n    // we checking the first byte, otherwise we may split an already-existent valid address\n    if (value.length === 20) {\n        return registry.createTypeUnsafe('EthereumAccountId', [value]);\n    }\n    else if (value[0] === 0xff) {\n        return registry.createTypeUnsafe('EthereumAccountId', [value.subarray(1)]);\n    }\n    const [offset, length] = GenericAccountIndex.readLength(value);\n    return registry.createTypeUnsafe('AccountIndex', [u8aToBn(value.subarray(offset, offset + length))]);\n}\nfunction decodeAddressOrIndex(registry, value) {\n    return value instanceof GenericEthereumLookupSource\n        ? value.inner\n        : value instanceof GenericEthereumAccountId || value instanceof GenericAccountIndex\n            ? value\n            : isU8a(value) || Array.isArray(value) || isHex(value)\n                ? decodeU8a(registry, u8aToU8a(value))\n                : isBn(value) || isNumber(value) || isBigInt(value)\n                    ? registry.createTypeUnsafe('AccountIndex', [value])\n                    : decodeString(registry, value);\n}\n/**\n * @name GenericEthereumLookupSource\n * @description\n * A wrapper around an EthereumAccountId and/or AccountIndex that is encoded with a prefix.\n * Since we are dealing with underlying publicKeys (or shorter encoded addresses),\n * we extend from Base with an AccountId/AccountIndex wrapper. Basically the Address\n * is encoded as `[ <prefix-byte>, ...publicKey/...bytes ]` as per spec\n */\nexport class GenericEthereumLookupSource extends AbstractBase {\n    constructor(registry, value = new Uint8Array()) {\n        super(registry, decodeAddressOrIndex(registry, value));\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        const rawLength = this._rawLength;\n        return rawLength + (\n        // for 1 byte AccountIndexes, we are not adding a specific prefix\n        rawLength > 1\n            ? 1\n            : 0);\n    }\n    /**\n     * @description The length of the raw value, either AccountIndex or AccountId\n     */\n    get _rawLength() {\n        return this.inner instanceof GenericAccountIndex\n            ? GenericAccountIndex.calcLength(this.inner)\n            : this.inner.encodedLength;\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'Address';\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        const encoded = this.inner.toU8a().subarray(0, this._rawLength);\n        return isBare\n            ? encoded\n            : u8aConcat(this.inner instanceof GenericAccountIndex\n                ? GenericAccountIndex.writeLength(encoded)\n                : ACCOUNT_ID_PREFIX, encoded);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}