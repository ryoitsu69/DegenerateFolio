{"ast":null,"code":"import { autoDetectEnvironment } from '../../environment/autoDetectEnvironment.mjs';\nimport { isWebGLSupported } from '../../utils/browser/isWebGLSupported.mjs';\nimport { isWebGPUSupported } from '../../utils/browser/isWebGPUSupported.mjs';\nimport { AbstractRenderer } from './shared/system/AbstractRenderer.mjs';\n\"use strict\";\nconst renderPriority = [\"webgl\", \"webgpu\", \"canvas\"];\nasync function autoDetectRenderer(options) {\n  let preferredOrder = [];\n  if (options.preference) {\n    preferredOrder.push(options.preference);\n    renderPriority.forEach(item => {\n      if (item !== options.preference) {\n        preferredOrder.push(item);\n      }\n    });\n  } else {\n    preferredOrder = renderPriority.slice();\n  }\n  let RendererClass;\n  await autoDetectEnvironment(options.manageImports ?? true);\n  let finalOptions = {};\n  for (let i = 0; i < preferredOrder.length; i++) {\n    const rendererType = preferredOrder[i];\n    if (rendererType === \"webgpu\" && (await isWebGPUSupported())) {\n      const {\n        WebGPURenderer\n      } = await import('./gpu/WebGPURenderer.mjs');\n      RendererClass = WebGPURenderer;\n      finalOptions = {\n        ...options,\n        ...options.webgpu\n      };\n      break;\n    } else if (rendererType === \"webgl\" && isWebGLSupported(options.failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat)) {\n      const {\n        WebGLRenderer\n      } = await import('./gl/WebGLRenderer.mjs');\n      RendererClass = WebGLRenderer;\n      finalOptions = {\n        ...options,\n        ...options.webgl\n      };\n      break;\n    } else if (rendererType === \"canvas\") {\n      finalOptions = {\n        ...options\n      };\n      throw new Error(\"CanvasRenderer is not yet implemented\");\n    }\n  }\n  delete finalOptions.webgpu;\n  delete finalOptions.webgl;\n  if (!RendererClass) {\n    throw new Error(\"No available renderer for the current environment\");\n  }\n  const renderer = new RendererClass();\n  await renderer.init(finalOptions);\n  return renderer;\n}\nexport { autoDetectRenderer };","map":{"version":3,"names":["renderPriority","autoDetectRenderer","options","preferredOrder","preference","push","forEach","item","slice","RendererClass","autoDetectEnvironment","manageImports","finalOptions","i","length","rendererType","isWebGPUSupported","WebGPURenderer","webgpu","isWebGLSupported","failIfMajorPerformanceCaveat","AbstractRenderer","defaultOptions","WebGLRenderer","webgl","Error","renderer","init"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/autoDetectRenderer.ts"],"sourcesContent":["import { autoDetectEnvironment } from '../../environment/autoDetectEnvironment';\nimport { isWebGLSupported } from '../../utils/browser/isWebGLSupported';\nimport { isWebGPUSupported } from '../../utils/browser/isWebGPUSupported';\nimport { AbstractRenderer } from './shared/system/AbstractRenderer';\n\nimport type { WebGLOptions } from './gl/WebGLRenderer';\nimport type { WebGPUOptions } from './gpu/WebGPURenderer';\nimport type { Renderer } from './types';\n\n/**\n * Options for {@link rendering.autoDetectRenderer}.\n * @memberof rendering\n */\nexport interface AutoDetectOptions extends WebGLOptions, WebGPUOptions\n{\n    /** The preferred renderer type. WebGPU is recommended as its generally faster than WebGL. */\n    preference?: 'webgl' | 'webgpu'// | 'canvas';\n    /**\n     * Whether to manage the dynamic imports of the renderer code. It is true by default, this means\n     * PixiJS will load all the default pixi systems and extensions. If you set this to false, then\n     * you as the dev will need to manually import the systems and extensions you need.\n     */\n    manageImports?: boolean;\n    /** Optional WebGPUOptions to pass only to WebGPU renderer. */\n    webgpu?: Partial<WebGPUOptions>;\n    /** Optional WebGLOptions to pass only to the WebGL renderer */\n    webgl?: Partial<WebGLOptions>;\n}\n\nconst renderPriority = ['webgl', 'webgpu', 'canvas'];\n\n/**\n * Automatically determines the most appropriate renderer for the current environment.\n *\n * The function will prioritize the WebGL renderer as it is the most tested safe API to use.\n * In the near future as WebGPU becomes more stable and ubiquitous, it will be prioritized over WebGL.\n *\n * The selected renderer's code is then dynamically imported to optimize\n * performance and minimize the initial bundle size.\n *\n * To maximize the benefits of dynamic imports, it's recommended to use a modern bundler\n * that supports code splitting. This will place the renderer code in a separate chunk,\n * which is loaded only when needed.\n * @example\n *\n * // create a renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   antialias: true,\n * });\n *\n * // custom for each renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   webgpu:{\n *     antialias: true,\n *     backgroundColor: 'red'\n *   },\n *   webgl:{\n *     antialias: true,\n *     backgroundColor: 'green'\n *   }\n *  });\n * @param options - A partial configuration object based on the `AutoDetectOptions` type.\n * @returns A Promise that resolves to an instance of the selected renderer.\n * @memberof rendering\n */\nexport async function autoDetectRenderer(options: Partial<AutoDetectOptions>): Promise<Renderer>\n{\n    let preferredOrder: string[] = [];\n\n    if (options.preference)\n    {\n        preferredOrder.push(options.preference);\n\n        renderPriority.forEach((item) =>\n        {\n            if (item !== options.preference)\n            {\n                preferredOrder.push(item);\n            }\n        });\n    }\n    else\n    {\n        preferredOrder = renderPriority.slice();\n    }\n\n    let RendererClass: new () => Renderer;\n\n    await autoDetectEnvironment(\n        options.manageImports ?? true,\n    );\n\n    let finalOptions: Partial<AutoDetectOptions> = {};\n\n    for (let i = 0; i < preferredOrder.length; i++)\n    {\n        const rendererType = preferredOrder[i];\n\n        if (rendererType === 'webgpu' && (await isWebGPUSupported()))\n        {\n            const { WebGPURenderer } = await import('./gpu/WebGPURenderer');\n\n            RendererClass = WebGPURenderer;\n\n            finalOptions = { ...options, ...options.webgpu };\n\n            break;\n        }\n        else if (\n            rendererType === 'webgl'\n            && isWebGLSupported(\n                options.failIfMajorPerformanceCaveat\n                    ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n            )\n        )\n        {\n            const { WebGLRenderer } = await import('./gl/WebGLRenderer');\n\n            RendererClass = WebGLRenderer;\n\n            finalOptions = { ...options, ...options.webgl };\n\n            break;\n        }\n        else if (rendererType === 'canvas')\n        {\n            finalOptions = { ...options };\n\n            throw new Error('CanvasRenderer is not yet implemented');\n        }\n    }\n\n    delete finalOptions.webgpu;\n    delete finalOptions.webgl;\n\n    if (!RendererClass)\n    {\n        throw new Error('No available renderer for the current environment');\n    }\n\n    const renderer = new RendererClass();\n\n    await renderer.init(finalOptions);\n\n    return renderer;\n}\n"],"mappings":";;;;;AA6BA,MAAMA,cAAiB,IAAC,OAAS,YAAU,QAAQ;AAwCnD,eAAsBC,mBAAmBC,OACzC;EACI,IAAIC,cAAA,GAA2B,EAAC;EAEhC,IAAID,OAAA,CAAQE,UACZ;IACmBD,cAAA,CAAAE,IAAA,CAAKH,OAAA,CAAQE,UAAU;IAEvBJ,cAAA,CAAAM,OAAA,CAASC,IACxB;MACQ,IAAAA,IAAA,KAASL,OAAA,CAAQE,UACrB;QACID,cAAA,CAAeE,IAAA,CAAKE,IAAI;MAAA;IAC5B,CACH;EAAA,CAGL;IACIJ,cAAA,GAAiBH,cAAA,CAAeQ,KAAM;EAAA;EAGtC,IAAAC,aAAA;EAEE,MAAAC,qBAAA,CACFR,OAAA,CAAQS,aAAiB,SAC7B;EAEA,IAAIC,YAAA,GAA2C,EAAC;EAEhD,SAASC,CAAI,MAAGA,CAAI,GAAAV,cAAA,CAAeW,MAAA,EAAQD,CAC3C;IACU,MAAAE,YAAA,GAAeZ,cAAA,CAAeU,CAAC;IAErC,IAAIE,YAAiB,kBAAa,MAAMC,iBAAA,EACxC;MACI,MAAM;QAAEC;MAAA,CAAmB,SAAM,OAAO,0BAAsB;MAE9CR,aAAA,GAAAQ,cAAA;MAEhBL,YAAA,GAAe;QAAE,GAAGV,OAAS;QAAA,GAAGA,OAAA,CAAQgB;MAAO;MAE/C;IAAA,CACJ,UAEIH,YAAA,KAAiB,OACd,IAAAI,gBAAA,CACCjB,OAAA,CAAQkB,4BACD,IAAAC,gBAAA,CAAiBC,cAAe,CAAAF,4BAAA,CAG/C;MACI,MAAM;QAAEG;MAAA,CAAkB,SAAM,OAAO,wBAAoB;MAE3Cd,aAAA,GAAAc,aAAA;MAEhBX,YAAA,GAAe;QAAE,GAAGV,OAAS;QAAA,GAAGA,OAAA,CAAQsB;MAAM;MAE9C;IAAA,CACJ,UACST,YAAA,KAAiB,QAC1B;MACmBH,YAAA;QAAE,GAAGV;MAAQ;MAEtB,UAAIuB,KAAA,CAAM,uCAAuC;IAAA;EAC3D;EAGJ,OAAOb,YAAa,CAAAM,MAAA;EACpB,OAAON,YAAa,CAAAY,KAAA;EAEpB,IAAI,CAACf,aACL;IACU,UAAIgB,KAAA,CAAM,mDAAmD;EAAA;EAGjE,MAAAC,QAAA,GAAW,IAAIjB,aAAc;EAE7B,MAAAiB,QAAA,CAASC,IAAA,CAAKf,YAAY;EAEzB,OAAAc,QAAA;AACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}