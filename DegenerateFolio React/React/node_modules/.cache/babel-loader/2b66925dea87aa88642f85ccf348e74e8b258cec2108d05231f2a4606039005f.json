{"ast":null,"code":"import { u8aToU8a } from '@polkadot/util';\n/** @internal */\nexport function createDecode(_ref, validate) {\n  let {\n    coder,\n    ipfs\n  } = _ref;\n  return (value, ipfsCompat) => {\n    validate(value, ipfsCompat);\n    return coder.decode(ipfs && ipfsCompat ? value.substring(1) : value);\n  };\n}\n/** @internal */\nexport function createEncode(_ref2) {\n  let {\n    coder,\n    ipfs\n  } = _ref2;\n  return (value, ipfsCompat) => {\n    const out = coder.encode(u8aToU8a(value));\n    return ipfs && ipfsCompat ? \"\".concat(ipfs).concat(out) : out;\n  };\n}\n/** @internal */\nexport function createIs(validate) {\n  return (value, ipfsCompat) => {\n    try {\n      return validate(value, ipfsCompat);\n    } catch {\n      return false;\n    }\n  };\n}\n/** @internal */\nexport function createValidate(_ref3) {\n  let {\n    chars,\n    ipfs,\n    type,\n    withPadding\n  } = _ref3;\n  return (value, ipfsCompat) => {\n    if (typeof value !== 'string') {\n      throw new Error(\"Expected \".concat(type, \" string input\"));\n    } else if (ipfs && ipfsCompat && !value.startsWith(ipfs)) {\n      throw new Error(\"Expected ipfs-compatible \".concat(type, \" to start with '\").concat(ipfs, \"'\"));\n    }\n    for (let i = ipfsCompat ? 1 : 0, count = value.length; i < count; i++) {\n      if (chars.includes(value[i])) {\n        // all ok, character found\n      } else if (withPadding && value[i] === '=') {\n        if (i === count - 1) {\n          // last character, everything ok\n        } else if (value[i + 1] === '=') {\n          // next one is also padding, sequence ok\n        } else {\n          throw new Error(\"Invalid \".concat(type, \" padding sequence \\\"\").concat(value[i]).concat(value[i + 1], \"\\\" at index \").concat(i));\n        }\n      } else {\n        throw new Error(\"Invalid \".concat(type, \" character \\\"\").concat(value[i], \"\\\" (0x\").concat(value.charCodeAt(i).toString(16), \") at index \").concat(i));\n      }\n    }\n    return true;\n  };\n}","map":{"version":3,"names":["u8aToU8a","createDecode","_ref","validate","coder","ipfs","value","ipfsCompat","decode","substring","createEncode","_ref2","out","encode","concat","createIs","createValidate","_ref3","chars","type","withPadding","Error","startsWith","i","count","length","includes","charCodeAt","toString"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util-crypto/base32/helpers.js"],"sourcesContent":["import { u8aToU8a } from '@polkadot/util';\n/** @internal */\nexport function createDecode({ coder, ipfs }, validate) {\n    return (value, ipfsCompat) => {\n        validate(value, ipfsCompat);\n        return coder.decode(ipfs && ipfsCompat\n            ? value.substring(1)\n            : value);\n    };\n}\n/** @internal */\nexport function createEncode({ coder, ipfs }) {\n    return (value, ipfsCompat) => {\n        const out = coder.encode(u8aToU8a(value));\n        return ipfs && ipfsCompat\n            ? `${ipfs}${out}`\n            : out;\n    };\n}\n/** @internal */\nexport function createIs(validate) {\n    return (value, ipfsCompat) => {\n        try {\n            return validate(value, ipfsCompat);\n        }\n        catch {\n            return false;\n        }\n    };\n}\n/** @internal */\nexport function createValidate({ chars, ipfs, type, withPadding }) {\n    return (value, ipfsCompat) => {\n        if (typeof value !== 'string') {\n            throw new Error(`Expected ${type} string input`);\n        }\n        else if (ipfs && ipfsCompat && !value.startsWith(ipfs)) {\n            throw new Error(`Expected ipfs-compatible ${type} to start with '${ipfs}'`);\n        }\n        for (let i = (ipfsCompat ? 1 : 0), count = value.length; i < count; i++) {\n            if (chars.includes(value[i])) {\n                // all ok, character found\n            }\n            else if (withPadding && value[i] === '=') {\n                if (i === count - 1) {\n                    // last character, everything ok\n                }\n                else if (value[i + 1] === '=') {\n                    // next one is also padding, sequence ok\n                }\n                else {\n                    throw new Error(`Invalid ${type} padding sequence \"${value[i]}${value[i + 1]}\" at index ${i}`);\n                }\n            }\n            else {\n                throw new Error(`Invalid ${type} character \"${value[i]}\" (0x${value.charCodeAt(i).toString(16)}) at index ${i}`);\n            }\n        }\n        return true;\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}