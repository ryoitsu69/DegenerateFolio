{"ast":null,"code":"import { firstValueFrom, map, of, switchMap } from 'rxjs';\nimport { Metadata, TypeRegistry } from '@polkadot/types';\nimport { getSpecAlias, getSpecExtensions, getSpecHasher, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assertReturn, BN_ZERO, isUndefined, logger, noop, objectSpread, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { Decorate } from './Decorate.js';\nconst KEEPALIVE_INTERVAL = 10000;\nconst WITH_VERSION_SHORTCUT = false;\nconst l = logger('api/init');\nfunction textToString(t) {\n  return t.toString();\n}\nexport class Init extends Decorate {\n  __internal__atLast = null;\n  __internal__healthTimer = null;\n  __internal__registries = [];\n  __internal__updateSub = null;\n  __internal__waitingRegistries = {};\n  constructor(options, type, decorateMethod) {\n    super(options, type, decorateMethod);\n    // all injected types added to the registry for overrides\n    this.registry.setKnownTypes(options);\n    // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n    if (!options.source) {\n      this.registerTypes(options.types);\n    } else {\n      this.__internal__registries = options.source.__internal__registries;\n    }\n    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n    if (this.supportMulti) {\n      this._queryMulti = this._decorateMulti(this._decorateMethod);\n      this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n    }\n    this._rx.signer = options.signer;\n    this._rpcCore.setRegistrySwap(blockHash => this.getBlockRegistry(blockHash));\n    this._rpcCore.setResolveBlockHash(blockNumber => firstValueFrom(this._rpcCore.chain.getBlockHash(blockNumber)));\n    if (this.hasSubscriptions) {\n      this._rpcCore.provider.on('disconnected', () => this.__internal__onProviderDisconnect());\n      this._rpcCore.provider.on('error', e => this.__internal__onProviderError(e));\n      this._rpcCore.provider.on('connected', () => this.__internal__onProviderConnect());\n    } else if (!this._options.noInitWarn) {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    }\n    // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n    if (this._rpcCore.provider.isConnected) {\n      this.__internal__onProviderConnect().catch(noop);\n    }\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n  _initRegistry(registry, chain, version, metadata, chainProps) {\n    registry.clearCache();\n    registry.setChainProperties(chainProps || this.registry.getChainProperties());\n    registry.setKnownTypes(this._options);\n    registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion));\n    registry.setHasher(getSpecHasher(registry, chain, version.specName));\n    // for bundled types, pull through the aliases defined\n    if (registry.knownTypes.typesBundle) {\n      registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n    }\n    registry.setMetadata(metadata, undefined, objectSpread({}, getSpecExtensions(registry, chain, version.specName), this._options.signedExtensions), this._options.noInitWarn);\n  }\n  /**\n   * @description Returns the default versioned registry\n   */\n  _getDefaultRegistry() {\n    return assertReturn(this.__internal__registries.find(({\n      isDefault\n    }) => isDefault), 'Initialization error, cannot find the default registry');\n  }\n  /**\n   * @description Returns a decorated API instance at a specific point in time\n   */\n  async at(blockHash, knownVersion) {\n    const u8aHash = u8aToU8a(blockHash);\n    const u8aHex = u8aToHex(u8aHash);\n    const registry = await this.getBlockRegistry(u8aHash, knownVersion);\n    if (!this.__internal__atLast || this.__internal__atLast[0] !== u8aHex) {\n      // always create a new decoration - since we are pointing to a specific hash, this\n      // means that all queries needs to use that hash (not a previous one already existing)\n      this.__internal__atLast = [u8aHex, this._createDecorated(registry, true, null, u8aHash).decoratedApi];\n    }\n    return this.__internal__atLast[1];\n  }\n  async _createBlockRegistry(blockHash, header, version) {\n    const registry = new TypeRegistry(blockHash);\n    const metadata = new Metadata(registry, await firstValueFrom(this._rpcCore.state.getMetadata.raw(header.parentHash)));\n    const runtimeChain = this._runtimeChain;\n    if (!runtimeChain) {\n      throw new Error('Invalid initializion order, runtimeChain is not available');\n    }\n    this._initRegistry(registry, runtimeChain, version, metadata);\n    // add our new registry\n    const result = {\n      counter: 0,\n      lastBlockHash: blockHash,\n      metadata,\n      registry,\n      runtimeVersion: version\n    };\n    this.__internal__registries.push(result);\n    return result;\n  }\n  _cacheBlockRegistryProgress(key, creator) {\n    // look for waiting resolves\n    let waiting = this.__internal__waitingRegistries[key];\n    if (isUndefined(waiting)) {\n      // nothing waiting, construct new\n      waiting = this.__internal__waitingRegistries[key] = new Promise((resolve, reject) => {\n        creator().then(registry => {\n          delete this.__internal__waitingRegistries[key];\n          resolve(registry);\n        }).catch(error => {\n          delete this.__internal__waitingRegistries[key];\n          reject(error);\n        });\n      });\n    }\n    return waiting;\n  }\n  _getBlockRegistryViaVersion(blockHash, version) {\n    if (version) {\n      // check for pre-existing registries. We also check specName, e.g. it\n      // could be changed like in Westmint with upgrade from shell -> westmint\n      const existingViaVersion = this.__internal__registries.find(({\n        runtimeVersion: {\n          specName,\n          specVersion\n        }\n      }) => specName.eq(version.specName) && specVersion.eq(version.specVersion));\n      if (existingViaVersion) {\n        existingViaVersion.counter++;\n        existingViaVersion.lastBlockHash = blockHash;\n        return existingViaVersion;\n      }\n    }\n    return null;\n  }\n  async _getBlockRegistryViaHash(blockHash) {\n    // ensure we have everything required\n    if (!this._genesisHash || !this._runtimeVersion) {\n      throw new Error('Cannot retrieve data on an uninitialized chain');\n    }\n    // We have to assume that on the RPC layer the calls used here does not call back into\n    // the registry swap, so getHeader & getRuntimeVersion should not be historic\n    const header = this.registry.createType('HeaderPartial', this._genesisHash.eq(blockHash) ? {\n      number: BN_ZERO,\n      parentHash: this._genesisHash\n    } : await firstValueFrom(this._rpcCore.chain.getHeader.raw(blockHash)));\n    if (header.parentHash.isEmpty) {\n      throw new Error('Unable to retrieve header and parent from supplied hash');\n    }\n    // get the runtime version, either on-chain or via an known upgrade history\n    const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number);\n    const version = this.registry.createType('RuntimeVersionPartial', WITH_VERSION_SHORTCUT && firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {\n      apis: firstVersion.apis,\n      specName: this._runtimeVersion.specName,\n      specVersion: firstVersion.specVersion\n    } : await firstValueFrom(this._rpcCore.state.getRuntimeVersion.raw(header.parentHash)));\n    return (\n      // try to find via version\n      this._getBlockRegistryViaVersion(blockHash, version) || (\n      // return new or in-flight result\n      await this._cacheBlockRegistryProgress(version.toHex(), () => this._createBlockRegistry(blockHash, header, version)))\n    );\n  }\n  /**\n   * @description Sets up a registry based on the block hash defined\n   */\n  async getBlockRegistry(blockHash, knownVersion) {\n    return (\n      // try to find via blockHash\n      this.__internal__registries.find(({\n        lastBlockHash\n      }) => lastBlockHash && u8aEq(lastBlockHash, blockHash)) ||\n      // try to find via version\n      this._getBlockRegistryViaVersion(blockHash, knownVersion) || (\n      // return new or in-flight result\n      await this._cacheBlockRegistryProgress(u8aToHex(blockHash), () => this._getBlockRegistryViaHash(blockHash)))\n    );\n  }\n  async _loadMeta() {\n    // on re-connection to the same chain, we don't want to re-do everything from chain again\n    if (this._isReady) {\n      return true;\n    }\n    this._unsubscribeUpdates();\n    // only load from on-chain if we are not a clone (default path), alternatively\n    // just use the values from the source instance provided\n    [this._genesisHash, this._runtimeMetadata] = this._options.source?._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata);\n    return this._initFromMeta(this._runtimeMetadata);\n  }\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async _metaFromSource(source) {\n    this._extrinsicType = source.extrinsicVersion;\n    this._runtimeChain = source.runtimeChain;\n    this._runtimeVersion = source.runtimeVersion;\n    // manually build a list of all available methods in this RPC, we are\n    // going to filter on it to align the cloned RPC without making a call\n    const sections = Object.keys(source.rpc);\n    const rpcs = [];\n    for (let s = 0, scount = sections.length; s < scount; s++) {\n      const section = sections[s];\n      const methods = Object.keys(source.rpc[section]);\n      for (let m = 0, mcount = methods.length; m < mcount; m++) {\n        rpcs.push(`${section}_${methods[m]}`);\n      }\n    }\n    this._filterRpc(rpcs, getSpecRpc(this.registry, source.runtimeChain, source.runtimeVersion.specName));\n    return [source.genesisHash, source.runtimeMetadata];\n  }\n  // subscribe to metadata updates, inject the types on changes\n  _subscribeUpdates() {\n    if (this.__internal__updateSub || !this.hasSubscriptions) {\n      return;\n    }\n    this.__internal__updateSub = this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap(version =>\n    // only retrieve the metadata when the on-chain version has been changed\n    this._runtimeVersion?.specVersion.eq(version.specVersion) ? of(false) : this._rpcCore.state.getMetadata().pipe(map(metadata => {\n      l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n      this._runtimeMetadata = metadata;\n      this._runtimeVersion = version;\n      this._rx.runtimeVersion = version;\n      // update the default registry version\n      const thisRegistry = this._getDefaultRegistry();\n      const runtimeChain = this._runtimeChain;\n      if (!runtimeChain) {\n        throw new Error('Invalid initializion order, runtimeChain is not available');\n      }\n      // setup the data as per the current versions\n      thisRegistry.metadata = metadata;\n      thisRegistry.runtimeVersion = version;\n      this._initRegistry(this.registry, runtimeChain, version, metadata);\n      this._injectMetadata(thisRegistry, true);\n      return true;\n    })))).subscribe();\n  }\n  async _metaFromChain(optMetadata) {\n    const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata] = await Promise.all([firstValueFrom(this._rpcCore.chain.getBlockHash(0)), firstValueFrom(this._rpcCore.state.getRuntimeVersion()), firstValueFrom(this._rpcCore.system.chain()), firstValueFrom(this._rpcCore.system.properties()), firstValueFrom(this._rpcCore.rpc.methods()), optMetadata ? Promise.resolve(null) : firstValueFrom(this._rpcCore.state.getMetadata())]);\n    // set our chain version & genesisHash as returned\n    this._runtimeChain = chain;\n    this._runtimeVersion = runtimeVersion;\n    this._rx.runtimeVersion = runtimeVersion;\n    // retrieve metadata, either from chain  or as pass-in via options\n    const metadataKey = `${genesisHash.toHex() || '0x'}-${runtimeVersion.specVersion.toString()}`;\n    const metadata = chainMetadata || (optMetadata?.[metadataKey] ? new Metadata(this.registry, optMetadata[metadataKey]) : await firstValueFrom(this._rpcCore.state.getMetadata()));\n    // initializes the registry & RPC\n    this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n    this._filterRpc(rpcMethods.methods.map(textToString), getSpecRpc(this.registry, chain, runtimeVersion.specName));\n    this._subscribeUpdates();\n    // setup the initial registry, when we have none\n    if (!this.__internal__registries.length) {\n      this.__internal__registries.push({\n        counter: 0,\n        isDefault: true,\n        metadata,\n        registry: this.registry,\n        runtimeVersion\n      });\n    }\n    // get unique types & validate\n    metadata.getUniqTypes(this._options.throwOnUnknown || false);\n    return [genesisHash, metadata];\n  }\n  _initFromMeta(metadata) {\n    const runtimeVersion = this._runtimeVersion;\n    if (!runtimeVersion) {\n      throw new Error('Invalid initializion order, runtimeVersion is not available');\n    }\n    this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();\n    this._rx.extrinsicType = this._extrinsicType;\n    this._rx.genesisHash = this._genesisHash;\n    this._rx.runtimeVersion = runtimeVersion;\n    // inject metadata and adjust the types as detected\n    this._injectMetadata(this._getDefaultRegistry(), true);\n    // derive is last, since it uses the decorated rx\n    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n    this._derive = this._decorateDerive(this._decorateMethod);\n    return true;\n  }\n  _subscribeHealth() {\n    this._unsubscribeHealth();\n    // Only enable the health keepalive on WS, not needed on HTTP\n    this.__internal__healthTimer = this.hasSubscriptions ? setInterval(() => {\n      firstValueFrom(this._rpcCore.system.health.raw()).catch(noop);\n    }, KEEPALIVE_INTERVAL) : null;\n  }\n  _unsubscribeHealth() {\n    if (this.__internal__healthTimer) {\n      clearInterval(this.__internal__healthTimer);\n      this.__internal__healthTimer = null;\n    }\n  }\n  _unsubscribeUpdates() {\n    if (this.__internal__updateSub) {\n      this.__internal__updateSub.unsubscribe();\n      this.__internal__updateSub = null;\n    }\n  }\n  _unsubscribe() {\n    this._unsubscribeHealth();\n    this._unsubscribeUpdates();\n  }\n  async __internal__onProviderConnect() {\n    this._isConnected.next(true);\n    this.emit('connected');\n    try {\n      const cryptoReady = this._options.initWasm === false ? true : await cryptoWaitReady();\n      const hasMeta = await this._loadMeta();\n      this._subscribeHealth();\n      if (hasMeta && !this._isReady && cryptoReady) {\n        this._isReady = true;\n        this.emit('ready', this);\n      }\n    } catch (_error) {\n      const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n      l.error(error);\n      this.emit('error', error);\n    }\n  }\n  __internal__onProviderDisconnect() {\n    this._isConnected.next(false);\n    this._unsubscribe();\n    this.emit('disconnected');\n  }\n  __internal__onProviderError(error) {\n    this.emit('error', error);\n  }\n}","map":{"version":3,"names":["firstValueFrom","map","of","switchMap","Metadata","TypeRegistry","getSpecAlias","getSpecExtensions","getSpecHasher","getSpecRpc","getSpecTypes","getUpgradeVersion","assertReturn","BN_ZERO","isUndefined","logger","noop","objectSpread","u8aEq","u8aToHex","u8aToU8a","cryptoWaitReady","Decorate","KEEPALIVE_INTERVAL","WITH_VERSION_SHORTCUT","l","textToString","t","toString","Init","__internal__atLast","__internal__healthTimer","__internal__registries","__internal__updateSub","__internal__waitingRegistries","constructor","options","type","decorateMethod","registry","setKnownTypes","source","registerTypes","types","_rpc","_decorateRpc","_rpcCore","_decorateMethod","_rx","rpc","_rxDecorateMethod","supportMulti","_queryMulti","_decorateMulti","queryMulti","signer","setRegistrySwap","blockHash","getBlockRegistry","setResolveBlockHash","blockNumber","chain","getBlockHash","hasSubscriptions","provider","on","__internal__onProviderDisconnect","e","__internal__onProviderError","__internal__onProviderConnect","_options","noInitWarn","warn","isConnected","catch","_initRegistry","version","metadata","chainProps","clearCache","setChainProperties","getChainProperties","register","specName","specVersion","setHasher","knownTypes","typesBundle","typesAlias","setMetadata","undefined","signedExtensions","_getDefaultRegistry","find","isDefault","at","knownVersion","u8aHash","u8aHex","_createDecorated","decoratedApi","_createBlockRegistry","header","state","getMetadata","raw","parentHash","runtimeChain","_runtimeChain","Error","result","counter","lastBlockHash","runtimeVersion","push","_cacheBlockRegistryProgress","key","creator","waiting","Promise","resolve","reject","then","error","_getBlockRegistryViaVersion","existingViaVersion","eq","_getBlockRegistryViaHash","_genesisHash","_runtimeVersion","createType","number","getHeader","isEmpty","firstVersion","lastVersion","apis","getRuntimeVersion","toHex","_loadMeta","_isReady","_unsubscribeUpdates","_runtimeMetadata","_metaFromSource","_metaFromChain","_initFromMeta","_extrinsicType","extrinsicVersion","sections","Object","keys","rpcs","s","scount","length","section","methods","m","mcount","_filterRpc","genesisHash","runtimeMetadata","_subscribeUpdates","subscribeRuntimeVersion","pipe","log","transactionVersion","thisRegistry","_injectMetadata","subscribe","optMetadata","rpcMethods","chainMetadata","all","system","properties","metadataKey","getUniqTypes","throwOnUnknown","asLatest","extrinsic","toNumber","extrinsicType","derive","_decorateDeriveRx","_derive","_decorateDerive","_subscribeHealth","_unsubscribeHealth","setInterval","health","clearInterval","unsubscribe","_unsubscribe","_isConnected","next","emit","cryptoReady","initWasm","hasMeta","_error","message"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api/base/Init.js"],"sourcesContent":["import { firstValueFrom, map, of, switchMap } from 'rxjs';\nimport { Metadata, TypeRegistry } from '@polkadot/types';\nimport { getSpecAlias, getSpecExtensions, getSpecHasher, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assertReturn, BN_ZERO, isUndefined, logger, noop, objectSpread, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { Decorate } from './Decorate.js';\nconst KEEPALIVE_INTERVAL = 10000;\nconst WITH_VERSION_SHORTCUT = false;\nconst l = logger('api/init');\nfunction textToString(t) {\n    return t.toString();\n}\nexport class Init extends Decorate {\n    __internal__atLast = null;\n    __internal__healthTimer = null;\n    __internal__registries = [];\n    __internal__updateSub = null;\n    __internal__waitingRegistries = {};\n    constructor(options, type, decorateMethod) {\n        super(options, type, decorateMethod);\n        // all injected types added to the registry for overrides\n        this.registry.setKnownTypes(options);\n        // We only register the types (global) if this is not a cloned instance.\n        // Do right up-front, so we get in the user types before we are actually\n        // doing anything on-chain, this ensures we have the overrides in-place\n        if (!options.source) {\n            this.registerTypes(options.types);\n        }\n        else {\n            this.__internal__registries = options.source.__internal__registries;\n        }\n        this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n        this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n        if (this.supportMulti) {\n            this._queryMulti = this._decorateMulti(this._decorateMethod);\n            this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n        }\n        this._rx.signer = options.signer;\n        this._rpcCore.setRegistrySwap((blockHash) => this.getBlockRegistry(blockHash));\n        this._rpcCore.setResolveBlockHash((blockNumber) => firstValueFrom(this._rpcCore.chain.getBlockHash(blockNumber)));\n        if (this.hasSubscriptions) {\n            this._rpcCore.provider.on('disconnected', () => this.__internal__onProviderDisconnect());\n            this._rpcCore.provider.on('error', (e) => this.__internal__onProviderError(e));\n            this._rpcCore.provider.on('connected', () => this.__internal__onProviderConnect());\n        }\n        else if (!this._options.noInitWarn) {\n            l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n        }\n        // If the provider was instantiated earlier, and has already emitted a\n        // 'connected' event, then the `on('connected')` won't fire anymore. To\n        // cater for this case, we call manually `this._onProviderConnect`.\n        if (this._rpcCore.provider.isConnected) {\n            this.__internal__onProviderConnect().catch(noop);\n        }\n    }\n    /**\n     * @description Decorates a registry based on the runtime version\n     */\n    _initRegistry(registry, chain, version, metadata, chainProps) {\n        registry.clearCache();\n        registry.setChainProperties(chainProps || this.registry.getChainProperties());\n        registry.setKnownTypes(this._options);\n        registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion));\n        registry.setHasher(getSpecHasher(registry, chain, version.specName));\n        // for bundled types, pull through the aliases defined\n        if (registry.knownTypes.typesBundle) {\n            registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n        }\n        registry.setMetadata(metadata, undefined, objectSpread({}, getSpecExtensions(registry, chain, version.specName), this._options.signedExtensions), this._options.noInitWarn);\n    }\n    /**\n     * @description Returns the default versioned registry\n     */\n    _getDefaultRegistry() {\n        return assertReturn(this.__internal__registries.find(({ isDefault }) => isDefault), 'Initialization error, cannot find the default registry');\n    }\n    /**\n     * @description Returns a decorated API instance at a specific point in time\n     */\n    async at(blockHash, knownVersion) {\n        const u8aHash = u8aToU8a(blockHash);\n        const u8aHex = u8aToHex(u8aHash);\n        const registry = await this.getBlockRegistry(u8aHash, knownVersion);\n        if (!this.__internal__atLast || this.__internal__atLast[0] !== u8aHex) {\n            // always create a new decoration - since we are pointing to a specific hash, this\n            // means that all queries needs to use that hash (not a previous one already existing)\n            this.__internal__atLast = [u8aHex, this._createDecorated(registry, true, null, u8aHash).decoratedApi];\n        }\n        return this.__internal__atLast[1];\n    }\n    async _createBlockRegistry(blockHash, header, version) {\n        const registry = new TypeRegistry(blockHash);\n        const metadata = new Metadata(registry, await firstValueFrom(this._rpcCore.state.getMetadata.raw(header.parentHash)));\n        const runtimeChain = this._runtimeChain;\n        if (!runtimeChain) {\n            throw new Error('Invalid initializion order, runtimeChain is not available');\n        }\n        this._initRegistry(registry, runtimeChain, version, metadata);\n        // add our new registry\n        const result = { counter: 0, lastBlockHash: blockHash, metadata, registry, runtimeVersion: version };\n        this.__internal__registries.push(result);\n        return result;\n    }\n    _cacheBlockRegistryProgress(key, creator) {\n        // look for waiting resolves\n        let waiting = this.__internal__waitingRegistries[key];\n        if (isUndefined(waiting)) {\n            // nothing waiting, construct new\n            waiting = this.__internal__waitingRegistries[key] = new Promise((resolve, reject) => {\n                creator()\n                    .then((registry) => {\n                    delete this.__internal__waitingRegistries[key];\n                    resolve(registry);\n                })\n                    .catch((error) => {\n                    delete this.__internal__waitingRegistries[key];\n                    reject(error);\n                });\n            });\n        }\n        return waiting;\n    }\n    _getBlockRegistryViaVersion(blockHash, version) {\n        if (version) {\n            // check for pre-existing registries. We also check specName, e.g. it\n            // could be changed like in Westmint with upgrade from shell -> westmint\n            const existingViaVersion = this.__internal__registries.find(({ runtimeVersion: { specName, specVersion } }) => specName.eq(version.specName) &&\n                specVersion.eq(version.specVersion));\n            if (existingViaVersion) {\n                existingViaVersion.counter++;\n                existingViaVersion.lastBlockHash = blockHash;\n                return existingViaVersion;\n            }\n        }\n        return null;\n    }\n    async _getBlockRegistryViaHash(blockHash) {\n        // ensure we have everything required\n        if (!this._genesisHash || !this._runtimeVersion) {\n            throw new Error('Cannot retrieve data on an uninitialized chain');\n        }\n        // We have to assume that on the RPC layer the calls used here does not call back into\n        // the registry swap, so getHeader & getRuntimeVersion should not be historic\n        const header = this.registry.createType('HeaderPartial', this._genesisHash.eq(blockHash)\n            ? { number: BN_ZERO, parentHash: this._genesisHash }\n            : await firstValueFrom(this._rpcCore.chain.getHeader.raw(blockHash)));\n        if (header.parentHash.isEmpty) {\n            throw new Error('Unable to retrieve header and parent from supplied hash');\n        }\n        // get the runtime version, either on-chain or via an known upgrade history\n        const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number);\n        const version = this.registry.createType('RuntimeVersionPartial', WITH_VERSION_SHORTCUT && (firstVersion && (lastVersion ||\n            firstVersion.specVersion.eq(this._runtimeVersion.specVersion)))\n            ? { apis: firstVersion.apis, specName: this._runtimeVersion.specName, specVersion: firstVersion.specVersion }\n            : await firstValueFrom(this._rpcCore.state.getRuntimeVersion.raw(header.parentHash)));\n        return (\n        // try to find via version\n        this._getBlockRegistryViaVersion(blockHash, version) ||\n            // return new or in-flight result\n            await this._cacheBlockRegistryProgress(version.toHex(), () => this._createBlockRegistry(blockHash, header, version)));\n    }\n    /**\n     * @description Sets up a registry based on the block hash defined\n     */\n    async getBlockRegistry(blockHash, knownVersion) {\n        return (\n        // try to find via blockHash\n        this.__internal__registries.find(({ lastBlockHash }) => lastBlockHash && u8aEq(lastBlockHash, blockHash)) ||\n            // try to find via version\n            this._getBlockRegistryViaVersion(blockHash, knownVersion) ||\n            // return new or in-flight result\n            await this._cacheBlockRegistryProgress(u8aToHex(blockHash), () => this._getBlockRegistryViaHash(blockHash)));\n    }\n    async _loadMeta() {\n        // on re-connection to the same chain, we don't want to re-do everything from chain again\n        if (this._isReady) {\n            return true;\n        }\n        this._unsubscribeUpdates();\n        // only load from on-chain if we are not a clone (default path), alternatively\n        // just use the values from the source instance provided\n        [this._genesisHash, this._runtimeMetadata] = this._options.source?._isReady\n            ? await this._metaFromSource(this._options.source)\n            : await this._metaFromChain(this._options.metadata);\n        return this._initFromMeta(this._runtimeMetadata);\n    }\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async _metaFromSource(source) {\n        this._extrinsicType = source.extrinsicVersion;\n        this._runtimeChain = source.runtimeChain;\n        this._runtimeVersion = source.runtimeVersion;\n        // manually build a list of all available methods in this RPC, we are\n        // going to filter on it to align the cloned RPC without making a call\n        const sections = Object.keys(source.rpc);\n        const rpcs = [];\n        for (let s = 0, scount = sections.length; s < scount; s++) {\n            const section = sections[s];\n            const methods = Object.keys(source.rpc[section]);\n            for (let m = 0, mcount = methods.length; m < mcount; m++) {\n                rpcs.push(`${section}_${methods[m]}`);\n            }\n        }\n        this._filterRpc(rpcs, getSpecRpc(this.registry, source.runtimeChain, source.runtimeVersion.specName));\n        return [source.genesisHash, source.runtimeMetadata];\n    }\n    // subscribe to metadata updates, inject the types on changes\n    _subscribeUpdates() {\n        if (this.__internal__updateSub || !this.hasSubscriptions) {\n            return;\n        }\n        this.__internal__updateSub = this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap((version) => \n        // only retrieve the metadata when the on-chain version has been changed\n        this._runtimeVersion?.specVersion.eq(version.specVersion)\n            ? of(false)\n            : this._rpcCore.state.getMetadata().pipe(map((metadata) => {\n                l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n                this._runtimeMetadata = metadata;\n                this._runtimeVersion = version;\n                this._rx.runtimeVersion = version;\n                // update the default registry version\n                const thisRegistry = this._getDefaultRegistry();\n                const runtimeChain = this._runtimeChain;\n                if (!runtimeChain) {\n                    throw new Error('Invalid initializion order, runtimeChain is not available');\n                }\n                // setup the data as per the current versions\n                thisRegistry.metadata = metadata;\n                thisRegistry.runtimeVersion = version;\n                this._initRegistry(this.registry, runtimeChain, version, metadata);\n                this._injectMetadata(thisRegistry, true);\n                return true;\n            })))).subscribe();\n    }\n    async _metaFromChain(optMetadata) {\n        const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata] = await Promise.all([\n            firstValueFrom(this._rpcCore.chain.getBlockHash(0)),\n            firstValueFrom(this._rpcCore.state.getRuntimeVersion()),\n            firstValueFrom(this._rpcCore.system.chain()),\n            firstValueFrom(this._rpcCore.system.properties()),\n            firstValueFrom(this._rpcCore.rpc.methods()),\n            optMetadata\n                ? Promise.resolve(null)\n                : firstValueFrom(this._rpcCore.state.getMetadata())\n        ]);\n        // set our chain version & genesisHash as returned\n        this._runtimeChain = chain;\n        this._runtimeVersion = runtimeVersion;\n        this._rx.runtimeVersion = runtimeVersion;\n        // retrieve metadata, either from chain  or as pass-in via options\n        const metadataKey = `${genesisHash.toHex() || '0x'}-${runtimeVersion.specVersion.toString()}`;\n        const metadata = chainMetadata || (optMetadata?.[metadataKey]\n            ? new Metadata(this.registry, optMetadata[metadataKey])\n            : await firstValueFrom(this._rpcCore.state.getMetadata()));\n        // initializes the registry & RPC\n        this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n        this._filterRpc(rpcMethods.methods.map(textToString), getSpecRpc(this.registry, chain, runtimeVersion.specName));\n        this._subscribeUpdates();\n        // setup the initial registry, when we have none\n        if (!this.__internal__registries.length) {\n            this.__internal__registries.push({ counter: 0, isDefault: true, metadata, registry: this.registry, runtimeVersion });\n        }\n        // get unique types & validate\n        metadata.getUniqTypes(this._options.throwOnUnknown || false);\n        return [genesisHash, metadata];\n    }\n    _initFromMeta(metadata) {\n        const runtimeVersion = this._runtimeVersion;\n        if (!runtimeVersion) {\n            throw new Error('Invalid initializion order, runtimeVersion is not available');\n        }\n        this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();\n        this._rx.extrinsicType = this._extrinsicType;\n        this._rx.genesisHash = this._genesisHash;\n        this._rx.runtimeVersion = runtimeVersion;\n        // inject metadata and adjust the types as detected\n        this._injectMetadata(this._getDefaultRegistry(), true);\n        // derive is last, since it uses the decorated rx\n        this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n        this._derive = this._decorateDerive(this._decorateMethod);\n        return true;\n    }\n    _subscribeHealth() {\n        this._unsubscribeHealth();\n        // Only enable the health keepalive on WS, not needed on HTTP\n        this.__internal__healthTimer = this.hasSubscriptions\n            ? setInterval(() => {\n                firstValueFrom(this._rpcCore.system.health.raw()).catch(noop);\n            }, KEEPALIVE_INTERVAL)\n            : null;\n    }\n    _unsubscribeHealth() {\n        if (this.__internal__healthTimer) {\n            clearInterval(this.__internal__healthTimer);\n            this.__internal__healthTimer = null;\n        }\n    }\n    _unsubscribeUpdates() {\n        if (this.__internal__updateSub) {\n            this.__internal__updateSub.unsubscribe();\n            this.__internal__updateSub = null;\n        }\n    }\n    _unsubscribe() {\n        this._unsubscribeHealth();\n        this._unsubscribeUpdates();\n    }\n    async __internal__onProviderConnect() {\n        this._isConnected.next(true);\n        this.emit('connected');\n        try {\n            const cryptoReady = this._options.initWasm === false\n                ? true\n                : await cryptoWaitReady();\n            const hasMeta = await this._loadMeta();\n            this._subscribeHealth();\n            if (hasMeta && !this._isReady && cryptoReady) {\n                this._isReady = true;\n                this.emit('ready', this);\n            }\n        }\n        catch (_error) {\n            const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n            l.error(error);\n            this.emit('error', error);\n        }\n    }\n    __internal__onProviderDisconnect() {\n        this._isConnected.next(false);\n        this._unsubscribe();\n        this.emit('disconnected');\n    }\n    __internal__onProviderError(error) {\n        this.emit('error', error);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}