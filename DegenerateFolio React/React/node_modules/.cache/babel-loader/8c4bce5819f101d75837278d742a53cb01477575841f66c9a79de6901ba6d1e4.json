{"ast":null,"code":"import { curves } from \"../const.mjs\";\nclass BezierUtils {\n  /**\n   * Calculate length of bezier curve.\n   * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n   * Therefore numerical solution is used.\n   * @private\n   * @param fromX - Starting point x\n   * @param fromY - Starting point y\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param cpX2 - Second Control point x\n   * @param cpY2 - Second Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @returns - Length of bezier curve\n   */\n  static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {\n    let result = 0,\n      t = 0,\n      t2 = 0,\n      t3 = 0,\n      nt = 0,\n      nt2 = 0,\n      nt3 = 0,\n      x = 0,\n      y = 0,\n      dx = 0,\n      dy = 0,\n      prevX = fromX,\n      prevY = fromY;\n    for (let i = 1; i <= 10; ++i) t = i / 10, t2 = t * t, t3 = t2 * t, nt = 1 - t, nt2 = nt * nt, nt3 = nt2 * nt, x = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX, y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY, dx = prevX - x, dy = prevY - y, prevX = x, prevY = y, result += Math.sqrt(dx * dx + dy * dy);\n    return result;\n  }\n  /**\n   * Calculate the points for a bezier curve and then draws it.\n   *\n   * Ignored from docs since it is not directly exposed.\n   * @ignore\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param cpX2 - Second Control point x\n   * @param cpY2 - Second Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @param points - Path array to push points into\n   */\n  static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {\n    const fromX = points[points.length - 2],\n      fromY = points[points.length - 1];\n    points.length -= 2;\n    const n = curves._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));\n    let dt = 0,\n      dt2 = 0,\n      dt3 = 0,\n      t2 = 0,\n      t3 = 0;\n    points.push(fromX, fromY);\n    for (let i = 1, j = 0; i <= n; ++i) j = i / n, dt = 1 - j, dt2 = dt * dt, dt3 = dt2 * dt, t2 = j * j, t3 = t2 * j, points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n  }\n}\nexport { BezierUtils };","map":{"version":3,"names":["BezierUtils","curveLength","fromX","fromY","cpX","cpY","cpX2","cpY2","toX","toY","result","t","t2","t3","nt","nt2","nt3","x","y","dx","dy","prevX","prevY","i","Math","sqrt","curveTo","points","length","n","curves","_segmentsCount","dt","dt2","dt3","push","j"],"sources":["/home/ryoitsu/node_modules/@pixi/graphics/src/utils/BezierUtils.ts"],"sourcesContent":["import { curves } from '../const';\n\n/**\n * Utilities for bezier curves\n * @private\n */\nexport class BezierUtils\n{\n    /**\n     * Calculate length of bezier curve.\n     * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n     * Therefore numerical solution is used.\n     * @private\n     * @param fromX - Starting point x\n     * @param fromY - Starting point y\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @returns - Length of bezier curve\n     */\n    static curveLength(\n        fromX: number, fromY: number,\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number): number\n    {\n        const n = 10;\n        let result = 0.0;\n        let t = 0.0;\n        let t2 = 0.0;\n        let t3 = 0.0;\n        let nt = 0.0;\n        let nt2 = 0.0;\n        let nt3 = 0.0;\n        let x = 0.0;\n        let y = 0.0;\n        let dx = 0.0;\n        let dy = 0.0;\n        let prevX = fromX;\n        let prevY = fromY;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            t = i / n;\n            t2 = t * t;\n            t3 = t2 * t;\n            nt = (1.0 - t);\n            nt2 = nt * nt;\n            nt3 = nt2 * nt;\n\n            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);\n            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);\n            dx = prevX - x;\n            dy = prevY - y;\n            prevX = x;\n            prevY = y;\n\n            result += Math.sqrt((dx * dx) + (dy * dy));\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * Ignored from docs since it is not directly exposed.\n     * @ignore\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @param points - Path array to push points into\n     */\n    static curveTo(\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number,\n        points: Array<number>): void\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        points.length -= 2;\n\n        const n = curves._segmentsCount(\n            BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n        );\n\n        let dt = 0;\n        let dt2 = 0;\n        let dt3 = 0;\n        let t2 = 0;\n        let t3 = 0;\n\n        points.push(fromX, fromY);\n\n        for (let i = 1, j = 0; i <= n; ++i)\n        {\n            j = i / n;\n\n            dt = (1 - j);\n            dt2 = dt * dt;\n            dt3 = dt2 * dt;\n\n            t2 = j * j;\n            t3 = t2 * j;\n\n            points.push(\n                (dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX),\n                (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY)\n            );\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}