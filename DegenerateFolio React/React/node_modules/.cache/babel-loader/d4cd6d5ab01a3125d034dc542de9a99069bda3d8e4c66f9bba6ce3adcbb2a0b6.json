{"ast":null,"code":"import { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { CLEAR } from '../const.mjs';\nimport { GlRenderTarget } from '../GlRenderTarget.mjs';\n\"use strict\";\nclass GlRenderTargetAdaptor {\n  constructor() {\n    this._clearColorCache = [0, 0, 0, 0];\n    this._viewPortCache = new Rectangle();\n  }\n  init(renderer, renderTargetSystem) {\n    this._renderer = renderer;\n    this._renderTargetSystem = renderTargetSystem;\n    renderer.runners.contextChange.add(this);\n  }\n  contextChange() {\n    this._clearColorCache = [0, 0, 0, 0];\n    this._viewPortCache = new Rectangle();\n  }\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const renderer = this._renderer;\n    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);\n    const gl = renderer.gl;\n    this.finishRenderPass(sourceRenderSurfaceTexture);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n    renderer.texture.bind(destinationTexture, 0);\n    gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, originDest.x, originDest.y, originSrc.x, originSrc.y, size.width, size.height);\n    return destinationTexture;\n  }\n  startRenderPass(renderTarget, clear = true, clearColor, viewport) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const source = renderTarget.colorTexture;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    let viewPortY = viewport.y;\n    if (renderTarget.isRoot) {\n      viewPortY = source.pixelHeight - viewport.height;\n    }\n    renderTarget.colorTextures.forEach(texture => {\n      this._renderer.texture.unbind(texture);\n    });\n    const gl = this._renderer.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);\n    const viewPortCache = this._viewPortCache;\n    if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {\n      viewPortCache.x = viewport.x;\n      viewPortCache.y = viewPortY;\n      viewPortCache.width = viewport.width;\n      viewPortCache.height = viewport.height;\n      gl.viewport(viewport.x, viewPortY, viewport.width, viewport.height);\n    }\n    if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) {\n      this._initStencil(gpuRenderTarget);\n    }\n    this.clear(renderTarget, clear, clearColor);\n  }\n  finishRenderPass(renderTarget) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (!glRenderTarget.msaa) return;\n    const gl = this._renderer.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);\n    gl.blitFramebuffer(0, 0, glRenderTarget.width, glRenderTarget.height, 0, 0, glRenderTarget.width, glRenderTarget.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);\n  }\n  initGpuRenderTarget(renderTarget) {\n    const renderer = this._renderer;\n    const gl = renderer.gl;\n    const glRenderTarget = new GlRenderTarget();\n    if (renderTarget.colorTexture.resource === renderer.gl.canvas) {\n      glRenderTarget.framebuffer = null;\n      return glRenderTarget;\n    }\n    this._initColor(renderTarget, glRenderTarget);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    return glRenderTarget;\n  }\n  destroyGpuRenderTarget(gpuRenderTarget) {\n    const gl = this._renderer.gl;\n    if (gpuRenderTarget.framebuffer) {\n      gl.deleteFramebuffer(gpuRenderTarget.framebuffer);\n      gpuRenderTarget.framebuffer = null;\n    }\n    if (gpuRenderTarget.resolveTargetFramebuffer) {\n      gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);\n      gpuRenderTarget.resolveTargetFramebuffer = null;\n    }\n    if (gpuRenderTarget.depthStencilRenderBuffer) {\n      gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);\n      gpuRenderTarget.depthStencilRenderBuffer = null;\n    }\n    gpuRenderTarget.msaaRenderBuffer.forEach(renderBuffer => {\n      gl.deleteRenderbuffer(renderBuffer);\n    });\n    gpuRenderTarget.msaaRenderBuffer = null;\n  }\n  clear(_renderTarget, clear, clearColor) {\n    if (!clear) return;\n    const renderTargetSystem = this._renderTargetSystem;\n    if (typeof clear === \"boolean\") {\n      clear = clear ? CLEAR.ALL : CLEAR.NONE;\n    }\n    const gl = this._renderer.gl;\n    if (clear & CLEAR.COLOR) {\n      clearColor ?? (clearColor = renderTargetSystem.defaultClearColor);\n      const clearColorCache = this._clearColorCache;\n      const clearColorArray = clearColor;\n      if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {\n        clearColorCache[0] = clearColorArray[0];\n        clearColorCache[1] = clearColorArray[1];\n        clearColorCache[2] = clearColorArray[2];\n        clearColorCache[3] = clearColorArray[3];\n        gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);\n      }\n    }\n    gl.clear(clear);\n  }\n  resizeGpuRenderTarget(renderTarget) {\n    if (renderTarget.isRoot) return;\n    const renderTargetSystem = this._renderTargetSystem;\n    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    this._resizeColor(renderTarget, glRenderTarget);\n    if (renderTarget.stencil) {\n      this._resizeStencil(glRenderTarget);\n    }\n  }\n  _initColor(renderTarget, glRenderTarget) {\n    const renderer = this._renderer;\n    const gl = renderer.gl;\n    const resolveTargetFramebuffer = gl.createFramebuffer();\n    glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);\n    glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;\n    glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      const source = colorTexture.source;\n      if (source.antialias) {\n        if (renderer.context.supports.msaa) {\n          glRenderTarget.msaa = true;\n        } else {\n          warn(\"[RenderTexture] Antialiasing on textures is not supported in WebGL1\");\n        }\n      }\n      renderer.texture.bindSource(source, 0);\n      const glSource = renderer.texture.getGlSource(source);\n      const glTexture = glSource.texture;\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, 3553,\n      // texture.target,\n      glTexture, 0);\n    });\n    if (glRenderTarget.msaa) {\n      const viewFramebuffer = gl.createFramebuffer();\n      glRenderTarget.framebuffer = viewFramebuffer;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n      renderTarget.colorTextures.forEach((_, i) => {\n        const msaaRenderBuffer = gl.createRenderbuffer();\n        glRenderTarget.msaaRenderBuffer[i] = msaaRenderBuffer;\n      });\n    } else {\n      glRenderTarget.framebuffer = resolveTargetFramebuffer;\n    }\n    this._resizeColor(renderTarget, glRenderTarget);\n  }\n  _resizeColor(renderTarget, glRenderTarget) {\n    const source = renderTarget.colorTexture.source;\n    glRenderTarget.width = source.pixelWidth;\n    glRenderTarget.height = source.pixelHeight;\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      if (i === 0) return;\n      colorTexture.source.resize(source.width, source.height, source._resolution);\n    });\n    if (glRenderTarget.msaa) {\n      const renderer = this._renderer;\n      const gl = renderer.gl;\n      const viewFramebuffer = glRenderTarget.framebuffer;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n      renderTarget.colorTextures.forEach((colorTexture, i) => {\n        const source2 = colorTexture.source;\n        renderer.texture.bindSource(source2, 0);\n        const glSource = renderer.texture.getGlSource(source2);\n        const glInternalFormat = glSource.internalFormat;\n        const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];\n        gl.bindRenderbuffer(gl.RENDERBUFFER, msaaRenderBuffer);\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 4, glInternalFormat, source2.pixelWidth, source2.pixelHeight);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderBuffer);\n      });\n    }\n  }\n  _initStencil(glRenderTarget) {\n    if (glRenderTarget.framebuffer === null) return;\n    const gl = this._renderer.gl;\n    const depthStencilRenderBuffer = gl.createRenderbuffer();\n    glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;\n    gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilRenderBuffer);\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilRenderBuffer);\n    this._resizeStencil(glRenderTarget);\n  }\n  _resizeStencil(glRenderTarget) {\n    const gl = this._renderer.gl;\n    gl.bindRenderbuffer(gl.RENDERBUFFER, glRenderTarget.depthStencilRenderBuffer);\n    if (glRenderTarget.msaa) {\n      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 4, gl.DEPTH24_STENCIL8, glRenderTarget.width, glRenderTarget.height);\n    } else {\n      gl.renderbufferStorage(gl.RENDERBUFFER, this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL, glRenderTarget.width, glRenderTarget.height);\n    }\n  }\n}\nexport { GlRenderTargetAdaptor };","map":{"version":3,"names":["GlRenderTargetAdaptor","constructor","_clearColorCache","_viewPortCache","Rectangle","init","renderer","renderTargetSystem","_renderer","_renderTargetSystem","runners","contextChange","add","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","size","originDest","glRenderTarget","getGpuRenderTarget","gl","finishRenderPass","bindFramebuffer","FRAMEBUFFER","resolveTargetFramebuffer","texture","bind","copyTexSubImage2D","TEXTURE_2D","x","y","width","height","startRenderPass","renderTarget","clear","clearColor","viewport","source","colorTexture","gpuRenderTarget","viewPortY","isRoot","pixelHeight","colorTextures","forEach","unbind","framebuffer","viewPortCache","depthStencilRenderBuffer","stencil","depth","_initStencil","msaa","READ_FRAMEBUFFER","blitFramebuffer","COLOR_BUFFER_BIT","NEAREST","initGpuRenderTarget","GlRenderTarget","resource","canvas","_initColor","destroyGpuRenderTarget","deleteFramebuffer","deleteRenderbuffer","msaaRenderBuffer","renderBuffer","_renderTarget","CLEAR","ALL","NONE","COLOR","defaultClearColor","clearColorCache","clearColorArray","resizeGpuRenderTarget","_resizeColor","_resizeStencil","createFramebuffer","pixelWidth","i","antialias","context","supports","warn","bindSource","glSource","getGlSource","glTexture","framebufferTexture2D","COLOR_ATTACHMENT0","viewFramebuffer","_","createRenderbuffer","resize","_resolution","source2","glInternalFormat","internalFormat","bindRenderbuffer","RENDERBUFFER","renderbufferStorageMultisample","framebufferRenderbuffer","DEPTH_STENCIL_ATTACHMENT","DEPTH24_STENCIL8","renderbufferStorage","webGLVersion","DEPTH_STENCIL"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.ts"],"sourcesContent":["import { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { warn } from '../../../../utils/logging/warn';\nimport { CLEAR } from '../const';\nimport { GlRenderTarget } from '../GlRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { CLEAR_OR_BOOL } from '../const';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGL renderer\n * @memberof rendering\n * @ignore\n */\nexport class GlRenderTargetAdaptor implements RenderTargetAdaptor<GlRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GlRenderTarget>;\n    private _renderer: WebGLRenderer<HTMLCanvasElement>;\n    private _clearColorCache: RgbaArray = [0, 0, 0, 0];\n    private _viewPortCache: Rectangle = new Rectangle();\n\n    public init(renderer: WebGLRenderer, renderTargetSystem: RenderTargetSystem<GlRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n\n        renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._clearColorCache = [0, 0, 0, 0];\n        this._viewPortCache = new Rectangle();\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const renderer = this._renderer;\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);\n        const gl = renderer.gl;\n\n        this.finishRenderPass(sourceRenderSurfaceTexture);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n\n        renderer.texture.bind(destinationTexture, 0);\n\n        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0,\n            originDest.x, originDest.y,\n            originSrc.x,\n            originSrc.y,\n            size.width,\n            size.height\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const source = renderTarget.colorTexture;\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        let viewPortY = viewport.y;\n\n        if (renderTarget.isRoot)\n        {\n            // /TODO this is the same logic?\n            viewPortY = source.pixelHeight - viewport.height;\n        }\n\n        // unbind the current render texture..\n        renderTarget.colorTextures.forEach((texture) =>\n        {\n            this._renderer.texture.unbind(texture);\n        });\n\n        const gl = this._renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);\n\n        const viewPortCache = this._viewPortCache;\n\n        if (viewPortCache.x !== viewport.x\n            || viewPortCache.y !== viewPortY\n            || viewPortCache.width !== viewport.width\n            || viewPortCache.height !== viewport.height)\n        {\n            viewPortCache.x = viewport.x;\n            viewPortCache.y = viewPortY;\n            viewPortCache.width = viewport.width;\n            viewPortCache.height = viewport.height;\n\n            gl.viewport(\n                viewport.x,\n                viewPortY,\n                viewport.width,\n                viewport.height,\n            );\n        }\n\n        // if the stencil buffer has been requested, we need to create a stencil buffer\n        if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth))\n        {\n            this._initStencil(gpuRenderTarget);\n        }\n\n        this.clear(renderTarget, clear, clearColor);\n    }\n\n    public finishRenderPass(renderTarget?: RenderTarget)\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (!glRenderTarget.msaa) return;\n\n        const gl = this._renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);\n\n        gl.blitFramebuffer(\n            0, 0, glRenderTarget.width, glRenderTarget.height,\n            0, 0, glRenderTarget.width, glRenderTarget.height,\n            gl.COLOR_BUFFER_BIT, gl.NEAREST,\n        );\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);\n\n        // dont think we need this anymore? keeping around just in case the wheels fall off\n        // gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GlRenderTarget\n    {\n        const renderer = this._renderer;\n\n        const gl = renderer.gl;\n\n        // do single...\n\n        const glRenderTarget = new GlRenderTarget();\n\n        // we are rendering to the main canvas..\n        if (renderTarget.colorTexture.resource === renderer.gl.canvas)\n        {\n            glRenderTarget.framebuffer = null;\n\n            return glRenderTarget;\n        }\n\n        this._initColor(renderTarget, glRenderTarget);\n\n        // set up a depth texture..\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        return glRenderTarget;\n    }\n\n    public destroyGpuRenderTarget(gpuRenderTarget: GlRenderTarget)\n    {\n        const gl = this._renderer.gl;\n\n        if (gpuRenderTarget.framebuffer)\n        {\n            gl.deleteFramebuffer(gpuRenderTarget.framebuffer);\n            gpuRenderTarget.framebuffer = null;\n        }\n\n        if (gpuRenderTarget.resolveTargetFramebuffer)\n        {\n            gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);\n            gpuRenderTarget.resolveTargetFramebuffer = null;\n        }\n\n        if (gpuRenderTarget.depthStencilRenderBuffer)\n        {\n            gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);\n            gpuRenderTarget.depthStencilRenderBuffer = null;\n        }\n\n        gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) =>\n        {\n            gl.deleteRenderbuffer(renderBuffer);\n        });\n\n        gpuRenderTarget.msaaRenderBuffer = null;\n    }\n\n    public clear(_renderTarget: RenderTarget, clear: CLEAR_OR_BOOL, clearColor?: RgbaArray)\n    {\n        if (!clear) return;\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        // if clear is boolean..\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const gl = this._renderer.gl;\n\n        if (clear & CLEAR.COLOR)\n        {\n            clearColor ??= renderTargetSystem.defaultClearColor;\n\n            const clearColorCache = this._clearColorCache;\n            const clearColorArray = clearColor as number[];\n\n            if (clearColorCache[0] !== clearColorArray[0]\n                || clearColorCache[1] !== clearColorArray[1]\n                || clearColorCache[2] !== clearColorArray[2]\n                || clearColorCache[3] !== clearColorArray[3])\n            {\n                clearColorCache[0] = clearColorArray[0];\n                clearColorCache[1] = clearColorArray[1];\n                clearColorCache[2] = clearColorArray[2];\n                clearColorCache[3] = clearColorArray[3];\n\n                gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);\n            }\n        }\n\n        gl.clear(clear);\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        if (renderTarget.isRoot) return;\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        this._resizeColor(renderTarget, glRenderTarget);\n\n        if (renderTarget.stencil)\n        {\n            this._resizeStencil(glRenderTarget);\n        }\n    }\n\n    private _initColor(renderTarget: RenderTarget, glRenderTarget: GlRenderTarget)\n    {\n        const renderer = this._renderer;\n\n        const gl = renderer.gl;\n        // deal with our outputs..\n        const resolveTargetFramebuffer = gl.createFramebuffer();\n\n        glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;\n\n        // set up the texture..\n        gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);\n\n        glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;\n        glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;\n\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            const source = colorTexture.source;\n\n            if (source.antialias)\n            {\n                if (renderer.context.supports.msaa)\n                {\n                    glRenderTarget.msaa = true;\n                }\n                else\n                {\n                    warn('[RenderTexture] Antialiasing on textures is not supported in WebGL1');\n                }\n            }\n\n            // TODO bindSource could return the glTexture\n            renderer.texture.bindSource(source, 0);\n            const glSource = renderer.texture.getGlSource(source);\n\n            const glTexture = glSource.texture;\n\n            gl.framebufferTexture2D(gl.FRAMEBUFFER,\n                gl.COLOR_ATTACHMENT0 + i,\n                3553, // texture.target,\n                glTexture,\n                0);// mipLevel);\n        });\n\n        if (glRenderTarget.msaa)\n        {\n            const viewFramebuffer = gl.createFramebuffer();\n\n            glRenderTarget.framebuffer = viewFramebuffer;\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n\n            renderTarget.colorTextures.forEach((_, i) =>\n            {\n                const msaaRenderBuffer = gl.createRenderbuffer();\n\n                glRenderTarget.msaaRenderBuffer[i] = msaaRenderBuffer;\n            });\n        }\n        else\n        {\n            glRenderTarget.framebuffer = resolveTargetFramebuffer;\n        }\n\n        this._resizeColor(renderTarget, glRenderTarget);\n    }\n\n    private _resizeColor(renderTarget: RenderTarget, glRenderTarget: GlRenderTarget)\n    {\n        const source = renderTarget.colorTexture.source;\n\n        glRenderTarget.width = source.pixelWidth;\n        glRenderTarget.height = source.pixelHeight;\n\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            // nno need to resize the first texture..\n            if (i === 0) return;\n\n            colorTexture.source.resize(source.width, source.height, source._resolution);\n        });\n\n        if (glRenderTarget.msaa)\n        {\n            const renderer = this._renderer;\n            const gl = renderer.gl;\n\n            const viewFramebuffer = glRenderTarget.framebuffer;\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const source = colorTexture.source;\n\n                renderer.texture.bindSource(source, 0);\n                const glSource = renderer.texture.getGlSource(source);\n\n                const glInternalFormat = glSource.internalFormat;\n\n                const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];\n\n                gl.bindRenderbuffer(\n                    gl.RENDERBUFFER,\n                    msaaRenderBuffer\n                );\n\n                gl.renderbufferStorageMultisample(\n                    gl.RENDERBUFFER,\n                    4,\n                    glInternalFormat,\n                    source.pixelWidth,\n                    source.pixelHeight\n                );\n\n                gl.framebufferRenderbuffer(\n                    gl.FRAMEBUFFER,\n                    gl.COLOR_ATTACHMENT0 + i,\n                    gl.RENDERBUFFER,\n                    msaaRenderBuffer\n                );\n            });\n        }\n    }\n\n    private _initStencil(glRenderTarget: GlRenderTarget)\n    {\n        // this already exists on the default screen\n        if (glRenderTarget.framebuffer === null) return;\n\n        const gl = this._renderer.gl;\n\n        const depthStencilRenderBuffer = gl.createRenderbuffer();\n\n        glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;\n\n        gl.bindRenderbuffer(\n            gl.RENDERBUFFER,\n            depthStencilRenderBuffer\n        );\n\n        gl.framebufferRenderbuffer(\n            gl.FRAMEBUFFER,\n            gl.DEPTH_STENCIL_ATTACHMENT,\n            gl.RENDERBUFFER,\n            depthStencilRenderBuffer\n        );\n\n        // TDO DO>>\n        this._resizeStencil(glRenderTarget);\n    }\n\n    private _resizeStencil(glRenderTarget: GlRenderTarget)\n    {\n        const gl = this._renderer.gl;\n\n        gl.bindRenderbuffer(\n            gl.RENDERBUFFER,\n            glRenderTarget.depthStencilRenderBuffer\n        );\n\n        if (glRenderTarget.msaa)\n        {\n            gl.renderbufferStorageMultisample(\n                gl.RENDERBUFFER,\n                4,\n                gl.DEPTH24_STENCIL8,\n                glRenderTarget.width,\n                glRenderTarget.height\n            );\n        }\n        else\n        {\n            gl.renderbufferStorage(\n                gl.RENDERBUFFER,\n                this._renderer.context.webGLVersion === 2\n                    ? gl.DEPTH24_STENCIL8\n                    : gl.DEPTH_STENCIL,\n                glRenderTarget.width,\n                glRenderTarget.height\n            );\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}