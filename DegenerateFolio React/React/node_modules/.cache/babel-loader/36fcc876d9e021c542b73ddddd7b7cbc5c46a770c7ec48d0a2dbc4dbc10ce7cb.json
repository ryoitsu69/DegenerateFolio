{"ast":null,"code":"import { Observable, publishReplay, refCount } from 'rxjs';\nimport { rpcDefinitions } from '@polkadot/types';\nimport { hexToU8a, isFunction, isNull, isUndefined, lazyMethod, logger, memoize, objectSpread, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { drr, refCountDelay } from './util/index.js';\nexport { packageInfo } from './packageInfo.js';\nexport * from './util/index.js';\nconst l = logger('rpc-core');\nconst EMPTY_META = {\n  fallback: undefined,\n  modifier: {\n    isOptional: true\n  },\n  type: {\n    asMap: {\n      linked: {\n        isTrue: false\n      }\n    },\n    isMap: false\n  }\n};\n/** @internal */\nfunction logErrorMessage(method, {\n  noErrorLog,\n  params,\n  type\n}, error) {\n  if (noErrorLog) {\n    return;\n  }\n  l.error(`${method}(${params.map(({\n    isOptional,\n    name,\n    type\n  }) => `${name}${isOptional ? '?' : ''}: ${type}`).join(', ')}): ${type}:: ${error.message}`);\n}\nfunction isTreatAsHex(key) {\n  // :code is problematic - it does not have the length attached, which is\n  // unlike all other storage entries where it is indeed properly encoded\n  return ['0x3a636f6465'].includes(key.toHex());\n}\n/**\n * @name Rpc\n * @summary The API may use a HTTP or WebSockets provider.\n * @description It allows for querying a Polkadot Client Node.\n * WebSockets provider is recommended since HTTP provider only supports basic querying.\n *\n * ```mermaid\n * graph LR;\n *   A[Api] --> |WebSockets| B[WsProvider];\n *   B --> |endpoint| C[ws://127.0.0.1:9944]\n * ```\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Rpc from '@polkadot/rpc-core';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const rpc = new Rpc(provider);\n * ```\n */\nexport class RpcCore {\n  __internal__instanceId;\n  __internal__isPedantic;\n  __internal__registryDefault;\n  __internal__storageCache = new Map();\n  __internal__storageCacheHits = 0;\n  __internal__storageCacheSize = 0;\n  __internal__getBlockRegistry;\n  __internal__getBlockHash;\n  mapping = new Map();\n  provider;\n  sections = [];\n  /**\n   * @constructor\n   * Default constructor for the core RPC handler\n   * @param  {ProviderInterface} provider An API provider using any of the supported providers (HTTP, SC or WebSocket)\n   */\n  constructor(instanceId, registry, {\n    isPedantic = true,\n    provider,\n    userRpc = {}\n  }) {\n    if (!provider || !isFunction(provider.send)) {\n      throw new Error('Expected Provider to API create');\n    }\n    this.__internal__instanceId = instanceId;\n    this.__internal__isPedantic = isPedantic;\n    this.__internal__registryDefault = registry;\n    this.provider = provider;\n    const sectionNames = Object.keys(rpcDefinitions);\n    // these are the base keys (i.e. part of jsonrpc)\n    this.sections.push(...sectionNames);\n    // decorate all interfaces, defined and user on this instance\n    this.addUserInterfaces(userRpc);\n  }\n  /**\n   * @description Returns the connected status of a provider\n   */\n  get isConnected() {\n    return this.provider.isConnected;\n  }\n  /**\n   * @description Manually connect from the attached provider\n   */\n  connect() {\n    return this.provider.connect();\n  }\n  /**\n   * @description Manually disconnect from the attached provider\n   */\n  disconnect() {\n    return this.provider.disconnect();\n  }\n  /**\n   * @description Returns the underlying core stats, including those from teh provider\n   */\n  get stats() {\n    const stats = this.provider.stats;\n    return stats ? {\n      ...stats,\n      core: {\n        cacheHits: this.__internal__storageCacheHits,\n        cacheSize: this.__internal__storageCacheSize\n      }\n    } : undefined;\n  }\n  /**\n   * @description Sets a registry swap (typically from Api)\n   */\n  setRegistrySwap(registrySwap) {\n    this.__internal__getBlockRegistry = memoize(registrySwap, {\n      getInstanceId: () => this.__internal__instanceId\n    });\n  }\n  /**\n   * @description Sets a function to resolve block hash from block number\n   */\n  setResolveBlockHash(resolveBlockHash) {\n    this.__internal__getBlockHash = memoize(resolveBlockHash, {\n      getInstanceId: () => this.__internal__instanceId\n    });\n  }\n  addUserInterfaces(userRpc) {\n    // add any extra user-defined sections\n    this.sections.push(...Object.keys(userRpc).filter(k => !this.sections.includes(k)));\n    for (let s = 0, scount = this.sections.length; s < scount; s++) {\n      const section = this.sections[s];\n      const defs = objectSpread({}, rpcDefinitions[section], userRpc[section]);\n      const methods = Object.keys(defs);\n      for (let m = 0, mcount = methods.length; m < mcount; m++) {\n        const method = methods[m];\n        const def = defs[method];\n        const jsonrpc = def.endpoint || `${section}_${method}`;\n        if (!this.mapping.has(jsonrpc)) {\n          const isSubscription = !!def.pubsub;\n          if (!this[section]) {\n            this[section] = {};\n          }\n          this.mapping.set(jsonrpc, objectSpread({}, def, {\n            isSubscription,\n            jsonrpc,\n            method,\n            section\n          }));\n          lazyMethod(this[section], method, () => isSubscription ? this._createMethodSubscribe(section, method, def) : this._createMethodSend(section, method, def));\n        }\n      }\n    }\n  }\n  _memomize(creator, def) {\n    const memoOpts = {\n      getInstanceId: () => this.__internal__instanceId\n    };\n    const memoized = memoize(creator(true), memoOpts);\n    memoized.raw = memoize(creator(false), memoOpts);\n    memoized.meta = def;\n    return memoized;\n  }\n  _formatResult(isScale, registry, blockHash, method, def, params, result) {\n    return isScale ? this._formatOutput(registry, blockHash, method, def, params, result) : result;\n  }\n  _createMethodSend(section, method, def) {\n    const rpcName = def.endpoint || `${section}_${method}`;\n    const hashIndex = def.params.findIndex(({\n      isHistoric\n    }) => isHistoric);\n    let memoized = null;\n    // execute the RPC call, doing a registry swap for historic as applicable\n    const callWithRegistry = async (isScale, values) => {\n      const blockId = hashIndex === -1 ? null : values[hashIndex];\n      const blockHash = blockId && def.params[hashIndex].type === 'BlockNumber' ? await this.__internal__getBlockHash?.(blockId) : blockId;\n      const {\n        registry\n      } = isScale && blockHash && this.__internal__getBlockRegistry ? await this.__internal__getBlockRegistry(u8aToU8a(blockHash)) : {\n        registry: this.__internal__registryDefault\n      };\n      const params = this._formatParams(registry, null, def, values);\n      // only cache .at(<blockHash>) queries, e.g. where valid blockHash was supplied\n      const result = await this.provider.send(rpcName, params.map(p => p.toJSON()), !!blockHash);\n      return this._formatResult(isScale, registry, blockHash, method, def, params, result);\n    };\n    const creator = isScale => (...values) => {\n      const isDelayed = isScale && hashIndex !== -1 && !!values[hashIndex];\n      return new Observable(observer => {\n        callWithRegistry(isScale, values).then(value => {\n          observer.next(value);\n          observer.complete();\n        }).catch(error => {\n          logErrorMessage(method, def, error);\n          observer.error(error);\n          observer.complete();\n        });\n        return () => {\n          // delete old results from cache\n          if (isScale) {\n            memoized?.unmemoize(...values);\n          } else {\n            memoized?.raw.unmemoize(...values);\n          }\n        };\n      }).pipe(\n      // eslint-disable-next-line deprecation/deprecation\n      publishReplay(1),\n      // create a Replay(1)\n      isDelayed ? refCountDelay() // Unsubscribe after delay\n      // eslint-disable-next-line deprecation/deprecation\n      : refCount());\n    };\n    memoized = this._memomize(creator, def);\n    return memoized;\n  }\n  // create a subscriptor, it subscribes once and resolves with the id as subscribe\n  _createSubscriber({\n    paramsJson,\n    subName,\n    subType,\n    update\n  }, errorHandler) {\n    return new Promise((resolve, reject) => {\n      this.provider.subscribe(subType, subName, paramsJson, update).then(resolve).catch(error => {\n        errorHandler(error);\n        reject(error);\n      });\n    });\n  }\n  _createMethodSubscribe(section, method, def) {\n    const [updateType, subMethod, unsubMethod] = def.pubsub;\n    const subName = `${section}_${subMethod}`;\n    const unsubName = `${section}_${unsubMethod}`;\n    const subType = `${section}_${updateType}`;\n    let memoized = null;\n    const creator = isScale => (...values) => {\n      return new Observable(observer => {\n        // Have at least an empty promise, as used in the unsubscribe\n        let subscriptionPromise = Promise.resolve(null);\n        const registry = this.__internal__registryDefault;\n        const errorHandler = error => {\n          logErrorMessage(method, def, error);\n          observer.error(error);\n        };\n        try {\n          const params = this._formatParams(registry, null, def, values);\n          const update = (error, result) => {\n            if (error) {\n              logErrorMessage(method, def, error);\n              return;\n            }\n            try {\n              observer.next(this._formatResult(isScale, registry, null, method, def, params, result));\n            } catch (error) {\n              observer.error(error);\n            }\n          };\n          subscriptionPromise = this._createSubscriber({\n            paramsJson: params.map(p => p.toJSON()),\n            subName,\n            subType,\n            update\n          }, errorHandler);\n        } catch (error) {\n          errorHandler(error);\n        }\n        // Teardown logic\n        return () => {\n          // Delete from cache, so old results don't hang around\n          if (isScale) {\n            memoized?.unmemoize(...values);\n          } else {\n            memoized?.raw.unmemoize(...values);\n          }\n          // Unsubscribe from provider\n          subscriptionPromise.then(subscriptionId => isNull(subscriptionId) ? Promise.resolve(false) : this.provider.unsubscribe(subType, unsubName, subscriptionId)).catch(error => logErrorMessage(method, def, error));\n        };\n      }).pipe(drr());\n    };\n    memoized = this._memomize(creator, def);\n    return memoized;\n  }\n  _formatParams(registry, blockHash, def, inputs) {\n    const count = inputs.length;\n    const reqCount = def.params.filter(({\n      isOptional\n    }) => !isOptional).length;\n    if (count < reqCount || count > def.params.length) {\n      throw new Error(`Expected ${def.params.length} parameters${reqCount === def.params.length ? '' : ` (${def.params.length - reqCount} optional)`}, ${count} found instead`);\n    }\n    const params = new Array(count);\n    for (let i = 0; i < count; i++) {\n      params[i] = registry.createTypeUnsafe(def.params[i].type, [inputs[i]], {\n        blockHash\n      });\n    }\n    return params;\n  }\n  _formatOutput(registry, blockHash, method, rpc, params, result) {\n    if (rpc.type === 'StorageData') {\n      const key = params[0];\n      return this._formatStorageData(registry, blockHash, key, result);\n    } else if (rpc.type === 'StorageChangeSet') {\n      const keys = params[0];\n      return keys ? this._formatStorageSet(registry, result.block, keys, result.changes) : registry.createType('StorageChangeSet', result);\n    } else if (rpc.type === 'Vec<StorageChangeSet>') {\n      const jsonSet = result;\n      const count = jsonSet.length;\n      const mapped = new Array(count);\n      for (let i = 0; i < count; i++) {\n        const {\n          block,\n          changes\n        } = jsonSet[i];\n        mapped[i] = [registry.createType('BlockHash', block), this._formatStorageSet(registry, block, params[0], changes)];\n      }\n      // we only query at a specific block, not a range - flatten\n      return method === 'queryStorageAt' ? mapped[0][1] : mapped;\n    }\n    return registry.createTypeUnsafe(rpc.type, [result], {\n      blockHash\n    });\n  }\n  _formatStorageData(registry, blockHash, key, value) {\n    const isEmpty = isNull(value);\n    // we convert to Uint8Array since it maps to the raw encoding, all\n    // data will be correctly encoded (incl. numbers, excl. :code)\n    const input = isEmpty ? null : isTreatAsHex(key) ? value : u8aToU8a(value);\n    return this._newType(registry, blockHash, key, input, isEmpty);\n  }\n  _formatStorageSet(registry, blockHash, keys, changes) {\n    // For StorageChangeSet, the changes has the [key, value] mappings\n    const count = keys.length;\n    const withCache = count !== 1;\n    const values = new Array(count);\n    // multiple return values (via state.storage subscription), decode the\n    // values one at a time, all based on the supplied query types\n    for (let i = 0; i < count; i++) {\n      values[i] = this._formatStorageSetEntry(registry, blockHash, keys[i], changes, withCache, i);\n    }\n    return values;\n  }\n  _formatStorageSetEntry(registry, blockHash, key, changes, withCache, entryIndex) {\n    const hexKey = key.toHex();\n    const found = changes.find(([key]) => key === hexKey);\n    const isNotFound = isUndefined(found);\n    // if we don't find the value, this is our fallback\n    //   - in the case of an array of values, fill the hole from the cache\n    //   - if a single result value, don't fill - it is not an update hole\n    //   - fallback to an empty option in all cases\n    if (isNotFound && withCache) {\n      const cached = this.__internal__storageCache.get(hexKey);\n      if (cached) {\n        this.__internal__storageCacheHits++;\n        return cached;\n      }\n    }\n    const value = isNotFound ? null : found[1];\n    const isEmpty = isNull(value);\n    const input = isEmpty || isTreatAsHex(key) ? value : u8aToU8a(value);\n    const codec = this._newType(registry, blockHash, key, input, isEmpty, entryIndex);\n    // store the retrieved result - the only issue with this cache is that there is no\n    // clearing of it, so very long running processes (not just a couple of hours, longer)\n    // will increase memory beyond what is allowed.\n    this.__internal__storageCache.set(hexKey, codec);\n    this.__internal__storageCacheSize++;\n    return codec;\n  }\n  _newType(registry, blockHash, key, input, isEmpty, entryIndex = -1) {\n    // single return value (via state.getStorage), decode the value based on the\n    // outputType that we have specified. Fallback to Raw on nothing\n    const type = key.outputType || 'Raw';\n    const meta = key.meta || EMPTY_META;\n    const entryNum = entryIndex === -1 ? '' : ` entry ${entryIndex}:`;\n    try {\n      return registry.createTypeUnsafe(type, [isEmpty ? meta.fallback\n      // For old-style Linkage, we add an empty linkage at the end\n      ? type.includes('Linkage<') ? u8aConcat(hexToU8a(meta.fallback.toHex()), new Uint8Array(2)) : hexToU8a(meta.fallback.toHex()) : undefined : meta.modifier.isOptional ? registry.createTypeUnsafe(type, [input], {\n        blockHash,\n        isPedantic: this.__internal__isPedantic\n      }) : input], {\n        blockHash,\n        isFallback: isEmpty && !!meta.fallback,\n        isOptional: meta.modifier.isOptional,\n        isPedantic: this.__internal__isPedantic && !meta.modifier.isOptional\n      });\n    } catch (error) {\n      throw new Error(`Unable to decode storage ${key.section || 'unknown'}.${key.method || 'unknown'}:${entryNum}: ${error.message}`);\n    }\n  }\n}","map":{"version":3,"names":["Observable","publishReplay","refCount","rpcDefinitions","hexToU8a","isFunction","isNull","isUndefined","lazyMethod","logger","memoize","objectSpread","u8aConcat","u8aToU8a","drr","refCountDelay","packageInfo","l","EMPTY_META","fallback","undefined","modifier","isOptional","type","asMap","linked","isTrue","isMap","logErrorMessage","method","noErrorLog","params","error","map","name","join","message","isTreatAsHex","key","includes","toHex","RpcCore","__internal__instanceId","__internal__isPedantic","__internal__registryDefault","__internal__storageCache","Map","__internal__storageCacheHits","__internal__storageCacheSize","__internal__getBlockRegistry","__internal__getBlockHash","mapping","provider","sections","constructor","instanceId","registry","isPedantic","userRpc","send","Error","sectionNames","Object","keys","push","addUserInterfaces","isConnected","connect","disconnect","stats","core","cacheHits","cacheSize","setRegistrySwap","registrySwap","getInstanceId","setResolveBlockHash","resolveBlockHash","filter","k","s","scount","length","section","defs","methods","m","mcount","def","jsonrpc","endpoint","has","isSubscription","pubsub","set","_createMethodSubscribe","_createMethodSend","_memomize","creator","memoOpts","memoized","raw","meta","_formatResult","isScale","blockHash","result","_formatOutput","rpcName","hashIndex","findIndex","isHistoric","callWithRegistry","values","blockId","_formatParams","p","toJSON","isDelayed","observer","then","value","next","complete","catch","unmemoize","pipe","_createSubscriber","paramsJson","subName","subType","update","errorHandler","Promise","resolve","reject","subscribe","updateType","subMethod","unsubMethod","unsubName","subscriptionPromise","subscriptionId","unsubscribe","inputs","count","reqCount","Array","i","createTypeUnsafe","rpc","_formatStorageData","_formatStorageSet","block","changes","createType","jsonSet","mapped","isEmpty","input","_newType","withCache","_formatStorageSetEntry","entryIndex","hexKey","found","find","isNotFound","cached","get","codec","outputType","entryNum","Uint8Array","isFallback"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/rpc-core/bundle.js"],"sourcesContent":["import { Observable, publishReplay, refCount } from 'rxjs';\nimport { rpcDefinitions } from '@polkadot/types';\nimport { hexToU8a, isFunction, isNull, isUndefined, lazyMethod, logger, memoize, objectSpread, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { drr, refCountDelay } from './util/index.js';\nexport { packageInfo } from './packageInfo.js';\nexport * from './util/index.js';\nconst l = logger('rpc-core');\nconst EMPTY_META = {\n    fallback: undefined,\n    modifier: { isOptional: true },\n    type: {\n        asMap: { linked: { isTrue: false } },\n        isMap: false\n    }\n};\n/** @internal */\nfunction logErrorMessage(method, { noErrorLog, params, type }, error) {\n    if (noErrorLog) {\n        return;\n    }\n    l.error(`${method}(${params.map(({ isOptional, name, type }) => `${name}${isOptional ? '?' : ''}: ${type}`).join(', ')}): ${type}:: ${error.message}`);\n}\nfunction isTreatAsHex(key) {\n    // :code is problematic - it does not have the length attached, which is\n    // unlike all other storage entries where it is indeed properly encoded\n    return ['0x3a636f6465'].includes(key.toHex());\n}\n/**\n * @name Rpc\n * @summary The API may use a HTTP or WebSockets provider.\n * @description It allows for querying a Polkadot Client Node.\n * WebSockets provider is recommended since HTTP provider only supports basic querying.\n *\n * ```mermaid\n * graph LR;\n *   A[Api] --> |WebSockets| B[WsProvider];\n *   B --> |endpoint| C[ws://127.0.0.1:9944]\n * ```\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Rpc from '@polkadot/rpc-core';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const rpc = new Rpc(provider);\n * ```\n */\nexport class RpcCore {\n    __internal__instanceId;\n    __internal__isPedantic;\n    __internal__registryDefault;\n    __internal__storageCache = new Map();\n    __internal__storageCacheHits = 0;\n    __internal__storageCacheSize = 0;\n    __internal__getBlockRegistry;\n    __internal__getBlockHash;\n    mapping = new Map();\n    provider;\n    sections = [];\n    /**\n     * @constructor\n     * Default constructor for the core RPC handler\n     * @param  {ProviderInterface} provider An API provider using any of the supported providers (HTTP, SC or WebSocket)\n     */\n    constructor(instanceId, registry, { isPedantic = true, provider, userRpc = {} }) {\n        if (!provider || !isFunction(provider.send)) {\n            throw new Error('Expected Provider to API create');\n        }\n        this.__internal__instanceId = instanceId;\n        this.__internal__isPedantic = isPedantic;\n        this.__internal__registryDefault = registry;\n        this.provider = provider;\n        const sectionNames = Object.keys(rpcDefinitions);\n        // these are the base keys (i.e. part of jsonrpc)\n        this.sections.push(...sectionNames);\n        // decorate all interfaces, defined and user on this instance\n        this.addUserInterfaces(userRpc);\n    }\n    /**\n     * @description Returns the connected status of a provider\n     */\n    get isConnected() {\n        return this.provider.isConnected;\n    }\n    /**\n     * @description Manually connect from the attached provider\n     */\n    connect() {\n        return this.provider.connect();\n    }\n    /**\n     * @description Manually disconnect from the attached provider\n     */\n    disconnect() {\n        return this.provider.disconnect();\n    }\n    /**\n     * @description Returns the underlying core stats, including those from teh provider\n     */\n    get stats() {\n        const stats = this.provider.stats;\n        return stats\n            ? {\n                ...stats,\n                core: {\n                    cacheHits: this.__internal__storageCacheHits,\n                    cacheSize: this.__internal__storageCacheSize\n                }\n            }\n            : undefined;\n    }\n    /**\n     * @description Sets a registry swap (typically from Api)\n     */\n    setRegistrySwap(registrySwap) {\n        this.__internal__getBlockRegistry = memoize(registrySwap, {\n            getInstanceId: () => this.__internal__instanceId\n        });\n    }\n    /**\n     * @description Sets a function to resolve block hash from block number\n     */\n    setResolveBlockHash(resolveBlockHash) {\n        this.__internal__getBlockHash = memoize(resolveBlockHash, {\n            getInstanceId: () => this.__internal__instanceId\n        });\n    }\n    addUserInterfaces(userRpc) {\n        // add any extra user-defined sections\n        this.sections.push(...Object.keys(userRpc).filter((k) => !this.sections.includes(k)));\n        for (let s = 0, scount = this.sections.length; s < scount; s++) {\n            const section = this.sections[s];\n            const defs = objectSpread({}, rpcDefinitions[section], userRpc[section]);\n            const methods = Object.keys(defs);\n            for (let m = 0, mcount = methods.length; m < mcount; m++) {\n                const method = methods[m];\n                const def = defs[method];\n                const jsonrpc = def.endpoint || `${section}_${method}`;\n                if (!this.mapping.has(jsonrpc)) {\n                    const isSubscription = !!def.pubsub;\n                    if (!this[section]) {\n                        this[section] = {};\n                    }\n                    this.mapping.set(jsonrpc, objectSpread({}, def, { isSubscription, jsonrpc, method, section }));\n                    lazyMethod(this[section], method, () => isSubscription\n                        ? this._createMethodSubscribe(section, method, def)\n                        : this._createMethodSend(section, method, def));\n                }\n            }\n        }\n    }\n    _memomize(creator, def) {\n        const memoOpts = { getInstanceId: () => this.__internal__instanceId };\n        const memoized = memoize(creator(true), memoOpts);\n        memoized.raw = memoize(creator(false), memoOpts);\n        memoized.meta = def;\n        return memoized;\n    }\n    _formatResult(isScale, registry, blockHash, method, def, params, result) {\n        return isScale\n            ? this._formatOutput(registry, blockHash, method, def, params, result)\n            : result;\n    }\n    _createMethodSend(section, method, def) {\n        const rpcName = def.endpoint || `${section}_${method}`;\n        const hashIndex = def.params.findIndex(({ isHistoric }) => isHistoric);\n        let memoized = null;\n        // execute the RPC call, doing a registry swap for historic as applicable\n        const callWithRegistry = async (isScale, values) => {\n            const blockId = hashIndex === -1\n                ? null\n                : values[hashIndex];\n            const blockHash = blockId && def.params[hashIndex].type === 'BlockNumber'\n                ? await this.__internal__getBlockHash?.(blockId)\n                : blockId;\n            const { registry } = isScale && blockHash && this.__internal__getBlockRegistry\n                ? await this.__internal__getBlockRegistry(u8aToU8a(blockHash))\n                : { registry: this.__internal__registryDefault };\n            const params = this._formatParams(registry, null, def, values);\n            // only cache .at(<blockHash>) queries, e.g. where valid blockHash was supplied\n            const result = await this.provider.send(rpcName, params.map((p) => p.toJSON()), !!blockHash);\n            return this._formatResult(isScale, registry, blockHash, method, def, params, result);\n        };\n        const creator = (isScale) => (...values) => {\n            const isDelayed = isScale && hashIndex !== -1 && !!values[hashIndex];\n            return new Observable((observer) => {\n                callWithRegistry(isScale, values)\n                    .then((value) => {\n                    observer.next(value);\n                    observer.complete();\n                })\n                    .catch((error) => {\n                    logErrorMessage(method, def, error);\n                    observer.error(error);\n                    observer.complete();\n                });\n                return () => {\n                    // delete old results from cache\n                    if (isScale) {\n                        memoized?.unmemoize(...values);\n                    }\n                    else {\n                        memoized?.raw.unmemoize(...values);\n                    }\n                };\n            }).pipe(\n            // eslint-disable-next-line deprecation/deprecation\n            publishReplay(1), // create a Replay(1)\n            isDelayed\n                ? refCountDelay() // Unsubscribe after delay\n                // eslint-disable-next-line deprecation/deprecation\n                : refCount());\n        };\n        memoized = this._memomize(creator, def);\n        return memoized;\n    }\n    // create a subscriptor, it subscribes once and resolves with the id as subscribe\n    _createSubscriber({ paramsJson, subName, subType, update }, errorHandler) {\n        return new Promise((resolve, reject) => {\n            this.provider\n                .subscribe(subType, subName, paramsJson, update)\n                .then(resolve)\n                .catch((error) => {\n                errorHandler(error);\n                reject(error);\n            });\n        });\n    }\n    _createMethodSubscribe(section, method, def) {\n        const [updateType, subMethod, unsubMethod] = def.pubsub;\n        const subName = `${section}_${subMethod}`;\n        const unsubName = `${section}_${unsubMethod}`;\n        const subType = `${section}_${updateType}`;\n        let memoized = null;\n        const creator = (isScale) => (...values) => {\n            return new Observable((observer) => {\n                // Have at least an empty promise, as used in the unsubscribe\n                let subscriptionPromise = Promise.resolve(null);\n                const registry = this.__internal__registryDefault;\n                const errorHandler = (error) => {\n                    logErrorMessage(method, def, error);\n                    observer.error(error);\n                };\n                try {\n                    const params = this._formatParams(registry, null, def, values);\n                    const update = (error, result) => {\n                        if (error) {\n                            logErrorMessage(method, def, error);\n                            return;\n                        }\n                        try {\n                            observer.next(this._formatResult(isScale, registry, null, method, def, params, result));\n                        }\n                        catch (error) {\n                            observer.error(error);\n                        }\n                    };\n                    subscriptionPromise = this._createSubscriber({ paramsJson: params.map((p) => p.toJSON()), subName, subType, update }, errorHandler);\n                }\n                catch (error) {\n                    errorHandler(error);\n                }\n                // Teardown logic\n                return () => {\n                    // Delete from cache, so old results don't hang around\n                    if (isScale) {\n                        memoized?.unmemoize(...values);\n                    }\n                    else {\n                        memoized?.raw.unmemoize(...values);\n                    }\n                    // Unsubscribe from provider\n                    subscriptionPromise\n                        .then((subscriptionId) => isNull(subscriptionId)\n                        ? Promise.resolve(false)\n                        : this.provider.unsubscribe(subType, unsubName, subscriptionId))\n                        .catch((error) => logErrorMessage(method, def, error));\n                };\n            }).pipe(drr());\n        };\n        memoized = this._memomize(creator, def);\n        return memoized;\n    }\n    _formatParams(registry, blockHash, def, inputs) {\n        const count = inputs.length;\n        const reqCount = def.params.filter(({ isOptional }) => !isOptional).length;\n        if (count < reqCount || count > def.params.length) {\n            throw new Error(`Expected ${def.params.length} parameters${reqCount === def.params.length ? '' : ` (${def.params.length - reqCount} optional)`}, ${count} found instead`);\n        }\n        const params = new Array(count);\n        for (let i = 0; i < count; i++) {\n            params[i] = registry.createTypeUnsafe(def.params[i].type, [inputs[i]], { blockHash });\n        }\n        return params;\n    }\n    _formatOutput(registry, blockHash, method, rpc, params, result) {\n        if (rpc.type === 'StorageData') {\n            const key = params[0];\n            return this._formatStorageData(registry, blockHash, key, result);\n        }\n        else if (rpc.type === 'StorageChangeSet') {\n            const keys = params[0];\n            return keys\n                ? this._formatStorageSet(registry, result.block, keys, result.changes)\n                : registry.createType('StorageChangeSet', result);\n        }\n        else if (rpc.type === 'Vec<StorageChangeSet>') {\n            const jsonSet = result;\n            const count = jsonSet.length;\n            const mapped = new Array(count);\n            for (let i = 0; i < count; i++) {\n                const { block, changes } = jsonSet[i];\n                mapped[i] = [\n                    registry.createType('BlockHash', block),\n                    this._formatStorageSet(registry, block, params[0], changes)\n                ];\n            }\n            // we only query at a specific block, not a range - flatten\n            return method === 'queryStorageAt'\n                ? mapped[0][1]\n                : mapped;\n        }\n        return registry.createTypeUnsafe(rpc.type, [result], { blockHash });\n    }\n    _formatStorageData(registry, blockHash, key, value) {\n        const isEmpty = isNull(value);\n        // we convert to Uint8Array since it maps to the raw encoding, all\n        // data will be correctly encoded (incl. numbers, excl. :code)\n        const input = isEmpty\n            ? null\n            : isTreatAsHex(key)\n                ? value\n                : u8aToU8a(value);\n        return this._newType(registry, blockHash, key, input, isEmpty);\n    }\n    _formatStorageSet(registry, blockHash, keys, changes) {\n        // For StorageChangeSet, the changes has the [key, value] mappings\n        const count = keys.length;\n        const withCache = count !== 1;\n        const values = new Array(count);\n        // multiple return values (via state.storage subscription), decode the\n        // values one at a time, all based on the supplied query types\n        for (let i = 0; i < count; i++) {\n            values[i] = this._formatStorageSetEntry(registry, blockHash, keys[i], changes, withCache, i);\n        }\n        return values;\n    }\n    _formatStorageSetEntry(registry, blockHash, key, changes, withCache, entryIndex) {\n        const hexKey = key.toHex();\n        const found = changes.find(([key]) => key === hexKey);\n        const isNotFound = isUndefined(found);\n        // if we don't find the value, this is our fallback\n        //   - in the case of an array of values, fill the hole from the cache\n        //   - if a single result value, don't fill - it is not an update hole\n        //   - fallback to an empty option in all cases\n        if (isNotFound && withCache) {\n            const cached = this.__internal__storageCache.get(hexKey);\n            if (cached) {\n                this.__internal__storageCacheHits++;\n                return cached;\n            }\n        }\n        const value = isNotFound\n            ? null\n            : found[1];\n        const isEmpty = isNull(value);\n        const input = isEmpty || isTreatAsHex(key)\n            ? value\n            : u8aToU8a(value);\n        const codec = this._newType(registry, blockHash, key, input, isEmpty, entryIndex);\n        // store the retrieved result - the only issue with this cache is that there is no\n        // clearing of it, so very long running processes (not just a couple of hours, longer)\n        // will increase memory beyond what is allowed.\n        this.__internal__storageCache.set(hexKey, codec);\n        this.__internal__storageCacheSize++;\n        return codec;\n    }\n    _newType(registry, blockHash, key, input, isEmpty, entryIndex = -1) {\n        // single return value (via state.getStorage), decode the value based on the\n        // outputType that we have specified. Fallback to Raw on nothing\n        const type = key.outputType || 'Raw';\n        const meta = key.meta || EMPTY_META;\n        const entryNum = entryIndex === -1\n            ? ''\n            : ` entry ${entryIndex}:`;\n        try {\n            return registry.createTypeUnsafe(type, [\n                isEmpty\n                    ? meta.fallback\n                        // For old-style Linkage, we add an empty linkage at the end\n                        ? type.includes('Linkage<')\n                            ? u8aConcat(hexToU8a(meta.fallback.toHex()), new Uint8Array(2))\n                            : hexToU8a(meta.fallback.toHex())\n                        : undefined\n                    : meta.modifier.isOptional\n                        ? registry.createTypeUnsafe(type, [input], { blockHash, isPedantic: this.__internal__isPedantic })\n                        : input\n            ], { blockHash, isFallback: isEmpty && !!meta.fallback, isOptional: meta.modifier.isOptional, isPedantic: this.__internal__isPedantic && !meta.modifier.isOptional });\n        }\n        catch (error) {\n            throw new Error(`Unable to decode storage ${key.section || 'unknown'}.${key.method || 'unknown'}:${entryNum}: ${error.message}`);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}