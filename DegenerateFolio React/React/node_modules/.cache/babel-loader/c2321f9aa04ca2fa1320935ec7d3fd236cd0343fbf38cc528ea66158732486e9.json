{"ast":null,"code":"import { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { Ticker } from '../../../../../ticker/Ticker.mjs';\nimport { detectVideoAlphaMode } from '../../../../../utils/browser/detectVideoAlphaMode.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\"use strict\";\nconst _VideoSource = class _VideoSource extends TextureSource {\n  constructor(options) {\n    super(options);\n    // Public\n    /** Whether or not the video is ready to play. */\n    this.isReady = false;\n    /** The upload method for this texture. */\n    this.uploadMethodId = \"video\";\n    options = {\n      ..._VideoSource.defaultOptions,\n      ...options\n    };\n    this._autoUpdate = true;\n    this._isConnectedToTicker = false;\n    this._updateFPS = options.updateFPS || 0;\n    this._msToNextUpdate = 0;\n    this.autoPlay = options.autoPlay !== false;\n    this.alphaMode = options.alphaMode ?? \"premultiply-alpha-on-upload\";\n    this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n    this._videoFrameRequestCallbackHandle = null;\n    this._load = null;\n    this._resolve = null;\n    this._reject = null;\n    this._onCanPlay = this._onCanPlay.bind(this);\n    this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n    this._onError = this._onError.bind(this);\n    this._onPlayStart = this._onPlayStart.bind(this);\n    this._onPlayStop = this._onPlayStop.bind(this);\n    this._onSeeked = this._onSeeked.bind(this);\n    if (options.autoLoad !== false) {\n      void this.load();\n    }\n  }\n  /** Update the video frame if the source is not destroyed and meets certain conditions. */\n  updateFrame() {\n    if (this.destroyed) {\n      return;\n    }\n    if (this._updateFPS) {\n      const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n    }\n    if (!this._updateFPS || this._msToNextUpdate <= 0) {\n      this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n    }\n    if (this.isValid) {\n      this.update();\n    }\n  }\n  /** Callback to update the video frame and potentially request the next frame update. */\n  _videoFrameRequestCallback() {\n    this.updateFrame();\n    if (this.destroyed) {\n      this._videoFrameRequestCallbackHandle = null;\n    } else {\n      this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);\n    }\n  }\n  /**\n   * Checks if the resource has valid dimensions.\n   * @returns {boolean} True if width and height are set, otherwise false.\n   */\n  get isValid() {\n    return !!this.resource.videoWidth && !!this.resource.videoHeight;\n  }\n  /**\n   * Start preloading the video resource.\n   * @returns {Promise<this>} Handle the validate event\n   */\n  async load() {\n    if (this._load) {\n      return this._load;\n    }\n    const source = this.resource;\n    const options = this.options;\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n    source.addEventListener(\"play\", this._onPlayStart);\n    source.addEventListener(\"pause\", this._onPlayStop);\n    source.addEventListener(\"seeked\", this._onSeeked);\n    if (!this._isSourceReady()) {\n      if (!options.preload) {\n        source.addEventListener(\"canplay\", this._onCanPlay);\n      }\n      source.addEventListener(\"canplaythrough\", this._onCanPlayThrough);\n      source.addEventListener(\"error\", this._onError, true);\n    } else {\n      this._mediaReady();\n    }\n    this.alphaMode = await detectVideoAlphaMode();\n    this._load = new Promise((resolve, reject) => {\n      if (this.isValid) {\n        resolve(this);\n      } else {\n        this._resolve = resolve;\n        this._reject = reject;\n        if (options.preloadTimeoutMs !== void 0) {\n          this._preloadTimeout = setTimeout(() => {\n            this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n          });\n        }\n        source.load();\n      }\n    });\n    return this._load;\n  }\n  /**\n   * Handle video error events.\n   * @param event - The error event\n   */\n  _onError(event) {\n    this.resource.removeEventListener(\"error\", this._onError, true);\n    this.emit(\"error\", event);\n    if (this._reject) {\n      this._reject(event);\n      this._reject = null;\n      this._resolve = null;\n    }\n  }\n  /**\n   * Checks if the underlying source is playing.\n   * @returns True if playing.\n   */\n  _isSourcePlaying() {\n    const source = this.resource;\n    return !source.paused && !source.ended;\n  }\n  /**\n   * Checks if the underlying source is ready for playing.\n   * @returns True if ready.\n   */\n  _isSourceReady() {\n    const source = this.resource;\n    return source.readyState > 2;\n  }\n  /** Runs the update loop when the video is ready to play. */\n  _onPlayStart() {\n    if (!this.isValid) {\n      this._mediaReady();\n    }\n    this._configureAutoUpdate();\n  }\n  /** Stops the update loop when a pause event is triggered. */\n  _onPlayStop() {\n    this._configureAutoUpdate();\n  }\n  /** Handles behavior when the video completes seeking to the current playback position. */\n  _onSeeked() {\n    if (this._autoUpdate && !this._isSourcePlaying()) {\n      this._msToNextUpdate = 0;\n      this.updateFrame();\n      this._msToNextUpdate = 0;\n    }\n  }\n  _onCanPlay() {\n    const source = this.resource;\n    source.removeEventListener(\"canplay\", this._onCanPlay);\n    this._mediaReady();\n  }\n  _onCanPlayThrough() {\n    const source = this.resource;\n    source.removeEventListener(\"canplaythrough\", this._onCanPlay);\n    if (this._preloadTimeout) {\n      clearTimeout(this._preloadTimeout);\n      this._preloadTimeout = void 0;\n    }\n    this._mediaReady();\n  }\n  /** Fired when the video is loaded and ready to play. */\n  _mediaReady() {\n    const source = this.resource;\n    if (this.isValid) {\n      this.isReady = true;\n      this.resize(source.videoWidth, source.videoHeight);\n    }\n    this._msToNextUpdate = 0;\n    this.updateFrame();\n    this._msToNextUpdate = 0;\n    if (this._resolve) {\n      this._resolve(this);\n      this._resolve = null;\n      this._reject = null;\n    }\n    if (this._isSourcePlaying()) {\n      this._onPlayStart();\n    } else if (this.autoPlay) {\n      void this.resource.play();\n    }\n  }\n  /** Cleans up resources and event listeners associated with this texture. */\n  destroy() {\n    this._configureAutoUpdate();\n    const source = this.resource;\n    if (source) {\n      source.removeEventListener(\"play\", this._onPlayStart);\n      source.removeEventListener(\"pause\", this._onPlayStop);\n      source.removeEventListener(\"seeked\", this._onSeeked);\n      source.removeEventListener(\"canplay\", this._onCanPlay);\n      source.removeEventListener(\"canplaythrough\", this._onCanPlayThrough);\n      source.removeEventListener(\"error\", this._onError, true);\n      source.pause();\n      source.src = \"\";\n      source.load();\n    }\n    super.destroy();\n  }\n  /** Should the base texture automatically update itself, set to true by default. */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * How many times a second to update the texture from the video.\n   * Leave at 0 to update at every render.\n   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n   */\n  get updateFPS() {\n    return this._updateFPS;\n  }\n  set updateFPS(value) {\n    if (value !== this._updateFPS) {\n      this._updateFPS = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * Configures the updating mechanism based on the current state and settings.\n   *\n   * This method decides between using the browser's native video frame callback or a custom ticker\n   * for updating the video frame. It ensures optimal performance and responsiveness\n   * based on the video's state, playback status, and the desired frames-per-second setting.\n   *\n   * - If `_autoUpdate` is enabled and the video source is playing:\n   *   - It will prefer the native video frame callback if available and no specific FPS is set.\n   *   - Otherwise, it will use a custom ticker for manual updates.\n   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n   */\n  _configureAutoUpdate() {\n    if (this._autoUpdate && this._isSourcePlaying()) {\n      if (!this._updateFPS && this.resource.requestVideoFrameCallback) {\n        if (this._isConnectedToTicker) {\n          Ticker.shared.remove(this.updateFrame, this);\n          this._isConnectedToTicker = false;\n          this._msToNextUpdate = 0;\n        }\n        if (this._videoFrameRequestCallbackHandle === null) {\n          this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);\n        }\n      } else {\n        if (this._videoFrameRequestCallbackHandle !== null) {\n          this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n          this._videoFrameRequestCallbackHandle = null;\n        }\n        if (!this._isConnectedToTicker) {\n          Ticker.shared.add(this.updateFrame, this);\n          this._isConnectedToTicker = true;\n          this._msToNextUpdate = 0;\n        }\n      }\n    } else {\n      if (this._videoFrameRequestCallbackHandle !== null) {\n        this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n        this._videoFrameRequestCallbackHandle = null;\n      }\n      if (this._isConnectedToTicker) {\n        Ticker.shared.remove(this.updateFrame, this);\n        this._isConnectedToTicker = false;\n        this._msToNextUpdate = 0;\n      }\n    }\n  }\n  static test(resource) {\n    return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement || globalThis.VideoFrame && resource instanceof VideoFrame;\n  }\n};\n_VideoSource.extension = ExtensionType.TextureSource;\n/** The default options for video sources. */\n_VideoSource.defaultOptions = {\n  ...TextureSource.defaultOptions,\n  /** If true, the video will start loading immediately. */\n  autoLoad: true,\n  /** If true, the video will start playing as soon as it is loaded. */\n  autoPlay: true,\n  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n  updateFPS: 0,\n  /** If true, the video will be loaded with the `crossorigin` attribute. */\n  crossorigin: true,\n  /** If true, the video will loop when it ends. */\n  loop: false,\n  /** If true, the video will be muted. */\n  muted: true,\n  /** If true, the video will play inline. */\n  playsinline: true,\n  /** If true, the video will be preloaded. */\n  preload: false\n};\n/**\n * Map of video MIME types that can't be directly derived from file extensions.\n * @readonly\n */\n_VideoSource.MIME_TYPES = {\n  ogv: \"video/ogg\",\n  mov: \"video/quicktime\",\n  m4v: \"video/mp4\"\n};\nlet VideoSource = _VideoSource;\nexport { VideoSource };","map":{"version":3,"names":["_VideoSource","TextureSource","constructor","options","isReady","uploadMethodId","defaultOptions","_autoUpdate","_isConnectedToTicker","_updateFPS","updateFPS","_msToNextUpdate","autoPlay","alphaMode","_videoFrameRequestCallback","bind","_videoFrameRequestCallbackHandle","_load","_resolve","_reject","_onCanPlay","_onCanPlayThrough","_onError","_onPlayStart","_onPlayStop","_onSeeked","autoLoad","load","updateFrame","destroyed","elapsedMS","Ticker","shared","resource","playbackRate","Math","floor","isValid","update","requestVideoFrameCallback","videoWidth","videoHeight","source","readyState","HAVE_ENOUGH_DATA","HAVE_FUTURE_DATA","width","height","complete","addEventListener","_isSourceReady","preload","_mediaReady","detectVideoAlphaMode","Promise","resolve","reject","preloadTimeoutMs","_preloadTimeout","setTimeout","ErrorEvent","event","removeEventListener","emit","_isSourcePlaying","paused","ended","_configureAutoUpdate","clearTimeout","resize","play","destroy","pause","src","autoUpdate","value","remove","cancelVideoFrameCallback","add","test","globalThis","HTMLVideoElement","VideoFrame","extension","ExtensionType","crossorigin","loop","muted","playsinline","MIME_TYPES","ogv","mov","m4v","VideoSource"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/VideoSource.ts"],"sourcesContent":["// VideoSource.ts\n\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { Ticker } from '../../../../../ticker/Ticker';\nimport { detectVideoAlphaMode } from '../../../../../utils/browser/detectVideoAlphaMode';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { Dict } from '../../../../../utils/types';\nimport type { ALPHA_MODES } from '../const';\nimport type { TextureSourceOptions } from './TextureSource';\n\ntype VideoResource = HTMLVideoElement;\n\n/**\n * Options for video sources.\n * @memberof rendering\n */\nexport interface VideoSourceOptions extends TextureSourceOptions<VideoResource>\n{\n    /** If true, the video will start loading immediately. */\n    autoLoad?: boolean;\n    /** If true, the video will start playing as soon as it is loaded. */\n    autoPlay?: boolean;\n    /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n    updateFPS?: number;\n    /** If true, the video will be loaded with the `crossorigin` attribute. */\n    crossorigin?: boolean | string;\n    /** If true, the video will loop when it ends. */\n    loop?: boolean;\n    /** If true, the video will be muted. */\n    muted?: boolean;\n    /** If true, the video will play inline. */\n    playsinline?: boolean;\n    /** If true, the video will be preloaded. */\n    preload?: boolean;\n    /** The time in milliseconds to wait for the video to preload before timing out. */\n    preloadTimeoutMs?: number;\n    /** The alpha mode of the video. */\n    alphaMode?: ALPHA_MODES;\n}\n\nexport interface VideoResourceOptionsElement\n{\n    src: string;\n    mime: string;\n}\n\n/**\n * A source for video-based textures.\n * @memberof rendering\n */\nexport class VideoSource extends TextureSource<VideoResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    /** The default options for video sources. */\n    public static defaultOptions: VideoSourceOptions = {\n        ...TextureSource.defaultOptions,\n        /** If true, the video will start loading immediately. */\n        autoLoad: true,\n        /** If true, the video will start playing as soon as it is loaded. */\n        autoPlay: true,\n        /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n        updateFPS: 0,\n        /** If true, the video will be loaded with the `crossorigin` attribute. */\n        crossorigin: true,\n        /** If true, the video will loop when it ends. */\n        loop: false,\n        /** If true, the video will be muted. */\n        muted: true,\n        /** If true, the video will play inline. */\n        playsinline: true,\n        /** If true, the video will be preloaded. */\n        preload: false,\n    };\n\n    // Public\n    /** Whether or not the video is ready to play. */\n    public isReady = false;\n    /** The upload method for this texture. */\n    public uploadMethodId = 'video';\n\n    // Protected\n    /**\n     * When set to true will automatically play videos used by this texture once\n     * they are loaded. If false, it will not modify the playing state.\n     * @default true\n     */\n    protected autoPlay: boolean;\n\n    // Private\n    /**\n     * `true` to use Ticker.shared to auto update the base texture.\n     * @default true\n     */\n    private _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to Ticker.shared to auto update the base texture.\n     * @default false\n     */\n    private _isConnectedToTicker: boolean;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    private _msToNextUpdate: number;\n    private _preloadTimeout: number;\n\n    /** Callback when completed with load. */\n    private _resolve: (value?: this | PromiseLike<this>) => void;\n    private _reject: (error: ErrorEvent) => void;\n\n    private _updateFPS: number;\n    private _videoFrameRequestCallbackHandle: number | null;\n\n    constructor(\n        options: VideoSourceOptions\n    )\n    {\n        super(options);\n\n        // Merge provided options with default ones\n        options = {\n            ...VideoSource.defaultOptions,\n            ...options\n        };\n\n        this._autoUpdate = true;\n        this._isConnectedToTicker = false;\n        this._updateFPS = options.updateFPS || 0;\n        this._msToNextUpdate = 0;\n        this.autoPlay = options.autoPlay !== false;\n        this.alphaMode = options.alphaMode ?? 'premultiply-alpha-on-upload';\n\n        // Binding for frame updates\n        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n        this._videoFrameRequestCallbackHandle = null;\n\n        this._load = null;\n        this._resolve = null;\n        this._reject = null;\n\n        // Bind for listeners\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n        this._onError = this._onError.bind(this);\n        this._onPlayStart = this._onPlayStart.bind(this);\n        this._onPlayStop = this._onPlayStop.bind(this);\n        this._onSeeked = this._onSeeked.bind(this);\n\n        if (options.autoLoad !== false)\n        {\n            void this.load();\n        }\n    }\n\n    /** Update the video frame if the source is not destroyed and meets certain conditions. */\n    protected updateFrame(): void\n    {\n        if (this.destroyed)\n        {\n            return;\n        }\n\n        if (this._updateFPS)\n        {\n            // Account for if video has had its playbackRate changed\n            const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;\n\n            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n        }\n\n        if (!this._updateFPS || this._msToNextUpdate <= 0)\n        {\n            this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;\n        }\n\n        if (this.isValid)\n        {\n            this.update();\n        }\n    }\n\n    /** Callback to update the video frame and potentially request the next frame update. */\n    private _videoFrameRequestCallback(): void\n    {\n        this.updateFrame();\n\n        if (this.destroyed)\n        {\n            this._videoFrameRequestCallbackHandle = null;\n        }\n        else\n        {\n            this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                this._videoFrameRequestCallback\n            );\n        }\n    }\n\n    /**\n     * Checks if the resource has valid dimensions.\n     * @returns {boolean} True if width and height are set, otherwise false.\n     */\n    public get isValid(): boolean\n    {\n        return !!this.resource.videoWidth && !!this.resource.videoHeight;\n    }\n\n    /**\n     * Start preloading the video resource.\n     * @returns {Promise<this>} Handle the validate event\n     */\n    public async load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const source = this.resource;\n        const options = this.options as VideoSourceOptions;\n\n        // Check if source data is enough and set it to complete if needed\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)\n            && source.width && source.height)\n        {\n            (source as any).complete = true;\n        }\n\n        // Add event listeners related to playback and seeking\n        source.addEventListener('play', this._onPlayStart);\n        source.addEventListener('pause', this._onPlayStop);\n        source.addEventListener('seeked', this._onSeeked);\n\n        // Add or handle source readiness event listeners\n        if (!this._isSourceReady())\n        {\n            if (!options.preload)\n            {\n                // since this event fires early, only bind if not waiting for a preload event\n                source.addEventListener('canplay', this._onCanPlay);\n            }\n            source.addEventListener('canplaythrough', this._onCanPlayThrough);\n            source.addEventListener('error', this._onError, true);\n        }\n        else\n        {\n            // Source is already ready, so handle it immediately\n            this._mediaReady();\n        }\n\n        this.alphaMode = await detectVideoAlphaMode();\n\n        // Create and return the loading promise\n        this._load = new Promise((resolve, reject): void =>\n        {\n            if (this.isValid)\n            {\n                resolve(this);\n            }\n            else\n            {\n                this._resolve = resolve;\n                this._reject = reject;\n\n                if (options.preloadTimeoutMs !== undefined)\n                {\n                    this._preloadTimeout = setTimeout(() =>\n                    {\n                        this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n                    }) as unknown as number;\n                }\n                source.load();\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Handle video error events.\n     * @param event - The error event\n     */\n    private _onError(event: ErrorEvent): void\n    {\n        this.resource.removeEventListener('error', this._onError, true);\n        this.emit('error', event);\n\n        if (this._reject)\n        {\n            this._reject(event);\n            this._reject = null;\n            this._resolve = null;\n        }\n    }\n\n    /**\n     * Checks if the underlying source is playing.\n     * @returns True if playing.\n     */\n    private _isSourcePlaying(): boolean\n    {\n        const source = this.resource;\n\n        return (!source.paused && !source.ended);\n    }\n\n    /**\n     * Checks if the underlying source is ready for playing.\n     * @returns True if ready.\n     */\n    private _isSourceReady(): boolean\n    {\n        const source = this.resource;\n\n        return source.readyState > 2;\n    }\n\n    /** Runs the update loop when the video is ready to play. */\n    private _onPlayStart(): void\n    {\n        // Handle edge case where video might not have received its \"can play\" event yet\n        if (!this.isValid)\n        {\n            this._mediaReady();\n        }\n\n        this._configureAutoUpdate();\n    }\n\n    /** Stops the update loop when a pause event is triggered. */\n    private _onPlayStop(): void\n    {\n        this._configureAutoUpdate();\n    }\n\n    /** Handles behavior when the video completes seeking to the current playback position. */\n    private _onSeeked(): void\n    {\n        if (this._autoUpdate && !this._isSourcePlaying())\n        {\n            this._msToNextUpdate = 0;\n            this.updateFrame();\n            this._msToNextUpdate = 0;\n        }\n    }\n\n    private _onCanPlay(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplay', this._onCanPlay);\n\n        this._mediaReady();\n    }\n\n    private _onCanPlayThrough(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplaythrough', this._onCanPlay);\n\n        if (this._preloadTimeout)\n        {\n            clearTimeout(this._preloadTimeout);\n            this._preloadTimeout = undefined;\n        }\n\n        this._mediaReady();\n    }\n\n    /** Fired when the video is loaded and ready to play. */\n    private _mediaReady(): void\n    {\n        const source = this.resource;\n\n        if (this.isValid)\n        {\n            this.isReady = true;\n            this.resize(source.videoWidth, source.videoHeight);\n        }\n\n        // Reset update timers and perform a frame update\n        this._msToNextUpdate = 0;\n        this.updateFrame();\n        this._msToNextUpdate = 0;\n\n        // Resolve the loading promise if it exists\n        if (this._resolve)\n        {\n            this._resolve(this);\n            this._resolve = null;\n            this._reject = null;\n        }\n\n        // Handle play behavior based on current source status\n        if (this._isSourcePlaying())\n        {\n            this._onPlayStart();\n        }\n        else if (this.autoPlay)\n        {\n            void this.resource.play();\n        }\n    }\n\n    /** Cleans up resources and event listeners associated with this texture. */\n    public destroy()\n    {\n        this._configureAutoUpdate();\n\n        const source = this.resource;\n\n        if (source)\n        {\n            // Remove event listeners\n            source.removeEventListener('play', this._onPlayStart);\n            source.removeEventListener('pause', this._onPlayStop);\n            source.removeEventListener('seeked', this._onSeeked);\n            source.removeEventListener('canplay', this._onCanPlay);\n            source.removeEventListener('canplaythrough', this._onCanPlayThrough);\n            source.removeEventListener('error', this._onError, true);\n\n            // Clear the video source and pause\n            source.pause();\n            source.src = '';\n            source.load();\n        }\n\n        super.destroy();\n    }\n\n    /** Should the base texture automatically update itself, set to true by default. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * How many times a second to update the texture from the video.\n     * Leave at 0 to update at every render.\n     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n     */\n    get updateFPS(): number\n    {\n        return this._updateFPS;\n    }\n\n    set updateFPS(value: number)\n    {\n        if (value !== this._updateFPS)\n        {\n            this._updateFPS = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * Configures the updating mechanism based on the current state and settings.\n     *\n     * This method decides between using the browser's native video frame callback or a custom ticker\n     * for updating the video frame. It ensures optimal performance and responsiveness\n     * based on the video's state, playback status, and the desired frames-per-second setting.\n     *\n     * - If `_autoUpdate` is enabled and the video source is playing:\n     *   - It will prefer the native video frame callback if available and no specific FPS is set.\n     *   - Otherwise, it will use a custom ticker for manual updates.\n     * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n     */\n    private _configureAutoUpdate(): void\n    {\n        // Check if automatic updating is enabled and if the source is currently playing\n        if (this._autoUpdate && this._isSourcePlaying())\n        {\n            // Determine if we should use the browser's native video frame callback (generally for better performance)\n            if (!this._updateFPS && this.resource.requestVideoFrameCallback)\n            {\n                // If connected to a custom ticker, remove the update frame function from it\n                if (this._isConnectedToTicker)\n                {\n                    Ticker.shared.remove(this.updateFrame, this);\n                    this._isConnectedToTicker = false;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n\n                // Check if we haven't already requested a video frame callback, and if not, request one\n                if (this._videoFrameRequestCallbackHandle === null)\n                {\n                    this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                        this._videoFrameRequestCallback\n                    );\n                }\n            }\n            else\n            {\n                // If a video frame request callback exists, cancel it, as we are switching to manual ticker-based updates\n                if (this._videoFrameRequestCallbackHandle !== null)\n                {\n                    this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                    this._videoFrameRequestCallbackHandle = null;\n                }\n\n                // If not connected to the custom ticker, add the update frame function to it\n                if (!this._isConnectedToTicker)\n                {\n                    Ticker.shared.add(this.updateFrame, this);\n                    this._isConnectedToTicker = true;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n            }\n        }\n        else\n        {\n            // If automatic updating is disabled or the source isn't playing, perform cleanup\n\n            // Cancel any existing video frame callback request\n            if (this._videoFrameRequestCallbackHandle !== null)\n            {\n                this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                this._videoFrameRequestCallbackHandle = null;\n            }\n\n            // Remove the update frame function from the custom ticker\n            if (this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.updateFrame, this);\n                this._isConnectedToTicker = false;\n                // Reset the time until the next update\n                this._msToNextUpdate = 0;\n            }\n        }\n    }\n\n    /**\n     * Map of video MIME types that can't be directly derived from file extensions.\n     * @readonly\n     */\n    public static MIME_TYPES: Dict<string>\n        = {\n            ogv: 'video/ogg',\n            mov: 'video/quicktime',\n            m4v: 'video/mp4',\n        };\n\n    public static test(resource: any): resource is VideoResource\n    {\n        return (globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement)\n            || (globalThis.VideoFrame && resource instanceof VideoFrame);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}