{"ast":null,"code":"import { Color } from '../../color/Color.mjs';\nimport { Rectangle } from '../../maths/shapes/Rectangle.mjs';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics.mjs';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle.mjs';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle.mjs';\nimport { AbstractBitmapFont } from './AbstractBitmapFont.mjs';\nimport { resolveCharacters } from './utils/resolveCharacters.mjs';\n\"use strict\";\nclass DynamicBitmapFont extends AbstractBitmapFont {\n  /**\n   * @param options - The options for the dynamic bitmap font.\n   */\n  constructor(options) {\n    super();\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    this.resolution = 1;\n    /** The pages of the font. */\n    this.pages = [];\n    this._padding = 4;\n    this._measureCache = /* @__PURE__ */Object.create(null);\n    this._currentChars = [];\n    this._currentX = 0;\n    this._currentY = 0;\n    this._currentPageIndex = -1;\n    this._skipKerning = false;\n    const dynamicOptions = options;\n    const style = dynamicOptions.style.clone();\n    if (dynamicOptions.overrideFill) {\n      style._fill.color = 16777215;\n      style._fill.alpha = 1;\n      style._fill.texture = Texture.WHITE;\n      style._fill.fill = null;\n    }\n    const requestedFontSize = style.fontSize;\n    style.fontSize = this.baseMeasurementFontSize;\n    const font = fontStringFromTextStyle(style);\n    if (dynamicOptions.overrideSize) {\n      if (style._stroke) {\n        style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n      }\n    } else {\n      style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n    }\n    this._style = style;\n    this._skipKerning = dynamicOptions.skipKerning ?? false;\n    this.resolution = dynamicOptions.resolution ?? 1;\n    this._padding = dynamicOptions.padding ?? 4;\n    this.fontMetrics = CanvasTextMetrics.measureFont(font);\n    this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n  }\n  ensureCharacters(chars) {\n    const charList = resolveCharacters(chars).filter(char => !this._currentChars.includes(char)).filter((char, index, self) => self.indexOf(char) === index);\n    if (!charList.length) return;\n    this._currentChars = [...this._currentChars, ...charList];\n    let pageData;\n    if (this._currentPageIndex === -1) {\n      pageData = this._nextPage();\n    } else {\n      pageData = this.pages[this._currentPageIndex];\n    }\n    let {\n      canvas,\n      context\n    } = pageData.canvasAndContext;\n    let textureSource = pageData.texture.source;\n    const style = this._style;\n    let currentX = this._currentX;\n    let currentY = this._currentY;\n    const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n    const padding = this._padding * fontScale;\n    const widthScale = style.fontStyle === \"italic\" ? 2 : 1;\n    let maxCharHeight = 0;\n    let skipTexture = false;\n    for (let i = 0; i < charList.length; i++) {\n      const char = charList[i];\n      const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n      metrics.lineHeight = metrics.height;\n      const width = widthScale * metrics.width * fontScale;\n      const height = metrics.height * fontScale;\n      const paddedWidth = width + padding * 2;\n      const paddedHeight = height + padding * 2;\n      skipTexture = false;\n      if (char !== \"\\n\" && char !== \"\\r\" && char !== \"\t\" && char !== \" \") {\n        skipTexture = true;\n        maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));\n      }\n      if (currentX + paddedWidth > 512) {\n        currentY += maxCharHeight;\n        maxCharHeight = paddedHeight;\n        currentX = 0;\n        if (currentY + maxCharHeight > 512) {\n          textureSource.update();\n          const pageData2 = this._nextPage();\n          canvas = pageData2.canvasAndContext.canvas;\n          context = pageData2.canvasAndContext.context;\n          textureSource = pageData2.texture.source;\n          currentY = 0;\n        }\n      }\n      const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);\n      this.chars[char] = {\n        id: char.codePointAt(0),\n        xOffset: -this._padding,\n        yOffset: -this._padding,\n        xAdvance,\n        kerning: {}\n      };\n      if (skipTexture) {\n        this._drawGlyph(context, metrics, currentX + padding, currentY + padding, fontScale, style);\n        const px = textureSource.width * fontScale;\n        const py = textureSource.height * fontScale;\n        const frame = new Rectangle(currentX / px * textureSource.width, currentY / py * textureSource.height, paddedWidth / px * textureSource.width, paddedHeight / py * textureSource.height);\n        this.chars[char].texture = new Texture({\n          source: textureSource,\n          frame\n        });\n        currentX += Math.ceil(paddedWidth);\n      }\n    }\n    textureSource.update();\n    this._currentX = currentX;\n    this._currentY = currentY;\n    this._skipKerning && this._applyKerning(charList, context);\n  }\n  /**\n   * @deprecated since 8.0.0\n   * The map of base page textures (i.e., sheets of glyphs).\n   */\n  get pageTextures() {\n    deprecation(v8_0_0, \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n    return this.pages;\n  }\n  _applyKerning(newChars, context) {\n    const measureCache = this._measureCache;\n    for (let i = 0; i < newChars.length; i++) {\n      const first = newChars[i];\n      for (let j = 0; j < this._currentChars.length; j++) {\n        const second = this._currentChars[j];\n        let c1 = measureCache[first];\n        if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n        let c2 = measureCache[second];\n        if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n        let total = context.measureText(first + second).width;\n        let amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[first].kerning[second] = amount;\n        }\n        total = context.measureText(first + second).width;\n        amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[second].kerning[first] = amount;\n        }\n      }\n    }\n  }\n  _nextPage() {\n    this._currentPageIndex++;\n    const textureResolution = this.resolution;\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(512, 512, textureResolution);\n    this._setupContext(canvasAndContext.context, this._style, textureResolution);\n    const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n    const texture = new Texture({\n      source: new ImageSource({\n        resource: canvasAndContext.canvas,\n        resolution,\n        alphaMode: \"premultiply-alpha-on-upload\"\n      })\n    });\n    const pageData = {\n      canvasAndContext,\n      texture\n    };\n    this.pages[this._currentPageIndex] = pageData;\n    return pageData;\n  }\n  // canvas style!\n  _setupContext(context, style, resolution) {\n    style.fontSize = this.baseRenderedFontSize;\n    context.scale(resolution, resolution);\n    context.font = fontStringFromTextStyle(style);\n    style.fontSize = this.baseMeasurementFontSize;\n    context.textBaseline = style.textBaseline;\n    const stroke = style._stroke;\n    const strokeThickness = stroke?.width ?? 0;\n    if (stroke) {\n      context.lineWidth = strokeThickness;\n      context.lineJoin = stroke.join;\n      context.miterLimit = stroke.miterLimit;\n      context.strokeStyle = getCanvasFillStyle(stroke, context);\n    }\n    if (style._fill) {\n      context.fillStyle = getCanvasFillStyle(style._fill, context);\n    }\n    if (style.dropShadow) {\n      const shadowOptions = style.dropShadow;\n      const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n      const dropShadowBlur = shadowOptions.blur * resolution;\n      const dropShadowDistance = shadowOptions.distance * resolution;\n      context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n      context.shadowBlur = dropShadowBlur;\n      context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n      context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n    } else {\n      context.shadowColor = \"black\";\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n  }\n  _drawGlyph(context, metrics, x, y, fontScale, style) {\n    const char = metrics.text;\n    const fontProperties = metrics.fontProperties;\n    const stroke = style._stroke;\n    const strokeThickness = (stroke?.width ?? 0) * fontScale;\n    const tx = x + strokeThickness / 2;\n    const ty = y - strokeThickness / 2;\n    const descent = fontProperties.descent * fontScale;\n    const lineHeight = metrics.lineHeight * fontScale;\n    if (style.stroke && strokeThickness) {\n      context.strokeText(char, tx, ty + lineHeight - descent);\n    }\n    if (style._fill) {\n      context.fillText(char, tx, ty + lineHeight - descent);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const {\n        canvasAndContext,\n        texture\n      } = this.pages[i];\n      CanvasPool.returnCanvasAndContext(canvasAndContext);\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n}\nexport { DynamicBitmapFont };","map":{"version":3,"names":["DynamicBitmapFont","AbstractBitmapFont","constructor","options","resolution","pages","_padding","_measureCache","Object","create","_currentChars","_currentX","_currentY","_currentPageIndex","_skipKerning","dynamicOptions","style","clone","overrideFill","_fill","color","alpha","texture","Texture","WHITE","fill","requestedFontSize","fontSize","baseMeasurementFontSize","font","fontStringFromTextStyle","overrideSize","_stroke","width","baseRenderedFontSize","_style","skipKerning","padding","fontMetrics","CanvasTextMetrics","measureFont","lineHeight","ensureCharacters","chars","charList","resolveCharacters","filter","char","includes","index","self","indexOf","length","pageData","_nextPage","canvas","context","canvasAndContext","textureSource","source","currentX","currentY","fontScale","widthScale","fontStyle","maxCharHeight","skipTexture","i","metrics","measureText","height","paddedWidth","paddedHeight","Math","ceil","max","update","pageData2","xAdvance","dropShadow","distance","id","codePointAt","xOffset","yOffset","kerning","_drawGlyph","px","py","frame","Rectangle","_applyKerning","pageTextures","deprecation","v8_0_0","newChars","measureCache","first","j","second","c1","c2","total","amount","textureResolution","CanvasPool","getOptimalCanvasAndContext","_setupContext","ImageSource","resource","alphaMode","scale","textBaseline","stroke","strokeThickness","lineWidth","lineJoin","join","miterLimit","strokeStyle","getCanvasFillStyle","fillStyle","shadowOptions","rgb","Color","shared","setValue","toArray","dropShadowBlur","blur","dropShadowDistance","shadowColor","shadowBlur","shadowOffsetX","cos","angle","shadowOffsetY","sin","x","y","text","fontProperties","tx","ty","descent","strokeText","fillText","destroy","returnCanvasAndContext"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/text-bitmap/DynamicBitmapFont.ts"],"sourcesContent":["import { Color } from '../../color/Color';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\nimport type { TextStyle } from '../text/TextStyle';\n\nexport interface DynamicBitmapFontOptions\n{\n    style: TextStyle\n    skipKerning?: boolean\n    resolution?: number\n    padding?: number\n    overrideFill?: boolean\n    overrideSize?: boolean\n}\n\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @memberof text\n * @ignore\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont>\n{\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    public resolution = 1;\n    /** The pages of the font. */\n    public override readonly pages: {canvasAndContext?: CanvasAndContext, texture: Texture}[] = [];\n\n    private readonly _padding: number = 4;\n    private readonly _measureCache: Record<string, number> = Object.create(null);\n    private _currentChars: string[] = [];\n    private _currentX = 0;\n    private _currentY = 0;\n    private _currentPageIndex = -1;\n    private readonly _style: TextStyle;\n    private readonly _skipKerning: boolean = false;\n\n    /**\n     * @param options - The options for the dynamic bitmap font.\n     */\n    constructor(options: DynamicBitmapFontOptions)\n    {\n        super();\n\n        const dynamicOptions = options;\n        const style = dynamicOptions.style.clone();\n\n        if (dynamicOptions.overrideFill)\n        {\n            // assuming no shape fill..\n            style._fill.color = 0xffffff;\n            style._fill.alpha = 1;\n            style._fill.texture = Texture.WHITE;\n            style._fill.fill = null;\n        }\n\n        const requestedFontSize = style.fontSize;\n\n        // adjust font size to match the base measurement size\n        style.fontSize = this.baseMeasurementFontSize;\n\n        const font = fontStringFromTextStyle(style);\n\n        if (dynamicOptions.overrideSize)\n        {\n            if (style._stroke)\n            {\n                // we want the stroke to fit the size of the requested text, so we need to scale it\n                // accordingly (eg font size 20, with stroke 10 - stroke is 50% of size,\n                // as dynamic font is size 100, the stroke should be adjusted to 50 to make it look right)\n                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n            }\n        }\n        else\n        {\n            style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        }\n\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n\n        (this.fontMetrics as FontMetrics) = CanvasTextMetrics.measureFont(font);\n        (this.lineHeight as number) = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n\n    public ensureCharacters(chars: string): void\n    {\n        const charList = resolveCharacters(chars)\n            .filter((char) => !this._currentChars.includes(char))\n            .filter((char, index, self) => self.indexOf(char) === index);\n        // filter returns..\n\n        if (!charList.length) return;\n\n        this._currentChars = [...this._currentChars, ...charList];\n\n        let pageData;\n\n        if (this._currentPageIndex === -1)\n        {\n            pageData = this._nextPage();\n        }\n        else\n        {\n            pageData = this.pages[this._currentPageIndex];\n        }\n\n        let { canvas, context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n\n        const style = this._style;\n\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n\n        const widthScale = style.fontStyle === 'italic' ? 2 : 1;\n        let maxCharHeight = 0;\n        let skipTexture = false;\n\n        for (let i = 0; i < charList.length; i++)\n        {\n            const char = charList[i];\n\n            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n\n            // override the line height.. we want this to be the glyps heigh\n            // not the user specified one.\n            metrics.lineHeight = metrics.height;\n\n            const width = (widthScale * metrics.width) * fontScale;\n            const height = (metrics.height) * fontScale;\n\n            const paddedWidth = width + (padding * 2);\n            const paddedHeight = height + (padding * 2);\n\n            skipTexture = false;\n            // don't let empty characters count towards the maxCharHeight\n            if (char !== '\\n' && char !== '\\r' && char !== '\\t' && char !== ' ')\n            {\n                skipTexture = true;\n                maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));// / 1.5;\n            }\n\n            if (currentX + paddedWidth > 512)\n            {\n                currentY += maxCharHeight;\n\n                // reset the line x and height..\n                maxCharHeight = paddedHeight;\n                currentX = 0;\n\n                if (currentY + maxCharHeight > 512)\n                {\n                    textureSource.update();\n\n                    const pageData = this._nextPage();\n\n                    canvas = pageData.canvasAndContext.canvas;\n                    context = pageData.canvasAndContext.context;\n                    textureSource = pageData.texture.source;\n\n                    currentY = 0;\n                }\n            }\n\n            const xAdvance = (width / fontScale)\n                - (style.dropShadow?.distance ?? 0)\n                - (style._stroke?.width ?? 0);\n\n            // This is in coord space of the measurements.. not the texture\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance,\n                kerning: {},\n            };\n\n            if (skipTexture)\n            {\n                this._drawGlyph(\n                    context,\n                    metrics,\n                    currentX + padding,\n                    currentY + padding,\n                    fontScale,\n                    style,\n                );\n\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n\n                const frame = new Rectangle(\n                    ((currentX) / px) * textureSource.width,\n                    ((currentY) / py) * textureSource.height,\n                    ((paddedWidth) / px) * textureSource.width,\n                    ((paddedHeight) / py) * textureSource.height,\n                );\n\n                this.chars[char].texture = new Texture({\n                    source: textureSource,\n                    frame,\n                });\n\n                currentX += Math.ceil(paddedWidth);\n            }\n\n            // now add it to the font data..\n        }\n\n        textureSource.update();\n\n        this._currentX = currentX;\n        this._currentY = currentY;\n\n        // now apply kerning..\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n\n    /**\n     * @deprecated since 8.0.0\n     * The map of base page textures (i.e., sheets of glyphs).\n     */\n    public override get pageTextures(): DynamicBitmapFont['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    private _applyKerning(newChars: string[], context: ICanvasRenderingContext2D): void\n    {\n        const measureCache = this._measureCache;\n\n        for (let i = 0; i < newChars.length; i++)\n        {\n            const first = newChars[i];\n\n            for (let j = 0; j < this._currentChars.length; j++)\n            {\n                // first go through new char being first\n                const second = this._currentChars[j];\n\n                let c1 = measureCache[first];\n\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n\n                let c2 = measureCache[second];\n\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[first].kerning[second] = amount;\n                }\n\n                // then go through new char being second\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[second].kerning[first] = amount;\n                }\n            }\n        }\n    }\n\n    private _nextPage(): {canvasAndContext: CanvasAndContext, texture: Texture}\n    {\n        this._currentPageIndex++;\n\n        const textureResolution = this.resolution;\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(512, 512, textureResolution);\n\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new Texture({\n            source: new ImageSource({\n                resource: canvasAndContext.canvas,\n                resolution,\n                alphaMode: 'premultiply-alpha-on-upload'\n            }),\n\n        });\n\n        const pageData = {\n            canvasAndContext,\n            texture,\n        };\n\n        this.pages[this._currentPageIndex] = pageData;\n\n        return pageData;\n    }\n\n    // canvas style!\n    private _setupContext(context: ICanvasRenderingContext2D, style: TextStyle, resolution: number): void\n    {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = fontStringFromTextStyle(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n\n        if (stroke)\n        {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n\n            // TODO prolly cache this??\n            context.strokeStyle = getCanvasFillStyle(stroke, context);\n        }\n\n        if (style._fill)\n        {\n            // set canvas text styles\n            context.fillStyle = getCanvasFillStyle(style._fill, context);\n        }\n\n        if (style.dropShadow)\n        {\n            const shadowOptions = style.dropShadow;\n            const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        }\n        else\n        {\n            context.shadowColor = 'black';\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n\n    private _drawGlyph(\n        context: ICanvasRenderingContext2D,\n        metrics: CanvasTextMetrics,\n        x: number,\n        y: number,\n        fontScale: number,\n        style: TextStyle\n    ): void\n    {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n\n        const tx = x + (strokeThickness / 2);\n        const ty = y - (strokeThickness / 2);\n\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n\n        if (style.stroke && strokeThickness)\n        {\n            context.strokeText(char, tx, ty + lineHeight - descent);\n        }\n\n        if (style._fill)\n        {\n            context.fillText(char, tx, ty + lineHeight - descent);\n        }\n    }\n\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { canvasAndContext, texture } = this.pages[i];\n\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}