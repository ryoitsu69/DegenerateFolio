{"ast":null,"code":"import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { VideoSource } from '../../../../rendering/renderers/shared/texture/sources/VideoSource.mjs';\nimport { detectVideoAlphaMode } from '../../../../utils/browser/detectVideoAlphaMode.mjs';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl.mjs';\nimport { checkDataUrl } from '../../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../../utils/checkExtension.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\n\"use strict\";\nconst validVideoExtensions = [\".mp4\", \".m4v\", \".webm\", \".ogg\", \".ogv\", \".h264\", \".avi\", \".mov\"];\nconst validVideoMIMEs = validVideoExtensions.map(ext => `video/${ext.substring(1)}`);\nfunction crossOrigin(element, url, crossorigin) {\n  if (crossorigin === void 0 && !url.startsWith(\"data:\")) {\n    element.crossOrigin = determineCrossOrigin(url);\n  } else if (crossorigin !== false) {\n    element.crossOrigin = typeof crossorigin === \"string\" ? crossorigin : \"anonymous\";\n  }\n}\nfunction preloadVideo(element) {\n  return new Promise((resolve, reject) => {\n    element.addEventListener(\"canplaythrough\", loaded);\n    element.addEventListener(\"error\", error);\n    element.load();\n    function loaded() {\n      cleanup();\n      resolve();\n    }\n    function error(err) {\n      cleanup();\n      reject(err);\n    }\n    function cleanup() {\n      element.removeEventListener(\"canplaythrough\", loaded);\n      element.removeEventListener(\"error\", error);\n    }\n  });\n}\nfunction determineCrossOrigin(url, loc = globalThis.location) {\n  if (url.startsWith(\"data:\")) {\n    return \"\";\n  }\n  loc = loc || globalThis.location;\n  const parsedUrl = new URL(url, document.baseURI);\n  if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {\n    return \"anonymous\";\n  }\n  return \"\";\n}\nconst loadVideoTextures = {\n  name: \"loadVideo\",\n  extension: {\n    type: ExtensionType.LoadParser\n  },\n  config: null,\n  test(url) {\n    const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);\n    const isValidExtension = checkExtension(url, validVideoExtensions);\n    return isValidDataUrl || isValidExtension;\n  },\n  async load(url, asset, loader) {\n    const options = {\n      ...VideoSource.defaultOptions,\n      resolution: asset.data?.resolution || getResolutionOfUrl(url),\n      alphaMode: asset.data?.alphaMode || (await detectVideoAlphaMode()),\n      ...asset.data\n    };\n    const videoElement = document.createElement(\"video\");\n    const attributeMap = {\n      preload: options.autoLoad !== false ? \"auto\" : void 0,\n      \"webkit-playsinline\": options.playsinline !== false ? \"\" : void 0,\n      playsinline: options.playsinline !== false ? \"\" : void 0,\n      muted: options.muted === true ? \"\" : void 0,\n      loop: options.loop === true ? \"\" : void 0,\n      autoplay: options.autoPlay !== false ? \"\" : void 0\n    };\n    Object.keys(attributeMap).forEach(key => {\n      const value = attributeMap[key];\n      if (value !== void 0) videoElement.setAttribute(key, value);\n    });\n    if (options.muted === true) {\n      videoElement.muted = true;\n    }\n    crossOrigin(videoElement, url, options.crossorigin);\n    const sourceElement = document.createElement(\"source\");\n    let mime;\n    if (url.startsWith(\"data:\")) {\n      mime = url.slice(5, url.indexOf(\";\"));\n    } else if (!url.startsWith(\"blob:\")) {\n      const ext = url.split(\"?\")[0].slice(url.lastIndexOf(\".\") + 1).toLowerCase();\n      mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;\n    }\n    sourceElement.src = url;\n    if (mime) {\n      sourceElement.type = mime;\n    }\n    return new Promise(resolve => {\n      const onCanPlay = async () => {\n        const base = new VideoSource({\n          ...options,\n          resource: videoElement\n        });\n        videoElement.removeEventListener(\"canplay\", onCanPlay);\n        if (asset.data.preload) {\n          await preloadVideo(videoElement);\n        }\n        resolve(createTexture(base, loader, url));\n      };\n      videoElement.addEventListener(\"canplay\", onCanPlay);\n      videoElement.appendChild(sourceElement);\n    });\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\nexport { crossOrigin, determineCrossOrigin, loadVideoTextures, preloadVideo };","map":{"version":3,"names":["validVideoExtensions","validVideoMIMEs","map","ext","substring","crossOrigin","element","url","crossorigin","startsWith","determineCrossOrigin","preloadVideo","Promise","resolve","reject","addEventListener","loaded","error","load","cleanup","err","removeEventListener","loc","globalThis","location","parsedUrl","URL","document","baseURI","hostname","port","protocol","loadVideoTextures","name","extension","type","ExtensionType","LoadParser","config","test","isValidDataUrl","checkDataUrl","isValidExtension","checkExtension","asset","loader","options","VideoSource","defaultOptions","resolution","data","getResolutionOfUrl","alphaMode","detectVideoAlphaMode","videoElement","createElement","attributeMap","preload","autoLoad","playsinline","muted","loop","autoplay","autoPlay","Object","keys","forEach","key","value","setAttribute","sourceElement","mime","slice","indexOf","split","lastIndexOf","toLowerCase","MIME_TYPES","src","onCanPlay","base","resource","createTexture","appendChild","unload","texture","destroy"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/assets/loader/parsers/textures/loadVideoTextures.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { VideoSource } from '../../../../rendering/renderers/shared/texture/sources/VideoSource';\nimport { detectVideoAlphaMode } from '../../../../utils/browser/detectVideoAlphaMode';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { createTexture } from './utils/createTexture';\n\nimport type { VideoSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/VideoSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validVideoExtensions = ['.mp4', '.m4v', '.webm', '.ogg', '.ogv', '.h264', '.avi', '.mov'];\nconst validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);\n\n/**\n * Set cross origin based detecting the url and the crossorigin\n * @param element - Element to apply crossOrigin\n * @param url - URL to check\n * @param crossorigin - Cross origin value to use\n * @memberof assets\n */\nexport function crossOrigin(element: HTMLImageElement | HTMLVideoElement, url: string, crossorigin?: boolean | string): void\n{\n    if (crossorigin === undefined && !url.startsWith('data:'))\n    {\n        element.crossOrigin = determineCrossOrigin(url);\n    }\n    else if (crossorigin !== false)\n    {\n        element.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';\n    }\n}\n\n/**\n * Preload a video element\n * @param element - Video element to preload\n */\nexport function preloadVideo(element: HTMLVideoElement): Promise<void>\n{\n    return new Promise((resolve, reject) =>\n    {\n        element.addEventListener('canplaythrough', loaded);\n        element.addEventListener('error', error);\n\n        element.load();\n\n        function loaded(): void\n        {\n            cleanup();\n            resolve();\n        }\n\n        function error(err: ErrorEvent): void\n        {\n            cleanup();\n            reject(err);\n        }\n\n        function cleanup(): void\n        {\n            element.removeEventListener('canplaythrough', loaded);\n            element.removeEventListener('error', error);\n        }\n    });\n}\n\n/**\n * Sets the `crossOrigin` property for this resource based on if the url\n * for this resource is cross-origin. If crossOrigin was manually set, this\n * function does nothing.\n * Nipped from the resource loader!\n * @ignore\n * @param url - The url to test.\n * @param {object} [loc=window.location] - The location object to test against.\n * @returns The crossOrigin value to use (or empty string for none).\n * @memberof assets\n */\nexport function determineCrossOrigin(url: string, loc: Location = globalThis.location): string\n{\n    // data: and javascript: urls are considered same-origin\n    if (url.startsWith('data:'))\n    {\n        return '';\n    }\n\n    // default is window.location\n    loc = loc || globalThis.location;\n\n    const parsedUrl = new URL(url, document.baseURI);\n\n    // if cross origin\n    if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol)\n    {\n        return 'anonymous';\n    }\n\n    return '';\n}\n\n/**\n * A simple plugin to load video textures.\n *\n * You can pass VideoSource options to the loader via the .data property of the asset descriptor\n * when using Asset.load().\n * ```js\n * // Set the data\n * const texture = await Assets.load({\n *     src: './assets/city.mp4',\n *     data: {\n *         preload: true,\n *         autoPlay: true,\n *     },\n * });\n * ```\n * @memberof assets\n */\nexport const loadVideoTextures = {\n\n    name: 'loadVideo',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n    },\n\n    config: null,\n\n    test(url: string): boolean\n    {\n        const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);\n        const isValidExtension = checkExtension(url, validVideoExtensions);\n\n        return isValidDataUrl || isValidExtension;\n    },\n\n    async load(url: string, asset: ResolvedAsset<VideoSourceOptions>, loader: Loader): Promise<Texture>\n    {\n        // --- Merge default and provided options ---\n        const options: VideoSourceOptions = {\n            ...VideoSource.defaultOptions,\n            resolution: asset.data?.resolution || getResolutionOfUrl(url),\n            alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),\n            ...asset.data,\n        };\n\n        // --- Create and configure HTMLVideoElement ---\n        const videoElement = document.createElement('video');\n\n        // Set attributes based on options\n        const attributeMap = {\n            preload: options.autoLoad !== false ? 'auto' : undefined,\n            'webkit-playsinline': options.playsinline !== false ? '' : undefined,\n            playsinline: options.playsinline !== false ? '' : undefined,\n            muted: options.muted === true ? '' : undefined,\n            loop: options.loop === true ? '' : undefined,\n            autoplay: options.autoPlay !== false ? '' : undefined\n        };\n\n        Object.keys(attributeMap).forEach((key) =>\n        {\n            const value = attributeMap[key as keyof typeof attributeMap];\n\n            if (value !== undefined) videoElement.setAttribute(key, value);\n        });\n\n        if (options.muted === true)\n        {\n            videoElement.muted = true;\n        }\n\n        crossOrigin(videoElement, url, options.crossorigin); // Assume crossOrigin is globally available\n\n        // --- Set up source and MIME type ---\n        const sourceElement = document.createElement('source');\n\n        // Determine MIME type\n        let mime: string | undefined;\n\n        if (url.startsWith('data:'))\n        {\n            mime = url.slice(5, url.indexOf(';'));\n        }\n        else if (!url.startsWith('blob:'))\n        {\n            const ext = url.split('?')[0].slice(url.lastIndexOf('.') + 1).toLowerCase();\n\n            mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;\n        }\n\n        sourceElement.src = url;\n\n        if (mime)\n        {\n            sourceElement.type = mime;\n        }\n\n        // this promise will make sure that video is ready to play - as in we have a valid width, height and it can be\n        // uploaded to the GPU. Our textures are kind of dumb now, and don't want to handle resizing right now.\n        return new Promise((resolve) =>\n        {\n            const onCanPlay = async () =>\n            {\n                const base = new VideoSource({ ...options, resource: videoElement });\n\n                videoElement.removeEventListener('canplay', onCanPlay);\n\n                if (asset.data.preload)\n                {\n                    await preloadVideo(videoElement);\n                }\n\n                resolve(createTexture(base, loader, url));\n            };\n\n            videoElement.addEventListener('canplay', onCanPlay);\n            videoElement.appendChild(sourceElement);\n        });\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} as LoaderParser<Texture, VideoSourceOptions, null>;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}