{"ast":null,"code":"import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { fastCopy } from '../../shared/buffer/utils/fastCopy.mjs';\n\"use strict\";\nclass GpuBufferSystem {\n  constructor() {\n    this._gpuBuffers = /* @__PURE__ */Object.create(null);\n    this._managedBuffers = [];\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getGPUBuffer(buffer) {\n    return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n  }\n  updateBuffer(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n    const data = buffer.data;\n    if (buffer._updateID && data) {\n      buffer._updateID = 0;\n      this._gpu.device.queue.writeBuffer(gpuBuffer, 0, data.buffer, 0,\n      // round to the nearest 4 bytes\n      (buffer._updateSize || data.byteLength) + 3 & ~3);\n    }\n    return gpuBuffer;\n  }\n  /** dispose all WebGL resources of all managed buffers */\n  destroyAll() {\n    for (const id in this._gpuBuffers) {\n      this._gpuBuffers[id].destroy();\n    }\n    this._gpuBuffers = {};\n  }\n  createGPUBuffer(buffer) {\n    if (!this._gpuBuffers[buffer.uid]) {\n      buffer.on(\"update\", this.updateBuffer, this);\n      buffer.on(\"change\", this.onBufferChange, this);\n      buffer.on(\"destroy\", this.onBufferDestroy, this);\n    }\n    const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n    buffer._updateID = 0;\n    if (buffer.data) {\n      fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());\n      gpuBuffer.unmap();\n    }\n    this._gpuBuffers[buffer.uid] = gpuBuffer;\n    this._managedBuffers.push(buffer);\n    return gpuBuffer;\n  }\n  onBufferChange(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid];\n    gpuBuffer.destroy();\n    buffer._updateID = 0;\n    this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);\n  }\n  /**\n   * Disposes buffer\n   * @param buffer - buffer with data\n   */\n  onBufferDestroy(buffer) {\n    this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);\n    this._destroyBuffer(buffer);\n  }\n  destroy() {\n    this._managedBuffers.forEach(buffer => this._destroyBuffer(buffer));\n    this._managedBuffers = null;\n    this._gpuBuffers = null;\n  }\n  _destroyBuffer(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid];\n    gpuBuffer.destroy();\n    buffer.off(\"update\", this.updateBuffer, this);\n    buffer.off(\"change\", this.onBufferChange, this);\n    buffer.off(\"destroy\", this.onBufferDestroy, this);\n    this._gpuBuffers[buffer.uid] = null;\n  }\n}\n/** @ignore */\nGpuBufferSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"buffer\"\n};\nexport { GpuBufferSystem };","map":{"version":3,"names":["GpuBufferSystem","constructor","_gpuBuffers","Object","create","_managedBuffers","contextChange","gpu","_gpu","getGPUBuffer","buffer","uid","createGPUBuffer","updateBuffer","gpuBuffer","data","_updateID","device","queue","writeBuffer","_updateSize","byteLength","destroyAll","id","destroy","on","onBufferChange","onBufferDestroy","createBuffer","descriptor","fastCopy","getMappedRange","unmap","push","splice","indexOf","_destroyBuffer","forEach","off","extension","type","ExtensionType","WebGPUSystem","name"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gpu/buffer/GpuBufferSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { fastCopy } from '../../shared/buffer/utils/fastCopy';\n\nimport type { Buffer } from '../../shared/buffer/Buffer';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\n\n/**\n * System plugin to the renderer to manage buffers.\n * @memberof rendering\n */\nexport class GpuBufferSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'buffer',\n    } as const;\n\n    protected CONTEXT_UID: number;\n    private _gpuBuffers: { [key: number]: GPUBuffer } = Object.create(null);\n    private readonly _managedBuffers: Buffer[] = [];\n\n    private _gpu: GPU;\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n    }\n\n    public updateBuffer(buffer: Buffer): GPUBuffer\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n\n        const data = buffer.data;\n\n        // TODO this can be better...\n        if (buffer._updateID && data)\n        {\n            buffer._updateID = 0;\n\n            // make sure\n            this._gpu.device.queue.writeBuffer(\n                gpuBuffer, 0, data.buffer, 0,\n                // round to the nearest 4 bytes\n                ((buffer._updateSize || data.byteLength) + 3) & ~3\n            );\n        }\n\n        return gpuBuffer;\n    }\n\n    /** dispose all WebGL resources of all managed buffers */\n    public destroyAll(): void\n    {\n        for (const id in this._gpuBuffers)\n        {\n            this._gpuBuffers[id].destroy();\n        }\n\n        this._gpuBuffers = {};\n    }\n\n    public createGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        if (!this._gpuBuffers[buffer.uid])\n        {\n            buffer.on('update', this.updateBuffer, this);\n            buffer.on('change', this.onBufferChange, this);\n            buffer.on('destroy', this.onBufferDestroy, this);\n        }\n\n        const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n\n        buffer._updateID = 0;\n\n        if (buffer.data)\n        {\n            // TODO if data is static, this can be mapped at creation\n            fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());\n\n            gpuBuffer.unmap();\n        }\n\n        this._gpuBuffers[buffer.uid] = gpuBuffer;\n\n        this._managedBuffers.push(buffer);\n\n        return gpuBuffer;\n    }\n\n    protected onBufferChange(buffer: Buffer)\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid];\n\n        gpuBuffer.destroy();\n        buffer._updateID = 0;\n        this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);\n    }\n\n    /**\n     * Disposes buffer\n     * @param buffer - buffer with data\n     */\n    protected onBufferDestroy(buffer: Buffer): void\n    {\n        this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);\n\n        this._destroyBuffer(buffer);\n    }\n\n    public destroy(): void\n    {\n        this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));\n\n        (this._managedBuffers as null) = null;\n\n        this._gpuBuffers = null;\n    }\n\n    private _destroyBuffer(buffer: Buffer): void\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid];\n\n        gpuBuffer.destroy();\n\n        buffer.off('update', this.updateBuffer, this);\n        buffer.off('change', this.onBufferChange, this);\n        buffer.off('destroy', this.onBufferDestroy, this);\n\n        this._gpuBuffers[buffer.uid] = null;\n    }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}