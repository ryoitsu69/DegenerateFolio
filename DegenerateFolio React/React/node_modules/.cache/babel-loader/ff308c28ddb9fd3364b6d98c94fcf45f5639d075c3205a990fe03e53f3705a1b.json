{"ast":null,"code":"import { Color } from '../../../color/Color.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { nextPow2 } from '../../../maths/misc/pow2.mjs';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox.mjs';\nimport { deprecation } from '../../../utils/logging/deprecation.mjs';\nimport { TextStyle } from '../TextStyle.mjs';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource.mjs';\nimport { CanvasTextMetrics } from './CanvasTextMetrics.mjs';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle.mjs';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle.mjs';\n\"use strict\";\nclass CanvasTextSystem {\n  constructor(_renderer) {\n    this._activeTextures = {};\n    this._renderer = _renderer;\n  }\n  getTextureSize(text, resolution, style) {\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    width = Math.ceil(width - 1e-6);\n    height = Math.ceil(height - 1e-6);\n    width = nextPow2(width);\n    height = nextPow2(height);\n    return {\n      width,\n      height\n    };\n  }\n  getTexture(options, resolution, style, _textKey) {\n    if (typeof options === \"string\") {\n      deprecation(\"8.0.0\", \"CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments\");\n      options = {\n        text: options,\n        style,\n        resolution\n      };\n    }\n    if (!(options.style instanceof TextStyle)) {\n      options.style = new TextStyle(options.style);\n    }\n    const {\n      texture,\n      canvasAndContext\n    } = this.createTextureAndCanvas(options);\n    this._renderer.texture.initSource(texture._source);\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n    return texture;\n  }\n  createTextureAndCanvas(options) {\n    const {\n      text,\n      style\n    } = options;\n    const resolution = options.resolution ?? this._renderer.resolution;\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n    const {\n      canvas\n    } = canvasAndContext;\n    this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n    const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n    if (style.trim) {\n      const trimmed = getCanvasBoundingBox(canvas, resolution);\n      texture.frame.copyFrom(trimmed);\n      texture.updateUvs();\n    }\n    return {\n      texture,\n      canvasAndContext\n    };\n  }\n  getManagedTexture(text) {\n    const textKey = text._getKey();\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].texture;\n    }\n    const {\n      texture,\n      canvasAndContext\n    } = this.createTextureAndCanvas(text);\n    this._activeTextures[textKey] = {\n      canvasAndContext,\n      texture,\n      usageCount: 1\n    };\n    return texture;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n      TexturePool.returnTexture(activeTexture.texture);\n      const source = activeTexture.texture.source;\n      source.resource = null;\n      source.uploadMethodId = \"unknown\";\n      source.alphaMode = \"no-premultiply-alpha\";\n      this._activeTextures[textKey] = null;\n    }\n  }\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey].usageCount;\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   *\n   * By default this is used internally to ensure the texture is correct before rendering,\n   * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n   * and then shared across multiple Sprites.\n   * @param text\n   * @param style\n   * @param resolution\n   * @param canvasAndContext\n   */\n  renderTextToCanvas(text, style, resolution, canvasAndContext) {\n    const {\n      canvas,\n      context\n    } = canvasAndContext;\n    const font = fontStringFromTextStyle(style);\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    const lines = measured.lines;\n    const lineHeight = measured.lineHeight;\n    const lineWidths = measured.lineWidths;\n    const maxLineWidth = measured.maxLineWidth;\n    const fontProperties = measured.fontProperties;\n    const height = canvas.height;\n    context.resetTransform();\n    context.scale(resolution, resolution);\n    const padding = style.padding * 2;\n    context.clearRect(0, 0, measured.width + 4 + padding, measured.height + 4 + padding);\n    if (style._stroke?.width) {\n      const strokeStyle = style._stroke;\n      context.lineWidth = strokeStyle.width;\n      context.miterLimit = strokeStyle.miterLimit;\n      context.lineJoin = strokeStyle.join;\n      context.lineCap = strokeStyle.cap;\n    }\n    context.font = font;\n    let linePositionX;\n    let linePositionY;\n    const passesCount = style.dropShadow ? 2 : 1;\n    for (let i = 0; i < passesCount; ++i) {\n      const isShadowPass = style.dropShadow && i === 0;\n      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;\n      const dsOffsetShadow = dsOffsetText * resolution;\n      if (isShadowPass) {\n        context.fillStyle = \"black\";\n        context.strokeStyle = \"black\";\n        const shadowOptions = style.dropShadow;\n        const dropShadowColor = shadowOptions.color;\n        const dropShadowAlpha = shadowOptions.alpha;\n        context.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();\n        const dropShadowBlur = shadowOptions.blur * resolution;\n        const dropShadowDistance = shadowOptions.distance * resolution;\n        context.shadowBlur = dropShadowBlur;\n        context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n        context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;\n      } else {\n        context.globalAlpha = style._fill?.alpha ?? 1;\n        context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context) : null;\n        if (style._stroke?.width) {\n          context.strokeStyle = getCanvasFillStyle(style._stroke, context);\n        }\n        context.shadowColor = \"black\";\n      }\n      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n      if (lineHeight - fontProperties.fontSize < 0) {\n        linePositionYShift = 0;\n      }\n      const strokeWidth = style._stroke?.width ?? 0;\n      for (let i2 = 0; i2 < lines.length; i2++) {\n        linePositionX = strokeWidth / 2;\n        linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n        if (style.align === \"right\") {\n          linePositionX += maxLineWidth - lineWidths[i2];\n        } else if (style.align === \"center\") {\n          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n        }\n        if (style._stroke?.width) {\n          this._drawLetterSpacing(lines[i2], style, canvasAndContext, linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);\n        }\n        if (style._fill !== void 0) {\n          this._drawLetterSpacing(lines[i2], style, canvasAndContext, linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);\n        }\n      }\n    }\n  }\n  /**\n   * Render the text with letter-spacing.\n   * @param text - The text to draw\n   * @param style\n   * @param canvasAndContext\n   * @param x - Horizontal position to draw the text\n   * @param y - Vertical position to draw the text\n   * @param isStroke - Is this drawing for the outside stroke of the\n   *  text? If not, it's for the inside fill\n   */\n  _drawLetterSpacing(text, style, canvasAndContext, x, y, isStroke = false) {\n    const {\n      context\n    } = canvasAndContext;\n    const letterSpacing = style.letterSpacing;\n    let useExperimentalLetterSpacing = false;\n    if (CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = \"0px\";\n        context.textLetterSpacing = \"0px\";\n      }\n    }\n    if (letterSpacing === 0 || useExperimentalLetterSpacing) {\n      if (isStroke) {\n        context.strokeText(text, x, y);\n      } else {\n        context.fillText(text, x, y);\n      }\n      return;\n    }\n    let currentPosition = x;\n    const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n    let previousWidth = context.measureText(text).width;\n    let currentWidth = 0;\n    for (let i = 0; i < stringArray.length; ++i) {\n      const currentChar = stringArray[i];\n      if (isStroke) {\n        context.strokeText(currentChar, currentPosition, y);\n      } else {\n        context.fillText(currentChar, currentPosition, y);\n      }\n      let textStr = \"\";\n      for (let j = i + 1; j < stringArray.length; ++j) {\n        textStr += stringArray[j];\n      }\n      currentWidth = context.measureText(textStr).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n  }\n  destroy() {\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nCanvasTextSystem.extension = {\n  type: [ExtensionType.WebGLSystem, ExtensionType.WebGPUSystem, ExtensionType.CanvasSystem],\n  name: \"canvasText\"\n};\nexport { CanvasTextSystem };","map":{"version":3,"names":["CanvasTextSystem","constructor","_renderer","_activeTextures","getTextureSize","text","resolution","style","measured","CanvasTextMetrics","measureText","width","Math","ceil","max","padding","height","nextPow2","getTexture","options","_textKey","deprecation","TextStyle","texture","canvasAndContext","createTextureAndCanvas","initSource","_source","CanvasPool","returnCanvasAndContext","getOptimalCanvasAndContext","canvas","renderTextToCanvas","getPo2TextureFromSource","trim","trimmed","getCanvasBoundingBox","frame","copyFrom","updateUvs","getManagedTexture","textKey","_getKey","_increaseReferenceCount","usageCount","decreaseReferenceCount","activeTexture","TexturePool","returnTexture","source","resource","uploadMethodId","alphaMode","getReferenceCount","context","font","fontStringFromTextStyle","lines","lineHeight","lineWidths","maxLineWidth","fontProperties","resetTransform","scale","clearRect","_stroke","strokeStyle","lineWidth","miterLimit","lineJoin","join","lineCap","cap","linePositionX","linePositionY","passesCount","dropShadow","i","isShadowPass","dsOffsetText","dsOffsetShadow","fillStyle","shadowOptions","dropShadowColor","color","dropShadowAlpha","alpha","shadowColor","Color","shared","setValue","setAlpha","toRgbaString","dropShadowBlur","blur","dropShadowDistance","distance","shadowBlur","shadowOffsetX","cos","angle","shadowOffsetY","sin","globalAlpha","_fill","getCanvasFillStyle","linePositionYShift","fontSize","strokeWidth","i2","length","ascent","align","_drawLetterSpacing","x","y","isStroke","letterSpacing","useExperimentalLetterSpacing","experimentalLetterSpacingSupported","experimentalLetterSpacing","textLetterSpacing","strokeText","fillText","currentPosition","stringArray","graphemeSegmenter","previousWidth","currentWidth","currentChar","textStr","j","destroy","extension","type","ExtensionType","WebGLSystem","WebGPUSystem","CanvasSystem","name"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/text/canvas/CanvasTextSystem.ts"],"sourcesContent":["import { Color } from '../../../color/Color';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { nextPow2 } from '../../../maths/misc/pow2';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { TextStyle } from '../TextStyle';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { TextOptions } from '../AbstractText';\nimport type { Text } from '../Text';\n\ninterface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @memberof rendering\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private _activeTextures: Record<string, {\n        canvasAndContext: CanvasAndContext,\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    private readonly _renderer: Renderer;\n\n    constructor(_renderer: Renderer)\n    {\n        this._renderer = _renderer;\n    }\n\n    public getTextureSize(text: string, resolution: number, style: TextStyle): { width: number, height: number }\n    {\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        let width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        let height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        width = Math.ceil((width) - 1e-6);\n        height = Math.ceil((height) - 1e-6);\n        width = nextPow2(width);\n        height = nextPow2(height);\n\n        return { width, height };\n    }\n\n    /**\n     * This is a function that will create a texture from a text string, style and resolution.\n     * Useful if you want to make a texture of your text and use if for various other pixi things!\n     * @param options - The options of the text that will be used to generate the texture.\n     * @param options.text - the text to render\n     * @param options.style - the style of the text\n     * @param options.resolution - the resolution of the texture\n     * @returns the newly created texture\n     */\n    /** @deprecated since 8.0.0 */\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n    public getTexture(options: TextOptions): Texture;\n    public getTexture(options: TextOptions | string, resolution?: number, style?: TextStyle, _textKey?: string): Texture\n    {\n        if (typeof options === 'string')\n        {\n            deprecation('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments');\n\n            options = {\n                text: options,\n                style,\n                resolution,\n            };\n        }\n\n        if (!(options.style instanceof TextStyle))\n        {\n            options.style = new TextStyle(options.style);\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(\n            options as {text: string, style: TextStyle, resolution?: number}\n        );\n\n        this._renderer.texture.initSource(texture._source);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return texture;\n    }\n\n    public createTextureAndCanvas(options: {text: string, style: TextStyle, resolution?: number})\n    {\n        const { text, style } = options;\n\n        const resolution = options.resolution ?? this._renderer.resolution;\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        // create a texture from the canvas\n        const { canvas } = canvasAndContext;\n\n        this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n\n        const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n\n        if (style.trim)\n        {\n            const trimmed = getCanvasBoundingBox(canvas, resolution);\n\n            texture.frame.copyFrom(trimmed);\n\n            texture.updateUvs();\n        }\n\n        return { texture, canvasAndContext };\n    }\n\n    public getManagedTexture(text: Text)\n    {\n        const textKey = text._getKey();\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(text);\n\n        this._activeTextures[textKey] = {\n            canvasAndContext,\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n            TexturePool.returnTexture(activeTexture.texture);\n\n            const source = activeTexture.texture.source;\n\n            source.resource = null;\n            source.uploadMethodId = 'unknown';\n            source.alphaMode = 'no-premultiply-alpha';\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param text\n     * @param style\n     * @param resolution\n     * @param canvasAndContext\n     */\n    public renderTextToCanvas(text: string, style: TextStyle, resolution: number, canvasAndContext: CanvasAndContext): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n\n        context.scale(resolution, resolution);\n\n        const padding = style.padding * 2;\n\n        context.clearRect(0, 0, measured.width + 4 + padding, measured.height + 4 + padding);\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.globalAlpha = style._fill?.alpha ?? 1;\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context) : null;\n\n                if (style._stroke?.width)\n                {\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke?.width)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param style\n     * @param canvasAndContext\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}