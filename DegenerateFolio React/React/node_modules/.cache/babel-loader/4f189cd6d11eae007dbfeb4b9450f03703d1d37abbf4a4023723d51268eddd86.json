{"ast":null,"code":"const CHR = '0123456789abcdef';\nconst U8 = new Uint8Array(256);\nconst U16 = new Uint8Array(256 * 256);\nfor (let i = 0, count = CHR.length; i < count; i++) {\n  U8[CHR[i].charCodeAt(0) | 0] = i | 0;\n  if (i > 9) {\n    U8[CHR[i].toUpperCase().charCodeAt(0) | 0] = i | 0;\n  }\n}\nfor (let i = 0; i < 256; i++) {\n  const s = i << 8;\n  for (let j = 0; j < 256; j++) {\n    U16[s | j] = U8[i] << 4 | U8[j];\n  }\n}\n/**\n * @name hexToU8a\n * @summary Creates a Uint8Array object from a hex string.\n * @description\n * `null` inputs returns an empty `Uint8Array` result. Hex input values return the actual bytes value converted to a Uint8Array. Anything that is not a hex string (including the `0x` prefix) throws an error.\n * @example\n * <BR>\n *\n * ```javascript\n * import { hexToU8a } from '@polkadot/util';\n *\n * hexToU8a('0x80001f'); // Uint8Array([0x80, 0x00, 0x1f])\n * hexToU8a('0x80001f', 32); // Uint8Array([0x00, 0x80, 0x00, 0x1f])\n * ```\n */\nexport function hexToU8a(value, bitLength = -1) {\n  if (!value) {\n    return new Uint8Array();\n  }\n  let s = value.startsWith('0x') ? 2 : 0;\n  const decLength = Math.ceil((value.length - s) / 2);\n  const endLength = Math.ceil(bitLength === -1 ? decLength : bitLength / 8);\n  const result = new Uint8Array(endLength);\n  const offset = endLength > decLength ? endLength - decLength : 0;\n  for (let i = offset; i < endLength; i++, s += 2) {\n    // The big factor here is actually the string lookups. If we do\n    // HEX_TO_U16[value.substring()] we get an 10x slowdown. In the\n    // same vein using charCodeAt (as opposed to value[s] or value.charAt(s)) is\n    // also the faster operation by at least 2x with the character map above\n    result[i] = U16[value.charCodeAt(s) << 8 | value.charCodeAt(s + 1)];\n  }\n  return result;\n}","map":{"version":3,"names":["CHR","U8","Uint8Array","U16","i","count","length","charCodeAt","toUpperCase","s","j","hexToU8a","value","bitLength","startsWith","decLength","Math","ceil","endLength","result","offset"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util/hex/toU8a.js"],"sourcesContent":["const CHR = '0123456789abcdef';\nconst U8 = new Uint8Array(256);\nconst U16 = new Uint8Array(256 * 256);\nfor (let i = 0, count = CHR.length; i < count; i++) {\n    U8[CHR[i].charCodeAt(0) | 0] = i | 0;\n    if (i > 9) {\n        U8[CHR[i].toUpperCase().charCodeAt(0) | 0] = i | 0;\n    }\n}\nfor (let i = 0; i < 256; i++) {\n    const s = i << 8;\n    for (let j = 0; j < 256; j++) {\n        U16[s | j] = (U8[i] << 4) | U8[j];\n    }\n}\n/**\n * @name hexToU8a\n * @summary Creates a Uint8Array object from a hex string.\n * @description\n * `null` inputs returns an empty `Uint8Array` result. Hex input values return the actual bytes value converted to a Uint8Array. Anything that is not a hex string (including the `0x` prefix) throws an error.\n * @example\n * <BR>\n *\n * ```javascript\n * import { hexToU8a } from '@polkadot/util';\n *\n * hexToU8a('0x80001f'); // Uint8Array([0x80, 0x00, 0x1f])\n * hexToU8a('0x80001f', 32); // Uint8Array([0x00, 0x80, 0x00, 0x1f])\n * ```\n */\nexport function hexToU8a(value, bitLength = -1) {\n    if (!value) {\n        return new Uint8Array();\n    }\n    let s = value.startsWith('0x')\n        ? 2\n        : 0;\n    const decLength = Math.ceil((value.length - s) / 2);\n    const endLength = Math.ceil(bitLength === -1\n        ? decLength\n        : bitLength / 8);\n    const result = new Uint8Array(endLength);\n    const offset = endLength > decLength\n        ? endLength - decLength\n        : 0;\n    for (let i = offset; i < endLength; i++, s += 2) {\n        // The big factor here is actually the string lookups. If we do\n        // HEX_TO_U16[value.substring()] we get an 10x slowdown. In the\n        // same vein using charCodeAt (as opposed to value[s] or value.charAt(s)) is\n        // also the faster operation by at least 2x with the character map above\n        result[i] = U16[(value.charCodeAt(s) << 8) | value.charCodeAt(s + 1)];\n    }\n    return result;\n}\n"],"mappings":"AAAA,MAAMA,GAAG,GAAG,kBAAkB;AAC9B,MAAMC,EAAE,GAAG,IAAIC,UAAU,CAAC,GAAG,CAAC;AAC9B,MAAMC,GAAG,GAAG,IAAID,UAAU,CAAC,GAAG,GAAG,GAAG,CAAC;AACrC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEC,KAAK,GAAGL,GAAG,CAACM,MAAM,EAAEF,CAAC,GAAGC,KAAK,EAAED,CAAC,EAAE,EAAE;EAChDH,EAAE,CAACD,GAAG,CAACI,CAAC,CAAC,CAACG,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAGH,CAAC,GAAG,CAAC;EACpC,IAAIA,CAAC,GAAG,CAAC,EAAE;IACPH,EAAE,CAACD,GAAG,CAACI,CAAC,CAAC,CAACI,WAAW,CAAC,CAAC,CAACD,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAGH,CAAC,GAAG,CAAC;EACtD;AACJ;AACA,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,GAAG,EAAEA,CAAC,EAAE,EAAE;EAC1B,MAAMK,CAAC,GAAGL,CAAC,IAAI,CAAC;EAChB,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,GAAG,EAAEA,CAAC,EAAE,EAAE;IAC1BP,GAAG,CAACM,CAAC,GAAGC,CAAC,CAAC,GAAIT,EAAE,CAACG,CAAC,CAAC,IAAI,CAAC,GAAIH,EAAE,CAACS,CAAC,CAAC;EACrC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,QAAQA,CAACC,KAAK,EAAEC,SAAS,GAAG,CAAC,CAAC,EAAE;EAC5C,IAAI,CAACD,KAAK,EAAE;IACR,OAAO,IAAIV,UAAU,CAAC,CAAC;EAC3B;EACA,IAAIO,CAAC,GAAGG,KAAK,CAACE,UAAU,CAAC,IAAI,CAAC,GACxB,CAAC,GACD,CAAC;EACP,MAAMC,SAAS,GAAGC,IAAI,CAACC,IAAI,CAAC,CAACL,KAAK,CAACN,MAAM,GAAGG,CAAC,IAAI,CAAC,CAAC;EACnD,MAAMS,SAAS,GAAGF,IAAI,CAACC,IAAI,CAACJ,SAAS,KAAK,CAAC,CAAC,GACtCE,SAAS,GACTF,SAAS,GAAG,CAAC,CAAC;EACpB,MAAMM,MAAM,GAAG,IAAIjB,UAAU,CAACgB,SAAS,CAAC;EACxC,MAAME,MAAM,GAAGF,SAAS,GAAGH,SAAS,GAC9BG,SAAS,GAAGH,SAAS,GACrB,CAAC;EACP,KAAK,IAAIX,CAAC,GAAGgB,MAAM,EAAEhB,CAAC,GAAGc,SAAS,EAAEd,CAAC,EAAE,EAAEK,CAAC,IAAI,CAAC,EAAE;IAC7C;IACA;IACA;IACA;IACAU,MAAM,CAACf,CAAC,CAAC,GAAGD,GAAG,CAAES,KAAK,CAACL,UAAU,CAACE,CAAC,CAAC,IAAI,CAAC,GAAIG,KAAK,CAACL,UAAU,CAACE,CAAC,GAAG,CAAC,CAAC,CAAC;EACzE;EACA,OAAOU,MAAM;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}