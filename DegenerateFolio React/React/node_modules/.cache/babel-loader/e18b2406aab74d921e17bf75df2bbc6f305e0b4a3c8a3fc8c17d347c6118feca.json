{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview The heart of the WebDriver JavaScript API.\n */\n\n'use strict';\n\nconst by = require('./by');\nconst {\n  RelativeBy\n} = require('./by');\nconst command = require('./command');\nconst error = require('./error');\nconst input = require('./input');\nconst logging = require('./logging');\nconst promise = require('./promise');\nconst Symbols = require('./symbols');\nconst cdp = require('../devtools/CDPConnection');\nconst WebSocket = require('ws');\nconst http = require('../http/index');\nconst fs = require('fs');\nconst {\n  Capabilities\n} = require('./capabilities');\nconst path = require('path');\nconst {\n  NoSuchElementError\n} = require('./error');\nconst cdpTargets = ['page', 'browser'];\nconst {\n  Credential\n} = require('./virtual_authenticator');\nconst webElement = require('./webelement');\nconst {\n  isObject\n} = require('./util');\nconst BIDI = require('../bidi');\nconst {\n  PinnedScript\n} = require('./pinnedScript');\nconst JSZip = require('jszip');\n\n// Capability names that are defined in the W3C spec.\nconst W3C_CAPABILITY_NAMES = new Set(['acceptInsecureCerts', 'browserName', 'browserVersion', 'pageLoadStrategy', 'platformName', 'proxy', 'setWindowRect', 'strictFileInteractability', 'timeouts', 'unhandledPromptBehavior', 'webSocketUrl']);\n\n/**\n * Defines a condition for use with WebDriver's {@linkplain WebDriver#wait wait\n * command}.\n *\n * @template OUT\n */\nclass Condition {\n  /**\n   * @param {string} message A descriptive error message. Should complete the\n   *     sentence \"Waiting [...]\"\n   * @param {function(!WebDriver): OUT} fn The condition function to\n   *     evaluate on each iteration of the wait loop.\n   */\n  constructor(message, fn) {\n    /** @private {string} */\n    this.description_ = 'Waiting ' + message;\n\n    /** @type {function(!WebDriver): OUT} */\n    this.fn = fn;\n  }\n\n  /** @return {string} A description of this condition. */\n  description() {\n    return this.description_;\n  }\n}\n\n/**\n * Defines a condition that will result in a {@link WebElement}.\n *\n * @extends {Condition<!(WebElement|IThenable<!WebElement>)>}\n */\nclass WebElementCondition extends Condition {\n  /**\n   * @param {string} message A descriptive error message. Should complete the\n   *     sentence \"Waiting [...]\"\n   * @param {function(!WebDriver): !(WebElement|IThenable<!WebElement>)}\n   *     fn The condition function to evaluate on each iteration of the wait\n   *     loop.\n   */\n  constructor(message, fn) {\n    super(message, fn);\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  WebDriver\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Translates a command to its wire-protocol representation before passing it\n * to the given `executor` for execution.\n * @param {!command.Executor} executor The executor to use.\n * @param {!command.Command} command The command to execute.\n * @return {!Promise} A promise that will resolve with the command response.\n */\nfunction executeCommand(executor, command) {\n  return toWireValue(command.getParameters()).then(function (parameters) {\n    command.setParameters(parameters);\n    return executor.execute(command);\n  });\n}\n\n/**\n * Converts an object to its JSON representation in the WebDriver wire protocol.\n * When converting values of type object, the following steps will be taken:\n * <ol>\n * <li>if the object is a WebElement, the return value will be the element's\n *     server ID\n * <li>if the object defines a {@link Symbols.serialize} method, this algorithm\n *     will be recursively applied to the object's serialized representation\n * <li>if the object provides a \"toJSON\" function, this algorithm will\n *     recursively be applied to the result of that function\n * <li>otherwise, the value of each key will be recursively converted according\n *     to the rules above.\n * </ol>\n *\n * @param {*} obj The object to convert.\n * @return {!Promise<?>} A promise that will resolve to the input value's JSON\n *     representation.\n */\nasync function toWireValue(obj) {\n  let value = await Promise.resolve(obj);\n  if (value === void 0 || value === null) {\n    return value;\n  }\n  if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string') {\n    return value;\n  }\n  if (Array.isArray(value)) {\n    return convertKeys(value);\n  }\n  if (typeof value === 'function') {\n    return '' + value;\n  }\n  if (typeof value[Symbols.serialize] === 'function') {\n    return toWireValue(value[Symbols.serialize]());\n  } else if (typeof value.toJSON === 'function') {\n    return toWireValue(value.toJSON());\n  }\n  return convertKeys(value);\n}\nasync function convertKeys(obj) {\n  const isArray = Array.isArray(obj);\n  const numKeys = isArray ? obj.length : Object.keys(obj).length;\n  const ret = isArray ? new Array(numKeys) : {};\n  if (!numKeys) {\n    return ret;\n  }\n  async function forEachKey(obj, fn) {\n    if (Array.isArray(obj)) {\n      for (let i = 0, n = obj.length; i < n; i++) {\n        await fn(obj[i], i);\n      }\n    } else {\n      for (let key in obj) {\n        await fn(obj[key], key);\n      }\n    }\n  }\n  await forEachKey(obj, async function (value, key) {\n    ret[key] = await toWireValue(value);\n  });\n  return ret;\n}\n\n/**\n * Converts a value from its JSON representation according to the WebDriver wire\n * protocol. Any JSON object that defines a WebElement ID will be decoded to a\n * {@link WebElement} object. All other values will be passed through as is.\n *\n * @param {!WebDriver} driver The driver to use as the parent of any unwrapped\n *     {@link WebElement} values.\n * @param {*} value The value to convert.\n * @return {*} The converted value.\n */\nfunction fromWireValue(driver, value) {\n  if (Array.isArray(value)) {\n    value = value.map(v => fromWireValue(driver, v));\n  } else if (WebElement.isId(value)) {\n    let id = WebElement.extractId(value);\n    value = new WebElement(driver, id);\n  } else if (ShadowRoot.isId(value)) {\n    let id = ShadowRoot.extractId(value);\n    value = new ShadowRoot(driver, id);\n  } else if (isObject(value)) {\n    let result = {};\n    for (let key in value) {\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\n        result[key] = fromWireValue(driver, value[key]);\n      }\n    }\n    value = result;\n  }\n  return value;\n}\n\n/**\n * Resolves a wait message from either a function or a string.\n * @param {(string|Function)=} message An optional message to use if the wait times out.\n * @return {string} The resolved message\n */\nfunction resolveWaitMessage(message) {\n  return message ? `${typeof message === 'function' ? message() : message}\\n` : '';\n}\n\n/**\n * Structural interface for a WebDriver client.\n *\n * @record\n */\nclass IWebDriver {\n  /**\n   * Executes the provided {@link command.Command} using this driver's\n   * {@link command.Executor}.\n   *\n   * @param {!command.Command} command The command to schedule.\n   * @return {!Promise<T>} A promise that will be resolved with the command\n   *     result.\n   * @template T\n   */\n  execute(command) {} // eslint-disable-line\n\n  /**\n   * Sets the {@linkplain input.FileDetector file detector} that should be\n   * used with this instance.\n   * @param {input.FileDetector} detector The detector to use or `null`.\n   */\n  setFileDetector(detector) {} // eslint-disable-line\n\n  /**\n   * @return {!command.Executor} The command executor used by this instance.\n   */\n  getExecutor() {}\n\n  /**\n   * @return {!Promise<!Session>} A promise for this client's session.\n   */\n  getSession() {}\n\n  /**\n   * @return {!Promise<!Capabilities>} A promise that will resolve with\n   *     the instance's capabilities.\n   */\n  getCapabilities() {}\n\n  /**\n   * Terminates the browser session. After calling quit, this instance will be\n   * invalidated and may no longer be used to issue commands against the\n   * browser.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     command has completed.\n   */\n  quit() {}\n\n  /**\n   * Creates a new action sequence using this driver. The sequence will not be\n   * submitted for execution until\n   * {@link ./input.Actions#perform Actions.perform()} is called.\n   *\n   * @param {{async: (boolean|undefined),\n   *          bridge: (boolean|undefined)}=} options Configuration options for\n   *     the action sequence (see {@link ./input.Actions Actions} documentation\n   *     for details).\n   * @return {!input.Actions} A new action sequence for this instance.\n   */\n  actions(options) {} // eslint-disable-line\n\n  /**\n   * Executes a snippet of JavaScript in the context of the currently selected\n   * frame or window. The script fragment will be executed as the body of an\n   * anonymous function. If the script is provided as a function object, that\n   * function will be converted to a string for injection into the target\n   * window.\n   *\n   * Any arguments provided in addition to the script will be included as script\n   * arguments and may be referenced using the `arguments` object. Arguments may\n   * be a boolean, number, string, or {@linkplain WebElement}. Arrays and\n   * objects may also be used as script arguments as long as each item adheres\n   * to the types previously mentioned.\n   *\n   * The script may refer to any variables accessible from the current window.\n   * Furthermore, the script will execute in the window's context, thus\n   * `document` may be used to refer to the current document. Any local\n   * variables will not be available once the script has finished executing,\n   * though global variables will persist.\n   *\n   * If the script has a return value (i.e. if the script contains a return\n   * statement), then the following steps will be taken for resolving this\n   * functions return value:\n   *\n   * - For a HTML element, the value will resolve to a {@linkplain WebElement}\n   * - Null and undefined return values will resolve to null</li>\n   * - Booleans, numbers, and strings will resolve as is</li>\n   * - Functions will resolve to their string representation</li>\n   * - For arrays and objects, each member item will be converted according to\n   *     the rules above\n   *\n   * @param {!(string|Function)} script The script to execute.\n   * @param {...*} args The arguments to pass to the script.\n   * @return {!IThenable<T>} A promise that will resolve to the\n   *    scripts return value.\n   * @template T\n   */\n  executeScript(script, ...args) {} // eslint-disable-line\n\n  /**\n   * Executes a snippet of asynchronous JavaScript in the context of the\n   * currently selected frame or window. The script fragment will be executed as\n   * the body of an anonymous function. If the script is provided as a function\n   * object, that function will be converted to a string for injection into the\n   * target window.\n   *\n   * Any arguments provided in addition to the script will be included as script\n   * arguments and may be referenced using the `arguments` object. Arguments may\n   * be a boolean, number, string, or {@linkplain WebElement}. Arrays and\n   * objects may also be used as script arguments as long as each item adheres\n   * to the types previously mentioned.\n   *\n   * Unlike executing synchronous JavaScript with {@link #executeScript},\n   * scripts executed with this function must explicitly signal they are\n   * finished by invoking the provided callback. This callback will always be\n   * injected into the executed function as the last argument, and thus may be\n   * referenced with  `arguments[arguments.length - 1]`. The following steps\n   * will be taken for resolving this functions return value against the first\n   * argument to the script's callback function:\n   *\n   * - For a HTML element, the value will resolve to a {@link WebElement}\n   * - Null and undefined return values will resolve to null\n   * - Booleans, numbers, and strings will resolve as is\n   * - Functions will resolve to their string representation\n   * - For arrays and objects, each member item will be converted according to\n   *     the rules above\n   *\n   * __Example #1:__ Performing a sleep that is synchronized with the currently\n   * selected window:\n   *\n   *     var start = new Date().getTime();\n   *     driver.executeAsyncScript(\n   *         'window.setTimeout(arguments[arguments.length - 1], 500);').\n   *         then(function() {\n   *           console.log(\n   *               'Elapsed time: ' + (new Date().getTime() - start) + ' ms');\n   *         });\n   *\n   * __Example #2:__ Synchronizing a test with an AJAX application:\n   *\n   *     var button = driver.findElement(By.id('compose-button'));\n   *     button.click();\n   *     driver.executeAsyncScript(\n   *         'var callback = arguments[arguments.length - 1];' +\n   *         'mailClient.getComposeWindowWidget().onload(callback);');\n   *     driver.switchTo().frame('composeWidget');\n   *     driver.findElement(By.id('to')).sendKeys('dog@example.com');\n   *\n   * __Example #3:__ Injecting a XMLHttpRequest and waiting for the result. In\n   * this example, the inject script is specified with a function literal. When\n   * using this format, the function is converted to a string for injection, so\n   * it should not reference any symbols not defined in the scope of the page\n   * under test.\n   *\n   *     driver.executeAsyncScript(function() {\n   *       var callback = arguments[arguments.length - 1];\n   *       var xhr = new XMLHttpRequest();\n   *       xhr.open(\"GET\", \"/resource/data.json\", true);\n   *       xhr.onreadystatechange = function() {\n   *         if (xhr.readyState == 4) {\n   *           callback(xhr.responseText);\n   *         }\n   *       };\n   *       xhr.send('');\n   *     }).then(function(str) {\n   *       console.log(JSON.parse(str)['food']);\n   *     });\n   *\n   * @param {!(string|Function)} script The script to execute.\n   * @param {...*} args The arguments to pass to the script.\n   * @return {!IThenable<T>} A promise that will resolve to the scripts return\n   *     value.\n   * @template T\n   */\n  executeAsyncScript(script, ...args) {} // eslint-disable-line\n\n  /**\n   * Waits for a condition to evaluate to a \"truthy\" value. The condition may be\n   * specified by a {@link Condition}, as a custom function, or as any\n   * promise-like thenable.\n   *\n   * For a {@link Condition} or function, the wait will repeatedly\n   * evaluate the condition until it returns a truthy value. If any errors occur\n   * while evaluating the condition, they will be allowed to propagate. In the\n   * event a condition returns a {@linkplain Promise}, the polling loop will\n   * wait for it to be resolved and use the resolved value for whether the\n   * condition has been satisfied. The resolution time for a promise is always\n   * factored into whether a wait has timed out.\n   *\n   * If the provided condition is a {@link WebElementCondition}, then\n   * the wait will return a {@link WebElementPromise} that will resolve to the\n   * element that satisfied the condition.\n   *\n   * _Example:_ waiting up to 10 seconds for an element to be present on the\n   * page.\n   *\n   *     async function example() {\n   *       let button =\n   *           await driver.wait(until.elementLocated(By.id('foo')), 10000);\n   *       await button.click();\n   *     }\n   *\n   * @param {!(IThenable<T>|\n   *           Condition<T>|\n   *           function(!WebDriver): T)} condition The condition to\n   *     wait on, defined as a promise, condition object, or  a function to\n   *     evaluate as a condition.\n   * @param {number=} timeout The duration in milliseconds, how long to wait\n   *     for the condition to be true.\n   * @param {(string|Function)=} message An optional message to use if the wait times out.\n   * @param {number=} pollTimeout The duration in milliseconds, how long to\n   *     wait between polling the condition.\n   * @return {!(IThenable<T>|WebElementPromise)} A promise that will be\n   *     resolved with the first truthy value returned by the condition\n   *     function, or rejected if the condition times out. If the input\n   *     condition is an instance of a {@link WebElementCondition},\n   *     the returned value will be a {@link WebElementPromise}.\n   * @throws {TypeError} if the provided `condition` is not a valid type.\n   * @template T\n   */\n  wait(condition,\n  // eslint-disable-line\n  timeout = undefined,\n  // eslint-disable-line\n  message = undefined,\n  // eslint-disable-line\n  pollTimeout = undefined // eslint-disable-line\n  ) {}\n\n  /**\n   * Makes the driver sleep for the given amount of time.\n   *\n   * @param {number} ms The amount of time, in milliseconds, to sleep.\n   * @return {!Promise<void>} A promise that will be resolved when the sleep has\n   *     finished.\n   */\n  sleep(ms) {} // eslint-disable-line\n\n  /**\n   * Retrieves the current window handle.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the current\n   *     window handle.\n   */\n  getWindowHandle() {}\n\n  /**\n   * Retrieves a list of all available window handles.\n   *\n   * @return {!Promise<!Array<string>>} A promise that will be resolved with an\n   *     array of window handles.\n   */\n  getAllWindowHandles() {}\n\n  /**\n   * Retrieves the current page's source. The returned source is a representation\n   * of the underlying DOM: do not expect it to be formatted or escaped in the\n   * same way as the raw response sent from the web server.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the current\n   *     page source.\n   */\n  getPageSource() {}\n\n  /**\n   * Closes the current window.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when this command\n   *     has completed.\n   */\n  close() {}\n\n  /**\n   * Navigates to the given URL.\n   *\n   * @param {string} url The fully qualified URL to open.\n   * @return {!Promise<void>} A promise that will be resolved when the document\n   *     has finished loading.\n   */\n  get(url) {} // eslint-disable-line\n\n  /**\n   * Retrieves the URL for the current page.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the\n   *     current URL.\n   */\n  getCurrentUrl() {}\n\n  /**\n   * Retrieves the current page title.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the current\n   *     page's title.\n   */\n  getTitle() {}\n\n  /**\n   * Locates an element on the page. If the element cannot be found, a\n   * {@link error.NoSuchElementError} will be returned by the driver.\n   *\n   * This function should not be used to test whether an element is present on\n   * the page. Rather, you should use {@link #findElements}:\n   *\n   *     driver.findElements(By.id('foo'))\n   *         .then(found => console.log('Element found? %s', !!found.length));\n   *\n   * The search criteria for an element may be defined using one of the\n   * factories in the {@link webdriver.By} namespace, or as a short-hand\n   * {@link webdriver.By.Hash} object. For example, the following two statements\n   * are equivalent:\n   *\n   *     var e1 = driver.findElement(By.id('foo'));\n   *     var e2 = driver.findElement({id:'foo'});\n   *\n   * You may also provide a custom locator function, which takes as input this\n   * instance and returns a {@link WebElement}, or a promise that will resolve\n   * to a WebElement. If the returned promise resolves to an array of\n   * WebElements, WebDriver will use the first element. For example, to find the\n   * first visible link on a page, you could write:\n   *\n   *     var link = driver.findElement(firstVisibleLink);\n   *\n   *     function firstVisibleLink(driver) {\n   *       var links = driver.findElements(By.tagName('a'));\n   *       return promise.filter(links, function(link) {\n   *         return link.isDisplayed();\n   *       });\n   *     }\n   *\n   * @param {!(by.By|Function)} locator The locator to use.\n   * @return {!WebElementPromise} A WebElement that can be used to issue\n   *     commands against the located element. If the element is not found, the\n   *     element will be invalidated and all scheduled commands aborted.\n   */\n  findElement(locator) {} // eslint-disable-line\n\n  /**\n   * Search for multiple elements on the page. Refer to the documentation on\n   * {@link #findElement(by)} for information on element locator strategies.\n   *\n   * @param {!(by.By|Function)} locator The locator to use.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   */\n  findElements(locator) {} // eslint-disable-line\n\n  /**\n   * Takes a screenshot of the current page. The driver makes the best effort to\n   * return a screenshot of the following, in order of preference:\n   *\n   * 1. Entire page\n   * 2. Current window\n   * 3. Visible portion of the current frame\n   * 4. The entire display containing the browser\n   *\n   * @return {!Promise<string>} A promise that will be resolved to the\n   *     screenshot as a base-64 encoded PNG.\n   */\n  takeScreenshot() {}\n\n  /**\n   * @return {!Options} The options interface for this instance.\n   */\n  manage() {}\n\n  /**\n   * @return {!Navigation} The navigation interface for this instance.\n   */\n  navigate() {}\n\n  /**\n   * @return {!TargetLocator} The target locator interface for this\n   *     instance.\n   */\n  switchTo() {}\n\n  /**\n   *\n   * Takes a PDF of the current page. The driver makes a best effort to\n   * return a PDF based on the provided parameters.\n   *\n   * @param {{orientation:(string|undefined),\n   *         scale:(number|undefined),\n   *         background:(boolean|undefined),\n   *         width:(number|undefined),\n   *         height:(number|undefined),\n   *         top:(number|undefined),\n   *         bottom:(number|undefined),\n   *         left:(number|undefined),\n   *         right:(number|undefined),\n   *         shrinkToFit:(boolean|undefined),\n   *         pageRanges:(Array|undefined)}} options\n   */\n  printPage(options) {} // eslint-disable-line\n}\n\n/**\n * @param {!Capabilities} capabilities A capabilities object.\n * @return {!Capabilities} A copy of the parameter capabilities, omitting\n *     capability names that are not valid W3C names.\n */\nfunction filterNonW3CCaps(capabilities) {\n  let newCaps = new Capabilities(capabilities);\n  for (let k of newCaps.keys()) {\n    // Any key containing a colon is a vendor-prefixed capability.\n    if (!(W3C_CAPABILITY_NAMES.has(k) || k.indexOf(':') >= 0)) {\n      newCaps.delete(k);\n    }\n  }\n  return newCaps;\n}\n\n/**\n * Each WebDriver instance provides automated control over a browser session.\n *\n * @implements {IWebDriver}\n */\nclass WebDriver {\n  /**\n   * @param {!(./session.Session|IThenable<!./session.Session>)} session Either\n   *     a known session or a promise that will be resolved to a session.\n   * @param {!command.Executor} executor The executor to use when sending\n   *     commands to the browser.\n   * @param {(function(this: void): ?)=} onQuit A function to call, if any,\n   *     when the session is terminated.\n   */\n  constructor(session, executor, onQuit = undefined) {\n    /** @private {!Promise<!Session>} */\n    this.session_ = Promise.resolve(session);\n\n    // If session is a rejected promise, add a no-op rejection handler.\n    // This effectively hides setup errors until users attempt to interact\n    // with the session.\n    this.session_.catch(function () {});\n\n    /** @private {!command.Executor} */\n    this.executor_ = executor;\n\n    /** @private {input.FileDetector} */\n    this.fileDetector_ = null;\n\n    /** @private @const {(function(this: void): ?|undefined)} */\n    this.onQuit_ = onQuit;\n\n    /** @private {./virtual_authenticator}*/\n    this.authenticatorId_ = null;\n    this.pinnedScripts_ = {};\n  }\n\n  /**\n   * Creates a new WebDriver session.\n   *\n   * This function will always return a WebDriver instance. If there is an error\n   * creating the session, such as the aforementioned SessionNotCreatedError,\n   * the driver will have a rejected {@linkplain #getSession session} promise.\n   * This rejection will propagate through any subsequent commands scheduled\n   * on the returned WebDriver instance.\n   *\n   *     let required = Capabilities.firefox();\n   *     let driver = WebDriver.createSession(executor, {required});\n   *\n   *     // If the createSession operation failed, then this command will also\n   *     // also fail, propagating the creation failure.\n   *     driver.get('http://www.google.com').catch(e => console.log(e));\n   *\n   * @param {!command.Executor} executor The executor to create the new session\n   *     with.\n   * @param {!Capabilities} capabilities The desired capabilities for the new\n   *     session.\n   * @param {(function(this: void): ?)=} onQuit A callback to invoke when\n   *    the newly created session is terminated. This should be used to clean\n   *    up any resources associated with the session.\n   * @return {!WebDriver} The driver for the newly created session.\n   */\n  static createSession(executor, capabilities, onQuit = undefined) {\n    let cmd = new command.Command(command.Name.NEW_SESSION);\n\n    // For W3C remote ends.\n    cmd.setParameter('capabilities', {\n      firstMatch: [{}],\n      alwaysMatch: filterNonW3CCaps(capabilities)\n    });\n    let session = executeCommand(executor, cmd);\n    if (typeof onQuit === 'function') {\n      session = session.catch(err => {\n        return Promise.resolve(onQuit.call(void 0)).then(_ => {\n          throw err;\n        });\n      });\n    }\n    return new this(session, executor, onQuit);\n  }\n\n  /** @override */\n  async execute(command) {\n    command.setParameter('sessionId', this.session_);\n    let parameters = await toWireValue(command.getParameters());\n    command.setParameters(parameters);\n    let value = await this.executor_.execute(command);\n    return fromWireValue(this, value);\n  }\n\n  /** @override */\n  setFileDetector(detector) {\n    this.fileDetector_ = detector;\n  }\n\n  /** @override */\n  getExecutor() {\n    return this.executor_;\n  }\n\n  /** @override */\n  getSession() {\n    return this.session_;\n  }\n\n  /** @override */\n  getCapabilities() {\n    return this.session_.then(s => s.getCapabilities());\n  }\n\n  /** @override */\n  quit() {\n    let result = this.execute(new command.Command(command.Name.QUIT));\n    // Delete our session ID when the quit command finishes; this will allow us\n    // to throw an error when attempting to use a driver post-quit.\n    return promise.finally(result, () => {\n      this.session_ = Promise.reject(new error.NoSuchSessionError('This driver instance does not have a valid session ID ' + '(did you call WebDriver.quit()?) and may no longer be used.'));\n\n      // Only want the session rejection to bubble if accessed.\n      this.session_.catch(function () {});\n      if (this.onQuit_) {\n        return this.onQuit_.call(void 0);\n      }\n    });\n  }\n\n  /** @override */\n  actions(options) {\n    return new input.Actions(this, options || undefined);\n  }\n\n  /** @override */\n  executeScript(script, ...args) {\n    if (typeof script === 'function') {\n      script = 'return (' + script + ').apply(null, arguments);';\n    }\n    if (script && script instanceof PinnedScript) {\n      return this.execute(new command.Command(command.Name.EXECUTE_SCRIPT).setParameter('script', script.executionScript()).setParameter('args', args));\n    }\n    return this.execute(new command.Command(command.Name.EXECUTE_SCRIPT).setParameter('script', script).setParameter('args', args));\n  }\n\n  /** @override */\n  executeAsyncScript(script, ...args) {\n    if (typeof script === 'function') {\n      script = 'return (' + script + ').apply(null, arguments);';\n    }\n    if (script && script instanceof PinnedScript) {\n      return this.execute(new command.Command(command.Name.EXECUTE_ASYNC_SCRIPT).setParameter('script', script.executionScript()).setParameter('args', args));\n    }\n    return this.execute(new command.Command(command.Name.EXECUTE_ASYNC_SCRIPT).setParameter('script', script).setParameter('args', args));\n  }\n\n  /** @override */\n  wait(condition, timeout = 0, message = undefined, pollTimeout = 200) {\n    if (typeof timeout !== 'number' || timeout < 0) {\n      throw TypeError('timeout must be a number >= 0: ' + timeout);\n    }\n    if (typeof pollTimeout !== 'number' || pollTimeout < 0) {\n      throw TypeError('pollTimeout must be a number >= 0: ' + pollTimeout);\n    }\n    if (promise.isPromise(condition)) {\n      return new Promise((resolve, reject) => {\n        if (!timeout) {\n          resolve(condition);\n          return;\n        }\n        let start = Date.now();\n        let timer = setTimeout(function () {\n          timer = null;\n          try {\n            let timeoutMessage = resolveWaitMessage(message);\n            reject(new error.TimeoutError(`${timeoutMessage}Timed out waiting for promise to resolve after ${Date.now() - start}ms`));\n          } catch (ex) {\n            reject(new error.TimeoutError(`${ex.message}\\nTimed out waiting for promise to resolve after ${Date.now() - start}ms`));\n          }\n        }, timeout);\n        const clearTimer = () => timer && clearTimeout(timer);\n\n        /** @type {!IThenable} */\n        condition.then(function (value) {\n          clearTimer();\n          resolve(value);\n        }, function (error) {\n          clearTimer();\n          reject(error);\n        });\n      });\n    }\n    let fn = /** @type {!Function} */condition;\n    if (condition instanceof Condition) {\n      message = message || condition.description();\n      fn = condition.fn;\n    }\n    if (typeof fn !== 'function') {\n      throw TypeError('Wait condition must be a promise-like object, function, or a ' + 'Condition object');\n    }\n    const driver = this;\n    function evaluateCondition() {\n      return new Promise((resolve, reject) => {\n        try {\n          resolve(fn(driver));\n        } catch (ex) {\n          reject(ex);\n        }\n      });\n    }\n    let result = new Promise((resolve, reject) => {\n      const startTime = Date.now();\n      const pollCondition = async () => {\n        evaluateCondition().then(function (value) {\n          const elapsed = Date.now() - startTime;\n          if (value) {\n            resolve(value);\n          } else if (timeout && elapsed >= timeout) {\n            try {\n              let timeoutMessage = resolveWaitMessage(message);\n              reject(new error.TimeoutError(`${timeoutMessage}Wait timed out after ${elapsed}ms`));\n            } catch (ex) {\n              reject(new error.TimeoutError(`${ex.message}\\nWait timed out after ${elapsed}ms`));\n            }\n          } else {\n            setTimeout(pollCondition, pollTimeout);\n          }\n        }, reject);\n      };\n      pollCondition();\n    });\n    if (condition instanceof WebElementCondition) {\n      result = new WebElementPromise(this, result.then(function (value) {\n        if (!(value instanceof WebElement)) {\n          throw TypeError('WebElementCondition did not resolve to a WebElement: ' + Object.prototype.toString.call(value));\n        }\n        return value;\n      }));\n    }\n    return result;\n  }\n\n  /** @override */\n  sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /** @override */\n  getWindowHandle() {\n    return this.execute(new command.Command(command.Name.GET_CURRENT_WINDOW_HANDLE));\n  }\n\n  /** @override */\n  getAllWindowHandles() {\n    return this.execute(new command.Command(command.Name.GET_WINDOW_HANDLES));\n  }\n\n  /** @override */\n  getPageSource() {\n    return this.execute(new command.Command(command.Name.GET_PAGE_SOURCE));\n  }\n\n  /** @override */\n  close() {\n    return this.execute(new command.Command(command.Name.CLOSE));\n  }\n\n  /** @override */\n  get(url) {\n    return this.navigate().to(url);\n  }\n\n  /** @override */\n  getCurrentUrl() {\n    return this.execute(new command.Command(command.Name.GET_CURRENT_URL));\n  }\n\n  /** @override */\n  getTitle() {\n    return this.execute(new command.Command(command.Name.GET_TITLE));\n  }\n\n  /** @override */\n  findElement(locator) {\n    let id;\n    let cmd = null;\n    if (locator instanceof RelativeBy) {\n      cmd = new command.Command(command.Name.FIND_ELEMENTS_RELATIVE).setParameter('args', locator.marshall());\n    } else {\n      locator = by.checkedLocator(locator);\n    }\n    if (typeof locator === 'function') {\n      id = this.findElementInternal_(locator, this);\n      return new WebElementPromise(this, id);\n    } else if (cmd === null) {\n      cmd = new command.Command(command.Name.FIND_ELEMENT).setParameter('using', locator.using).setParameter('value', locator.value);\n    }\n    id = this.execute(cmd);\n    if (locator instanceof RelativeBy) {\n      return this.normalize_(id);\n    } else {\n      return new WebElementPromise(this, id);\n    }\n  }\n\n  /**\n   * @param {!Function} webElementPromise The webElement in unresolved state\n   * @return {!Promise<!WebElement>} First single WebElement from array of resolved promises\n   */\n  async normalize_(webElementPromise) {\n    let result = await webElementPromise;\n    if (result.length === 0) {\n      throw new NoSuchElementError('Cannot locate an element with provided parameters');\n    } else {\n      return result[0];\n    }\n  }\n\n  /**\n   * @param {!Function} locatorFn The locator function to use.\n   * @param {!(WebDriver|WebElement)} context The search context.\n   * @return {!Promise<!WebElement>} A promise that will resolve to a list of\n   *     WebElements.\n   * @private\n   */\n  async findElementInternal_(locatorFn, context) {\n    let result = await locatorFn(context);\n    if (Array.isArray(result)) {\n      result = result[0];\n    }\n    if (!(result instanceof WebElement)) {\n      throw new TypeError('Custom locator did not return a WebElement');\n    }\n    return result;\n  }\n\n  /** @override */\n  async findElements(locator) {\n    let cmd = null;\n    if (locator instanceof RelativeBy) {\n      cmd = new command.Command(command.Name.FIND_ELEMENTS_RELATIVE).setParameter('args', locator.marshall());\n    } else {\n      locator = by.checkedLocator(locator);\n    }\n    if (typeof locator === 'function') {\n      return this.findElementsInternal_(locator, this);\n    } else if (cmd === null) {\n      cmd = new command.Command(command.Name.FIND_ELEMENTS).setParameter('using', locator.using).setParameter('value', locator.value);\n    }\n    try {\n      let res = await this.execute(cmd);\n      return Array.isArray(res) ? res : [];\n    } catch (ex) {\n      if (ex instanceof error.NoSuchElementError) {\n        return [];\n      }\n      throw ex;\n    }\n  }\n\n  /**\n   * @param {!Function} locatorFn The locator function to use.\n   * @param {!(WebDriver|WebElement)} context The search context.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   * @private\n   */\n  async findElementsInternal_(locatorFn, context) {\n    const result = await locatorFn(context);\n    if (result instanceof WebElement) {\n      return [result];\n    }\n    if (!Array.isArray(result)) {\n      return [];\n    }\n    return result.filter(function (item) {\n      return item instanceof WebElement;\n    });\n  }\n\n  /** @override */\n  takeScreenshot() {\n    return this.execute(new command.Command(command.Name.SCREENSHOT));\n  }\n\n  /** @override */\n  manage() {\n    return new Options(this);\n  }\n\n  /** @override */\n  navigate() {\n    return new Navigation(this);\n  }\n\n  /** @override */\n  switchTo() {\n    return new TargetLocator(this);\n  }\n  validatePrintPageParams(keys, object) {\n    let page = {};\n    let margin = {};\n    let data;\n    Object.keys(keys).forEach(function (key) {\n      data = keys[key];\n      let obj = {\n        orientation: function () {\n          object.orientation = data;\n        },\n        scale: function () {\n          object.scale = data;\n        },\n        background: function () {\n          object.background = data;\n        },\n        width: function () {\n          page.width = data;\n          object.page = page;\n        },\n        height: function () {\n          page.height = data;\n          object.page = page;\n        },\n        top: function () {\n          margin.top = data;\n          object.margin = margin;\n        },\n        left: function () {\n          margin.left = data;\n          object.margin = margin;\n        },\n        bottom: function () {\n          margin.bottom = data;\n          object.margin = margin;\n        },\n        right: function () {\n          margin.right = data;\n          object.margin = margin;\n        },\n        shrinkToFit: function () {\n          object.shrinkToFit = data;\n        },\n        pageRanges: function () {\n          object.pageRanges = data;\n        }\n      };\n      if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n        throw new error.InvalidArgumentError(`Invalid Argument '${key}'`);\n      } else {\n        obj[key]();\n      }\n    });\n    return object;\n  }\n\n  /** @override */\n  printPage(options = {}) {\n    let keys = options;\n    let params = {};\n    let resultObj;\n    let self = this;\n    resultObj = self.validatePrintPageParams(keys, params);\n    return this.execute(new command.Command(command.Name.PRINT_PAGE).setParameters(resultObj));\n  }\n\n  /**\n   * Creates a new WebSocket connection.\n   * @return {!Promise<resolved>} A new CDP instance.\n   */\n  async createCDPConnection(target) {\n    let debuggerUrl = null;\n    const caps = await this.getCapabilities();\n    if (process.env.SELENIUM_REMOTE_URL) {\n      const host = new URL(process.env.SELENIUM_REMOTE_URL).host;\n      const sessionId = await this.getSession().then(session => session.getId());\n      debuggerUrl = `ws://${host}/session/${sessionId}/se/cdp`;\n    } else {\n      const seCdp = caps['map_'].get('se:cdp');\n      const vendorInfo = caps['map_'].get('goog:chromeOptions') || caps['map_'].get('ms:edgeOptions') || caps['map_'].get('moz:debuggerAddress') || new Map();\n      debuggerUrl = seCdp || vendorInfo['debuggerAddress'] || vendorInfo;\n    }\n    this._wsUrl = await this.getWsUrl(debuggerUrl, target, caps);\n    return new Promise((resolve, reject) => {\n      try {\n        this._wsConnection = new WebSocket(this._wsUrl.replace('localhost', '127.0.0.1'));\n        this._cdpConnection = new cdp.CdpConnection(this._wsConnection);\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      this._wsConnection.on('open', async () => {\n        await this.getCdpTargets();\n      });\n      this._wsConnection.on('message', async message => {\n        const params = JSON.parse(message);\n        if (params.result) {\n          if (params.result.targetInfos) {\n            const targets = params.result.targetInfos;\n            const page = targets.find(info => info.type === 'page');\n            if (page) {\n              this.targetID = page.targetId;\n              this._cdpConnection.execute('Target.attachToTarget', {\n                targetId: this.targetID,\n                flatten: true\n              }, null);\n            } else {\n              reject('Unable to find Page target.');\n            }\n          }\n          if (params.result.sessionId) {\n            this.sessionId = params.result.sessionId;\n            this._cdpConnection.sessionId = this.sessionId;\n            resolve(this._cdpConnection);\n          }\n        }\n      });\n      this._wsConnection.on('error', error => {\n        reject(error);\n      });\n    });\n  }\n  async getCdpTargets() {\n    this._cdpConnection.execute('Target.getTargets');\n  }\n\n  /**\n   * Initiates bidi connection using 'webSocketUrl'\n   * @returns {BIDI}\n   */\n  async getBidi() {\n    const caps = await this.getCapabilities();\n    let WebSocketUrl = caps['map_'].get('webSocketUrl');\n    return new BIDI(WebSocketUrl.replace('localhost', '127.0.0.1'));\n  }\n\n  /**\n   * Retrieves 'webSocketDebuggerUrl' by sending a http request using debugger address\n   * @param {string} debuggerAddress\n   * @param target\n   * @param caps\n   * @return {string} Returns parsed webSocketDebuggerUrl obtained from the http request\n   */\n  async getWsUrl(debuggerAddress, target, caps) {\n    if (target && cdpTargets.indexOf(target.toLowerCase()) === -1) {\n      throw new error.InvalidArgumentError('invalid target value');\n    }\n    if (debuggerAddress.match(/\\/se\\/cdp/)) {\n      return debuggerAddress;\n    }\n    let path;\n    if (target === 'page' && caps['map_'].get('browserName') !== 'firefox') {\n      path = '/json';\n    } else if (target === 'page' && caps['map_'].get('browserName') === 'firefox') {\n      path = '/json/list';\n    } else {\n      path = '/json/version';\n    }\n    let request = new http.Request('GET', path);\n    let client = new http.HttpClient('http://' + debuggerAddress);\n    let response = await client.send(request);\n    if (target.toLowerCase() === 'page') {\n      return JSON.parse(response.body)[0]['webSocketDebuggerUrl'];\n    } else {\n      return JSON.parse(response.body)['webSocketDebuggerUrl'];\n    }\n  }\n\n  /**\n   * Sets a listener for Fetch.authRequired event from CDP\n   * If event is triggered, it enters username and password\n   * and allows the test to move forward\n   * @param {string} username\n   * @param {string} password\n   * @param connection CDP Connection\n   */\n  async register(username, password, connection) {\n    this._wsConnection.on('message', message => {\n      const params = JSON.parse(message);\n      if (params.method === 'Fetch.authRequired') {\n        const requestParams = params['params'];\n        connection.execute('Fetch.continueWithAuth', {\n          requestId: requestParams['requestId'],\n          authChallengeResponse: {\n            response: 'ProvideCredentials',\n            username: username,\n            password: password\n          }\n        });\n      } else if (params.method === 'Fetch.requestPaused') {\n        const requestPausedParams = params['params'];\n        connection.execute('Fetch.continueRequest', {\n          requestId: requestPausedParams['requestId']\n        });\n      }\n    });\n    await connection.execute('Fetch.enable', {\n      handleAuthRequests: true\n    }, null);\n    await connection.execute('Network.setCacheDisabled', {\n      cacheDisabled: true\n    }, null);\n  }\n\n  /**\n   * Handle Network interception requests\n   * @param connection WebSocket connection to the browser\n   * @param httpResponse Object representing what we are intercepting\n   *                     as well as what should be returned.\n   * @param callback callback called when we intercept requests.\n   */\n  async onIntercept(connection, httpResponse, callback) {\n    this._wsConnection.on('message', message => {\n      const params = JSON.parse(message);\n      if (params.method === 'Fetch.requestPaused') {\n        const requestPausedParams = params['params'];\n        if (requestPausedParams.request.url == httpResponse.urlToIntercept) {\n          connection.execute('Fetch.fulfillRequest', {\n            requestId: requestPausedParams['requestId'],\n            responseCode: httpResponse.status,\n            responseHeaders: httpResponse.headers,\n            body: httpResponse.body\n          });\n          callback();\n        } else {\n          connection.execute('Fetch.continueRequest', {\n            requestId: requestPausedParams['requestId']\n          });\n        }\n      }\n    });\n    await connection.execute('Fetch.enable', {}, null);\n    await connection.execute('Network.setCacheDisabled', {\n      cacheDisabled: true\n    }, null);\n  }\n\n  /**\n   *\n   * @param connection\n   * @param callback\n   * @returns {Promise<void>}\n   */\n  async onLogEvent(connection, callback) {\n    this._wsConnection.on('message', message => {\n      const params = JSON.parse(message);\n      if (params.method === 'Runtime.consoleAPICalled') {\n        const consoleEventParams = params['params'];\n        let event = {\n          type: consoleEventParams['type'],\n          timestamp: new Date(consoleEventParams['timestamp']),\n          args: consoleEventParams['args']\n        };\n        callback(event);\n      }\n      if (params.method === 'Log.entryAdded') {\n        const logEventParams = params['params'];\n        const logEntry = logEventParams['entry'];\n        let event = {\n          level: logEntry['level'],\n          timestamp: new Date(logEntry['timestamp']),\n          message: logEntry['text']\n        };\n        callback(event);\n      }\n    });\n    await connection.execute('Runtime.enable', {}, null);\n  }\n\n  /**\n   *\n   * @param connection\n   * @param callback\n   * @returns {Promise<void>}\n   */\n  async onLogException(connection, callback) {\n    await connection.execute('Runtime.enable', {}, null);\n    this._wsConnection.on('message', message => {\n      const params = JSON.parse(message);\n      if (params.method === 'Runtime.exceptionThrown') {\n        const exceptionEventParams = params['params'];\n        let event = {\n          exceptionDetails: exceptionEventParams['exceptionDetails'],\n          timestamp: new Date(exceptionEventParams['timestamp'])\n        };\n        callback(event);\n      }\n    });\n  }\n\n  /**\n   * @param connection\n   * @param callback\n   * @returns {Promise<void>}\n   */\n  async logMutationEvents(connection, callback) {\n    await connection.execute('Runtime.enable', {}, null);\n    await connection.execute('Page.enable', {}, null);\n    await connection.execute('Runtime.addBinding', {\n      name: '__webdriver_attribute'\n    }, null);\n    let mutationListener = '';\n    try {\n      // Depending on what is running the code it could appear in 2 different places which is why we try\n      // here and then the other location\n      mutationListener = fs.readFileSync('./javascript/node/selenium-webdriver/lib/atoms/mutation-listener.js', 'utf-8').toString();\n    } catch {\n      mutationListener = fs.readFileSync(path.resolve(__dirname, './atoms/mutation-listener.js'), 'utf-8').toString();\n    }\n    this.executeScript(mutationListener);\n    await connection.execute('Page.addScriptToEvaluateOnNewDocument', {\n      source: mutationListener\n    }, null);\n    this._wsConnection.on('message', async message => {\n      const params = JSON.parse(message);\n      if (params.method === 'Runtime.bindingCalled') {\n        let payload = JSON.parse(params['params']['payload']);\n        let elements = await this.findElements({\n          css: '*[data-__webdriver_id=' + by.escapeCss(payload['target']) + ']'\n        });\n        if (elements.length === 0) {\n          return;\n        }\n        let event = {\n          element: elements[0],\n          attribute_name: payload['name'],\n          current_value: payload['value'],\n          old_value: payload['oldValue']\n        };\n        callback(event);\n      }\n    });\n  }\n  async pinScript(script) {\n    let pinnedScript = new PinnedScript(script);\n    let connection;\n    if (Object.is(this._cdpConnection, undefined)) {\n      connection = await this.createCDPConnection('page');\n    } else {\n      connection = this._cdpConnection;\n    }\n    await connection.execute('Page.enable', {}, null);\n    await connection.execute('Runtime.evaluate', {\n      expression: pinnedScript.creationScript()\n    }, null);\n    let result = await connection.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: pinnedScript.creationScript()\n    });\n    pinnedScript.scriptId = result['result']['identifier'];\n    this.pinnedScripts_[pinnedScript.handle] = pinnedScript;\n    return pinnedScript;\n  }\n  async unpinScript(script) {\n    if (script && !(script instanceof PinnedScript)) {\n      throw Error(`Pass valid PinnedScript object. Received: ${script}`);\n    }\n    if (script.handle in this.pinnedScripts_) {\n      let connection;\n      if (Object.is(this._cdpConnection, undefined)) {\n        connection = this.createCDPConnection('page');\n      } else {\n        connection = this._cdpConnection;\n      }\n      await connection.execute('Page.enable', {}, null);\n      await connection.execute('Runtime.evaluate', {\n        expression: script.removalScript()\n      }, null);\n      await connection.execute('Page.removeScriptToEvaluateOnLoad', {\n        identifier: script.scriptId\n      }, null);\n      delete this.pinnedScripts_[script.handle];\n    }\n  }\n\n  /**\n   *\n   * @returns The value of authenticator ID added\n   */\n  virtualAuthenticatorId() {\n    return this.authenticatorId_;\n  }\n\n  /**\n   * Adds a virtual authenticator with the given options.\n   * @param options VirtualAuthenticatorOptions object to set authenticator options.\n   */\n  async addVirtualAuthenticator(options) {\n    this.authenticatorId_ = await this.execute(new command.Command(command.Name.ADD_VIRTUAL_AUTHENTICATOR).setParameters(options.toDict()));\n  }\n\n  /**\n   * Removes a previously added virtual authenticator. The authenticator is no\n   * longer valid after removal, so no methods may be called.\n   */\n  async removeVirtualAuthenticator() {\n    await this.execute(new command.Command(command.Name.REMOVE_VIRTUAL_AUTHENTICATOR).setParameter('authenticatorId', this.authenticatorId_));\n    this.authenticatorId_ = null;\n  }\n\n  /**\n   * Injects a credential into the authenticator.\n   * @param credential Credential to be added\n   */\n  async addCredential(credential) {\n    credential = credential.toDict();\n    credential['authenticatorId'] = this.authenticatorId_;\n    await this.execute(new command.Command(command.Name.ADD_CREDENTIAL).setParameters(credential));\n  }\n\n  /**\n   *\n   * @returns The list of credentials owned by the authenticator.\n   */\n  async getCredentials() {\n    let credential_data = await this.execute(new command.Command(command.Name.GET_CREDENTIALS).setParameter('authenticatorId', this.virtualAuthenticatorId()));\n    var credential_list = [];\n    for (var i = 0; i < credential_data.length; i++) {\n      credential_list.push(new Credential().fromDict(credential_data[i]));\n    }\n    return credential_list;\n  }\n\n  /**\n   * Removes a credential from the authenticator.\n   * @param credential_id The ID of the credential to be removed.\n   */\n  async removeCredential(credential_id) {\n    // If credential_id is not a base64url, then convert it to base64url.\n    if (Array.isArray(credential_id)) {\n      credential_id = Buffer.from(credential_id).toString('base64url');\n    }\n    await this.execute(new command.Command(command.Name.REMOVE_CREDENTIAL).setParameter('credentialId', credential_id).setParameter('authenticatorId', this.authenticatorId_));\n  }\n\n  /**\n   * Removes all the credentials from the authenticator.\n   */\n  async removeAllCredentials() {\n    await this.execute(new command.Command(command.Name.REMOVE_ALL_CREDENTIALS).setParameter('authenticatorId', this.authenticatorId_));\n  }\n\n  /**\n   * Sets whether the authenticator will simulate success or fail on user verification.\n   * @param verified true if the authenticator will pass user verification, false otherwise.\n   */\n  async setUserVerified(verified) {\n    await this.execute(new command.Command(command.Name.SET_USER_VERIFIED).setParameter('authenticatorId', this.authenticatorId_).setParameter('isUserVerified', verified));\n  }\n  async getDownloadableFiles() {\n    const caps = await this.getCapabilities();\n    if (!caps['map_'].get('se:downloadsEnabled')) {\n      throw new error.WebDriverError('Downloads must be enabled in options');\n    }\n    return (await this.execute(new command.Command(command.Name.GET_DOWNLOADABLE_FILES))).names;\n  }\n  async downloadFile(fileName, targetDirectory) {\n    const caps = await this.getCapabilities();\n    if (!caps['map_'].get('se:downloadsEnabled')) {\n      throw new Error('Downloads must be enabled in options');\n    }\n    const response = await this.execute(new command.Command(command.Name.DOWNLOAD_FILE).setParameter('name', fileName));\n    const base64Content = response.contents;\n    if (!targetDirectory.endsWith('/')) {\n      targetDirectory += '/';\n    }\n    fs.mkdirSync(targetDirectory, {\n      recursive: true\n    });\n    const zipFilePath = path.join(targetDirectory, `${fileName}.zip`);\n    fs.writeFileSync(zipFilePath, Buffer.from(base64Content, 'base64'));\n    const zipData = fs.readFileSync(zipFilePath);\n    await JSZip.loadAsync(zipData).then(zip => {\n      // Iterate through each file in the zip archive\n      Object.keys(zip.files).forEach(async fileName => {\n        const fileData = await zip.files[fileName].async('nodebuffer');\n        fs.writeFileSync(`${targetDirectory}/${fileName}`, fileData);\n        console.log(`File extracted: ${fileName}`);\n      });\n    }).catch(error => {\n      console.error('Error unzipping file:', error);\n    });\n  }\n  async deleteDownloadableFiles() {\n    const caps = await this.getCapabilities();\n    if (!caps['map_'].get('se:downloadsEnabled')) {\n      throw new error.WebDriverError('Downloads must be enabled in options');\n    }\n    return await this.execute(new command.Command(command.Name.DELETE_DOWNLOADABLE_FILES));\n  }\n}\n\n/**\n * Interface for navigating back and forth in the browser history.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with\n *\n *    webdriver.navigate()\n *\n * @see WebDriver#navigate()\n */\nclass Navigation {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Navigates to a new URL.\n   *\n   * @param {string} url The URL to navigate to.\n   * @return {!Promise<void>} A promise that will be resolved when the URL\n   *     has been loaded.\n   */\n  to(url) {\n    return this.driver_.execute(new command.Command(command.Name.GET).setParameter('url', url));\n  }\n\n  /**\n   * Moves backwards in the browser history.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     navigation event has completed.\n   */\n  back() {\n    return this.driver_.execute(new command.Command(command.Name.GO_BACK));\n  }\n\n  /**\n   * Moves forwards in the browser history.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     navigation event has completed.\n   */\n  forward() {\n    return this.driver_.execute(new command.Command(command.Name.GO_FORWARD));\n  }\n\n  /**\n   * Refreshes the current page.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     navigation event has completed.\n   */\n  refresh() {\n    return this.driver_.execute(new command.Command(command.Name.REFRESH));\n  }\n}\n\n/**\n * Provides methods for managing browser and driver state.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with {@linkplain WebDriver#manage() webdriver.manage()}.\n */\nclass Options {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Adds a cookie.\n   *\n   * __Sample Usage:__\n   *\n   *     // Set a basic cookie.\n   *     driver.manage().addCookie({name: 'foo', value: 'bar'});\n   *\n   *     // Set a cookie that expires in 10 minutes.\n   *     let expiry = new Date(Date.now() + (10 * 60 * 1000));\n   *     driver.manage().addCookie({name: 'foo', value: 'bar', expiry});\n   *\n   *     // The cookie expiration may also be specified in seconds since epoch.\n   *     driver.manage().addCookie({\n   *       name: 'foo',\n   *       value: 'bar',\n   *       expiry: Math.floor(Date.now() / 1000)\n   *     });\n   *\n   * @param {!Options.Cookie} spec Defines the cookie to add.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the cookie has been added to the page.\n   * @throws {error.InvalidArgumentError} if any of the cookie parameters are\n   *     invalid.\n   * @throws {TypeError} if `spec` is not a cookie object.\n   */\n  addCookie({\n    name,\n    value,\n    path,\n    domain,\n    secure,\n    httpOnly,\n    expiry,\n    sameSite\n  }) {\n    // We do not allow '=' or ';' in the name.\n    if (/[;=]/.test(name)) {\n      throw new error.InvalidArgumentError('Invalid cookie name \"' + name + '\"');\n    }\n\n    // We do not allow ';' in value.\n    if (/;/.test(value)) {\n      throw new error.InvalidArgumentError('Invalid cookie value \"' + value + '\"');\n    }\n    if (typeof expiry === 'number') {\n      expiry = Math.floor(expiry);\n    } else if (expiry instanceof Date) {\n      let date = /** @type {!Date} */expiry;\n      expiry = Math.floor(date.getTime() / 1000);\n    }\n    if (sameSite && !['Strict', 'Lax', 'None'].includes(sameSite)) {\n      throw new error.InvalidArgumentError(`Invalid sameSite cookie value '${sameSite}'. It should be one of \"Lax\", \"Strict\" or \"None\"`);\n    }\n    if (sameSite === 'None' && !secure) {\n      throw new error.InvalidArgumentError('Invalid cookie configuration: SameSite=None must be Secure');\n    }\n    return this.driver_.execute(new command.Command(command.Name.ADD_COOKIE).setParameter('cookie', {\n      name: name,\n      value: value,\n      path: path,\n      domain: domain,\n      secure: !!secure,\n      httpOnly: !!httpOnly,\n      expiry: expiry,\n      sameSite: sameSite\n    }));\n  }\n\n  /**\n   * Deletes all cookies visible to the current page.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when all cookies have been deleted.\n   */\n  deleteAllCookies() {\n    return this.driver_.execute(new command.Command(command.Name.DELETE_ALL_COOKIES));\n  }\n\n  /**\n   * Deletes the cookie with the given name. This command is a no-op if there is\n   * no cookie with the given name visible to the current page.\n   *\n   * @param {string} name The name of the cookie to delete.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the cookie has been deleted.\n   */\n  deleteCookie(name) {\n    return this.driver_.execute(new command.Command(command.Name.DELETE_COOKIE).setParameter('name', name));\n  }\n\n  /**\n   * Retrieves all cookies visible to the current page. Each cookie will be\n   * returned as a JSON object as described by the WebDriver wire protocol.\n   *\n   * @return {!Promise<!Array<!Options.Cookie>>} A promise that will be\n   *     resolved with the cookies visible to the current browsing context.\n   */\n  getCookies() {\n    return this.driver_.execute(new command.Command(command.Name.GET_ALL_COOKIES));\n  }\n\n  /**\n   * Retrieves the cookie with the given name. Returns null if there is no such\n   * cookie. The cookie will be returned as a JSON object as described by the\n   * WebDriver wire protocol.\n   *\n   * @param {string} name The name of the cookie to retrieve.\n   * @return {!Promise<?Options.Cookie>} A promise that will be resolved\n   *     with the named cookie\n   * @throws {error.NoSuchCookieError} if there is no such cookie.\n   */\n  async getCookie(name) {\n    try {\n      const cookie = await this.driver_.execute(new command.Command(command.Name.GET_COOKIE).setParameter('name', name));\n      return cookie;\n    } catch (err) {\n      if (!(err instanceof error.UnknownCommandError) && !(err instanceof error.UnsupportedOperationError)) {\n        throw err;\n      }\n      const cookies = await this.getCookies();\n      for (let cookie of cookies) {\n        if (cookie && cookie['name'] === name) {\n          return cookie;\n        }\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Fetches the timeouts currently configured for the current session.\n   *\n   * @return {!Promise<{script: number,\n   *                             pageLoad: number,\n   *                             implicit: number}>} A promise that will be\n   *     resolved with the timeouts currently configured for the current\n   *     session.\n   * @see #setTimeouts()\n   */\n  getTimeouts() {\n    return this.driver_.execute(new command.Command(command.Name.GET_TIMEOUT));\n  }\n\n  /**\n   * Sets the timeout durations associated with the current session.\n   *\n   * The following timeouts are supported (all timeouts are specified in\n   * milliseconds):\n   *\n   * -  `implicit` specifies the maximum amount of time to wait for an element\n   *    locator to succeed when {@linkplain WebDriver#findElement locating}\n   *    {@linkplain WebDriver#findElements elements} on the page.\n   *    Defaults to 0 milliseconds.\n   *\n   * -  `pageLoad` specifies the maximum amount of time to wait for a page to\n   *    finishing loading. Defaults to 300000 milliseconds.\n   *\n   * -  `script` specifies the maximum amount of time to wait for an\n   *    {@linkplain WebDriver#executeScript evaluated script} to run. If set to\n   *    `null`, the script timeout will be indefinite.\n   *    Defaults to 30000 milliseconds.\n   *\n   * @param {{script: (number|null|undefined),\n   *          pageLoad: (number|null|undefined),\n   *          implicit: (number|null|undefined)}} conf\n   *     The desired timeout configuration.\n   * @return {!Promise<void>} A promise that will be resolved when the timeouts\n   *     have been set.\n   * @throws {!TypeError} if an invalid options object is provided.\n   * @see #getTimeouts()\n   * @see <https://w3c.github.io/webdriver/webdriver-spec.html#dfn-set-timeouts>\n   */\n  setTimeouts({\n    script,\n    pageLoad,\n    implicit\n  } = {}) {\n    let cmd = new command.Command(command.Name.SET_TIMEOUT);\n    let valid = false;\n    function setParam(key, value) {\n      if (value === null || typeof value === 'number') {\n        valid = true;\n        cmd.setParameter(key, value);\n      } else if (typeof value !== 'undefined') {\n        throw TypeError('invalid timeouts configuration:' + ` expected \"${key}\" to be a number, got ${typeof value}`);\n      }\n    }\n    setParam('implicit', implicit);\n    setParam('pageLoad', pageLoad);\n    setParam('script', script);\n    if (valid) {\n      return this.driver_.execute(cmd).catch(() => {\n        // Fallback to the legacy method.\n        let cmds = [];\n        if (typeof script === 'number') {\n          cmds.push(legacyTimeout(this.driver_, 'script', script));\n        }\n        if (typeof implicit === 'number') {\n          cmds.push(legacyTimeout(this.driver_, 'implicit', implicit));\n        }\n        if (typeof pageLoad === 'number') {\n          cmds.push(legacyTimeout(this.driver_, 'page load', pageLoad));\n        }\n        return Promise.all(cmds);\n      });\n    }\n    throw TypeError('no timeouts specified');\n  }\n\n  /**\n   * @return {!Logs} The interface for managing driver logs.\n   */\n  logs() {\n    return new Logs(this.driver_);\n  }\n\n  /**\n   * @return {!Window} The interface for managing the current window.\n   */\n  window() {\n    return new Window(this.driver_);\n  }\n}\n\n/**\n * @param {!WebDriver} driver\n * @param {string} type\n * @param {number} ms\n * @return {!Promise<void>}\n */\nfunction legacyTimeout(driver, type, ms) {\n  return driver.execute(new command.Command(command.Name.SET_TIMEOUT).setParameter('type', type).setParameter('ms', ms));\n}\n\n/**\n * A record object describing a browser cookie.\n *\n * @record\n */\nOptions.Cookie = function () {};\n\n/**\n * The name of the cookie.\n *\n * @type {string}\n */\nOptions.Cookie.prototype.name;\n\n/**\n * The cookie value.\n *\n * @type {string}\n */\nOptions.Cookie.prototype.value;\n\n/**\n * The cookie path. Defaults to \"/\" when adding a cookie.\n *\n * @type {(string|undefined)}\n */\nOptions.Cookie.prototype.path;\n\n/**\n * The domain the cookie is visible to. Defaults to the current browsing\n * context's document's URL when adding a cookie.\n *\n * @type {(string|undefined)}\n */\nOptions.Cookie.prototype.domain;\n\n/**\n * Whether the cookie is a secure cookie. Defaults to false when adding a new\n * cookie.\n *\n * @type {(boolean|undefined)}\n */\nOptions.Cookie.prototype.secure;\n\n/**\n * Whether the cookie is an HTTP only cookie. Defaults to false when adding a\n * new cookie.\n *\n * @type {(boolean|undefined)}\n */\nOptions.Cookie.prototype.httpOnly;\n\n/**\n * When the cookie expires.\n *\n * When {@linkplain Options#addCookie() adding a cookie}, this may be specified\n * as a {@link Date} object, or in _seconds_ since Unix epoch (January 1, 1970).\n *\n * The expiry is always returned in seconds since epoch when\n * {@linkplain Options#getCookies() retrieving cookies} from the browser.\n *\n * @type {(!Date|number|undefined)}\n */\nOptions.Cookie.prototype.expiry;\n\n/**\n * When the cookie applies to a SameSite policy.\n *\n * When {@linkplain Options#addCookie() adding a cookie}, this may be specified\n * as a {@link string} object which is one of 'Lax', 'Strict' or 'None'.\n *\n *\n * @type {(string|undefined)}\n */\nOptions.Cookie.prototype.sameSite;\n\n/**\n * An interface for managing the current window.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with\n *\n *    webdriver.manage().window()\n *\n * @see WebDriver#manage()\n * @see Options#window()\n */\nclass Window {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n    /** @private {!Logger} */\n    this.log_ = logging.getLogger(logging.Type.DRIVER);\n  }\n\n  /**\n   * Retrieves a rect describing the current top-level window's size and\n   * position.\n   *\n   * @return {!Promise<{x: number, y: number, width: number, height: number}>}\n   *     A promise that will resolve to the window rect of the current window.\n   */\n  getRect() {\n    return this.driver_.execute(new command.Command(command.Name.GET_WINDOW_RECT));\n  }\n\n  /**\n   * Sets the current top-level window's size and position. You may update just\n   * the size by omitting `x` & `y`, or just the position by omitting\n   * `width` & `height` options.\n   *\n   * @param {{x: (number|undefined),\n   *          y: (number|undefined),\n   *          width: (number|undefined),\n   *          height: (number|undefined)}} options\n   *     The desired window size and position.\n   * @return {!Promise<{x: number, y: number, width: number, height: number}>}\n   *     A promise that will resolve to the current window's updated window\n   *     rect.\n   */\n  setRect({\n    x,\n    y,\n    width,\n    height\n  }) {\n    return this.driver_.execute(new command.Command(command.Name.SET_WINDOW_RECT).setParameters({\n      x,\n      y,\n      width,\n      height\n    }));\n  }\n\n  /**\n   * Maximizes the current window. The exact behavior of this command is\n   * specific to individual window managers, but typically involves increasing\n   * the window to the maximum available size without going full-screen.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   */\n  maximize() {\n    return this.driver_.execute(new command.Command(command.Name.MAXIMIZE_WINDOW).setParameter('windowHandle', 'current'));\n  }\n\n  /**\n   * Minimizes the current window. The exact behavior of this command is\n   * specific to individual window managers, but typically involves hiding\n   * the window in the system tray.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   */\n  minimize() {\n    return this.driver_.execute(new command.Command(command.Name.MINIMIZE_WINDOW));\n  }\n\n  /**\n   * Invokes the \"full screen\" operation on the current window. The exact\n   * behavior of this command is specific to individual window managers, but\n   * this will typically increase the window size to the size of the physical\n   * display and hide the browser chrome.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   * @see <https://fullscreen.spec.whatwg.org/#fullscreen-an-element>\n   */\n  fullscreen() {\n    return this.driver_.execute(new command.Command(command.Name.FULLSCREEN_WINDOW));\n  }\n\n  /**\n   * Gets the width and height of the current window\n   * @param windowHandle\n   * @returns {Promise<{width: *, height: *}>}\n   */\n  async getSize(windowHandle = 'current') {\n    if (windowHandle !== 'current') {\n      this.log_.warning(`Only 'current' window is supported for W3C compatible browsers.`);\n    }\n    const rect = await this.getRect();\n    return {\n      height: rect.height,\n      width: rect.width\n    };\n  }\n\n  /**\n   * Sets the width and height of the current window. (window.resizeTo)\n   * @param x\n   * @param y\n   * @param width\n   * @param height\n   * @param windowHandle\n   * @returns {Promise<void>}\n   */\n  async setSize({\n    x = 0,\n    y = 0,\n    width = 0,\n    height = 0\n  }, windowHandle = 'current') {\n    if (windowHandle !== 'current') {\n      this.log_.warning(`Only 'current' window is supported for W3C compatible browsers.`);\n    }\n    await this.setRect({\n      x,\n      y,\n      width,\n      height\n    });\n  }\n}\n\n/**\n * Interface for managing WebDriver log records.\n *\n * This class should never be instantiated directly. Instead, obtain an\n * instance with\n *\n *     webdriver.manage().logs()\n *\n * @see WebDriver#manage()\n * @see Options#logs()\n */\nclass Logs {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Fetches available log entries for the given type.\n   *\n   * Note that log buffers are reset after each call, meaning that available\n   * log entries correspond to those entries not yet returned for a given log\n   * type. In practice, this means that this call will return the available log\n   * entries since the last call, or from the start of the session.\n   *\n   * @param {!logging.Type} type The desired log type.\n   * @return {!Promise<!Array.<!logging.Entry>>} A\n   *   promise that will resolve to a list of log entries for the specified\n   *   type.\n   */\n  get(type) {\n    let cmd = new command.Command(command.Name.GET_LOG).setParameter('type', type);\n    return this.driver_.execute(cmd).then(function (entries) {\n      return entries.map(function (entry) {\n        if (!(entry instanceof logging.Entry)) {\n          return new logging.Entry(entry['level'], entry['message'], entry['timestamp'], entry['type']);\n        }\n        return entry;\n      });\n    });\n  }\n\n  /**\n   * Retrieves the log types available to this driver.\n   * @return {!Promise<!Array<!logging.Type>>} A\n   *     promise that will resolve to a list of available log types.\n   */\n  getAvailableLogTypes() {\n    return this.driver_.execute(new command.Command(command.Name.GET_AVAILABLE_LOG_TYPES));\n  }\n}\n\n/**\n * An interface for changing the focus of the driver to another frame or window.\n *\n * This class should never be instantiated directly. Instead, obtain an\n * instance with\n *\n *     webdriver.switchTo()\n *\n * @see WebDriver#switchTo()\n */\nclass TargetLocator {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Locates the DOM element on the current page that corresponds to\n   * `document.activeElement` or `document.body` if the active element is not\n   * available.\n   *\n   * @return {!WebElementPromise} The active element.\n   */\n  activeElement() {\n    const id = this.driver_.execute(new command.Command(command.Name.GET_ACTIVE_ELEMENT));\n    return new WebElementPromise(this.driver_, id);\n  }\n\n  /**\n   * Switches focus of all future commands to the topmost frame in the current\n   * window.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the default content.\n   */\n  defaultContent() {\n    return this.driver_.execute(new command.Command(command.Name.SWITCH_TO_FRAME).setParameter('id', null));\n  }\n\n  /**\n   * Changes the focus of all future commands to another frame on the page. The\n   * target frame may be specified as one of the following:\n   *\n   * - A number that specifies a (zero-based) index into [window.frames](\n   *   https://developer.mozilla.org/en-US/docs/Web/API/Window.frames).\n   * - A {@link WebElement} reference, which correspond to a `frame` or `iframe`\n   *   DOM element.\n   * - The `null` value, to select the topmost frame on the page. Passing `null`\n   *   is the same as calling {@link #defaultContent defaultContent()}.\n   *\n   * If the specified frame can not be found, the returned promise will be\n   * rejected with a {@linkplain error.NoSuchFrameError}.\n   *\n   * @param {(number|string|WebElement|null)} id The frame locator.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the specified frame.\n   */\n  frame(id) {\n    let frameReference = id;\n    if (typeof id === 'string') {\n      frameReference = this.driver_.findElement({\n        id\n      }).catch(_ => this.driver_.findElement({\n        name: id\n      }));\n    }\n    return this.driver_.execute(new command.Command(command.Name.SWITCH_TO_FRAME).setParameter('id', frameReference));\n  }\n\n  /**\n   * Changes the focus of all future commands to the parent frame of the\n   * currently selected frame. This command has no effect if the driver is\n   * already focused on the top-level browsing context.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   */\n  parentFrame() {\n    return this.driver_.execute(new command.Command(command.Name.SWITCH_TO_FRAME_PARENT));\n  }\n\n  /**\n   * Changes the focus of all future commands to another window. Windows may be\n   * specified by their {@code window.name} attribute or by its handle\n   * (as returned by {@link WebDriver#getWindowHandles}).\n   *\n   * If the specified window cannot be found, the returned promise will be\n   * rejected with a {@linkplain error.NoSuchWindowError}.\n   *\n   * @param {string} nameOrHandle The name or window handle of the window to\n   *     switch focus to.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the specified window.\n   */\n  window(nameOrHandle) {\n    return this.driver_.execute(new command.Command(command.Name.SWITCH_TO_WINDOW)\n    // \"name\" supports the legacy drivers. \"handle\" is the W3C\n    // compliant parameter.\n    .setParameter('name', nameOrHandle).setParameter('handle', nameOrHandle));\n  }\n\n  /**\n   * Creates a new browser window and switches the focus for future\n   * commands of this driver to the new window.\n   *\n   * @param {string} typeHint 'window' or 'tab'. The created window is not\n   *     guaranteed to be of the requested type; if the driver does not support\n   *     the requested type, a new browser window will be created of whatever type\n   *     the driver does support.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the new window.\n   */\n  newWindow(typeHint) {\n    const driver = this.driver_;\n    return this.driver_.execute(new command.Command(command.Name.SWITCH_TO_NEW_WINDOW).setParameter('type', typeHint)).then(function (response) {\n      return driver.switchTo().window(response.handle);\n    });\n  }\n\n  /**\n   * Changes focus to the active modal dialog, such as those opened by\n   * `window.alert()`, `window.confirm()`, and `window.prompt()`. The returned\n   * promise will be rejected with a\n   * {@linkplain error.NoSuchAlertError} if there are no open alerts.\n   *\n   * @return {!AlertPromise} The open alert.\n   */\n  alert() {\n    const text = this.driver_.execute(new command.Command(command.Name.GET_ALERT_TEXT));\n    const driver = this.driver_;\n    return new AlertPromise(driver, text.then(function (text) {\n      return new Alert(driver, text);\n    }));\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  WebElement\n//\n//////////////////////////////////////////////////////////////////////////////\n\nconst LEGACY_ELEMENT_ID_KEY = 'ELEMENT';\nconst ELEMENT_ID_KEY = 'element-6066-11e4-a52e-4f735466cecf';\nconst SHADOW_ROOT_ID_KEY = 'shadow-6066-11e4-a52e-4f735466cecf';\n\n/**\n * Represents a DOM element. WebElements can be found by searching from the\n * document root using a {@link WebDriver} instance, or by searching\n * under another WebElement:\n *\n *     driver.get('http://www.google.com');\n *     var searchForm = driver.findElement(By.tagName('form'));\n *     var searchBox = searchForm.findElement(By.name('q'));\n *     searchBox.sendKeys('webdriver');\n */\nclass WebElement {\n  /**\n   * @param {!WebDriver} driver the parent WebDriver instance for this element.\n   * @param {(!IThenable<string>|string)} id The server-assigned opaque ID for\n   *     the underlying DOM element.\n   */\n  constructor(driver, id) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n\n    /** @private {!Promise<string>} */\n    this.id_ = Promise.resolve(id);\n\n    /** @private {!Logger} */\n    this.log_ = logging.getLogger(logging.Type.DRIVER);\n  }\n\n  /**\n   * @param {string} id The raw ID.\n   * @param {boolean=} noLegacy Whether to exclude the legacy element key.\n   * @return {!Object} The element ID for use with WebDriver's wire protocol.\n   */\n  static buildId(id, noLegacy = false) {\n    return noLegacy ? {\n      [ELEMENT_ID_KEY]: id\n    } : {\n      [ELEMENT_ID_KEY]: id,\n      [LEGACY_ELEMENT_ID_KEY]: id\n    };\n  }\n\n  /**\n   * Extracts the encoded WebElement ID from the object.\n   *\n   * @param {?} obj The object to extract the ID from.\n   * @return {string} the extracted ID.\n   * @throws {TypeError} if the object is not a valid encoded ID.\n   */\n  static extractId(obj) {\n    return webElement.extractId(obj);\n  }\n\n  /**\n   * @param {?} obj the object to test.\n   * @return {boolean} whether the object is a valid encoded WebElement ID.\n   */\n  static isId(obj) {\n    return webElement.isId(obj);\n  }\n\n  /**\n   * Compares two WebElements for equality.\n   *\n   * @param {!WebElement} a A WebElement.\n   * @param {!WebElement} b A WebElement.\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved to whether the two WebElements are equal.\n   */\n  static async equals(a, b) {\n    if (a === b) {\n      return true;\n    }\n    return a.driver_.executeScript('return arguments[0] === arguments[1]', a, b);\n  }\n\n  /** @return {!WebDriver} The parent driver for this instance. */\n  getDriver() {\n    return this.driver_;\n  }\n\n  /**\n   * @return {!Promise<string>} A promise that resolves to\n   *     the server-assigned opaque ID assigned to this element.\n   */\n  getId() {\n    return this.id_;\n  }\n\n  /**\n   * @return {!Object} Returns the serialized representation of this WebElement.\n   */\n  [Symbols.serialize]() {\n    return this.getId().then(WebElement.buildId);\n  }\n\n  /**\n   * Schedules a command that targets this element with the parent WebDriver\n   * instance. Will ensure this element's ID is included in the command\n   * parameters under the \"id\" key.\n   *\n   * @param {!command.Command} command The command to schedule.\n   * @return {!Promise<T>} A promise that will be resolved with the result.\n   * @template T\n   * @see WebDriver#schedule\n   * @private\n   */\n  execute_(command) {\n    command.setParameter('id', this);\n    return this.driver_.execute(command);\n  }\n\n  /**\n   * Schedule a command to find a descendant of this element. If the element\n   * cannot be found, the returned promise will be rejected with a\n   * {@linkplain error.NoSuchElementError NoSuchElementError}.\n   *\n   * The search criteria for an element may be defined using one of the static\n   * factories on the {@link by.By} class, or as a short-hand\n   * {@link ./by.ByHash} object. For example, the following two statements\n   * are equivalent:\n   *\n   *     var e1 = element.findElement(By.id('foo'));\n   *     var e2 = element.findElement({id:'foo'});\n   *\n   * You may also provide a custom locator function, which takes as input this\n   * instance and returns a {@link WebElement}, or a promise that will resolve\n   * to a WebElement. If the returned promise resolves to an array of\n   * WebElements, WebDriver will use the first element. For example, to find the\n   * first visible link on a page, you could write:\n   *\n   *     var link = element.findElement(firstVisibleLink);\n   *\n   *     function firstVisibleLink(element) {\n   *       var links = element.findElements(By.tagName('a'));\n   *       return promise.filter(links, function(link) {\n   *         return link.isDisplayed();\n   *       });\n   *     }\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!WebElementPromise} A WebElement that can be used to issue\n   *     commands against the located element. If the element is not found, the\n   *     element will be invalidated and all scheduled commands aborted.\n   */\n  findElement(locator) {\n    locator = by.checkedLocator(locator);\n    let id;\n    if (typeof locator === 'function') {\n      id = this.driver_.findElementInternal_(locator, this);\n    } else {\n      let cmd = new command.Command(command.Name.FIND_CHILD_ELEMENT).setParameter('using', locator.using).setParameter('value', locator.value);\n      id = this.execute_(cmd);\n    }\n    return new WebElementPromise(this.driver_, id);\n  }\n\n  /**\n   * Locates all the descendants of this element that match the given search\n   * criteria.\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   */\n  async findElements(locator) {\n    locator = by.checkedLocator(locator);\n    if (typeof locator === 'function') {\n      return this.driver_.findElementsInternal_(locator, this);\n    } else {\n      let cmd = new command.Command(command.Name.FIND_CHILD_ELEMENTS).setParameter('using', locator.using).setParameter('value', locator.value);\n      let result = await this.execute_(cmd);\n      return Array.isArray(result) ? result : [];\n    }\n  }\n\n  /**\n   * Clicks on this element.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the click\n   *     command has completed.\n   */\n  click() {\n    return this.execute_(new command.Command(command.Name.CLICK_ELEMENT));\n  }\n\n  /**\n   * Types a key sequence on the DOM element represented by this instance.\n   *\n   * Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is\n   * processed in the key sequence, that key state is toggled until one of the\n   * following occurs:\n   *\n   * - The modifier key is encountered again in the sequence. At this point the\n   *   state of the key is toggled (along with the appropriate keyup/down\n   *   events).\n   * - The {@link input.Key.NULL} key is encountered in the sequence. When\n   *   this key is encountered, all modifier keys current in the down state are\n   *   released (with accompanying keyup events). The NULL key can be used to\n   *   simulate common keyboard shortcuts:\n   *\n   *         element.sendKeys(\"text was\",\n   *                          Key.CONTROL, \"a\", Key.NULL,\n   *                          \"now text is\");\n   *         // Alternatively:\n   *         element.sendKeys(\"text was\",\n   *                          Key.chord(Key.CONTROL, \"a\"),\n   *                          \"now text is\");\n   *\n   * - The end of the key sequence is encountered. When there are no more keys\n   *   to type, all depressed modifier keys are released (with accompanying\n   *   keyup events).\n   *\n   * If this element is a file input ({@code <input type=\"file\">}), the\n   * specified key sequence should specify the path to the file to attach to\n   * the element. This is analogous to the user clicking \"Browse...\" and entering\n   * the path into the file select dialog.\n   *\n   *     var form = driver.findElement(By.css('form'));\n   *     var element = form.findElement(By.css('input[type=file]'));\n   *     element.sendKeys('/path/to/file.txt');\n   *     form.submit();\n   *\n   * For uploads to function correctly, the entered path must reference a file\n   * on the _browser's_ machine, not the local machine running this script. When\n   * running against a remote Selenium server, a {@link input.FileDetector}\n   * may be used to transparently copy files to the remote machine before\n   * attempting to upload them in the browser.\n   *\n   * __Note:__ On browsers where native keyboard events are not supported\n   * (e.g. Firefox on OS X), key events will be synthesized. Special\n   * punctuation keys will be synthesized according to a standard QWERTY en-us\n   * keyboard layout.\n   *\n   * @param {...(number|string|!IThenable<(number|string)>)} args The\n   *     sequence of keys to type. Number keys may be referenced numerically or\n   *     by string (1 or '1'). All arguments will be joined into a single\n   *     sequence.\n   * @return {!Promise<void>} A promise that will be resolved when all keys\n   *     have been typed.\n   */\n  async sendKeys(...args) {\n    let keys = [];\n    (await Promise.all(args)).forEach(key => {\n      let type = typeof key;\n      if (type === 'number') {\n        key = String(key);\n      } else if (type !== 'string') {\n        throw TypeError('each key must be a number or string; got ' + type);\n      }\n\n      // The W3C protocol requires keys to be specified as an array where\n      // each element is a single key.\n      keys.push(...key);\n    });\n    if (!this.driver_.fileDetector_) {\n      return this.execute_(new command.Command(command.Name.SEND_KEYS_TO_ELEMENT).setParameter('text', keys.join('')).setParameter('value', keys));\n    }\n    try {\n      keys = await this.driver_.fileDetector_.handleFile(this.driver_, keys.join(''));\n    } catch (ex) {\n      this.log_.severe('Error trying parse string as a file with file detector; sending keys instead' + ex);\n    }\n    return this.execute_(new command.Command(command.Name.SEND_KEYS_TO_ELEMENT).setParameter('text', keys).setParameter('value', keys.split('')));\n  }\n\n  /**\n   * Retrieves the element's tag name.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the\n   *     element's tag name.\n   */\n  getTagName() {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_TAG_NAME));\n  }\n\n  /**\n   * Retrieves the value of a computed style property for this instance. If\n   * the element inherits the named style from its parent, the parent will be\n   * queried for its value.  Where possible, color values will be converted to\n   * their hex representation (e.g. #00ff00 instead of rgb(0, 255, 0)).\n   *\n   * _Warning:_ the value returned will be as the browser interprets it, so\n   * it may be tricky to form a proper assertion.\n   *\n   * @param {string} cssStyleProperty The name of the CSS style property to look\n   *     up.\n   * @return {!Promise<string>} A promise that will be resolved with the\n   *     requested CSS value.\n   */\n  getCssValue(cssStyleProperty) {\n    const name = command.Name.GET_ELEMENT_VALUE_OF_CSS_PROPERTY;\n    return this.execute_(new command.Command(name).setParameter('propertyName', cssStyleProperty));\n  }\n\n  /**\n   * Retrieves the current value of the given attribute of this element.\n   * Will return the current value, even if it has been modified after the page\n   * has been loaded. More exactly, this method will return the value\n   * of the given attribute, unless that attribute is not present, in which case\n   * the value of the property with the same name is returned. If neither value\n   * is set, null is returned (for example, the \"value\" property of a textarea\n   * element). The \"style\" attribute is converted as best can be to a\n   * text representation with a trailing semicolon. The following are deemed to\n   * be \"boolean\" attributes and will return either \"true\" or null:\n   *\n   * async, autofocus, autoplay, checked, compact, complete, controls, declare,\n   * defaultchecked, defaultselected, defer, disabled, draggable, ended,\n   * formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,\n   * loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,\n   * paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,\n   * selected, spellcheck, truespeed, willvalidate\n   *\n   * Finally, the following commonly mis-capitalized attribute/property names\n   * are evaluated as expected:\n   *\n   * - \"class\"\n   * - \"readonly\"\n   *\n   * @param {string} attributeName The name of the attribute to query.\n   * @return {!Promise<?string>} A promise that will be\n   *     resolved with the attribute's value. The returned value will always be\n   *     either a string or null.\n   */\n  getAttribute(attributeName) {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_ATTRIBUTE).setParameter('name', attributeName));\n  }\n\n  /**\n   * Get the value of the given attribute of the element.\n   * <p>\n   * This method, unlike {@link #getAttribute(String)}, returns the value of the attribute with the\n   * given name but not the property with the same name.\n   * <p>\n   * The following are deemed to be \"boolean\" attributes, and will return either \"true\" or null:\n   * <p>\n   * async, autofocus, autoplay, checked, compact, complete, controls, declare, defaultchecked,\n   * defaultselected, defer, disabled, draggable, ended, formnovalidate, hidden, indeterminate,\n   * iscontenteditable, ismap, itemscope, loop, multiple, muted, nohref, noresize, noshade,\n   * novalidate, nowrap, open, paused, pubdate, readonly, required, reversed, scoped, seamless,\n   * seeking, selected, truespeed, willvalidate\n   * <p>\n   * See <a href=\"https://w3c.github.io/webdriver/#get-element-attribute\">W3C WebDriver specification</a>\n   * for more details.\n   *\n   * @param attributeName The name of the attribute.\n   * @return The attribute's value or null if the value is not set.\n   */\n\n  getDomAttribute(attributeName) {\n    return this.execute_(new command.Command(command.Name.GET_DOM_ATTRIBUTE).setParameter('name', attributeName));\n  }\n\n  /**\n   * Get the given property of the referenced web element\n   * @param {string} propertyName The name of the attribute to query.\n   * @return {!Promise<string>} A promise that will be\n   *     resolved with the element's property value\n   */\n  getProperty(propertyName) {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_PROPERTY).setParameter('name', propertyName));\n  }\n\n  /**\n   * Get the shadow root of the current web element.\n   * @returns {!Promise<ShadowRoot>} A promise that will be\n   *      resolved with the elements shadow root or rejected\n   *      with {@link NoSuchShadowRootError}\n   */\n  getShadowRoot() {\n    return this.execute_(new command.Command(command.Name.GET_SHADOW_ROOT));\n  }\n\n  /**\n   * Get the visible (i.e. not hidden by CSS) innerText of this element,\n   * including sub-elements, without any leading or trailing whitespace.\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved with the element's visible text.\n   */\n  getText() {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_TEXT));\n  }\n\n  /**\n   * Get the computed WAI-ARIA role of element.\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved with the element's computed role.\n   */\n  getAriaRole() {\n    return this.execute_(new command.Command(command.Name.GET_COMPUTED_ROLE));\n  }\n\n  /**\n   * Get the computed WAI-ARIA label of element.\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved with the element's computed label.\n   */\n  getAccessibleName() {\n    return this.execute_(new command.Command(command.Name.GET_COMPUTED_LABEL));\n  }\n\n  /**\n   * Returns an object describing an element's location, in pixels relative to\n   * the document element, and the element's size in pixels.\n   *\n   * @return {!Promise<{width: number, height: number, x: number, y: number}>}\n   *     A promise that will resolve with the element's rect.\n   */\n  getRect() {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_RECT));\n  }\n\n  /**\n   * Tests whether this element is enabled, as dictated by the `disabled`\n   * attribute.\n   *\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved with whether this element is currently enabled.\n   */\n  isEnabled() {\n    return this.execute_(new command.Command(command.Name.IS_ELEMENT_ENABLED));\n  }\n\n  /**\n   * Tests whether this element is selected.\n   *\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved with whether this element is currently selected.\n   */\n  isSelected() {\n    return this.execute_(new command.Command(command.Name.IS_ELEMENT_SELECTED));\n  }\n\n  /**\n   * Submits the form containing this element (or this element if it is itself\n   * a FORM element). his command is a no-op if the element is not contained in\n   * a form.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the form has been submitted.\n   */\n  submit() {\n    const script = '/* submitForm */var form = arguments[0];\\n' + 'while (form.nodeName != \"FORM\" && form.parentNode) {\\n' + '  form = form.parentNode;\\n' + '}\\n' + \"if (!form) { throw Error('Unable to find containing form element'); }\\n\" + \"if (!form.ownerDocument) { throw Error('Unable to find owning document'); }\\n\" + \"var e = form.ownerDocument.createEvent('Event');\\n\" + \"e.initEvent('submit', true, true);\\n\" + 'if (form.dispatchEvent(e)) { HTMLFormElement.prototype.submit.call(form) }\\n';\n    return this.driver_.executeScript(script, this);\n  }\n\n  /**\n   * Clear the `value` of this element. This command has no effect if the\n   * underlying DOM element is neither a text INPUT element nor a TEXTAREA\n   * element.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the element has been cleared.\n   */\n  clear() {\n    return this.execute_(new command.Command(command.Name.CLEAR_ELEMENT));\n  }\n\n  /**\n   * Test whether this element is currently displayed.\n   *\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved with whether this element is currently visible on the page.\n   */\n  isDisplayed() {\n    return this.execute_(new command.Command(command.Name.IS_ELEMENT_DISPLAYED));\n  }\n\n  /**\n   * Take a screenshot of the visible region encompassed by this element's\n   * bounding rectangle.\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved to the screenshot as a base-64 encoded PNG.\n   */\n  takeScreenshot() {\n    return this.execute_(new command.Command(command.Name.TAKE_ELEMENT_SCREENSHOT));\n  }\n}\n\n/**\n * WebElementPromise is a promise that will be fulfilled with a WebElement.\n * This serves as a forward proxy on WebElement, allowing calls to be\n * scheduled without directly on this instance before the underlying\n * WebElement has been fulfilled. In other words, the following two statements\n * are equivalent:\n *\n *     driver.findElement({id: 'my-button'}).click();\n *     driver.findElement({id: 'my-button'}).then(function(el) {\n *       return el.click();\n *     });\n *\n * @implements {IThenable<!WebElement>}\n * @final\n */\nclass WebElementPromise extends WebElement {\n  /**\n   * @param {!WebDriver} driver The parent WebDriver instance for this\n   *     element.\n   * @param {!Promise<!WebElement>} el A promise\n   *     that will resolve to the promised element.\n   */\n  constructor(driver, el) {\n    super(driver, 'unused');\n\n    /** @override */\n    this.then = el.then.bind(el);\n\n    /** @override */\n    this.catch = el.catch.bind(el);\n\n    /**\n     * Defers returning the element ID until the wrapped WebElement has been\n     * resolved.\n     * @override\n     */\n    this.getId = function () {\n      return el.then(function (el) {\n        return el.getId();\n      });\n    };\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  ShadowRoot\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Represents a ShadowRoot of a {@link WebElement}. Provides functions to\n * retrieve elements that live in the DOM below the ShadowRoot.\n */\nclass ShadowRoot {\n  constructor(driver, id) {\n    this.driver_ = driver;\n    this.id_ = id;\n  }\n\n  /**\n   * Extracts the encoded ShadowRoot ID from the object.\n   *\n   * @param {?} obj The object to extract the ID from.\n   * @return {string} the extracted ID.\n   * @throws {TypeError} if the object is not a valid encoded ID.\n   */\n  static extractId(obj) {\n    if (obj && typeof obj === 'object') {\n      if (typeof obj[SHADOW_ROOT_ID_KEY] === 'string') {\n        return obj[SHADOW_ROOT_ID_KEY];\n      }\n    }\n    throw new TypeError('object is not a ShadowRoot ID');\n  }\n\n  /**\n   * @param {?} obj the object to test.\n   * @return {boolean} whether the object is a valid encoded WebElement ID.\n   */\n  static isId(obj) {\n    return obj && typeof obj === 'object' && typeof obj[SHADOW_ROOT_ID_KEY] === 'string';\n  }\n\n  /**\n   * @return {!Object} Returns the serialized representation of this ShadowRoot.\n   */\n  [Symbols.serialize]() {\n    return this.getId();\n  }\n\n  /**\n   * Schedules a command that targets this element with the parent WebDriver\n   * instance. Will ensure this element's ID is included in the command\n   * parameters under the \"id\" key.\n   *\n   * @param {!command.Command} command The command to schedule.\n   * @return {!Promise<T>} A promise that will be resolved with the result.\n   * @template T\n   * @see WebDriver#schedule\n   * @private\n   */\n  execute_(command) {\n    command.setParameter('id', this);\n    return this.driver_.execute(command);\n  }\n\n  /**\n   * Schedule a command to find a descendant of this ShadowROot. If the element\n   * cannot be found, the returned promise will be rejected with a\n   * {@linkplain error.NoSuchElementError NoSuchElementError}.\n   *\n   * The search criteria for an element may be defined using one of the static\n   * factories on the {@link by.By} class, or as a short-hand\n   * {@link ./by.ByHash} object. For example, the following two statements\n   * are equivalent:\n   *\n   *     var e1 = shadowroot.findElement(By.id('foo'));\n   *     var e2 = shadowroot.findElement({id:'foo'});\n   *\n   * You may also provide a custom locator function, which takes as input this\n   * instance and returns a {@link WebElement}, or a promise that will resolve\n   * to a WebElement. If the returned promise resolves to an array of\n   * WebElements, WebDriver will use the first element. For example, to find the\n   * first visible link on a page, you could write:\n   *\n   *     var link = element.findElement(firstVisibleLink);\n   *\n   *     function firstVisibleLink(shadowRoot) {\n   *       var links = shadowRoot.findElements(By.tagName('a'));\n   *       return promise.filter(links, function(link) {\n   *         return link.isDisplayed();\n   *       });\n   *     }\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!WebElementPromise} A WebElement that can be used to issue\n   *     commands against the located element. If the element is not found, the\n   *     element will be invalidated and all scheduled commands aborted.\n   */\n  findElement(locator) {\n    locator = by.checkedLocator(locator);\n    let id;\n    if (typeof locator === 'function') {\n      id = this.driver_.findElementInternal_(locator, this);\n    } else {\n      let cmd = new command.Command(command.Name.FIND_ELEMENT_FROM_SHADOWROOT).setParameter('using', locator.using).setParameter('value', locator.value);\n      id = this.execute_(cmd);\n    }\n    return new ShadowRootPromise(this.driver_, id);\n  }\n\n  /**\n   * Locates all the descendants of this element that match the given search\n   * criteria.\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   */\n  async findElements(locator) {\n    locator = by.checkedLocator(locator);\n    if (typeof locator === 'function') {\n      return this.driver_.findElementsInternal_(locator, this);\n    } else {\n      let cmd = new command.Command(command.Name.FIND_ELEMENTS_FROM_SHADOWROOT).setParameter('using', locator.using).setParameter('value', locator.value);\n      let result = await this.execute_(cmd);\n      return Array.isArray(result) ? result : [];\n    }\n  }\n  getId() {\n    return this.id_;\n  }\n}\n\n/**\n * ShadowRootPromise is a promise that will be fulfilled with a WebElement.\n * This serves as a forward proxy on ShadowRoot, allowing calls to be\n * scheduled without directly on this instance before the underlying\n * ShadowRoot has been fulfilled.\n *\n * @implements { IThenable<!ShadowRoot>}\n * @final\n */\nclass ShadowRootPromise extends ShadowRoot {\n  /**\n   * @param {!WebDriver} driver The parent WebDriver instance for this\n   *     element.\n   * @param {!Promise<!ShadowRoot>} shadow A promise\n   *     that will resolve to the promised element.\n   */\n  constructor(driver, shadow) {\n    super(driver, 'unused');\n\n    /** @override */\n    this.then = shadow.then.bind(shadow);\n\n    /** @override */\n    this.catch = shadow.catch.bind(shadow);\n\n    /**\n     * Defers returning the ShadowRoot ID until the wrapped WebElement has been\n     * resolved.\n     * @override\n     */\n    this.getId = function () {\n      return shadow.then(function (shadow) {\n        return shadow.getId();\n      });\n    };\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  Alert\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Represents a modal dialog such as {@code alert}, {@code confirm}, or\n * {@code prompt}. Provides functions to retrieve the message displayed with\n * the alert, accept or dismiss the alert, and set the response text (in the\n * case of {@code prompt}).\n */\nclass Alert {\n  /**\n   * @param {!WebDriver} driver The driver controlling the browser this alert\n   *     is attached to.\n   * @param {string} text The message text displayed with this alert.\n   */\n  constructor(driver, text) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n\n    /** @private {!Promise<string>} */\n    this.text_ = Promise.resolve(text);\n  }\n\n  /**\n   * Retrieves the message text displayed with this alert. For instance, if the\n   * alert were opened with alert(\"hello\"), then this would return \"hello\".\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved to the text displayed with this alert.\n   */\n  getText() {\n    return this.text_;\n  }\n\n  /**\n   * Accepts this alert.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  accept() {\n    return this.driver_.execute(new command.Command(command.Name.ACCEPT_ALERT));\n  }\n\n  /**\n   * Dismisses this alert.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  dismiss() {\n    return this.driver_.execute(new command.Command(command.Name.DISMISS_ALERT));\n  }\n\n  /**\n   * Sets the response text on this alert. This command will return an error if\n   * the underlying alert does not support response text (e.g. window.alert and\n   * window.confirm).\n   *\n   * @param {string} text The text to set.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  sendKeys(text) {\n    return this.driver_.execute(new command.Command(command.Name.SET_ALERT_TEXT).setParameter('text', text));\n  }\n}\n\n/**\n * AlertPromise is a promise that will be fulfilled with an Alert. This promise\n * serves as a forward proxy on an Alert, allowing calls to be scheduled\n * directly on this instance before the underlying Alert has been fulfilled. In\n * other words, the following two statements are equivalent:\n *\n *     driver.switchTo().alert().dismiss();\n *     driver.switchTo().alert().then(function(alert) {\n *       return alert.dismiss();\n *     });\n *\n * @implements {IThenable<!Alert>}\n * @final\n */\nclass AlertPromise extends Alert {\n  /**\n   * @param {!WebDriver} driver The driver controlling the browser this\n   *     alert is attached to.\n   * @param {!Promise<!Alert>} alert A thenable\n   *     that will be fulfilled with the promised alert.\n   */\n  constructor(driver, alert) {\n    super(driver, 'unused');\n\n    /** @override */\n    this.then = alert.then.bind(alert);\n\n    /** @override */\n    this.catch = alert.catch.bind(alert);\n\n    /**\n     * Defer returning text until the promised alert has been resolved.\n     * @override\n     */\n    this.getText = function () {\n      return alert.then(function (alert) {\n        return alert.getText();\n      });\n    };\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.accept = function () {\n      return alert.then(function (alert) {\n        return alert.accept();\n      });\n    };\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.dismiss = function () {\n      return alert.then(function (alert) {\n        return alert.dismiss();\n      });\n    };\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.sendKeys = function (text) {\n      return alert.then(function (alert) {\n        return alert.sendKeys(text);\n      });\n    };\n  }\n}\n\n// PUBLIC API\n\nmodule.exports = {\n  Alert,\n  AlertPromise,\n  Condition,\n  Logs,\n  Navigation,\n  Options,\n  ShadowRoot,\n  TargetLocator,\n  IWebDriver,\n  WebDriver,\n  WebElement,\n  WebElementCondition,\n  WebElementPromise,\n  Window\n};","map":{"version":3,"names":["by","require","RelativeBy","command","error","input","logging","promise","Symbols","cdp","WebSocket","http","fs","Capabilities","path","NoSuchElementError","cdpTargets","Credential","webElement","isObject","BIDI","PinnedScript","JSZip","W3C_CAPABILITY_NAMES","Set","Condition","constructor","message","fn","description_","description","WebElementCondition","executeCommand","executor","toWireValue","getParameters","then","parameters","setParameters","execute","obj","value","Promise","resolve","Array","isArray","convertKeys","serialize","toJSON","numKeys","length","Object","keys","ret","forEachKey","i","n","key","fromWireValue","driver","map","v","WebElement","isId","id","extractId","ShadowRoot","result","prototype","hasOwnProperty","call","resolveWaitMessage","IWebDriver","setFileDetector","detector","getExecutor","getSession","getCapabilities","quit","actions","options","executeScript","script","args","executeAsyncScript","wait","condition","timeout","undefined","pollTimeout","sleep","ms","getWindowHandle","getAllWindowHandles","getPageSource","close","get","url","getCurrentUrl","getTitle","findElement","locator","findElements","takeScreenshot","manage","navigate","switchTo","printPage","filterNonW3CCaps","capabilities","newCaps","k","has","indexOf","delete","WebDriver","session","onQuit","session_","catch","executor_","fileDetector_","onQuit_","authenticatorId_","pinnedScripts_","createSession","cmd","Command","Name","NEW_SESSION","setParameter","firstMatch","alwaysMatch","err","_","s","QUIT","finally","reject","NoSuchSessionError","Actions","EXECUTE_SCRIPT","executionScript","EXECUTE_ASYNC_SCRIPT","TypeError","isPromise","start","Date","now","timer","setTimeout","timeoutMessage","TimeoutError","ex","clearTimer","clearTimeout","evaluateCondition","startTime","pollCondition","elapsed","WebElementPromise","toString","GET_CURRENT_WINDOW_HANDLE","GET_WINDOW_HANDLES","GET_PAGE_SOURCE","CLOSE","to","GET_CURRENT_URL","GET_TITLE","FIND_ELEMENTS_RELATIVE","marshall","checkedLocator","findElementInternal_","FIND_ELEMENT","using","normalize_","webElementPromise","locatorFn","context","findElementsInternal_","FIND_ELEMENTS","res","filter","item","SCREENSHOT","Options","Navigation","TargetLocator","validatePrintPageParams","object","page","margin","data","forEach","orientation","scale","background","width","height","top","left","bottom","right","shrinkToFit","pageRanges","InvalidArgumentError","params","resultObj","self","PRINT_PAGE","createCDPConnection","target","debuggerUrl","caps","process","env","SELENIUM_REMOTE_URL","host","URL","sessionId","getId","seCdp","vendorInfo","Map","_wsUrl","getWsUrl","_wsConnection","replace","_cdpConnection","CdpConnection","on","getCdpTargets","JSON","parse","targetInfos","targets","find","info","type","targetID","targetId","flatten","getBidi","WebSocketUrl","debuggerAddress","toLowerCase","match","request","Request","client","HttpClient","response","send","body","register","username","password","connection","method","requestParams","requestId","authChallengeResponse","requestPausedParams","handleAuthRequests","cacheDisabled","onIntercept","httpResponse","callback","urlToIntercept","responseCode","status","responseHeaders","headers","onLogEvent","consoleEventParams","event","timestamp","logEventParams","logEntry","level","onLogException","exceptionEventParams","exceptionDetails","logMutationEvents","name","mutationListener","readFileSync","__dirname","source","payload","elements","css","escapeCss","element","attribute_name","current_value","old_value","pinScript","pinnedScript","is","expression","creationScript","scriptId","handle","unpinScript","Error","removalScript","identifier","virtualAuthenticatorId","addVirtualAuthenticator","ADD_VIRTUAL_AUTHENTICATOR","toDict","removeVirtualAuthenticator","REMOVE_VIRTUAL_AUTHENTICATOR","addCredential","credential","ADD_CREDENTIAL","getCredentials","credential_data","GET_CREDENTIALS","credential_list","push","fromDict","removeCredential","credential_id","Buffer","from","REMOVE_CREDENTIAL","removeAllCredentials","REMOVE_ALL_CREDENTIALS","setUserVerified","verified","SET_USER_VERIFIED","getDownloadableFiles","WebDriverError","GET_DOWNLOADABLE_FILES","names","downloadFile","fileName","targetDirectory","DOWNLOAD_FILE","base64Content","contents","endsWith","mkdirSync","recursive","zipFilePath","join","writeFileSync","zipData","loadAsync","zip","files","fileData","async","console","log","deleteDownloadableFiles","DELETE_DOWNLOADABLE_FILES","driver_","GET","back","GO_BACK","forward","GO_FORWARD","refresh","REFRESH","addCookie","domain","secure","httpOnly","expiry","sameSite","test","Math","floor","date","getTime","includes","ADD_COOKIE","deleteAllCookies","DELETE_ALL_COOKIES","deleteCookie","DELETE_COOKIE","getCookies","GET_ALL_COOKIES","getCookie","cookie","GET_COOKIE","UnknownCommandError","UnsupportedOperationError","cookies","getTimeouts","GET_TIMEOUT","setTimeouts","pageLoad","implicit","SET_TIMEOUT","valid","setParam","cmds","legacyTimeout","all","logs","Logs","window","Window","Cookie","log_","getLogger","Type","DRIVER","getRect","GET_WINDOW_RECT","setRect","x","y","SET_WINDOW_RECT","maximize","MAXIMIZE_WINDOW","minimize","MINIMIZE_WINDOW","fullscreen","FULLSCREEN_WINDOW","getSize","windowHandle","warning","rect","setSize","GET_LOG","entries","entry","Entry","getAvailableLogTypes","GET_AVAILABLE_LOG_TYPES","activeElement","GET_ACTIVE_ELEMENT","defaultContent","SWITCH_TO_FRAME","frame","frameReference","parentFrame","SWITCH_TO_FRAME_PARENT","nameOrHandle","SWITCH_TO_WINDOW","newWindow","typeHint","SWITCH_TO_NEW_WINDOW","alert","text","GET_ALERT_TEXT","AlertPromise","Alert","LEGACY_ELEMENT_ID_KEY","ELEMENT_ID_KEY","SHADOW_ROOT_ID_KEY","id_","buildId","noLegacy","equals","a","b","getDriver","execute_","FIND_CHILD_ELEMENT","FIND_CHILD_ELEMENTS","click","CLICK_ELEMENT","sendKeys","String","SEND_KEYS_TO_ELEMENT","handleFile","severe","split","getTagName","GET_ELEMENT_TAG_NAME","getCssValue","cssStyleProperty","GET_ELEMENT_VALUE_OF_CSS_PROPERTY","getAttribute","attributeName","GET_ELEMENT_ATTRIBUTE","getDomAttribute","GET_DOM_ATTRIBUTE","getProperty","propertyName","GET_ELEMENT_PROPERTY","getShadowRoot","GET_SHADOW_ROOT","getText","GET_ELEMENT_TEXT","getAriaRole","GET_COMPUTED_ROLE","getAccessibleName","GET_COMPUTED_LABEL","GET_ELEMENT_RECT","isEnabled","IS_ELEMENT_ENABLED","isSelected","IS_ELEMENT_SELECTED","submit","clear","CLEAR_ELEMENT","isDisplayed","IS_ELEMENT_DISPLAYED","TAKE_ELEMENT_SCREENSHOT","el","bind","FIND_ELEMENT_FROM_SHADOWROOT","ShadowRootPromise","FIND_ELEMENTS_FROM_SHADOWROOT","shadow","text_","accept","ACCEPT_ALERT","dismiss","DISMISS_ALERT","SET_ALERT_TEXT","module","exports"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/selenium-webdriver/lib/webdriver.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview The heart of the WebDriver JavaScript API.\n */\n\n'use strict'\n\nconst by = require('./by')\nconst { RelativeBy } = require('./by')\nconst command = require('./command')\nconst error = require('./error')\nconst input = require('./input')\nconst logging = require('./logging')\nconst promise = require('./promise')\nconst Symbols = require('./symbols')\nconst cdp = require('../devtools/CDPConnection')\nconst WebSocket = require('ws')\nconst http = require('../http/index')\nconst fs = require('fs')\nconst { Capabilities } = require('./capabilities')\nconst path = require('path')\nconst { NoSuchElementError } = require('./error')\nconst cdpTargets = ['page', 'browser']\nconst { Credential } = require('./virtual_authenticator')\nconst webElement = require('./webelement')\nconst { isObject } = require('./util')\nconst BIDI = require('../bidi')\nconst { PinnedScript } = require('./pinnedScript')\nconst JSZip = require('jszip')\n\n// Capability names that are defined in the W3C spec.\nconst W3C_CAPABILITY_NAMES = new Set([\n  'acceptInsecureCerts',\n  'browserName',\n  'browserVersion',\n  'pageLoadStrategy',\n  'platformName',\n  'proxy',\n  'setWindowRect',\n  'strictFileInteractability',\n  'timeouts',\n  'unhandledPromptBehavior',\n  'webSocketUrl',\n])\n\n/**\n * Defines a condition for use with WebDriver's {@linkplain WebDriver#wait wait\n * command}.\n *\n * @template OUT\n */\nclass Condition {\n  /**\n   * @param {string} message A descriptive error message. Should complete the\n   *     sentence \"Waiting [...]\"\n   * @param {function(!WebDriver): OUT} fn The condition function to\n   *     evaluate on each iteration of the wait loop.\n   */\n  constructor(message, fn) {\n    /** @private {string} */\n    this.description_ = 'Waiting ' + message\n\n    /** @type {function(!WebDriver): OUT} */\n    this.fn = fn\n  }\n\n  /** @return {string} A description of this condition. */\n  description() {\n    return this.description_\n  }\n}\n\n/**\n * Defines a condition that will result in a {@link WebElement}.\n *\n * @extends {Condition<!(WebElement|IThenable<!WebElement>)>}\n */\nclass WebElementCondition extends Condition {\n  /**\n   * @param {string} message A descriptive error message. Should complete the\n   *     sentence \"Waiting [...]\"\n   * @param {function(!WebDriver): !(WebElement|IThenable<!WebElement>)}\n   *     fn The condition function to evaluate on each iteration of the wait\n   *     loop.\n   */\n  constructor(message, fn) {\n    super(message, fn)\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  WebDriver\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Translates a command to its wire-protocol representation before passing it\n * to the given `executor` for execution.\n * @param {!command.Executor} executor The executor to use.\n * @param {!command.Command} command The command to execute.\n * @return {!Promise} A promise that will resolve with the command response.\n */\nfunction executeCommand(executor, command) {\n  return toWireValue(command.getParameters()).then(function (parameters) {\n    command.setParameters(parameters)\n    return executor.execute(command)\n  })\n}\n\n/**\n * Converts an object to its JSON representation in the WebDriver wire protocol.\n * When converting values of type object, the following steps will be taken:\n * <ol>\n * <li>if the object is a WebElement, the return value will be the element's\n *     server ID\n * <li>if the object defines a {@link Symbols.serialize} method, this algorithm\n *     will be recursively applied to the object's serialized representation\n * <li>if the object provides a \"toJSON\" function, this algorithm will\n *     recursively be applied to the result of that function\n * <li>otherwise, the value of each key will be recursively converted according\n *     to the rules above.\n * </ol>\n *\n * @param {*} obj The object to convert.\n * @return {!Promise<?>} A promise that will resolve to the input value's JSON\n *     representation.\n */\nasync function toWireValue(obj) {\n  let value = await Promise.resolve(obj)\n  if (value === void 0 || value === null) {\n    return value\n  }\n\n  if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string') {\n    return value\n  }\n\n  if (Array.isArray(value)) {\n    return convertKeys(value)\n  }\n\n  if (typeof value === 'function') {\n    return '' + value\n  }\n\n  if (typeof value[Symbols.serialize] === 'function') {\n    return toWireValue(value[Symbols.serialize]())\n  } else if (typeof value.toJSON === 'function') {\n    return toWireValue(value.toJSON())\n  }\n  return convertKeys(value)\n}\n\nasync function convertKeys(obj) {\n  const isArray = Array.isArray(obj)\n  const numKeys = isArray ? obj.length : Object.keys(obj).length\n  const ret = isArray ? new Array(numKeys) : {}\n  if (!numKeys) {\n    return ret\n  }\n\n  async function forEachKey(obj, fn) {\n    if (Array.isArray(obj)) {\n      for (let i = 0, n = obj.length; i < n; i++) {\n        await fn(obj[i], i)\n      }\n    } else {\n      for (let key in obj) {\n        await fn(obj[key], key)\n      }\n    }\n  }\n\n  await forEachKey(obj, async function (value, key) {\n    ret[key] = await toWireValue(value)\n  })\n\n  return ret\n}\n\n/**\n * Converts a value from its JSON representation according to the WebDriver wire\n * protocol. Any JSON object that defines a WebElement ID will be decoded to a\n * {@link WebElement} object. All other values will be passed through as is.\n *\n * @param {!WebDriver} driver The driver to use as the parent of any unwrapped\n *     {@link WebElement} values.\n * @param {*} value The value to convert.\n * @return {*} The converted value.\n */\nfunction fromWireValue(driver, value) {\n  if (Array.isArray(value)) {\n    value = value.map((v) => fromWireValue(driver, v))\n  } else if (WebElement.isId(value)) {\n    let id = WebElement.extractId(value)\n    value = new WebElement(driver, id)\n  } else if (ShadowRoot.isId(value)) {\n    let id = ShadowRoot.extractId(value)\n    value = new ShadowRoot(driver, id)\n  } else if (isObject(value)) {\n    let result = {}\n    for (let key in value) {\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\n        result[key] = fromWireValue(driver, value[key])\n      }\n    }\n    value = result\n  }\n  return value\n}\n\n/**\n * Resolves a wait message from either a function or a string.\n * @param {(string|Function)=} message An optional message to use if the wait times out.\n * @return {string} The resolved message\n */\nfunction resolveWaitMessage(message) {\n  return message ? `${typeof message === 'function' ? message() : message}\\n` : ''\n}\n\n/**\n * Structural interface for a WebDriver client.\n *\n * @record\n */\nclass IWebDriver {\n  /**\n   * Executes the provided {@link command.Command} using this driver's\n   * {@link command.Executor}.\n   *\n   * @param {!command.Command} command The command to schedule.\n   * @return {!Promise<T>} A promise that will be resolved with the command\n   *     result.\n   * @template T\n   */\n  execute(command) {} // eslint-disable-line\n\n  /**\n   * Sets the {@linkplain input.FileDetector file detector} that should be\n   * used with this instance.\n   * @param {input.FileDetector} detector The detector to use or `null`.\n   */\n  setFileDetector(detector) {} // eslint-disable-line\n\n  /**\n   * @return {!command.Executor} The command executor used by this instance.\n   */\n  getExecutor() {}\n\n  /**\n   * @return {!Promise<!Session>} A promise for this client's session.\n   */\n  getSession() {}\n\n  /**\n   * @return {!Promise<!Capabilities>} A promise that will resolve with\n   *     the instance's capabilities.\n   */\n  getCapabilities() {}\n\n  /**\n   * Terminates the browser session. After calling quit, this instance will be\n   * invalidated and may no longer be used to issue commands against the\n   * browser.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     command has completed.\n   */\n  quit() {}\n\n  /**\n   * Creates a new action sequence using this driver. The sequence will not be\n   * submitted for execution until\n   * {@link ./input.Actions#perform Actions.perform()} is called.\n   *\n   * @param {{async: (boolean|undefined),\n   *          bridge: (boolean|undefined)}=} options Configuration options for\n   *     the action sequence (see {@link ./input.Actions Actions} documentation\n   *     for details).\n   * @return {!input.Actions} A new action sequence for this instance.\n   */\n  actions(options) {} // eslint-disable-line\n\n  /**\n   * Executes a snippet of JavaScript in the context of the currently selected\n   * frame or window. The script fragment will be executed as the body of an\n   * anonymous function. If the script is provided as a function object, that\n   * function will be converted to a string for injection into the target\n   * window.\n   *\n   * Any arguments provided in addition to the script will be included as script\n   * arguments and may be referenced using the `arguments` object. Arguments may\n   * be a boolean, number, string, or {@linkplain WebElement}. Arrays and\n   * objects may also be used as script arguments as long as each item adheres\n   * to the types previously mentioned.\n   *\n   * The script may refer to any variables accessible from the current window.\n   * Furthermore, the script will execute in the window's context, thus\n   * `document` may be used to refer to the current document. Any local\n   * variables will not be available once the script has finished executing,\n   * though global variables will persist.\n   *\n   * If the script has a return value (i.e. if the script contains a return\n   * statement), then the following steps will be taken for resolving this\n   * functions return value:\n   *\n   * - For a HTML element, the value will resolve to a {@linkplain WebElement}\n   * - Null and undefined return values will resolve to null</li>\n   * - Booleans, numbers, and strings will resolve as is</li>\n   * - Functions will resolve to their string representation</li>\n   * - For arrays and objects, each member item will be converted according to\n   *     the rules above\n   *\n   * @param {!(string|Function)} script The script to execute.\n   * @param {...*} args The arguments to pass to the script.\n   * @return {!IThenable<T>} A promise that will resolve to the\n   *    scripts return value.\n   * @template T\n   */\n  executeScript(script, ...args) {} // eslint-disable-line\n\n  /**\n   * Executes a snippet of asynchronous JavaScript in the context of the\n   * currently selected frame or window. The script fragment will be executed as\n   * the body of an anonymous function. If the script is provided as a function\n   * object, that function will be converted to a string for injection into the\n   * target window.\n   *\n   * Any arguments provided in addition to the script will be included as script\n   * arguments and may be referenced using the `arguments` object. Arguments may\n   * be a boolean, number, string, or {@linkplain WebElement}. Arrays and\n   * objects may also be used as script arguments as long as each item adheres\n   * to the types previously mentioned.\n   *\n   * Unlike executing synchronous JavaScript with {@link #executeScript},\n   * scripts executed with this function must explicitly signal they are\n   * finished by invoking the provided callback. This callback will always be\n   * injected into the executed function as the last argument, and thus may be\n   * referenced with  `arguments[arguments.length - 1]`. The following steps\n   * will be taken for resolving this functions return value against the first\n   * argument to the script's callback function:\n   *\n   * - For a HTML element, the value will resolve to a {@link WebElement}\n   * - Null and undefined return values will resolve to null\n   * - Booleans, numbers, and strings will resolve as is\n   * - Functions will resolve to their string representation\n   * - For arrays and objects, each member item will be converted according to\n   *     the rules above\n   *\n   * __Example #1:__ Performing a sleep that is synchronized with the currently\n   * selected window:\n   *\n   *     var start = new Date().getTime();\n   *     driver.executeAsyncScript(\n   *         'window.setTimeout(arguments[arguments.length - 1], 500);').\n   *         then(function() {\n   *           console.log(\n   *               'Elapsed time: ' + (new Date().getTime() - start) + ' ms');\n   *         });\n   *\n   * __Example #2:__ Synchronizing a test with an AJAX application:\n   *\n   *     var button = driver.findElement(By.id('compose-button'));\n   *     button.click();\n   *     driver.executeAsyncScript(\n   *         'var callback = arguments[arguments.length - 1];' +\n   *         'mailClient.getComposeWindowWidget().onload(callback);');\n   *     driver.switchTo().frame('composeWidget');\n   *     driver.findElement(By.id('to')).sendKeys('dog@example.com');\n   *\n   * __Example #3:__ Injecting a XMLHttpRequest and waiting for the result. In\n   * this example, the inject script is specified with a function literal. When\n   * using this format, the function is converted to a string for injection, so\n   * it should not reference any symbols not defined in the scope of the page\n   * under test.\n   *\n   *     driver.executeAsyncScript(function() {\n   *       var callback = arguments[arguments.length - 1];\n   *       var xhr = new XMLHttpRequest();\n   *       xhr.open(\"GET\", \"/resource/data.json\", true);\n   *       xhr.onreadystatechange = function() {\n   *         if (xhr.readyState == 4) {\n   *           callback(xhr.responseText);\n   *         }\n   *       };\n   *       xhr.send('');\n   *     }).then(function(str) {\n   *       console.log(JSON.parse(str)['food']);\n   *     });\n   *\n   * @param {!(string|Function)} script The script to execute.\n   * @param {...*} args The arguments to pass to the script.\n   * @return {!IThenable<T>} A promise that will resolve to the scripts return\n   *     value.\n   * @template T\n   */\n  executeAsyncScript(script, ...args) {} // eslint-disable-line\n\n  /**\n   * Waits for a condition to evaluate to a \"truthy\" value. The condition may be\n   * specified by a {@link Condition}, as a custom function, or as any\n   * promise-like thenable.\n   *\n   * For a {@link Condition} or function, the wait will repeatedly\n   * evaluate the condition until it returns a truthy value. If any errors occur\n   * while evaluating the condition, they will be allowed to propagate. In the\n   * event a condition returns a {@linkplain Promise}, the polling loop will\n   * wait for it to be resolved and use the resolved value for whether the\n   * condition has been satisfied. The resolution time for a promise is always\n   * factored into whether a wait has timed out.\n   *\n   * If the provided condition is a {@link WebElementCondition}, then\n   * the wait will return a {@link WebElementPromise} that will resolve to the\n   * element that satisfied the condition.\n   *\n   * _Example:_ waiting up to 10 seconds for an element to be present on the\n   * page.\n   *\n   *     async function example() {\n   *       let button =\n   *           await driver.wait(until.elementLocated(By.id('foo')), 10000);\n   *       await button.click();\n   *     }\n   *\n   * @param {!(IThenable<T>|\n   *           Condition<T>|\n   *           function(!WebDriver): T)} condition The condition to\n   *     wait on, defined as a promise, condition object, or  a function to\n   *     evaluate as a condition.\n   * @param {number=} timeout The duration in milliseconds, how long to wait\n   *     for the condition to be true.\n   * @param {(string|Function)=} message An optional message to use if the wait times out.\n   * @param {number=} pollTimeout The duration in milliseconds, how long to\n   *     wait between polling the condition.\n   * @return {!(IThenable<T>|WebElementPromise)} A promise that will be\n   *     resolved with the first truthy value returned by the condition\n   *     function, or rejected if the condition times out. If the input\n   *     condition is an instance of a {@link WebElementCondition},\n   *     the returned value will be a {@link WebElementPromise}.\n   * @throws {TypeError} if the provided `condition` is not a valid type.\n   * @template T\n   */\n  wait(\n    condition, // eslint-disable-line\n    timeout = undefined, // eslint-disable-line\n    message = undefined, // eslint-disable-line\n    pollTimeout = undefined, // eslint-disable-line\n  ) {}\n\n  /**\n   * Makes the driver sleep for the given amount of time.\n   *\n   * @param {number} ms The amount of time, in milliseconds, to sleep.\n   * @return {!Promise<void>} A promise that will be resolved when the sleep has\n   *     finished.\n   */\n  sleep(ms) {} // eslint-disable-line\n\n  /**\n   * Retrieves the current window handle.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the current\n   *     window handle.\n   */\n  getWindowHandle() {}\n\n  /**\n   * Retrieves a list of all available window handles.\n   *\n   * @return {!Promise<!Array<string>>} A promise that will be resolved with an\n   *     array of window handles.\n   */\n  getAllWindowHandles() {}\n\n  /**\n   * Retrieves the current page's source. The returned source is a representation\n   * of the underlying DOM: do not expect it to be formatted or escaped in the\n   * same way as the raw response sent from the web server.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the current\n   *     page source.\n   */\n  getPageSource() {}\n\n  /**\n   * Closes the current window.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when this command\n   *     has completed.\n   */\n  close() {}\n\n  /**\n   * Navigates to the given URL.\n   *\n   * @param {string} url The fully qualified URL to open.\n   * @return {!Promise<void>} A promise that will be resolved when the document\n   *     has finished loading.\n   */\n  get(url) {} // eslint-disable-line\n\n  /**\n   * Retrieves the URL for the current page.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the\n   *     current URL.\n   */\n  getCurrentUrl() {}\n\n  /**\n   * Retrieves the current page title.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the current\n   *     page's title.\n   */\n  getTitle() {}\n\n  /**\n   * Locates an element on the page. If the element cannot be found, a\n   * {@link error.NoSuchElementError} will be returned by the driver.\n   *\n   * This function should not be used to test whether an element is present on\n   * the page. Rather, you should use {@link #findElements}:\n   *\n   *     driver.findElements(By.id('foo'))\n   *         .then(found => console.log('Element found? %s', !!found.length));\n   *\n   * The search criteria for an element may be defined using one of the\n   * factories in the {@link webdriver.By} namespace, or as a short-hand\n   * {@link webdriver.By.Hash} object. For example, the following two statements\n   * are equivalent:\n   *\n   *     var e1 = driver.findElement(By.id('foo'));\n   *     var e2 = driver.findElement({id:'foo'});\n   *\n   * You may also provide a custom locator function, which takes as input this\n   * instance and returns a {@link WebElement}, or a promise that will resolve\n   * to a WebElement. If the returned promise resolves to an array of\n   * WebElements, WebDriver will use the first element. For example, to find the\n   * first visible link on a page, you could write:\n   *\n   *     var link = driver.findElement(firstVisibleLink);\n   *\n   *     function firstVisibleLink(driver) {\n   *       var links = driver.findElements(By.tagName('a'));\n   *       return promise.filter(links, function(link) {\n   *         return link.isDisplayed();\n   *       });\n   *     }\n   *\n   * @param {!(by.By|Function)} locator The locator to use.\n   * @return {!WebElementPromise} A WebElement that can be used to issue\n   *     commands against the located element. If the element is not found, the\n   *     element will be invalidated and all scheduled commands aborted.\n   */\n  findElement(locator) {} // eslint-disable-line\n\n  /**\n   * Search for multiple elements on the page. Refer to the documentation on\n   * {@link #findElement(by)} for information on element locator strategies.\n   *\n   * @param {!(by.By|Function)} locator The locator to use.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   */\n  findElements(locator) {} // eslint-disable-line\n\n  /**\n   * Takes a screenshot of the current page. The driver makes the best effort to\n   * return a screenshot of the following, in order of preference:\n   *\n   * 1. Entire page\n   * 2. Current window\n   * 3. Visible portion of the current frame\n   * 4. The entire display containing the browser\n   *\n   * @return {!Promise<string>} A promise that will be resolved to the\n   *     screenshot as a base-64 encoded PNG.\n   */\n  takeScreenshot() {}\n\n  /**\n   * @return {!Options} The options interface for this instance.\n   */\n  manage() {}\n\n  /**\n   * @return {!Navigation} The navigation interface for this instance.\n   */\n  navigate() {}\n\n  /**\n   * @return {!TargetLocator} The target locator interface for this\n   *     instance.\n   */\n  switchTo() {}\n\n  /**\n   *\n   * Takes a PDF of the current page. The driver makes a best effort to\n   * return a PDF based on the provided parameters.\n   *\n   * @param {{orientation:(string|undefined),\n   *         scale:(number|undefined),\n   *         background:(boolean|undefined),\n   *         width:(number|undefined),\n   *         height:(number|undefined),\n   *         top:(number|undefined),\n   *         bottom:(number|undefined),\n   *         left:(number|undefined),\n   *         right:(number|undefined),\n   *         shrinkToFit:(boolean|undefined),\n   *         pageRanges:(Array|undefined)}} options\n   */\n  printPage(options) {} // eslint-disable-line\n}\n\n/**\n * @param {!Capabilities} capabilities A capabilities object.\n * @return {!Capabilities} A copy of the parameter capabilities, omitting\n *     capability names that are not valid W3C names.\n */\nfunction filterNonW3CCaps(capabilities) {\n  let newCaps = new Capabilities(capabilities)\n  for (let k of newCaps.keys()) {\n    // Any key containing a colon is a vendor-prefixed capability.\n    if (!(W3C_CAPABILITY_NAMES.has(k) || k.indexOf(':') >= 0)) {\n      newCaps.delete(k)\n    }\n  }\n  return newCaps\n}\n\n/**\n * Each WebDriver instance provides automated control over a browser session.\n *\n * @implements {IWebDriver}\n */\nclass WebDriver {\n  /**\n   * @param {!(./session.Session|IThenable<!./session.Session>)} session Either\n   *     a known session or a promise that will be resolved to a session.\n   * @param {!command.Executor} executor The executor to use when sending\n   *     commands to the browser.\n   * @param {(function(this: void): ?)=} onQuit A function to call, if any,\n   *     when the session is terminated.\n   */\n  constructor(session, executor, onQuit = undefined) {\n    /** @private {!Promise<!Session>} */\n    this.session_ = Promise.resolve(session)\n\n    // If session is a rejected promise, add a no-op rejection handler.\n    // This effectively hides setup errors until users attempt to interact\n    // with the session.\n    this.session_.catch(function () {})\n\n    /** @private {!command.Executor} */\n    this.executor_ = executor\n\n    /** @private {input.FileDetector} */\n    this.fileDetector_ = null\n\n    /** @private @const {(function(this: void): ?|undefined)} */\n    this.onQuit_ = onQuit\n\n    /** @private {./virtual_authenticator}*/\n    this.authenticatorId_ = null\n\n    this.pinnedScripts_ = {}\n  }\n\n  /**\n   * Creates a new WebDriver session.\n   *\n   * This function will always return a WebDriver instance. If there is an error\n   * creating the session, such as the aforementioned SessionNotCreatedError,\n   * the driver will have a rejected {@linkplain #getSession session} promise.\n   * This rejection will propagate through any subsequent commands scheduled\n   * on the returned WebDriver instance.\n   *\n   *     let required = Capabilities.firefox();\n   *     let driver = WebDriver.createSession(executor, {required});\n   *\n   *     // If the createSession operation failed, then this command will also\n   *     // also fail, propagating the creation failure.\n   *     driver.get('http://www.google.com').catch(e => console.log(e));\n   *\n   * @param {!command.Executor} executor The executor to create the new session\n   *     with.\n   * @param {!Capabilities} capabilities The desired capabilities for the new\n   *     session.\n   * @param {(function(this: void): ?)=} onQuit A callback to invoke when\n   *    the newly created session is terminated. This should be used to clean\n   *    up any resources associated with the session.\n   * @return {!WebDriver} The driver for the newly created session.\n   */\n  static createSession(executor, capabilities, onQuit = undefined) {\n    let cmd = new command.Command(command.Name.NEW_SESSION)\n\n    // For W3C remote ends.\n    cmd.setParameter('capabilities', {\n      firstMatch: [{}],\n      alwaysMatch: filterNonW3CCaps(capabilities),\n    })\n\n    let session = executeCommand(executor, cmd)\n    if (typeof onQuit === 'function') {\n      session = session.catch((err) => {\n        return Promise.resolve(onQuit.call(void 0)).then((_) => {\n          throw err\n        })\n      })\n    }\n    return new this(session, executor, onQuit)\n  }\n\n  /** @override */\n  async execute(command) {\n    command.setParameter('sessionId', this.session_)\n\n    let parameters = await toWireValue(command.getParameters())\n    command.setParameters(parameters)\n    let value = await this.executor_.execute(command)\n    return fromWireValue(this, value)\n  }\n\n  /** @override */\n  setFileDetector(detector) {\n    this.fileDetector_ = detector\n  }\n\n  /** @override */\n  getExecutor() {\n    return this.executor_\n  }\n\n  /** @override */\n  getSession() {\n    return this.session_\n  }\n\n  /** @override */\n  getCapabilities() {\n    return this.session_.then((s) => s.getCapabilities())\n  }\n\n  /** @override */\n  quit() {\n    let result = this.execute(new command.Command(command.Name.QUIT))\n    // Delete our session ID when the quit command finishes; this will allow us\n    // to throw an error when attempting to use a driver post-quit.\n    return promise.finally(result, () => {\n      this.session_ = Promise.reject(\n        new error.NoSuchSessionError(\n          'This driver instance does not have a valid session ID ' +\n            '(did you call WebDriver.quit()?) and may no longer be used.',\n        ),\n      )\n\n      // Only want the session rejection to bubble if accessed.\n      this.session_.catch(function () {})\n\n      if (this.onQuit_) {\n        return this.onQuit_.call(void 0)\n      }\n    })\n  }\n\n  /** @override */\n  actions(options) {\n    return new input.Actions(this, options || undefined)\n  }\n\n  /** @override */\n  executeScript(script, ...args) {\n    if (typeof script === 'function') {\n      script = 'return (' + script + ').apply(null, arguments);'\n    }\n\n    if (script && script instanceof PinnedScript) {\n      return this.execute(\n        new command.Command(command.Name.EXECUTE_SCRIPT)\n          .setParameter('script', script.executionScript())\n          .setParameter('args', args),\n      )\n    }\n\n    return this.execute(\n      new command.Command(command.Name.EXECUTE_SCRIPT).setParameter('script', script).setParameter('args', args),\n    )\n  }\n\n  /** @override */\n  executeAsyncScript(script, ...args) {\n    if (typeof script === 'function') {\n      script = 'return (' + script + ').apply(null, arguments);'\n    }\n\n    if (script && script instanceof PinnedScript) {\n      return this.execute(\n        new command.Command(command.Name.EXECUTE_ASYNC_SCRIPT)\n          .setParameter('script', script.executionScript())\n          .setParameter('args', args),\n      )\n    }\n\n    return this.execute(\n      new command.Command(command.Name.EXECUTE_ASYNC_SCRIPT).setParameter('script', script).setParameter('args', args),\n    )\n  }\n\n  /** @override */\n  wait(condition, timeout = 0, message = undefined, pollTimeout = 200) {\n    if (typeof timeout !== 'number' || timeout < 0) {\n      throw TypeError('timeout must be a number >= 0: ' + timeout)\n    }\n\n    if (typeof pollTimeout !== 'number' || pollTimeout < 0) {\n      throw TypeError('pollTimeout must be a number >= 0: ' + pollTimeout)\n    }\n\n    if (promise.isPromise(condition)) {\n      return new Promise((resolve, reject) => {\n        if (!timeout) {\n          resolve(condition)\n          return\n        }\n\n        let start = Date.now()\n        let timer = setTimeout(function () {\n          timer = null\n          try {\n            let timeoutMessage = resolveWaitMessage(message)\n            reject(\n              new error.TimeoutError(\n                `${timeoutMessage}Timed out waiting for promise to resolve after ${Date.now() - start}ms`,\n              ),\n            )\n          } catch (ex) {\n            reject(\n              new error.TimeoutError(\n                `${ex.message}\\nTimed out waiting for promise to resolve after ${Date.now() - start}ms`,\n              ),\n            )\n          }\n        }, timeout)\n        const clearTimer = () => timer && clearTimeout(timer)\n\n        /** @type {!IThenable} */ condition.then(\n          function (value) {\n            clearTimer()\n            resolve(value)\n          },\n          function (error) {\n            clearTimer()\n            reject(error)\n          },\n        )\n      })\n    }\n\n    let fn = /** @type {!Function} */ (condition)\n    if (condition instanceof Condition) {\n      message = message || condition.description()\n      fn = condition.fn\n    }\n\n    if (typeof fn !== 'function') {\n      throw TypeError('Wait condition must be a promise-like object, function, or a ' + 'Condition object')\n    }\n\n    const driver = this\n\n    function evaluateCondition() {\n      return new Promise((resolve, reject) => {\n        try {\n          resolve(fn(driver))\n        } catch (ex) {\n          reject(ex)\n        }\n      })\n    }\n\n    let result = new Promise((resolve, reject) => {\n      const startTime = Date.now()\n      const pollCondition = async () => {\n        evaluateCondition().then(function (value) {\n          const elapsed = Date.now() - startTime\n          if (value) {\n            resolve(value)\n          } else if (timeout && elapsed >= timeout) {\n            try {\n              let timeoutMessage = resolveWaitMessage(message)\n              reject(new error.TimeoutError(`${timeoutMessage}Wait timed out after ${elapsed}ms`))\n            } catch (ex) {\n              reject(new error.TimeoutError(`${ex.message}\\nWait timed out after ${elapsed}ms`))\n            }\n          } else {\n            setTimeout(pollCondition, pollTimeout)\n          }\n        }, reject)\n      }\n      pollCondition()\n    })\n\n    if (condition instanceof WebElementCondition) {\n      result = new WebElementPromise(\n        this,\n        result.then(function (value) {\n          if (!(value instanceof WebElement)) {\n            throw TypeError(\n              'WebElementCondition did not resolve to a WebElement: ' + Object.prototype.toString.call(value),\n            )\n          }\n          return value\n        }),\n      )\n    }\n    return result\n  }\n\n  /** @override */\n  sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms))\n  }\n\n  /** @override */\n  getWindowHandle() {\n    return this.execute(new command.Command(command.Name.GET_CURRENT_WINDOW_HANDLE))\n  }\n\n  /** @override */\n  getAllWindowHandles() {\n    return this.execute(new command.Command(command.Name.GET_WINDOW_HANDLES))\n  }\n\n  /** @override */\n  getPageSource() {\n    return this.execute(new command.Command(command.Name.GET_PAGE_SOURCE))\n  }\n\n  /** @override */\n  close() {\n    return this.execute(new command.Command(command.Name.CLOSE))\n  }\n\n  /** @override */\n  get(url) {\n    return this.navigate().to(url)\n  }\n\n  /** @override */\n  getCurrentUrl() {\n    return this.execute(new command.Command(command.Name.GET_CURRENT_URL))\n  }\n\n  /** @override */\n  getTitle() {\n    return this.execute(new command.Command(command.Name.GET_TITLE))\n  }\n\n  /** @override */\n  findElement(locator) {\n    let id\n    let cmd = null\n\n    if (locator instanceof RelativeBy) {\n      cmd = new command.Command(command.Name.FIND_ELEMENTS_RELATIVE).setParameter('args', locator.marshall())\n    } else {\n      locator = by.checkedLocator(locator)\n    }\n\n    if (typeof locator === 'function') {\n      id = this.findElementInternal_(locator, this)\n      return new WebElementPromise(this, id)\n    } else if (cmd === null) {\n      cmd = new command.Command(command.Name.FIND_ELEMENT)\n        .setParameter('using', locator.using)\n        .setParameter('value', locator.value)\n    }\n\n    id = this.execute(cmd)\n    if (locator instanceof RelativeBy) {\n      return this.normalize_(id)\n    } else {\n      return new WebElementPromise(this, id)\n    }\n  }\n\n  /**\n   * @param {!Function} webElementPromise The webElement in unresolved state\n   * @return {!Promise<!WebElement>} First single WebElement from array of resolved promises\n   */\n  async normalize_(webElementPromise) {\n    let result = await webElementPromise\n    if (result.length === 0) {\n      throw new NoSuchElementError('Cannot locate an element with provided parameters')\n    } else {\n      return result[0]\n    }\n  }\n\n  /**\n   * @param {!Function} locatorFn The locator function to use.\n   * @param {!(WebDriver|WebElement)} context The search context.\n   * @return {!Promise<!WebElement>} A promise that will resolve to a list of\n   *     WebElements.\n   * @private\n   */\n  async findElementInternal_(locatorFn, context) {\n    let result = await locatorFn(context)\n    if (Array.isArray(result)) {\n      result = result[0]\n    }\n    if (!(result instanceof WebElement)) {\n      throw new TypeError('Custom locator did not return a WebElement')\n    }\n    return result\n  }\n\n  /** @override */\n  async findElements(locator) {\n    let cmd = null\n    if (locator instanceof RelativeBy) {\n      cmd = new command.Command(command.Name.FIND_ELEMENTS_RELATIVE).setParameter('args', locator.marshall())\n    } else {\n      locator = by.checkedLocator(locator)\n    }\n\n    if (typeof locator === 'function') {\n      return this.findElementsInternal_(locator, this)\n    } else if (cmd === null) {\n      cmd = new command.Command(command.Name.FIND_ELEMENTS)\n        .setParameter('using', locator.using)\n        .setParameter('value', locator.value)\n    }\n    try {\n      let res = await this.execute(cmd)\n      return Array.isArray(res) ? res : []\n    } catch (ex) {\n      if (ex instanceof error.NoSuchElementError) {\n        return []\n      }\n      throw ex\n    }\n  }\n\n  /**\n   * @param {!Function} locatorFn The locator function to use.\n   * @param {!(WebDriver|WebElement)} context The search context.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   * @private\n   */\n  async findElementsInternal_(locatorFn, context) {\n    const result = await locatorFn(context)\n    if (result instanceof WebElement) {\n      return [result]\n    }\n\n    if (!Array.isArray(result)) {\n      return []\n    }\n\n    return result.filter(function (item) {\n      return item instanceof WebElement\n    })\n  }\n\n  /** @override */\n  takeScreenshot() {\n    return this.execute(new command.Command(command.Name.SCREENSHOT))\n  }\n\n  /** @override */\n  manage() {\n    return new Options(this)\n  }\n\n  /** @override */\n  navigate() {\n    return new Navigation(this)\n  }\n\n  /** @override */\n  switchTo() {\n    return new TargetLocator(this)\n  }\n\n  validatePrintPageParams(keys, object) {\n    let page = {}\n    let margin = {}\n    let data\n    Object.keys(keys).forEach(function (key) {\n      data = keys[key]\n      let obj = {\n        orientation: function () {\n          object.orientation = data\n        },\n\n        scale: function () {\n          object.scale = data\n        },\n\n        background: function () {\n          object.background = data\n        },\n\n        width: function () {\n          page.width = data\n          object.page = page\n        },\n\n        height: function () {\n          page.height = data\n          object.page = page\n        },\n\n        top: function () {\n          margin.top = data\n          object.margin = margin\n        },\n\n        left: function () {\n          margin.left = data\n          object.margin = margin\n        },\n\n        bottom: function () {\n          margin.bottom = data\n          object.margin = margin\n        },\n\n        right: function () {\n          margin.right = data\n          object.margin = margin\n        },\n\n        shrinkToFit: function () {\n          object.shrinkToFit = data\n        },\n\n        pageRanges: function () {\n          object.pageRanges = data\n        },\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n        throw new error.InvalidArgumentError(`Invalid Argument '${key}'`)\n      } else {\n        obj[key]()\n      }\n    })\n\n    return object\n  }\n\n  /** @override */\n  printPage(options = {}) {\n    let keys = options\n    let params = {}\n    let resultObj\n\n    let self = this\n    resultObj = self.validatePrintPageParams(keys, params)\n\n    return this.execute(new command.Command(command.Name.PRINT_PAGE).setParameters(resultObj))\n  }\n\n  /**\n   * Creates a new WebSocket connection.\n   * @return {!Promise<resolved>} A new CDP instance.\n   */\n  async createCDPConnection(target) {\n    let debuggerUrl = null\n\n    const caps = await this.getCapabilities()\n\n    if (process.env.SELENIUM_REMOTE_URL) {\n      const host = new URL(process.env.SELENIUM_REMOTE_URL).host\n      const sessionId = await this.getSession().then((session) => session.getId())\n      debuggerUrl = `ws://${host}/session/${sessionId}/se/cdp`\n    } else {\n      const seCdp = caps['map_'].get('se:cdp')\n      const vendorInfo =\n        caps['map_'].get('goog:chromeOptions') ||\n        caps['map_'].get('ms:edgeOptions') ||\n        caps['map_'].get('moz:debuggerAddress') ||\n        new Map()\n      debuggerUrl = seCdp || vendorInfo['debuggerAddress'] || vendorInfo\n    }\n    this._wsUrl = await this.getWsUrl(debuggerUrl, target, caps)\n    return new Promise((resolve, reject) => {\n      try {\n        this._wsConnection = new WebSocket(this._wsUrl.replace('localhost', '127.0.0.1'))\n        this._cdpConnection = new cdp.CdpConnection(this._wsConnection)\n      } catch (err) {\n        reject(err)\n        return\n      }\n\n      this._wsConnection.on('open', async () => {\n        await this.getCdpTargets()\n      })\n\n      this._wsConnection.on('message', async (message) => {\n        const params = JSON.parse(message)\n        if (params.result) {\n          if (params.result.targetInfos) {\n            const targets = params.result.targetInfos\n            const page = targets.find((info) => info.type === 'page')\n            if (page) {\n              this.targetID = page.targetId\n              this._cdpConnection.execute('Target.attachToTarget', { targetId: this.targetID, flatten: true }, null)\n            } else {\n              reject('Unable to find Page target.')\n            }\n          }\n          if (params.result.sessionId) {\n            this.sessionId = params.result.sessionId\n            this._cdpConnection.sessionId = this.sessionId\n            resolve(this._cdpConnection)\n          }\n        }\n      })\n\n      this._wsConnection.on('error', (error) => {\n        reject(error)\n      })\n    })\n  }\n\n  async getCdpTargets() {\n    this._cdpConnection.execute('Target.getTargets')\n  }\n\n  /**\n   * Initiates bidi connection using 'webSocketUrl'\n   * @returns {BIDI}\n   */\n  async getBidi() {\n    const caps = await this.getCapabilities()\n    let WebSocketUrl = caps['map_'].get('webSocketUrl')\n    return new BIDI(WebSocketUrl.replace('localhost', '127.0.0.1'))\n  }\n\n  /**\n   * Retrieves 'webSocketDebuggerUrl' by sending a http request using debugger address\n   * @param {string} debuggerAddress\n   * @param target\n   * @param caps\n   * @return {string} Returns parsed webSocketDebuggerUrl obtained from the http request\n   */\n  async getWsUrl(debuggerAddress, target, caps) {\n    if (target && cdpTargets.indexOf(target.toLowerCase()) === -1) {\n      throw new error.InvalidArgumentError('invalid target value')\n    }\n\n    if (debuggerAddress.match(/\\/se\\/cdp/)) {\n      return debuggerAddress\n    }\n\n    let path\n    if (target === 'page' && caps['map_'].get('browserName') !== 'firefox') {\n      path = '/json'\n    } else if (target === 'page' && caps['map_'].get('browserName') === 'firefox') {\n      path = '/json/list'\n    } else {\n      path = '/json/version'\n    }\n\n    let request = new http.Request('GET', path)\n    let client = new http.HttpClient('http://' + debuggerAddress)\n    let response = await client.send(request)\n\n    if (target.toLowerCase() === 'page') {\n      return JSON.parse(response.body)[0]['webSocketDebuggerUrl']\n    } else {\n      return JSON.parse(response.body)['webSocketDebuggerUrl']\n    }\n  }\n\n  /**\n   * Sets a listener for Fetch.authRequired event from CDP\n   * If event is triggered, it enters username and password\n   * and allows the test to move forward\n   * @param {string} username\n   * @param {string} password\n   * @param connection CDP Connection\n   */\n  async register(username, password, connection) {\n    this._wsConnection.on('message', (message) => {\n      const params = JSON.parse(message)\n\n      if (params.method === 'Fetch.authRequired') {\n        const requestParams = params['params']\n        connection.execute('Fetch.continueWithAuth', {\n          requestId: requestParams['requestId'],\n          authChallengeResponse: {\n            response: 'ProvideCredentials',\n            username: username,\n            password: password,\n          },\n        })\n      } else if (params.method === 'Fetch.requestPaused') {\n        const requestPausedParams = params['params']\n        connection.execute('Fetch.continueRequest', {\n          requestId: requestPausedParams['requestId'],\n        })\n      }\n    })\n\n    await connection.execute(\n      'Fetch.enable',\n      {\n        handleAuthRequests: true,\n      },\n      null,\n    )\n    await connection.execute(\n      'Network.setCacheDisabled',\n      {\n        cacheDisabled: true,\n      },\n      null,\n    )\n  }\n\n  /**\n   * Handle Network interception requests\n   * @param connection WebSocket connection to the browser\n   * @param httpResponse Object representing what we are intercepting\n   *                     as well as what should be returned.\n   * @param callback callback called when we intercept requests.\n   */\n  async onIntercept(connection, httpResponse, callback) {\n    this._wsConnection.on('message', (message) => {\n      const params = JSON.parse(message)\n      if (params.method === 'Fetch.requestPaused') {\n        const requestPausedParams = params['params']\n        if (requestPausedParams.request.url == httpResponse.urlToIntercept) {\n          connection.execute('Fetch.fulfillRequest', {\n            requestId: requestPausedParams['requestId'],\n            responseCode: httpResponse.status,\n            responseHeaders: httpResponse.headers,\n            body: httpResponse.body,\n          })\n          callback()\n        } else {\n          connection.execute('Fetch.continueRequest', {\n            requestId: requestPausedParams['requestId'],\n          })\n        }\n      }\n    })\n\n    await connection.execute('Fetch.enable', {}, null)\n    await connection.execute(\n      'Network.setCacheDisabled',\n      {\n        cacheDisabled: true,\n      },\n      null,\n    )\n  }\n\n  /**\n   *\n   * @param connection\n   * @param callback\n   * @returns {Promise<void>}\n   */\n  async onLogEvent(connection, callback) {\n    this._wsConnection.on('message', (message) => {\n      const params = JSON.parse(message)\n      if (params.method === 'Runtime.consoleAPICalled') {\n        const consoleEventParams = params['params']\n        let event = {\n          type: consoleEventParams['type'],\n          timestamp: new Date(consoleEventParams['timestamp']),\n          args: consoleEventParams['args'],\n        }\n\n        callback(event)\n      }\n\n      if (params.method === 'Log.entryAdded') {\n        const logEventParams = params['params']\n        const logEntry = logEventParams['entry']\n        let event = {\n          level: logEntry['level'],\n          timestamp: new Date(logEntry['timestamp']),\n          message: logEntry['text'],\n        }\n\n        callback(event)\n      }\n    })\n    await connection.execute('Runtime.enable', {}, null)\n  }\n\n  /**\n   *\n   * @param connection\n   * @param callback\n   * @returns {Promise<void>}\n   */\n  async onLogException(connection, callback) {\n    await connection.execute('Runtime.enable', {}, null)\n\n    this._wsConnection.on('message', (message) => {\n      const params = JSON.parse(message)\n\n      if (params.method === 'Runtime.exceptionThrown') {\n        const exceptionEventParams = params['params']\n        let event = {\n          exceptionDetails: exceptionEventParams['exceptionDetails'],\n          timestamp: new Date(exceptionEventParams['timestamp']),\n        }\n\n        callback(event)\n      }\n    })\n  }\n\n  /**\n   * @param connection\n   * @param callback\n   * @returns {Promise<void>}\n   */\n  async logMutationEvents(connection, callback) {\n    await connection.execute('Runtime.enable', {}, null)\n    await connection.execute('Page.enable', {}, null)\n\n    await connection.execute(\n      'Runtime.addBinding',\n      {\n        name: '__webdriver_attribute',\n      },\n      null,\n    )\n\n    let mutationListener = ''\n    try {\n      // Depending on what is running the code it could appear in 2 different places which is why we try\n      // here and then the other location\n      mutationListener = fs\n        .readFileSync('./javascript/node/selenium-webdriver/lib/atoms/mutation-listener.js', 'utf-8')\n        .toString()\n    } catch {\n      mutationListener = fs.readFileSync(path.resolve(__dirname, './atoms/mutation-listener.js'), 'utf-8').toString()\n    }\n\n    this.executeScript(mutationListener)\n\n    await connection.execute(\n      'Page.addScriptToEvaluateOnNewDocument',\n      {\n        source: mutationListener,\n      },\n      null,\n    )\n\n    this._wsConnection.on('message', async (message) => {\n      const params = JSON.parse(message)\n      if (params.method === 'Runtime.bindingCalled') {\n        let payload = JSON.parse(params['params']['payload'])\n        let elements = await this.findElements({\n          css: '*[data-__webdriver_id=' + by.escapeCss(payload['target']) + ']',\n        })\n\n        if (elements.length === 0) {\n          return\n        }\n\n        let event = {\n          element: elements[0],\n          attribute_name: payload['name'],\n          current_value: payload['value'],\n          old_value: payload['oldValue'],\n        }\n        callback(event)\n      }\n    })\n  }\n\n  async pinScript(script) {\n    let pinnedScript = new PinnedScript(script)\n    let connection\n    if (Object.is(this._cdpConnection, undefined)) {\n      connection = await this.createCDPConnection('page')\n    } else {\n      connection = this._cdpConnection\n    }\n\n    await connection.execute('Page.enable', {}, null)\n\n    await connection.execute(\n      'Runtime.evaluate',\n      {\n        expression: pinnedScript.creationScript(),\n      },\n      null,\n    )\n\n    let result = await connection.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: pinnedScript.creationScript(),\n    })\n\n    pinnedScript.scriptId = result['result']['identifier']\n\n    this.pinnedScripts_[pinnedScript.handle] = pinnedScript\n\n    return pinnedScript\n  }\n\n  async unpinScript(script) {\n    if (script && !(script instanceof PinnedScript)) {\n      throw Error(`Pass valid PinnedScript object. Received: ${script}`)\n    }\n\n    if (script.handle in this.pinnedScripts_) {\n      let connection\n      if (Object.is(this._cdpConnection, undefined)) {\n        connection = this.createCDPConnection('page')\n      } else {\n        connection = this._cdpConnection\n      }\n\n      await connection.execute('Page.enable', {}, null)\n\n      await connection.execute(\n        'Runtime.evaluate',\n        {\n          expression: script.removalScript(),\n        },\n        null,\n      )\n\n      await connection.execute(\n        'Page.removeScriptToEvaluateOnLoad',\n        {\n          identifier: script.scriptId,\n        },\n        null,\n      )\n\n      delete this.pinnedScripts_[script.handle]\n    }\n  }\n\n  /**\n   *\n   * @returns The value of authenticator ID added\n   */\n  virtualAuthenticatorId() {\n    return this.authenticatorId_\n  }\n\n  /**\n   * Adds a virtual authenticator with the given options.\n   * @param options VirtualAuthenticatorOptions object to set authenticator options.\n   */\n  async addVirtualAuthenticator(options) {\n    this.authenticatorId_ = await this.execute(\n      new command.Command(command.Name.ADD_VIRTUAL_AUTHENTICATOR).setParameters(options.toDict()),\n    )\n  }\n\n  /**\n   * Removes a previously added virtual authenticator. The authenticator is no\n   * longer valid after removal, so no methods may be called.\n   */\n  async removeVirtualAuthenticator() {\n    await this.execute(\n      new command.Command(command.Name.REMOVE_VIRTUAL_AUTHENTICATOR).setParameter(\n        'authenticatorId',\n        this.authenticatorId_,\n      ),\n    )\n    this.authenticatorId_ = null\n  }\n\n  /**\n   * Injects a credential into the authenticator.\n   * @param credential Credential to be added\n   */\n  async addCredential(credential) {\n    credential = credential.toDict()\n    credential['authenticatorId'] = this.authenticatorId_\n    await this.execute(new command.Command(command.Name.ADD_CREDENTIAL).setParameters(credential))\n  }\n\n  /**\n   *\n   * @returns The list of credentials owned by the authenticator.\n   */\n  async getCredentials() {\n    let credential_data = await this.execute(\n      new command.Command(command.Name.GET_CREDENTIALS).setParameter('authenticatorId', this.virtualAuthenticatorId()),\n    )\n    var credential_list = []\n    for (var i = 0; i < credential_data.length; i++) {\n      credential_list.push(new Credential().fromDict(credential_data[i]))\n    }\n    return credential_list\n  }\n\n  /**\n   * Removes a credential from the authenticator.\n   * @param credential_id The ID of the credential to be removed.\n   */\n  async removeCredential(credential_id) {\n    // If credential_id is not a base64url, then convert it to base64url.\n    if (Array.isArray(credential_id)) {\n      credential_id = Buffer.from(credential_id).toString('base64url')\n    }\n\n    await this.execute(\n      new command.Command(command.Name.REMOVE_CREDENTIAL)\n        .setParameter('credentialId', credential_id)\n        .setParameter('authenticatorId', this.authenticatorId_),\n    )\n  }\n\n  /**\n   * Removes all the credentials from the authenticator.\n   */\n  async removeAllCredentials() {\n    await this.execute(\n      new command.Command(command.Name.REMOVE_ALL_CREDENTIALS).setParameter('authenticatorId', this.authenticatorId_),\n    )\n  }\n\n  /**\n   * Sets whether the authenticator will simulate success or fail on user verification.\n   * @param verified true if the authenticator will pass user verification, false otherwise.\n   */\n  async setUserVerified(verified) {\n    await this.execute(\n      new command.Command(command.Name.SET_USER_VERIFIED)\n        .setParameter('authenticatorId', this.authenticatorId_)\n        .setParameter('isUserVerified', verified),\n    )\n  }\n\n  async getDownloadableFiles() {\n    const caps = await this.getCapabilities()\n    if (!caps['map_'].get('se:downloadsEnabled')) {\n      throw new error.WebDriverError('Downloads must be enabled in options')\n    }\n\n    return (await this.execute(new command.Command(command.Name.GET_DOWNLOADABLE_FILES))).names\n  }\n\n  async downloadFile(fileName, targetDirectory) {\n    const caps = await this.getCapabilities()\n    if (!caps['map_'].get('se:downloadsEnabled')) {\n      throw new Error('Downloads must be enabled in options')\n    }\n\n    const response = await this.execute(new command.Command(command.Name.DOWNLOAD_FILE).setParameter('name', fileName))\n\n    const base64Content = response.contents\n\n    if (!targetDirectory.endsWith('/')) {\n      targetDirectory += '/'\n    }\n\n    fs.mkdirSync(targetDirectory, { recursive: true })\n    const zipFilePath = path.join(targetDirectory, `${fileName}.zip`)\n    fs.writeFileSync(zipFilePath, Buffer.from(base64Content, 'base64'))\n\n    const zipData = fs.readFileSync(zipFilePath)\n    await JSZip.loadAsync(zipData)\n      .then((zip) => {\n        // Iterate through each file in the zip archive\n        Object.keys(zip.files).forEach(async (fileName) => {\n          const fileData = await zip.files[fileName].async('nodebuffer')\n          fs.writeFileSync(`${targetDirectory}/${fileName}`, fileData)\n          console.log(`File extracted: ${fileName}`)\n        })\n      })\n      .catch((error) => {\n        console.error('Error unzipping file:', error)\n      })\n  }\n\n  async deleteDownloadableFiles() {\n    const caps = await this.getCapabilities()\n    if (!caps['map_'].get('se:downloadsEnabled')) {\n      throw new error.WebDriverError('Downloads must be enabled in options')\n    }\n\n    return await this.execute(new command.Command(command.Name.DELETE_DOWNLOADABLE_FILES))\n  }\n}\n\n/**\n * Interface for navigating back and forth in the browser history.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with\n *\n *    webdriver.navigate()\n *\n * @see WebDriver#navigate()\n */\nclass Navigation {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver\n  }\n\n  /**\n   * Navigates to a new URL.\n   *\n   * @param {string} url The URL to navigate to.\n   * @return {!Promise<void>} A promise that will be resolved when the URL\n   *     has been loaded.\n   */\n  to(url) {\n    return this.driver_.execute(new command.Command(command.Name.GET).setParameter('url', url))\n  }\n\n  /**\n   * Moves backwards in the browser history.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     navigation event has completed.\n   */\n  back() {\n    return this.driver_.execute(new command.Command(command.Name.GO_BACK))\n  }\n\n  /**\n   * Moves forwards in the browser history.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     navigation event has completed.\n   */\n  forward() {\n    return this.driver_.execute(new command.Command(command.Name.GO_FORWARD))\n  }\n\n  /**\n   * Refreshes the current page.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     navigation event has completed.\n   */\n  refresh() {\n    return this.driver_.execute(new command.Command(command.Name.REFRESH))\n  }\n}\n\n/**\n * Provides methods for managing browser and driver state.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with {@linkplain WebDriver#manage() webdriver.manage()}.\n */\nclass Options {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver\n  }\n\n  /**\n   * Adds a cookie.\n   *\n   * __Sample Usage:__\n   *\n   *     // Set a basic cookie.\n   *     driver.manage().addCookie({name: 'foo', value: 'bar'});\n   *\n   *     // Set a cookie that expires in 10 minutes.\n   *     let expiry = new Date(Date.now() + (10 * 60 * 1000));\n   *     driver.manage().addCookie({name: 'foo', value: 'bar', expiry});\n   *\n   *     // The cookie expiration may also be specified in seconds since epoch.\n   *     driver.manage().addCookie({\n   *       name: 'foo',\n   *       value: 'bar',\n   *       expiry: Math.floor(Date.now() / 1000)\n   *     });\n   *\n   * @param {!Options.Cookie} spec Defines the cookie to add.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the cookie has been added to the page.\n   * @throws {error.InvalidArgumentError} if any of the cookie parameters are\n   *     invalid.\n   * @throws {TypeError} if `spec` is not a cookie object.\n   */\n  addCookie({ name, value, path, domain, secure, httpOnly, expiry, sameSite }) {\n    // We do not allow '=' or ';' in the name.\n    if (/[;=]/.test(name)) {\n      throw new error.InvalidArgumentError('Invalid cookie name \"' + name + '\"')\n    }\n\n    // We do not allow ';' in value.\n    if (/;/.test(value)) {\n      throw new error.InvalidArgumentError('Invalid cookie value \"' + value + '\"')\n    }\n\n    if (typeof expiry === 'number') {\n      expiry = Math.floor(expiry)\n    } else if (expiry instanceof Date) {\n      let date = /** @type {!Date} */ (expiry)\n      expiry = Math.floor(date.getTime() / 1000)\n    }\n\n    if (sameSite && !['Strict', 'Lax', 'None'].includes(sameSite)) {\n      throw new error.InvalidArgumentError(\n        `Invalid sameSite cookie value '${sameSite}'. It should be one of \"Lax\", \"Strict\" or \"None\"`,\n      )\n    }\n\n    if (sameSite === 'None' && !secure) {\n      throw new error.InvalidArgumentError('Invalid cookie configuration: SameSite=None must be Secure')\n    }\n\n    return this.driver_.execute(\n      new command.Command(command.Name.ADD_COOKIE).setParameter('cookie', {\n        name: name,\n        value: value,\n        path: path,\n        domain: domain,\n        secure: !!secure,\n        httpOnly: !!httpOnly,\n        expiry: expiry,\n        sameSite: sameSite,\n      }),\n    )\n  }\n\n  /**\n   * Deletes all cookies visible to the current page.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when all cookies have been deleted.\n   */\n  deleteAllCookies() {\n    return this.driver_.execute(new command.Command(command.Name.DELETE_ALL_COOKIES))\n  }\n\n  /**\n   * Deletes the cookie with the given name. This command is a no-op if there is\n   * no cookie with the given name visible to the current page.\n   *\n   * @param {string} name The name of the cookie to delete.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the cookie has been deleted.\n   */\n  deleteCookie(name) {\n    return this.driver_.execute(new command.Command(command.Name.DELETE_COOKIE).setParameter('name', name))\n  }\n\n  /**\n   * Retrieves all cookies visible to the current page. Each cookie will be\n   * returned as a JSON object as described by the WebDriver wire protocol.\n   *\n   * @return {!Promise<!Array<!Options.Cookie>>} A promise that will be\n   *     resolved with the cookies visible to the current browsing context.\n   */\n  getCookies() {\n    return this.driver_.execute(new command.Command(command.Name.GET_ALL_COOKIES))\n  }\n\n  /**\n   * Retrieves the cookie with the given name. Returns null if there is no such\n   * cookie. The cookie will be returned as a JSON object as described by the\n   * WebDriver wire protocol.\n   *\n   * @param {string} name The name of the cookie to retrieve.\n   * @return {!Promise<?Options.Cookie>} A promise that will be resolved\n   *     with the named cookie\n   * @throws {error.NoSuchCookieError} if there is no such cookie.\n   */\n  async getCookie(name) {\n    try {\n      const cookie = await this.driver_.execute(new command.Command(command.Name.GET_COOKIE).setParameter('name', name))\n      return cookie\n    } catch (err) {\n      if (!(err instanceof error.UnknownCommandError) && !(err instanceof error.UnsupportedOperationError)) {\n        throw err\n      }\n\n      const cookies = await this.getCookies()\n      for (let cookie of cookies) {\n        if (cookie && cookie['name'] === name) {\n          return cookie\n        }\n      }\n      return null\n    }\n  }\n\n  /**\n   * Fetches the timeouts currently configured for the current session.\n   *\n   * @return {!Promise<{script: number,\n   *                             pageLoad: number,\n   *                             implicit: number}>} A promise that will be\n   *     resolved with the timeouts currently configured for the current\n   *     session.\n   * @see #setTimeouts()\n   */\n  getTimeouts() {\n    return this.driver_.execute(new command.Command(command.Name.GET_TIMEOUT))\n  }\n\n  /**\n   * Sets the timeout durations associated with the current session.\n   *\n   * The following timeouts are supported (all timeouts are specified in\n   * milliseconds):\n   *\n   * -  `implicit` specifies the maximum amount of time to wait for an element\n   *    locator to succeed when {@linkplain WebDriver#findElement locating}\n   *    {@linkplain WebDriver#findElements elements} on the page.\n   *    Defaults to 0 milliseconds.\n   *\n   * -  `pageLoad` specifies the maximum amount of time to wait for a page to\n   *    finishing loading. Defaults to 300000 milliseconds.\n   *\n   * -  `script` specifies the maximum amount of time to wait for an\n   *    {@linkplain WebDriver#executeScript evaluated script} to run. If set to\n   *    `null`, the script timeout will be indefinite.\n   *    Defaults to 30000 milliseconds.\n   *\n   * @param {{script: (number|null|undefined),\n   *          pageLoad: (number|null|undefined),\n   *          implicit: (number|null|undefined)}} conf\n   *     The desired timeout configuration.\n   * @return {!Promise<void>} A promise that will be resolved when the timeouts\n   *     have been set.\n   * @throws {!TypeError} if an invalid options object is provided.\n   * @see #getTimeouts()\n   * @see <https://w3c.github.io/webdriver/webdriver-spec.html#dfn-set-timeouts>\n   */\n  setTimeouts({ script, pageLoad, implicit } = {}) {\n    let cmd = new command.Command(command.Name.SET_TIMEOUT)\n\n    let valid = false\n\n    function setParam(key, value) {\n      if (value === null || typeof value === 'number') {\n        valid = true\n        cmd.setParameter(key, value)\n      } else if (typeof value !== 'undefined') {\n        throw TypeError('invalid timeouts configuration:' + ` expected \"${key}\" to be a number, got ${typeof value}`)\n      }\n    }\n\n    setParam('implicit', implicit)\n    setParam('pageLoad', pageLoad)\n    setParam('script', script)\n\n    if (valid) {\n      return this.driver_.execute(cmd).catch(() => {\n        // Fallback to the legacy method.\n        let cmds = []\n        if (typeof script === 'number') {\n          cmds.push(legacyTimeout(this.driver_, 'script', script))\n        }\n        if (typeof implicit === 'number') {\n          cmds.push(legacyTimeout(this.driver_, 'implicit', implicit))\n        }\n        if (typeof pageLoad === 'number') {\n          cmds.push(legacyTimeout(this.driver_, 'page load', pageLoad))\n        }\n        return Promise.all(cmds)\n      })\n    }\n    throw TypeError('no timeouts specified')\n  }\n\n  /**\n   * @return {!Logs} The interface for managing driver logs.\n   */\n  logs() {\n    return new Logs(this.driver_)\n  }\n\n  /**\n   * @return {!Window} The interface for managing the current window.\n   */\n  window() {\n    return new Window(this.driver_)\n  }\n}\n\n/**\n * @param {!WebDriver} driver\n * @param {string} type\n * @param {number} ms\n * @return {!Promise<void>}\n */\nfunction legacyTimeout(driver, type, ms) {\n  return driver.execute(new command.Command(command.Name.SET_TIMEOUT).setParameter('type', type).setParameter('ms', ms))\n}\n\n/**\n * A record object describing a browser cookie.\n *\n * @record\n */\nOptions.Cookie = function () {}\n\n/**\n * The name of the cookie.\n *\n * @type {string}\n */\nOptions.Cookie.prototype.name\n\n/**\n * The cookie value.\n *\n * @type {string}\n */\nOptions.Cookie.prototype.value\n\n/**\n * The cookie path. Defaults to \"/\" when adding a cookie.\n *\n * @type {(string|undefined)}\n */\nOptions.Cookie.prototype.path\n\n/**\n * The domain the cookie is visible to. Defaults to the current browsing\n * context's document's URL when adding a cookie.\n *\n * @type {(string|undefined)}\n */\nOptions.Cookie.prototype.domain\n\n/**\n * Whether the cookie is a secure cookie. Defaults to false when adding a new\n * cookie.\n *\n * @type {(boolean|undefined)}\n */\nOptions.Cookie.prototype.secure\n\n/**\n * Whether the cookie is an HTTP only cookie. Defaults to false when adding a\n * new cookie.\n *\n * @type {(boolean|undefined)}\n */\nOptions.Cookie.prototype.httpOnly\n\n/**\n * When the cookie expires.\n *\n * When {@linkplain Options#addCookie() adding a cookie}, this may be specified\n * as a {@link Date} object, or in _seconds_ since Unix epoch (January 1, 1970).\n *\n * The expiry is always returned in seconds since epoch when\n * {@linkplain Options#getCookies() retrieving cookies} from the browser.\n *\n * @type {(!Date|number|undefined)}\n */\nOptions.Cookie.prototype.expiry\n\n/**\n * When the cookie applies to a SameSite policy.\n *\n * When {@linkplain Options#addCookie() adding a cookie}, this may be specified\n * as a {@link string} object which is one of 'Lax', 'Strict' or 'None'.\n *\n *\n * @type {(string|undefined)}\n */\nOptions.Cookie.prototype.sameSite\n\n/**\n * An interface for managing the current window.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with\n *\n *    webdriver.manage().window()\n *\n * @see WebDriver#manage()\n * @see Options#window()\n */\nclass Window {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver\n    /** @private {!Logger} */\n    this.log_ = logging.getLogger(logging.Type.DRIVER)\n  }\n\n  /**\n   * Retrieves a rect describing the current top-level window's size and\n   * position.\n   *\n   * @return {!Promise<{x: number, y: number, width: number, height: number}>}\n   *     A promise that will resolve to the window rect of the current window.\n   */\n  getRect() {\n    return this.driver_.execute(new command.Command(command.Name.GET_WINDOW_RECT))\n  }\n\n  /**\n   * Sets the current top-level window's size and position. You may update just\n   * the size by omitting `x` & `y`, or just the position by omitting\n   * `width` & `height` options.\n   *\n   * @param {{x: (number|undefined),\n   *          y: (number|undefined),\n   *          width: (number|undefined),\n   *          height: (number|undefined)}} options\n   *     The desired window size and position.\n   * @return {!Promise<{x: number, y: number, width: number, height: number}>}\n   *     A promise that will resolve to the current window's updated window\n   *     rect.\n   */\n  setRect({ x, y, width, height }) {\n    return this.driver_.execute(\n      new command.Command(command.Name.SET_WINDOW_RECT).setParameters({\n        x,\n        y,\n        width,\n        height,\n      }),\n    )\n  }\n\n  /**\n   * Maximizes the current window. The exact behavior of this command is\n   * specific to individual window managers, but typically involves increasing\n   * the window to the maximum available size without going full-screen.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   */\n  maximize() {\n    return this.driver_.execute(\n      new command.Command(command.Name.MAXIMIZE_WINDOW).setParameter('windowHandle', 'current'),\n    )\n  }\n\n  /**\n   * Minimizes the current window. The exact behavior of this command is\n   * specific to individual window managers, but typically involves hiding\n   * the window in the system tray.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   */\n  minimize() {\n    return this.driver_.execute(new command.Command(command.Name.MINIMIZE_WINDOW))\n  }\n\n  /**\n   * Invokes the \"full screen\" operation on the current window. The exact\n   * behavior of this command is specific to individual window managers, but\n   * this will typically increase the window size to the size of the physical\n   * display and hide the browser chrome.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   * @see <https://fullscreen.spec.whatwg.org/#fullscreen-an-element>\n   */\n  fullscreen() {\n    return this.driver_.execute(new command.Command(command.Name.FULLSCREEN_WINDOW))\n  }\n\n  /**\n   * Gets the width and height of the current window\n   * @param windowHandle\n   * @returns {Promise<{width: *, height: *}>}\n   */\n  async getSize(windowHandle = 'current') {\n    if (windowHandle !== 'current') {\n      this.log_.warning(`Only 'current' window is supported for W3C compatible browsers.`)\n    }\n\n    const rect = await this.getRect()\n    return { height: rect.height, width: rect.width }\n  }\n\n  /**\n   * Sets the width and height of the current window. (window.resizeTo)\n   * @param x\n   * @param y\n   * @param width\n   * @param height\n   * @param windowHandle\n   * @returns {Promise<void>}\n   */\n  async setSize({ x = 0, y = 0, width = 0, height = 0 }, windowHandle = 'current') {\n    if (windowHandle !== 'current') {\n      this.log_.warning(`Only 'current' window is supported for W3C compatible browsers.`)\n    }\n\n    await this.setRect({ x, y, width, height })\n  }\n}\n\n/**\n * Interface for managing WebDriver log records.\n *\n * This class should never be instantiated directly. Instead, obtain an\n * instance with\n *\n *     webdriver.manage().logs()\n *\n * @see WebDriver#manage()\n * @see Options#logs()\n */\nclass Logs {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver\n  }\n\n  /**\n   * Fetches available log entries for the given type.\n   *\n   * Note that log buffers are reset after each call, meaning that available\n   * log entries correspond to those entries not yet returned for a given log\n   * type. In practice, this means that this call will return the available log\n   * entries since the last call, or from the start of the session.\n   *\n   * @param {!logging.Type} type The desired log type.\n   * @return {!Promise<!Array.<!logging.Entry>>} A\n   *   promise that will resolve to a list of log entries for the specified\n   *   type.\n   */\n  get(type) {\n    let cmd = new command.Command(command.Name.GET_LOG).setParameter('type', type)\n    return this.driver_.execute(cmd).then(function (entries) {\n      return entries.map(function (entry) {\n        if (!(entry instanceof logging.Entry)) {\n          return new logging.Entry(entry['level'], entry['message'], entry['timestamp'], entry['type'])\n        }\n        return entry\n      })\n    })\n  }\n\n  /**\n   * Retrieves the log types available to this driver.\n   * @return {!Promise<!Array<!logging.Type>>} A\n   *     promise that will resolve to a list of available log types.\n   */\n  getAvailableLogTypes() {\n    return this.driver_.execute(new command.Command(command.Name.GET_AVAILABLE_LOG_TYPES))\n  }\n}\n\n/**\n * An interface for changing the focus of the driver to another frame or window.\n *\n * This class should never be instantiated directly. Instead, obtain an\n * instance with\n *\n *     webdriver.switchTo()\n *\n * @see WebDriver#switchTo()\n */\nclass TargetLocator {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver\n  }\n\n  /**\n   * Locates the DOM element on the current page that corresponds to\n   * `document.activeElement` or `document.body` if the active element is not\n   * available.\n   *\n   * @return {!WebElementPromise} The active element.\n   */\n  activeElement() {\n    const id = this.driver_.execute(new command.Command(command.Name.GET_ACTIVE_ELEMENT))\n    return new WebElementPromise(this.driver_, id)\n  }\n\n  /**\n   * Switches focus of all future commands to the topmost frame in the current\n   * window.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the default content.\n   */\n  defaultContent() {\n    return this.driver_.execute(new command.Command(command.Name.SWITCH_TO_FRAME).setParameter('id', null))\n  }\n\n  /**\n   * Changes the focus of all future commands to another frame on the page. The\n   * target frame may be specified as one of the following:\n   *\n   * - A number that specifies a (zero-based) index into [window.frames](\n   *   https://developer.mozilla.org/en-US/docs/Web/API/Window.frames).\n   * - A {@link WebElement} reference, which correspond to a `frame` or `iframe`\n   *   DOM element.\n   * - The `null` value, to select the topmost frame on the page. Passing `null`\n   *   is the same as calling {@link #defaultContent defaultContent()}.\n   *\n   * If the specified frame can not be found, the returned promise will be\n   * rejected with a {@linkplain error.NoSuchFrameError}.\n   *\n   * @param {(number|string|WebElement|null)} id The frame locator.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the specified frame.\n   */\n  frame(id) {\n    let frameReference = id\n    if (typeof id === 'string') {\n      frameReference = this.driver_.findElement({ id }).catch((_) => this.driver_.findElement({ name: id }))\n    }\n\n    return this.driver_.execute(new command.Command(command.Name.SWITCH_TO_FRAME).setParameter('id', frameReference))\n  }\n\n  /**\n   * Changes the focus of all future commands to the parent frame of the\n   * currently selected frame. This command has no effect if the driver is\n   * already focused on the top-level browsing context.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   */\n  parentFrame() {\n    return this.driver_.execute(new command.Command(command.Name.SWITCH_TO_FRAME_PARENT))\n  }\n\n  /**\n   * Changes the focus of all future commands to another window. Windows may be\n   * specified by their {@code window.name} attribute or by its handle\n   * (as returned by {@link WebDriver#getWindowHandles}).\n   *\n   * If the specified window cannot be found, the returned promise will be\n   * rejected with a {@linkplain error.NoSuchWindowError}.\n   *\n   * @param {string} nameOrHandle The name or window handle of the window to\n   *     switch focus to.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the specified window.\n   */\n  window(nameOrHandle) {\n    return this.driver_.execute(\n      new command.Command(command.Name.SWITCH_TO_WINDOW)\n        // \"name\" supports the legacy drivers. \"handle\" is the W3C\n        // compliant parameter.\n        .setParameter('name', nameOrHandle)\n        .setParameter('handle', nameOrHandle),\n    )\n  }\n\n  /**\n   * Creates a new browser window and switches the focus for future\n   * commands of this driver to the new window.\n   *\n   * @param {string} typeHint 'window' or 'tab'. The created window is not\n   *     guaranteed to be of the requested type; if the driver does not support\n   *     the requested type, a new browser window will be created of whatever type\n   *     the driver does support.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the new window.\n   */\n  newWindow(typeHint) {\n    const driver = this.driver_\n    return this.driver_\n      .execute(new command.Command(command.Name.SWITCH_TO_NEW_WINDOW).setParameter('type', typeHint))\n      .then(function (response) {\n        return driver.switchTo().window(response.handle)\n      })\n  }\n\n  /**\n   * Changes focus to the active modal dialog, such as those opened by\n   * `window.alert()`, `window.confirm()`, and `window.prompt()`. The returned\n   * promise will be rejected with a\n   * {@linkplain error.NoSuchAlertError} if there are no open alerts.\n   *\n   * @return {!AlertPromise} The open alert.\n   */\n  alert() {\n    const text = this.driver_.execute(new command.Command(command.Name.GET_ALERT_TEXT))\n    const driver = this.driver_\n    return new AlertPromise(\n      driver,\n      text.then(function (text) {\n        return new Alert(driver, text)\n      }),\n    )\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  WebElement\n//\n//////////////////////////////////////////////////////////////////////////////\n\nconst LEGACY_ELEMENT_ID_KEY = 'ELEMENT'\nconst ELEMENT_ID_KEY = 'element-6066-11e4-a52e-4f735466cecf'\nconst SHADOW_ROOT_ID_KEY = 'shadow-6066-11e4-a52e-4f735466cecf'\n\n/**\n * Represents a DOM element. WebElements can be found by searching from the\n * document root using a {@link WebDriver} instance, or by searching\n * under another WebElement:\n *\n *     driver.get('http://www.google.com');\n *     var searchForm = driver.findElement(By.tagName('form'));\n *     var searchBox = searchForm.findElement(By.name('q'));\n *     searchBox.sendKeys('webdriver');\n */\nclass WebElement {\n  /**\n   * @param {!WebDriver} driver the parent WebDriver instance for this element.\n   * @param {(!IThenable<string>|string)} id The server-assigned opaque ID for\n   *     the underlying DOM element.\n   */\n  constructor(driver, id) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver\n\n    /** @private {!Promise<string>} */\n    this.id_ = Promise.resolve(id)\n\n    /** @private {!Logger} */\n    this.log_ = logging.getLogger(logging.Type.DRIVER)\n  }\n\n  /**\n   * @param {string} id The raw ID.\n   * @param {boolean=} noLegacy Whether to exclude the legacy element key.\n   * @return {!Object} The element ID for use with WebDriver's wire protocol.\n   */\n  static buildId(id, noLegacy = false) {\n    return noLegacy ? { [ELEMENT_ID_KEY]: id } : { [ELEMENT_ID_KEY]: id, [LEGACY_ELEMENT_ID_KEY]: id }\n  }\n\n  /**\n   * Extracts the encoded WebElement ID from the object.\n   *\n   * @param {?} obj The object to extract the ID from.\n   * @return {string} the extracted ID.\n   * @throws {TypeError} if the object is not a valid encoded ID.\n   */\n  static extractId(obj) {\n    return webElement.extractId(obj)\n  }\n\n  /**\n   * @param {?} obj the object to test.\n   * @return {boolean} whether the object is a valid encoded WebElement ID.\n   */\n  static isId(obj) {\n    return webElement.isId(obj)\n  }\n\n  /**\n   * Compares two WebElements for equality.\n   *\n   * @param {!WebElement} a A WebElement.\n   * @param {!WebElement} b A WebElement.\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved to whether the two WebElements are equal.\n   */\n  static async equals(a, b) {\n    if (a === b) {\n      return true\n    }\n    return a.driver_.executeScript('return arguments[0] === arguments[1]', a, b)\n  }\n\n  /** @return {!WebDriver} The parent driver for this instance. */\n  getDriver() {\n    return this.driver_\n  }\n\n  /**\n   * @return {!Promise<string>} A promise that resolves to\n   *     the server-assigned opaque ID assigned to this element.\n   */\n  getId() {\n    return this.id_\n  }\n\n  /**\n   * @return {!Object} Returns the serialized representation of this WebElement.\n   */\n  [Symbols.serialize]() {\n    return this.getId().then(WebElement.buildId)\n  }\n\n  /**\n   * Schedules a command that targets this element with the parent WebDriver\n   * instance. Will ensure this element's ID is included in the command\n   * parameters under the \"id\" key.\n   *\n   * @param {!command.Command} command The command to schedule.\n   * @return {!Promise<T>} A promise that will be resolved with the result.\n   * @template T\n   * @see WebDriver#schedule\n   * @private\n   */\n  execute_(command) {\n    command.setParameter('id', this)\n    return this.driver_.execute(command)\n  }\n\n  /**\n   * Schedule a command to find a descendant of this element. If the element\n   * cannot be found, the returned promise will be rejected with a\n   * {@linkplain error.NoSuchElementError NoSuchElementError}.\n   *\n   * The search criteria for an element may be defined using one of the static\n   * factories on the {@link by.By} class, or as a short-hand\n   * {@link ./by.ByHash} object. For example, the following two statements\n   * are equivalent:\n   *\n   *     var e1 = element.findElement(By.id('foo'));\n   *     var e2 = element.findElement({id:'foo'});\n   *\n   * You may also provide a custom locator function, which takes as input this\n   * instance and returns a {@link WebElement}, or a promise that will resolve\n   * to a WebElement. If the returned promise resolves to an array of\n   * WebElements, WebDriver will use the first element. For example, to find the\n   * first visible link on a page, you could write:\n   *\n   *     var link = element.findElement(firstVisibleLink);\n   *\n   *     function firstVisibleLink(element) {\n   *       var links = element.findElements(By.tagName('a'));\n   *       return promise.filter(links, function(link) {\n   *         return link.isDisplayed();\n   *       });\n   *     }\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!WebElementPromise} A WebElement that can be used to issue\n   *     commands against the located element. If the element is not found, the\n   *     element will be invalidated and all scheduled commands aborted.\n   */\n  findElement(locator) {\n    locator = by.checkedLocator(locator)\n    let id\n    if (typeof locator === 'function') {\n      id = this.driver_.findElementInternal_(locator, this)\n    } else {\n      let cmd = new command.Command(command.Name.FIND_CHILD_ELEMENT)\n        .setParameter('using', locator.using)\n        .setParameter('value', locator.value)\n      id = this.execute_(cmd)\n    }\n    return new WebElementPromise(this.driver_, id)\n  }\n\n  /**\n   * Locates all the descendants of this element that match the given search\n   * criteria.\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   */\n  async findElements(locator) {\n    locator = by.checkedLocator(locator)\n    if (typeof locator === 'function') {\n      return this.driver_.findElementsInternal_(locator, this)\n    } else {\n      let cmd = new command.Command(command.Name.FIND_CHILD_ELEMENTS)\n        .setParameter('using', locator.using)\n        .setParameter('value', locator.value)\n      let result = await this.execute_(cmd)\n      return Array.isArray(result) ? result : []\n    }\n  }\n\n  /**\n   * Clicks on this element.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the click\n   *     command has completed.\n   */\n  click() {\n    return this.execute_(new command.Command(command.Name.CLICK_ELEMENT))\n  }\n\n  /**\n   * Types a key sequence on the DOM element represented by this instance.\n   *\n   * Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is\n   * processed in the key sequence, that key state is toggled until one of the\n   * following occurs:\n   *\n   * - The modifier key is encountered again in the sequence. At this point the\n   *   state of the key is toggled (along with the appropriate keyup/down\n   *   events).\n   * - The {@link input.Key.NULL} key is encountered in the sequence. When\n   *   this key is encountered, all modifier keys current in the down state are\n   *   released (with accompanying keyup events). The NULL key can be used to\n   *   simulate common keyboard shortcuts:\n   *\n   *         element.sendKeys(\"text was\",\n   *                          Key.CONTROL, \"a\", Key.NULL,\n   *                          \"now text is\");\n   *         // Alternatively:\n   *         element.sendKeys(\"text was\",\n   *                          Key.chord(Key.CONTROL, \"a\"),\n   *                          \"now text is\");\n   *\n   * - The end of the key sequence is encountered. When there are no more keys\n   *   to type, all depressed modifier keys are released (with accompanying\n   *   keyup events).\n   *\n   * If this element is a file input ({@code <input type=\"file\">}), the\n   * specified key sequence should specify the path to the file to attach to\n   * the element. This is analogous to the user clicking \"Browse...\" and entering\n   * the path into the file select dialog.\n   *\n   *     var form = driver.findElement(By.css('form'));\n   *     var element = form.findElement(By.css('input[type=file]'));\n   *     element.sendKeys('/path/to/file.txt');\n   *     form.submit();\n   *\n   * For uploads to function correctly, the entered path must reference a file\n   * on the _browser's_ machine, not the local machine running this script. When\n   * running against a remote Selenium server, a {@link input.FileDetector}\n   * may be used to transparently copy files to the remote machine before\n   * attempting to upload them in the browser.\n   *\n   * __Note:__ On browsers where native keyboard events are not supported\n   * (e.g. Firefox on OS X), key events will be synthesized. Special\n   * punctuation keys will be synthesized according to a standard QWERTY en-us\n   * keyboard layout.\n   *\n   * @param {...(number|string|!IThenable<(number|string)>)} args The\n   *     sequence of keys to type. Number keys may be referenced numerically or\n   *     by string (1 or '1'). All arguments will be joined into a single\n   *     sequence.\n   * @return {!Promise<void>} A promise that will be resolved when all keys\n   *     have been typed.\n   */\n  async sendKeys(...args) {\n    let keys = []\n    ;(await Promise.all(args)).forEach((key) => {\n      let type = typeof key\n      if (type === 'number') {\n        key = String(key)\n      } else if (type !== 'string') {\n        throw TypeError('each key must be a number or string; got ' + type)\n      }\n\n      // The W3C protocol requires keys to be specified as an array where\n      // each element is a single key.\n      keys.push(...key)\n    })\n\n    if (!this.driver_.fileDetector_) {\n      return this.execute_(\n        new command.Command(command.Name.SEND_KEYS_TO_ELEMENT)\n          .setParameter('text', keys.join(''))\n          .setParameter('value', keys),\n      )\n    }\n\n    try {\n      keys = await this.driver_.fileDetector_.handleFile(this.driver_, keys.join(''))\n    } catch (ex) {\n      this.log_.severe('Error trying parse string as a file with file detector; sending keys instead' + ex)\n    }\n\n    return this.execute_(\n      new command.Command(command.Name.SEND_KEYS_TO_ELEMENT)\n        .setParameter('text', keys)\n        .setParameter('value', keys.split('')),\n    )\n  }\n\n  /**\n   * Retrieves the element's tag name.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the\n   *     element's tag name.\n   */\n  getTagName() {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_TAG_NAME))\n  }\n\n  /**\n   * Retrieves the value of a computed style property for this instance. If\n   * the element inherits the named style from its parent, the parent will be\n   * queried for its value.  Where possible, color values will be converted to\n   * their hex representation (e.g. #00ff00 instead of rgb(0, 255, 0)).\n   *\n   * _Warning:_ the value returned will be as the browser interprets it, so\n   * it may be tricky to form a proper assertion.\n   *\n   * @param {string} cssStyleProperty The name of the CSS style property to look\n   *     up.\n   * @return {!Promise<string>} A promise that will be resolved with the\n   *     requested CSS value.\n   */\n  getCssValue(cssStyleProperty) {\n    const name = command.Name.GET_ELEMENT_VALUE_OF_CSS_PROPERTY\n    return this.execute_(new command.Command(name).setParameter('propertyName', cssStyleProperty))\n  }\n\n  /**\n   * Retrieves the current value of the given attribute of this element.\n   * Will return the current value, even if it has been modified after the page\n   * has been loaded. More exactly, this method will return the value\n   * of the given attribute, unless that attribute is not present, in which case\n   * the value of the property with the same name is returned. If neither value\n   * is set, null is returned (for example, the \"value\" property of a textarea\n   * element). The \"style\" attribute is converted as best can be to a\n   * text representation with a trailing semicolon. The following are deemed to\n   * be \"boolean\" attributes and will return either \"true\" or null:\n   *\n   * async, autofocus, autoplay, checked, compact, complete, controls, declare,\n   * defaultchecked, defaultselected, defer, disabled, draggable, ended,\n   * formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,\n   * loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,\n   * paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,\n   * selected, spellcheck, truespeed, willvalidate\n   *\n   * Finally, the following commonly mis-capitalized attribute/property names\n   * are evaluated as expected:\n   *\n   * - \"class\"\n   * - \"readonly\"\n   *\n   * @param {string} attributeName The name of the attribute to query.\n   * @return {!Promise<?string>} A promise that will be\n   *     resolved with the attribute's value. The returned value will always be\n   *     either a string or null.\n   */\n  getAttribute(attributeName) {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_ATTRIBUTE).setParameter('name', attributeName))\n  }\n\n  /**\n   * Get the value of the given attribute of the element.\n   * <p>\n   * This method, unlike {@link #getAttribute(String)}, returns the value of the attribute with the\n   * given name but not the property with the same name.\n   * <p>\n   * The following are deemed to be \"boolean\" attributes, and will return either \"true\" or null:\n   * <p>\n   * async, autofocus, autoplay, checked, compact, complete, controls, declare, defaultchecked,\n   * defaultselected, defer, disabled, draggable, ended, formnovalidate, hidden, indeterminate,\n   * iscontenteditable, ismap, itemscope, loop, multiple, muted, nohref, noresize, noshade,\n   * novalidate, nowrap, open, paused, pubdate, readonly, required, reversed, scoped, seamless,\n   * seeking, selected, truespeed, willvalidate\n   * <p>\n   * See <a href=\"https://w3c.github.io/webdriver/#get-element-attribute\">W3C WebDriver specification</a>\n   * for more details.\n   *\n   * @param attributeName The name of the attribute.\n   * @return The attribute's value or null if the value is not set.\n   */\n\n  getDomAttribute(attributeName) {\n    return this.execute_(new command.Command(command.Name.GET_DOM_ATTRIBUTE).setParameter('name', attributeName))\n  }\n\n  /**\n   * Get the given property of the referenced web element\n   * @param {string} propertyName The name of the attribute to query.\n   * @return {!Promise<string>} A promise that will be\n   *     resolved with the element's property value\n   */\n  getProperty(propertyName) {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_PROPERTY).setParameter('name', propertyName))\n  }\n\n  /**\n   * Get the shadow root of the current web element.\n   * @returns {!Promise<ShadowRoot>} A promise that will be\n   *      resolved with the elements shadow root or rejected\n   *      with {@link NoSuchShadowRootError}\n   */\n  getShadowRoot() {\n    return this.execute_(new command.Command(command.Name.GET_SHADOW_ROOT))\n  }\n\n  /**\n   * Get the visible (i.e. not hidden by CSS) innerText of this element,\n   * including sub-elements, without any leading or trailing whitespace.\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved with the element's visible text.\n   */\n  getText() {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_TEXT))\n  }\n\n  /**\n   * Get the computed WAI-ARIA role of element.\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved with the element's computed role.\n   */\n  getAriaRole() {\n    return this.execute_(new command.Command(command.Name.GET_COMPUTED_ROLE))\n  }\n\n  /**\n   * Get the computed WAI-ARIA label of element.\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved with the element's computed label.\n   */\n  getAccessibleName() {\n    return this.execute_(new command.Command(command.Name.GET_COMPUTED_LABEL))\n  }\n\n  /**\n   * Returns an object describing an element's location, in pixels relative to\n   * the document element, and the element's size in pixels.\n   *\n   * @return {!Promise<{width: number, height: number, x: number, y: number}>}\n   *     A promise that will resolve with the element's rect.\n   */\n  getRect() {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_RECT))\n  }\n\n  /**\n   * Tests whether this element is enabled, as dictated by the `disabled`\n   * attribute.\n   *\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved with whether this element is currently enabled.\n   */\n  isEnabled() {\n    return this.execute_(new command.Command(command.Name.IS_ELEMENT_ENABLED))\n  }\n\n  /**\n   * Tests whether this element is selected.\n   *\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved with whether this element is currently selected.\n   */\n  isSelected() {\n    return this.execute_(new command.Command(command.Name.IS_ELEMENT_SELECTED))\n  }\n\n  /**\n   * Submits the form containing this element (or this element if it is itself\n   * a FORM element). his command is a no-op if the element is not contained in\n   * a form.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the form has been submitted.\n   */\n  submit() {\n    const script =\n      '/* submitForm */var form = arguments[0];\\n' +\n      'while (form.nodeName != \"FORM\" && form.parentNode) {\\n' +\n      '  form = form.parentNode;\\n' +\n      '}\\n' +\n      \"if (!form) { throw Error('Unable to find containing form element'); }\\n\" +\n      \"if (!form.ownerDocument) { throw Error('Unable to find owning document'); }\\n\" +\n      \"var e = form.ownerDocument.createEvent('Event');\\n\" +\n      \"e.initEvent('submit', true, true);\\n\" +\n      'if (form.dispatchEvent(e)) { HTMLFormElement.prototype.submit.call(form) }\\n'\n\n    return this.driver_.executeScript(script, this)\n  }\n\n  /**\n   * Clear the `value` of this element. This command has no effect if the\n   * underlying DOM element is neither a text INPUT element nor a TEXTAREA\n   * element.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the element has been cleared.\n   */\n  clear() {\n    return this.execute_(new command.Command(command.Name.CLEAR_ELEMENT))\n  }\n\n  /**\n   * Test whether this element is currently displayed.\n   *\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved with whether this element is currently visible on the page.\n   */\n  isDisplayed() {\n    return this.execute_(new command.Command(command.Name.IS_ELEMENT_DISPLAYED))\n  }\n\n  /**\n   * Take a screenshot of the visible region encompassed by this element's\n   * bounding rectangle.\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved to the screenshot as a base-64 encoded PNG.\n   */\n  takeScreenshot() {\n    return this.execute_(new command.Command(command.Name.TAKE_ELEMENT_SCREENSHOT))\n  }\n}\n\n/**\n * WebElementPromise is a promise that will be fulfilled with a WebElement.\n * This serves as a forward proxy on WebElement, allowing calls to be\n * scheduled without directly on this instance before the underlying\n * WebElement has been fulfilled. In other words, the following two statements\n * are equivalent:\n *\n *     driver.findElement({id: 'my-button'}).click();\n *     driver.findElement({id: 'my-button'}).then(function(el) {\n *       return el.click();\n *     });\n *\n * @implements {IThenable<!WebElement>}\n * @final\n */\nclass WebElementPromise extends WebElement {\n  /**\n   * @param {!WebDriver} driver The parent WebDriver instance for this\n   *     element.\n   * @param {!Promise<!WebElement>} el A promise\n   *     that will resolve to the promised element.\n   */\n  constructor(driver, el) {\n    super(driver, 'unused')\n\n    /** @override */\n    this.then = el.then.bind(el)\n\n    /** @override */\n    this.catch = el.catch.bind(el)\n\n    /**\n     * Defers returning the element ID until the wrapped WebElement has been\n     * resolved.\n     * @override\n     */\n    this.getId = function () {\n      return el.then(function (el) {\n        return el.getId()\n      })\n    }\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  ShadowRoot\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Represents a ShadowRoot of a {@link WebElement}. Provides functions to\n * retrieve elements that live in the DOM below the ShadowRoot.\n */\nclass ShadowRoot {\n  constructor(driver, id) {\n    this.driver_ = driver\n    this.id_ = id\n  }\n\n  /**\n   * Extracts the encoded ShadowRoot ID from the object.\n   *\n   * @param {?} obj The object to extract the ID from.\n   * @return {string} the extracted ID.\n   * @throws {TypeError} if the object is not a valid encoded ID.\n   */\n  static extractId(obj) {\n    if (obj && typeof obj === 'object') {\n      if (typeof obj[SHADOW_ROOT_ID_KEY] === 'string') {\n        return obj[SHADOW_ROOT_ID_KEY]\n      }\n    }\n    throw new TypeError('object is not a ShadowRoot ID')\n  }\n\n  /**\n   * @param {?} obj the object to test.\n   * @return {boolean} whether the object is a valid encoded WebElement ID.\n   */\n  static isId(obj) {\n    return obj && typeof obj === 'object' && typeof obj[SHADOW_ROOT_ID_KEY] === 'string'\n  }\n\n  /**\n   * @return {!Object} Returns the serialized representation of this ShadowRoot.\n   */\n  [Symbols.serialize]() {\n    return this.getId()\n  }\n\n  /**\n   * Schedules a command that targets this element with the parent WebDriver\n   * instance. Will ensure this element's ID is included in the command\n   * parameters under the \"id\" key.\n   *\n   * @param {!command.Command} command The command to schedule.\n   * @return {!Promise<T>} A promise that will be resolved with the result.\n   * @template T\n   * @see WebDriver#schedule\n   * @private\n   */\n  execute_(command) {\n    command.setParameter('id', this)\n    return this.driver_.execute(command)\n  }\n\n  /**\n   * Schedule a command to find a descendant of this ShadowROot. If the element\n   * cannot be found, the returned promise will be rejected with a\n   * {@linkplain error.NoSuchElementError NoSuchElementError}.\n   *\n   * The search criteria for an element may be defined using one of the static\n   * factories on the {@link by.By} class, or as a short-hand\n   * {@link ./by.ByHash} object. For example, the following two statements\n   * are equivalent:\n   *\n   *     var e1 = shadowroot.findElement(By.id('foo'));\n   *     var e2 = shadowroot.findElement({id:'foo'});\n   *\n   * You may also provide a custom locator function, which takes as input this\n   * instance and returns a {@link WebElement}, or a promise that will resolve\n   * to a WebElement. If the returned promise resolves to an array of\n   * WebElements, WebDriver will use the first element. For example, to find the\n   * first visible link on a page, you could write:\n   *\n   *     var link = element.findElement(firstVisibleLink);\n   *\n   *     function firstVisibleLink(shadowRoot) {\n   *       var links = shadowRoot.findElements(By.tagName('a'));\n   *       return promise.filter(links, function(link) {\n   *         return link.isDisplayed();\n   *       });\n   *     }\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!WebElementPromise} A WebElement that can be used to issue\n   *     commands against the located element. If the element is not found, the\n   *     element will be invalidated and all scheduled commands aborted.\n   */\n  findElement(locator) {\n    locator = by.checkedLocator(locator)\n    let id\n    if (typeof locator === 'function') {\n      id = this.driver_.findElementInternal_(locator, this)\n    } else {\n      let cmd = new command.Command(command.Name.FIND_ELEMENT_FROM_SHADOWROOT)\n        .setParameter('using', locator.using)\n        .setParameter('value', locator.value)\n      id = this.execute_(cmd)\n    }\n    return new ShadowRootPromise(this.driver_, id)\n  }\n\n  /**\n   * Locates all the descendants of this element that match the given search\n   * criteria.\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   */\n  async findElements(locator) {\n    locator = by.checkedLocator(locator)\n    if (typeof locator === 'function') {\n      return this.driver_.findElementsInternal_(locator, this)\n    } else {\n      let cmd = new command.Command(command.Name.FIND_ELEMENTS_FROM_SHADOWROOT)\n        .setParameter('using', locator.using)\n        .setParameter('value', locator.value)\n      let result = await this.execute_(cmd)\n      return Array.isArray(result) ? result : []\n    }\n  }\n\n  getId() {\n    return this.id_\n  }\n}\n\n/**\n * ShadowRootPromise is a promise that will be fulfilled with a WebElement.\n * This serves as a forward proxy on ShadowRoot, allowing calls to be\n * scheduled without directly on this instance before the underlying\n * ShadowRoot has been fulfilled.\n *\n * @implements { IThenable<!ShadowRoot>}\n * @final\n */\nclass ShadowRootPromise extends ShadowRoot {\n  /**\n   * @param {!WebDriver} driver The parent WebDriver instance for this\n   *     element.\n   * @param {!Promise<!ShadowRoot>} shadow A promise\n   *     that will resolve to the promised element.\n   */\n  constructor(driver, shadow) {\n    super(driver, 'unused')\n\n    /** @override */\n    this.then = shadow.then.bind(shadow)\n\n    /** @override */\n    this.catch = shadow.catch.bind(shadow)\n\n    /**\n     * Defers returning the ShadowRoot ID until the wrapped WebElement has been\n     * resolved.\n     * @override\n     */\n    this.getId = function () {\n      return shadow.then(function (shadow) {\n        return shadow.getId()\n      })\n    }\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  Alert\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Represents a modal dialog such as {@code alert}, {@code confirm}, or\n * {@code prompt}. Provides functions to retrieve the message displayed with\n * the alert, accept or dismiss the alert, and set the response text (in the\n * case of {@code prompt}).\n */\nclass Alert {\n  /**\n   * @param {!WebDriver} driver The driver controlling the browser this alert\n   *     is attached to.\n   * @param {string} text The message text displayed with this alert.\n   */\n  constructor(driver, text) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver\n\n    /** @private {!Promise<string>} */\n    this.text_ = Promise.resolve(text)\n  }\n\n  /**\n   * Retrieves the message text displayed with this alert. For instance, if the\n   * alert were opened with alert(\"hello\"), then this would return \"hello\".\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved to the text displayed with this alert.\n   */\n  getText() {\n    return this.text_\n  }\n\n  /**\n   * Accepts this alert.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  accept() {\n    return this.driver_.execute(new command.Command(command.Name.ACCEPT_ALERT))\n  }\n\n  /**\n   * Dismisses this alert.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  dismiss() {\n    return this.driver_.execute(new command.Command(command.Name.DISMISS_ALERT))\n  }\n\n  /**\n   * Sets the response text on this alert. This command will return an error if\n   * the underlying alert does not support response text (e.g. window.alert and\n   * window.confirm).\n   *\n   * @param {string} text The text to set.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  sendKeys(text) {\n    return this.driver_.execute(new command.Command(command.Name.SET_ALERT_TEXT).setParameter('text', text))\n  }\n}\n\n/**\n * AlertPromise is a promise that will be fulfilled with an Alert. This promise\n * serves as a forward proxy on an Alert, allowing calls to be scheduled\n * directly on this instance before the underlying Alert has been fulfilled. In\n * other words, the following two statements are equivalent:\n *\n *     driver.switchTo().alert().dismiss();\n *     driver.switchTo().alert().then(function(alert) {\n *       return alert.dismiss();\n *     });\n *\n * @implements {IThenable<!Alert>}\n * @final\n */\nclass AlertPromise extends Alert {\n  /**\n   * @param {!WebDriver} driver The driver controlling the browser this\n   *     alert is attached to.\n   * @param {!Promise<!Alert>} alert A thenable\n   *     that will be fulfilled with the promised alert.\n   */\n  constructor(driver, alert) {\n    super(driver, 'unused')\n\n    /** @override */\n    this.then = alert.then.bind(alert)\n\n    /** @override */\n    this.catch = alert.catch.bind(alert)\n\n    /**\n     * Defer returning text until the promised alert has been resolved.\n     * @override\n     */\n    this.getText = function () {\n      return alert.then(function (alert) {\n        return alert.getText()\n      })\n    }\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.accept = function () {\n      return alert.then(function (alert) {\n        return alert.accept()\n      })\n    }\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.dismiss = function () {\n      return alert.then(function (alert) {\n        return alert.dismiss()\n      })\n    }\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.sendKeys = function (text) {\n      return alert.then(function (alert) {\n        return alert.sendKeys(text)\n      })\n    }\n  }\n}\n\n// PUBLIC API\n\nmodule.exports = {\n  Alert,\n  AlertPromise,\n  Condition,\n  Logs,\n  Navigation,\n  Options,\n  ShadowRoot,\n  TargetLocator,\n  IWebDriver,\n  WebDriver,\n  WebElement,\n  WebElementCondition,\n  WebElementPromise,\n  Window,\n}\n"],"mappings":"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E,OAAOA,OAAO,KAAK,UAAU,GAAGA,OAAO,CAAC,CAAC,GAAGA,OAAQ,IAAG,GAAG,EAAE;AAClF;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM6C,UAAU,CAAC;EACf;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEjC,OAAOA,CAACpC,OAAO,EAAE,CAAC,CAAC,CAAC;;EAEpB;AACF;AACA;AACA;AACA;EACEsE,eAAeA,CAACC,QAAQ,EAAE,CAAC,CAAC,CAAC;;EAE7B;AACF;AACA;EACEC,WAAWA,CAAA,EAAG,CAAC;;EAEf;AACF;AACA;EACEC,UAAUA,CAAA,EAAG,CAAC;;EAEd;AACF;AACA;AACA;EACEC,eAAeA,CAAA,EAAG,CAAC;;EAEnB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,IAAIA,CAAA,EAAG,CAAC;;EAER;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,OAAOA,CAACC,OAAO,EAAE,CAAC,CAAC,CAAC;;EAEpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,aAAaA,CAACC,MAAM,EAAE,GAAGC,IAAI,EAAE,CAAC,CAAC,CAAC;;EAElC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,kBAAkBA,CAACF,MAAM,EAAE,GAAGC,IAAI,EAAE,CAAC,CAAC,CAAC;;EAEvC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,IAAIA,CACFC,SAAS;EAAE;EACXC,OAAO,GAAGC,SAAS;EAAE;EACrB7D,OAAO,GAAG6D,SAAS;EAAE;EACrBC,WAAW,GAAGD,SAAS,CAAE;EAAA,EACzB,CAAC;;EAEH;AACF;AACA;AACA;AACA;AACA;AACA;EACEE,KAAKA,CAACC,EAAE,EAAE,CAAC,CAAC,CAAC;;EAEb;AACF;AACA;AACA;AACA;AACA;EACEC,eAAeA,CAAA,EAAG,CAAC;;EAEnB;AACF;AACA;AACA;AACA;AACA;EACEC,mBAAmBA,CAAA,EAAG,CAAC;;EAEvB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,aAAaA,CAAA,EAAG,CAAC;;EAEjB;AACF;AACA;AACA;AACA;AACA;EACEC,KAAKA,CAAA,EAAG,CAAC;;EAET;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,GAAGA,CAACC,GAAG,EAAE,CAAC,CAAC,CAAC;;EAEZ;AACF;AACA;AACA;AACA;AACA;EACEC,aAAaA,CAAA,EAAG,CAAC;;EAEjB;AACF;AACA;AACA;AACA;AACA;EACEC,QAAQA,CAAA,EAAG,CAAC;;EAEZ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAACC,OAAO,EAAE,CAAC,CAAC,CAAC;;EAExB;AACF;AACA;AACA;AACA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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}