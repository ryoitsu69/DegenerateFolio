{"ast":null,"code":"import { PRECISION } from \"@pixi/constants\";\nimport { ProgramCache, isMobile } from \"@pixi/utils\";\nimport defaultFragment from \"./defaultProgram.frag.mjs\";\nimport defaultVertex from \"./defaultProgram.vert.mjs\";\nimport \"./utils/index.mjs\";\nimport { setPrecision } from \"./utils/setPrecision.mjs\";\nimport { getMaxFragmentPrecision } from \"./utils/getMaxFragmentPrecision.mjs\";\nlet UID = 0;\nconst nameCache = {},\n  _Program = class _Program2 {\n    /**\n     * @param vertexSrc - The source of the vertex shader.\n     * @param fragmentSrc - The source of the fragment shader.\n     * @param name - Name for shader\n     * @param extra - Extra data for shader\n     */\n    constructor(vertexSrc, fragmentSrc, name = \"pixi-shader\", extra = {}) {\n      this.extra = {}, this.id = UID++, this.vertexSrc = vertexSrc || _Program2.defaultVertexSrc, this.fragmentSrc = fragmentSrc || _Program2.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.extra = extra, this.vertexSrc.substring(0, 8) !== \"#version\" && (name = name.replace(/\\s+/g, \"-\"), nameCache[name] ? (nameCache[name]++, name += `-${nameCache[name]}`) : nameCache[name] = 1, this.vertexSrc = `#define SHADER_NAME ${name}\n${this.vertexSrc}`, this.fragmentSrc = `#define SHADER_NAME ${name}\n${this.fragmentSrc}`, this.vertexSrc = setPrecision(this.vertexSrc, _Program2.defaultVertexPrecision, PRECISION.HIGH), this.fragmentSrc = setPrecision(this.fragmentSrc, _Program2.defaultFragmentPrecision, getMaxFragmentPrecision())), this.glPrograms = {}, this.syncUniforms = null;\n    }\n    /**\n     * The default vertex shader source.\n     * @readonly\n     */\n    static get defaultVertexSrc() {\n      return defaultVertex;\n    }\n    /**\n     * The default fragment shader source.\n     * @readonly\n     */\n    static get defaultFragmentSrc() {\n      return defaultFragment;\n    }\n    /**\n     * A short hand function to create a program based of a vertex and fragment shader.\n     *\n     * This method will also check to see if there is a cached program.\n     * @param vertexSrc - The source of the vertex shader.\n     * @param fragmentSrc - The source of the fragment shader.\n     * @param name - Name for shader\n     * @returns A shiny new PixiJS shader program!\n     */\n    static from(vertexSrc, fragmentSrc, name) {\n      const key = vertexSrc + fragmentSrc;\n      let program = ProgramCache[key];\n      return program || (ProgramCache[key] = program = new _Program2(vertexSrc, fragmentSrc, name)), program;\n    }\n  };\n_Program.defaultVertexPrecision = PRECISION.HIGH,\n/**\n* Default specify float precision in fragment shader.\n* iOS is best set at highp due to https://github.com/pixijs/pixijs/issues/3742\n* @static\n* @type {PIXI.PRECISION}\n* @default PIXI.PRECISION.MEDIUM\n*/\n_Program.defaultFragmentPrecision = isMobile.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM;\nlet Program = _Program;\nexport { Program };","map":{"version":3,"names":["UID","nameCache","_Program","_Program2","constructor","vertexSrc","fragmentSrc","name","extra","id","defaultVertexSrc","defaultFragmentSrc","trim","substring","replace","setPrecision","defaultVertexPrecision","PRECISION","HIGH","defaultFragmentPrecision","getMaxFragmentPrecision","glPrograms","syncUniforms","defaultVertex","defaultFragment","from","key","program","ProgramCache","isMobile","apple","device","MEDIUM","Program"],"sources":["/home/ryoitsu/node_modules/@pixi/core/src/shader/Program.ts"],"sourcesContent":["import { PRECISION } from '@pixi/constants';\nimport { isMobile, ProgramCache } from '@pixi/utils';\nimport defaultFragment from './defaultProgram.frag';\nimport defaultVertex from './defaultProgram.vert';\nimport { getMaxFragmentPrecision, setPrecision } from './utils';\n\nimport type { GLProgram } from './GLProgram';\n\nlet UID = 0;\n\nconst nameCache: { [key: string]: number } = {};\n\nexport interface IAttributeData\n{\n    type: string;\n    size: number;\n    location: number;\n    name: string;\n}\n\nexport interface IUniformData\n{\n    index: number;\n    type: string;\n    size: number;\n    isArray: boolean;\n    value: any;\n    name: string;\n}\n\nexport interface IProgramExtraData\n{\n    transformFeedbackVaryings?: {\n        names: string[],\n        bufferMode: 'separate' | 'interleaved'\n    }\n}\n\n/**\n * Helper class to create a shader program.\n * @memberof PIXI\n */\nexport class Program\n{\n    /**\n     * Default specify float precision in vertex shader.\n     * @static\n     * @type {PIXI.PRECISION}\n     * @default PIXI.PRECISION.HIGH\n     */\n    public static defaultVertexPrecision: PRECISION = PRECISION.HIGH;\n\n    /**\n     * Default specify float precision in fragment shader.\n     * iOS is best set at highp due to https://github.com/pixijs/pixijs/issues/3742\n     * @static\n     * @type {PIXI.PRECISION}\n     * @default PIXI.PRECISION.MEDIUM\n     */\n    public static defaultFragmentPrecision: PRECISION = isMobile.apple.device\n        ? PRECISION.HIGH\n        : PRECISION.MEDIUM;\n\n    public id: number;\n\n    /** Source code for the vertex shader. */\n    public vertexSrc: string;\n\n    /** Source code for the fragment shader. */\n    public fragmentSrc: string;\n\n    nameCache: any;\n    glPrograms: { [ key: number ]: GLProgram};\n    syncUniforms: any;\n\n    /** Assigned when a program is first bound to the shader system. */\n    attributeData: { [key: string]: IAttributeData};\n\n    /** Assigned when a program is first bound to the shader system. */\n    uniformData: {[key: string]: IUniformData};\n\n    extra: IProgramExtraData = {};\n\n    /**\n     * @param vertexSrc - The source of the vertex shader.\n     * @param fragmentSrc - The source of the fragment shader.\n     * @param name - Name for shader\n     * @param extra - Extra data for shader\n     */\n    constructor(vertexSrc?: string, fragmentSrc?: string, name = 'pixi-shader', extra: IProgramExtraData = {})\n    {\n        this.id = UID++;\n        this.vertexSrc = vertexSrc || Program.defaultVertexSrc;\n        this.fragmentSrc = fragmentSrc || Program.defaultFragmentSrc;\n\n        this.vertexSrc = this.vertexSrc.trim();\n        this.fragmentSrc = this.fragmentSrc.trim();\n\n        this.extra = extra;\n\n        if (this.vertexSrc.substring(0, 8) !== '#version')\n        {\n            name = name.replace(/\\s+/g, '-');\n\n            if (nameCache[name])\n            {\n                nameCache[name]++;\n                name += `-${nameCache[name]}`;\n            }\n            else\n            {\n                nameCache[name] = 1;\n            }\n\n            this.vertexSrc = `#define SHADER_NAME ${name}\\n${this.vertexSrc}`;\n            this.fragmentSrc = `#define SHADER_NAME ${name}\\n${this.fragmentSrc}`;\n\n            this.vertexSrc = setPrecision(\n                this.vertexSrc,\n                Program.defaultVertexPrecision,\n                PRECISION.HIGH\n            );\n            this.fragmentSrc = setPrecision(\n                this.fragmentSrc,\n                Program.defaultFragmentPrecision,\n                getMaxFragmentPrecision()\n            );\n        }\n\n        // currently this does not extract structs only default types\n        // this is where we store shader references..\n        this.glPrograms = {};\n\n        this.syncUniforms = null;\n    }\n\n    /**\n     * The default vertex shader source.\n     * @readonly\n     */\n    static get defaultVertexSrc(): string\n    {\n        return defaultVertex;\n    }\n\n    /**\n     * The default fragment shader source.\n     * @readonly\n     */\n    static get defaultFragmentSrc(): string\n    {\n        return defaultFragment;\n    }\n\n    /**\n     * A short hand function to create a program based of a vertex and fragment shader.\n     *\n     * This method will also check to see if there is a cached program.\n     * @param vertexSrc - The source of the vertex shader.\n     * @param fragmentSrc - The source of the fragment shader.\n     * @param name - Name for shader\n     * @returns A shiny new PixiJS shader program!\n     */\n    static from(vertexSrc?: string, fragmentSrc?: string, name?: string): Program\n    {\n        const key = vertexSrc + fragmentSrc;\n\n        let program = ProgramCache[key];\n\n        if (!program)\n        {\n            ProgramCache[key] = program = new Program(vertexSrc, fragmentSrc, name);\n        }\n\n        return program;\n    }\n}\n"],"mappings":";;;;;;;AAQA,IAAIA,GAAA,GAAM;AAEV,MAAMC,SAAA,GAAuC,CAgChC;EAAAC,QAAA,GAAN,MAAMC,SAAA,CACb;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IA8CIC,YAAYC,SAAA,EAAoBC,WAAA,EAAsBC,IAAA,GAAO,eAAeC,KAAA,GAA2B,IACvG;MATA,KAAAA,KAAA,GAA2B,IAUlB,KAAAC,EAAA,GAAKT,GAAA,IACV,KAAKK,SAAA,GAAYA,SAAA,IAAaF,SAAA,CAAQO,gBAAA,EACtC,KAAKJ,WAAA,GAAcA,WAAA,IAAeH,SAAA,CAAQQ,kBAAA,EAE1C,KAAKN,SAAA,GAAY,KAAKA,SAAA,CAAUO,IAAA,IAChC,KAAKN,WAAA,GAAc,KAAKA,WAAA,CAAYM,IAAA,IAEpC,KAAKJ,KAAA,GAAQA,KAAA,EAET,KAAKH,SAAA,CAAUQ,SAAA,CAAU,GAAG,CAAC,MAAM,eAEnCN,IAAA,GAAOA,IAAA,CAAKO,OAAA,CAAQ,QAAQ,GAAG,GAE3Bb,SAAA,CAAUM,IAAI,KAEdN,SAAA,CAAUM,IAAI,KACdA,IAAA,IAAQ,IAAIN,SAAA,CAAUM,IAAI,CAAC,MAI3BN,SAAA,CAAUM,IAAI,IAAI,GAGtB,KAAKF,SAAA,GAAY,uBAAuBE,IAAI;AAAA,EAAK,KAAKF,SAAS,IAC/D,KAAKC,WAAA,GAAc,uBAAuBC,IAAI;AAAA,EAAK,KAAKD,WAAW,IAEnE,KAAKD,SAAA,GAAYU,YAAA,CACb,KAAKV,SAAA,EACLF,SAAA,CAAQa,sBAAA,EACRC,SAAA,CAAUC,IAAA,GAEd,KAAKZ,WAAA,GAAcS,YAAA,CACf,KAAKT,WAAA,EACLH,SAAA,CAAQgB,wBAAA,EACRC,uBAAA,CAAwB,KAMhC,KAAKC,UAAA,GAAa,CAAC,GAEnB,KAAKC,YAAA,GAAe;IACxB;IAAA;AAAA;AAAA;AAAA;IAMA,WAAWZ,iBAAA,EACX;MACW,OAAAa,aAAA;IACX;IAAA;AAAA;AAAA;AAAA;IAMA,WAAWZ,mBAAA,EACX;MACW,OAAAa,eAAA;IACX;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAWA,OAAOC,KAAKpB,SAAA,EAAoBC,WAAA,EAAsBC,IAAA,EACtD;MACI,MAAMmB,GAAA,GAAMrB,SAAA,GAAYC,WAAA;MAEpB,IAAAqB,OAAA,GAAUC,YAAA,CAAaF,GAAG;MAEzB,OAAAC,OAAA,KAEDC,YAAA,CAAaF,GAAG,IAAIC,OAAA,GAAU,IAAIxB,SAAA,CAAQE,SAAA,EAAWC,WAAA,EAAaC,IAAI,IAGnEoB,OAAA;IACX;EACJ;AAtIazB,QAAA,CAQKc,sBAAA,GAAoCC,SAAA,CAAUC,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AARnDhB,QAAA,CAiBKiB,wBAAA,GAAsCU,QAAA,CAASC,KAAA,CAAMC,MAAA,GAC7Dd,SAAA,CAAUC,IAAA,GACVD,SAAA,CAAUe,MAAA;AAnBb,IAAMC,OAAA,GAAN/B,QAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}