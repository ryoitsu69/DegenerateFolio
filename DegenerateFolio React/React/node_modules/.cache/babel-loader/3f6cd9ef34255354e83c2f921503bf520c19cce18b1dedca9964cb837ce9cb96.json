{"ast":null,"code":"import _defineProperty from \"/home/ryoitsu/Documents/test/react-todo-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { compactFromU8aLim, compactToU8a, isString, u8aConcatStrict, u8aToU8a } from '@polkadot/util';\nimport { Raw } from '../native/Raw.js';\n/** @internal */\nfunction decodeBitVecU8a(value) {\n  if (!(value !== null && value !== void 0 && value.length)) {\n    return [0, new Uint8Array()];\n  }\n  // handle all other Uint8Array inputs, these do have a length prefix which is the number of bits encoded\n  const [offset, length] = compactFromU8aLim(value);\n  const total = offset + Math.ceil(length / 8);\n  if (total > value.length) {\n    throw new Error(\"BitVec: required length less than remainder, expected at least \".concat(total, \", found \").concat(value.length));\n  }\n  return [length, value.subarray(offset, total)];\n}\n/** @internal */\nfunction decodeBitVec(value) {\n  if (Array.isArray(value) || isString(value)) {\n    const u8a = u8aToU8a(value);\n    return [u8a.length / 8, u8a];\n  }\n  return decodeBitVecU8a(value);\n}\n/**\n * @name BitVec\n * @description\n * A BitVec that represents an array of bits. The bits are however stored encoded. The difference between this\n * and a normal Bytes would be that the length prefix indicates the number of bits encoded, not the bytes\n */\nexport class BitVec extends Raw {\n  // In lieu of having the Msb/Lsb identifiers passed through, we default to assuming\n  // we are dealing with Lsb, which is the default (as of writing) BitVec format used\n  // in the Polkadot code (this only affects the toHuman displays)\n  constructor(registry, value) {\n    let isMsb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const [decodedLength, u8a] = decodeBitVec(value);\n    super(registry, u8a);\n    _defineProperty(this, \"__internal__decodedLength\", void 0);\n    _defineProperty(this, \"__internal__isMsb\", void 0);\n    this.__internal__decodedLength = decodedLength;\n    this.__internal__isMsb = isMsb;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    return this.length + compactToU8a(this.__internal__decodedLength).length;\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return {\n      outer: [compactToU8a(this.__internal__decodedLength), super.toU8a()]\n    };\n  }\n  /**\n   * @description Creates a boolean array of the bit values\n   */\n  toBoolArray() {\n    const map = [...this.toU8a(true)].map(v => [!!(v & 128), !!(v & 64), !!(v & 32), !!(v & 16), !!(v & 8), !!(v & 4), !!(v & 2), !!(v & 1)]);\n    const count = map.length;\n    const result = new Array(8 * count);\n    for (let i = 0; i < count; i++) {\n      const off = i * 8;\n      const v = map[i];\n      for (let j = 0; j < 8; j++) {\n        result[off + j] = this.__internal__isMsb ? v[j] : v[7 - j];\n      }\n    }\n    return result;\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman() {\n    return \"0b\".concat([...this.toU8a(true)].map(d => \"00000000\".concat(d.toString(2)).slice(-8)).map(s => this.__internal__isMsb ? s : s.split('').reverse().join('')).join('_'));\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'BitVec';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    const bitVec = super.toU8a(isBare);\n    return isBare ? bitVec : u8aConcatStrict([compactToU8a(this.__internal__decodedLength), bitVec]);\n  }\n}","map":{"version":3,"names":["compactFromU8aLim","compactToU8a","isString","u8aConcatStrict","u8aToU8a","Raw","decodeBitVecU8a","value","length","Uint8Array","offset","total","Math","ceil","Error","concat","subarray","decodeBitVec","Array","isArray","u8a","BitVec","constructor","registry","isMsb","arguments","undefined","decodedLength","_defineProperty","__internal__decodedLength","__internal__isMsb","encodedLength","inspect","outer","toU8a","toBoolArray","map","v","count","result","i","off","j","toHuman","d","toString","slice","s","split","reverse","join","toRawType","isBare","bitVec"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/extended/BitVec.js"],"sourcesContent":["import { compactFromU8aLim, compactToU8a, isString, u8aConcatStrict, u8aToU8a } from '@polkadot/util';\nimport { Raw } from '../native/Raw.js';\n/** @internal */\nfunction decodeBitVecU8a(value) {\n    if (!value?.length) {\n        return [0, new Uint8Array()];\n    }\n    // handle all other Uint8Array inputs, these do have a length prefix which is the number of bits encoded\n    const [offset, length] = compactFromU8aLim(value);\n    const total = offset + Math.ceil(length / 8);\n    if (total > value.length) {\n        throw new Error(`BitVec: required length less than remainder, expected at least ${total}, found ${value.length}`);\n    }\n    return [length, value.subarray(offset, total)];\n}\n/** @internal */\nfunction decodeBitVec(value) {\n    if (Array.isArray(value) || isString(value)) {\n        const u8a = u8aToU8a(value);\n        return [u8a.length / 8, u8a];\n    }\n    return decodeBitVecU8a(value);\n}\n/**\n * @name BitVec\n * @description\n * A BitVec that represents an array of bits. The bits are however stored encoded. The difference between this\n * and a normal Bytes would be that the length prefix indicates the number of bits encoded, not the bytes\n */\nexport class BitVec extends Raw {\n    __internal__decodedLength;\n    __internal__isMsb;\n    // In lieu of having the Msb/Lsb identifiers passed through, we default to assuming\n    // we are dealing with Lsb, which is the default (as of writing) BitVec format used\n    // in the Polkadot code (this only affects the toHuman displays)\n    constructor(registry, value, isMsb = false) {\n        const [decodedLength, u8a] = decodeBitVec(value);\n        super(registry, u8a);\n        this.__internal__decodedLength = decodedLength;\n        this.__internal__isMsb = isMsb;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return this.length + compactToU8a(this.__internal__decodedLength).length;\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            outer: [compactToU8a(this.__internal__decodedLength), super.toU8a()]\n        };\n    }\n    /**\n     * @description Creates a boolean array of the bit values\n     */\n    toBoolArray() {\n        const map = [...this.toU8a(true)].map((v) => [\n            !!(v & 128),\n            !!(v & 64),\n            !!(v & 32),\n            !!(v & 16),\n            !!(v & 8),\n            !!(v & 4),\n            !!(v & 2),\n            !!(v & 1)\n        ]);\n        const count = map.length;\n        const result = new Array(8 * count);\n        for (let i = 0; i < count; i++) {\n            const off = i * 8;\n            const v = map[i];\n            for (let j = 0; j < 8; j++) {\n                result[off + j] = this.__internal__isMsb\n                    ? v[j]\n                    : v[7 - j];\n            }\n        }\n        return result;\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman() {\n        return `0b${[...this.toU8a(true)]\n            .map((d) => `00000000${d.toString(2)}`.slice(-8))\n            .map((s) => this.__internal__isMsb ? s : s.split('').reverse().join(''))\n            .join('_')}`;\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'BitVec';\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        const bitVec = super.toU8a(isBare);\n        return isBare\n            ? bitVec\n            : u8aConcatStrict([compactToU8a(this.__internal__decodedLength), bitVec]);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}