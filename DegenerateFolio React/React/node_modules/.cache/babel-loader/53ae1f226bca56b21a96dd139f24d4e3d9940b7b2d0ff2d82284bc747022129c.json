{"ast":null,"code":"import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { updateQuadBounds } from '../../../utils/data/updateQuadBounds.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { BatchableSprite } from '../../sprite/BatchableSprite.mjs';\n\"use strict\";\nclass CanvasTextPipe {\n  constructor(renderer) {\n    this._gpuText = /* @__PURE__ */Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const newKey = text._getKey();\n    if (gpuText.currentKey !== newKey) {\n      const resolution = text.resolution ?? this._renderer.resolution;\n      const {\n        width,\n        height\n      } = this._renderer.canvasText.getTextureSize(text.text, resolution, text._style);\n      if (\n      // is only being used by this text:\n      this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1 && width === gpuText.texture._source.width && height === gpuText.texture._source.height) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n  addRenderable(text, _instructionSet) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (text._didTextUpdate) {\n      this._updateText(text);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n  }\n  updateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (text._didTextUpdate) {\n      this._updateText(text);\n    }\n    batchableSprite.batcher.updateElement(batchableSprite);\n  }\n  destroyRenderable(text) {\n    this._destroyRenderableById(text.uid);\n  }\n  _destroyRenderableById(textUid) {\n    const gpuText = this._gpuText[textUid];\n    this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n    BigPool.return(gpuText.batchableSprite);\n    this._gpuText[textUid] = null;\n  }\n  _updateText(text) {\n    const newKey = text._getKey();\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.currentKey !== newKey) {\n      this._updateGpuText(text);\n    }\n    text._didTextUpdate = false;\n    const padding = text._style.padding;\n    updateQuadBounds(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n  }\n  _updateGpuText(text) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.texture) {\n      this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n    }\n    gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text);\n    gpuText.currentKey = text._getKey();\n    batchableSprite.texture = gpuText.texture;\n  }\n  _getGpuText(text) {\n    return this._gpuText[text.uid] || this.initGpuText(text);\n  }\n  initGpuText(text) {\n    const gpuTextData = {\n      texture: null,\n      currentKey: \"--\",\n      batchableSprite: BigPool.get(BatchableSprite)\n    };\n    gpuTextData.batchableSprite.renderable = text;\n    gpuTextData.batchableSprite.bounds = {\n      minX: 0,\n      maxX: 1,\n      minY: 0,\n      maxY: 0\n    };\n    gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | text._roundPixels;\n    this._gpuText[text.uid] = gpuTextData;\n    this._updateText(text);\n    text.on(\"destroyed\", () => {\n      this.destroyRenderable(text);\n    });\n    return gpuTextData;\n  }\n  destroy() {\n    for (const i in this._gpuText) {\n      this._destroyRenderableById(i);\n    }\n    this._gpuText = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nCanvasTextPipe.extension = {\n  type: [ExtensionType.WebGLPipes, ExtensionType.WebGPUPipes, ExtensionType.CanvasPipes],\n  name: \"text\"\n};\nexport { CanvasTextPipe };","map":{"version":3,"names":["CanvasTextPipe","constructor","renderer","_gpuText","Object","create","_renderer","validateRenderable","text","gpuText","_getGpuText","newKey","_getKey","currentKey","resolution","width","height","canvasText","getTextureSize","_style","getReferenceCount","texture","_source","addRenderable","_instructionSet","batchableSprite","_didTextUpdate","_updateText","renderPipes","batch","addToBatch","updateRenderable","batcher","updateElement","destroyRenderable","_destroyRenderableById","uid","textUid","decreaseReferenceCount","BigPool","return","_updateGpuText","padding","updateQuadBounds","bounds","_anchor","getManagedTexture","initGpuText","gpuTextData","get","BatchableSprite","renderable","minX","maxX","minY","maxY","roundPixels","_roundPixels","on","destroy","i","extension","type","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","name"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/text/canvas/CanvasTextPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../../sprite/BatchableSprite';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        const gpuText = this._getGpuText(text);\n\n        const newKey = text._getKey();\n\n        if (gpuText.currentKey !== newKey)\n        {\n            const resolution = text.resolution ?? this._renderer.resolution;\n\n            const { width, height } = this._renderer.canvasText.getTextureSize(\n                text.text,\n                resolution,\n                text._style,\n            );\n\n            if (\n                // is only being used by this text:\n                this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1\n                // check the size of the text is the same po2\n                && width === gpuText.texture._source.width\n                && height === gpuText.texture._source.height\n            )\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(text: Text, _instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(text);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(text: Text)\n    {\n        this._destroyRenderableById(text.uid);\n    }\n\n    private _destroyRenderableById(textUid: number)\n    {\n        const gpuText = this._gpuText[textUid];\n\n        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[textUid] = null;\n    }\n\n    private _updateText(text: Text)\n    {\n        const newKey = text._getKey();\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(text);\n        }\n\n        text._didTextUpdate = false;\n\n        const padding = text._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.texture)\n        {\n            this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n        }\n\n        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text);\n\n        gpuText.currentKey = text._getKey();\n        batchableSprite.texture = gpuText.texture;\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return this._gpuText[text.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const gpuTextData: CanvasTextPipe['_gpuText'][number] = {\n            texture: null,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n        };\n\n        gpuTextData.batchableSprite.renderable = text;\n        gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        gpuTextData.batchableSprite.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        this._gpuText[text.uid] = gpuTextData;\n\n        this._updateText(text);\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        text.on('destroyed', () =>\n        {\n            this.destroyRenderable(text);\n        });\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}