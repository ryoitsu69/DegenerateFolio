{"ast":null,"code":"import { extensions, ExtensionType } from '../extensions/Extensions.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\nimport { BackgroundLoader } from './BackgroundLoader.mjs';\nimport { Cache } from './cache/Cache.mjs';\nimport { cacheTextureArray } from './cache/parsers/cacheTextureArray.mjs';\nimport { detectAvif } from './detections/parsers/detectAvif.mjs';\nimport { detectDefaults } from './detections/parsers/detectDefaults.mjs';\nimport { detectMp4 } from './detections/parsers/detectMp4.mjs';\nimport { detectOgv } from './detections/parsers/detectOgv.mjs';\nimport { detectWebm } from './detections/parsers/detectWebm.mjs';\nimport { detectWebp } from './detections/parsers/detectWebp.mjs';\nimport { Loader } from './loader/Loader.mjs';\nimport { loadJson } from './loader/parsers/loadJson.mjs';\nimport { loadTxt } from './loader/parsers/loadTxt.mjs';\nimport { loadWebFont } from './loader/parsers/loadWebFont.mjs';\nimport { loadSvg } from './loader/parsers/textures/loadSVG.mjs';\nimport { loadTextures } from './loader/parsers/textures/loadTextures.mjs';\nimport { loadVideoTextures } from './loader/parsers/textures/loadVideoTextures.mjs';\nimport { resolveJsonUrl } from './resolver/parsers/resolveJsonUrl.mjs';\nimport { resolveTextureUrl } from './resolver/parsers/resolveTextureUrl.mjs';\nimport { Resolver } from './resolver/Resolver.mjs';\nimport { convertToList } from './utils/convertToList.mjs';\nimport { isSingleItem } from './utils/isSingleItem.mjs';\n\"use strict\";\nclass AssetsClass {\n  constructor() {\n    this._detections = [];\n    this._initialized = false;\n    this.resolver = new Resolver();\n    this.loader = new Loader();\n    this.cache = Cache;\n    this._backgroundLoader = new BackgroundLoader(this.loader);\n    this._backgroundLoader.active = true;\n    this.reset();\n  }\n  /**\n   * Best practice is to call this function before any loading commences\n   * Initiating is the best time to add any customization to the way things are loaded.\n   *\n   * you do not need to call this for the Assets class to work, only if you want to set any initial properties\n   * @param options - options to initialize the Assets manager with\n   */\n  async init(options = {}) {\n    if (this._initialized) {\n      warn(\"[Assets]AssetManager already initialized, did you load before calling this Assets.init()?\");\n      return;\n    }\n    this._initialized = true;\n    if (options.defaultSearchParams) {\n      this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n    }\n    if (options.basePath) {\n      this.resolver.basePath = options.basePath;\n    }\n    if (options.bundleIdentifier) {\n      this.resolver.setBundleIdentifier(options.bundleIdentifier);\n    }\n    if (options.manifest) {\n      let manifest = options.manifest;\n      if (typeof manifest === \"string\") {\n        manifest = await this.load(manifest);\n      }\n      this.resolver.addManifest(manifest);\n    }\n    const resolutionPref = options.texturePreference?.resolution ?? 1;\n    const resolution = typeof resolutionPref === \"number\" ? [resolutionPref] : resolutionPref;\n    const formats = await this._detectFormats({\n      preferredFormats: options.texturePreference?.format,\n      skipDetections: options.skipDetections,\n      detections: this._detections\n    });\n    this.resolver.prefer({\n      params: {\n        format: formats,\n        resolution\n      }\n    });\n    if (options.preferences) {\n      this.setPreferences(options.preferences);\n    }\n  }\n  /**\n   * Allows you to specify how to resolve any assets load requests.\n   * There are a few ways to add things here as shown below:\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Simple\n   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});\n   * const bunny = await Assets.load('bunnyBooBoo');\n   *\n   * // Multiple keys:\n   * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});\n   *\n   * const bunny = await Assets.load('burger');\n   * const bunny2 = await Assets.load('chicken');\n   *\n   * // passing options to to the object\n   * Assets.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * // Multiple assets\n   *\n   * // The following all do the same thing:\n   *\n   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny{png,webp}'});\n   *\n   * Assets.add({\n   *     alias: 'bunnyBooBoo',\n   *     src: [\n   *         'bunny.png',\n   *         'bunny.webp',\n   *    ],\n   * });\n   *\n   * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available\n   * @param assets - the unresolved assets to add to the resolver\n   */\n  add(assets) {\n    this.resolver.add(assets);\n  }\n  async load(urls, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const singleAsset = isSingleItem(urls);\n    const urlArray = convertToList(urls).map(url => {\n      if (typeof url !== \"string\") {\n        const aliases = this.resolver.getAlias(url);\n        if (aliases.some(alias => !this.resolver.hasKey(alias))) {\n          this.add(url);\n        }\n        return Array.isArray(aliases) ? aliases[0] : aliases;\n      }\n      if (!this.resolver.hasKey(url)) this.add({\n        alias: url,\n        src: url\n      });\n      return url;\n    });\n    const resolveResults = this.resolver.resolve(urlArray);\n    const out = await this._mapLoadToResolve(resolveResults, onProgress);\n    return singleAsset ? out[urlArray[0]] : out;\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can load them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * Assets.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const assets = await Assets.loadBundle('animals');\n   * @param bundleId - the id of the bundle to add\n   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    this.resolver.addBundle(bundleId, assets);\n  }\n  /**\n   * Bundles are a way to load multiple assets at once.\n   * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n   * you can also add bundles via `addBundle`\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * await Assets.init({ manifest });\n   *\n   * // Load a bundle...\n   * loadScreenAssets = await Assets.loadBundle('load-screen');\n   * // Load another bundle...\n   * gameScreenAssets = await Assets.loadBundle('game-screen');\n   * @param bundleIds - the bundle id or ids to load\n   * @param onProgress - Optional function that is called when progress on asset loading is made.\n   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n   * of the assets loaded. Do not use this function to detect when assets are complete and available,\n   * instead use the Promise returned by this function.\n   * @returns all the bundles assets or a hash of assets for each bundle specified\n   */\n  async loadBundle(bundleIds, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    let singleAsset = false;\n    if (typeof bundleIds === \"string\") {\n      singleAsset = true;\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const out = {};\n    const keys = Object.keys(resolveResults);\n    let count = 0;\n    let total = 0;\n    const _onProgress = () => {\n      onProgress?.(++count / total);\n    };\n    const promises = keys.map(bundleId => {\n      const resolveResult = resolveResults[bundleId];\n      total += Object.keys(resolveResult).length;\n      return this._mapLoadToResolve(resolveResult, _onProgress).then(resolveResult2 => {\n        out[bundleId] = resolveResult2;\n      });\n    });\n    await Promise.all(promises);\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n   *\n   * An example of this might be that you would background load game assets after your inital load.\n   * then when you got to actually load your game screen assets when a player goes to the game - the loading\n   * would already have stared or may even be complete, saving you having to show an interim load bar.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.backgroundLoad('bunny.png');\n   *\n   * // later on in your app...\n   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!\n   * @param urls - the url / urls you want to background load\n   */\n  async backgroundLoad(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof urls === \"string\") {\n      urls = [urls];\n    }\n    const resolveResults = this.resolver.resolve(urls);\n    this._backgroundLoader.add(Object.values(resolveResults));\n  }\n  /**\n   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n   * this can only be used if the loader has been initiated with a manifest\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * await Assets.init({\n   *     manifest: {\n   *         bundles: [\n   *             {\n   *                 name: 'load-screen',\n   *                 assets: [...],\n   *             },\n   *             ...\n   *         ],\n   *     },\n   * });\n   *\n   * Assets.backgroundLoadBundle('load-screen');\n   *\n   * // Later on in your app...\n   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!\n   * @param bundleIds - the bundleId / bundleIds you want to background load\n   */\n  async backgroundLoadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof bundleIds === \"string\") {\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    Object.values(resolveResults).forEach(resolveResult => {\n      this._backgroundLoader.add(Object.values(resolveResult));\n    });\n  }\n  /**\n   * Only intended for development purposes.\n   * This will wipe the resolver and caches.\n   * You will need to reinitialize the Asset\n   */\n  reset() {\n    this.resolver.reset();\n    this.loader.reset();\n    this.cache.reset();\n    this._initialized = false;\n  }\n  get(keys) {\n    if (typeof keys === \"string\") {\n      return Cache.get(keys);\n    }\n    const assets = {};\n    for (let i = 0; i < keys.length; i++) {\n      assets[i] = Cache.get(keys[i]);\n    }\n    return assets;\n  }\n  /**\n   * helper function to map resolved assets back to loaded assets\n   * @param resolveResults - the resolve results from the resolver\n   * @param onProgress - the progress callback\n   */\n  async _mapLoadToResolve(resolveResults, onProgress) {\n    const resolveArray = [...new Set(Object.values(resolveResults))];\n    this._backgroundLoader.active = false;\n    const loadedAssets = await this.loader.load(resolveArray, onProgress);\n    this._backgroundLoader.active = true;\n    const out = {};\n    resolveArray.forEach(resolveResult => {\n      const asset = loadedAssets[resolveResult.src];\n      const keys = [resolveResult.src];\n      if (resolveResult.alias) {\n        keys.push(...resolveResult.alias);\n      }\n      keys.forEach(key => {\n        out[key] = asset;\n      });\n      Cache.set(keys, asset);\n    });\n    return out;\n  }\n  /**\n   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n   * this will make sure to destroy any assets and release them from memory.\n   * Once unloaded, you will need to load the asset again.\n   *\n   * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n   *\n   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n   * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Load a URL:\n   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n   *\n   * await Assets.unload('http://some.url.com/image.png')\n   *\n   * // myImageTexture will be destroyed now.\n   *\n   * // Unload multiple assets:\n   * const textures = await Assets.unload(['thumper', 'chicko']);\n   * @param urls - the urls to unload\n   */\n  async unload(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const urlArray = convertToList(urls).map(url => typeof url !== \"string\" ? url.src : url);\n    const resolveResults = this.resolver.resolve(urlArray);\n    await this._unloadFromResolved(resolveResults);\n  }\n  /**\n   * Bundles are a way to manage multiple assets at once.\n   * this will unload all files in a bundle.\n   *\n   * once a bundle has been unloaded, you need to load it again to have access to the assets.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle({\n   *     'thumper': 'http://some.url.com/thumper.png',\n   * })\n   *\n   * const assets = await Assets.loadBundle('thumper');\n   *\n   * // Now to unload...\n   *\n   * await Assets.unloadBundle('thumper');\n   *\n   * // All assets in the assets object will now have been destroyed and purged from the cache\n   * @param bundleIds - the bundle id or ids to unload\n   */\n  async unloadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    bundleIds = convertToList(bundleIds);\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const promises = Object.keys(resolveResults).map(bundleId => this._unloadFromResolved(resolveResults[bundleId]));\n    await Promise.all(promises);\n  }\n  async _unloadFromResolved(resolveResult) {\n    const resolveArray = Object.values(resolveResult);\n    resolveArray.forEach(resolveResult2 => {\n      Cache.remove(resolveResult2.src);\n    });\n    await this.loader.unload(resolveArray);\n  }\n  /**\n   * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n   * the users preferred formats order.\n   * @param options - the options to use when detecting formats\n   * @param options.preferredFormats - the preferred formats to use\n   * @param options.skipDetections - if we should skip the detections altogether\n   * @param options.detections - the detections to use\n   * @returns - the detected formats\n   */\n  async _detectFormats(options) {\n    let formats = [];\n    if (options.preferredFormats) {\n      formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];\n    }\n    for (const detection of options.detections) {\n      if (options.skipDetections || (await detection.test())) {\n        formats = await detection.add(formats);\n      } else if (!options.skipDetections) {\n        formats = await detection.remove(formats);\n      }\n    }\n    formats = formats.filter((format, index) => formats.indexOf(format) === index);\n    return formats;\n  }\n  /** All the detection parsers currently added to the Assets class. */\n  get detections() {\n    return this._detections;\n  }\n  /**\n   * General setter for preferences. This is a helper function to set preferences on all parsers.\n   * @param preferences - the preferences to set\n   */\n  setPreferences(preferences) {\n    this.loader.parsers.forEach(parser => {\n      if (!parser.config) return;\n      Object.keys(parser.config).filter(key => key in preferences).forEach(key => {\n        parser.config[key] = preferences[key];\n      });\n    });\n  }\n}\nconst Assets = new AssetsClass();\nextensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);\nextensions.add(cacheTextureArray, detectDefaults, detectAvif, detectWebp, detectMp4, detectOgv, detectWebm, loadJson, loadTxt, loadWebFont, loadSvg, loadTextures, loadVideoTextures, resolveTextureUrl, resolveJsonUrl);\nconst assetKeyMap = {\n  loader: ExtensionType.LoadParser,\n  resolver: ExtensionType.ResolveParser,\n  cache: ExtensionType.CacheParser,\n  detection: ExtensionType.DetectionParser\n};\nextensions.handle(ExtensionType.Asset, extension => {\n  const ref = extension.ref;\n  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions.add(Object.assign(ref[key],\n  // Allow the function to optionally define it's own\n  // ExtensionMetadata, the use cases here is priority for LoaderParsers\n  {\n    extension: ref[key].extension ?? type\n  })));\n}, extension => {\n  const ref = extension.ref;\n  Object.keys(assetKeyMap).filter(key => !!ref[key]).forEach(key => extensions.remove(ref[key]));\n});\nexport { Assets, AssetsClass };","map":{"version":3,"names":["AssetsClass","constructor","_detections","_initialized","resolver","Resolver","loader","Loader","cache","Cache","_backgroundLoader","BackgroundLoader","active","reset","init","options","warn","defaultSearchParams","setDefaultSearchParams","basePath","bundleIdentifier","setBundleIdentifier","manifest","load","addManifest","resolutionPref","texturePreference","resolution","formats","_detectFormats","preferredFormats","format","skipDetections","detections","prefer","params","preferences","setPreferences","add","assets","urls","onProgress","singleAsset","isSingleItem","urlArray","convertToList","map","url","aliases","getAlias","some","alias","hasKey","Array","isArray","src","resolveResults","resolve","out","_mapLoadToResolve","addBundle","bundleId","loadBundle","bundleIds","resolveBundle","keys","Object","count","total","_onProgress","promises","resolveResult","length","then","resolveResult2","Promise","all","backgroundLoad","values","backgroundLoadBundle","forEach","get","i","resolveArray","Set","loadedAssets","asset","push","key","set","unload","_unloadFromResolved","unloadBundle","remove","detection","test","filter","index","indexOf","parsers","parser","config","Assets","extensions","handleByList","ExtensionType","LoadParser","ResolveParser","CacheParser","DetectionParser","cacheTextureArray","detectDefaults","detectAvif","detectWebp","detectMp4","detectOgv","detectWebm","loadJson","loadTxt","loadWebFont","loadSvg","loadTextures","loadVideoTextures","resolveTextureUrl","resolveJsonUrl","assetKeyMap","handle","Asset","extension","ref","entries","type","assign"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/assets/Assets.ts"],"sourcesContent":["/* eslint-disable max-len */\nimport { extensions, ExtensionType } from '../extensions/Extensions';\nimport { warn } from '../utils/logging/warn';\nimport { BackgroundLoader } from './BackgroundLoader';\nimport { Cache } from './cache/Cache';\nimport { cacheTextureArray } from './cache/parsers/cacheTextureArray';\nimport { detectAvif } from './detections/parsers/detectAvif';\nimport { detectDefaults } from './detections/parsers/detectDefaults';\nimport { detectMp4 } from './detections/parsers/detectMp4';\nimport { detectOgv } from './detections/parsers/detectOgv';\nimport { detectWebm } from './detections/parsers/detectWebm';\nimport { detectWebp } from './detections/parsers/detectWebp';\nimport { Loader } from './loader/Loader';\nimport { loadJson } from './loader/parsers/loadJson';\nimport { loadTxt } from './loader/parsers/loadTxt';\nimport { loadWebFont } from './loader/parsers/loadWebFont';\nimport { loadSvg } from './loader/parsers/textures/loadSVG';\nimport { type LoadTextureConfig, loadTextures } from './loader/parsers/textures/loadTextures';\nimport { loadVideoTextures } from './loader/parsers/textures/loadVideoTextures';\nimport { resolveJsonUrl } from './resolver/parsers/resolveJsonUrl';\nimport { resolveTextureUrl } from './resolver/parsers/resolveTextureUrl';\nimport { Resolver } from './resolver/Resolver';\nimport { convertToList } from './utils/convertToList';\nimport { isSingleItem } from './utils/isSingleItem';\n\nimport type { AssetExtension } from './AssetExtension';\nimport type { FormatDetectionParser } from './detections/types';\nimport type { LoadSVGConfig } from './loader/parsers/textures/loadSVG';\nimport type { BundleIdentifierOptions } from './resolver/Resolver';\nimport type { ArrayOr, AssetsBundle, AssetsManifest, ResolvedAsset, UnresolvedAsset } from './types';\n\n/**\n * Callback for when progress on asset loading is made.\n * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n * of the assets loaded.\n * @memberof assets\n * @callback ProgressCallback\n * @param {number} progress - The percentage (0.0 - 1.0) of the assets loaded.\n * @returns {void}\n * @example\n * (progress) => console.log(progress * 100 + '%')\n */\nexport type ProgressCallback = (progress: number) => void;\n\n/**\n * Extensible preferences that can be used, for instance, when configuring loaders.\n * @since 7.2.0\n * @memberof assets\n */\nexport interface AssetsPreferences extends LoadTextureConfig, LoadSVGConfig, PixiMixins.AssetsPreferences {}\n\n/**\n * Initialization options object for the Assets Class.\n * @memberof assets\n */\nexport interface AssetInitOptions\n{\n    // basic...\n    /** a base path for any assets loaded */\n    basePath?: string;\n\n    /** a default URL parameter string to append to all assets loaded */\n    defaultSearchParams?: string | Record<string, any>;\n\n    /**\n     * a manifest to tell the asset loader upfront what all your assets are\n     * this can be the manifest object itself, or a URL to the manifest.\n     */\n    manifest?: string | AssetsManifest;\n    /**\n     * optional preferences for which textures preferences you have when resolving assets\n     * for example you might set the resolution to 0.5 if the user is on a rubbish old phone\n     * or you might set the resolution to 2 if the user is on a retina display\n     */\n    texturePreference?: {\n        /** the resolution order you prefer, can be an array (priority order - first is prefered) or a single resolutions  */\n        resolution?: number | number[];\n        /**\n         * the formats you prefer, by default this will be:\n         * ['avif', 'webp', 'png', 'jpg', 'jpeg', 'webm', 'mp4', 'm4v', 'ogv']\n         */\n        format?: ArrayOr<string>;\n    };\n\n    /**\n     * If true, don't attempt to detect whether browser has preferred formats available.\n     * May result in increased performance as it skips detection step.\n     */\n    skipDetections?: boolean;\n\n    /** advanced - override how bundlesIds are generated */\n    bundleIdentifier?: BundleIdentifierOptions;\n\n    /** Optional loader preferences */\n    preferences?: Partial<AssetsPreferences>;\n}\n\n/**\n * A one stop shop for all Pixi resource management!\n * Super modern and easy to use, with enough flexibility to customize and do what you need!\n * @namespace assets\n *\n * Use the singleton class [Assets]{@link assets.Assets} to easily load and manage all your assets.\n *\n * ```typescript\n * import { Assets, Texture } from 'pixi.js';\n *\n * const bunnyTexture = await Assets.load<Texture>('bunny.png');\n * const sprite = new Sprite(bunnyTexture);\n * ```\n *\n * Check out the sections below for more information on how to deal with assets.\n *\n * <details id=\"assets-loading\">\n *\n * <summary>Asset Loading</summary>\n *\n * Do not be afraid to load things multiple times - under the hood, it will **NEVER** load anything more than once.\n *\n * *For example:*\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * promise1 = Assets.load('bunny.png')\n * promise2 = Assets.load('bunny.png')\n *\n * // promise1 === promise2\n * ```\n *\n * Here both promises will be the same. Once resolved... Forever resolved! It makes for really easy resource management!\n *\n * Out of the box Pixi supports the following files:\n * - Textures (**_avif_**, **_webp_**, **_png_**, **_jpg_**, **_gif_**, **_svg_**) via {@link assets.loadTextures}, {@link assets.loadSvg}\n * - Video Textures (**_mp4_**, **_m4v_**, **_webm_**, **_ogg_**, **_ogv_**, **_h264_**, **_avi_**, **_mov_**) via {@link assets.loadVideoTextures}\n * - Sprite sheets (**_json_**) via {@link assets.spritesheetAsset}\n * - Bitmap fonts (**_xml_**, **_fnt_**, **_txt_**) via {@link assets.loadBitmapFont}\n * - Web fonts (**_ttf_**, **_woff_**, **_woff2_**) via {@link assets.loadWebFont}\n * - JSON files (**_json_**) via {@link assets.loadJson}\n * - Text Files (**_txt_**) via {@link assets.loadTxt}\n * <br/>\n * More types can be added fairly easily by creating additional {@link assets.LoaderParser LoaderParsers}.\n * </details>\n *\n * <details id=\"textures\">\n *\n * <summary>Textures</summary>\n *\n * - Textures are loaded as ImageBitmap on a worker thread where possible. Leading to much less janky load + parse times.\n * - By default, we will prefer to load AVIF and WebP image files if you specify them.\n * But if the browser doesn't support AVIF or WebP we will fall back to png and jpg.\n * - Textures can also be accessed via `Texture.from()` (see {@link core.from|Texture.from})\n * and now use this asset manager under the hood!\n * - Don't worry if you set preferences for textures that don't exist\n * (for example you prefer 2x resolutions images but only 1x is available for that texture,\n * the Assets manager will pick that up as a fallback automatically)\n *\n * #### Sprite sheets\n * - It's hard to know what resolution a sprite sheet is without loading it first, to address this\n * there is a naming convention we have added that will let Pixi understand the image format and resolution\n * of the spritesheet via its file name: `my-spritesheet{resolution}.{imageFormat}.json`\n * <br><br>For example:\n *   - `my-spritesheet@2x.webp.json`* // 2x resolution, WebP sprite sheet*\n *   - `my-spritesheet@0.5x.png.json`* // 0.5x resolution, png sprite sheet*\n * - This is optional! You can just load a sprite sheet as normal.\n * This is only useful if you have a bunch of different res / formatted spritesheets.\n * </details>\n *\n * <details id=\"fonts\">\n *\n * <summary>Fonts</summary>\n *\n * Web fonts will be loaded with all weights.\n * It is possible to load only specific weights by doing the following:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * // Load specific weights..\n * await Assets.load({\n *     data: {\n *         weights: ['normal'], // Only loads the weight\n *     },\n *     src: `outfit.woff2`,\n * });\n *\n * // Load everything...\n * await Assets.load(`outfit.woff2`);\n * ```\n * </details>\n *\n * <details id=\"background-loading\">\n *\n * <summary>Background Loading</summary>\n *\n * Background loading will load stuff for you passively behind the scenes. To minimize jank,\n * it will only load one asset at a time. As soon as a developer calls `Assets.load(...)` the\n * background loader is paused and requested assets are loaded as a priority.\n * Don't worry if something is in there that's already loaded, it will just get skipped!\n *\n * You still need to call `Assets.load(...)` to get an asset that has been loaded in the background.\n * It's just that this promise will resolve instantly if the asset\n * has already been loaded.\n * </details>\n *\n * <details id=\"manifests-and-bundles\">\n *\n * <summary>Manifest and Bundles</summary>\n *\n * - {@link assets.AssetsManifest Manifest} is a descriptor that contains a list of all assets and their properties.\n * - {@link assets.AssetsBundle Bundles} are a way to group assets together.\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * // Manifest Example\n * const manifest = {\n *     bundles: [\n *         {\n *             name: 'load-screen',\n *             assets: [\n *                 {\n *                     alias: 'background',\n *                     src: 'sunset.png',\n *                 },\n *                 {\n *                     alias: 'bar',\n *                     src: 'load-bar.{png,webp}',\n *                 },\n *             ],\n *         },\n *         {\n *             name: 'game-screen',\n *             assets: [\n *                 {\n *                     alias: 'character',\n *                     src: 'robot.png',\n *                 },\n *                 {\n *                     alias: 'enemy',\n *                     src: 'bad-guy.png',\n *                 },\n *             ],\n *         },\n *     ]\n * };\n *\n * await Assets.init({ manifest });\n *\n * // Load a bundle...\n * loadScreenAssets = await Assets.loadBundle('load-screen');\n * // Load another bundle...\n * gameScreenAssets = await Assets.loadBundle('game-screen');\n * ```\n * </details>\n */\n\n/**\n * The global Assets class, it's a singleton so you don't need to instantiate it.\n *\n * **The `Assets` class has four main responsibilities:**\n * 1. Allows users to map URLs to keys and resolve them according to the user's browser capabilities\n * 2. Loads the resources and transforms them into assets that developers understand.\n * 3. Caches the assets and provides a way to access them.\n * 4. Allow developers to unload assets and clear the cache.\n *\n *\n * **It also has a few advanced features:**\n * 1. Allows developers to provide a {@link assets.Manifest} upfront of all assets and help manage\n * them via {@link assets.AssetsBundles Bundles}.\n * 2. Allows users to background load assets. Shortening (or eliminating) load times and improving UX. With this feature,\n * in-game loading bars can be a thing of the past!\n * @example\n * import { Assets } from 'pixi.js';\n *\n * const bunny = await Assets.load('bunny.png');\n * @memberof assets\n * @class Assets\n */\nexport class AssetsClass\n{\n    /** the resolver to map various urls */\n    public resolver: Resolver;\n    /** The loader, loads stuff! */\n    public loader: Loader;\n    /**\n     * The global cache of all assets within PixiJS\n     * @type {assets.Cache}\n     */\n    public cache: typeof Cache;\n\n    /** takes care of loading assets in the background */\n    private readonly _backgroundLoader: BackgroundLoader;\n\n    private readonly _detections: FormatDetectionParser[] = [];\n\n    private _initialized = false;\n\n    constructor()\n    {\n        this.resolver = new Resolver();\n        this.loader = new Loader();\n        this.cache = Cache;\n\n        this._backgroundLoader = new BackgroundLoader(this.loader);\n        this._backgroundLoader.active = true;\n\n        this.reset();\n    }\n\n    /**\n     * Best practice is to call this function before any loading commences\n     * Initiating is the best time to add any customization to the way things are loaded.\n     *\n     * you do not need to call this for the Assets class to work, only if you want to set any initial properties\n     * @param options - options to initialize the Assets manager with\n     */\n    public async init(options: AssetInitOptions = {}): Promise<void>\n    {\n        if (this._initialized)\n        {\n            // #if _DEBUG\n            warn('[Assets]AssetManager already initialized, did you load before calling this Assets.init()?');\n            // #endif\n\n            return;\n        }\n\n        this._initialized = true;\n\n        if (options.defaultSearchParams)\n        {\n            this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n        }\n\n        if (options.basePath)\n        {\n            this.resolver.basePath = options.basePath;\n        }\n\n        if (options.bundleIdentifier)\n        {\n            this.resolver.setBundleIdentifier(options.bundleIdentifier);\n        }\n\n        if (options.manifest)\n        {\n            let manifest = options.manifest;\n\n            if (typeof manifest === 'string')\n            {\n                manifest = await this.load<AssetsManifest>(manifest);\n            }\n\n            this.resolver.addManifest(manifest);\n        }\n\n        const resolutionPref = options.texturePreference?.resolution ?? 1;\n        const resolution = (typeof resolutionPref === 'number') ? [resolutionPref] : resolutionPref;\n\n        const formats = await this._detectFormats({\n            preferredFormats: options.texturePreference?.format,\n            skipDetections: options.skipDetections,\n            detections: this._detections\n        });\n\n        this.resolver.prefer({\n            params: {\n                format: formats,\n                resolution,\n            },\n        });\n\n        if (options.preferences)\n        {\n            this.setPreferences(options.preferences);\n        }\n    }\n\n    /**\n     * Allows you to specify how to resolve any assets load requests.\n     * There are a few ways to add things here as shown below:\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Simple\n     * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});\n     * const bunny = await Assets.load('bunnyBooBoo');\n     *\n     * // Multiple keys:\n     * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});\n     *\n     * const bunny = await Assets.load('burger');\n     * const bunny2 = await Assets.load('chicken');\n     *\n     * // passing options to to the object\n     * Assets.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny{png,webp}',\n     *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * // Multiple assets\n     *\n     * // The following all do the same thing:\n     *\n     * Assets.add({alias: 'bunnyBooBoo', src: 'bunny{png,webp}'});\n     *\n     * Assets.add({\n     *     alias: 'bunnyBooBoo',\n     *     src: [\n     *         'bunny.png',\n     *         'bunny.webp',\n     *    ],\n     * });\n     *\n     * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available\n     * @param assets - the unresolved assets to add to the resolver\n     */\n    public add(assets: (ArrayOr<UnresolvedAsset>)): void\n    {\n        this.resolver.add(assets);\n    }\n\n    /**\n     * Loads your assets! You pass in a key or URL and it will return a promise that\n     * resolves to the loaded asset. If multiple assets a requested, it will return a hash of assets.\n     *\n     * Don't worry about loading things multiple times, behind the scenes assets are only ever loaded\n     * once and the same promise reused behind the scenes so you can safely call this function multiple\n     * times with the same key and it will always return the same asset.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Load a URL:\n     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n     *\n     * Assets.add('thumper', 'bunny.png');\n     * Assets.add('chicko', 'chicken.png');\n     *\n     * // Load multiple assets:\n     * const textures = await Assets.load(['thumper', 'chicko']); // => {thumper: Texture, chicko: Texture}\n     * @param urls - the urls to load\n     * @param onProgress - optional function that is called when progress on asset loading is made.\n     * The function is passed a single parameter, `progress`, which represents the percentage\n     * (0.0 - 1.0) of the assets loaded.\n     * @returns - the assets that were loaded, either a single asset or a hash of assets\n     */\n    public async load<T = any>(\n        urls: string | UnresolvedAsset,\n        onProgress?: ProgressCallback,\n    ): Promise<T>;\n    public async load<T = any>(\n        urls: string[] | UnresolvedAsset[],\n        onProgress?: ProgressCallback,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        urls: ArrayOr<string> | ArrayOr<UnresolvedAsset>,\n        onProgress?: ProgressCallback\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const singleAsset = isSingleItem(urls);\n\n        const urlArray: string[] = convertToList<UnresolvedAsset | string>(urls)\n            .map((url) =>\n            {\n                if (typeof url !== 'string')\n                {\n                    const aliases = this.resolver.getAlias(url);\n\n                    if (aliases.some((alias) => !this.resolver.hasKey(alias)))\n                    {\n                        this.add(url);\n                    }\n\n                    return Array.isArray(aliases) ? aliases[0] : aliases;\n                }\n\n                // if it hasn't been added, add it now\n                if (!this.resolver.hasKey(url)) this.add({ alias: url, src: url });\n\n                return url;\n            }) as string[];\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        // remap to the keys used..\n        const out: Record<string, T> = await this._mapLoadToResolve<T>(resolveResults, onProgress);\n\n        return singleAsset ? out[urlArray[0] as string] : out;\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can load them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.addBundle('animals', [\n     *  { alias: 'bunny', src: 'bunny.png' },\n     *  { alias: 'chicken', src: 'chicken.png' },\n     *  { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     * // or\n     * Assets.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const assets = await Assets.loadBundle('animals');\n     * @param bundleId - the id of the bundle to add\n     * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        this.resolver.addBundle(bundleId, assets);\n    }\n\n    /**\n     * Bundles are a way to load multiple assets at once.\n     * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n     * you can also add bundles via `addBundle`\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * await Assets.init({ manifest });\n     *\n     * // Load a bundle...\n     * loadScreenAssets = await Assets.loadBundle('load-screen');\n     * // Load another bundle...\n     * gameScreenAssets = await Assets.loadBundle('game-screen');\n     * @param bundleIds - the bundle id or ids to load\n     * @param onProgress - Optional function that is called when progress on asset loading is made.\n     * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n     * of the assets loaded. Do not use this function to detect when assets are complete and available,\n     * instead use the Promise returned by this function.\n     * @returns all the bundles assets or a hash of assets for each bundle specified\n     */\n    public async loadBundle(bundleIds: ArrayOr<string>, onProgress?: ProgressCallback): Promise<any>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        let singleAsset = false;\n\n        if (typeof bundleIds === 'string')\n        {\n            singleAsset = true;\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const out: Record<string, Record<string, any>> = {};\n\n        const keys = Object.keys(resolveResults);\n        let count = 0;\n        let total = 0;\n        const _onProgress = () =>\n        {\n            onProgress?.(++count / total);\n        };\n        const promises = keys.map((bundleId) =>\n        {\n            const resolveResult = resolveResults[bundleId];\n\n            total += Object.keys(resolveResult).length;\n\n            return this._mapLoadToResolve(resolveResult, _onProgress)\n                .then((resolveResult) =>\n                {\n                    out[bundleId] = resolveResult;\n                });\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n     * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n     *\n     * An example of this might be that you would background load game assets after your inital load.\n     * then when you got to actually load your game screen assets when a player goes to the game - the loading\n     * would already have stared or may even be complete, saving you having to show an interim load bar.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.backgroundLoad('bunny.png');\n     *\n     * // later on in your app...\n     * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!\n     * @param urls - the url / urls you want to background load\n     */\n    public async backgroundLoad(urls: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof urls === 'string')\n        {\n            urls = [urls];\n        }\n\n        const resolveResults = this.resolver.resolve(urls);\n\n        this._backgroundLoader.add(Object.values(resolveResults));\n    }\n\n    /**\n     * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n     * this can only be used if the loader has been initiated with a manifest\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [\n     *             {\n     *                 name: 'load-screen',\n     *                 assets: [...],\n     *             },\n     *             ...\n     *         ],\n     *     },\n     * });\n     *\n     * Assets.backgroundLoadBundle('load-screen');\n     *\n     * // Later on in your app...\n     * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!\n     * @param bundleIds - the bundleId / bundleIds you want to background load\n     */\n    public async backgroundLoadBundle(bundleIds: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof bundleIds === 'string')\n        {\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        Object.values(resolveResults).forEach((resolveResult) =>\n        {\n            this._backgroundLoader.add(Object.values(resolveResult));\n        });\n    }\n\n    /**\n     * Only intended for development purposes.\n     * This will wipe the resolver and caches.\n     * You will need to reinitialize the Asset\n     */\n    public reset(): void\n    {\n        this.resolver.reset();\n        this.loader.reset();\n        this.cache.reset();\n\n        this._initialized = false;\n    }\n\n    /**\n     * Instantly gets an asset already loaded from the cache. If the asset has not yet been loaded,\n     * it will return undefined. So it's on you! When in doubt just use `Assets.load` instead.\n     * (Remember, the loader will never load things more than once!)\n     * @param keys - The key or keys for the assets that you want to access\n     * @returns - The assets or hash of assets requested\n     */\n    public get<T = any>(keys: string): T;\n    public get<T = any>(keys: string[]): Record<string, T>;\n    public get<T = any>(keys: ArrayOr<string>): T | Record<string, T>\n    {\n        if (typeof keys === 'string')\n        {\n            return Cache.get(keys);\n        }\n\n        const assets: Record<string, T> = {};\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            assets[i] = Cache.get(keys[i]);\n        }\n\n        return assets;\n    }\n\n    /**\n     * helper function to map resolved assets back to loaded assets\n     * @param resolveResults - the resolve results from the resolver\n     * @param onProgress - the progress callback\n     */\n    private async _mapLoadToResolve<T>(\n        resolveResults: ResolvedAsset | Record<string, ResolvedAsset>,\n        onProgress?: ProgressCallback\n    ): Promise<Record<string, T>>\n    {\n        const resolveArray = [...new Set(Object.values(resolveResults))] as ResolvedAsset[];\n\n        // pause background loader...\n        this._backgroundLoader.active = false;\n\n        const loadedAssets = await this.loader.load<T>(resolveArray, onProgress);\n\n        // resume background loader...\n        this._backgroundLoader.active = true;\n\n        // remap to the keys used..\n\n        const out: Record<string, T> = {};\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            const asset = loadedAssets[resolveResult.src];\n\n            const keys = [resolveResult.src];\n\n            if (resolveResult.alias)\n            {\n                keys.push(...resolveResult.alias);\n            }\n\n            keys.forEach((key) =>\n            {\n                out[key] = asset;\n            });\n\n            Cache.set(keys, asset);\n        });\n\n        return out;\n    }\n\n    /**\n     * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n     * this will make sure to destroy any assets and release them from memory.\n     * Once unloaded, you will need to load the asset again.\n     *\n     * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n     *\n     * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n     * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Load a URL:\n     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n     *\n     * await Assets.unload('http://some.url.com/image.png')\n     *\n     * // myImageTexture will be destroyed now.\n     *\n     * // Unload multiple assets:\n     * const textures = await Assets.unload(['thumper', 'chicko']);\n     * @param urls - the urls to unload\n     */\n    public async unload(\n        urls: ArrayOr<string> | ResolvedAsset | ResolvedAsset[]\n    ): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const urlArray = convertToList<string | ResolvedAsset>(urls)\n            .map((url) =>\n                ((typeof url !== 'string') ? url.src : url));\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        await this._unloadFromResolved(resolveResults);\n    }\n\n    /**\n     * Bundles are a way to manage multiple assets at once.\n     * this will unload all files in a bundle.\n     *\n     * once a bundle has been unloaded, you need to load it again to have access to the assets.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.addBundle({\n     *     'thumper': 'http://some.url.com/thumper.png',\n     * })\n     *\n     * const assets = await Assets.loadBundle('thumper');\n     *\n     * // Now to unload...\n     *\n     * await Assets.unloadBundle('thumper');\n     *\n     * // All assets in the assets object will now have been destroyed and purged from the cache\n     * @param bundleIds - the bundle id or ids to unload\n     */\n    public async unloadBundle(bundleIds: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const promises = Object.keys(resolveResults).map((bundleId) =>\n            this._unloadFromResolved(resolveResults[bundleId]));\n\n        await Promise.all(promises);\n    }\n\n    private async _unloadFromResolved(resolveResult: ResolvedAsset | Record<string, ResolvedAsset>)\n    {\n        const resolveArray = Object.values(resolveResult);\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            Cache.remove(resolveResult.src);\n        });\n\n        await this.loader.unload(resolveArray);\n    }\n\n    /**\n     * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n     * the users preferred formats order.\n     * @param options - the options to use when detecting formats\n     * @param options.preferredFormats - the preferred formats to use\n     * @param options.skipDetections - if we should skip the detections altogether\n     * @param options.detections - the detections to use\n     * @returns - the detected formats\n     */\n    private async _detectFormats(options: {\n        preferredFormats: string | string[],\n        skipDetections: boolean,\n        detections: FormatDetectionParser[]\n    }): Promise<string[]>\n    {\n        let formats: string[] = [];\n\n        // set preferred formats\n        if (options.preferredFormats)\n        {\n            formats = Array.isArray(options.preferredFormats)\n                ? options.preferredFormats : [options.preferredFormats];\n        }\n\n        // we should add any formats that are supported by the browser\n        for (const detection of options.detections)\n        {\n            if (options.skipDetections || await detection.test())\n            {\n                formats = await detection.add(formats);\n            }\n            else if (!options.skipDetections)\n            {\n                formats = await detection.remove(formats);\n            }\n        }\n\n        // remove any duplicates\n        formats = formats.filter((format, index) => formats.indexOf(format) === index);\n\n        return formats;\n    }\n\n    /** All the detection parsers currently added to the Assets class. */\n    public get detections(): FormatDetectionParser[]\n    {\n        return this._detections;\n    }\n\n    /**\n     * General setter for preferences. This is a helper function to set preferences on all parsers.\n     * @param preferences - the preferences to set\n     */\n    public setPreferences(preferences: Partial<AssetsPreferences>): void\n    {\n        // Find matching config keys in loaders with preferences\n        // and set the values\n        this.loader.parsers.forEach((parser) =>\n        {\n            if (!parser.config) return;\n\n            (Object.keys(parser.config) as (keyof AssetsPreferences)[])\n                .filter((key) => key in preferences)\n                .forEach((key) =>\n                {\n                    parser.config[key] = preferences[key];\n                });\n        });\n    }\n}\n\nexport const Assets = new AssetsClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.LoadParser, Assets.loader.parsers)\n    .handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers)\n    .handleByList(ExtensionType.CacheParser, Assets.cache.parsers)\n    .handleByList(ExtensionType.DetectionParser, Assets.detections);\nextensions.add(\n    cacheTextureArray,\n\n    detectDefaults,\n    detectAvif,\n    detectWebp,\n    detectMp4,\n    detectOgv,\n    detectWebm,\n\n    loadJson,\n    loadTxt,\n    loadWebFont,\n    loadSvg,\n    loadTextures,\n    loadVideoTextures,\n\n    resolveTextureUrl,\n    resolveJsonUrl\n);\n\nconst assetKeyMap = {\n    loader: ExtensionType.LoadParser,\n    resolver: ExtensionType.ResolveParser,\n    cache: ExtensionType.CacheParser,\n    detection: ExtensionType.DetectionParser,\n};\n\ntype AssetType = keyof typeof assetKeyMap;\n\n// Split the Asset extension into it's various parts\n// these are handled in the Assets.ts file\nextensions.handle(ExtensionType.Asset, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.entries(assetKeyMap)\n        .filter(([key]) => !!ref[key as AssetType])\n        .forEach(([key, type]) => extensions.add(Object.assign(\n            ref[key as AssetType],\n            // Allow the function to optionally define it's own\n            // ExtensionMetadata, the use cases here is priority for LoaderParsers\n            { extension: ref[key as AssetType].extension ?? type },\n        )));\n}, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.keys(assetKeyMap)\n        .filter((key) => !!ref[key as AssetType])\n        .forEach((key) => extensions.remove(ref[key as AssetType]));\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}