{"ast":null,"code":"import { catchError, combineLatest, map, of, switchMap } from 'rxjs';\nimport { Enum } from '@polkadot/types';\nimport { isFunction, objectSpread, stringToHex } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nimport { getImageHashBounded } from './util.js';\nconst DEMOCRACY_ID = stringToHex('democrac');\nfunction isMaybeHashedOrBounded(call) {\n  // check for enum\n  return call instanceof Enum;\n}\nfunction isBounded(call) {\n  // check for type\n  return call.isInline || call.isLegacy || call.isLookup;\n}\nfunction queryQueue(api) {\n  return api.query.democracy['dispatchQueue']().pipe(switchMap(dispatches => combineLatest([of(dispatches), api.derive.democracy.preimages(dispatches.map(_ref => {\n    let [, hash] = _ref;\n    return hash;\n  }))])), map(_ref2 => {\n    let [dispatches, images] = _ref2;\n    return dispatches.map((_ref3, dispatchIndex) => {\n      let [at, imageHash, index] = _ref3;\n      return {\n        at,\n        image: images[dispatchIndex],\n        imageHash: getImageHashBounded(imageHash),\n        index\n      };\n    });\n  }));\n}\nfunction schedulerEntries(api) {\n  // We don't get entries, but rather we get the keys (triggered via finished referendums) and\n  // the subscribe to those keys - this means we pickup when the schedulers actually executes\n  // at a block, the entry for that block will become empty\n  return api.derive.democracy.referendumsFinished().pipe(switchMap(() => api.query.scheduler.agenda.keys()), switchMap(keys => {\n    const blockNumbers = keys.map(_ref4 => {\n      let {\n        args: [blockNumber]\n      } = _ref4;\n      return blockNumber;\n    });\n    return blockNumbers.length ? combineLatest([of(blockNumbers),\n    // this should simply be api.query.scheduler.agenda.multi,\n    // however we have had cases on Darwinia where the indices have moved around after an\n    // upgrade, which results in invalid on-chain data\n    api.query.scheduler.agenda.multi(blockNumbers).pipe(catchError(() => of(blockNumbers.map(() => []))))]) : of([[], []]);\n  }));\n}\nfunction queryScheduler(api) {\n  return schedulerEntries(api).pipe(switchMap(_ref5 => {\n    let [blockNumbers, agendas] = _ref5;\n    const result = [];\n    blockNumbers.forEach((at, index) => {\n      (agendas[index] || []).filter(o => o.isSome).forEach(o => {\n        const scheduled = o.unwrap();\n        if (scheduled.maybeId.isSome) {\n          const id = scheduled.maybeId.unwrap().toHex();\n          if (id.startsWith(DEMOCRACY_ID)) {\n            const imageHash = isMaybeHashedOrBounded(scheduled.call) ? isBounded(scheduled.call) ? getImageHashBounded(scheduled.call) : scheduled.call.isHash ? scheduled.call.asHash.toHex() : scheduled.call.asValue.args[0].toHex() : scheduled.call.args[0].toHex();\n            result.push({\n              at,\n              imageHash,\n              index: api.registry.createType('(u64, ReferendumIndex)', id)[1]\n            });\n          }\n        }\n      });\n    });\n    return combineLatest([of(result), result.length ? api.derive.democracy.preimages(result.map(_ref6 => {\n      let {\n        imageHash\n      } = _ref6;\n      return imageHash;\n    })) : of([])]);\n  }), map(_ref7 => {\n    let [infos, images] = _ref7;\n    return infos.map((info, index) => objectSpread({\n      image: images[index]\n    }, info));\n  }));\n}\nexport function dispatchQueue(instanceId, api) {\n  return memo(instanceId, () => {\n    var _api$query$scheduler;\n    return isFunction((_api$query$scheduler = api.query.scheduler) === null || _api$query$scheduler === void 0 ? void 0 : _api$query$scheduler.agenda) ? queryScheduler(api) : api.query.democracy['dispatchQueue'] ? queryQueue(api) : of([]);\n  });\n}","map":{"version":3,"names":["catchError","combineLatest","map","of","switchMap","Enum","isFunction","objectSpread","stringToHex","memo","getImageHashBounded","DEMOCRACY_ID","isMaybeHashedOrBounded","call","isBounded","isInline","isLegacy","isLookup","queryQueue","api","query","democracy","pipe","dispatches","derive","preimages","_ref","hash","_ref2","images","_ref3","dispatchIndex","at","imageHash","index","image","schedulerEntries","referendumsFinished","scheduler","agenda","keys","blockNumbers","_ref4","args","blockNumber","length","multi","queryScheduler","_ref5","agendas","result","forEach","filter","o","isSome","scheduled","unwrap","maybeId","id","toHex","startsWith","isHash","asHash","asValue","push","registry","createType","_ref6","_ref7","infos","info","dispatchQueue","instanceId","_api$query$scheduler"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api-derive/democracy/dispatchQueue.js"],"sourcesContent":["import { catchError, combineLatest, map, of, switchMap } from 'rxjs';\nimport { Enum } from '@polkadot/types';\nimport { isFunction, objectSpread, stringToHex } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nimport { getImageHashBounded } from './util.js';\nconst DEMOCRACY_ID = stringToHex('democrac');\nfunction isMaybeHashedOrBounded(call) {\n    // check for enum\n    return call instanceof Enum;\n}\nfunction isBounded(call) {\n    // check for type\n    return call.isInline || call.isLegacy || call.isLookup;\n}\nfunction queryQueue(api) {\n    return api.query.democracy['dispatchQueue']().pipe(switchMap((dispatches) => combineLatest([\n        of(dispatches),\n        api.derive.democracy.preimages(dispatches.map(([, hash]) => hash))\n    ])), map(([dispatches, images]) => dispatches.map(([at, imageHash, index], dispatchIndex) => ({\n        at,\n        image: images[dispatchIndex],\n        imageHash: getImageHashBounded(imageHash),\n        index\n    }))));\n}\nfunction schedulerEntries(api) {\n    // We don't get entries, but rather we get the keys (triggered via finished referendums) and\n    // the subscribe to those keys - this means we pickup when the schedulers actually executes\n    // at a block, the entry for that block will become empty\n    return api.derive.democracy.referendumsFinished().pipe(switchMap(() => api.query.scheduler.agenda.keys()), switchMap((keys) => {\n        const blockNumbers = keys.map(({ args: [blockNumber] }) => blockNumber);\n        return blockNumbers.length\n            ? combineLatest([\n                of(blockNumbers),\n                // this should simply be api.query.scheduler.agenda.multi,\n                // however we have had cases on Darwinia where the indices have moved around after an\n                // upgrade, which results in invalid on-chain data\n                api.query.scheduler.agenda.multi(blockNumbers).pipe(catchError(() => of(blockNumbers.map(() => []))))\n            ])\n            : of([[], []]);\n    }));\n}\nfunction queryScheduler(api) {\n    return schedulerEntries(api).pipe(switchMap(([blockNumbers, agendas]) => {\n        const result = [];\n        blockNumbers.forEach((at, index) => {\n            (agendas[index] || []).filter((o) => o.isSome).forEach((o) => {\n                const scheduled = o.unwrap();\n                if (scheduled.maybeId.isSome) {\n                    const id = scheduled.maybeId.unwrap().toHex();\n                    if (id.startsWith(DEMOCRACY_ID)) {\n                        const imageHash = isMaybeHashedOrBounded(scheduled.call)\n                            ? isBounded(scheduled.call)\n                                ? getImageHashBounded(scheduled.call)\n                                : scheduled.call.isHash\n                                    ? scheduled.call.asHash.toHex()\n                                    : scheduled.call.asValue.args[0].toHex()\n                            : scheduled.call.args[0].toHex();\n                        result.push({ at, imageHash, index: api.registry.createType('(u64, ReferendumIndex)', id)[1] });\n                    }\n                }\n            });\n        });\n        return combineLatest([\n            of(result),\n            result.length\n                ? api.derive.democracy.preimages(result.map(({ imageHash }) => imageHash))\n                : of([])\n        ]);\n    }), map(([infos, images]) => infos.map((info, index) => objectSpread({ image: images[index] }, info))));\n}\nexport function dispatchQueue(instanceId, api) {\n    return memo(instanceId, () => isFunction(api.query.scheduler?.agenda)\n        ? queryScheduler(api)\n        : api.query.democracy['dispatchQueue']\n            ? queryQueue(api)\n            : of([]));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}