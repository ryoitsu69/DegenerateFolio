{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decompress = exports.compress = void 0;\nconst codecimpl_1 = require(\"./generated/codecimpl\");\nfunction compress(proof) {\n  if (!proof.batch) {\n    return proof;\n  }\n  return {\n    compressed: compressBatch(proof.batch)\n  };\n}\nexports.compress = compress;\nfunction decompress(proof) {\n  if (!proof.compressed) {\n    return proof;\n  }\n  return {\n    batch: decompressBatch(proof.compressed)\n  };\n}\nexports.decompress = decompress;\nfunction compressBatch(proof) {\n  const centries = [];\n  const lookup = [];\n  const registry = new Map();\n  for (const entry of proof.entries) {\n    if (entry.exist) {\n      const centry = {\n        exist: compressExist(entry.exist, lookup, registry)\n      };\n      centries.push(centry);\n    } else if (entry.nonexist) {\n      const non = entry.nonexist;\n      const centry = {\n        nonexist: {\n          key: non.key,\n          left: compressExist(non.left, lookup, registry),\n          right: compressExist(non.right, lookup, registry)\n        }\n      };\n      centries.push(centry);\n    } else {\n      throw new Error(\"Unexpected batch entry during compress\");\n    }\n  }\n  return {\n    entries: centries,\n    lookupInners: lookup\n  };\n}\nfunction compressExist(exist, lookup, registry) {\n  if (!exist) {\n    return undefined;\n  }\n  const path = exist.path.map(inner => {\n    const sig = codecimpl_1.ics23.InnerOp.encode(inner).finish();\n    let idx = registry.get(sig);\n    if (idx === undefined) {\n      idx = lookup.length;\n      lookup.push(inner);\n      registry.set(sig, idx);\n    }\n    return idx;\n  });\n  return {\n    key: exist.key,\n    value: exist.value,\n    leaf: exist.leaf,\n    path\n  };\n}\nfunction decompressBatch(proof) {\n  const lookup = proof.lookupInners;\n  const entries = proof.entries.map(comp => {\n    if (comp.exist) {\n      return {\n        exist: decompressExist(comp.exist, lookup)\n      };\n    } else if (comp.nonexist) {\n      const non = comp.nonexist;\n      return {\n        nonexist: {\n          key: non.key,\n          left: decompressExist(non.left, lookup),\n          right: decompressExist(non.right, lookup)\n        }\n      };\n    } else {\n      throw new Error(\"Unexpected batch entry during compress\");\n    }\n  });\n  return {\n    entries\n  };\n}\nfunction decompressExist(exist, lookup) {\n  if (!exist) {\n    return undefined;\n  }\n  const {\n    key,\n    value,\n    leaf,\n    path\n  } = exist;\n  const newPath = (path || []).map(idx => lookup[idx]);\n  return {\n    key,\n    value,\n    leaf,\n    path: newPath\n  };\n}","map":{"version":3,"names":["codecimpl_1","require","compress","proof","batch","compressed","compressBatch","exports","decompress","decompressBatch","centries","lookup","registry","Map","entry","entries","exist","centry","compressExist","push","nonexist","non","key","left","right","Error","lookupInners","undefined","path","map","inner","sig","ics23","InnerOp","encode","finish","idx","get","length","set","value","leaf","comp","decompressExist","newPath"],"sources":["../src/compress.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}