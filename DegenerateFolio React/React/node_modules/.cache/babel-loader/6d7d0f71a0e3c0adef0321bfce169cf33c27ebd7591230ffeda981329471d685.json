{"ast":null,"code":"/**\n * @name lazyMethod\n * @description\n * Creates a lazy, on-demand getter for the specific value. Upon get the value will be evaluated.\n */\nexport function lazyMethod(result, item, creator, getName) {\n  let index = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  const name = getName ? getName(item, index) : item.toString();\n  let value;\n  Object.defineProperty(result, name, {\n    // This allows for re-configuration with the embedded defineProperty below\n    // and ensures that on tested browsers and Node, it _will_ be redefined\n    // and thus short-circuited for future access\n    configurable: true,\n    enumerable: true,\n    // Use a function here, we don't want to capture the outer this, i.e.\n    // don't use arrow functions in this context since we have a this inside\n    get: function () {\n      // This check should _always_ be false and unneeded, since we override\n      // with a value below ... however we ensure we are quire vigilant against\n      // all environment failures, so we are rather be safe than sorry\n      if (value === undefined) {\n        value = creator(item, index, this);\n        try {\n          // re-define the property as a value, next time around this\n          // getter will only return the computed value\n          Object.defineProperty(this, name, {\n            value\n          });\n        } catch {\n          // ignore any errors, since this _should_ not happen due to\n          // the \"configurable\" property above. But if it ever does\n          // from here-on we will be the cached value the next time\n          // around (with a very slight dip in performance)\n        }\n      }\n      return value;\n    }\n  });\n}\n/**\n * @name lazyMethods\n * @description\n * Creates lazy, on-demand getters for the specific values.\n */\nexport function lazyMethods(result, items, creator, getName) {\n  for (let i = 0, count = items.length; i < count; i++) {\n    lazyMethod(result, items[i], creator, getName, i);\n  }\n  return result;\n}","map":{"version":3,"names":["lazyMethod","result","item","creator","getName","index","arguments","length","undefined","name","toString","value","Object","defineProperty","configurable","enumerable","get","lazyMethods","items","i","count"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util/lazy.js"],"sourcesContent":["/**\n * @name lazyMethod\n * @description\n * Creates a lazy, on-demand getter for the specific value. Upon get the value will be evaluated.\n */\nexport function lazyMethod(result, item, creator, getName, index = 0) {\n    const name = getName\n        ? getName(item, index)\n        : item.toString();\n    let value;\n    Object.defineProperty(result, name, {\n        // This allows for re-configuration with the embedded defineProperty below\n        // and ensures that on tested browsers and Node, it _will_ be redefined\n        // and thus short-circuited for future access\n        configurable: true,\n        enumerable: true,\n        // Use a function here, we don't want to capture the outer this, i.e.\n        // don't use arrow functions in this context since we have a this inside\n        get: function () {\n            // This check should _always_ be false and unneeded, since we override\n            // with a value below ... however we ensure we are quire vigilant against\n            // all environment failures, so we are rather be safe than sorry\n            if (value === undefined) {\n                value = creator(item, index, this);\n                try {\n                    // re-define the property as a value, next time around this\n                    // getter will only return the computed value\n                    Object.defineProperty(this, name, { value });\n                }\n                catch {\n                    // ignore any errors, since this _should_ not happen due to\n                    // the \"configurable\" property above. But if it ever does\n                    // from here-on we will be the cached value the next time\n                    // around (with a very slight dip in performance)\n                }\n            }\n            return value;\n        }\n    });\n}\n/**\n * @name lazyMethods\n * @description\n * Creates lazy, on-demand getters for the specific values.\n */\nexport function lazyMethods(result, items, creator, getName) {\n    for (let i = 0, count = items.length; i < count; i++) {\n        lazyMethod(result, items[i], creator, getName, i);\n    }\n    return result;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,UAAUA,CAACC,MAAM,EAAEC,IAAI,EAAEC,OAAO,EAAEC,OAAO,EAAa;EAAA,IAAXC,KAAK,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAChE,MAAMG,IAAI,GAAGL,OAAO,GACdA,OAAO,CAACF,IAAI,EAAEG,KAAK,CAAC,GACpBH,IAAI,CAACQ,QAAQ,CAAC,CAAC;EACrB,IAAIC,KAAK;EACTC,MAAM,CAACC,cAAc,CAACZ,MAAM,EAAEQ,IAAI,EAAE;IAChC;IACA;IACA;IACAK,YAAY,EAAE,IAAI;IAClBC,UAAU,EAAE,IAAI;IAChB;IACA;IACAC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb;MACA;MACA;MACA,IAAIL,KAAK,KAAKH,SAAS,EAAE;QACrBG,KAAK,GAAGR,OAAO,CAACD,IAAI,EAAEG,KAAK,EAAE,IAAI,CAAC;QAClC,IAAI;UACA;UACA;UACAO,MAAM,CAACC,cAAc,CAAC,IAAI,EAAEJ,IAAI,EAAE;YAAEE;UAAM,CAAC,CAAC;QAChD,CAAC,CACD,MAAM;UACF;UACA;UACA;UACA;QAAA;MAER;MACA,OAAOA,KAAK;IAChB;EACJ,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASM,WAAWA,CAAChB,MAAM,EAAEiB,KAAK,EAAEf,OAAO,EAAEC,OAAO,EAAE;EACzD,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEC,KAAK,GAAGF,KAAK,CAACX,MAAM,EAAEY,CAAC,GAAGC,KAAK,EAAED,CAAC,EAAE,EAAE;IAClDnB,UAAU,CAACC,MAAM,EAAEiB,KAAK,CAACC,CAAC,CAAC,EAAEhB,OAAO,EAAEC,OAAO,EAAEe,CAAC,CAAC;EACrD;EACA,OAAOlB,MAAM;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}