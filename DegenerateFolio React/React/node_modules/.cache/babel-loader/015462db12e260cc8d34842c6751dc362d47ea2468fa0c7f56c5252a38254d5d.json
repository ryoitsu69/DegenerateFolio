{"ast":null,"code":"import { Option } from '../base/Option.js';\nimport { Tuple } from '../base/Tuple.js';\nimport { Vec } from '../base/Vec.js';\nimport { Struct } from '../native/Struct.js';\nconst EMPTY = new Uint8Array();\n/**\n * @name Linkage\n * @description The wrapper for the result from a LinkedMap\n */\nexport class Linkage extends Struct {\n  constructor(registry, Type, value) {\n    super(registry, {\n      previous: Option.with(Type),\n      // eslint-disable-next-line sort-keys\n      next: Option.with(Type)\n    }, value);\n  }\n  static withKey(Type) {\n    return class extends Linkage {\n      constructor(registry, value) {\n        super(registry, Type, value);\n      }\n    };\n  }\n  /**\n   * @description Returns the next item the Linkage is pointing to\n   */\n  get previous() {\n    return this.get('previous');\n  }\n  /**\n   * @description Returns the previous item the Linkage is pointing to\n   */\n  get next() {\n    return this.get('next');\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return \"Linkage<\".concat(this.next.toRawType(true), \">\");\n  }\n  /**\n   * @description Custom toU8a which with bare mode does not return the linkage if empty\n   */\n  toU8a(isBare) {\n    // As part of a storage query (where these appear), in the case of empty, the values\n    // are NOT populated by the node - follow the same logic, leaving it empty\n    return this.isEmpty ? EMPTY : super.toU8a(isBare);\n  }\n}\n/**\n * @name LinkageResult\n * @description A Linkage keys/Values tuple\n */\nexport class LinkageResult extends Tuple {\n  constructor(registry, _ref, _ref2) {\n    let [TypeKey, keys] = _ref;\n    let [TypeValue, values] = _ref2;\n    super(registry, {\n      Keys: Vec.with(TypeKey),\n      Values: Vec.with(TypeValue)\n    }, [keys, values]);\n  }\n}","map":{"version":3,"names":["Option","Tuple","Vec","Struct","EMPTY","Uint8Array","Linkage","constructor","registry","Type","value","previous","with","next","withKey","get","toRawType","concat","toU8a","isBare","isEmpty","LinkageResult","_ref","_ref2","TypeKey","keys","TypeValue","values","Keys","Values"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/extended/Linkage.js"],"sourcesContent":["import { Option } from '../base/Option.js';\nimport { Tuple } from '../base/Tuple.js';\nimport { Vec } from '../base/Vec.js';\nimport { Struct } from '../native/Struct.js';\nconst EMPTY = new Uint8Array();\n/**\n * @name Linkage\n * @description The wrapper for the result from a LinkedMap\n */\nexport class Linkage extends Struct {\n    constructor(registry, Type, value) {\n        super(registry, {\n            previous: Option.with(Type),\n            // eslint-disable-next-line sort-keys\n            next: Option.with(Type)\n        }, value);\n    }\n    static withKey(Type) {\n        return class extends Linkage {\n            constructor(registry, value) {\n                super(registry, Type, value);\n            }\n        };\n    }\n    /**\n     * @description Returns the next item the Linkage is pointing to\n     */\n    get previous() {\n        return this.get('previous');\n    }\n    /**\n     * @description Returns the previous item the Linkage is pointing to\n     */\n    get next() {\n        return this.get('next');\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `Linkage<${this.next.toRawType(true)}>`;\n    }\n    /**\n     * @description Custom toU8a which with bare mode does not return the linkage if empty\n     */\n    toU8a(isBare) {\n        // As part of a storage query (where these appear), in the case of empty, the values\n        // are NOT populated by the node - follow the same logic, leaving it empty\n        return this.isEmpty\n            ? EMPTY\n            : super.toU8a(isBare);\n    }\n}\n/**\n * @name LinkageResult\n * @description A Linkage keys/Values tuple\n */\nexport class LinkageResult extends Tuple {\n    constructor(registry, [TypeKey, keys], [TypeValue, values]) {\n        super(registry, {\n            Keys: Vec.with(TypeKey),\n            Values: Vec.with(TypeValue)\n        }, [keys, values]);\n    }\n}\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,mBAAmB;AAC1C,SAASC,KAAK,QAAQ,kBAAkB;AACxC,SAASC,GAAG,QAAQ,gBAAgB;AACpC,SAASC,MAAM,QAAQ,qBAAqB;AAC5C,MAAMC,KAAK,GAAG,IAAIC,UAAU,CAAC,CAAC;AAC9B;AACA;AACA;AACA;AACA,OAAO,MAAMC,OAAO,SAASH,MAAM,CAAC;EAChCI,WAAWA,CAACC,QAAQ,EAAEC,IAAI,EAAEC,KAAK,EAAE;IAC/B,KAAK,CAACF,QAAQ,EAAE;MACZG,QAAQ,EAAEX,MAAM,CAACY,IAAI,CAACH,IAAI,CAAC;MAC3B;MACAI,IAAI,EAAEb,MAAM,CAACY,IAAI,CAACH,IAAI;IAC1B,CAAC,EAAEC,KAAK,CAAC;EACb;EACA,OAAOI,OAAOA,CAACL,IAAI,EAAE;IACjB,OAAO,cAAcH,OAAO,CAAC;MACzBC,WAAWA,CAACC,QAAQ,EAAEE,KAAK,EAAE;QACzB,KAAK,CAACF,QAAQ,EAAEC,IAAI,EAAEC,KAAK,CAAC;MAChC;IACJ,CAAC;EACL;EACA;AACJ;AACA;EACI,IAAIC,QAAQA,CAAA,EAAG;IACX,OAAO,IAAI,CAACI,GAAG,CAAC,UAAU,CAAC;EAC/B;EACA;AACJ;AACA;EACI,IAAIF,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACE,GAAG,CAAC,MAAM,CAAC;EAC3B;EACA;AACJ;AACA;EACIC,SAASA,CAAA,EAAG;IACR,kBAAAC,MAAA,CAAkB,IAAI,CAACJ,IAAI,CAACG,SAAS,CAAC,IAAI,CAAC;EAC/C;EACA;AACJ;AACA;EACIE,KAAKA,CAACC,MAAM,EAAE;IACV;IACA;IACA,OAAO,IAAI,CAACC,OAAO,GACbhB,KAAK,GACL,KAAK,CAACc,KAAK,CAACC,MAAM,CAAC;EAC7B;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,aAAa,SAASpB,KAAK,CAAC;EACrCM,WAAWA,CAACC,QAAQ,EAAAc,IAAA,EAAAC,KAAA,EAAwC;IAAA,IAAtC,CAACC,OAAO,EAAEC,IAAI,CAAC,GAAAH,IAAA;IAAA,IAAE,CAACI,SAAS,EAAEC,MAAM,CAAC,GAAAJ,KAAA;IACtD,KAAK,CAACf,QAAQ,EAAE;MACZoB,IAAI,EAAE1B,GAAG,CAACU,IAAI,CAACY,OAAO,CAAC;MACvBK,MAAM,EAAE3B,GAAG,CAACU,IAAI,CAACc,SAAS;IAC9B,CAAC,EAAE,CAACD,IAAI,EAAEE,MAAM,CAAC,CAAC;EACtB;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}