{"ast":null,"code":"import { BLEND_MODES, Color } from \"@pixi/core\";\nimport { Container } from \"@pixi/display\";\nclass ParticleContainer extends Container {\n  /**\n   * @param maxSize - The maximum number of particles that can be rendered by the container.\n   *  Affects size of allocated buffers.\n   * @param properties - The properties of children that should be uploaded to the gpu and applied.\n   * @param {boolean} [properties.vertices=false] - When true, vertices be uploaded and applied.\n   *                  if sprite's ` scale/anchor/trim/frame/orig` is dynamic, please set `true`.\n   * @param {boolean} [properties.position=true] - When true, position be uploaded and applied.\n   * @param {boolean} [properties.rotation=false] - When true, rotation be uploaded and applied.\n   * @param {boolean} [properties.uvs=false] - When true, uvs be uploaded and applied.\n   * @param {boolean} [properties.tint=false] - When true, alpha and tint be uploaded and applied.\n   * @param {number} [batchSize=16384] - Number of particles per batch. If less than maxSize, it uses maxSize instead.\n   * @param {boolean} [autoResize=false] - If true, container allocates more batches in case\n   *  there are more than `maxSize` particles.\n   */\n  constructor(maxSize = 1500, properties, batchSize = 16384, autoResize = !1) {\n    super();\n    const maxBatchSize = 16384;\n    batchSize > maxBatchSize && (batchSize = maxBatchSize), this._properties = [!1, !0, !1, !1, !1], this._maxSize = maxSize, this._batchSize = batchSize, this._buffers = null, this._bufferUpdateIDs = [], this._updateID = 0, this.interactiveChildren = !1, this.blendMode = BLEND_MODES.NORMAL, this.autoResize = autoResize, this.roundPixels = !0, this.baseTexture = null, this.setProperties(properties), this._tintColor = new Color(0), this.tintRgb = new Float32Array(3), this.tint = 16777215;\n  }\n  /**\n   * Sets the private properties array to dynamic / static based on the passed properties object\n   * @param properties - The properties to be uploaded\n   */\n  setProperties(properties) {\n    properties && (this._properties[0] = \"vertices\" in properties || \"scale\" in properties ? !!properties.vertices || !!properties.scale : this._properties[0], this._properties[1] = \"position\" in properties ? !!properties.position : this._properties[1], this._properties[2] = \"rotation\" in properties ? !!properties.rotation : this._properties[2], this._properties[3] = \"uvs\" in properties ? !!properties.uvs : this._properties[3], this._properties[4] = \"tint\" in properties || \"alpha\" in properties ? !!properties.tint || !!properties.alpha : this._properties[4]);\n  }\n  updateTransform() {\n    this.displayObjectUpdateTransform();\n  }\n  /**\n   * The tint applied to the container. This is a hex value.\n   * A value of 0xFFFFFF will remove any tint effect.\n   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    return this._tintColor.value;\n  }\n  set tint(value) {\n    this._tintColor.setValue(value), this._tintColor.toRgbArray(this.tintRgb);\n  }\n  /**\n   * Renders the container using the WebGL renderer.\n   * @param renderer - The WebGL renderer.\n   */\n  render(renderer) {\n    !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once(\"update\", () => this.onChildrenChange(0))), renderer.batch.setObjectRenderer(renderer.plugins.particle), renderer.plugins.particle.render(this));\n  }\n  /**\n   * Set the flag that static data should be updated to true\n   * @param smallestChildIndex - The smallest child index.\n   */\n  onChildrenChange(smallestChildIndex) {\n    const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);\n    for (; this._bufferUpdateIDs.length < bufferIndex;) this._bufferUpdateIDs.push(0);\n    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;\n  }\n  dispose() {\n    if (this._buffers) {\n      for (let i = 0; i < this._buffers.length; ++i) this._buffers[i].destroy();\n      this._buffers = null;\n    }\n  }\n  /**\n   * Destroys the container\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their\n   *  destroy method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n  destroy(options) {\n    super.destroy(options), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;\n  }\n}\nexport { ParticleContainer };","map":{"version":3,"names":["ParticleContainer","Container","constructor","maxSize","properties","batchSize","autoResize","maxBatchSize","_properties","_maxSize","_batchSize","_buffers","_bufferUpdateIDs","_updateID","interactiveChildren","blendMode","BLEND_MODES","NORMAL","roundPixels","baseTexture","setProperties","_tintColor","Color","tintRgb","Float32Array","tint","vertices","scale","position","rotation","uvs","alpha","updateTransform","displayObjectUpdateTransform","value","setValue","toRgbArray","render","renderer","visible","worldAlpha","children","length","renderable","_texture","valid","once","onChildrenChange","batch","setObjectRenderer","plugins","particle","smallestChildIndex","bufferIndex","Math","floor","push","dispose","i","destroy","options"],"sources":["/home/ryoitsu/node_modules/@pixi/particle-container/src/ParticleContainer.ts"],"sourcesContent":["import { BLEND_MODES, Color } from '@pixi/core';\nimport { Container } from '@pixi/display';\n\nimport type { BaseTexture, ColorSource, Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { Sprite } from '@pixi/sprite';\nimport type { ParticleBuffer } from './ParticleBuffer';\n\nexport interface IParticleProperties\n{\n    vertices?: boolean;\n    position?: boolean;\n    rotation?: boolean;\n    uvs?: boolean;\n    tint?: boolean;\n    alpha?: boolean;\n    scale?: boolean;\n}\n\n/**\n * The ParticleContainer class is a really fast version of the Container built solely for speed,\n * so use when you need a lot of sprites or particles.\n *\n * The tradeoff of the ParticleContainer is that most advanced functionality will not work.\n * ParticleContainer implements the basic object transform (position, scale, rotation)\n * and some advanced functionality like tint (as of v4.5.6).\n *\n * Other more advanced functionality like masking, children, filters, etc will not work on sprites in this batch.\n *\n * It's extremely easy to use. And here you have a hundred sprites that will be rendered at the speed of light.\n * @example\n * import { ParticleContainer, Sprite } from 'pixi.js';\n *\n * const container = new ParticleContainer();\n *\n * for (let i = 0; i < 100; ++i)\n * {\n *     let sprite = Sprite.from('myImage.png');\n *     container.addChild(sprite);\n * }\n * @memberof PIXI\n */\nexport class ParticleContainer<T extends Sprite = Sprite> extends Container<T>\n{\n    /**\n     * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL`\n     * to reset the blend mode.\n     * @default PIXI.BLEND_MODES.NORMAL\n     */\n    public blendMode: BLEND_MODES;\n\n    /**\n     * If true, container allocates more batches in case there are more than `maxSize` particles.\n     * @default false\n     */\n    public autoResize: boolean;\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     * Default to true here as performance is usually the priority for particles.\n     * @default true\n     */\n    public roundPixels: boolean;\n\n    /**\n     * The texture used to render the children.\n     * @readonly\n     */\n    public baseTexture: BaseTexture;\n    public tintRgb: Float32Array;\n\n    /** @private */\n    _maxSize: number;\n\n    /** @private */\n    _buffers: ParticleBuffer[];\n\n    /** @private */\n    _batchSize: number;\n\n    /**\n     * Set properties to be dynamic (true) / static (false).\n     * @private\n     */\n    _properties: boolean[];\n\n    /**\n     * For every batch, stores _updateID corresponding to the last change in that batch.\n     * @private\n     */\n    _bufferUpdateIDs: number[];\n\n    /**\n     * When child inserted, removed or changes position this number goes up.\n     * @private\n     */\n    _updateID: number;\n\n    /**\n     * The tint applied to the container.\n     * This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     * @default 0xFFFFFF\n     */\n    private _tintColor: Color;\n\n    /**\n     * @param maxSize - The maximum number of particles that can be rendered by the container.\n     *  Affects size of allocated buffers.\n     * @param properties - The properties of children that should be uploaded to the gpu and applied.\n     * @param {boolean} [properties.vertices=false] - When true, vertices be uploaded and applied.\n     *                  if sprite's ` scale/anchor/trim/frame/orig` is dynamic, please set `true`.\n     * @param {boolean} [properties.position=true] - When true, position be uploaded and applied.\n     * @param {boolean} [properties.rotation=false] - When true, rotation be uploaded and applied.\n     * @param {boolean} [properties.uvs=false] - When true, uvs be uploaded and applied.\n     * @param {boolean} [properties.tint=false] - When true, alpha and tint be uploaded and applied.\n     * @param {number} [batchSize=16384] - Number of particles per batch. If less than maxSize, it uses maxSize instead.\n     * @param {boolean} [autoResize=false] - If true, container allocates more batches in case\n     *  there are more than `maxSize` particles.\n     */\n    constructor(maxSize = 1500, properties?: IParticleProperties, batchSize = 16384, autoResize = false)\n    {\n        super();\n\n        // Making sure the batch size is valid\n        // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n        // so max number of particles is 65536 / 4 = 16384\n        const maxBatchSize = 16384;\n\n        if (batchSize > maxBatchSize)\n        {\n            batchSize = maxBatchSize;\n        }\n\n        this._properties = [false, true, false, false, false];\n        this._maxSize = maxSize;\n        this._batchSize = batchSize;\n        this._buffers = null;\n        this._bufferUpdateIDs = [];\n        this._updateID = 0;\n\n        this.interactiveChildren = false;\n        this.blendMode = BLEND_MODES.NORMAL;\n        this.autoResize = autoResize;\n        this.roundPixels = true;\n        this.baseTexture = null;\n\n        this.setProperties(properties);\n\n        this._tintColor = new Color(0);\n        this.tintRgb = new Float32Array(3);\n        this.tint = 0xFFFFFF;\n    }\n\n    /**\n     * Sets the private properties array to dynamic / static based on the passed properties object\n     * @param properties - The properties to be uploaded\n     */\n    public setProperties(properties: IParticleProperties): void\n    {\n        if (properties)\n        {\n            this._properties[0] = 'vertices' in properties || 'scale' in properties\n                ? !!properties.vertices || !!properties.scale : this._properties[0];\n            this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];\n            this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];\n            this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];\n            this._properties[4] = 'tint' in properties || 'alpha' in properties\n                ? !!properties.tint || !!properties.alpha : this._properties[4];\n        }\n    }\n\n    updateTransform(): void\n    {\n        // TODO don't need to!\n        this.displayObjectUpdateTransform();\n    }\n\n    /**\n     * The tint applied to the container. This is a hex value.\n     * A value of 0xFFFFFF will remove any tint effect.\n     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * @default 0xFFFFFF\n     */\n    get tint(): ColorSource\n    {\n        return this._tintColor.value;\n    }\n\n    set tint(value: ColorSource)\n    {\n        this._tintColor.setValue(value);\n        this._tintColor.toRgbArray(this.tintRgb);\n    }\n\n    /**\n     * Renders the container using the WebGL renderer.\n     * @param renderer - The WebGL renderer.\n     */\n    public render(renderer: Renderer): void\n    {\n        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)\n        {\n            return;\n        }\n\n        if (!this.baseTexture)\n        {\n            this.baseTexture = this.children[0]._texture.baseTexture;\n            if (!this.baseTexture.valid)\n            {\n                this.baseTexture.once('update', () => this.onChildrenChange(0));\n            }\n        }\n\n        renderer.batch.setObjectRenderer(renderer.plugins.particle);\n        renderer.plugins.particle.render(this);\n    }\n\n    /**\n     * Set the flag that static data should be updated to true\n     * @param smallestChildIndex - The smallest child index.\n     */\n    protected onChildrenChange(smallestChildIndex: number): void\n    {\n        const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);\n\n        while (this._bufferUpdateIDs.length < bufferIndex)\n        {\n            this._bufferUpdateIDs.push(0);\n        }\n        this._bufferUpdateIDs[bufferIndex] = ++this._updateID;\n    }\n\n    public dispose(): void\n    {\n        if (this._buffers)\n        {\n            for (let i = 0; i < this._buffers.length; ++i)\n            {\n                this._buffers[i].destroy();\n            }\n\n            this._buffers = null;\n        }\n    }\n\n    /**\n     * Destroys the container\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their\n     *  destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        super.destroy(options);\n\n        this.dispose();\n\n        this._properties = null;\n        this._buffers = null;\n        this._bufferUpdateIDs = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}