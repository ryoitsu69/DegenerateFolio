{"ast":null,"code":"import { assertUnreachable } from '@polkadot/util';\nfunction convertType(key) {\n  return (registry, {\n    type\n  }) => registry.createType('Si1TypeDef', {\n    [key]: {\n      type: type.toNumber()\n    }\n  });\n}\nfunction convertArray(registry, {\n  len,\n  type\n}) {\n  return registry.createType('Si1TypeDef', {\n    Array: {\n      len,\n      type: type.toNumber()\n    }\n  });\n}\nfunction convertBitSequence(registry, {\n  bitOrderType,\n  bitStoreType\n}) {\n  return registry.createType('Si1TypeDef', {\n    BitSequence: {\n      bitOrderType: bitOrderType.toNumber(),\n      bitStoreType: bitStoreType.toNumber()\n    }\n  });\n}\nconst convertCompact = convertType('Compact');\nfunction convertComposite(registry, {\n  fields\n}) {\n  return registry.createType('Si1TypeDef', {\n    Composite: {\n      fields: convertFields(registry, fields)\n    }\n  });\n}\nfunction convertFields(registry, fields) {\n  return fields.map(({\n    docs,\n    name,\n    type,\n    typeName\n  }) => registry.createType('Si1Field', {\n    docs,\n    name,\n    type: type.toNumber(),\n    typeName\n  }));\n}\nfunction convertPhantom(registry, path) {\n  console.warn(`Converting phantom type ${path.map(p => p.toString()).join('::')} to empty tuple`);\n  return registry.createType('Si1TypeDef', {\n    Tuple: []\n  });\n}\nfunction convertPrimitive(registry, prim) {\n  return registry.createType('Si1TypeDef', {\n    Primitive: prim.toString()\n  });\n}\nconst convertSequence = convertType('Sequence');\nfunction convertTuple(registry, types) {\n  return registry.createType('Si1TypeDef', {\n    Tuple: types.map(t => t.toNumber())\n  });\n}\nfunction convertVariant(registry, {\n  variants\n}) {\n  return registry.createType('Si1TypeDef', {\n    Variant: {\n      variants: variants.map(({\n        discriminant,\n        docs,\n        fields,\n        name\n      }, index) => registry.createType('Si1Variant', {\n        docs,\n        fields: convertFields(registry, fields),\n        index: discriminant.isSome ? discriminant.unwrap().toNumber() : index,\n        name\n      }))\n    }\n  });\n}\nfunction convertDef(registry, {\n  def,\n  path\n}) {\n  let result;\n  switch (def.type) {\n    case 'Array':\n      result = convertArray(registry, def.asArray);\n      break;\n    case 'BitSequence':\n      result = convertBitSequence(registry, def.asBitSequence);\n      break;\n    case 'Compact':\n      result = convertCompact(registry, def.asCompact);\n      break;\n    case 'Composite':\n      result = convertComposite(registry, def.asComposite);\n      break;\n    case 'Phantom':\n      result = convertPhantom(registry, path);\n      break;\n    case 'Primitive':\n      result = convertPrimitive(registry, def.asPrimitive);\n      break;\n    case 'Sequence':\n      result = convertSequence(registry, def.asSequence);\n      break;\n    case 'Tuple':\n      result = convertTuple(registry, def.asTuple);\n      break;\n    case 'Variant':\n      result = convertVariant(registry, def.asVariant);\n      break;\n    default:\n      assertUnreachable(def.type);\n  }\n  return result;\n}\nexport function toV1(registry, types) {\n  return types.map((t, index) => registry.createType('PortableType', {\n    // offsets are +1 from v0\n    id: index + 1,\n    type: {\n      def: convertDef(registry, t),\n      docs: [],\n      params: t.params.map(p => registry.createType('Si1TypeParameter', {\n        type: p.toNumber()\n      })),\n      path: t.path.map(p => p.toString())\n    }\n  }));\n}","map":{"version":3,"names":["assertUnreachable","convertType","key","registry","type","createType","toNumber","convertArray","len","Array","convertBitSequence","bitOrderType","bitStoreType","BitSequence","convertCompact","convertComposite","fields","Composite","convertFields","map","docs","name","typeName","convertPhantom","path","console","warn","p","toString","join","Tuple","convertPrimitive","prim","Primitive","convertSequence","convertTuple","types","t","convertVariant","variants","Variant","discriminant","index","isSome","unwrap","convertDef","def","result","asArray","asBitSequence","asCompact","asComposite","asPrimitive","asSequence","asTuple","asVariant","toV1","id","params"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/metadata/PortableRegistry/toV1.js"],"sourcesContent":["import { assertUnreachable } from '@polkadot/util';\nfunction convertType(key) {\n    return (registry, { type }) => registry.createType('Si1TypeDef', {\n        [key]: {\n            type: type.toNumber()\n        }\n    });\n}\nfunction convertArray(registry, { len, type }) {\n    return registry.createType('Si1TypeDef', {\n        Array: {\n            len,\n            type: type.toNumber()\n        }\n    });\n}\nfunction convertBitSequence(registry, { bitOrderType, bitStoreType }) {\n    return registry.createType('Si1TypeDef', {\n        BitSequence: {\n            bitOrderType: bitOrderType.toNumber(),\n            bitStoreType: bitStoreType.toNumber()\n        }\n    });\n}\nconst convertCompact = convertType('Compact');\nfunction convertComposite(registry, { fields }) {\n    return registry.createType('Si1TypeDef', {\n        Composite: {\n            fields: convertFields(registry, fields)\n        }\n    });\n}\nfunction convertFields(registry, fields) {\n    return fields.map(({ docs, name, type, typeName }) => registry.createType('Si1Field', {\n        docs,\n        name,\n        type: type.toNumber(),\n        typeName\n    }));\n}\nfunction convertPhantom(registry, path) {\n    console.warn(`Converting phantom type ${path.map((p) => p.toString()).join('::')} to empty tuple`);\n    return registry.createType('Si1TypeDef', {\n        Tuple: []\n    });\n}\nfunction convertPrimitive(registry, prim) {\n    return registry.createType('Si1TypeDef', {\n        Primitive: prim.toString()\n    });\n}\nconst convertSequence = convertType('Sequence');\nfunction convertTuple(registry, types) {\n    return registry.createType('Si1TypeDef', {\n        Tuple: types.map((t) => t.toNumber())\n    });\n}\nfunction convertVariant(registry, { variants }) {\n    return registry.createType('Si1TypeDef', {\n        Variant: {\n            variants: variants.map(({ discriminant, docs, fields, name }, index) => registry.createType('Si1Variant', {\n                docs,\n                fields: convertFields(registry, fields),\n                index: discriminant.isSome\n                    ? discriminant.unwrap().toNumber()\n                    : index,\n                name\n            }))\n        }\n    });\n}\nfunction convertDef(registry, { def, path }) {\n    let result;\n    switch (def.type) {\n        case 'Array':\n            result = convertArray(registry, def.asArray);\n            break;\n        case 'BitSequence':\n            result = convertBitSequence(registry, def.asBitSequence);\n            break;\n        case 'Compact':\n            result = convertCompact(registry, def.asCompact);\n            break;\n        case 'Composite':\n            result = convertComposite(registry, def.asComposite);\n            break;\n        case 'Phantom':\n            result = convertPhantom(registry, path);\n            break;\n        case 'Primitive':\n            result = convertPrimitive(registry, def.asPrimitive);\n            break;\n        case 'Sequence':\n            result = convertSequence(registry, def.asSequence);\n            break;\n        case 'Tuple':\n            result = convertTuple(registry, def.asTuple);\n            break;\n        case 'Variant':\n            result = convertVariant(registry, def.asVariant);\n            break;\n        default: assertUnreachable(def.type);\n    }\n    return result;\n}\nexport function toV1(registry, types) {\n    return types.map((t, index) => registry.createType('PortableType', {\n        // offsets are +1 from v0\n        id: index + 1,\n        type: {\n            def: convertDef(registry, t),\n            docs: [],\n            params: t.params.map((p) => registry.createType('Si1TypeParameter', {\n                type: p.toNumber()\n            })),\n            path: t.path.map((p) => p.toString())\n        }\n    }));\n}\n"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,gBAAgB;AAClD,SAASC,WAAWA,CAACC,GAAG,EAAE;EACtB,OAAO,CAACC,QAAQ,EAAE;IAAEC;EAAK,CAAC,KAAKD,QAAQ,CAACE,UAAU,CAAC,YAAY,EAAE;IAC7D,CAACH,GAAG,GAAG;MACHE,IAAI,EAAEA,IAAI,CAACE,QAAQ,CAAC;IACxB;EACJ,CAAC,CAAC;AACN;AACA,SAASC,YAAYA,CAACJ,QAAQ,EAAE;EAAEK,GAAG;EAAEJ;AAAK,CAAC,EAAE;EAC3C,OAAOD,QAAQ,CAACE,UAAU,CAAC,YAAY,EAAE;IACrCI,KAAK,EAAE;MACHD,GAAG;MACHJ,IAAI,EAAEA,IAAI,CAACE,QAAQ,CAAC;IACxB;EACJ,CAAC,CAAC;AACN;AACA,SAASI,kBAAkBA,CAACP,QAAQ,EAAE;EAAEQ,YAAY;EAAEC;AAAa,CAAC,EAAE;EAClE,OAAOT,QAAQ,CAACE,UAAU,CAAC,YAAY,EAAE;IACrCQ,WAAW,EAAE;MACTF,YAAY,EAAEA,YAAY,CAACL,QAAQ,CAAC,CAAC;MACrCM,YAAY,EAAEA,YAAY,CAACN,QAAQ,CAAC;IACxC;EACJ,CAAC,CAAC;AACN;AACA,MAAMQ,cAAc,GAAGb,WAAW,CAAC,SAAS,CAAC;AAC7C,SAASc,gBAAgBA,CAACZ,QAAQ,EAAE;EAAEa;AAAO,CAAC,EAAE;EAC5C,OAAOb,QAAQ,CAACE,UAAU,CAAC,YAAY,EAAE;IACrCY,SAAS,EAAE;MACPD,MAAM,EAAEE,aAAa,CAACf,QAAQ,EAAEa,MAAM;IAC1C;EACJ,CAAC,CAAC;AACN;AACA,SAASE,aAAaA,CAACf,QAAQ,EAAEa,MAAM,EAAE;EACrC,OAAOA,MAAM,CAACG,GAAG,CAAC,CAAC;IAAEC,IAAI;IAAEC,IAAI;IAAEjB,IAAI;IAAEkB;EAAS,CAAC,KAAKnB,QAAQ,CAACE,UAAU,CAAC,UAAU,EAAE;IAClFe,IAAI;IACJC,IAAI;IACJjB,IAAI,EAAEA,IAAI,CAACE,QAAQ,CAAC,CAAC;IACrBgB;EACJ,CAAC,CAAC,CAAC;AACP;AACA,SAASC,cAAcA,CAACpB,QAAQ,EAAEqB,IAAI,EAAE;EACpCC,OAAO,CAACC,IAAI,CAAE,2BAA0BF,IAAI,CAACL,GAAG,CAAEQ,CAAC,IAAKA,CAAC,CAACC,QAAQ,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,IAAI,CAAE,iBAAgB,CAAC;EAClG,OAAO1B,QAAQ,CAACE,UAAU,CAAC,YAAY,EAAE;IACrCyB,KAAK,EAAE;EACX,CAAC,CAAC;AACN;AACA,SAASC,gBAAgBA,CAAC5B,QAAQ,EAAE6B,IAAI,EAAE;EACtC,OAAO7B,QAAQ,CAACE,UAAU,CAAC,YAAY,EAAE;IACrC4B,SAAS,EAAED,IAAI,CAACJ,QAAQ,CAAC;EAC7B,CAAC,CAAC;AACN;AACA,MAAMM,eAAe,GAAGjC,WAAW,CAAC,UAAU,CAAC;AAC/C,SAASkC,YAAYA,CAAChC,QAAQ,EAAEiC,KAAK,EAAE;EACnC,OAAOjC,QAAQ,CAACE,UAAU,CAAC,YAAY,EAAE;IACrCyB,KAAK,EAAEM,KAAK,CAACjB,GAAG,CAAEkB,CAAC,IAAKA,CAAC,CAAC/B,QAAQ,CAAC,CAAC;EACxC,CAAC,CAAC;AACN;AACA,SAASgC,cAAcA,CAACnC,QAAQ,EAAE;EAAEoC;AAAS,CAAC,EAAE;EAC5C,OAAOpC,QAAQ,CAACE,UAAU,CAAC,YAAY,EAAE;IACrCmC,OAAO,EAAE;MACLD,QAAQ,EAAEA,QAAQ,CAACpB,GAAG,CAAC,CAAC;QAAEsB,YAAY;QAAErB,IAAI;QAAEJ,MAAM;QAAEK;MAAK,CAAC,EAAEqB,KAAK,KAAKvC,QAAQ,CAACE,UAAU,CAAC,YAAY,EAAE;QACtGe,IAAI;QACJJ,MAAM,EAAEE,aAAa,CAACf,QAAQ,EAAEa,MAAM,CAAC;QACvC0B,KAAK,EAAED,YAAY,CAACE,MAAM,GACpBF,YAAY,CAACG,MAAM,CAAC,CAAC,CAACtC,QAAQ,CAAC,CAAC,GAChCoC,KAAK;QACXrB;MACJ,CAAC,CAAC;IACN;EACJ,CAAC,CAAC;AACN;AACA,SAASwB,UAAUA,CAAC1C,QAAQ,EAAE;EAAE2C,GAAG;EAAEtB;AAAK,CAAC,EAAE;EACzC,IAAIuB,MAAM;EACV,QAAQD,GAAG,CAAC1C,IAAI;IACZ,KAAK,OAAO;MACR2C,MAAM,GAAGxC,YAAY,CAACJ,QAAQ,EAAE2C,GAAG,CAACE,OAAO,CAAC;MAC5C;IACJ,KAAK,aAAa;MACdD,MAAM,GAAGrC,kBAAkB,CAACP,QAAQ,EAAE2C,GAAG,CAACG,aAAa,CAAC;MACxD;IACJ,KAAK,SAAS;MACVF,MAAM,GAAGjC,cAAc,CAACX,QAAQ,EAAE2C,GAAG,CAACI,SAAS,CAAC;MAChD;IACJ,KAAK,WAAW;MACZH,MAAM,GAAGhC,gBAAgB,CAACZ,QAAQ,EAAE2C,GAAG,CAACK,WAAW,CAAC;MACpD;IACJ,KAAK,SAAS;MACVJ,MAAM,GAAGxB,cAAc,CAACpB,QAAQ,EAAEqB,IAAI,CAAC;MACvC;IACJ,KAAK,WAAW;MACZuB,MAAM,GAAGhB,gBAAgB,CAAC5B,QAAQ,EAAE2C,GAAG,CAACM,WAAW,CAAC;MACpD;IACJ,KAAK,UAAU;MACXL,MAAM,GAAGb,eAAe,CAAC/B,QAAQ,EAAE2C,GAAG,CAACO,UAAU,CAAC;MAClD;IACJ,KAAK,OAAO;MACRN,MAAM,GAAGZ,YAAY,CAAChC,QAAQ,EAAE2C,GAAG,CAACQ,OAAO,CAAC;MAC5C;IACJ,KAAK,SAAS;MACVP,MAAM,GAAGT,cAAc,CAACnC,QAAQ,EAAE2C,GAAG,CAACS,SAAS,CAAC;MAChD;IACJ;MAASvD,iBAAiB,CAAC8C,GAAG,CAAC1C,IAAI,CAAC;EACxC;EACA,OAAO2C,MAAM;AACjB;AACA,OAAO,SAASS,IAAIA,CAACrD,QAAQ,EAAEiC,KAAK,EAAE;EAClC,OAAOA,KAAK,CAACjB,GAAG,CAAC,CAACkB,CAAC,EAAEK,KAAK,KAAKvC,QAAQ,CAACE,UAAU,CAAC,cAAc,EAAE;IAC/D;IACAoD,EAAE,EAAEf,KAAK,GAAG,CAAC;IACbtC,IAAI,EAAE;MACF0C,GAAG,EAAED,UAAU,CAAC1C,QAAQ,EAAEkC,CAAC,CAAC;MAC5BjB,IAAI,EAAE,EAAE;MACRsC,MAAM,EAAErB,CAAC,CAACqB,MAAM,CAACvC,GAAG,CAAEQ,CAAC,IAAKxB,QAAQ,CAACE,UAAU,CAAC,kBAAkB,EAAE;QAChED,IAAI,EAAEuB,CAAC,CAACrB,QAAQ,CAAC;MACrB,CAAC,CAAC,CAAC;MACHkB,IAAI,EAAEa,CAAC,CAACb,IAAI,CAACL,GAAG,CAAEQ,CAAC,IAAKA,CAAC,CAACC,QAAQ,CAAC,CAAC;IACxC;EACJ,CAAC,CAAC,CAAC;AACP","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}