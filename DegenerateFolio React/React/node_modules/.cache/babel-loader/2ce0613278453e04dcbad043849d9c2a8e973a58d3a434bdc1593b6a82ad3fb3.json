{"ast":null,"code":"import EventEmitter from 'eventemitter3';\nimport { groupD8 } from '../../../../maths/matrix/groupD8.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\nimport { NOOP } from '../../../../utils/misc/NOOP.mjs';\nimport { BufferImageSource } from './sources/BufferSource.mjs';\nimport { TextureSource } from './sources/TextureSource.mjs';\nimport { TextureMatrix } from './TextureMatrix.mjs';\n\"use strict\";\nclass Texture extends EventEmitter {\n  /**\n   * @param {TextureOptions} param0 - Options for the texture\n   */\n  constructor({\n    source,\n    label,\n    frame,\n    orig,\n    trim,\n    defaultAnchor,\n    defaultBorders,\n    rotate,\n    dynamic\n  } = {}) {\n    super();\n    /** unique id for this texture */\n    this.uid = uid(\"texture\");\n    /** A uvs object based on the given frame and the texture source */\n    this.uvs = {\n      x0: 0,\n      y0: 0,\n      x1: 0,\n      y1: 0,\n      x2: 0,\n      y2: 0,\n      x3: 0,\n      y3: 0\n    };\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    this.frame = new Rectangle();\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */\n    this.noFrame = false;\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    this.dynamic = false;\n    /** is it a texture? yes! used for type checking */\n    this.isTexture = true;\n    this.label = label;\n    this.source = source?.source ?? new TextureSource();\n    this.noFrame = !frame;\n    if (frame) {\n      this.frame.copyFrom(frame);\n    } else {\n      const {\n        width,\n        height\n      } = this._source;\n      this.frame.width = width;\n      this.frame.height = height;\n    }\n    this.orig = orig || this.frame;\n    this.trim = trim;\n    this.rotate = rotate ?? 0;\n    this.defaultAnchor = defaultAnchor;\n    this.defaultBorders = defaultBorders;\n    this.destroyed = false;\n    this.dynamic = dynamic || false;\n    this.updateUvs();\n  }\n  set source(value) {\n    if (this._source) {\n      this._source.off(\"resize\", this.update, this);\n    }\n    this._source = value;\n    value.on(\"resize\", this.update, this);\n    this.emit(\"update\", this);\n  }\n  /** the underlying source of the texture (equivalent of baseTexture in v7) */\n  get source() {\n    return this._source;\n  }\n  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n  get textureMatrix() {\n    if (!this._textureMatrix) {\n      this._textureMatrix = new TextureMatrix(this);\n    }\n    return this._textureMatrix;\n  }\n  /** The width of the Texture in pixels. */\n  get width() {\n    return this.orig.width;\n  }\n  /** The height of the Texture in pixels. */\n  get height() {\n    return this.orig.height;\n  }\n  /** Call this function when you have modified the frame of this texture. */\n  updateUvs() {\n    const {\n      uvs,\n      frame\n    } = this;\n    const {\n      width,\n      height\n    } = this._source;\n    const nX = frame.x / width;\n    const nY = frame.y / height;\n    const nW = frame.width / width;\n    const nH = frame.height / height;\n    let rotate = this.rotate;\n    if (rotate) {\n      const w2 = nW / 2;\n      const h2 = nH / 2;\n      const cX = nX + w2;\n      const cY = nY + h2;\n      rotate = groupD8.add(rotate, groupD8.NW);\n      uvs.x0 = cX + w2 * groupD8.uX(rotate);\n      uvs.y0 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x1 = cX + w2 * groupD8.uX(rotate);\n      uvs.y1 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x2 = cX + w2 * groupD8.uX(rotate);\n      uvs.y2 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x3 = cX + w2 * groupD8.uX(rotate);\n      uvs.y3 = cY + h2 * groupD8.uY(rotate);\n    } else {\n      uvs.x0 = nX;\n      uvs.y0 = nY;\n      uvs.x1 = nX + nW;\n      uvs.y1 = nY;\n      uvs.x2 = nX + nW;\n      uvs.y2 = nY + nH;\n      uvs.x3 = nX;\n      uvs.y3 = nY + nH;\n    }\n  }\n  /**\n   * Destroys this texture\n   * @param destroySource - Destroy the source when the texture is destroyed.\n   */\n  destroy(destroySource = false) {\n    if (this._source) {\n      if (destroySource) {\n        this._source.destroy();\n        this._source = null;\n      }\n    }\n    this._textureMatrix = null;\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n  }\n  /** call this if you have modified the `texture outside` of the constructor */\n  update() {\n    if (this.noFrame) {\n      this.frame.width = this._source.width;\n      this.frame.height = this._source.height;\n    }\n    this.updateUvs();\n    this.emit(\"update\", this);\n  }\n  /** @deprecated since 8.0.0 */\n  get baseTexture() {\n    deprecation(v8_0_0, \"Texture.baseTexture is now Texture.source\");\n    return this._source;\n  }\n}\nTexture.EMPTY = new Texture({\n  label: \"EMPTY\",\n  source: new TextureSource({\n    label: \"EMPTY\"\n  })\n});\nTexture.EMPTY.destroy = NOOP;\nTexture.WHITE = new Texture({\n  source: new BufferImageSource({\n    resource: new Uint8Array([255, 255, 255, 255]),\n    width: 1,\n    height: 1,\n    alphaMode: \"premultiply-alpha-on-upload\",\n    label: \"WHITE\"\n  }),\n  label: \"WHITE\"\n});\nTexture.WHITE.destroy = NOOP;\nexport { Texture };","map":{"version":3,"names":["Texture","EventEmitter","constructor","source","label","frame","orig","trim","defaultAnchor","defaultBorders","rotate","dynamic","uid","uvs","x0","y0","x1","y1","x2","y2","x3","y3","Rectangle","noFrame","isTexture","TextureSource","copyFrom","width","height","_source","destroyed","updateUvs","value","off","update","on","emit","textureMatrix","_textureMatrix","TextureMatrix","nX","x","nY","y","nW","nH","w2","h2","cX","cY","groupD8","add","NW","uX","uY","destroy","destroySource","removeAllListeners","baseTexture","deprecation","v8_0_0","EMPTY","NOOP","WHITE","BufferImageSource","resource","Uint8Array","alphaMode"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/shared/texture/Texture.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { groupD8 } from '../../../../maths/matrix/groupD8';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { NOOP } from '../../../../utils/misc/NOOP';\nimport { BufferImageSource } from './sources/BufferSource';\nimport { TextureSource } from './sources/TextureSource';\nimport { TextureMatrix } from './TextureMatrix';\n\nimport type { TextureResourceOrOptions } from './utils/textureFrom';\n\n/**\n * Stores the width of the non-scalable borders, for example when used with {@link scene.NineSlicePlane} texture.\n * @memberof rendering\n */\nexport interface TextureBorders\n{\n    /** left border in pixels */\n    left: number;\n    /** top border in pixels */\n    top: number;\n    /** right border in pixels */\n    right: number;\n    /** bottom border in pixels */\n    bottom: number;\n}\n\n/**\n * The UVs data structure for a texture.\n * @memberof rendering\n */\nexport type UVs = {\n    x0: number;\n    y0: number;\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    x3: number;\n    y3: number;\n};\n\n/**\n * The options that can be passed to a new Texture\n * @memberof rendering\n */\nexport interface TextureOptions\n{\n    /** the underlying texture data that this texture will use  */\n    source?: TextureSource;\n    /** optional label, for debugging */\n    label?: string;\n    /** The rectangle frame of the texture to show */\n    frame?: Rectangle;\n    /** The area of original texture */\n    orig?: Rectangle;\n    /** Trimmed rectangle of original texture */\n    trim?: Rectangle;\n    /** Default anchor point used for sprite placement / rotation */\n    defaultAnchor?: { x: number; y: number };\n    /** Default borders used for 9-slice scaling {@link NineSlicePlane}*/\n    defaultBorders?: TextureBorders;\n    /** indicates how the texture was rotated by texture packer. See {@link groupD8} */\n    rotate?: number;\n    /** set to true if you plan on modifying the uvs of this texture - can affect performance with high numbers of sprites*/\n    dynamic?: boolean;\n}\n\nexport interface BindableTexture\n{\n    source: TextureSource;\n}\n\nexport type TextureSourceLike = TextureSource | TextureResourceOrOptions | string;\n\n/**\n * A texture stores the information that represents an image or part of an image.\n *\n * A texture must have a loaded resource passed to it to work. It does not contain any\n * loading mechanisms.\n *\n * The Assets class can be used to load an texture from a file. This is the recommended\n * way as it will handle the loading and caching for you.\n *\n * ```js\n *\n * const texture = await Asset.load('assets/image.png');\n *\n * // once Assets has loaded the image it will be available via the from method\n * const sameTexture = Texture.from('assets/image.png');\n * // another way to acces the texture once loaded\n * const sameAgainTexture = Asset.get('assets/image.png');\n *\n * const sprite1 = new Sprite(texture);\n *\n * ```\n *\n * It cannot be added to the display list directly; instead use it as the texture for a Sprite.\n * If no frame is provided for a texture, then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * import { Sprite, Texture } from 'pixi.js';\n *\n * const texture = await Asset.load('assets/image.png');\n * const sprite1 = new Sprite(texture);\n * const sprite2 = new Sprite(texture);\n * ```\n *\n * If you didn't pass the texture frame to constructor, it enables `noFrame` mode:\n * it subscribes on baseTexture events, it automatically resizes at the same time as baseTexture.\n * @memberof rendering\n * @class\n */\nexport class Texture extends EventEmitter<{\n    update: Texture\n    destroy: Texture\n}> implements BindableTexture\n{\n    /**\n     * Helper function that creates a returns Texture based on the source you provide.\n     * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n     * @param id - String or Source to create texture from\n     * @param skipCache - Skip adding the texture to the cache\n     * @returns The texture based on the Id provided\n     */\n    public static from: (id: TextureSourceLike, skipCache?: boolean) => Texture;\n\n    /** label used for debugging */\n    public label?: string;\n    /** unique id for this texture */\n    public uid = uid('texture');\n    /**\n     * Has the texture been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    public _source: TextureSource;\n\n    /**\n     * Indicates whether the texture is rotated inside the atlas\n     * set to 2 to compensate for texture packer rotation\n     * set to 6 to compensate for spine packer rotation\n     * can be used to rotate or mirror sprites\n     * See {@link maths.groupD8} for explanation\n     */\n    public readonly rotate: number;\n    /** A uvs object based on the given frame and the texture source */\n    public readonly uvs: UVs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * Anchor point that is used as default if sprite is created with this texture.\n     * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.\n     * @default {0,0}\n     */\n    public readonly defaultAnchor?: { x: number; y: number };\n    /**\n     * Default width of the non-scalable border that is used if 9-slice plane is created with this texture.\n     * @since 7.2.0\n     * @see scene.NineSliceSprite\n     */\n    public readonly defaultBorders?: TextureBorders;\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    public readonly frame = new Rectangle();\n    /** This is the area of original texture, before it was put in atlas. */\n    public readonly orig: Rectangle;\n    /**\n     * This is the trimmed area of original texture, before it was put in atlas\n     * Please call `updateUvs()` after you change coordinates of `trim` manually.\n     */\n    public readonly trim: Rectangle;\n\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */\n    public noFrame = false;\n\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    public dynamic = false;\n\n    private _textureMatrix: TextureMatrix;\n\n    /** is it a texture? yes! used for type checking */\n    public readonly isTexture = true;\n\n    /**\n     * @param {TextureOptions} param0 - Options for the texture\n     */\n    constructor({\n        source,\n        label,\n        frame,\n        orig,\n        trim,\n        defaultAnchor,\n        defaultBorders,\n        rotate,\n        dynamic\n    }: TextureOptions = {})\n    {\n        super();\n\n        this.label = label;\n        this.source = source?.source ?? new TextureSource();\n\n        this.noFrame = !frame;\n\n        if (frame)\n        {\n            this.frame.copyFrom(frame);\n        }\n        else\n        {\n            const { width, height } = this._source;\n\n            this.frame.width = width;\n            this.frame.height = height;\n        }\n\n        this.orig = orig || this.frame;\n        this.trim = trim;\n\n        this.rotate = rotate ?? 0;\n        this.defaultAnchor = defaultAnchor;\n        this.defaultBorders = defaultBorders;\n\n        this.destroyed = false;\n        this.dynamic = dynamic || false;\n\n        this.updateUvs();\n    }\n\n    set source(value: TextureSource)\n    {\n        if (this._source)\n        {\n            this._source.off('resize', this.update, this);\n        }\n\n        this._source = value;\n\n        value.on('resize', this.update, this);\n\n        this.emit('update', this);\n    }\n\n    /** the underlying source of the texture (equivalent of baseTexture in v7) */\n    get source(): TextureSource\n    {\n        return this._source;\n    }\n\n    /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n    get textureMatrix()\n    {\n        if (!this._textureMatrix)\n        {\n            this._textureMatrix = new TextureMatrix(this);\n        }\n\n        return this._textureMatrix;\n    }\n\n    /** The width of the Texture in pixels. */\n    get width(): number\n    {\n        return this.orig.width;\n    }\n\n    /** The height of the Texture in pixels. */\n    get height(): number\n    {\n        return this.orig.height;\n    }\n\n    /** Call this function when you have modified the frame of this texture. */\n    public updateUvs()\n    {\n        const { uvs, frame } = this;\n        const { width, height } = this._source;\n\n        const nX = frame.x / width;\n        const nY = frame.y / height;\n\n        const nW = frame.width / width;\n        const nH = frame.height / height;\n\n        let rotate = this.rotate;\n\n        if (rotate)\n        {\n            // width and height div 2 div baseFrame size\n            const w2 = nW / 2;\n            const h2 = nH / 2;\n\n            // coordinates of center\n            const cX = nX + w2;\n            const cY = nY + h2;\n\n            rotate = groupD8.add(rotate, groupD8.NW); // NW is top-left corner\n            uvs.x0 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y0 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\n            uvs.x1 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y1 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x2 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y2 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x3 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y3 = cY + (h2 * groupD8.uY(rotate));\n        }\n\n        else\n        {\n            uvs.x0 = nX;\n            uvs.y0 = nY;\n            uvs.x1 = nX + nW;\n            uvs.y1 = nY;\n            uvs.x2 = nX + nW;\n            uvs.y2 = nY + nH;\n            uvs.x3 = nX;\n            uvs.y3 = nY + nH;\n        }\n    }\n\n    /**\n     * Destroys this texture\n     * @param destroySource - Destroy the source when the texture is destroyed.\n     */\n    public destroy(destroySource = false)\n    {\n        if (this._source)\n        {\n            if (destroySource)\n            {\n                this._source.destroy();\n                this._source = null;\n            }\n        }\n\n        this._textureMatrix = null;\n        this.destroyed = true;\n        this.emit('destroy', this);\n        this.removeAllListeners();\n    }\n\n    /** call this if you have modified the `texture outside` of the constructor */\n    public update(): void\n    {\n        if (this.noFrame)\n        {\n            this.frame.width = this._source.width;\n            this.frame.height = this._source.height;\n        }\n\n        this.updateUvs();\n        this.emit('update', this);\n    }\n\n    /** @deprecated since 8.0.0 */\n    get baseTexture(): TextureSource\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Texture.baseTexture is now Texture.source');\n        // #endif\n\n        return this._source;\n    }\n\n    /** an Empty Texture used internally by the engine */\n    public static EMPTY: Texture;\n    /** a White texture used internally by the engine */\n    public static WHITE: Texture;\n}\n\nTexture.EMPTY = new Texture({\n    label: 'EMPTY',\n    source: new TextureSource({\n        label: 'EMPTY',\n    })\n});\n\nTexture.EMPTY.destroy = NOOP;\n\nTexture.WHITE = new Texture({\n    source: new BufferImageSource({\n        resource: new Uint8Array([255, 255, 255, 255]),\n        width: 1,\n        height: 1,\n        alphaMode: 'premultiply-alpha-on-upload',\n        label: 'WHITE',\n    }),\n    label: 'WHITE',\n});\n\nTexture.WHITE.destroy = NOOP;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}