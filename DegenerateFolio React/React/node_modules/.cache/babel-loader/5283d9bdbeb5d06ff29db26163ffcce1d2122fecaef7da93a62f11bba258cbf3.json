{"ast":null,"code":"import { stringToU8a, u8aToU8a } from '@polkadot/util';\nimport { pbkdf2Encode } from '../pbkdf2/index.js';\nimport { randomAsU8a } from '../random/index.js';\nimport { sha256AsU8a } from '../sha/index.js';\nimport DEFAULT_WORDLIST from './wordlists/en.js';\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\n/** @internal */\nfunction normalize(str) {\n  return (str || '').normalize('NFKD');\n}\n/** @internal */\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\n/** @internal */\nfunction bytesToBinary(bytes) {\n  return bytes.map(x => x.toString(2).padStart(8, '0')).join('');\n}\n/** @internal */\nfunction deriveChecksumBits(entropyBuffer) {\n  return bytesToBinary(Array.from(sha256AsU8a(entropyBuffer))).slice(0, entropyBuffer.length * 8 / 32);\n}\nexport function mnemonicToSeedSync(mnemonic, password) {\n  return pbkdf2Encode(stringToU8a(normalize(mnemonic)), stringToU8a(`mnemonic${normalize(password)}`)).password;\n}\nexport function mnemonicToEntropy(mnemonic, wordlist = DEFAULT_WORDLIST) {\n  const words = normalize(mnemonic).split(' ');\n  if (words.length % 3 !== 0) {\n    throw new Error(INVALID_MNEMONIC);\n  }\n  // convert word indices to 11 bit binary strings\n  const bits = words.map(word => {\n    const index = wordlist.indexOf(word);\n    if (index === -1) {\n      throw new Error(INVALID_MNEMONIC);\n    }\n    return index.toString(2).padStart(11, '0');\n  }).join('');\n  // split the binary string into ENT/CS\n  const dividerIndex = Math.floor(bits.length / 33) * 32;\n  const entropyBits = bits.slice(0, dividerIndex);\n  const checksumBits = bits.slice(dividerIndex);\n  // calculate the checksum and compare\n  const matched = entropyBits.match(/(.{1,8})/g);\n  const entropyBytes = matched?.map(binaryToByte);\n  if (!entropyBytes || entropyBytes.length % 4 !== 0 || entropyBytes.length < 16 || entropyBytes.length > 32) {\n    throw new Error(INVALID_ENTROPY);\n  }\n  const entropy = u8aToU8a(entropyBytes);\n  if (deriveChecksumBits(entropy) !== checksumBits) {\n    throw new Error(INVALID_CHECKSUM);\n  }\n  return entropy;\n}\nexport function entropyToMnemonic(entropy, wordlist = DEFAULT_WORDLIST) {\n  // 128 <= ENT <= 256\n  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {\n    throw new Error(INVALID_ENTROPY);\n  }\n  const matched = `${bytesToBinary(Array.from(entropy))}${deriveChecksumBits(entropy)}`.match(/(.{1,11})/g);\n  const mapped = matched?.map(b => wordlist[binaryToByte(b)]);\n  if (!mapped || mapped.length < 12) {\n    throw new Error('Unable to map entropy to mnemonic');\n  }\n  return mapped.join(' ');\n}\nexport function generateMnemonic(numWords, wordlist) {\n  return entropyToMnemonic(randomAsU8a(numWords / 3 * 4), wordlist);\n}\nexport function validateMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n  } catch {\n    return false;\n  }\n  return true;\n}","map":{"version":3,"names":["stringToU8a","u8aToU8a","pbkdf2Encode","randomAsU8a","sha256AsU8a","DEFAULT_WORDLIST","INVALID_MNEMONIC","INVALID_ENTROPY","INVALID_CHECKSUM","normalize","str","binaryToByte","bin","parseInt","bytesToBinary","bytes","map","x","toString","padStart","join","deriveChecksumBits","entropyBuffer","Array","from","slice","length","mnemonicToSeedSync","mnemonic","password","mnemonicToEntropy","wordlist","words","split","Error","bits","word","index","indexOf","dividerIndex","Math","floor","entropyBits","checksumBits","matched","match","entropyBytes","entropy","entropyToMnemonic","mapped","b","generateMnemonic","numWords","validateMnemonic"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util-crypto/mnemonic/bip39.js"],"sourcesContent":["import { stringToU8a, u8aToU8a } from '@polkadot/util';\nimport { pbkdf2Encode } from '../pbkdf2/index.js';\nimport { randomAsU8a } from '../random/index.js';\nimport { sha256AsU8a } from '../sha/index.js';\nimport DEFAULT_WORDLIST from './wordlists/en.js';\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\n/** @internal */\nfunction normalize(str) {\n    return (str || '').normalize('NFKD');\n}\n/** @internal */\nfunction binaryToByte(bin) {\n    return parseInt(bin, 2);\n}\n/** @internal */\nfunction bytesToBinary(bytes) {\n    return bytes.map((x) => x.toString(2).padStart(8, '0')).join('');\n}\n/** @internal */\nfunction deriveChecksumBits(entropyBuffer) {\n    return bytesToBinary(Array.from(sha256AsU8a(entropyBuffer))).slice(0, (entropyBuffer.length * 8) / 32);\n}\nexport function mnemonicToSeedSync(mnemonic, password) {\n    return pbkdf2Encode(stringToU8a(normalize(mnemonic)), stringToU8a(`mnemonic${normalize(password)}`)).password;\n}\nexport function mnemonicToEntropy(mnemonic, wordlist = DEFAULT_WORDLIST) {\n    const words = normalize(mnemonic).split(' ');\n    if (words.length % 3 !== 0) {\n        throw new Error(INVALID_MNEMONIC);\n    }\n    // convert word indices to 11 bit binary strings\n    const bits = words\n        .map((word) => {\n        const index = wordlist.indexOf(word);\n        if (index === -1) {\n            throw new Error(INVALID_MNEMONIC);\n        }\n        return index.toString(2).padStart(11, '0');\n    })\n        .join('');\n    // split the binary string into ENT/CS\n    const dividerIndex = Math.floor(bits.length / 33) * 32;\n    const entropyBits = bits.slice(0, dividerIndex);\n    const checksumBits = bits.slice(dividerIndex);\n    // calculate the checksum and compare\n    const matched = entropyBits.match(/(.{1,8})/g);\n    const entropyBytes = matched?.map(binaryToByte);\n    if (!entropyBytes || (entropyBytes.length % 4 !== 0) || (entropyBytes.length < 16) || (entropyBytes.length > 32)) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    const entropy = u8aToU8a(entropyBytes);\n    if (deriveChecksumBits(entropy) !== checksumBits) {\n        throw new Error(INVALID_CHECKSUM);\n    }\n    return entropy;\n}\nexport function entropyToMnemonic(entropy, wordlist = DEFAULT_WORDLIST) {\n    // 128 <= ENT <= 256\n    if ((entropy.length % 4 !== 0) || (entropy.length < 16) || (entropy.length > 32)) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    const matched = `${bytesToBinary(Array.from(entropy))}${deriveChecksumBits(entropy)}`.match(/(.{1,11})/g);\n    const mapped = matched?.map((b) => wordlist[binaryToByte(b)]);\n    if (!mapped || (mapped.length < 12)) {\n        throw new Error('Unable to map entropy to mnemonic');\n    }\n    return mapped.join(' ');\n}\nexport function generateMnemonic(numWords, wordlist) {\n    return entropyToMnemonic(randomAsU8a((numWords / 3) * 4), wordlist);\n}\nexport function validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch {\n        return false;\n    }\n    return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}