{"ast":null,"code":"import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { boundsPool } from './utils/matrixAndBoundsPool.mjs';\n\"use strict\";\nconst tempMatrix = new Matrix();\nfunction getFastGlobalBounds(target, bounds) {\n  bounds.clear();\n  _getGlobalBoundsRecursive(target, bounds);\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  if (!target.renderGroup) {\n    bounds.applyMatrix(target.parentRenderGroup.worldTransform);\n  } else {\n    bounds.applyMatrix(target.renderGroup.localTransform);\n  }\n  return bounds;\n}\nfunction _getGlobalBoundsRecursive(target, bounds) {\n  if (target.localDisplayStatus !== 7 || !target.measurable) {\n    return;\n  }\n  const manageEffects = !!target.effects.length;\n  let localBounds = bounds;\n  if (target.renderGroup || manageEffects) {\n    localBounds = boundsPool.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, target.worldTransform);\n  } else {\n    if (target.renderPipeId) {\n      const viewBounds = target.bounds;\n      localBounds.addFrame(viewBounds.minX, viewBounds.minY, viewBounds.maxX, viewBounds.maxY, target.groupTransform);\n    }\n    const children = target.children;\n    for (let i = 0; i < children.length; i++) {\n      _getGlobalBoundsRecursive(children[i], localBounds);\n    }\n  }\n  if (manageEffects) {\n    let advanced = false;\n    for (let i = 0; i < target.effects.length; i++) {\n      if (target.effects[i].addBounds) {\n        if (!advanced) {\n          advanced = true;\n          localBounds.applyMatrix(target.parentRenderGroup.worldTransform);\n        }\n        target.effects[i].addBounds(localBounds, true);\n      }\n    }\n    if (advanced) {\n      localBounds.applyMatrix(target.parentRenderGroup.worldTransform.copyTo(tempMatrix).invert());\n      bounds.addBounds(localBounds, target.relativeGroupTransform);\n    }\n    bounds.addBounds(localBounds);\n    boundsPool.return(localBounds);\n  } else if (target.renderGroup) {\n    bounds.addBounds(localBounds, target.relativeGroupTransform);\n    boundsPool.return(localBounds);\n  }\n}\nexport { _getGlobalBoundsRecursive, getFastGlobalBounds };","map":{"version":3,"names":["tempMatrix","Matrix","getFastGlobalBounds","target","bounds","clear","_getGlobalBoundsRecursive","isValid","set","renderGroup","applyMatrix","parentRenderGroup","worldTransform","localTransform","localDisplayStatus","measurable","manageEffects","effects","length","localBounds","boundsPool","get","boundsArea","addRect","renderPipeId","viewBounds","addFrame","minX","minY","maxX","maxY","groupTransform","children","i","advanced","addBounds","copyTo","invert","relativeGroupTransform","return"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/container/bounds/getFastGlobalBounds.ts"],"sourcesContent":["import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\n// TODO could we cache local bounds on the render groups?\n\nconst tempMatrix = new Matrix();\n\n/**\n * Does exactly the same as getGlobalBounds, but does instead makes use of transforming AABBs\n * of the various children within the scene graph. This is much faster, but less accurate.\n *\n * the result will never be smaller - only ever slightly larger (in most cases, it will be the same).\n * @param target - The target container to get the bounds from\n * @param bounds - The output bounds object.\n * @returns The bounds.\n */\nexport function getFastGlobalBounds(target: Container, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    _getGlobalBoundsRecursive(target, bounds);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    if (!target.renderGroup)\n    {\n        bounds.applyMatrix(target.parentRenderGroup.worldTransform);\n    }\n    else\n    {\n        bounds.applyMatrix(target.renderGroup.localTransform);\n    }\n\n    return bounds;\n}\n\nexport function _getGlobalBoundsRecursive(\n    target: Container,\n    bounds: Bounds,\n)\n{\n    if (target.localDisplayStatus !== 0b111 || !target.measurable)\n    {\n        return;\n    }\n\n    const manageEffects = !!target.effects.length;\n\n    let localBounds = bounds;\n\n    if (target.renderGroup || manageEffects)\n    {\n        localBounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, target.worldTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            const viewBounds = (target as Renderable).bounds;\n\n            localBounds.addFrame(\n                viewBounds.minX,\n                viewBounds.minY,\n                viewBounds.maxX,\n                viewBounds.maxY,\n                target.groupTransform\n            );\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getGlobalBoundsRecursive(children[i], localBounds);\n        }\n    }\n\n    if (manageEffects)\n    {\n        let advanced = false;\n\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            if (target.effects[i].addBounds)\n            {\n                if (!advanced)\n                {\n                    advanced = true;\n                    localBounds.applyMatrix(target.parentRenderGroup.worldTransform);\n                }\n\n                target.effects[i].addBounds(localBounds, true);\n            }\n        }\n\n        if (advanced)\n        {\n            localBounds.applyMatrix(target.parentRenderGroup.worldTransform.copyTo(tempMatrix).invert());\n            bounds.addBounds(localBounds, target.relativeGroupTransform);\n        }\n\n        bounds.addBounds(localBounds);\n        boundsPool.return(localBounds);\n    }\n    else if (target.renderGroup)\n    {\n        bounds.addBounds(localBounds, target.relativeGroupTransform);\n        boundsPool.return(localBounds);\n    }\n}\n"],"mappings":";;;AASA,MAAMA,UAAA,GAAa,IAAIC,MAAO;AAWd,SAAAC,oBAAoBC,MAAA,EAAmBC,MACvD;EACIA,MAAA,CAAOC,KAAM;EAEbC,yBAAA,CAA0BH,MAAA,EAAQC,MAAM;EAEpC,KAACA,MAAA,CAAOG,OACZ;IACIH,MAAA,CAAOI,GAAI,IAAG,CAAG,KAAG,CAAC;EAAA;EAGrB,KAACL,MAAA,CAAOM,WACZ;IACWL,MAAA,CAAAM,WAAA,CAAYP,MAAO,CAAAQ,iBAAA,CAAkBC,cAAc;EAAA,CAG9D;IACWR,MAAA,CAAAM,WAAA,CAAYP,MAAO,CAAAM,WAAA,CAAYI,cAAc;EAAA;EAGjD,OAAAT,MAAA;AACX;AAEgB,SAAAE,0BACZH,MAAA,EACAC,MAEJ;EACI,IAAID,MAAO,CAAAW,kBAAA,KAAuB,CAAS,KAACX,MAAA,CAAOY,UACnD;IACI;EAAA;EAGJ,MAAMC,aAAgB,IAAC,CAACb,MAAA,CAAOc,OAAQ,CAAAC,MAAA;EAEvC,IAAIC,WAAc,GAAAf,MAAA;EAEd,IAAAD,MAAA,CAAOM,WAAA,IAAeO,aAC1B;IACkBG,WAAA,GAAAC,UAAA,CAAWC,GAAI,GAAEhB,KAAM;EAAA;EAGzC,IAAIF,MAAA,CAAOmB,UACX;IACIlB,MAAA,CAAOmB,OAAQ,CAAApB,MAAA,CAAOmB,UAAY,EAAAnB,MAAA,CAAOS,cAAc;EAAA,CAG3D;IACI,IAAIT,MAAA,CAAOqB,YACX;MACI,MAAMC,UAAA,GAActB,MAAsB,CAAAC,MAAA;MAE9Be,WAAA,CAAAO,QAAA,CACRD,UAAW,CAAAE,IAAA,EACXF,UAAW,CAAAG,IAAA,EACXH,UAAW,CAAAI,IAAA,EACXJ,UAAW,CAAAK,IAAA,EACX3B,MAAO,CAAA4B,cAAA,CACX;IAAA;IAGJ,MAAMC,QAAA,GAAW7B,MAAO,CAAA6B,QAAA;IAExB,SAASC,CAAI,MAAGA,CAAI,GAAAD,QAAA,CAASd,MAAA,EAAQe,CACrC;MAC8B3B,yBAAA,CAAA0B,QAAA,CAASC,CAAC,GAAGd,WAAW;IAAA;EACtD;EAGJ,IAAIH,aACJ;IACI,IAAIkB,QAAW;IAEf,SAASD,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAI9B,MAAO,CAAAc,OAAA,CAAQC,MAAA,EAAQe,CAC3C;MACI,IAAI9B,MAAO,CAAAc,OAAA,CAAQgB,CAAC,EAAEE,SACtB;QACI,IAAI,CAACD,QACL;UACeA,QAAA;UACCf,WAAA,CAAAT,WAAA,CAAYP,MAAO,CAAAQ,iBAAA,CAAkBC,cAAc;QAAA;QAGnET,MAAA,CAAOc,OAAQ,CAAAgB,CAAC,CAAE,CAAAE,SAAA,CAAUhB,WAAA,EAAa,IAAI;MAAA;IACjD;IAGJ,IAAIe,QACJ;MACgBf,WAAA,CAAAT,WAAA,CAAYP,MAAA,CAAOQ,iBAAkB,CAAAC,cAAA,CAAewB,MAAA,CAAOpC,UAAU,EAAEqC,MAAA,EAAQ;MACpFjC,MAAA,CAAA+B,SAAA,CAAUhB,WAAa,EAAAhB,MAAA,CAAOmC,sBAAsB;IAAA;IAG/DlC,MAAA,CAAO+B,SAAA,CAAUhB,WAAW;IAC5BC,UAAA,CAAWmB,MAAA,CAAOpB,WAAW;EAAA,CACjC,UACShB,MAAA,CAAOM,WAChB;IACWL,MAAA,CAAA+B,SAAA,CAAUhB,WAAa,EAAAhB,MAAA,CAAOmC,sBAAsB;IAC3DlB,UAAA,CAAWmB,MAAA,CAAOpB,WAAW;EAAA;AAErC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}