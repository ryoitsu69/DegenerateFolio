{"ast":null,"code":"\"use strict\";\n\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getMessage = void 0;\nconst web3_utils_1 = require(\"web3-utils\");\nconst web3_errors_1 = require(\"web3-errors\");\nconst encode_js_1 = require(\"./coders/encode.js\");\nconst TYPE_REGEX = /^\\w+/;\nconst ARRAY_REGEX = /^(.*)\\[([0-9]*?)]$/;\n/**\n * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once\n * in the resulting array.\n */\nconst getDependencies = function (typedData, type) {\n  let dependencies = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const match = type.match(TYPE_REGEX);\n  const actualType = match[0];\n  if (dependencies.includes(actualType)) {\n    return dependencies;\n  }\n  if (!typedData.types[actualType]) {\n    return dependencies;\n  }\n  return [actualType, ...typedData.types[actualType].reduce((previous, _type) => [...previous, ...getDependencies(typedData, _type.type, previous).filter(dependency => !previous.includes(dependency))], [])];\n};\n/**\n * Encode a type to a string. All dependant types are alphabetically sorted.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {Options} [options]\n * @return {string}\n */\nconst encodeType = (typedData, type) => {\n  const [primary, ...dependencies] = getDependencies(typedData, type);\n  // eslint-disable-next-line @typescript-eslint/require-array-sort-compare\n  const types = [primary, ...dependencies.sort()];\n  return types.map(dependency => // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  \"\".concat(dependency, \"(\").concat(typedData.types[dependency].map(_type => \"\".concat(_type.type, \" \").concat(_type.name)), \")\")).join('');\n};\n/**\n * Get a type string as hash.\n */\nconst getTypeHash = (typedData, type) => (0, web3_utils_1.keccak256)(encodeType(typedData, type));\n/**\n * Get encoded data as a hash. The data should be a key -> value object with all the required values. All dependant\n * types are automatically encoded.\n */\nconst getStructHash = (typedData, type, data) => (0, web3_utils_1.keccak256)(encodeData(typedData, type, data));\n/**\n * Get the EIP-191 encoded message to sign, from the typedData object. If `hash` is enabled, the message will be hashed\n * with Keccak256.\n */\nconst getMessage = (typedData, hash) => {\n  const EIP_191_PREFIX = '1901';\n  const message = \"0x\".concat(EIP_191_PREFIX).concat(getStructHash(typedData, 'EIP712Domain', typedData.domain).substring(2)).concat(getStructHash(typedData, typedData.primaryType, typedData.message).substring(2));\n  if (hash) {\n    return (0, web3_utils_1.keccak256)(message);\n  }\n  return message;\n};\nexports.getMessage = getMessage;\n/**\n * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of\n * an array of ABI compatible types, and an array of corresponding values.\n */\nconst encodeValue = (typedData, type, data) => {\n  const match = type.match(ARRAY_REGEX);\n  // Checks for array types\n  if (match) {\n    const arrayType = match[1];\n    const length = Number(match[2]) || undefined;\n    if (!Array.isArray(data)) {\n      throw new web3_errors_1.AbiError('Cannot encode data: value is not of array type', {\n        data\n      });\n    }\n    if (length && data.length !== length) {\n      throw new web3_errors_1.AbiError(\"Cannot encode data: expected length of \".concat(length, \", but got \").concat(data.length), {\n        data\n      });\n    }\n    const encodedData = data.map(item => encodeValue(typedData, arrayType, item));\n    const types = encodedData.map(item => item[0]);\n    const values = encodedData.map(item => item[1]);\n    return ['bytes32', (0, web3_utils_1.keccak256)((0, encode_js_1.encodeParameters)(types, values))];\n  }\n  if (typedData.types[type]) {\n    return ['bytes32', getStructHash(typedData, type, data)];\n  }\n  // Strings and arbitrary byte arrays are hashed to bytes32\n  if (type === 'string') {\n    return ['bytes32', (0, web3_utils_1.keccak256)(data)];\n  }\n  if (type === 'bytes') {\n    return ['bytes32', (0, web3_utils_1.keccak256)(data)];\n  }\n  return [type, data];\n};\n/**\n * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values. All\n * dependant types are automatically encoded.\n */\nconst encodeData = (typedData, type, data) => {\n  const [types, values] = typedData.types[type].reduce((_ref, field) => {\n    let [_types, _values] = _ref;\n    if ((0, web3_utils_1.isNullish)(data[field.name]) || (0, web3_utils_1.isNullish)(data[field.name])) {\n      throw new web3_errors_1.AbiError(\"Cannot encode data: missing data for '\".concat(field.name, \"'\"), {\n        data,\n        field\n      });\n    }\n    const value = data[field.name];\n    const [_type, encodedValue] = encodeValue(typedData, field.type, value);\n    return [[..._types, _type], [..._values, encodedValue]];\n  }, [['bytes32'], [getTypeHash(typedData, type)]]);\n  return (0, encode_js_1.encodeParameters)(types, values);\n};","map":{"version":3,"names":["web3_utils_1","require","web3_errors_1","encode_js_1","TYPE_REGEX","ARRAY_REGEX","getDependencies","typedData","type","dependencies","arguments","length","undefined","match","actualType","includes","types","reduce","previous","_type","filter","dependency","encodeType","primary","sort","map","concat","name","join","getTypeHash","keccak256","getStructHash","data","encodeData","getMessage","hash","EIP_191_PREFIX","message","domain","substring","primaryType","exports","encodeValue","arrayType","Number","Array","isArray","AbiError","encodedData","item","values","encodeParameters","_ref","field","_types","_values","isNullish","value","encodedValue"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/web3-eth-abi/src/eip_712.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * The web3.eth.abi functions let you encode and decode parameters to ABI (Application Binary Interface) for function calls to the EVM (Ethereum Virtual Machine).\n * \n *  For using Web3 ABI functions, first install Web3 package using `npm i web3` or `yarn add web3`.\n * After that, Web3 ABI functions will be available. \n * ```ts\n * import { Web3 } from 'web3';\n * \n * const web3 = new Web3();\n * const encoded = web3.eth.abi.encodeFunctionSignature({\n *     name: 'myMethod',\n *     type: 'function',\n *     inputs: [{\n *         type: 'uint256',\n *         name: 'myNumber'\n *     },{\n *         type: 'string',\n *         name: 'myString'\n *     }]\n * });\n * \n * ```\n * \n * For using individual package install `web3-eth-abi` package using `npm i web3-eth-abi` or `yarn add web3-eth-abi` and only import required functions.\n * This is more efficient approach for building lightweight applications. \n * ```ts\n * import { encodeFunctionSignature } from 'web3-eth-abi';\n * \n * const encoded = encodeFunctionSignature({\n *     name: 'myMethod',\n *     type: 'function',\n *     inputs: [{\n *         type: 'uint256',\n *         name: 'myNumber'\n *     },{\n *         type: 'string',\n *         name: 'myString'\n *     }]\n * });\n * \n * ```\n * \n *  @module ABI\n */\n\n\n// This code was taken from: https://github.com/Mrtenz/eip-712/tree/master\n\nimport { Eip712TypedData } from 'web3-types';\nimport { isNullish, keccak256 } from 'web3-utils';\nimport { AbiError } from 'web3-errors';\nimport { encodeParameters } from './coders/encode.js';\n\nconst TYPE_REGEX = /^\\w+/;\nconst ARRAY_REGEX = /^(.*)\\[([0-9]*?)]$/;\n\n/**\n * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once\n * in the resulting array.\n */\nconst getDependencies = (\n\ttypedData: Eip712TypedData,\n\ttype: string,\n\tdependencies: string[] = [],\n): string[] => {\n\tconst match = type.match(TYPE_REGEX)!;\n\tconst actualType = match[0];\n\tif (dependencies.includes(actualType)) {\n\t\treturn dependencies;\n\t}\n\n\tif (!typedData.types[actualType]) {\n\t\treturn dependencies;\n\t}\n\n\treturn [\n\t\tactualType,\n\t\t...typedData.types[actualType].reduce<string[]>(\n\t\t\t(previous, _type) => [\n\t\t\t\t...previous,\n\t\t\t\t...getDependencies(typedData, _type.type, previous).filter(\n\t\t\t\t\tdependency => !previous.includes(dependency),\n\t\t\t\t),\n\t\t\t],\n\t\t\t[],\n\t\t),\n\t];\n};\n\n/**\n * Encode a type to a string. All dependant types are alphabetically sorted.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {Options} [options]\n * @return {string}\n */\nconst encodeType = (typedData: Eip712TypedData, type: string): string => {\n\tconst [primary, ...dependencies] = getDependencies(typedData, type);\n\t// eslint-disable-next-line @typescript-eslint/require-array-sort-compare\n\tconst types = [primary, ...dependencies.sort()];\n\n\treturn types\n\t\t.map(\n\t\t\tdependency =>\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n\t\t\t\t`${dependency}(${typedData.types[dependency].map(\n\t\t\t\t\t_type => `${_type.type} ${_type.name}`,\n\t\t\t\t)})`,\n\t\t)\n\t\t.join('');\n};\n\n/**\n * Get a type string as hash.\n */\nconst getTypeHash = (typedData: Eip712TypedData, type: string) =>\n\tkeccak256(encodeType(typedData, type));\n\n/**\n * Get encoded data as a hash. The data should be a key -> value object with all the required values. All dependant\n * types are automatically encoded.\n */\nconst getStructHash = (\n\ttypedData: Eip712TypedData,\n\ttype: string,\n\tdata: Record<string, unknown>,\n\t// eslint-disable-next-line  no-use-before-define\n): string => keccak256(encodeData(typedData, type, data));\n\n/**\n * Get the EIP-191 encoded message to sign, from the typedData object. If `hash` is enabled, the message will be hashed\n * with Keccak256.\n */\nexport const getMessage = (typedData: Eip712TypedData, hash?: boolean): string => {\n\tconst EIP_191_PREFIX = '1901';\n\tconst message = `0x${EIP_191_PREFIX}${getStructHash(\n\t\ttypedData,\n\t\t'EIP712Domain',\n\t\ttypedData.domain as Record<string, unknown>,\n\t).substring(2)}${getStructHash(typedData, typedData.primaryType, typedData.message).substring(\n\t\t2,\n\t)}`;\n\n\tif (hash) {\n\t\treturn keccak256(message);\n\t}\n\n\treturn message;\n};\n\n/**\n * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of\n * an array of ABI compatible types, and an array of corresponding values.\n */\nconst encodeValue = (\n\ttypedData: Eip712TypedData,\n\ttype: string,\n\tdata: unknown,\n): [string, string | Uint8Array | number] => {\n\tconst match = type.match(ARRAY_REGEX);\n\n\t// Checks for array types\n\tif (match) {\n\t\tconst arrayType = match[1];\n\t\tconst length = Number(match[2]) || undefined;\n\n\t\tif (!Array.isArray(data)) {\n\t\t\tthrow new AbiError('Cannot encode data: value is not of array type', {\n\t\t\t\tdata,\n\t\t\t});\n\t\t}\n\n\t\tif (length && data.length !== length) {\n\t\t\tthrow new AbiError(\n\t\t\t\t`Cannot encode data: expected length of ${length}, but got ${data.length}`,\n\t\t\t\t{\n\t\t\t\t\tdata,\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\n\t\tconst encodedData = data.map(item => encodeValue(typedData, arrayType, item));\n\t\tconst types = encodedData.map(item => item[0]);\n\t\tconst values = encodedData.map(item => item[1]);\n\n\t\treturn ['bytes32', keccak256(encodeParameters(types, values))];\n\t}\n\n\tif (typedData.types[type]) {\n\t\treturn ['bytes32', getStructHash(typedData, type, data as Record<string, unknown>)];\n\t}\n\n\t// Strings and arbitrary byte arrays are hashed to bytes32\n\tif (type === 'string') {\n\t\treturn ['bytes32', keccak256(data as string)];\n\t}\n\n\tif (type === 'bytes') {\n\t\treturn ['bytes32', keccak256(data as string)];\n\t}\n\n\treturn [type, data as string];\n};\n\n/**\n * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values. All\n * dependant types are automatically encoded.\n */\nconst encodeData = (\n\ttypedData: Eip712TypedData,\n\ttype: string,\n\tdata: Record<string, unknown>,\n): string => {\n\tconst [types, values] = typedData.types[type].reduce<[string[], unknown[]]>(\n\t\t([_types, _values], field) => {\n\t\t\tif (isNullish(data[field.name]) || isNullish(data[field.name])) {\n\t\t\t\tthrow new AbiError(`Cannot encode data: missing data for '${field.name}'`, {\n\t\t\t\t\tdata,\n\t\t\t\t\tfield,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst value = data[field.name];\n\t\t\tconst [_type, encodedValue] = encodeValue(typedData, field.type, value);\n\n\t\t\treturn [\n\t\t\t\t[..._types, _type],\n\t\t\t\t[..._values, encodedValue],\n\t\t\t];\n\t\t},\n\t\t[['bytes32'], [getTypeHash(typedData, type)]],\n\t);\n\n\treturn encodeParameters(types, values);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}