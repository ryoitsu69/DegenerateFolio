{"ast":null,"code":"import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\"use strict\";\nclass BufferResource extends EventEmitter {\n  /**\n   * Create a new Buffer Resource.\n   * @param options - The options for the buffer resource\n   * @param options.buffer - The underlying buffer that this resource is using\n   * @param options.offset - The offset of the buffer this resource is using.\n   * If not provided, then it will use the offset of the buffer.\n   * @param options.size - The size of the buffer this resource is using.\n   * If not provided, then it will use the size of the buffer.\n   */\n  constructor({\n    buffer,\n    offset,\n    size\n  }) {\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /**\n     * a unique id for this uniform group used through the renderer\n     * @internal\n     * @ignore\n     */\n    this.uid = uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    this._resourceType = \"bufferResource\";\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    this._touched = 0;\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     * @ignore\n     */\n    this._bufferResource = true;\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    this.buffer = buffer;\n    this.offset = offset | 0;\n    this.size = size;\n    this.buffer.on(\"change\", this.onBufferChange, this);\n  }\n  onBufferChange() {\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n  }\n  /**\n   * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n   * if you want to destroy it as well, or code will explode\n   * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n   */\n  destroy(destroyBuffer = false) {\n    this.destroyed = true;\n    if (destroyBuffer) {\n      this.buffer.destroy();\n    }\n    this.emit(\"change\", this);\n    this.buffer = null;\n  }\n}\nexport { BufferResource };","map":{"version":3,"names":["BufferResource","EventEmitter","constructor","buffer","offset","size","uid","_resourceType","_touched","_resourceId","_bufferResource","destroyed","on","onBufferChange","emit","destroy","destroyBuffer"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/shared/buffer/BufferResource.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from './Buffer';\n\n/**\n * A resource that can be bound to a bind group and used in a shader.\n * Whilst a buffer can be used as a resource, this class allows you to specify an offset and size of the buffer to use.\n * This is useful if you have a large buffer and only part of it is used in a shader.\n *\n * This resource, will listen for changes on the underlying buffer and emit a itself if the buffer changes shape.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array(1000),\n *    usage: BufferUsage.UNIFORM,\n * });\n * // Create a buffer resource that uses the first 100 bytes of a buffer\n * const bufferResource = new BufferResource({\n *    buffer,\n *    offset: 0,\n *    size: 100,\n * });\n * @memberof rendering\n */\nexport class BufferResource extends EventEmitter<{\n    change: BindResource,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /**\n     * a unique id for this uniform group used through the renderer\n     * @internal\n     * @ignore\n     */\n    public readonly uid = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    public readonly _resourceType = 'bufferResource';\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    public _touched = 0;\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    public _resourceId = uid('resource');\n\n    /** the underlying buffer that this resource is using */\n    public buffer: Buffer;\n    /** the offset of the buffer this resource is using. If not provided, then it will use the offset of the buffer. */\n    public readonly offset: number;\n    /** the size of the buffer this resource is using. If not provided, then it will use the size of the buffer. */\n    public readonly size: number;\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     * @ignore\n     */\n    public readonly _bufferResource = true;\n\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Create a new Buffer Resource.\n     * @param options - The options for the buffer resource\n     * @param options.buffer - The underlying buffer that this resource is using\n     * @param options.offset - The offset of the buffer this resource is using.\n     * If not provided, then it will use the offset of the buffer.\n     * @param options.size - The size of the buffer this resource is using.\n     * If not provided, then it will use the size of the buffer.\n     */\n    constructor({ buffer, offset, size }: { buffer: Buffer; offset?: number; size?: number; })\n    {\n        super();\n\n        this.buffer = buffer;\n        this.offset = offset | 0;\n        this.size = size;\n\n        this.buffer.on('change', this.onBufferChange, this);\n    }\n\n    protected onBufferChange(): void\n    {\n        this._resourceId = uid('resource');\n\n        this.emit('change', this);\n    }\n\n    /**\n     * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n     * if you want to destroy it as well, or code will explode\n     * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n     */\n    public destroy(destroyBuffer = false): void\n    {\n        this.destroyed = true;\n\n        if (destroyBuffer)\n        {\n            this.buffer.destroy();\n        }\n\n        this.emit('change', this);\n\n        this.buffer = null;\n    }\n}\n"],"mappings":";;;AA0BO,MAAMA,cAAA,SAAuBC,YAGpC;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EA+DIC,WAAYA,CAAA;IAAEC,MAAQ;IAAAC,MAAA;IAAQC;EAAA,CAC9B;IACU;IArDV;AAAA;AAAA;AAAA;AAAA;IAAA;AAAA;AAAA;AAAA;AAAA;IAAgB,KAAAC,GAAA,GAAMA,GAAA,CAAI,QAAQ;IAOlC;AAAA;AAAA;AAAA;AAAA;IAAA,KAAgBC,aAAgB;IAOhC;AAAA;AAAA;AAAA;AAAA;IAAA,KAAOC,QAAW;IAOlB;AAAA;AAAA;AAAA;AAAA;IAAO,KAAAC,WAAA,GAAcH,GAAA,CAAI,UAAU;IAanC;AAAA;AAAA;AAAA;AAAA;IAAA,KAAgBI,eAAkB;IAMlC;AAAA;AAAA;AAAA;IAAA,KAAOC,SAAY;IAef,KAAKR,MAAS,GAAAA,MAAA;IACd,KAAKC,MAAA,GAASA,MAAS;IACvB,KAAKC,IAAO,GAAAA,IAAA;IAEZ,KAAKF,MAAO,CAAAS,EAAA,CAAG,QAAU,OAAKC,cAAA,EAAgB,IAAI;EAAA;EAG5CA,cACVA,CAAA;IACS,KAAAJ,WAAA,GAAcH,GAAA,CAAI,UAAU;IAE5B,KAAAQ,IAAA,CAAK,UAAU,IAAI;EAAA;EAC5B;AAAA;AAAA;AAAA;AAAA;EAOOC,QAAQC,aAAA,GAAgB,KAC/B;IACI,KAAKL,SAAY;IAEjB,IAAIK,aACJ;MACI,KAAKb,MAAA,CAAOY,OAAQ;IAAA;IAGnB,KAAAD,IAAA,CAAK,UAAU,IAAI;IAExB,KAAKX,MAAS;EAAA;AAEtB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}