{"ast":null,"code":"import _defineProperty from \"/home/ryoitsu/Documents/test/react-todo-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { stringify } from '@polkadot/util';\n/*\n * Creates a new health checker.\n *\n * The role of the health checker is to report to the user the health of a smoldot chain.\n *\n * In order to use it, start by creating a health checker, and call `setSendJsonRpc` to set the\n * way to send a JSON-RPC request to a chain. The health checker is disabled by default. Use\n * `start()` in order to start the health checks. The `start()` function must be passed a callback called\n * when an update to the health of the node is available.\n *\n * In order to send a JSON-RPC request to the chain, you **must** use the `sendJsonRpc` function\n * of the health checker. The health checker rewrites the `id` of the requests it receives.\n *\n * When the chain send a JSON-RPC response, it must be passed to `responsePassThrough()`. This\n * function intercepts the responses destined to the requests that have been emitted by the health\n * checker and returns `null`. If the response doesn't concern the health checker, the response is\n * simply returned by the function.\n *\n * # How it works\n *\n * The health checker periodically calls the `system_health` JSON-RPC call in order to determine\n * the health of the chain.\n *\n * In addition to this, as long as the health check reports that `isSyncing` is `true`, the\n * health checker also maintains a subscription to new best blocks using `chain_subscribeNewHeads`.\n * Whenever a new block is notified, a health check is performed immediately in order to determine\n * whether `isSyncing` has changed to `false`.\n *\n * Thanks to this subscription, the latency of the report of the switch from `isSyncing: true` to\n * `isSyncing: false` is very low.\n *\n */\nexport function healthChecker() {\n  // `null` if health checker is not started.\n  let checker = null;\n  let sendJsonRpc = null;\n  return {\n    responsePassThrough: jsonRpcResponse => {\n      if (checker === null) {\n        return jsonRpcResponse;\n      }\n      return checker.responsePassThrough(jsonRpcResponse);\n    },\n    sendJsonRpc: request => {\n      if (!sendJsonRpc) {\n        throw new Error('setSendJsonRpc must be called before sending requests');\n      }\n      if (checker === null) {\n        sendJsonRpc(request);\n      } else {\n        checker.sendJsonRpc(request);\n      }\n    },\n    setSendJsonRpc: cb => {\n      sendJsonRpc = cb;\n    },\n    start: healthCallback => {\n      if (checker !== null) {\n        throw new Error(\"Can't start the health checker multiple times in parallel\");\n      } else if (!sendJsonRpc) {\n        throw new Error('setSendJsonRpc must be called before starting the health checks');\n      }\n      checker = new InnerChecker(healthCallback, sendJsonRpc);\n      checker.update(true);\n    },\n    stop: () => {\n      if (checker === null) {\n        return;\n      } // Already stopped.\n      checker.destroy();\n      checker = null;\n    }\n  };\n}\nclass InnerChecker {\n  constructor(healthCallback, requestToSmoldot) {\n    _defineProperty(this, \"__internal__healthCallback\", void 0);\n    _defineProperty(this, \"__internal__currentHealthCheckId\", null);\n    _defineProperty(this, \"__internal__currentHealthTimeout\", null);\n    _defineProperty(this, \"__internal__currentSubunsubRequestId\", null);\n    _defineProperty(this, \"__internal__currentSubscriptionId\", null);\n    _defineProperty(this, \"__internal__requestToSmoldot\", void 0);\n    _defineProperty(this, \"__internal__isSyncing\", false);\n    _defineProperty(this, \"__internal__nextRequestId\", 0);\n    _defineProperty(this, \"sendJsonRpc\", request => {\n      // Replace the `id` in the request to prefix the request ID with `extern:`.\n      let parsedRequest;\n      try {\n        parsedRequest = JSON.parse(request);\n      } catch {\n        return;\n      }\n      if (parsedRequest.id) {\n        const newId = 'extern:' + stringify(parsedRequest.id);\n        parsedRequest.id = newId;\n      }\n      this.__internal__requestToSmoldot(parsedRequest);\n    });\n    _defineProperty(this, \"responsePassThrough\", jsonRpcResponse => {\n      let parsedResponse;\n      try {\n        parsedResponse = JSON.parse(jsonRpcResponse);\n      } catch {\n        return jsonRpcResponse;\n      }\n      // Check whether response is a response to `system_health`.\n      if (parsedResponse.id && this.__internal__currentHealthCheckId === parsedResponse.id) {\n        this.__internal__currentHealthCheckId = null;\n        // Check whether query was successful. It is possible for queries to fail for\n        // various reasons, such as the client being overloaded.\n        if (!parsedResponse.result) {\n          this.update(false);\n          return null;\n        }\n        this.__internal__healthCallback(parsedResponse.result);\n        this.__internal__isSyncing = parsedResponse.result.isSyncing;\n        this.update(false);\n        return null;\n      }\n      // Check whether response is a response to the subscription or unsubscription.\n      if (parsedResponse.id && this.__internal__currentSubunsubRequestId === parsedResponse.id) {\n        this.__internal__currentSubunsubRequestId = null;\n        // Check whether query was successful. It is possible for queries to fail for\n        // various reasons, such as the client being overloaded.\n        if (!parsedResponse.result) {\n          this.update(false);\n          return null;\n        }\n        if (this.__internal__currentSubscriptionId) {\n          this.__internal__currentSubscriptionId = null;\n        } else {\n          this.__internal__currentSubscriptionId = parsedResponse.result;\n        }\n        this.update(false);\n        return null;\n      }\n      // Check whether response is a notification to a subscription.\n      if (parsedResponse.params && this.__internal__currentSubscriptionId && parsedResponse.params.subscription === this.__internal__currentSubscriptionId) {\n        // Note that after a successful subscription, a notification containing\n        // the current best block is always returned. Considering that a\n        // subscription is performed in response to a health check, calling\n        // `startHealthCheck()` here will lead to a second health check.\n        // It might seem redundant to perform two health checks in a quick\n        // succession, but doing so doesn't lead to any problem, and it is\n        // actually possible for the health to have changed in between as the\n        // current best block might have been updated during the subscription\n        // request.\n        this.update(true);\n        return null;\n      }\n      // Response doesn't concern us.\n      if (parsedResponse.id) {\n        const id = parsedResponse.id;\n        // Need to remove the `extern:` prefix.\n        if (!id.startsWith('extern:')) {\n          throw new Error('State inconsistency in health checker');\n        }\n        const newId = JSON.parse(id.slice('extern:'.length));\n        parsedResponse.id = newId;\n      }\n      return stringify(parsedResponse);\n    });\n    _defineProperty(this, \"update\", startNow => {\n      // If `startNow`, clear `#currentHealthTimeout` so that it is set below.\n      if (startNow && this.__internal__currentHealthTimeout) {\n        clearTimeout(this.__internal__currentHealthTimeout);\n        this.__internal__currentHealthTimeout = null;\n      }\n      if (!this.__internal__currentHealthTimeout) {\n        const startHealthRequest = () => {\n          this.__internal__currentHealthTimeout = null;\n          // No matter what, don't start a health request if there is already one in progress.\n          // This is sane to do because receiving a response to a health request calls `update()`.\n          if (this.__internal__currentHealthCheckId) {\n            return;\n          }\n          // Actual request starting.\n          this.__internal__currentHealthCheckId = \"health-checker:\".concat(this.__internal__nextRequestId);\n          this.__internal__nextRequestId += 1;\n          this.__internal__requestToSmoldot({\n            id: this.__internal__currentHealthCheckId,\n            jsonrpc: '2.0',\n            method: 'system_health',\n            params: []\n          });\n        };\n        if (startNow) {\n          startHealthRequest();\n        } else {\n          this.__internal__currentHealthTimeout = setTimeout(startHealthRequest, 1000);\n        }\n      }\n      if (this.__internal__isSyncing && !this.__internal__currentSubscriptionId && !this.__internal__currentSubunsubRequestId) {\n        this.startSubscription();\n      }\n      if (!this.__internal__isSyncing && this.__internal__currentSubscriptionId && !this.__internal__currentSubunsubRequestId) {\n        this.endSubscription();\n      }\n    });\n    _defineProperty(this, \"startSubscription\", () => {\n      if (this.__internal__currentSubunsubRequestId || this.__internal__currentSubscriptionId) {\n        throw new Error('Internal error in health checker');\n      }\n      this.__internal__currentSubunsubRequestId = \"health-checker:\".concat(this.__internal__nextRequestId);\n      this.__internal__nextRequestId += 1;\n      this.__internal__requestToSmoldot({\n        id: this.__internal__currentSubunsubRequestId,\n        jsonrpc: '2.0',\n        method: 'chain_subscribeNewHeads',\n        params: []\n      });\n    });\n    _defineProperty(this, \"endSubscription\", () => {\n      if (this.__internal__currentSubunsubRequestId || !this.__internal__currentSubscriptionId) {\n        throw new Error('Internal error in health checker');\n      }\n      this.__internal__currentSubunsubRequestId = \"health-checker:\".concat(this.__internal__nextRequestId);\n      this.__internal__nextRequestId += 1;\n      this.__internal__requestToSmoldot({\n        id: this.__internal__currentSubunsubRequestId,\n        jsonrpc: '2.0',\n        method: 'chain_unsubscribeNewHeads',\n        params: [this.__internal__currentSubscriptionId]\n      });\n    });\n    _defineProperty(this, \"destroy\", () => {\n      if (this.__internal__currentHealthTimeout) {\n        clearTimeout(this.__internal__currentHealthTimeout);\n        this.__internal__currentHealthTimeout = null;\n      }\n    });\n    this.__internal__healthCallback = healthCallback;\n    this.__internal__requestToSmoldot = request => requestToSmoldot(stringify(request));\n  }\n}\nexport class HealthCheckError extends Error {\n  getCause() {\n    return this.__internal__cause;\n  }\n  constructor(response) {\n    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Got error response asking for system health';\n    super(message);\n    _defineProperty(this, \"__internal__cause\", void 0);\n    this.__internal__cause = response;\n  }\n}","map":{"version":3,"names":["stringify","healthChecker","checker","sendJsonRpc","responsePassThrough","jsonRpcResponse","request","Error","setSendJsonRpc","cb","start","healthCallback","InnerChecker","update","stop","destroy","constructor","requestToSmoldot","_defineProperty","parsedRequest","JSON","parse","id","newId","__internal__requestToSmoldot","parsedResponse","__internal__currentHealthCheckId","result","__internal__healthCallback","__internal__isSyncing","isSyncing","__internal__currentSubunsubRequestId","__internal__currentSubscriptionId","params","subscription","startsWith","slice","length","startNow","__internal__currentHealthTimeout","clearTimeout","startHealthRequest","concat","__internal__nextRequestId","jsonrpc","method","setTimeout","startSubscription","endSubscription","HealthCheckError","getCause","__internal__cause","response","message","arguments","undefined"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/rpc-provider/substrate-connect/Health.js"],"sourcesContent":["import { stringify } from '@polkadot/util';\n/*\n * Creates a new health checker.\n *\n * The role of the health checker is to report to the user the health of a smoldot chain.\n *\n * In order to use it, start by creating a health checker, and call `setSendJsonRpc` to set the\n * way to send a JSON-RPC request to a chain. The health checker is disabled by default. Use\n * `start()` in order to start the health checks. The `start()` function must be passed a callback called\n * when an update to the health of the node is available.\n *\n * In order to send a JSON-RPC request to the chain, you **must** use the `sendJsonRpc` function\n * of the health checker. The health checker rewrites the `id` of the requests it receives.\n *\n * When the chain send a JSON-RPC response, it must be passed to `responsePassThrough()`. This\n * function intercepts the responses destined to the requests that have been emitted by the health\n * checker and returns `null`. If the response doesn't concern the health checker, the response is\n * simply returned by the function.\n *\n * # How it works\n *\n * The health checker periodically calls the `system_health` JSON-RPC call in order to determine\n * the health of the chain.\n *\n * In addition to this, as long as the health check reports that `isSyncing` is `true`, the\n * health checker also maintains a subscription to new best blocks using `chain_subscribeNewHeads`.\n * Whenever a new block is notified, a health check is performed immediately in order to determine\n * whether `isSyncing` has changed to `false`.\n *\n * Thanks to this subscription, the latency of the report of the switch from `isSyncing: true` to\n * `isSyncing: false` is very low.\n *\n */\nexport function healthChecker() {\n    // `null` if health checker is not started.\n    let checker = null;\n    let sendJsonRpc = null;\n    return {\n        responsePassThrough: (jsonRpcResponse) => {\n            if (checker === null) {\n                return jsonRpcResponse;\n            }\n            return checker.responsePassThrough(jsonRpcResponse);\n        },\n        sendJsonRpc: (request) => {\n            if (!sendJsonRpc) {\n                throw new Error('setSendJsonRpc must be called before sending requests');\n            }\n            if (checker === null) {\n                sendJsonRpc(request);\n            }\n            else {\n                checker.sendJsonRpc(request);\n            }\n        },\n        setSendJsonRpc: (cb) => {\n            sendJsonRpc = cb;\n        },\n        start: (healthCallback) => {\n            if (checker !== null) {\n                throw new Error(\"Can't start the health checker multiple times in parallel\");\n            }\n            else if (!sendJsonRpc) {\n                throw new Error('setSendJsonRpc must be called before starting the health checks');\n            }\n            checker = new InnerChecker(healthCallback, sendJsonRpc);\n            checker.update(true);\n        },\n        stop: () => {\n            if (checker === null) {\n                return;\n            } // Already stopped.\n            checker.destroy();\n            checker = null;\n        }\n    };\n}\nclass InnerChecker {\n    __internal__healthCallback;\n    __internal__currentHealthCheckId = null;\n    __internal__currentHealthTimeout = null;\n    __internal__currentSubunsubRequestId = null;\n    __internal__currentSubscriptionId = null;\n    __internal__requestToSmoldot;\n    __internal__isSyncing = false;\n    __internal__nextRequestId = 0;\n    constructor(healthCallback, requestToSmoldot) {\n        this.__internal__healthCallback = healthCallback;\n        this.__internal__requestToSmoldot = (request) => requestToSmoldot(stringify(request));\n    }\n    sendJsonRpc = (request) => {\n        // Replace the `id` in the request to prefix the request ID with `extern:`.\n        let parsedRequest;\n        try {\n            parsedRequest = JSON.parse(request);\n        }\n        catch {\n            return;\n        }\n        if (parsedRequest.id) {\n            const newId = 'extern:' + stringify(parsedRequest.id);\n            parsedRequest.id = newId;\n        }\n        this.__internal__requestToSmoldot(parsedRequest);\n    };\n    responsePassThrough = (jsonRpcResponse) => {\n        let parsedResponse;\n        try {\n            parsedResponse = JSON.parse(jsonRpcResponse);\n        }\n        catch {\n            return jsonRpcResponse;\n        }\n        // Check whether response is a response to `system_health`.\n        if (parsedResponse.id && this.__internal__currentHealthCheckId === parsedResponse.id) {\n            this.__internal__currentHealthCheckId = null;\n            // Check whether query was successful. It is possible for queries to fail for\n            // various reasons, such as the client being overloaded.\n            if (!parsedResponse.result) {\n                this.update(false);\n                return null;\n            }\n            this.__internal__healthCallback(parsedResponse.result);\n            this.__internal__isSyncing = parsedResponse.result.isSyncing;\n            this.update(false);\n            return null;\n        }\n        // Check whether response is a response to the subscription or unsubscription.\n        if (parsedResponse.id &&\n            this.__internal__currentSubunsubRequestId === parsedResponse.id) {\n            this.__internal__currentSubunsubRequestId = null;\n            // Check whether query was successful. It is possible for queries to fail for\n            // various reasons, such as the client being overloaded.\n            if (!parsedResponse.result) {\n                this.update(false);\n                return null;\n            }\n            if (this.__internal__currentSubscriptionId) {\n                this.__internal__currentSubscriptionId = null;\n            }\n            else {\n                this.__internal__currentSubscriptionId = parsedResponse.result;\n            }\n            this.update(false);\n            return null;\n        }\n        // Check whether response is a notification to a subscription.\n        if (parsedResponse.params &&\n            this.__internal__currentSubscriptionId &&\n            parsedResponse.params.subscription === this.__internal__currentSubscriptionId) {\n            // Note that after a successful subscription, a notification containing\n            // the current best block is always returned. Considering that a\n            // subscription is performed in response to a health check, calling\n            // `startHealthCheck()` here will lead to a second health check.\n            // It might seem redundant to perform two health checks in a quick\n            // succession, but doing so doesn't lead to any problem, and it is\n            // actually possible for the health to have changed in between as the\n            // current best block might have been updated during the subscription\n            // request.\n            this.update(true);\n            return null;\n        }\n        // Response doesn't concern us.\n        if (parsedResponse.id) {\n            const id = parsedResponse.id;\n            // Need to remove the `extern:` prefix.\n            if (!id.startsWith('extern:')) {\n                throw new Error('State inconsistency in health checker');\n            }\n            const newId = JSON.parse(id.slice('extern:'.length));\n            parsedResponse.id = newId;\n        }\n        return stringify(parsedResponse);\n    };\n    update = (startNow) => {\n        // If `startNow`, clear `#currentHealthTimeout` so that it is set below.\n        if (startNow && this.__internal__currentHealthTimeout) {\n            clearTimeout(this.__internal__currentHealthTimeout);\n            this.__internal__currentHealthTimeout = null;\n        }\n        if (!this.__internal__currentHealthTimeout) {\n            const startHealthRequest = () => {\n                this.__internal__currentHealthTimeout = null;\n                // No matter what, don't start a health request if there is already one in progress.\n                // This is sane to do because receiving a response to a health request calls `update()`.\n                if (this.__internal__currentHealthCheckId) {\n                    return;\n                }\n                // Actual request starting.\n                this.__internal__currentHealthCheckId = `health-checker:${this.__internal__nextRequestId}`;\n                this.__internal__nextRequestId += 1;\n                this.__internal__requestToSmoldot({\n                    id: this.__internal__currentHealthCheckId,\n                    jsonrpc: '2.0',\n                    method: 'system_health',\n                    params: []\n                });\n            };\n            if (startNow) {\n                startHealthRequest();\n            }\n            else {\n                this.__internal__currentHealthTimeout = setTimeout(startHealthRequest, 1000);\n            }\n        }\n        if (this.__internal__isSyncing &&\n            !this.__internal__currentSubscriptionId &&\n            !this.__internal__currentSubunsubRequestId) {\n            this.startSubscription();\n        }\n        if (!this.__internal__isSyncing &&\n            this.__internal__currentSubscriptionId &&\n            !this.__internal__currentSubunsubRequestId) {\n            this.endSubscription();\n        }\n    };\n    startSubscription = () => {\n        if (this.__internal__currentSubunsubRequestId || this.__internal__currentSubscriptionId) {\n            throw new Error('Internal error in health checker');\n        }\n        this.__internal__currentSubunsubRequestId = `health-checker:${this.__internal__nextRequestId}`;\n        this.__internal__nextRequestId += 1;\n        this.__internal__requestToSmoldot({\n            id: this.__internal__currentSubunsubRequestId,\n            jsonrpc: '2.0',\n            method: 'chain_subscribeNewHeads',\n            params: []\n        });\n    };\n    endSubscription = () => {\n        if (this.__internal__currentSubunsubRequestId || !this.__internal__currentSubscriptionId) {\n            throw new Error('Internal error in health checker');\n        }\n        this.__internal__currentSubunsubRequestId = `health-checker:${this.__internal__nextRequestId}`;\n        this.__internal__nextRequestId += 1;\n        this.__internal__requestToSmoldot({\n            id: this.__internal__currentSubunsubRequestId,\n            jsonrpc: '2.0',\n            method: 'chain_unsubscribeNewHeads',\n            params: [this.__internal__currentSubscriptionId]\n        });\n    };\n    destroy = () => {\n        if (this.__internal__currentHealthTimeout) {\n            clearTimeout(this.__internal__currentHealthTimeout);\n            this.__internal__currentHealthTimeout = null;\n        }\n    };\n}\nexport class HealthCheckError extends Error {\n    __internal__cause;\n    getCause() {\n        return this.__internal__cause;\n    }\n    constructor(response, message = 'Got error response asking for system health') {\n        super(message);\n        this.__internal__cause = response;\n    }\n}\n"],"mappings":";AAAA,SAASA,SAAS,QAAQ,gBAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,aAAaA,CAAA,EAAG;EAC5B;EACA,IAAIC,OAAO,GAAG,IAAI;EAClB,IAAIC,WAAW,GAAG,IAAI;EACtB,OAAO;IACHC,mBAAmB,EAAGC,eAAe,IAAK;MACtC,IAAIH,OAAO,KAAK,IAAI,EAAE;QAClB,OAAOG,eAAe;MAC1B;MACA,OAAOH,OAAO,CAACE,mBAAmB,CAACC,eAAe,CAAC;IACvD,CAAC;IACDF,WAAW,EAAGG,OAAO,IAAK;MACtB,IAAI,CAACH,WAAW,EAAE;QACd,MAAM,IAAII,KAAK,CAAC,uDAAuD,CAAC;MAC5E;MACA,IAAIL,OAAO,KAAK,IAAI,EAAE;QAClBC,WAAW,CAACG,OAAO,CAAC;MACxB,CAAC,MACI;QACDJ,OAAO,CAACC,WAAW,CAACG,OAAO,CAAC;MAChC;IACJ,CAAC;IACDE,cAAc,EAAGC,EAAE,IAAK;MACpBN,WAAW,GAAGM,EAAE;IACpB,CAAC;IACDC,KAAK,EAAGC,cAAc,IAAK;MACvB,IAAIT,OAAO,KAAK,IAAI,EAAE;QAClB,MAAM,IAAIK,KAAK,CAAC,2DAA2D,CAAC;MAChF,CAAC,MACI,IAAI,CAACJ,WAAW,EAAE;QACnB,MAAM,IAAII,KAAK,CAAC,iEAAiE,CAAC;MACtF;MACAL,OAAO,GAAG,IAAIU,YAAY,CAACD,cAAc,EAAER,WAAW,CAAC;MACvDD,OAAO,CAACW,MAAM,CAAC,IAAI,CAAC;IACxB,CAAC;IACDC,IAAI,EAAEA,CAAA,KAAM;MACR,IAAIZ,OAAO,KAAK,IAAI,EAAE;QAClB;MACJ,CAAC,CAAC;MACFA,OAAO,CAACa,OAAO,CAAC,CAAC;MACjBb,OAAO,GAAG,IAAI;IAClB;EACJ,CAAC;AACL;AACA,MAAMU,YAAY,CAAC;EASfI,WAAWA,CAACL,cAAc,EAAEM,gBAAgB,EAAE;IAAAC,eAAA;IAAAA,eAAA,2CAPX,IAAI;IAAAA,eAAA,2CACJ,IAAI;IAAAA,eAAA,+CACA,IAAI;IAAAA,eAAA,4CACP,IAAI;IAAAA,eAAA;IAAAA,eAAA,gCAEhB,KAAK;IAAAA,eAAA,oCACD,CAAC;IAAAA,eAAA,sBAKdZ,OAAO,IAAK;MACvB;MACA,IAAIa,aAAa;MACjB,IAAI;QACAA,aAAa,GAAGC,IAAI,CAACC,KAAK,CAACf,OAAO,CAAC;MACvC,CAAC,CACD,MAAM;QACF;MACJ;MACA,IAAIa,aAAa,CAACG,EAAE,EAAE;QAClB,MAAMC,KAAK,GAAG,SAAS,GAAGvB,SAAS,CAACmB,aAAa,CAACG,EAAE,CAAC;QACrDH,aAAa,CAACG,EAAE,GAAGC,KAAK;MAC5B;MACA,IAAI,CAACC,4BAA4B,CAACL,aAAa,CAAC;IACpD,CAAC;IAAAD,eAAA,8BACsBb,eAAe,IAAK;MACvC,IAAIoB,cAAc;MAClB,IAAI;QACAA,cAAc,GAAGL,IAAI,CAACC,KAAK,CAAChB,eAAe,CAAC;MAChD,CAAC,CACD,MAAM;QACF,OAAOA,eAAe;MAC1B;MACA;MACA,IAAIoB,cAAc,CAACH,EAAE,IAAI,IAAI,CAACI,gCAAgC,KAAKD,cAAc,CAACH,EAAE,EAAE;QAClF,IAAI,CAACI,gCAAgC,GAAG,IAAI;QAC5C;QACA;QACA,IAAI,CAACD,cAAc,CAACE,MAAM,EAAE;UACxB,IAAI,CAACd,MAAM,CAAC,KAAK,CAAC;UAClB,OAAO,IAAI;QACf;QACA,IAAI,CAACe,0BAA0B,CAACH,cAAc,CAACE,MAAM,CAAC;QACtD,IAAI,CAACE,qBAAqB,GAAGJ,cAAc,CAACE,MAAM,CAACG,SAAS;QAC5D,IAAI,CAACjB,MAAM,CAAC,KAAK,CAAC;QAClB,OAAO,IAAI;MACf;MACA;MACA,IAAIY,cAAc,CAACH,EAAE,IACjB,IAAI,CAACS,oCAAoC,KAAKN,cAAc,CAACH,EAAE,EAAE;QACjE,IAAI,CAACS,oCAAoC,GAAG,IAAI;QAChD;QACA;QACA,IAAI,CAACN,cAAc,CAACE,MAAM,EAAE;UACxB,IAAI,CAACd,MAAM,CAAC,KAAK,CAAC;UAClB,OAAO,IAAI;QACf;QACA,IAAI,IAAI,CAACmB,iCAAiC,EAAE;UACxC,IAAI,CAACA,iCAAiC,GAAG,IAAI;QACjD,CAAC,MACI;UACD,IAAI,CAACA,iCAAiC,GAAGP,cAAc,CAACE,MAAM;QAClE;QACA,IAAI,CAACd,MAAM,CAAC,KAAK,CAAC;QAClB,OAAO,IAAI;MACf;MACA;MACA,IAAIY,cAAc,CAACQ,MAAM,IACrB,IAAI,CAACD,iCAAiC,IACtCP,cAAc,CAACQ,MAAM,CAACC,YAAY,KAAK,IAAI,CAACF,iCAAiC,EAAE;QAC/E;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,IAAI,CAACnB,MAAM,CAAC,IAAI,CAAC;QACjB,OAAO,IAAI;MACf;MACA;MACA,IAAIY,cAAc,CAACH,EAAE,EAAE;QACnB,MAAMA,EAAE,GAAGG,cAAc,CAACH,EAAE;QAC5B;QACA,IAAI,CAACA,EAAE,CAACa,UAAU,CAAC,SAAS,CAAC,EAAE;UAC3B,MAAM,IAAI5B,KAAK,CAAC,uCAAuC,CAAC;QAC5D;QACA,MAAMgB,KAAK,GAAGH,IAAI,CAACC,KAAK,CAACC,EAAE,CAACc,KAAK,CAAC,SAAS,CAACC,MAAM,CAAC,CAAC;QACpDZ,cAAc,CAACH,EAAE,GAAGC,KAAK;MAC7B;MACA,OAAOvB,SAAS,CAACyB,cAAc,CAAC;IACpC,CAAC;IAAAP,eAAA,iBACSoB,QAAQ,IAAK;MACnB;MACA,IAAIA,QAAQ,IAAI,IAAI,CAACC,gCAAgC,EAAE;QACnDC,YAAY,CAAC,IAAI,CAACD,gCAAgC,CAAC;QACnD,IAAI,CAACA,gCAAgC,GAAG,IAAI;MAChD;MACA,IAAI,CAAC,IAAI,CAACA,gCAAgC,EAAE;QACxC,MAAME,kBAAkB,GAAGA,CAAA,KAAM;UAC7B,IAAI,CAACF,gCAAgC,GAAG,IAAI;UAC5C;UACA;UACA,IAAI,IAAI,CAACb,gCAAgC,EAAE;YACvC;UACJ;UACA;UACA,IAAI,CAACA,gCAAgC,qBAAAgB,MAAA,CAAqB,IAAI,CAACC,yBAAyB,CAAE;UAC1F,IAAI,CAACA,yBAAyB,IAAI,CAAC;UACnC,IAAI,CAACnB,4BAA4B,CAAC;YAC9BF,EAAE,EAAE,IAAI,CAACI,gCAAgC;YACzCkB,OAAO,EAAE,KAAK;YACdC,MAAM,EAAE,eAAe;YACvBZ,MAAM,EAAE;UACZ,CAAC,CAAC;QACN,CAAC;QACD,IAAIK,QAAQ,EAAE;UACVG,kBAAkB,CAAC,CAAC;QACxB,CAAC,MACI;UACD,IAAI,CAACF,gCAAgC,GAAGO,UAAU,CAACL,kBAAkB,EAAE,IAAI,CAAC;QAChF;MACJ;MACA,IAAI,IAAI,CAACZ,qBAAqB,IAC1B,CAAC,IAAI,CAACG,iCAAiC,IACvC,CAAC,IAAI,CAACD,oCAAoC,EAAE;QAC5C,IAAI,CAACgB,iBAAiB,CAAC,CAAC;MAC5B;MACA,IAAI,CAAC,IAAI,CAAClB,qBAAqB,IAC3B,IAAI,CAACG,iCAAiC,IACtC,CAAC,IAAI,CAACD,oCAAoC,EAAE;QAC5C,IAAI,CAACiB,eAAe,CAAC,CAAC;MAC1B;IACJ,CAAC;IAAA9B,eAAA,4BACmB,MAAM;MACtB,IAAI,IAAI,CAACa,oCAAoC,IAAI,IAAI,CAACC,iCAAiC,EAAE;QACrF,MAAM,IAAIzB,KAAK,CAAC,kCAAkC,CAAC;MACvD;MACA,IAAI,CAACwB,oCAAoC,qBAAAW,MAAA,CAAqB,IAAI,CAACC,yBAAyB,CAAE;MAC9F,IAAI,CAACA,yBAAyB,IAAI,CAAC;MACnC,IAAI,CAACnB,4BAA4B,CAAC;QAC9BF,EAAE,EAAE,IAAI,CAACS,oCAAoC;QAC7Ca,OAAO,EAAE,KAAK;QACdC,MAAM,EAAE,yBAAyB;QACjCZ,MAAM,EAAE;MACZ,CAAC,CAAC;IACN,CAAC;IAAAf,eAAA,0BACiB,MAAM;MACpB,IAAI,IAAI,CAACa,oCAAoC,IAAI,CAAC,IAAI,CAACC,iCAAiC,EAAE;QACtF,MAAM,IAAIzB,KAAK,CAAC,kCAAkC,CAAC;MACvD;MACA,IAAI,CAACwB,oCAAoC,qBAAAW,MAAA,CAAqB,IAAI,CAACC,yBAAyB,CAAE;MAC9F,IAAI,CAACA,yBAAyB,IAAI,CAAC;MACnC,IAAI,CAACnB,4BAA4B,CAAC;QAC9BF,EAAE,EAAE,IAAI,CAACS,oCAAoC;QAC7Ca,OAAO,EAAE,KAAK;QACdC,MAAM,EAAE,2BAA2B;QACnCZ,MAAM,EAAE,CAAC,IAAI,CAACD,iCAAiC;MACnD,CAAC,CAAC;IACN,CAAC;IAAAd,eAAA,kBACS,MAAM;MACZ,IAAI,IAAI,CAACqB,gCAAgC,EAAE;QACvCC,YAAY,CAAC,IAAI,CAACD,gCAAgC,CAAC;QACnD,IAAI,CAACA,gCAAgC,GAAG,IAAI;MAChD;IACJ,CAAC;IAhKG,IAAI,CAACX,0BAA0B,GAAGjB,cAAc;IAChD,IAAI,CAACa,4BAA4B,GAAIlB,OAAO,IAAKW,gBAAgB,CAACjB,SAAS,CAACM,OAAO,CAAC,CAAC;EACzF;AA+JJ;AACA,OAAO,MAAM2C,gBAAgB,SAAS1C,KAAK,CAAC;EAExC2C,QAAQA,CAAA,EAAG;IACP,OAAO,IAAI,CAACC,iBAAiB;EACjC;EACAnC,WAAWA,CAACoC,QAAQ,EAA2D;IAAA,IAAzDC,OAAO,GAAAC,SAAA,CAAAjB,MAAA,QAAAiB,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,6CAA6C;IACzE,KAAK,CAACD,OAAO,CAAC;IAACnC,eAAA;IACf,IAAI,CAACiC,iBAAiB,GAAGC,QAAQ;EACrC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}