{"ast":null,"code":"\"use strict\";\n\nfunction getBitmapTextLayout(chars, style, font) {\n  const layoutData = {\n    width: 0,\n    height: 0,\n    offsetY: 0,\n    scale: style.fontSize / font.baseMeasurementFontSize,\n    lines: [{\n      width: 0,\n      charPositions: [],\n      spaceWidth: 0,\n      spacesIndex: [],\n      chars: []\n    }]\n  };\n  layoutData.offsetY = font.baseLineOffset;\n  let currentLine = layoutData.lines[0];\n  let previousChar = null;\n  let firstWord = true;\n  const currentWord = {\n    spaceWord: false,\n    width: 0,\n    start: 0,\n    index: 0,\n    // use index to not modify the array as we use it a lot!\n    positions: [],\n    chars: []\n  };\n  const nextWord = word => {\n    const start = currentLine.width;\n    for (let j = 0; j < currentWord.index; j++) {\n      const position = word.positions[j];\n      currentLine.chars.push(word.chars[j]);\n      currentLine.charPositions.push(position + start);\n    }\n    currentLine.width += word.width;\n    firstWord = false;\n    currentWord.width = 0;\n    currentWord.index = 0;\n    currentWord.chars.length = 0;\n  };\n  const nextLine = () => {\n    let index = currentLine.chars.length - 1;\n    let lastChar = currentLine.chars[index];\n    while (lastChar === \" \") {\n      currentLine.width -= font.chars[lastChar].xAdvance;\n      lastChar = currentLine.chars[--index];\n    }\n    layoutData.width = Math.max(layoutData.width, currentLine.width);\n    currentLine = {\n      width: 0,\n      charPositions: [],\n      chars: [],\n      spaceWidth: 0,\n      spacesIndex: []\n    };\n    firstWord = true;\n    layoutData.lines.push(currentLine);\n    layoutData.height += font.lineHeight;\n  };\n  const scale = font.baseMeasurementFontSize / style.fontSize;\n  const adjustedLetterSpacing = style.letterSpacing * scale;\n  const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n  for (let i = 0; i < chars.length + 1; i++) {\n    let char;\n    const isEnd = i === chars.length;\n    if (!isEnd) {\n      char = chars[i];\n    }\n    const charData = font.chars[char] || font.chars[\" \"];\n    const isSpace = /(?:\\s)/.test(char);\n    const isWordBreak = isSpace || char === \"\\r\" || char === \"\\n\" || isEnd;\n    if (isWordBreak) {\n      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;\n      if (addWordToNextLine) {\n        nextLine();\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      } else {\n        currentWord.start = currentLine.width;\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      }\n      if (char === \"\\r\" || char === \"\\n\") {\n        if (currentLine.width !== 0) {\n          nextLine();\n        }\n      } else if (!isEnd) {\n        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n        currentLine.width += spaceWidth;\n        currentLine.spaceWidth = spaceWidth;\n        currentLine.spacesIndex.push(currentLine.charPositions.length);\n        currentLine.chars.push(char);\n      }\n    } else {\n      const kerning = charData.kerning[previousChar] || 0;\n      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n      currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n      currentWord.chars.push(char);\n      currentWord.width += nextCharWidth;\n    }\n    previousChar = char;\n  }\n  nextLine();\n  if (style.align === \"center\") {\n    alignCenter(layoutData);\n  } else if (style.align === \"right\") {\n    alignRight(layoutData);\n  } else if (style.align === \"justify\") {\n    alignJustify(layoutData);\n  }\n  return layoutData;\n}\nfunction alignCenter(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width / 2 - line.width / 2;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignRight(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width - line.width;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignJustify(measurementData) {\n  const width = measurementData.width;\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    let indy = 0;\n    let spaceIndex = line.spacesIndex[indy++];\n    let offset = 0;\n    const totalSpaces = line.spacesIndex.length;\n    const newSpaceWidth = (width - line.width) / totalSpaces;\n    const spaceWidth = newSpaceWidth;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      if (j === spaceIndex) {\n        spaceIndex = line.spacesIndex[indy++];\n        offset += spaceWidth;\n      }\n      line.charPositions[j] += offset;\n    }\n  }\n}\nexport { getBitmapTextLayout };","map":{"version":3,"names":["getBitmapTextLayout","chars","style","font","layoutData","width","height","offsetY","scale","fontSize","baseMeasurementFontSize","lines","charPositions","spaceWidth","spacesIndex","baseLineOffset","currentLine","previousChar","firstWord","currentWord","spaceWord","start","index","positions","nextWord","word","j","position","push","length","nextLine","lastChar","xAdvance","Math","max","lineHeight","adjustedLetterSpacing","letterSpacing","adjustedWordWrapWidth","wordWrapWidth","i","char","isEnd","charData","isSpace","test","isWordBreak","addWordToNextLine","wordWrap","kerning","nextCharWidth","align","alignCenter","alignRight","alignJustify","measurementData","line","offset","indy","spaceIndex","totalSpaces","newSpaceWidth"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/text-bitmap/utils/getBitmapTextLayout.ts"],"sourcesContent":["import type { TextStyle } from '../../text/TextStyle';\nimport type { AbstractBitmapFont } from '../AbstractBitmapFont';\n\nexport interface BitmapTextLayoutData\n{\n    width: number;\n    height: number;\n    scale: number;\n    offsetY: number;\n    lines: {\n        width: number\n        charPositions: number[],\n        chars: string[],\n        // / spaces: number\n        spaceWidth: number\n        spacesIndex: number[]\n    }[];\n}\n\nexport function getBitmapTextLayout(chars: string[], style: TextStyle, font: AbstractBitmapFont<any>): BitmapTextLayoutData\n{\n    const layoutData: BitmapTextLayoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [{\n            width: 0,\n            charPositions: [] as number[],\n            spaceWidth: 0,\n            spacesIndex: [],\n            chars: [],\n        }]\n    };\n\n    layoutData.offsetY = font.baseLineOffset;\n\n    let currentLine = layoutData.lines[0];\n\n    let previousChar: string = null;\n    let firstWord = true;\n    //    let spaceCount = 0;\n\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0, // use index to not modify the array as we use it a lot!\n        positions: [] as number[],\n        chars: [] as string[],\n    };\n\n    const nextWord = (word: typeof currentWord) =>\n    {\n        const start = currentLine.width;\n\n        for (let j = 0; j < currentWord.index; j++)\n        {\n            const position = word.positions[j];\n\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n\n        currentLine.width += word.width;\n\n        firstWord = false;\n\n        // reset the word..\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n\n        // spaceCount = 0;\n    };\n\n    const nextLine = () =>\n    {\n        let index = currentLine.chars.length - 1;\n        let lastChar = currentLine.chars[index];\n\n        while (lastChar === ' ')\n        {\n            currentLine.width -= font.chars[lastChar].xAdvance;\n            lastChar = currentLine.chars[--index];\n        }\n\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: [],\n        };\n\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += font.lineHeight;\n    };\n\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n\n    // loop an extra time to force a line break..\n    for (let i = 0; i < chars.length + 1; i++)\n    {\n        let char: string;\n\n        const isEnd = i === chars.length;\n\n        if (!isEnd)\n        {\n            char = chars[i];\n        }\n\n        const charData = font.chars[char] || font.chars[' '];\n\n        const isSpace = (/(?:\\s)/).test(char);\n        const isWordBreak = isSpace || char === '\\r' || char === '\\n' || isEnd;\n\n        // spaceCount++;\n        // wasSpace = isSpace;\n\n        if (isWordBreak)\n        {\n            const addWordToNextLine = !firstWord\n                && style.wordWrap\n                && (currentLine.width + currentWord.width - adjustedLetterSpacing) > adjustedWordWrapWidth;\n\n            if (addWordToNextLine)\n            {\n                nextLine();\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n            else\n            {\n                currentWord.start = currentLine.width;\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                if (currentLine.width !== 0)\n                {\n                    nextLine();\n                }\n            }\n            else if (!isEnd)\n            {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n\n                currentLine.width += spaceWidth;\n\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n\n                // spaceCount++;\n            }\n        }\n        else\n        {\n            const kerning = charData.kerning[previousChar] || 0;\n\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n\n            currentWord.width += nextCharWidth;\n        }\n\n        previousChar = char;\n        // lastChar = char;\n    }\n\n    nextLine();\n\n    if (style.align === 'center')\n    {\n        alignCenter(layoutData);\n    }\n    else if (style.align === 'right')\n    {\n        alignRight(layoutData);\n    }\n    else if (style.align === 'justify')\n    {\n        alignJustify(layoutData);\n    }\n\n    return layoutData;\n}\n\nfunction alignCenter(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width / 2) - (line.width / 2));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignRight(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width) - (line.width));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignJustify(measurementData: BitmapTextLayoutData)\n{\n    const width = measurementData.width;\n\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n\n        let offset = 0;\n\n        const totalSpaces = line.spacesIndex.length;\n\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n\n        const spaceWidth = newSpaceWidth;\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            if (j === spaceIndex)\n            {\n                spaceIndex = line.spacesIndex[indy++];\n\n                offset += spaceWidth;\n            }\n\n            line.charPositions[j] += offset;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}