{"ast":null,"code":"var _jsxFileName = \"/home/ryoitsu/Documents/test/react-todo-app/src/index.js\";\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './css/index.css';\nimport TodoApp from './components/todo.jsx';\nimport reportWebVitals from './reportWebVitals';\nimport Sketch from \"react-p5\";\nimport * as THREE from 'three';\nimport Stats from 'three/examples/jsm/libs/stats.module';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nconst vertexShader = `\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`;\nconst fragmentShader = `\nvarying vec2 vUv;\nuniform vec3 iResolution;\nuniform float iTime;\nuniform vec3 origin;\nuniform float roll;\nuniform float pitch;\nuniform float yaw;\nuniform float alt;\nuniform float amplitude;\nuniform float frequency;\nuniform float choppy;\nuniform bool night;\n\n// Fragment Shader based on ShaderToy https://www.shadertoy.com/view/lt3GWj\n// Which itself is an evolution of several water shaders before it\n\n// A documented, altered, recolored version of \"Seascape\".\n// The famous original at:\n// https://www.shadertoy.com/view/Ms2SD1\n\n// \"Seascape\" by Alexander Alekseev aka TDM - 2014\n// Commenting added by bteitler\n// HSV/color adjustments and additional commenting by CaliCoastReplay - 2016\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// PI is a mathematical constant relating the ratio of a circle's circumference (distance around\n// the edge) to its diameter (distance between two points opposite on the edge).\n// Change pi at your own peril, with your own apologies to God.\nconst float PI\t \t= 3.14159265358;\n\n// Can you explain these epsilons to a wide graphics audience?  YOUR comment could go here.\nconst float EPSILON\t= 1e-3;\n#define  EPSILON_NRM\t(0.5 / iResolution.x)\n\n// Constant indicaing the number of steps taken while marching the light ray.\nconst int NUM_STEPS = 6;\n\n//Constants relating to the iteration of the heightmap for the wave, another part of the rendering\n//process.\nconst int ITER_GEOMETRY = 2;\nconst int ITER_FRAGMENT =5;\n\n// Constants that represent physical characteristics of the sea, can and should be changed and\n//  played with\nconst float SEA_SPEED = 1.9;\nconst vec3 SEA_BASE = vec3(0.11,0.19,0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.55,0.9,0.7);\n#define SEA_TIME (iTime * SEA_SPEED)\n\n//Matrix to permute the water surface into a complex, realistic form\nmat2 octave_m = mat2(1.7,1.2,-1.2,1.4);\n\n//Space bar key constant\nconst float KEY_SP    = 32.5/256.0;\n\n//CaliCoastReplay :  These HSV/RGB translation functions are\n//from http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\n//This one converts red-green-blue color to hue-saturation-value color\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n//CaliCoastReplay :  These HSV/RGB translation functions are\n//from http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\n//This one converts hue-saturation-value color to red-green-blue color\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// math\n// bteitler: Turn a vector of Euler angles into a rotation matrix\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    m[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return m;\n}\n\n// bteitler: A 2D hash function for use in noise generation that returns range [0 .. 1].  You could\n// use any hash function of choice, just needs to import * as THREE from 'three'\nimport Stats from 'three/examples/jsm/libs/stats.module'\nimport { GUI } from 'dat.gui'deterministic and return\n// between 0 and 1, and also behave randomly.  Googling \"GLSL hash function\" returns almost exactly\n// this function: http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// Performance is a real consideration of hash functions since ray-marching is already so heavy.\nfloat hash( vec2 p ) {\n    float h = dot(p,vec2(127.1,311.7));\n    return fract(sin(h)*83758.5453123);\n}\n\n// bteitler: A 2D psuedo-random wave / terrain function.  This is actually a poor name in my opinion,\n// since its the \"hash\" function that is really the noise, and this function is smoothly interpolating\n// between noisy points to create a continuous surface.\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    // bteitler: This is equivalent to the \"smoothstep\" interpolation function.\n    // This is a smooth wave function with input between 0 and 1\n    // (since it is taking the fractional part of <p>) and gives an output\n    // between 0 and 1 that behaves and looks like a wave.  This is far from obvious, but we can graph it to see\n    // Wolfram link: http://www.wolframalpha.com/input/?i=plot+x*x*%283.0-2.0*x%29+from+x%3D0+to+1\n    // This is used to interpolate between random points.  Any smooth wave function that ramps up from 0 and\n    // and hit 1.0 over the domain 0 to 1 would work.  For instance, sin(f * PI / 2.0) gives similar visuals.\n    // This function is nice however because it does not require an expensive sine calculation.\n    vec2 u = f*f*(3.0-2.0*f);\n\n    // bteitler: This very confusing looking mish-mash is simply pulling deterministic random values (between 0 and 1)\n    // for 4 corners of the grid square that <p> is inside, and doing 2D interpolation using the <u> function\n    // (remember it looks like a nice wave!)\n    // The grid square has points defined at integer boundaries.  For example, if <p> is (4.3, 2.1), we will\n    // evaluate at points (4, 2), (5, 2), (4, 3), (5, 3), and then interpolate x using u(.3) and y using u(.1).\n    return -1.0+2.0*mix(\n        mix( hash( i + vec2(0.0,0.0) ),\n             hash( i + vec2(1.0,0.0) ),\n             u.x),\n             mix( hash( i + vec2(0.0,1.0) ),\n                  hash( i + vec2(1.0,1.0) ),\n                  u.x),\n                  u.y);\n}\n\n// bteitler: diffuse lighting calculation - could be tweaked to taste\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\n\n// bteitler: specular lighting calculation - could be tweaked taste\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {\n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// bteitler: Generate a smooth sky gradient color based on ray direction's Y value\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,2.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    return ret;\n}\n\n// sea\n// bteitler: TLDR is that this passes a low frequency random terrain through a 2D symmetric wave function that looks like this:\n// http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n// The <choppy> parameter affects the wave shape.\nfloat sea_octave(vec2 uv, float choppy) {\n    // bteitler: Add the smoothed 2D terrain / wave function to the input coordinates\n    // which are going to be our X and Z world coordinates.  It may be unclear why we are doing this.\n    // This value is about to be passed through a wave function.  So we have a smoothed psuedo random height\n    // field being added to our (X, Z) coordinates, and then fed through yet another wav function below.\n    uv += noise(uv);\n    // Note that you could simply return noise(uv) here and it would take on the characteristics of our\n    // noise interpolation function u and would be a reasonable heightmap for terrain.\n    // However, that isn't the shape we want in the end for an ocean with waves, so it will be fed through\n    // a more wave like function.  Note that although both x and y channels of <uv> have the same value added, there is a\n    // symmetry break because <uv>.x and <uv>.y will typically be different values.\n\n    // bteitler: This is a wave function with pointy peaks and curved troughs:\n    // http://www.wolframalpha.com/input/?i=1-abs%28cos%28x%29%29%3B\n    vec2 wv = 1.0-abs(sin(uv));\n\n    // bteitler: This is a wave function with curved peaks and pointy troughs:\n    // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29%3B\n    vec2 swv = abs(cos(uv));\n\n    // bteitler: Blending both wave functions gets us a new, cooler wave function (output between 0 and 1):\n    // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29+%2B+abs%28cos%28x%29%29+*+%28%281.0-abs%28sin%28x%29%29%29+-+abs%28cos%28x%29%29%29\n    wv = mix(wv,swv,wv);\n\n    // bteitler: Finally, compose both of the wave functions for X and Y channels into a final\n    // 1D height value, shaping it a bit along the way.  First, there is the composition (multiplication) of\n    // the wave functions: wv.x * wv.y.  Wolfram will give us a cute 2D height graph for this!:\n    // http://www.wolframalpha.com/input/?i=%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D\n    // Next, we reshape the 2D wave function by exponentiation: (wv.x * wv.y)^0.65.  This slightly rounds the base of the wave:\n    // http://www.wolframalpha.com/input/?i=%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65\n    // one last final transform (with choppy = 4) results in this which resembles a recognizable ocean wave shape in 2D:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4\n    // Note that this function is called with a specific frequency multiplier which will stretch out the wave.  Here is the graph\n    // with the base frequency used by map and map_detailed (0.16):\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// bteitler: Compute the distance along Y axis of a point to the surface of the ocean\n// using a low(er) resolution ocean height composition function (less iterations).\nfloat map(vec3 p) {\n    float freq = frequency;\n    float amp = amplitude;\n    float chop = choppy;\n    vec2 uv = p.xz; uv.x *= 0.75;\n\n    // bteitler: Compose our wave noise generation (\"sea_octave\") with different frequencies\n    // and offsets to achieve a final height map that looks like an ocean.  Likely lots\n    // of black magic / trial and error here to get it to look right.  Each sea_octave has this shape:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    // which should give you an idea of what is going.  You don't need to graph this function because it\n    // appears to your left :)\n    float d, h = 0.0;\n    for(int i = 0; i < ITER_GEOMETRY; i++) {\n        // bteitler: start out with our 2D symmetric wave at the current frequency\n        d = sea_octave((uv+SEA_TIME)*freq,chop);\n        // bteitler: stack wave ontop of itself at an offset that varies over time for more height and wave pattern variance\n        //d += sea_octave((uv-SEA_TIME)*freq,chop);\n\n        h += d * amp; // bteitler: Bump our height by the current wave function\n\n        // bteitler: \"Twist\" our domain input into a different space based on a permutation matrix\n        // The scales of the matrix values affect the frequency of the wave at this iteration, but more importantly\n        // it is responsible for the realistic assymetry since the domain is shiftly differently.\n        // This is likely the most important parameter for wave topology.\n        uv *=  octave_m;\n\n        freq *= 1.9; // bteitler: Exponentially increase frequency every iteration (on top of our permutation)\n        amp *= 0.22; // bteitler: Lower the amplitude every frequency, since we are adding finer and finer detail\n        // bteitler: finally, adjust the choppy parameter which will effect our base 2D sea_octave shape a bit.  This makes\n        // the \"waves within waves\" have different looking shapes, not just frequency and offset\n        chop = mix(chop,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n// bteitler: Compute the distance along Y axis of a point to the surface of the ocean\n// using a high(er) resolution ocean height composition function (more iterations).\nfloat map_detailed(vec3 p) {\n    float freq = frequency;\n    float amp = amplitude;\n    float chop = choppy;\n    vec2 uv = p.xz; uv.x *= 0.75;\n\n    // bteitler: Compose our wave noise generation (\"sea_octave\") with different frequencies\n    // and offsets to achieve a final height map that looks like an ocean.  Likely lots\n    // of black magic / trial and error here to get it to look right.  Each sea_octave has this shape:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    // which should give you an idea of what is going.  You don't need to graph this function because it\n    // appears to your left :)\n    float d, h = 0.0;\n    for(int i = 0; i < ITER_FRAGMENT; i++) {\n        // bteitler: start out with our 2D symmetric wave at the current frequency\n        d = sea_octave((uv+SEA_TIME)*freq,chop);\n        // bteitler: stack wave ontop of itself at an offset that varies over time for more height and wave pattern variance\n        d += sea_octave((uv-SEA_TIME)*freq,chop);\n\n        h += d * amp; // bteitler: Bump our height by the current wave function\n\n        // bteitler: \"Twist\" our domain input into a different space based on a permutation matrix\n        // The scales of the matrix values affect the frequency of the wave at this iteration, but more importantly\n        // it is responsible for the realistic assymetry since the domain is shiftly differently.\n        // This is likely the most important parameter for wave topology.\n        uv *= octave_m/1.2;\n\n        freq *= 1.9; // bteitler: Exponentially increase frequency every iteration (on top of our permutation)\n        amp *= 0.22; // bteitler: Lower the amplitude every frequency, since we are adding finer and finer detail\n        // bteitler: finally, adjust the choppy parameter which will effect our base 2D sea_octave shape a bit.  This makes\n        // the \"waves within waves\" have different looking shapes, not just frequency and offset\n        chop = mix(chop,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n// bteitler:\n// p: point on ocean surface to get color for\n// n: normal on ocean surface at <p>\n// l: light (sun) direction\n// eye: ray direction from camera position for this pixel\n// dist: distance from camera to point <p> on ocean surface\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {\n    // bteitler: Fresnel is an exponential that gets bigger when the angle between ocean\n    // surface normal and eye ray is smaller\n    float fresnel = 1.0 - max(dot(n,-eye),0.0);\n    fresnel = pow(fresnel,3.0) * 0.45;\n\n    // bteitler: Bounce eye ray off ocean towards sky, and get the color of the sky\n    vec3 reflected = getSkyColor(reflect(eye,n))*0.99;\n\n    // bteitler: refraction effect based on angle between light surface normal\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.27;\n\n    // bteitler: blend the refracted color with the reflected color based on our fresnel term\n    vec3 color = mix(refracted,reflected,fresnel);\n\n    // bteitler: Apply a distance based attenuation factor which is stronger\n    // at peaks\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - amplitude) * 0.15 * atten;\n\n    // bteitler: Apply specular highlight\n    color += vec3(specular(n,l,eye,90.0))*0.5;\n\n    return color;\n}\n\n// bteitler: Estimate the normal at a point <p> on the ocean surface using a slight more detailed\n// ocean mapping function (using more noise octaves).\n// Takes an argument <eps> (stands for epsilon) which is the resolution to use\n// for the gradient.  See here for more info on gradients: https://en.wikipedia.org/wiki/Gradient\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    // bteitler: Approximate gradient.  An exact gradient would need the \"map\" / \"map_detailed\" functions\n    // to return x, y, and z, but it only computes height relative to surface along Y axis.  I'm assuming\n    // for simplicity and / or optimization reasons we approximate the gradient by the change in ocean\n    // height for all axis.\n    vec3 n;\n    n.y = map_detailed(p); // bteitler: Detailed height relative to surface, temporarily here to save a variable?\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y; // bteitler approximate X gradient as change in height along X axis delta\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y; // bteitler approximate Z gradient as change in height along Z axis delta\n    // bteitler: Taking advantage of the fact that we know we won't have really steep waves, we expect\n    // the Y normal component to be fairly large always.  Sacrifices yet more accurately to avoid some calculation.\n    n.y = eps;\n    return normalize(n);\n\n    // bteitler: A more naive and easy to understand version could look like this and\n    // produces almost the same visuals and is a little more expensive.\n    // vec3 n;\n    // float h = map_detailed(p);\n    // n.y = map_detailed(vec3(p.x,p.y+eps,p.z)) - h;\n    // n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - h;\n    // n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - h;\n    // return normalize(n);\n}\n\n// bteitler: Find out where a ray intersects the current ocean\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {\n    float tm = 0.0;\n    float tx = 5000.0; // bteitler: a really far distance, this could likely be tweaked a bit as desired\n\n    // bteitler: At a really far away distance along the ray, what is it's height relative\n    // to the ocean in ONLY the Y direction?\n    float hx = map(ori + dir * tx);\n\n    // bteitler: A positive height relative to the ocean surface (in Y direction) at a really far distance means\n    // this pixel is pure sky.  Quit early and return the far distance constant.\n    if(hx > 0.0) return tx;\n\n    // bteitler: hm starts out as the height of the camera position relative to ocean.\n    float hm = map(ori + dir * tm);\n\n    // bteitler: This is the main ray marching logic.  This is probably the single most confusing part of the shader\n    // since height mapping is not an exact distance field (tells you distance to surface if you drop a line down to ocean\n    // surface in the Y direction, but there could have been a peak at a very close point along the x and z\n    // directions that is closer).  Therefore, it would be possible/easy to overshoot the surface using the raw height field\n    // as the march distance.  The author uses a trick to compensate for this.\n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) { // bteitler: Constant number of ray marches per ray that hits the water\n        // bteitler: Move forward along ray in such a way that has the following properties:\n        // 1. If our current height relative to ocean is higher, move forward more\n        // 2. If the height relative to ocean floor very far along the ray is much lower\n        //    below the ocean surface, move forward less\n        // Idea behind 1. is that if we are far above the ocean floor we can risk jumping\n        // forward more without shooting under ocean, because the ocean is mostly level.\n        // The idea behind 2. is that if extruding the ray goes farther under the ocean, then\n        // you are looking more orthgonal to ocean surface (as opposed to looking towards horizon), and therefore\n        // movement along the ray gets closer to ocean faster, so we need to move forward less to reduce risk\n        // of overshooting.\n        tmid = mix(tm,tx, hm/(hm-hx));\n        p = ori + dir * tmid;\n\n        float hmid = map(p); // bteitler: Re-evaluate height relative to ocean surface in Y axis\n\n        if(hmid < 0.0) { // bteitler: We went through the ocean surface if we are negative relative to surface now\n            // bteitler: So instead of actually marching forward to cross the surface, we instead\n            // assign our really far distance and height to be where we just evaluated that crossed the surface.\n            // Next iteration will attempt to go forward more and is less likely to cross the boundary.\n            // A naive implementation might have returned <tmid> immediately here, which\n            // results in a much poorer / somewhat indeterministic quality rendering.\n            tx = tmid;\n            hx = hmid;\n        } else {\n            // Haven't hit surface yet, easy case, just march forward\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n\n    // bteitler: Return the distance, which should be really close to the height map without going under the ocean\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // bteitler: 2D Pixel location passed in as raw pixel, let's divide by resolution\n    // to convert to coordinates between 0 and 1\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    uv = uv * 2.0 - 1.0; //  bteitler: Shift pixel coordinates from 0 to 1 to between -1 and 1\n    uv.x *= iResolution.x / iResolution.y; // bteitler: Aspect ratio correction - if you don't do this your rays will be distorted\n    float time = iTime * 2.7; // bteitler: Animation is based on time, but allows you to scrub the animation based on mouse movement\n\n    // ray\n\n    // This will be used to drive where the user is looking in world space.\n    vec3 ang = vec3(roll,pitch,yaw);\n\n    // bteitler: Calculate the \"origin\" of the camera in world space based on time.  Camera is located\n    // at height 3.5 atx 0 (zero), and flies over the ocean in the z axis over time.\n    //vec3 ori = vec3(0, 3.5, 0);\n\n    // bteitler: This is the ray direction we are shooting from the camera location (\"ori\") that we need to light\n    // for this pixel.  The -2.0 indicates we are using a focal length of 2.0 - this is just an artistic choice and\n    // results in about a 90 degree field of view.\n    //  CaliCoastReplay :  Adjusted slightly to a lower focal length.  Seems to dramatize the scene.\n    vec3 dir = normalize(vec3(uv.xy,-1.6));\n\n    // bteitler: Distort the ray a bit for a fish eye effect (if you remove this line, it will remove\n    // the fish eye effect and look like a realistic perspective).\n    //  dir.z += length(uv) * 0.15;\n\n    // bteitler: Renormalize the ray direction, and then rotate it based on the previously calculated\n    // animation angle \"ang\".  \"fromEuler\" just calculates a rotation matrix from a vector of angles.\n    // if you remove the \" * fromEuler(ang)\" part, you will disable the camera rotation animation.\n    dir = normalize(dir) * fromEuler(ang);\n\n    // tracing\n\n    // bteitler: ray-march to the ocean surface (which can be thought of as a randomly generated height map)\n    // and store in p\n    vec3 p;\n    heightMapTracing(origin,dir,p);\n\n    vec3 dist = p - origin; // bteitler: distance vector to ocean surface for this pixel's ray\n\n    // bteitler: Calculate the normal on the ocean surface where we intersected (p), using\n    // different \"resolution\" (in a sense) based on how far away the ray traveled.  Normals close to\n    // the camera should be calculated with high resolution, and normals far from the camera should be calculated with low resolution\n    // The reason to do this is that specular effects (or non linear normal based lighting effects) become fairly random at\n    // far distances and low resolutions and can cause unpleasant shimmering during motion.\n    vec3 n = getNormal(p,\n                       dot(dist,dist)   // bteitler: Think of this as inverse resolution, so far distances get bigger at an expnential rate\n                       * EPSILON_NRM // bteitler: Just a resolution constant.. could easily be tweaked to artistic content\n    );\n\n    // bteitler: direction of the infinitely far away directional light.  Changing this will change\n    // the sunlight direction.\n    vec3 light = normalize(vec3(0.0,1.0,0.8));\n\n    // CaliCoastReplay:  Get the sky and sea colors\n    vec3 skyColor = getSkyColor(dir);\n    vec3 seaColor = getSeaColor(p,n,light,dir,dist);\n\n    //Sea/sky preprocessing\n\n    //CaliCoastReplay:  A distance falloff for the sea color.   Drastically darkens the sea,\n    //this will be reversed later based on day/night.\n    seaColor /= sqrt(sqrt(length(dist))) ;\n\n\n    //CaliCoastReplay:  Day/night mode\n    if( night )    //night mode!\n    {\n        //Brighten the sea up again, but not too bright at night\n        seaColor *= seaColor * 8.5;\n\n        //Turn down the sky\n        skyColor /= 1.69;\n    }\n    else  //day mode!\n    {\n        //Brighten the sea up again - bright and beautiful blue at day\n        seaColor *= sqrt(sqrt(seaColor)) * 4.0;\n        skyColor *= 1.05;\n        skyColor -= 0.03;\n    }\n\n\n    //CaliCoastReplay:  A slight \"constrasting\" for the sky to match the more contrasted ocean\n    skyColor *= skyColor;\n\n\n    //CaliCoastReplay:  A rather hacky manipulation of the high-value regions in the image that seems\n    //to add a subtle charm and \"sheen\" and foamy effect to high value regions through subtle darkening,\n    //but it is hacky, and not physically modeled at all.\n    vec3 seaHsv = rgb2hsv(seaColor);\n    if (seaHsv.z > .75 && length(dist) < 50.0)\n        seaHsv.z -= (0.9 - seaHsv.z) * 1.3;\n    seaColor = hsv2rgb(seaHsv);\n\n    // bteitler: Mix (linear interpolate) a color calculated for the sky (based solely on ray direction) and a sea color\n    // which contains a realistic lighting model.  This is basically doing a fog calculation: weighing more the sky color\n    // in the distance in an exponential manner.\n\n    vec3 color = mix(\n        skyColor,\n        seaColor,\n        pow(smoothstep(0.0,-0.05,dir.y), 0.3) // bteitler: Can be thought of as \"fog\" that gets thicker in the distance\n    );\n\n    // Postprocessing\n\n    // bteitler: Apply an overall image brightness factor as the final color for this pixel.  Can be\n    // tweaked artistically.\n    fragColor = vec4(pow(color,vec3(0.75)), 1.0);\n\n    // CaliCoastReplay:  Adjust hue, saturation, and value adjustment for an even more processed look\n    // hsv.x is hue, hsv.y is saturation, and hsv.z is value\n    vec3 hsv = rgb2hsv(fragColor.xyz);\n    //CaliCoastReplay: Increase saturation slightly\n    hsv.y += 0.131;\n    //CaliCoastReplay:\n    //A pseudo-multiplicative adjustment of value, increasing intensity near 1 and decreasing it near\n    //0 to achieve a more contrasted, real-world look\n    hsv.z *= sqrt(hsv.z) * 1.1;\n\n    if (night)\n    {\n        ///CaliCoastReplay:\n        //Slight value adjustment at night to turn down global intensity\n        hsv.z -= 0.045;\n        hsv*=0.8;\n        hsv.x += 0.12 + hsv.z/100.0;\n        //Highly increased saturation at night op, oddly.  Nights appear to be very colorful\n        //within their ranges.\n        hsv.y *= 2.87;\n    }\n    else\n    {\n        //CaliCoastReplay:\n        //Add green tinge to the high range\n        //Turn down intensity in day in a different way\n\n        hsv.z *= 0.9;\n\n        //CaliCoastReplay:  Hue alteration\n        hsv.x -= hsv.z/10.0;\n        hsv.x += 0.02 + hsv.z/50.0;\n        //Final brightening\n        hsv.z *= 1.01;\n        //This really \"cinemafies\" it for the day -\n        //puts the saturation on a squared, highly magnified footing.\n        //Worth looking into more as to exactly why.\n        //hsv.y *= 5.10 * hsv.y * sqrt(hsv.y);\n        hsv.y += 0.07;\n    }\n\n    //CaliCoastReplay:\n    //Replace the final color with the adjusted, translated HSV values\n    fragColor.xyz = hsv2rgb(hsv);\n}\n\nvoid main() {\n    mainImage(gl_FragColor, vUv * iResolution.xy);\n}\n`;\nconst scene = new THREE.Scene();\nconst camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\nconst superman = {\n  origin: new THREE.Vector3(0, 3.5, 0),\n  speed: 10.0,\n  roll: Math.PI,\n  heading: 0,\n  pitch: Math.PI\n};\nconst uniforms = {\n  iTime: {\n    value: 0\n  },\n  iResolution: {\n    value: new THREE.Vector3(window.innerWidth, window.innerHeight, 1)\n  },\n  origin: {\n    value: superman.origin\n  },\n  roll: {\n    value: superman.roll\n  },\n  yaw: {\n    value: superman.heading\n  },\n  pitch: {\n    value: superman.pitch\n  },\n  amplitude: {\n    value: 0.5\n  },\n  frequency: {\n    value: 0.24\n  },\n  choppy: {\n    value: 3.0\n  },\n  night: {\n    value: false\n  }\n};\nconst plane = new THREE.PlaneGeometry(2, 2);\nconst material = new THREE.ShaderMaterial({\n  vertexShader,\n  fragmentShader,\n  uniforms\n});\nscene.add(new THREE.Mesh(plane, material));\nwindow.addEventListener('resize', onWindowResize, false);\nfunction onWindowResize() {\n  camera.updateProjectionMatrix();\n  uniforms.iResolution.value.set(window.innerWidth, window.innerHeight, 1);\n  renderer.setSize(window.innerWidth, window.innerHeight);\n}\nconst stats = Stats();\ndocument.body.appendChild(stats.dom);\nconst gui = new GUI();\ngui.width = 500;\nconst waterFolder = gui.addFolder('Water');\nwaterFolder.add(uniforms.amplitude, 'value', 0.1, 2, 0.1).name('Amplitude');\nwaterFolder.add(uniforms.frequency, 'value', 0.01, 2, 0.01).name('Frequency');\nwaterFolder.add(uniforms.choppy, 'value', 0.1, 20, 0.1).name('Choppy');\nwaterFolder.add(uniforms.night, 'value').name('Night');\nwaterFolder.open();\nconst supermanFolder = gui.addFolder('Superman');\nsupermanFolder.add(superman, 'roll', Math.PI - Math.PI / 4, Math.PI + Math.PI / 4, 0.01).name('Roll');\nsupermanFolder.add(superman, 'pitch', Math.PI - Math.PI / 4, Math.PI + Math.PI / 4, 0.01).name('Pitch');\nsupermanFolder.add(superman, 'speed', 0, 100, 0.1).name('Speed');\nsupermanFolder.open();\nconst clock = new THREE.Clock();\nlet delta = 0;\nlet alt = 0;\nfunction animate() {\n  requestAnimationFrame(animate);\n  delta = clock.getDelta();\n  superman.heading += (superman.roll - Math.PI) / 75;\n  superman.origin.x += -Math.sin(superman.heading) * superman.speed * delta;\n  superman.origin.z += Math.cos(superman.heading) * superman.speed * delta;\n  alt = superman.origin.y + (superman.pitch - Math.PI) / 10;\n  if (alt > 1) superman.origin.y = alt;\n  uniforms.iTime.value = clock.getElapsedTime();\n  uniforms.roll.value = superman.roll;\n  uniforms.yaw.value = superman.heading;\n  uniforms.pitch.value = superman.pitch;\n  uniforms.origin.value.copy(superman.origin);\n  render();\n  stats.update();\n}\nfunction render() {\n  renderer.render(scene, camera);\n}\nanimate();\nroot.render( /*#__PURE__*/_jsxDEV(_Fragment, {\n  children: [/*#__PURE__*/_jsxDEV(TodoApp, {}, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 683,\n    columnNumber: 1\n  }, this), /*#__PURE__*/_jsxDEV(\"footer\", {\n    children: \"\\xA92024 Ultra Degenerate Labs, No Rights Reserved\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 684,\n    columnNumber: 1\n  }, this)]\n}, void 0, true));\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();","map":{"version":3,"names":["React","ReactDOM","TodoApp","reportWebVitals","Sketch","THREE","Stats","jsxDEV","_jsxDEV","Fragment","_Fragment","root","createRoot","document","getElementById","vertexShader","fragmentShader","scene","Scene","camera","OrthographicCamera","renderer","WebGLRenderer","setSize","window","innerWidth","innerHeight","body","appendChild","domElement","superman","origin","Vector3","speed","roll","Math","PI","heading","pitch","uniforms","iTime","value","iResolution","yaw","amplitude","frequency","choppy","night","plane","PlaneGeometry","material","ShaderMaterial","add","Mesh","addEventListener","onWindowResize","updateProjectionMatrix","set","stats","dom","gui","GUI","width","waterFolder","addFolder","name","open","supermanFolder","clock","Clock","delta","alt","animate","requestAnimationFrame","getDelta","x","sin","z","cos","y","getElapsedTime","copy","render","update","children","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/src/index.js"],"sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './css/index.css';\nimport TodoApp from './components/todo.jsx';\nimport reportWebVitals from './reportWebVitals';\nimport Sketch from \"react-p5\";\nimport * as THREE from 'three'\nimport Stats from 'three/examples/jsm/libs/stats.module'\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n\n\nconst vertexShader = `\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`\n\nconst fragmentShader = `\nvarying vec2 vUv;\nuniform vec3 iResolution;\nuniform float iTime;\nuniform vec3 origin;\nuniform float roll;\nuniform float pitch;\nuniform float yaw;\nuniform float alt;\nuniform float amplitude;\nuniform float frequency;\nuniform float choppy;\nuniform bool night;\n\n// Fragment Shader based on ShaderToy https://www.shadertoy.com/view/lt3GWj\n// Which itself is an evolution of several water shaders before it\n\n// A documented, altered, recolored version of \"Seascape\".\n// The famous original at:\n// https://www.shadertoy.com/view/Ms2SD1\n\n// \"Seascape\" by Alexander Alekseev aka TDM - 2014\n// Commenting added by bteitler\n// HSV/color adjustments and additional commenting by CaliCoastReplay - 2016\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// PI is a mathematical constant relating the ratio of a circle's circumference (distance around\n// the edge) to its diameter (distance between two points opposite on the edge).\n// Change pi at your own peril, with your own apologies to God.\nconst float PI\t \t= 3.14159265358;\n\n// Can you explain these epsilons to a wide graphics audience?  YOUR comment could go here.\nconst float EPSILON\t= 1e-3;\n#define  EPSILON_NRM\t(0.5 / iResolution.x)\n\n// Constant indicaing the number of steps taken while marching the light ray.\nconst int NUM_STEPS = 6;\n\n//Constants relating to the iteration of the heightmap for the wave, another part of the rendering\n//process.\nconst int ITER_GEOMETRY = 2;\nconst int ITER_FRAGMENT =5;\n\n// Constants that represent physical characteristics of the sea, can and should be changed and\n//  played with\nconst float SEA_SPEED = 1.9;\nconst vec3 SEA_BASE = vec3(0.11,0.19,0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.55,0.9,0.7);\n#define SEA_TIME (iTime * SEA_SPEED)\n\n//Matrix to permute the water surface into a complex, realistic form\nmat2 octave_m = mat2(1.7,1.2,-1.2,1.4);\n\n//Space bar key constant\nconst float KEY_SP    = 32.5/256.0;\n\n//CaliCoastReplay :  These HSV/RGB translation functions are\n//from http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\n//This one converts red-green-blue color to hue-saturation-value color\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n//CaliCoastReplay :  These HSV/RGB translation functions are\n//from http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\n//This one converts hue-saturation-value color to red-green-blue color\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// math\n// bteitler: Turn a vector of Euler angles into a rotation matrix\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    m[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return m;\n}\n\n// bteitler: A 2D hash function for use in noise generation that returns range [0 .. 1].  You could\n// use any hash function of choice, just needs to import * as THREE from 'three'\nimport Stats from 'three/examples/jsm/libs/stats.module'\nimport { GUI } from 'dat.gui'deterministic and return\n// between 0 and 1, and also behave randomly.  Googling \"GLSL hash function\" returns almost exactly\n// this function: http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// Performance is a real consideration of hash functions since ray-marching is already so heavy.\nfloat hash( vec2 p ) {\n    float h = dot(p,vec2(127.1,311.7));\n    return fract(sin(h)*83758.5453123);\n}\n\n// bteitler: A 2D psuedo-random wave / terrain function.  This is actually a poor name in my opinion,\n// since its the \"hash\" function that is really the noise, and this function is smoothly interpolating\n// between noisy points to create a continuous surface.\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    // bteitler: This is equivalent to the \"smoothstep\" interpolation function.\n    // This is a smooth wave function with input between 0 and 1\n    // (since it is taking the fractional part of <p>) and gives an output\n    // between 0 and 1 that behaves and looks like a wave.  This is far from obvious, but we can graph it to see\n    // Wolfram link: http://www.wolframalpha.com/input/?i=plot+x*x*%283.0-2.0*x%29+from+x%3D0+to+1\n    // This is used to interpolate between random points.  Any smooth wave function that ramps up from 0 and\n    // and hit 1.0 over the domain 0 to 1 would work.  For instance, sin(f * PI / 2.0) gives similar visuals.\n    // This function is nice however because it does not require an expensive sine calculation.\n    vec2 u = f*f*(3.0-2.0*f);\n\n    // bteitler: This very confusing looking mish-mash is simply pulling deterministic random values (between 0 and 1)\n    // for 4 corners of the grid square that <p> is inside, and doing 2D interpolation using the <u> function\n    // (remember it looks like a nice wave!)\n    // The grid square has points defined at integer boundaries.  For example, if <p> is (4.3, 2.1), we will\n    // evaluate at points (4, 2), (5, 2), (4, 3), (5, 3), and then interpolate x using u(.3) and y using u(.1).\n    return -1.0+2.0*mix(\n        mix( hash( i + vec2(0.0,0.0) ),\n             hash( i + vec2(1.0,0.0) ),\n             u.x),\n             mix( hash( i + vec2(0.0,1.0) ),\n                  hash( i + vec2(1.0,1.0) ),\n                  u.x),\n                  u.y);\n}\n\n// bteitler: diffuse lighting calculation - could be tweaked to taste\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\n\n// bteitler: specular lighting calculation - could be tweaked taste\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {\n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// bteitler: Generate a smooth sky gradient color based on ray direction's Y value\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,2.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    return ret;\n}\n\n// sea\n// bteitler: TLDR is that this passes a low frequency random terrain through a 2D symmetric wave function that looks like this:\n// http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n// The <choppy> parameter affects the wave shape.\nfloat sea_octave(vec2 uv, float choppy) {\n    // bteitler: Add the smoothed 2D terrain / wave function to the input coordinates\n    // which are going to be our X and Z world coordinates.  It may be unclear why we are doing this.\n    // This value is about to be passed through a wave function.  So we have a smoothed psuedo random height\n    // field being added to our (X, Z) coordinates, and then fed through yet another wav function below.\n    uv += noise(uv);\n    // Note that you could simply return noise(uv) here and it would take on the characteristics of our\n    // noise interpolation function u and would be a reasonable heightmap for terrain.\n    // However, that isn't the shape we want in the end for an ocean with waves, so it will be fed through\n    // a more wave like function.  Note that although both x and y channels of <uv> have the same value added, there is a\n    // symmetry break because <uv>.x and <uv>.y will typically be different values.\n\n    // bteitler: This is a wave function with pointy peaks and curved troughs:\n    // http://www.wolframalpha.com/input/?i=1-abs%28cos%28x%29%29%3B\n    vec2 wv = 1.0-abs(sin(uv));\n\n    // bteitler: This is a wave function with curved peaks and pointy troughs:\n    // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29%3B\n    vec2 swv = abs(cos(uv));\n\n    // bteitler: Blending both wave functions gets us a new, cooler wave function (output between 0 and 1):\n    // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29+%2B+abs%28cos%28x%29%29+*+%28%281.0-abs%28sin%28x%29%29%29+-+abs%28cos%28x%29%29%29\n    wv = mix(wv,swv,wv);\n\n    // bteitler: Finally, compose both of the wave functions for X and Y channels into a final\n    // 1D height value, shaping it a bit along the way.  First, there is the composition (multiplication) of\n    // the wave functions: wv.x * wv.y.  Wolfram will give us a cute 2D height graph for this!:\n    // http://www.wolframalpha.com/input/?i=%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D\n    // Next, we reshape the 2D wave function by exponentiation: (wv.x * wv.y)^0.65.  This slightly rounds the base of the wave:\n    // http://www.wolframalpha.com/input/?i=%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65\n    // one last final transform (with choppy = 4) results in this which resembles a recognizable ocean wave shape in 2D:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4\n    // Note that this function is called with a specific frequency multiplier which will stretch out the wave.  Here is the graph\n    // with the base frequency used by map and map_detailed (0.16):\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// bteitler: Compute the distance along Y axis of a point to the surface of the ocean\n// using a low(er) resolution ocean height composition function (less iterations).\nfloat map(vec3 p) {\n    float freq = frequency;\n    float amp = amplitude;\n    float chop = choppy;\n    vec2 uv = p.xz; uv.x *= 0.75;\n\n    // bteitler: Compose our wave noise generation (\"sea_octave\") with different frequencies\n    // and offsets to achieve a final height map that looks like an ocean.  Likely lots\n    // of black magic / trial and error here to get it to look right.  Each sea_octave has this shape:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    // which should give you an idea of what is going.  You don't need to graph this function because it\n    // appears to your left :)\n    float d, h = 0.0;\n    for(int i = 0; i < ITER_GEOMETRY; i++) {\n        // bteitler: start out with our 2D symmetric wave at the current frequency\n        d = sea_octave((uv+SEA_TIME)*freq,chop);\n        // bteitler: stack wave ontop of itself at an offset that varies over time for more height and wave pattern variance\n        //d += sea_octave((uv-SEA_TIME)*freq,chop);\n\n        h += d * amp; // bteitler: Bump our height by the current wave function\n\n        // bteitler: \"Twist\" our domain input into a different space based on a permutation matrix\n        // The scales of the matrix values affect the frequency of the wave at this iteration, but more importantly\n        // it is responsible for the realistic assymetry since the domain is shiftly differently.\n        // This is likely the most important parameter for wave topology.\n        uv *=  octave_m;\n\n        freq *= 1.9; // bteitler: Exponentially increase frequency every iteration (on top of our permutation)\n        amp *= 0.22; // bteitler: Lower the amplitude every frequency, since we are adding finer and finer detail\n        // bteitler: finally, adjust the choppy parameter which will effect our base 2D sea_octave shape a bit.  This makes\n        // the \"waves within waves\" have different looking shapes, not just frequency and offset\n        chop = mix(chop,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n// bteitler: Compute the distance along Y axis of a point to the surface of the ocean\n// using a high(er) resolution ocean height composition function (more iterations).\nfloat map_detailed(vec3 p) {\n    float freq = frequency;\n    float amp = amplitude;\n    float chop = choppy;\n    vec2 uv = p.xz; uv.x *= 0.75;\n\n    // bteitler: Compose our wave noise generation (\"sea_octave\") with different frequencies\n    // and offsets to achieve a final height map that looks like an ocean.  Likely lots\n    // of black magic / trial and error here to get it to look right.  Each sea_octave has this shape:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    // which should give you an idea of what is going.  You don't need to graph this function because it\n    // appears to your left :)\n    float d, h = 0.0;\n    for(int i = 0; i < ITER_FRAGMENT; i++) {\n        // bteitler: start out with our 2D symmetric wave at the current frequency\n        d = sea_octave((uv+SEA_TIME)*freq,chop);\n        // bteitler: stack wave ontop of itself at an offset that varies over time for more height and wave pattern variance\n        d += sea_octave((uv-SEA_TIME)*freq,chop);\n\n        h += d * amp; // bteitler: Bump our height by the current wave function\n\n        // bteitler: \"Twist\" our domain input into a different space based on a permutation matrix\n        // The scales of the matrix values affect the frequency of the wave at this iteration, but more importantly\n        // it is responsible for the realistic assymetry since the domain is shiftly differently.\n        // This is likely the most important parameter for wave topology.\n        uv *= octave_m/1.2;\n\n        freq *= 1.9; // bteitler: Exponentially increase frequency every iteration (on top of our permutation)\n        amp *= 0.22; // bteitler: Lower the amplitude every frequency, since we are adding finer and finer detail\n        // bteitler: finally, adjust the choppy parameter which will effect our base 2D sea_octave shape a bit.  This makes\n        // the \"waves within waves\" have different looking shapes, not just frequency and offset\n        chop = mix(chop,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n// bteitler:\n// p: point on ocean surface to get color for\n// n: normal on ocean surface at <p>\n// l: light (sun) direction\n// eye: ray direction from camera position for this pixel\n// dist: distance from camera to point <p> on ocean surface\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {\n    // bteitler: Fresnel is an exponential that gets bigger when the angle between ocean\n    // surface normal and eye ray is smaller\n    float fresnel = 1.0 - max(dot(n,-eye),0.0);\n    fresnel = pow(fresnel,3.0) * 0.45;\n\n    // bteitler: Bounce eye ray off ocean towards sky, and get the color of the sky\n    vec3 reflected = getSkyColor(reflect(eye,n))*0.99;\n\n    // bteitler: refraction effect based on angle between light surface normal\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.27;\n\n    // bteitler: blend the refracted color with the reflected color based on our fresnel term\n    vec3 color = mix(refracted,reflected,fresnel);\n\n    // bteitler: Apply a distance based attenuation factor which is stronger\n    // at peaks\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - amplitude) * 0.15 * atten;\n\n    // bteitler: Apply specular highlight\n    color += vec3(specular(n,l,eye,90.0))*0.5;\n\n    return color;\n}\n\n// bteitler: Estimate the normal at a point <p> on the ocean surface using a slight more detailed\n// ocean mapping function (using more noise octaves).\n// Takes an argument <eps> (stands for epsilon) which is the resolution to use\n// for the gradient.  See here for more info on gradients: https://en.wikipedia.org/wiki/Gradient\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    // bteitler: Approximate gradient.  An exact gradient would need the \"map\" / \"map_detailed\" functions\n    // to return x, y, and z, but it only computes height relative to surface along Y axis.  I'm assuming\n    // for simplicity and / or optimization reasons we approximate the gradient by the change in ocean\n    // height for all axis.\n    vec3 n;\n    n.y = map_detailed(p); // bteitler: Detailed height relative to surface, temporarily here to save a variable?\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y; // bteitler approximate X gradient as change in height along X axis delta\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y; // bteitler approximate Z gradient as change in height along Z axis delta\n    // bteitler: Taking advantage of the fact that we know we won't have really steep waves, we expect\n    // the Y normal component to be fairly large always.  Sacrifices yet more accurately to avoid some calculation.\n    n.y = eps;\n    return normalize(n);\n\n    // bteitler: A more naive and easy to understand version could look like this and\n    // produces almost the same visuals and is a little more expensive.\n    // vec3 n;\n    // float h = map_detailed(p);\n    // n.y = map_detailed(vec3(p.x,p.y+eps,p.z)) - h;\n    // n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - h;\n    // n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - h;\n    // return normalize(n);\n}\n\n// bteitler: Find out where a ray intersects the current ocean\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {\n    float tm = 0.0;\n    float tx = 5000.0; // bteitler: a really far distance, this could likely be tweaked a bit as desired\n\n    // bteitler: At a really far away distance along the ray, what is it's height relative\n    // to the ocean in ONLY the Y direction?\n    float hx = map(ori + dir * tx);\n\n    // bteitler: A positive height relative to the ocean surface (in Y direction) at a really far distance means\n    // this pixel is pure sky.  Quit early and return the far distance constant.\n    if(hx > 0.0) return tx;\n\n    // bteitler: hm starts out as the height of the camera position relative to ocean.\n    float hm = map(ori + dir * tm);\n\n    // bteitler: This is the main ray marching logic.  This is probably the single most confusing part of the shader\n    // since height mapping is not an exact distance field (tells you distance to surface if you drop a line down to ocean\n    // surface in the Y direction, but there could have been a peak at a very close point along the x and z\n    // directions that is closer).  Therefore, it would be possible/easy to overshoot the surface using the raw height field\n    // as the march distance.  The author uses a trick to compensate for this.\n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) { // bteitler: Constant number of ray marches per ray that hits the water\n        // bteitler: Move forward along ray in such a way that has the following properties:\n        // 1. If our current height relative to ocean is higher, move forward more\n        // 2. If the height relative to ocean floor very far along the ray is much lower\n        //    below the ocean surface, move forward less\n        // Idea behind 1. is that if we are far above the ocean floor we can risk jumping\n        // forward more without shooting under ocean, because the ocean is mostly level.\n        // The idea behind 2. is that if extruding the ray goes farther under the ocean, then\n        // you are looking more orthgonal to ocean surface (as opposed to looking towards horizon), and therefore\n        // movement along the ray gets closer to ocean faster, so we need to move forward less to reduce risk\n        // of overshooting.\n        tmid = mix(tm,tx, hm/(hm-hx));\n        p = ori + dir * tmid;\n\n        float hmid = map(p); // bteitler: Re-evaluate height relative to ocean surface in Y axis\n\n        if(hmid < 0.0) { // bteitler: We went through the ocean surface if we are negative relative to surface now\n            // bteitler: So instead of actually marching forward to cross the surface, we instead\n            // assign our really far distance and height to be where we just evaluated that crossed the surface.\n            // Next iteration will attempt to go forward more and is less likely to cross the boundary.\n            // A naive implementation might have returned <tmid> immediately here, which\n            // results in a much poorer / somewhat indeterministic quality rendering.\n            tx = tmid;\n            hx = hmid;\n        } else {\n            // Haven't hit surface yet, easy case, just march forward\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n\n    // bteitler: Return the distance, which should be really close to the height map without going under the ocean\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // bteitler: 2D Pixel location passed in as raw pixel, let's divide by resolution\n    // to convert to coordinates between 0 and 1\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    uv = uv * 2.0 - 1.0; //  bteitler: Shift pixel coordinates from 0 to 1 to between -1 and 1\n    uv.x *= iResolution.x / iResolution.y; // bteitler: Aspect ratio correction - if you don't do this your rays will be distorted\n    float time = iTime * 2.7; // bteitler: Animation is based on time, but allows you to scrub the animation based on mouse movement\n\n    // ray\n\n    // This will be used to drive where the user is looking in world space.\n    vec3 ang = vec3(roll,pitch,yaw);\n\n    // bteitler: Calculate the \"origin\" of the camera in world space based on time.  Camera is located\n    // at height 3.5 atx 0 (zero), and flies over the ocean in the z axis over time.\n    //vec3 ori = vec3(0, 3.5, 0);\n\n    // bteitler: This is the ray direction we are shooting from the camera location (\"ori\") that we need to light\n    // for this pixel.  The -2.0 indicates we are using a focal length of 2.0 - this is just an artistic choice and\n    // results in about a 90 degree field of view.\n    //  CaliCoastReplay :  Adjusted slightly to a lower focal length.  Seems to dramatize the scene.\n    vec3 dir = normalize(vec3(uv.xy,-1.6));\n\n    // bteitler: Distort the ray a bit for a fish eye effect (if you remove this line, it will remove\n    // the fish eye effect and look like a realistic perspective).\n    //  dir.z += length(uv) * 0.15;\n\n    // bteitler: Renormalize the ray direction, and then rotate it based on the previously calculated\n    // animation angle \"ang\".  \"fromEuler\" just calculates a rotation matrix from a vector of angles.\n    // if you remove the \" * fromEuler(ang)\" part, you will disable the camera rotation animation.\n    dir = normalize(dir) * fromEuler(ang);\n\n    // tracing\n\n    // bteitler: ray-march to the ocean surface (which can be thought of as a randomly generated height map)\n    // and store in p\n    vec3 p;\n    heightMapTracing(origin,dir,p);\n\n    vec3 dist = p - origin; // bteitler: distance vector to ocean surface for this pixel's ray\n\n    // bteitler: Calculate the normal on the ocean surface where we intersected (p), using\n    // different \"resolution\" (in a sense) based on how far away the ray traveled.  Normals close to\n    // the camera should be calculated with high resolution, and normals far from the camera should be calculated with low resolution\n    // The reason to do this is that specular effects (or non linear normal based lighting effects) become fairly random at\n    // far distances and low resolutions and can cause unpleasant shimmering during motion.\n    vec3 n = getNormal(p,\n                       dot(dist,dist)   // bteitler: Think of this as inverse resolution, so far distances get bigger at an expnential rate\n                       * EPSILON_NRM // bteitler: Just a resolution constant.. could easily be tweaked to artistic content\n    );\n\n    // bteitler: direction of the infinitely far away directional light.  Changing this will change\n    // the sunlight direction.\n    vec3 light = normalize(vec3(0.0,1.0,0.8));\n\n    // CaliCoastReplay:  Get the sky and sea colors\n    vec3 skyColor = getSkyColor(dir);\n    vec3 seaColor = getSeaColor(p,n,light,dir,dist);\n\n    //Sea/sky preprocessing\n\n    //CaliCoastReplay:  A distance falloff for the sea color.   Drastically darkens the sea,\n    //this will be reversed later based on day/night.\n    seaColor /= sqrt(sqrt(length(dist))) ;\n\n\n    //CaliCoastReplay:  Day/night mode\n    if( night )    //night mode!\n    {\n        //Brighten the sea up again, but not too bright at night\n        seaColor *= seaColor * 8.5;\n\n        //Turn down the sky\n        skyColor /= 1.69;\n    }\n    else  //day mode!\n    {\n        //Brighten the sea up again - bright and beautiful blue at day\n        seaColor *= sqrt(sqrt(seaColor)) * 4.0;\n        skyColor *= 1.05;\n        skyColor -= 0.03;\n    }\n\n\n    //CaliCoastReplay:  A slight \"constrasting\" for the sky to match the more contrasted ocean\n    skyColor *= skyColor;\n\n\n    //CaliCoastReplay:  A rather hacky manipulation of the high-value regions in the image that seems\n    //to add a subtle charm and \"sheen\" and foamy effect to high value regions through subtle darkening,\n    //but it is hacky, and not physically modeled at all.\n    vec3 seaHsv = rgb2hsv(seaColor);\n    if (seaHsv.z > .75 && length(dist) < 50.0)\n        seaHsv.z -= (0.9 - seaHsv.z) * 1.3;\n    seaColor = hsv2rgb(seaHsv);\n\n    // bteitler: Mix (linear interpolate) a color calculated for the sky (based solely on ray direction) and a sea color\n    // which contains a realistic lighting model.  This is basically doing a fog calculation: weighing more the sky color\n    // in the distance in an exponential manner.\n\n    vec3 color = mix(\n        skyColor,\n        seaColor,\n        pow(smoothstep(0.0,-0.05,dir.y), 0.3) // bteitler: Can be thought of as \"fog\" that gets thicker in the distance\n    );\n\n    // Postprocessing\n\n    // bteitler: Apply an overall image brightness factor as the final color for this pixel.  Can be\n    // tweaked artistically.\n    fragColor = vec4(pow(color,vec3(0.75)), 1.0);\n\n    // CaliCoastReplay:  Adjust hue, saturation, and value adjustment for an even more processed look\n    // hsv.x is hue, hsv.y is saturation, and hsv.z is value\n    vec3 hsv = rgb2hsv(fragColor.xyz);\n    //CaliCoastReplay: Increase saturation slightly\n    hsv.y += 0.131;\n    //CaliCoastReplay:\n    //A pseudo-multiplicative adjustment of value, increasing intensity near 1 and decreasing it near\n    //0 to achieve a more contrasted, real-world look\n    hsv.z *= sqrt(hsv.z) * 1.1;\n\n    if (night)\n    {\n        ///CaliCoastReplay:\n        //Slight value adjustment at night to turn down global intensity\n        hsv.z -= 0.045;\n        hsv*=0.8;\n        hsv.x += 0.12 + hsv.z/100.0;\n        //Highly increased saturation at night op, oddly.  Nights appear to be very colorful\n        //within their ranges.\n        hsv.y *= 2.87;\n    }\n    else\n    {\n        //CaliCoastReplay:\n        //Add green tinge to the high range\n        //Turn down intensity in day in a different way\n\n        hsv.z *= 0.9;\n\n        //CaliCoastReplay:  Hue alteration\n        hsv.x -= hsv.z/10.0;\n        hsv.x += 0.02 + hsv.z/50.0;\n        //Final brightening\n        hsv.z *= 1.01;\n        //This really \"cinemafies\" it for the day -\n        //puts the saturation on a squared, highly magnified footing.\n        //Worth looking into more as to exactly why.\n        //hsv.y *= 5.10 * hsv.y * sqrt(hsv.y);\n        hsv.y += 0.07;\n    }\n\n    //CaliCoastReplay:\n    //Replace the final color with the adjusted, translated HSV values\n    fragColor.xyz = hsv2rgb(hsv);\n}\n\nvoid main() {\n    mainImage(gl_FragColor, vUv * iResolution.xy);\n}\n`\n\nconst scene = new THREE.Scene()\n\nconst camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1)\n\nconst renderer = new THREE.WebGLRenderer()\nrenderer.setSize(window.innerWidth, window.innerHeight)\ndocument.body.appendChild(renderer.domElement)\n\nconst superman = {\n    origin: new THREE.Vector3(0, 3.5, 0),\n    speed: 10.0,\n    roll: Math.PI,\n    heading: 0,\n    pitch: Math.PI,\n}\n\nconst uniforms = {\n    iTime: { value: 0 },\n    iResolution: { value: new THREE.Vector3(window.innerWidth, window.innerHeight, 1) },\n    origin: { value: superman.origin },\n    roll: { value: superman.roll },\n    yaw: { value: superman.heading },\n    pitch: { value: superman.pitch },\n    amplitude: { value: 0.5 },\n    frequency: { value: 0.24 },\n    choppy: { value: 3.0 },\n    night: { value: false },\n}\n\nconst plane = new THREE.PlaneGeometry(2, 2)\nconst material = new THREE.ShaderMaterial({\n    vertexShader,\n    fragmentShader,\n    uniforms,\n})\nscene.add(new THREE.Mesh(plane, material))\n\nwindow.addEventListener('resize', onWindowResize, false)\nfunction onWindowResize() {\n    camera.updateProjectionMatrix()\n    uniforms.iResolution.value.set(window.innerWidth, window.innerHeight, 1)\n    renderer.setSize(window.innerWidth, window.innerHeight)\n}\n\nconst stats = Stats()\ndocument.body.appendChild(stats.dom)\n\nconst gui = new GUI()\ngui.width = 500\nconst waterFolder = gui.addFolder('Water')\nwaterFolder.add(uniforms.amplitude, 'value', 0.1, 2, 0.1).name('Amplitude')\nwaterFolder.add(uniforms.frequency, 'value', 0.01, 2, 0.01).name('Frequency')\nwaterFolder.add(uniforms.choppy, 'value', 0.1, 20, 0.1).name('Choppy')\nwaterFolder.add(uniforms.night, 'value').name('Night')\nwaterFolder.open()\nconst supermanFolder = gui.addFolder('Superman')\nsupermanFolder\n.add(superman, 'roll', Math.PI - Math.PI / 4, Math.PI + Math.PI / 4, 0.01)\n.name('Roll')\nsupermanFolder\n.add(superman, 'pitch', Math.PI - Math.PI / 4, Math.PI + Math.PI / 4, 0.01)\n.name('Pitch')\nsupermanFolder.add(superman, 'speed', 0, 100, 0.1).name('Speed')\nsupermanFolder.open()\n\nconst clock = new THREE.Clock()\nlet delta = 0\nlet alt = 0\n\nfunction animate() {\n    requestAnimationFrame(animate)\n\n    delta = clock.getDelta()\n\n    superman.heading += (superman.roll - Math.PI) / 75\n    superman.origin.x += -Math.sin(superman.heading) * superman.speed * delta\n    superman.origin.z += Math.cos(superman.heading) * superman.speed * delta\n    alt = superman.origin.y + (superman.pitch - Math.PI) / 10\n    if (alt > 1) superman.origin.y = alt\n\n        uniforms.iTime.value = clock.getElapsedTime()\n        uniforms.roll.value = superman.roll\n        uniforms.yaw.value = superman.heading\n        uniforms.pitch.value = superman.pitch\n        uniforms.origin.value.copy(superman.origin)\n\n        render()\n\n        stats.update()\n}\n\nfunction render() {\n    renderer.render(scene, camera)\n}\n\nanimate()\n\n\nroot.render(\n    <>\n<TodoApp />\n<footer>©2024 Ultra Degenerate Labs, No Rights Reserved</footer>\n</>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"mappings":";AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAOC,QAAQ,MAAM,kBAAkB;AACvC,OAAO,iBAAiB;AACxB,OAAOC,OAAO,MAAM,uBAAuB;AAC3C,OAAOC,eAAe,MAAM,mBAAmB;AAC/C,OAAOC,MAAM,MAAM,UAAU;AAC7B,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,OAAOC,KAAK,MAAM,sCAAsC;AAAA,SAAAC,MAAA,IAAAC,OAAA,EAAAC,QAAA,IAAAC,SAAA;AAExD,MAAMC,IAAI,GAAGV,QAAQ,CAACW,UAAU,CAACC,QAAQ,CAACC,cAAc,CAAC,MAAM,CAAC,CAAC;AAGjE,MAAMC,YAAY,GAAI;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,MAAMC,cAAc,GAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,MAAMC,KAAK,GAAG,IAAIZ,KAAK,CAACa,KAAK,CAAC,CAAC;AAE/B,MAAMC,MAAM,GAAG,IAAId,KAAK,CAACe,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AAE/D,MAAMC,QAAQ,GAAG,IAAIhB,KAAK,CAACiB,aAAa,CAAC,CAAC;AAC1CD,QAAQ,CAACE,OAAO,CAACC,MAAM,CAACC,UAAU,EAAED,MAAM,CAACE,WAAW,CAAC;AACvDb,QAAQ,CAACc,IAAI,CAACC,WAAW,CAACP,QAAQ,CAACQ,UAAU,CAAC;AA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}