{"ast":null,"code":"import { BitmapFontData } from \"../BitmapFontData.mjs\";\nclass TextFormat {\n  /**\n   * Check if resource refers to txt font data.\n   * @param data\n   * @returns - True if resource could be treated as font data, false otherwise.\n   */\n  static test(data) {\n    return typeof data == \"string\" && data.startsWith(\"info face=\");\n  }\n  /**\n   * Convert text font data to a javascript object.\n   * @param txt - Raw string data to be converted\n   * @returns - Parsed font data\n   */\n  static parse(txt) {\n    const items = txt.match(/^[a-z]+\\s+.+$/gm),\n      rawData = {\n        info: [],\n        common: [],\n        page: [],\n        char: [],\n        chars: [],\n        kerning: [],\n        kernings: [],\n        distanceField: []\n      };\n    for (const i in items) {\n      const name = items[i].match(/^[a-z]+/gm)[0],\n        attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm),\n        itemData = {};\n      for (const i2 in attributeList) {\n        const split = attributeList[i2].split(\"=\"),\n          key = split[0],\n          strValue = split[1].replace(/\"/gm, \"\"),\n          floatValue = parseFloat(strValue),\n          value = isNaN(floatValue) ? strValue : floatValue;\n        itemData[key] = value;\n      }\n      rawData[name].push(itemData);\n    }\n    const font = new BitmapFontData();\n    return rawData.info.forEach(info => font.info.push({\n      face: info.face,\n      size: parseInt(info.size, 10)\n    })), rawData.common.forEach(common => font.common.push({\n      lineHeight: parseInt(common.lineHeight, 10)\n    })), rawData.page.forEach(page => font.page.push({\n      id: parseInt(page.id, 10),\n      file: page.file\n    })), rawData.char.forEach(char => font.char.push({\n      id: parseInt(char.id, 10),\n      page: parseInt(char.page, 10),\n      x: parseInt(char.x, 10),\n      y: parseInt(char.y, 10),\n      width: parseInt(char.width, 10),\n      height: parseInt(char.height, 10),\n      xoffset: parseInt(char.xoffset, 10),\n      yoffset: parseInt(char.yoffset, 10),\n      xadvance: parseInt(char.xadvance, 10)\n    })), rawData.kerning.forEach(kerning => font.kerning.push({\n      first: parseInt(kerning.first, 10),\n      second: parseInt(kerning.second, 10),\n      amount: parseInt(kerning.amount, 10)\n    })), rawData.distanceField.forEach(df => font.distanceField.push({\n      distanceRange: parseInt(df.distanceRange, 10),\n      fieldType: df.fieldType\n    })), font;\n  }\n}\nexport { TextFormat };","map":{"version":3,"names":["TextFormat","test","data","startsWith","parse","txt","items","match","rawData","info","common","page","char","chars","kerning","kernings","distanceField","i","name","attributeList","itemData","i2","split","key","strValue","replace","floatValue","parseFloat","value","isNaN","push","font","BitmapFontData","forEach","face","size","parseInt","lineHeight","id","file","x","y","width","height","xoffset","yoffset","xadvance","first","second","amount","df","distanceRange","fieldType"],"sources":["/home/ryoitsu/node_modules/@pixi/text-bitmap/src/formats/TextFormat.ts"],"sourcesContent":["import { BitmapFontData } from '../BitmapFontData';\n\n/**\n * Internal data format used to convert to BitmapFontData.\n * @private\n */\nexport interface IBitmapFontRawData\n{\n    info: {\n        face: string;\n        size: string;\n    }[];\n    common: { lineHeight: string }[];\n    page: {\n        id: string;\n        file: string;\n    }[];\n    chars: {\n        count: number;\n    }[];\n    char: {\n        id: string;\n        page: string;\n        x: string;\n        y: string;\n        width: string;\n        height: string;\n        xoffset: string;\n        yoffset: string;\n        xadvance: string;\n    }[];\n    kernings?: {\n        count: number;\n    }[];\n    kerning?: {\n        first: string;\n        second: string;\n        amount: string;\n    }[];\n    distanceField?: {\n        fieldType: string;\n        distanceRange: string;\n    }[]\n}\n\n/**\n * BitmapFont format that's Text-based.\n * @private\n */\nexport class TextFormat\n{\n    /**\n     * Check if resource refers to txt font data.\n     * @param data\n     * @returns - True if resource could be treated as font data, false otherwise.\n     */\n    static test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        return typeof data === 'string' && data.startsWith('info face=');\n    }\n\n    /**\n     * Convert text font data to a javascript object.\n     * @param txt - Raw string data to be converted\n     * @returns - Parsed font data\n     */\n    static parse(txt: string): BitmapFontData\n    {\n        // Retrieve data item\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData: IBitmapFontRawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: [],\n        };\n\n        for (const i in items)\n        {\n            // Extract item name\n            const name = items[i].match(/^[a-z]+/gm)[0] as keyof BitmapFontData;\n\n            // Extract item attribute list as string ex.: \"width=10\"\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n\n            // Convert attribute list into an object\n            const itemData: any = {};\n\n            for (const i in attributeList)\n            {\n                // Split key-value pairs\n                const split = attributeList[i].split('=');\n                const key = split[0];\n\n                // Remove eventual quotes from value\n                const strValue = split[1].replace(/\"/gm, '');\n\n                // Try to convert value into float\n                const floatValue = parseFloat(strValue);\n\n                // Use string value case float value is NaN\n                const value = isNaN(floatValue) ? strValue : floatValue;\n\n                itemData[key] = value;\n            }\n\n            // Push current item to the resulting data\n            rawData[name].push(itemData);\n        }\n\n        const font = new BitmapFontData();\n\n        rawData.info.forEach((info) => font.info.push({\n            face: info.face,\n            size: parseInt(info.size, 10),\n        }));\n\n        rawData.common.forEach((common) => font.common.push({\n            lineHeight: parseInt(common.lineHeight, 10),\n        }));\n\n        rawData.page.forEach((page) => font.page.push({\n            id: parseInt(page.id, 10),\n            file: page.file,\n        }));\n\n        rawData.char.forEach((char) => font.char.push({\n            id: parseInt(char.id, 10),\n            page: parseInt(char.page, 10),\n            x: parseInt(char.x, 10),\n            y: parseInt(char.y, 10),\n            width: parseInt(char.width, 10),\n            height: parseInt(char.height, 10),\n            xoffset: parseInt(char.xoffset, 10),\n            yoffset: parseInt(char.yoffset, 10),\n            xadvance: parseInt(char.xadvance, 10),\n        }));\n\n        rawData.kerning.forEach((kerning) => font.kerning.push({\n            first: parseInt(kerning.first, 10),\n            second: parseInt(kerning.second, 10),\n            amount: parseInt(kerning.amount, 10),\n        }));\n\n        rawData.distanceField.forEach((df) => font.distanceField.push({\n            distanceRange: parseInt(df.distanceRange, 10),\n            fieldType: df.fieldType,\n        }));\n\n        return font;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}