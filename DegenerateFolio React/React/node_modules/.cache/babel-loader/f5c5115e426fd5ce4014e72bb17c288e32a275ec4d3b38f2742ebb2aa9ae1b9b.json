{"ast":null,"code":"import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { Bounds } from '../../container/bounds/Bounds.mjs';\n\"use strict\";\nconst tempBounds = new Bounds();\nfunction getPo2TextureFromSource(image, width, height, resolution) {\n  const bounds = tempBounds;\n  bounds.minX = 0;\n  bounds.minY = 0;\n  bounds.maxX = image.width / resolution | 0;\n  bounds.maxY = image.height / resolution | 0;\n  const texture = TexturePool.getOptimalTexture(bounds.width, bounds.height, resolution, false);\n  texture.source.uploadMethodId = \"image\";\n  texture.source.resource = image;\n  texture.source.alphaMode = \"premultiply-alpha-on-upload\";\n  texture.frame.width = width / resolution;\n  texture.frame.height = height / resolution;\n  texture.source.emit(\"update\", texture.source);\n  texture.updateUvs();\n  return texture;\n}\nexport { getPo2TextureFromSource };","map":{"version":3,"names":["tempBounds","Bounds","getPo2TextureFromSource","image","width","height","resolution","bounds","minX","minY","maxX","maxY","texture","TexturePool","getOptimalTexture","source","uploadMethodId","resource","alphaMode","frame","emit","updateUvs"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/text/utils/getPo2TextureFromSource.ts"],"sourcesContent":["import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n */\nexport function getPo2TextureFromSource(\n    image: HTMLImageElement | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n"],"mappings":";;;AAMA,MAAMA,UAAA,GAAa,IAAIC,MAAO;AAWvB,SAASC,uBACZA,CAAAC,KAAA,EACAC,KACA,EAAAC,MAAA,EACAC,UAEJ;EACI,MAAMC,MAAS,GAAAP,UAAA;EAEfO,MAAA,CAAOC,IAAO;EACdD,MAAA,CAAOE,IAAO;EAEPF,MAAA,CAAAG,IAAA,GAAQP,KAAM,CAAAC,KAAA,GAAQE,UAAc;EACpCC,MAAA,CAAAI,IAAA,GAAQR,KAAM,CAAAE,MAAA,GAASC,UAAc;EAE5C,MAAMM,OAAA,GAAUC,WAAY,CAAAC,iBAAA,CACxBP,MAAO,CAAAH,KAAA,EACPG,MAAO,CAAAF,MAAA,EACPC,UAAA,EACA,MACJ;EAEAM,OAAA,CAAQG,MAAA,CAAOC,cAAiB;EAChCJ,OAAA,CAAQG,MAAA,CAAOE,QAAW,GAAAd,KAAA;EAC1BS,OAAA,CAAQG,MAAA,CAAOG,SAAY;EAEnBN,OAAA,CAAAO,KAAA,CAAMf,KAAA,GAAQA,KAAQ,GAAAE,UAAA;EACtBM,OAAA,CAAAO,KAAA,CAAMd,MAAA,GAASA,MAAS,GAAAC,UAAA;EAOhCM,OAAA,CAAQG,MAAO,CAAAK,IAAA,CAAK,QAAU,EAAAR,OAAA,CAAQG,MAAM;EAE5CH,OAAA,CAAQS,SAAU;EAEX,OAAAT,OAAA;AACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}