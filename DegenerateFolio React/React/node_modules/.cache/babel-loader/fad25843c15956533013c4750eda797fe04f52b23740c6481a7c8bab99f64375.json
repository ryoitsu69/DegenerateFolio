{"ast":null,"code":"import { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram.mjs';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups.mjs';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups.mjs';\nimport { generateLayoutHash } from './utils/generateLayoutHash.mjs';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates.mjs';\n\"use strict\";\nconst programCache = /* @__PURE__ */Object.create(null);\nclass GpuProgram {\n  /**\n   * Create a new GpuProgram\n   * @param options - The options for the gpu program\n   */\n  constructor(options) {\n    /**\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    const {\n      fragment,\n      vertex,\n      layout,\n      gpuLayout,\n      name\n    } = options;\n    this.name = name;\n    this.fragment = fragment;\n    this.vertex = vertex;\n    if (fragment.source === vertex.source) {\n      const structsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = structsAndGroups;\n    } else {\n      const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n      const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n    }\n    this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n    this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n    this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);\n    this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);\n    this._generateProgramKey();\n  }\n  // TODO maker this pure\n  _generateProgramKey() {\n    const {\n      vertex,\n      fragment\n    } = this;\n    const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n    this._layoutKey = createIdFromString(bigKey, \"program\");\n  }\n  get attributeData() {\n    this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));\n    return this._attributeData;\n  }\n  /** destroys the program */\n  destroy() {\n    this.gpuLayout = null;\n    this.layout = null;\n    this.structsAndGroups = null;\n    this.fragment = null;\n    this.vertex = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n    if (!programCache[key]) {\n      programCache[key] = new GpuProgram(options);\n    }\n    return programCache[key];\n  }\n}\nexport { GpuProgram };","map":{"version":3,"names":["programCache","Object","create","GpuProgram","constructor","options","_layoutKey","fragment","vertex","layout","gpuLayout","name","source","structsAndGroups","extractStructAndGroups","vertexStructsAndGroups","fragmentStructsAndGroups","removeStructAndGroupDuplicates","generateLayoutHash","generateGpuLayoutGroups","autoAssignGlobalUniforms","globalUniforms","autoAssignLocalUniforms","localUniforms","_generateProgramKey","bigKey","entryPoint","createIdFromString","attributeData","_attributeData","extractAttributesFromGpuProgram","destroy","from","key"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuProgram.ts"],"sourcesContent":["import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups';\nimport { generateLayoutHash } from './utils/generateLayoutHash';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates';\n\nimport type { ExtractedAttributeData } from '../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { StructsAndGroups } from './utils/extractStructAndGroups';\n\n/**\n * a WebGPU descriptions of how the program is layed out\n * @see https://gpuweb.github.io/gpuweb/#gpupipelinelayout\n * @memberof rendering\n */\nexport type ProgramPipelineLayoutDescription = GPUBindGroupLayoutEntry[][];\n/**\n * a map the maps names of uniforms to group indexes\n * @memberof rendering\n */\nexport type ProgramLayout = Record<string, number>[];\n\n/**\n * the program source\n * @memberof rendering\n */\nexport interface ProgramSource\n{\n    /** The wgsl source code of the shader. */\n    source: string;\n    /** The main function to run in this shader */\n    entryPoint?: string;\n}\n\n/**\n * The options for the gpu program\n * @memberof rendering\n */\nexport interface GpuProgramOptions\n{\n    /**\n     * the name of the program, this is added to the label of the GPU Program created\n     * under the hood. Makes it much easier to debug!\n     */\n    name?: string;\n    /** The fragment glsl shader source. */\n    fragment?: ProgramSource;\n    /** The vertex glsl shader source. */\n    vertex?: ProgramSource;\n    /** The layout of the program. If not provided, it will be generated from the shader sources. */\n    layout?: ProgramLayout;\n    /** The gpu layout of the program. If not provided, it will be generated from the shader sources. */\n    gpuLayout?: ProgramPipelineLayoutDescription;\n}\n\nconst programCache: Record<string, GpuProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGPU Program, specifically designed for the WebGPU renderer.\n * This class facilitates the creation and management of shader code that integrates with the WebGPU pipeline.\n *\n * To leverage the full capabilities of this class, familiarity with WGSL shaders is recommended.\n * @see https://gpuweb.github.io/gpuweb/#index\n * @example\n *\n * // Create a new program\n * const program = new GpuProgram({\n *   vertex: {\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n *   fragment:{\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n * });\n *\n *\n * Note: Both fragment and vertex shader sources can coexist within a single WGSL source file\n * this can make things a bit simpler.\n *\n * For optimal usage and best performance, it help to reuse programs whenever possible.\n * The {@link GpuProgram.from} helper function is designed for this purpose, utilizing an\n * internal cache to efficiently manage and retrieve program instances.\n * By leveraging this function, you can significantly reduce overhead and enhance the performance of your rendering pipeline.\n *\n * An important distinction between WebGL and WebGPU regarding program data retrieval:\n * While WebGL allows extraction of program information directly from its compiled state,\n * WebGPU does not offer such a capability. Therefore, in the context of WebGPU, we're required\n * to manually extract the program layout information from the source code itself.\n * @memberof rendering\n */\nexport class GpuProgram\n{\n    /** The fragment glsl shader source. */\n    public readonly fragment?: ProgramSource;\n    /** The vertex glsl shader source */\n    public readonly vertex?: ProgramSource;\n\n    /**\n     * Mapping of uniform names to group indexes for organizing shader program uniforms.\n     * Automatically generated from shader sources if not provided.\n     * @example\n     * // Assuming a shader with two uniforms, `u_time` and `u_resolution`, grouped respectively:\n     * [\n     *   { \"u_time\": 0 },\n     *   { \"u_resolution\": 1 }\n     * ]\n     */\n    public readonly layout: ProgramLayout;\n\n    /**\n     * Configuration for the WebGPU bind group layouts, detailing resource organization for the shader.\n     * Generated from shader sources if not explicitly provided.\n     * @example\n     * // Assuming a shader program that requires two bind groups:\n     * [\n     *   // First bind group layout entries\n     *   [{ binding: 0, visibility: GPUShaderStage.VERTEX, type: \"uniform-buffer\" }],\n     *   // Second bind group layout entries\n     *   [{ binding: 1, visibility: GPUShaderStage.FRAGMENT, type: \"sampler\" },\n     *    { binding: 2, visibility: GPUShaderStage.FRAGMENT, type: \"sampled-texture\" }]\n     * ]\n     */\n    public readonly gpuLayout: ProgramPipelineLayoutDescription;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /** the structs and groups extracted from the shader sources */\n    public readonly structsAndGroups: StructsAndGroups;\n    /**\n     * the name of the program, this is added to the label of the GPU Program created under the hood.\n     * Makes it much easier to debug!\n     */\n    public readonly name: string;\n    private _attributeData: Record<string, ExtractedAttributeData>;\n\n    /** if true, the program will automatically assign global uniforms to group[0] */\n    public autoAssignGlobalUniforms: boolean;\n    /** if true, the program will automatically assign local uniforms to group[1] */\n    public autoAssignLocalUniforms: boolean;\n\n    /**\n     * Create a new GpuProgram\n     * @param options - The options for the gpu program\n     */\n    constructor(options: GpuProgramOptions)\n    {\n        const { fragment, vertex, layout, gpuLayout, name } = options;\n\n        this.name = name;\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        // TODO this should be cached - or dealt with at a system level.\n        if (fragment.source === vertex.source)\n        {\n            const structsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = structsAndGroups;\n        }\n        else\n        {\n            const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n            const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n\n        // todo layout\n        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n\n        // struct properties!\n\n        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== undefined);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== undefined);\n\n        this._generateProgramKey();\n    }\n\n    // TODO maker this pure\n    private _generateProgramKey()\n    {\n        const { vertex, fragment } = this;\n\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n\n        this._layoutKey = createIdFromString(bigKey, 'program');\n    }\n\n    get attributeData()\n    {\n        this._attributeData ??= extractAttributesFromGpuProgram(this.vertex);\n\n        return this._attributeData;\n    }\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.gpuLayout as null) = null;\n        (this.layout as null) = null;\n        (this.structsAndGroups as null) = null;\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GpuProgramOptions): GpuProgram\n    {\n        // eslint-disable-next-line max-len\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GpuProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n\n"],"mappings":";;;;;;;AAuDA,MAAMA,YAAA,kBAAkDC,MAAA,CAAAC,MAAA,CAAO,IAAI;AAqC5D,MAAMC,UACb;EAAA;AAAA;AAAA;AAAA;EAyDIC,YAAYC,OACZ;IArBA;AAAA;AAAA;AAAA;IAAA,KAAOC,UAAa;IAsBhB,MAAM;MAAEC,QAAU;MAAAC,MAAA;MAAQC,MAAQ;MAAAC,SAAA;MAAWC;IAAA,CAAS,GAAAN,OAAA;IAEtD,KAAKM,IAAO,GAAAA,IAAA;IAEZ,KAAKJ,QAAW,GAAAA,QAAA;IAChB,KAAKC,MAAS,GAAAA,MAAA;IAGV,IAAAD,QAAA,CAASK,MAAW,KAAAJ,MAAA,CAAOI,MAC/B;MACU,MAAAC,gBAAA,GAAmBC,sBAAuB,CAAAP,QAAA,CAASK,MAAM;MAE/D,KAAKC,gBAAmB,GAAAA,gBAAA;IAAA,CAG5B;MACU,MAAAE,sBAAA,GAAyBD,sBAAuB,CAAAN,MAAA,CAAOI,MAAM;MAC7D,MAAAI,wBAAA,GAA2BF,sBAAuB,CAAAP,QAAA,CAASK,MAAM;MAElE,KAAAC,gBAAA,GAAmBI,8BAA+B,CAAAF,sBAAA,EAAwBC,wBAAwB;IAAA;IAI3G,KAAKP,MAAS,GAAAA,MAAA,IAAUS,kBAAmB,MAAKL,gBAAgB;IAIhE,KAAKH,SAAY,GAAAA,SAAA,IAAaS,uBAAwB,MAAKN,gBAAgB;IAE3E,KAAKO,wBAAA,GAA2B,CAAC,EAAE,KAAKX,MAAO,EAAC,GAAGY,cAAmB;IACtE,KAAKC,uBAAA,GAA0B,CAAC,EAAE,KAAKb,MAAO,EAAC,GAAGc,aAAkB;IAEpE,KAAKC,mBAAoB;EAAA;EAC7B;EAGQA,mBACRA,CAAA;IACU;MAAEhB,MAAQ;MAAAD;IAAA,CAAa;IAE7B,MAAMkB,MAAA,GAASjB,MAAO,CAAAI,MAAA,GAASL,QAAA,CAASK,MAAS,GAAAJ,MAAA,CAAOkB,UAAA,GAAanB,QAAS,CAAAmB,UAAA;IAEzE,KAAApB,UAAA,GAAaqB,kBAAmB,CAAAF,MAAA,EAAQ,SAAS;EAAA;EAG1D,IAAIG,aACJA,CAAA;IACI,KAAKC,cAAL,UAAKA,cAAmB,GAAAC,+BAAA,CAAgC,KAAKtB,MAAM;IAEnE,OAAO,IAAK,CAAAqB,cAAA;EAAA;EAChB;EAEOE,OACPA,CAAA;IACK,KAAKrB,SAAqB;IAC1B,KAAKD,MAAkB;IACvB,KAAKI,gBAA4B;IACjC,KAAKN,QAAoB;IACzB,KAAKC,MAAkB;EAAA;EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASA,OAAcwB,KAAK3B,OACnB;IAEI,MAAM4B,GAAA,GAAS,GAAA5B,OAAA,CAAQG,MAAO,CAAAI,MAAM,IAAIP,OAAQ,CAAAE,QAAA,CAASK,MAAM,IAAIP,OAAA,CAAQE,QAAS,CAAAmB,UAAc,IAAArB,OAAA,CAAQG,MAAA,CAAOkB,UAAU;IAEvH,KAAC1B,YAAa,CAAAiC,GAAG,CACrB;MACIjC,YAAA,CAAaiC,GAAG,IAAI,IAAI9B,UAAA,CAAWE,OAAO;IAAA;IAG9C,OAAOL,YAAA,CAAaiC,GAAG;EAAA;AAE/B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}