{"ast":null,"code":"import { Texture } from '../../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { warn } from '../../../../../utils/logging/warn.mjs';\nimport { Cache } from '../../../../cache/Cache.mjs';\n\"use strict\";\nfunction createTexture(source, loader, url) {\n  source.label = url;\n  source._sourceOrigin = url;\n  const texture = new Texture({\n    source,\n    label: url\n  });\n  const unload = () => {\n    delete loader.promiseCache[url];\n    if (Cache.has(url)) {\n      Cache.remove(url);\n    }\n  };\n  texture.source.once(\"destroy\", () => {\n    if (loader.promiseCache[url]) {\n      warn(\"[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource.\");\n      unload();\n    }\n  });\n  texture.once(\"destroy\", () => {\n    if (!source.destroyed) {\n      warn(\"[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.\");\n      unload();\n    }\n  });\n  return texture;\n}\nexport { createTexture };","map":{"version":3,"names":["createTexture","source","loader","url","label","_sourceOrigin","texture","Texture","unload","promiseCache","Cache","has","remove","once","warn","destroyed"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/assets/loader/parsers/textures/utils/createTexture.ts"],"sourcesContent":["import { Texture } from '../../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../../utils/logging/warn';\nimport { Cache } from '../../../../cache/Cache';\n\nimport type { TextureSource } from '../../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Loader } from '../../../Loader';\n\n/**\n * Creates a texture from a source and adds it to the cache.\n * @param source - source of the texture\n * @param loader - loader\n * @param url - url of the texture\n * @ignore\n */\nexport function createTexture(source: TextureSource, loader: Loader, url: string)\n{\n    source.label = url;\n    source._sourceOrigin = url;\n\n    const texture = new Texture({\n        source,\n        label: url,\n    });\n\n    const unload = () =>\n    {\n        delete loader.promiseCache[url];\n\n        if (Cache.has(url))\n        {\n            Cache.remove(url);\n        }\n    };\n\n    // remove the promise from the loader and the url from the cache when the texture is destroyed\n    texture.source.once('destroy', () =>\n    {\n        if (loader.promiseCache[url])\n        {\n            // #if _DEBUG\n            warn('[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! '\n           + 'Use Assets.unload() instead of destroying the TextureSource.');\n            // #endif\n\n            unload();\n        }\n    });\n\n    texture.once('destroy', () =>\n    {\n        if (!source.destroyed)\n        {\n            // #if _DEBUG\n            warn('[Assets] A Texture managed by Assets was destroyed instead of unloaded! '\n             + 'Use Assets.unload() instead of destroying the Texture.');\n            // #endif\n\n            unload();\n        }\n    });\n\n    return texture;\n}\n"],"mappings":";;;;AAcgB,SAAAA,cAAcC,MAAuB,EAAAC,MAAA,EAAgBC,GACrE;EACIF,MAAA,CAAOG,KAAQ,GAAAD,GAAA;EACfF,MAAA,CAAOI,aAAgB,GAAAF,GAAA;EAEjB,MAAAG,OAAA,GAAU,IAAIC,OAAQ;IACxBN,MAAA;IACAG,KAAO,EAAAD;EAAA,CACV;EAED,MAAMK,MAAA,GAASA,CAAA,KACf;IACW,OAAAN,MAAA,CAAOO,YAAA,CAAaN,GAAG;IAE1B,IAAAO,KAAA,CAAMC,GAAI,CAAAR,GAAG,CACjB;MACIO,KAAA,CAAME,MAAA,CAAOT,GAAG;IAAA;EACpB,CACJ;EAGQG,OAAA,CAAAL,MAAA,CAAOY,IAAK,YAAW,MAC/B;IACQ,IAAAX,MAAA,CAAOO,YAAa,CAAAN,GAAG,CAC3B;MAEIW,IAAA,CAAK,4IAC0D;MAGxDN,MAAA;IAAA;EACX,CACH;EAEOF,OAAA,CAAAO,IAAA,CAAK,WAAW,MACxB;IACQ,KAACZ,MAAA,CAAOc,SACZ;MAEID,IAAA,CAAK,gIACsD;MAGpDN,MAAA;IAAA;EACX,CACH;EAEM,OAAAF,OAAA;AACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}