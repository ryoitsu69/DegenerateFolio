{"ast":null,"code":"import { stringCamelCase } from '@polkadot/util';\nimport { getAliasTypes } from '../../interfaces/alias.js';\nimport { knownOrigins } from '../../interfaces/runtime/definitions.js';\nconst BOXES = [['<', '>'], ['<', ','], [',', '>'], ['(', ')'], ['(', ','], [',', ','], [',', ')']];\n/**\n * Creates a compatible type mapping\n * @internal\n **/\nfunction compatType(specs, _type) {\n  const type = _type.toString();\n  const index = specs.findIndex(_ref => {\n    let {\n      def\n    } = _ref;\n    return def.HistoricMetaCompat === type;\n  });\n  if (index !== -1) {\n    return index;\n  }\n  return specs.push({\n    def: {\n      HistoricMetaCompat: type\n    }\n  }) - 1;\n}\nfunction compatTypes(specs) {\n  for (let i = 0, count = arguments.length <= 1 ? 0 : arguments.length - 1; i < count; i++) {\n    compatType(specs, i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1]);\n  }\n}\nfunction makeTupleType(specs, entries) {\n  return specs.push({\n    def: {\n      Tuple: entries\n    }\n  }) - 1;\n}\nfunction makeVariantType(modName, variantType, specs, variants) {\n  return specs.push({\n    def: {\n      Variant: {\n        variants\n      }\n    },\n    path: [\"pallet_\".concat(modName.toString()), 'pallet', variantType]\n  }) - 1;\n}\n/**\n * @internal\n * generate & register the OriginCaller type\n **/\nfunction registerOriginCaller(registry, modules, metaVersion) {\n  registry.register({\n    OriginCaller: {\n      _enum: modules.map((mod, index) => [mod.name.toString(), metaVersion >= 12 ? mod.index.toNumber() : index]).sort((a, b) => a[1] - b[1]).reduce((result, _ref2) => {\n        let [name, index] = _ref2;\n        for (let i = Object.keys(result).length; i < index; i++) {\n          result[\"Empty\".concat(i)] = 'Null';\n        }\n        result[name] = knownOrigins[name] || 'Null';\n        return result;\n      }, {})\n    }\n  });\n}\n/**\n * Find and apply the correct type override\n * @internal\n **/\nfunction setTypeOverride(sectionTypes, types) {\n  types.forEach(type => {\n    const override = Object.keys(sectionTypes).find(aliased => type.eq(aliased));\n    if (override) {\n      type.setOverride(sectionTypes[override]);\n    } else {\n      // FIXME: NOT happy with this approach, but gets over the initial hump cased by (Vec<Announcement>,BalanceOf)\n      const orig = type.toString();\n      const alias = Object.entries(sectionTypes).reduce((result, _ref3) => {\n        let [src, dst] = _ref3;\n        return BOXES.reduce((result, _ref4) => {\n          let [a, z] = _ref4;\n          return result.replace(\"\".concat(a).concat(src).concat(z), \"\".concat(a).concat(dst).concat(z));\n        }, result);\n      }, orig);\n      if (orig !== alias) {\n        type.setOverride(alias);\n      }\n    }\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n **/\nfunction convertCalls(specs, registry, modName, calls, sectionTypes) {\n  const variants = calls.map((_ref5, index) => {\n    let {\n      args,\n      docs,\n      name\n    } = _ref5;\n    setTypeOverride(sectionTypes, args.map(_ref6 => {\n      let {\n        type\n      } = _ref6;\n      return type;\n    }));\n    return registry.createTypeUnsafe('SiVariant', [{\n      docs,\n      fields: args.map(_ref7 => {\n        let {\n          name,\n          type\n        } = _ref7;\n        return registry.createTypeUnsafe('SiField', [{\n          name,\n          type: compatType(specs, type)\n        }]);\n      }),\n      index,\n      name\n    }]);\n  });\n  return registry.createTypeUnsafe('PalletCallMetadataV14', [{\n    type: makeVariantType(modName, 'Call', specs, variants)\n  }]);\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n */\nfunction convertConstants(specs, registry, constants, sectionTypes) {\n  return constants.map(_ref8 => {\n    let {\n      docs,\n      name,\n      type,\n      value\n    } = _ref8;\n    setTypeOverride(sectionTypes, [type]);\n    return registry.createTypeUnsafe('PalletConstantMetadataV14', [{\n      docs,\n      name,\n      type: compatType(specs, type),\n      value\n    }]);\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n */\nfunction convertErrors(specs, registry, modName, errors, _sectionTypes) {\n  const variants = errors.map((_ref9, index) => {\n    let {\n      docs,\n      name\n    } = _ref9;\n    return registry.createTypeUnsafe('SiVariant', [{\n      docs,\n      fields: [],\n      index,\n      name\n    }]);\n  });\n  return registry.createTypeUnsafe('PalletErrorMetadataV14', [{\n    type: makeVariantType(modName, 'Error', specs, variants)\n  }]);\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n **/\nfunction convertEvents(specs, registry, modName, events, sectionTypes) {\n  const variants = events.map((_ref10, index) => {\n    let {\n      args,\n      docs,\n      name\n    } = _ref10;\n    setTypeOverride(sectionTypes, args);\n    return registry.createTypeUnsafe('SiVariant', [{\n      docs,\n      fields: args.map(t => registry.createTypeUnsafe('SiField', [{\n        type: compatType(specs, t)\n      }])),\n      index,\n      name\n    }]);\n  });\n  return registry.createTypeUnsafe('PalletEventMetadataV14', [{\n    type: makeVariantType(modName, 'Event', specs, variants)\n  }]);\n}\nfunction createMapEntry(specs, registry, sectionTypes, _ref11) {\n  let {\n    hashers,\n    isLinked,\n    isOptional,\n    keys,\n    value\n  } = _ref11;\n  setTypeOverride(sectionTypes, [value, ...(Array.isArray(keys) ? keys : [keys])]);\n  return registry.createTypeUnsafe('StorageEntryTypeV14', [{\n    Map: {\n      hashers,\n      key: hashers.length === 1 ? compatType(specs, keys[0]) : makeTupleType(specs, keys.map(t => compatType(specs, t))),\n      value: isLinked\n      // For previous-generation linked-map support, the actual storage result\n      // is a Tuple with the value and the Linkage (Option appears in teh value-part only)\n      ? compatType(specs, \"(\".concat(isOptional ? \"Option<\".concat(value.toString(), \">\") : value.toString(), \", Linkage<\").concat(keys[0].toString(), \">)\")) : compatType(specs, value)\n    }\n  }]);\n}\n/**\n * Apply module-specific storage type overrides (always part of toV14)\n * @internal\n **/\nfunction convertStorage(specs, registry, _ref12, sectionTypes) {\n  let {\n    items,\n    prefix\n  } = _ref12;\n  return registry.createTypeUnsafe('PalletStorageMetadataV14', [{\n    items: items.map(_ref13 => {\n      let {\n        docs,\n        fallback,\n        modifier,\n        name,\n        type\n      } = _ref13;\n      let entryType;\n      if (type.isPlain) {\n        const plain = type.asPlain;\n        setTypeOverride(sectionTypes, [plain]);\n        entryType = registry.createTypeUnsafe('StorageEntryTypeV14', [{\n          Plain: compatType(specs, plain)\n        }]);\n      } else if (type.isMap) {\n        const map = type.asMap;\n        entryType = createMapEntry(specs, registry, sectionTypes, {\n          hashers: [map.hasher],\n          isLinked: map.linked.isTrue,\n          isOptional: modifier.isOptional,\n          keys: [map.key],\n          value: map.value\n        });\n      } else if (type.isDoubleMap) {\n        const dm = type.asDoubleMap;\n        entryType = createMapEntry(specs, registry, sectionTypes, {\n          hashers: [dm.hasher, dm.key2Hasher],\n          isLinked: false,\n          isOptional: modifier.isOptional,\n          keys: [dm.key1, dm.key2],\n          value: dm.value\n        });\n      } else {\n        const nm = type.asNMap;\n        entryType = createMapEntry(specs, registry, sectionTypes, {\n          hashers: nm.hashers,\n          isLinked: false,\n          isOptional: modifier.isOptional,\n          keys: nm.keyVec,\n          value: nm.value\n        });\n      }\n      return registry.createTypeUnsafe('StorageEntryMetadataV14', [{\n        docs,\n        fallback,\n        modifier,\n        name,\n        type: entryType\n      }]);\n    }),\n    prefix\n  }]);\n}\n/** @internal */\nfunction convertExtrinsic(registry, _ref14) {\n  let {\n    signedExtensions,\n    version\n  } = _ref14;\n  return registry.createTypeUnsafe('ExtrinsicMetadataV14', [{\n    signedExtensions: signedExtensions.map(identifier => ({\n      identifier,\n      type: 0 // we don't map the fields at all\n    })),\n    type: 0,\n    // Map to extrinsic like in v14?\n    version\n  }]);\n}\n/** @internal */\nfunction createPallet(specs, registry, mod, _ref15) {\n  let {\n    calls,\n    constants,\n    errors,\n    events,\n    storage\n  } = _ref15;\n  const sectionTypes = getAliasTypes(registry, stringCamelCase(mod.name));\n  return registry.createTypeUnsafe('PalletMetadataV14', [{\n    calls: calls && convertCalls(specs, registry, mod.name, calls, sectionTypes),\n    constants: convertConstants(specs, registry, constants, sectionTypes),\n    errors: errors && convertErrors(specs, registry, mod.name, errors, sectionTypes),\n    events: events && convertEvents(specs, registry, mod.name, events, sectionTypes),\n    index: mod.index,\n    name: mod.name,\n    storage: storage && convertStorage(specs, registry, storage, sectionTypes)\n  }]);\n}\n/**\n * Convert the Metadata to v14\n * @internal\n **/\nexport function toV14(registry, v13, metaVersion) {\n  const specs = [];\n  // position 0 always has Null, additionally add internal defaults\n  compatTypes(specs, 'Null', 'u8', 'u16', 'u32', 'u64');\n  registerOriginCaller(registry, v13.modules, metaVersion);\n  const extrinsic = convertExtrinsic(registry, v13.extrinsic);\n  const pallets = v13.modules.map(mod => createPallet(specs, registry, mod, {\n    calls: mod.calls.unwrapOr(null),\n    constants: mod.constants,\n    errors: mod.errors.length ? mod.errors : null,\n    events: mod.events.unwrapOr(null),\n    storage: mod.storage.unwrapOr(null)\n  }));\n  return registry.createTypeUnsafe('MetadataV14', [{\n    extrinsic,\n    lookup: {\n      types: specs.map((type, id) => registry.createTypeUnsafe('PortableType', [{\n        id,\n        type\n      }]))\n    },\n    pallets\n  }]);\n}","map":{"version":3,"names":["stringCamelCase","getAliasTypes","knownOrigins","BOXES","compatType","specs","_type","type","toString","index","findIndex","_ref","def","HistoricMetaCompat","push","compatTypes","i","count","arguments","length","undefined","makeTupleType","entries","Tuple","makeVariantType","modName","variantType","variants","Variant","path","concat","registerOriginCaller","registry","modules","metaVersion","register","OriginCaller","_enum","map","mod","name","toNumber","sort","a","b","reduce","result","_ref2","Object","keys","setTypeOverride","sectionTypes","types","forEach","override","find","aliased","eq","setOverride","orig","alias","_ref3","src","dst","_ref4","z","replace","convertCalls","calls","_ref5","args","docs","_ref6","createTypeUnsafe","fields","_ref7","convertConstants","constants","_ref8","value","convertErrors","errors","_sectionTypes","_ref9","convertEvents","events","_ref10","t","createMapEntry","_ref11","hashers","isLinked","isOptional","Array","isArray","Map","key","convertStorage","_ref12","items","prefix","_ref13","fallback","modifier","entryType","isPlain","plain","asPlain","Plain","isMap","asMap","hasher","linked","isTrue","isDoubleMap","dm","asDoubleMap","key2Hasher","key1","key2","nm","asNMap","keyVec","convertExtrinsic","_ref14","signedExtensions","version","identifier","createPallet","_ref15","storage","toV14","v13","extrinsic","pallets","unwrapOr","lookup","id"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/metadata/v13/toV14.js"],"sourcesContent":["import { stringCamelCase } from '@polkadot/util';\nimport { getAliasTypes } from '../../interfaces/alias.js';\nimport { knownOrigins } from '../../interfaces/runtime/definitions.js';\nconst BOXES = [['<', '>'], ['<', ','], [',', '>'], ['(', ')'], ['(', ','], [',', ','], [',', ')']];\n/**\n * Creates a compatible type mapping\n * @internal\n **/\nfunction compatType(specs, _type) {\n    const type = _type.toString();\n    const index = specs.findIndex(({ def }) => def.HistoricMetaCompat === type);\n    if (index !== -1) {\n        return index;\n    }\n    return specs.push({\n        def: {\n            HistoricMetaCompat: type\n        }\n    }) - 1;\n}\nfunction compatTypes(specs, ...types) {\n    for (let i = 0, count = types.length; i < count; i++) {\n        compatType(specs, types[i]);\n    }\n}\nfunction makeTupleType(specs, entries) {\n    return specs.push({\n        def: {\n            Tuple: entries\n        }\n    }) - 1;\n}\nfunction makeVariantType(modName, variantType, specs, variants) {\n    return specs.push({\n        def: {\n            Variant: { variants }\n        },\n        path: [`pallet_${modName.toString()}`, 'pallet', variantType]\n    }) - 1;\n}\n/**\n * @internal\n * generate & register the OriginCaller type\n **/\nfunction registerOriginCaller(registry, modules, metaVersion) {\n    registry.register({\n        OriginCaller: {\n            _enum: modules\n                .map((mod, index) => [\n                mod.name.toString(),\n                metaVersion >= 12\n                    ? mod.index.toNumber()\n                    : index\n            ])\n                .sort((a, b) => a[1] - b[1])\n                .reduce((result, [name, index]) => {\n                for (let i = Object.keys(result).length; i < index; i++) {\n                    result[`Empty${i}`] = 'Null';\n                }\n                result[name] = knownOrigins[name] || 'Null';\n                return result;\n            }, {})\n        }\n    });\n}\n/**\n * Find and apply the correct type override\n * @internal\n **/\nfunction setTypeOverride(sectionTypes, types) {\n    types.forEach((type) => {\n        const override = Object.keys(sectionTypes).find((aliased) => type.eq(aliased));\n        if (override) {\n            type.setOverride(sectionTypes[override]);\n        }\n        else {\n            // FIXME: NOT happy with this approach, but gets over the initial hump cased by (Vec<Announcement>,BalanceOf)\n            const orig = type.toString();\n            const alias = Object\n                .entries(sectionTypes)\n                .reduce((result, [src, dst]) => BOXES.reduce((result, [a, z]) => result.replace(`${a}${src}${z}`, `${a}${dst}${z}`), result), orig);\n            if (orig !== alias) {\n                type.setOverride(alias);\n            }\n        }\n    });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n **/\nfunction convertCalls(specs, registry, modName, calls, sectionTypes) {\n    const variants = calls.map(({ args, docs, name }, index) => {\n        setTypeOverride(sectionTypes, args.map(({ type }) => type));\n        return registry.createTypeUnsafe('SiVariant', [{\n                docs,\n                fields: args.map(({ name, type }) => registry.createTypeUnsafe('SiField', [{ name, type: compatType(specs, type) }])),\n                index,\n                name\n            }]);\n    });\n    return registry.createTypeUnsafe('PalletCallMetadataV14', [{\n            type: makeVariantType(modName, 'Call', specs, variants)\n        }]);\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n */\nfunction convertConstants(specs, registry, constants, sectionTypes) {\n    return constants.map(({ docs, name, type, value }) => {\n        setTypeOverride(sectionTypes, [type]);\n        return registry.createTypeUnsafe('PalletConstantMetadataV14', [{\n                docs,\n                name,\n                type: compatType(specs, type),\n                value\n            }]);\n    });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n */\nfunction convertErrors(specs, registry, modName, errors, _sectionTypes) {\n    const variants = errors.map(({ docs, name }, index) => registry.createTypeUnsafe('SiVariant', [{\n            docs,\n            fields: [],\n            index,\n            name\n        }]));\n    return registry.createTypeUnsafe('PalletErrorMetadataV14', [{\n            type: makeVariantType(modName, 'Error', specs, variants)\n        }]);\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n **/\nfunction convertEvents(specs, registry, modName, events, sectionTypes) {\n    const variants = events.map(({ args, docs, name }, index) => {\n        setTypeOverride(sectionTypes, args);\n        return registry.createTypeUnsafe('SiVariant', [{\n                docs,\n                fields: args.map((t) => registry.createTypeUnsafe('SiField', [{ type: compatType(specs, t) }])),\n                index,\n                name\n            }]);\n    });\n    return registry.createTypeUnsafe('PalletEventMetadataV14', [{\n            type: makeVariantType(modName, 'Event', specs, variants)\n        }]);\n}\nfunction createMapEntry(specs, registry, sectionTypes, { hashers, isLinked, isOptional, keys, value }) {\n    setTypeOverride(sectionTypes, [value, ...(Array.isArray(keys) ? keys : [keys])]);\n    return registry.createTypeUnsafe('StorageEntryTypeV14', [{\n            Map: {\n                hashers,\n                key: hashers.length === 1\n                    ? compatType(specs, keys[0])\n                    : makeTupleType(specs, keys.map((t) => compatType(specs, t))),\n                value: isLinked\n                    // For previous-generation linked-map support, the actual storage result\n                    // is a Tuple with the value and the Linkage (Option appears in teh value-part only)\n                    ? compatType(specs, `(${isOptional ? `Option<${value.toString()}>` : value.toString()}, Linkage<${keys[0].toString()}>)`)\n                    : compatType(specs, value)\n            }\n        }]);\n}\n/**\n * Apply module-specific storage type overrides (always part of toV14)\n * @internal\n **/\nfunction convertStorage(specs, registry, { items, prefix }, sectionTypes) {\n    return registry.createTypeUnsafe('PalletStorageMetadataV14', [{\n            items: items.map(({ docs, fallback, modifier, name, type }) => {\n                let entryType;\n                if (type.isPlain) {\n                    const plain = type.asPlain;\n                    setTypeOverride(sectionTypes, [plain]);\n                    entryType = registry.createTypeUnsafe('StorageEntryTypeV14', [{\n                            Plain: compatType(specs, plain)\n                        }]);\n                }\n                else if (type.isMap) {\n                    const map = type.asMap;\n                    entryType = createMapEntry(specs, registry, sectionTypes, {\n                        hashers: [map.hasher],\n                        isLinked: map.linked.isTrue,\n                        isOptional: modifier.isOptional,\n                        keys: [map.key],\n                        value: map.value\n                    });\n                }\n                else if (type.isDoubleMap) {\n                    const dm = type.asDoubleMap;\n                    entryType = createMapEntry(specs, registry, sectionTypes, {\n                        hashers: [dm.hasher, dm.key2Hasher],\n                        isLinked: false,\n                        isOptional: modifier.isOptional,\n                        keys: [dm.key1, dm.key2],\n                        value: dm.value\n                    });\n                }\n                else {\n                    const nm = type.asNMap;\n                    entryType = createMapEntry(specs, registry, sectionTypes, {\n                        hashers: nm.hashers,\n                        isLinked: false,\n                        isOptional: modifier.isOptional,\n                        keys: nm.keyVec,\n                        value: nm.value\n                    });\n                }\n                return registry.createTypeUnsafe('StorageEntryMetadataV14', [{\n                        docs,\n                        fallback,\n                        modifier,\n                        name,\n                        type: entryType\n                    }]);\n            }),\n            prefix\n        }]);\n}\n/** @internal */\nfunction convertExtrinsic(registry, { signedExtensions, version }) {\n    return registry.createTypeUnsafe('ExtrinsicMetadataV14', [{\n            signedExtensions: signedExtensions.map((identifier) => ({\n                identifier,\n                type: 0 // we don't map the fields at all\n            })),\n            type: 0, // Map to extrinsic like in v14?\n            version\n        }]);\n}\n/** @internal */\nfunction createPallet(specs, registry, mod, { calls, constants, errors, events, storage }) {\n    const sectionTypes = getAliasTypes(registry, stringCamelCase(mod.name));\n    return registry.createTypeUnsafe('PalletMetadataV14', [{\n            calls: calls && convertCalls(specs, registry, mod.name, calls, sectionTypes),\n            constants: convertConstants(specs, registry, constants, sectionTypes),\n            errors: errors && convertErrors(specs, registry, mod.name, errors, sectionTypes),\n            events: events && convertEvents(specs, registry, mod.name, events, sectionTypes),\n            index: mod.index,\n            name: mod.name,\n            storage: storage && convertStorage(specs, registry, storage, sectionTypes)\n        }]);\n}\n/**\n * Convert the Metadata to v14\n * @internal\n **/\nexport function toV14(registry, v13, metaVersion) {\n    const specs = [];\n    // position 0 always has Null, additionally add internal defaults\n    compatTypes(specs, 'Null', 'u8', 'u16', 'u32', 'u64');\n    registerOriginCaller(registry, v13.modules, metaVersion);\n    const extrinsic = convertExtrinsic(registry, v13.extrinsic);\n    const pallets = v13.modules.map((mod) => createPallet(specs, registry, mod, {\n        calls: mod.calls.unwrapOr(null),\n        constants: mod.constants,\n        errors: mod.errors.length ? mod.errors : null,\n        events: mod.events.unwrapOr(null),\n        storage: mod.storage.unwrapOr(null)\n    }));\n    return registry.createTypeUnsafe('MetadataV14', [{\n            extrinsic,\n            lookup: {\n                types: specs.map((type, id) => registry.createTypeUnsafe('PortableType', [{ id, type }]))\n            },\n            pallets\n        }]);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}