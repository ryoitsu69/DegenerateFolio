{"ast":null,"code":"import { identity, isFunction, isHex, isString, isU8a, stringify, u8aConcatStrict, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8a, mapToTypeMap, typesToConstructors, typeToConstructor } from '../utils/index.js';\n/** @internal */\nfunction decodeTuple(registry, result, value, Classes) {\n  if (Array.isArray(value)) {\n    const Types = Classes[0];\n    for (let i = 0, count = Types.length; i < count; i++) {\n      try {\n        const entry = value?.[i];\n        result[i] = entry instanceof Types[i] ? entry : new Types[i](registry, entry);\n      } catch (error) {\n        throw new Error(`Tuple: failed on ${i}:: ${error.message}`);\n      }\n    }\n    return [result, 0];\n  } else if (isHex(value)) {\n    return decodeU8a(registry, result, u8aToU8a(value), Classes);\n  } else if (!value || !result.length) {\n    const Types = Classes[0];\n    for (let i = 0, count = Types.length; i < count; i++) {\n      result[i] = new Types[i](registry);\n    }\n    return [result, 0];\n  }\n  throw new Error(`Expected array input to Tuple decoding, found ${typeof value}: ${stringify(value)}`);\n}\n/**\n * @name Tuple\n * @description\n * A Tuple defines an anonymous fixed-length array, where each element has its\n * own type. It extends the base JS `Array` object.\n */\nexport class Tuple extends AbstractArray {\n  __internal__Types;\n  constructor(registry, Types, value, {\n    definition,\n    setDefinition = identity\n  } = {}) {\n    const Classes = definition || setDefinition(Array.isArray(Types) ? [typesToConstructors(registry, Types), []] : isFunction(Types) || isString(Types) ? [[typeToConstructor(registry, Types)], []] : mapToTypeMap(registry, Types));\n    super(registry, Classes[0].length);\n    this.initialU8aLength = (isU8a(value) ? decodeU8a(registry, this, value, Classes) : decodeTuple(registry, this, value, Classes))[1];\n    this.__internal__Types = Classes;\n  }\n  static with(Types) {\n    let definition;\n    // eslint-disable-next-line no-return-assign\n    const setDefinition = d => definition = d;\n    return class extends Tuple {\n      constructor(registry, value) {\n        super(registry, Types, value, {\n          definition,\n          setDefinition\n        });\n      }\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    let total = 0;\n    for (let i = 0, count = this.length; i < count; i++) {\n      total += this[i].encodedLength;\n    }\n    return total;\n  }\n  /**\n   * @description The types definition of the tuple\n   */\n  get Types() {\n    return this.__internal__Types[1].length ? this.__internal__Types[1] : this.__internal__Types[0].map(T => new T(this.registry).toRawType());\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return {\n      inner: this.inspectInner()\n    };\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    const types = this.__internal__Types[0].map(T => this.registry.getClassName(T) || new T(this.registry).toRawType());\n    return `(${types.join(',')})`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    // Overwrite the default toString representation of Array.\n    return stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    return u8aConcatStrict(this.toU8aInner(isBare));\n  }\n}","map":{"version":3,"names":["identity","isFunction","isHex","isString","isU8a","stringify","u8aConcatStrict","u8aToU8a","AbstractArray","decodeU8a","mapToTypeMap","typesToConstructors","typeToConstructor","decodeTuple","registry","result","value","Classes","Array","isArray","Types","i","count","length","entry","error","Error","message","Tuple","__internal__Types","constructor","definition","setDefinition","initialU8aLength","with","d","encodedLength","total","map","T","toRawType","inspect","inner","inspectInner","types","getClassName","join","toString","toJSON","toU8a","isBare","toU8aInner"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/base/Tuple.js"],"sourcesContent":["import { identity, isFunction, isHex, isString, isU8a, stringify, u8aConcatStrict, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8a, mapToTypeMap, typesToConstructors, typeToConstructor } from '../utils/index.js';\n/** @internal */\nfunction decodeTuple(registry, result, value, Classes) {\n    if (Array.isArray(value)) {\n        const Types = Classes[0];\n        for (let i = 0, count = Types.length; i < count; i++) {\n            try {\n                const entry = value?.[i];\n                result[i] = entry instanceof Types[i]\n                    ? entry\n                    : new Types[i](registry, entry);\n            }\n            catch (error) {\n                throw new Error(`Tuple: failed on ${i}:: ${error.message}`);\n            }\n        }\n        return [result, 0];\n    }\n    else if (isHex(value)) {\n        return decodeU8a(registry, result, u8aToU8a(value), Classes);\n    }\n    else if (!value || !result.length) {\n        const Types = Classes[0];\n        for (let i = 0, count = Types.length; i < count; i++) {\n            result[i] = new Types[i](registry);\n        }\n        return [result, 0];\n    }\n    throw new Error(`Expected array input to Tuple decoding, found ${typeof value}: ${stringify(value)}`);\n}\n/**\n * @name Tuple\n * @description\n * A Tuple defines an anonymous fixed-length array, where each element has its\n * own type. It extends the base JS `Array` object.\n */\nexport class Tuple extends AbstractArray {\n    __internal__Types;\n    constructor(registry, Types, value, { definition, setDefinition = identity } = {}) {\n        const Classes = definition || setDefinition(Array.isArray(Types)\n            ? [typesToConstructors(registry, Types), []]\n            : isFunction(Types) || isString(Types)\n                ? [[typeToConstructor(registry, Types)], []]\n                : mapToTypeMap(registry, Types));\n        super(registry, Classes[0].length);\n        this.initialU8aLength = (isU8a(value)\n            ? decodeU8a(registry, this, value, Classes)\n            : decodeTuple(registry, this, value, Classes))[1];\n        this.__internal__Types = Classes;\n    }\n    static with(Types) {\n        let definition;\n        // eslint-disable-next-line no-return-assign\n        const setDefinition = (d) => definition = d;\n        return class extends Tuple {\n            constructor(registry, value) {\n                super(registry, Types, value, { definition, setDefinition });\n            }\n        };\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        let total = 0;\n        for (let i = 0, count = this.length; i < count; i++) {\n            total += this[i].encodedLength;\n        }\n        return total;\n    }\n    /**\n     * @description The types definition of the tuple\n     */\n    get Types() {\n        return this.__internal__Types[1].length\n            ? this.__internal__Types[1]\n            : this.__internal__Types[0].map((T) => new T(this.registry).toRawType());\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            inner: this.inspectInner()\n        };\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        const types = this.__internal__Types[0].map((T) => this.registry.getClassName(T) || new T(this.registry).toRawType());\n        return `(${types.join(',')})`;\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        // Overwrite the default toString representation of Array.\n        return stringify(this.toJSON());\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        return u8aConcatStrict(this.toU8aInner(isBare));\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}