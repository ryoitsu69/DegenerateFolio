{"ast":null,"code":"import { warn } from '../../../../../utils/logging/warn.mjs';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\"use strict\";\nfunction ensureAttributes(geometry, extractedData) {\n  for (const i in geometry.attributes) {\n    const attribute = geometry.attributes[i];\n    const attributeData = extractedData[i];\n    if (attributeData) {\n      attribute.location ?? (attribute.location = attributeData.location);\n      attribute.format ?? (attribute.format = attributeData.format);\n      attribute.offset ?? (attribute.offset = attributeData.offset);\n      attribute.instance ?? (attribute.instance = attributeData.instance);\n    } else {\n      warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n    }\n  }\n  ensureStartAndStride(geometry);\n}\nfunction ensureStartAndStride(geometry) {\n  const {\n    buffers,\n    attributes\n  } = geometry;\n  const tempStride = {};\n  const tempStart = {};\n  for (const j in buffers) {\n    const buffer = buffers[j];\n    tempStride[buffer.uid] = 0;\n    tempStart[buffer.uid] = 0;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);\n    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);\n    tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n}\nexport { ensureAttributes };","map":{"version":3,"names":["ensureAttributes","geometry","extractedData","i","attributes","attribute","attributeData","location","format","offset","instance","warn","ensureStartAndStride","buffers","tempStride","tempStart","j","buffer","uid","getAttributeInfoFromFormat","stride","start"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/ensureAttributes.ts"],"sourcesContent":["import { warn } from '../../../../../utils/logging/warn';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { Geometry } from '../../../shared/geometry/Geometry';\nimport type { ExtractedAttributeData } from './extractAttributesFromGlProgram';\n\n/**\n * This function looks at the attribute information provided to the geometry and attempts\n * to fill in an gaps. WE do this by looking at the extracted data from the shader and\n * making best guesses.\n *\n * Most of th etime users don't need to provide all the attribute info beyond the data itself, so we\n * can fill in the gaps for them. If you are using attributes in a more advanced way, you can\n * don't forget to add all the info at creation!\n * @param geometry - the geometry to ensure attributes for\n * @param extractedData - the extracted data from the shader\n */\nexport function ensureAttributes(\n    geometry: Geometry,\n    extractedData: Record<string, ExtractedAttributeData>\n): void\n{\n    for (const i in geometry.attributes)\n    {\n        const attribute = geometry.attributes[i];\n        const attributeData = extractedData[i];\n\n        if (attributeData)\n        {\n            attribute.location ??= attributeData.location;\n            attribute.format ??= attributeData.format;\n            attribute.offset ??= attributeData.offset;\n            attribute.instance ??= attributeData.instance;\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n        }\n    }\n\n    ensureStartAndStride(geometry);\n}\n\nfunction ensureStartAndStride(geometry: Geometry): void\n{\n    const { buffers, attributes } = geometry;\n\n    const tempStride: Record<string, number> = {};\n    const tempStart: Record<string, number> = {};\n\n    for (const j in buffers)\n    {\n        const buffer = buffers[j];\n\n        tempStride[buffer.uid] = 0;\n        tempStart[buffer.uid] = 0;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        attribute.stride ??= tempStride[attribute.buffer.uid];\n\n        attribute.start ??= tempStart[attribute.buffer.uid];\n\n        tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n}\n"],"mappings":";;;AAiBgB,SAAAA,iBACZC,QAAA,EACAC,aAEJ;EACe,WAAAC,CAAA,IAAKF,QAAA,CAASG,UACzB;IACU,MAAAC,SAAA,GAAYJ,QAAS,CAAAG,UAAA,CAAWD,CAAC;IACjC,MAAAG,aAAA,GAAgBJ,aAAA,CAAcC,CAAC;IAErC,IAAIG,aACJ;MACcD,SAAA,CAAAE,QAAA,KAAVF,SAAU,CAAAE,QAAA,GAAaD,aAAc,CAAAC,QAAA;MAC3BF,SAAA,CAAAG,MAAA,KAAVH,SAAU,CAAAG,MAAA,GAAWF,aAAc,CAAAE,MAAA;MACzBH,SAAA,CAAAI,MAAA,KAAVJ,SAAU,CAAAI,MAAA,GAAWH,aAAc,CAAAG,MAAA;MACzBJ,SAAA,CAAAK,QAAA,KAAVL,SAAU,CAAAK,QAAA,GAAaJ,aAAc,CAAAI,QAAA;IAAA,CAGzC;MAESC,IAAA,cAAaR,CAAoG;IAAA;EAC1H;EAGJS,oBAAA,CAAqBX,QAAQ;AACjC;AAEA,SAASW,qBAAqBX,QAC9B;EACU;IAAEY,OAAS;IAAAT;EAAA,CAAe,GAAAH,QAAA;EAEhC,MAAMa,UAAA,GAAqC,EAAC;EAC5C,MAAMC,SAAA,GAAoC,EAAC;EAE3C,WAAWC,CAAA,IAAKH,OAChB;IACU,MAAAI,MAAA,GAASJ,OAAA,CAAQG,CAAC;IAEbF,UAAA,CAAAG,MAAA,CAAOC,GAAG,CAAI;IACfH,SAAA,CAAAE,MAAA,CAAOC,GAAG,CAAI;EAAA;EAG5B,WAAWF,CAAA,IAAKZ,UAChB;IACU,MAAAC,SAAA,GAAYD,UAAA,CAAWY,CAAC;IAE9BF,UAAA,CAAWT,SAAA,CAAUY,MAAO,CAAAC,GAAG,KAAKC,0BAA2B,CAAAd,SAAA,CAAUG,MAAM,CAAE,CAAAY,MAAA;EAAA;EAGrF,WAAWJ,CAAA,IAAKZ,UAChB;IACU,MAAAC,SAAA,GAAYD,UAAA,CAAWY,CAAC;IAE9BX,SAAA,CAAUe,MAAA,KAAVf,SAAU,CAAAe,MAAA,GAAWN,UAAW,CAAAT,SAAA,CAAUY,MAAA,CAAOC,GAAG;IAEpDb,SAAA,CAAUgB,KAAA,KAAVhB,SAAU,CAAAgB,KAAA,GAAUN,SAAU,CAAAV,SAAA,CAAUY,MAAA,CAAOC,GAAG;IAElDH,SAAA,CAAUV,SAAA,CAAUY,MAAO,CAAAC,GAAG,KAAKC,0BAA2B,CAAAd,SAAA,CAAUG,MAAM,CAAE,CAAAY,MAAA;EAAA;AAExF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}