{"ast":null,"code":"import _defineProperty from \"/home/ryoitsu/Documents/test/react-todo-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { compactFromU8aLim, identity, isHex, isU8a, logger, stringify, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8aVec, typeToConstructor } from '../utils/index.js';\nconst MAX_LENGTH = 64 * 1024;\nconst l = logger('Vec');\nfunction decodeVecLength(value) {\n  if (Array.isArray(value)) {\n    return [value, value.length, 0];\n  } else if (isU8a(value) || isHex(value)) {\n    const u8a = u8aToU8a(value);\n    const [startAt, length] = compactFromU8aLim(u8a);\n    if (length > MAX_LENGTH) {\n      throw new Error(\"Vec length \".concat(length.toString(), \" exceeds \").concat(MAX_LENGTH));\n    }\n    return [u8a, length, startAt];\n  } else if (!value) {\n    return [null, 0, 0];\n  }\n  throw new Error(\"Expected array/hex input to Vec<*> decoding, found \".concat(typeof value, \": \").concat(stringify(value)));\n}\nexport function decodeVec(registry, result, value, startAt, Type) {\n  if (Array.isArray(value)) {\n    const count = result.length;\n    for (let i = 0; i < count; i++) {\n      // 26/08/2022 this is actually a false positive - after recent eslint upgdates\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const entry = value[i];\n      try {\n        result[i] = entry instanceof Type ? entry : new Type(registry, entry);\n      } catch (error) {\n        l.error(\"Unable to decode on index \".concat(i), error.message);\n        throw error;\n      }\n    }\n    return [0, 0];\n  } else if (!value) {\n    return [0, 0];\n  }\n  // we don't need more checks, we already limited it via the length decoding\n  return decodeU8aVec(registry, result, u8aToU8a(value), startAt, Type);\n}\n/**\n * @name Vec\n * @description\n * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows\n * construction with the passed `Type` in the constructor. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n */\nexport class Vec extends AbstractArray {\n  constructor(registry, Type) {\n    let value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let {\n      definition,\n      setDefinition = identity\n    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const [decodeFrom, length, startAt] = decodeVecLength(value);\n    super(registry, length);\n    _defineProperty(this, \"__internal__Type\", void 0);\n    this.__internal__Type = definition || setDefinition(typeToConstructor(registry, Type));\n    this.initialU8aLength = (isU8a(decodeFrom) ? decodeU8aVec(registry, this, decodeFrom, startAt, this.__internal__Type) : decodeVec(registry, this, decodeFrom, startAt, this.__internal__Type))[0];\n  }\n  static with(Type) {\n    let definition;\n    // eslint-disable-next-line no-return-assign\n    const setDefinition = d => definition = d;\n    return class extends Vec {\n      constructor(registry, value) {\n        super(registry, Type, value, {\n          definition,\n          setDefinition\n        });\n      }\n    };\n  }\n  /**\n   * @description The type for the items\n   */\n  get Type() {\n    return this.__internal__Type.name;\n  }\n  /**\n   * @description Finds the index of the value in the array\n   */\n  indexOf(other) {\n    // convert type first, this removes overhead from the eq\n    const check = other instanceof this.__internal__Type ? other : new this.__internal__Type(this.registry, other);\n    for (let i = 0, count = this.length; i < count; i++) {\n      if (check.eq(this[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return \"Vec<\".concat(this.registry.getClassName(this.__internal__Type) || new this.__internal__Type(this.registry).toRawType(), \">\");\n  }\n}","map":{"version":3,"names":["compactFromU8aLim","identity","isHex","isU8a","logger","stringify","u8aToU8a","AbstractArray","decodeU8aVec","typeToConstructor","MAX_LENGTH","l","decodeVecLength","value","Array","isArray","length","u8a","startAt","Error","concat","toString","decodeVec","registry","result","Type","count","i","entry","error","message","Vec","constructor","arguments","undefined","definition","setDefinition","decodeFrom","_defineProperty","__internal__Type","initialU8aLength","with","d","name","indexOf","other","check","eq","toRawType","getClassName"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/base/Vec.js"],"sourcesContent":["import { compactFromU8aLim, identity, isHex, isU8a, logger, stringify, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8aVec, typeToConstructor } from '../utils/index.js';\nconst MAX_LENGTH = 64 * 1024;\nconst l = logger('Vec');\nfunction decodeVecLength(value) {\n    if (Array.isArray(value)) {\n        return [value, value.length, 0];\n    }\n    else if (isU8a(value) || isHex(value)) {\n        const u8a = u8aToU8a(value);\n        const [startAt, length] = compactFromU8aLim(u8a);\n        if (length > MAX_LENGTH) {\n            throw new Error(`Vec length ${length.toString()} exceeds ${MAX_LENGTH}`);\n        }\n        return [u8a, length, startAt];\n    }\n    else if (!value) {\n        return [null, 0, 0];\n    }\n    throw new Error(`Expected array/hex input to Vec<*> decoding, found ${typeof value}: ${stringify(value)}`);\n}\nexport function decodeVec(registry, result, value, startAt, Type) {\n    if (Array.isArray(value)) {\n        const count = result.length;\n        for (let i = 0; i < count; i++) {\n            // 26/08/2022 this is actually a false positive - after recent eslint upgdates\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const entry = value[i];\n            try {\n                result[i] = entry instanceof Type\n                    ? entry\n                    : new Type(registry, entry);\n            }\n            catch (error) {\n                l.error(`Unable to decode on index ${i}`, error.message);\n                throw error;\n            }\n        }\n        return [0, 0];\n    }\n    else if (!value) {\n        return [0, 0];\n    }\n    // we don't need more checks, we already limited it via the length decoding\n    return decodeU8aVec(registry, result, u8aToU8a(value), startAt, Type);\n}\n/**\n * @name Vec\n * @description\n * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows\n * construction with the passed `Type` in the constructor. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n */\nexport class Vec extends AbstractArray {\n    __internal__Type;\n    constructor(registry, Type, value = [], { definition, setDefinition = identity } = {}) {\n        const [decodeFrom, length, startAt] = decodeVecLength(value);\n        super(registry, length);\n        this.__internal__Type = definition || setDefinition(typeToConstructor(registry, Type));\n        this.initialU8aLength = (isU8a(decodeFrom)\n            ? decodeU8aVec(registry, this, decodeFrom, startAt, this.__internal__Type)\n            : decodeVec(registry, this, decodeFrom, startAt, this.__internal__Type))[0];\n    }\n    static with(Type) {\n        let definition;\n        // eslint-disable-next-line no-return-assign\n        const setDefinition = (d) => (definition = d);\n        return class extends Vec {\n            constructor(registry, value) {\n                super(registry, Type, value, { definition, setDefinition });\n            }\n        };\n    }\n    /**\n     * @description The type for the items\n     */\n    get Type() {\n        return this.__internal__Type.name;\n    }\n    /**\n     * @description Finds the index of the value in the array\n     */\n    indexOf(other) {\n        // convert type first, this removes overhead from the eq\n        const check = other instanceof this.__internal__Type\n            ? other\n            : new this.__internal__Type(this.registry, other);\n        for (let i = 0, count = this.length; i < count; i++) {\n            if (check.eq(this[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `Vec<${this.registry.getClassName(this.__internal__Type) || new this.__internal__Type(this.registry).toRawType()}>`;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}