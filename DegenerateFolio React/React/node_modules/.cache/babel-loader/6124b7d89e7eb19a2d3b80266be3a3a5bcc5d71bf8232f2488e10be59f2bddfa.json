{"ast":null,"code":"import { stringify } from '@polkadot/util';\n/*\n * Creates a new health checker.\n *\n * The role of the health checker is to report to the user the health of a smoldot chain.\n *\n * In order to use it, start by creating a health checker, and call `setSendJsonRpc` to set the\n * way to send a JSON-RPC request to a chain. The health checker is disabled by default. Use\n * `start()` in order to start the health checks. The `start()` function must be passed a callback called\n * when an update to the health of the node is available.\n *\n * In order to send a JSON-RPC request to the chain, you **must** use the `sendJsonRpc` function\n * of the health checker. The health checker rewrites the `id` of the requests it receives.\n *\n * When the chain send a JSON-RPC response, it must be passed to `responsePassThrough()`. This\n * function intercepts the responses destined to the requests that have been emitted by the health\n * checker and returns `null`. If the response doesn't concern the health checker, the response is\n * simply returned by the function.\n *\n * # How it works\n *\n * The health checker periodically calls the `system_health` JSON-RPC call in order to determine\n * the health of the chain.\n *\n * In addition to this, as long as the health check reports that `isSyncing` is `true`, the\n * health checker also maintains a subscription to new best blocks using `chain_subscribeNewHeads`.\n * Whenever a new block is notified, a health check is performed immediately in order to determine\n * whether `isSyncing` has changed to `false`.\n *\n * Thanks to this subscription, the latency of the report of the switch from `isSyncing: true` to\n * `isSyncing: false` is very low.\n *\n */\nexport function healthChecker() {\n  // `null` if health checker is not started.\n  let checker = null;\n  let sendJsonRpc = null;\n  return {\n    responsePassThrough: jsonRpcResponse => {\n      if (checker === null) {\n        return jsonRpcResponse;\n      }\n      return checker.responsePassThrough(jsonRpcResponse);\n    },\n    sendJsonRpc: request => {\n      if (!sendJsonRpc) {\n        throw new Error('setSendJsonRpc must be called before sending requests');\n      }\n      if (checker === null) {\n        sendJsonRpc(request);\n      } else {\n        checker.sendJsonRpc(request);\n      }\n    },\n    setSendJsonRpc: cb => {\n      sendJsonRpc = cb;\n    },\n    start: healthCallback => {\n      if (checker !== null) {\n        throw new Error(\"Can't start the health checker multiple times in parallel\");\n      } else if (!sendJsonRpc) {\n        throw new Error('setSendJsonRpc must be called before starting the health checks');\n      }\n      checker = new InnerChecker(healthCallback, sendJsonRpc);\n      checker.update(true);\n    },\n    stop: () => {\n      if (checker === null) {\n        return;\n      } // Already stopped.\n      checker.destroy();\n      checker = null;\n    }\n  };\n}\nclass InnerChecker {\n  __internal__healthCallback;\n  __internal__currentHealthCheckId = null;\n  __internal__currentHealthTimeout = null;\n  __internal__currentSubunsubRequestId = null;\n  __internal__currentSubscriptionId = null;\n  __internal__requestToSmoldot;\n  __internal__isSyncing = false;\n  __internal__nextRequestId = 0;\n  constructor(healthCallback, requestToSmoldot) {\n    this.__internal__healthCallback = healthCallback;\n    this.__internal__requestToSmoldot = request => requestToSmoldot(stringify(request));\n  }\n  sendJsonRpc = request => {\n    // Replace the `id` in the request to prefix the request ID with `extern:`.\n    let parsedRequest;\n    try {\n      parsedRequest = JSON.parse(request);\n    } catch {\n      return;\n    }\n    if (parsedRequest.id) {\n      const newId = 'extern:' + stringify(parsedRequest.id);\n      parsedRequest.id = newId;\n    }\n    this.__internal__requestToSmoldot(parsedRequest);\n  };\n  responsePassThrough = jsonRpcResponse => {\n    let parsedResponse;\n    try {\n      parsedResponse = JSON.parse(jsonRpcResponse);\n    } catch {\n      return jsonRpcResponse;\n    }\n    // Check whether response is a response to `system_health`.\n    if (parsedResponse.id && this.__internal__currentHealthCheckId === parsedResponse.id) {\n      this.__internal__currentHealthCheckId = null;\n      // Check whether query was successful. It is possible for queries to fail for\n      // various reasons, such as the client being overloaded.\n      if (!parsedResponse.result) {\n        this.update(false);\n        return null;\n      }\n      this.__internal__healthCallback(parsedResponse.result);\n      this.__internal__isSyncing = parsedResponse.result.isSyncing;\n      this.update(false);\n      return null;\n    }\n    // Check whether response is a response to the subscription or unsubscription.\n    if (parsedResponse.id && this.__internal__currentSubunsubRequestId === parsedResponse.id) {\n      this.__internal__currentSubunsubRequestId = null;\n      // Check whether query was successful. It is possible for queries to fail for\n      // various reasons, such as the client being overloaded.\n      if (!parsedResponse.result) {\n        this.update(false);\n        return null;\n      }\n      if (this.__internal__currentSubscriptionId) {\n        this.__internal__currentSubscriptionId = null;\n      } else {\n        this.__internal__currentSubscriptionId = parsedResponse.result;\n      }\n      this.update(false);\n      return null;\n    }\n    // Check whether response is a notification to a subscription.\n    if (parsedResponse.params && this.__internal__currentSubscriptionId && parsedResponse.params.subscription === this.__internal__currentSubscriptionId) {\n      // Note that after a successful subscription, a notification containing\n      // the current best block is always returned. Considering that a\n      // subscription is performed in response to a health check, calling\n      // `startHealthCheck()` here will lead to a second health check.\n      // It might seem redundant to perform two health checks in a quick\n      // succession, but doing so doesn't lead to any problem, and it is\n      // actually possible for the health to have changed in between as the\n      // current best block might have been updated during the subscription\n      // request.\n      this.update(true);\n      return null;\n    }\n    // Response doesn't concern us.\n    if (parsedResponse.id) {\n      const id = parsedResponse.id;\n      // Need to remove the `extern:` prefix.\n      if (!id.startsWith('extern:')) {\n        throw new Error('State inconsistency in health checker');\n      }\n      const newId = JSON.parse(id.slice('extern:'.length));\n      parsedResponse.id = newId;\n    }\n    return stringify(parsedResponse);\n  };\n  update = startNow => {\n    // If `startNow`, clear `#currentHealthTimeout` so that it is set below.\n    if (startNow && this.__internal__currentHealthTimeout) {\n      clearTimeout(this.__internal__currentHealthTimeout);\n      this.__internal__currentHealthTimeout = null;\n    }\n    if (!this.__internal__currentHealthTimeout) {\n      const startHealthRequest = () => {\n        this.__internal__currentHealthTimeout = null;\n        // No matter what, don't start a health request if there is already one in progress.\n        // This is sane to do because receiving a response to a health request calls `update()`.\n        if (this.__internal__currentHealthCheckId) {\n          return;\n        }\n        // Actual request starting.\n        this.__internal__currentHealthCheckId = `health-checker:${this.__internal__nextRequestId}`;\n        this.__internal__nextRequestId += 1;\n        this.__internal__requestToSmoldot({\n          id: this.__internal__currentHealthCheckId,\n          jsonrpc: '2.0',\n          method: 'system_health',\n          params: []\n        });\n      };\n      if (startNow) {\n        startHealthRequest();\n      } else {\n        this.__internal__currentHealthTimeout = setTimeout(startHealthRequest, 1000);\n      }\n    }\n    if (this.__internal__isSyncing && !this.__internal__currentSubscriptionId && !this.__internal__currentSubunsubRequestId) {\n      this.startSubscription();\n    }\n    if (!this.__internal__isSyncing && this.__internal__currentSubscriptionId && !this.__internal__currentSubunsubRequestId) {\n      this.endSubscription();\n    }\n  };\n  startSubscription = () => {\n    if (this.__internal__currentSubunsubRequestId || this.__internal__currentSubscriptionId) {\n      throw new Error('Internal error in health checker');\n    }\n    this.__internal__currentSubunsubRequestId = `health-checker:${this.__internal__nextRequestId}`;\n    this.__internal__nextRequestId += 1;\n    this.__internal__requestToSmoldot({\n      id: this.__internal__currentSubunsubRequestId,\n      jsonrpc: '2.0',\n      method: 'chain_subscribeNewHeads',\n      params: []\n    });\n  };\n  endSubscription = () => {\n    if (this.__internal__currentSubunsubRequestId || !this.__internal__currentSubscriptionId) {\n      throw new Error('Internal error in health checker');\n    }\n    this.__internal__currentSubunsubRequestId = `health-checker:${this.__internal__nextRequestId}`;\n    this.__internal__nextRequestId += 1;\n    this.__internal__requestToSmoldot({\n      id: this.__internal__currentSubunsubRequestId,\n      jsonrpc: '2.0',\n      method: 'chain_unsubscribeNewHeads',\n      params: [this.__internal__currentSubscriptionId]\n    });\n  };\n  destroy = () => {\n    if (this.__internal__currentHealthTimeout) {\n      clearTimeout(this.__internal__currentHealthTimeout);\n      this.__internal__currentHealthTimeout = null;\n    }\n  };\n}\nexport class HealthCheckError extends Error {\n  __internal__cause;\n  getCause() {\n    return this.__internal__cause;\n  }\n  constructor(response, message = 'Got error response asking for system health') {\n    super(message);\n    this.__internal__cause = response;\n  }\n}","map":{"version":3,"names":["stringify","healthChecker","checker","sendJsonRpc","responsePassThrough","jsonRpcResponse","request","Error","setSendJsonRpc","cb","start","healthCallback","InnerChecker","update","stop","destroy","__internal__healthCallback","__internal__currentHealthCheckId","__internal__currentHealthTimeout","__internal__currentSubunsubRequestId","__internal__currentSubscriptionId","__internal__requestToSmoldot","__internal__isSyncing","__internal__nextRequestId","constructor","requestToSmoldot","parsedRequest","JSON","parse","id","newId","parsedResponse","result","isSyncing","params","subscription","startsWith","slice","length","startNow","clearTimeout","startHealthRequest","jsonrpc","method","setTimeout","startSubscription","endSubscription","HealthCheckError","__internal__cause","getCause","response","message"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/rpc-provider/substrate-connect/Health.js"],"sourcesContent":["import { stringify } from '@polkadot/util';\n/*\n * Creates a new health checker.\n *\n * The role of the health checker is to report to the user the health of a smoldot chain.\n *\n * In order to use it, start by creating a health checker, and call `setSendJsonRpc` to set the\n * way to send a JSON-RPC request to a chain. The health checker is disabled by default. Use\n * `start()` in order to start the health checks. The `start()` function must be passed a callback called\n * when an update to the health of the node is available.\n *\n * In order to send a JSON-RPC request to the chain, you **must** use the `sendJsonRpc` function\n * of the health checker. The health checker rewrites the `id` of the requests it receives.\n *\n * When the chain send a JSON-RPC response, it must be passed to `responsePassThrough()`. This\n * function intercepts the responses destined to the requests that have been emitted by the health\n * checker and returns `null`. If the response doesn't concern the health checker, the response is\n * simply returned by the function.\n *\n * # How it works\n *\n * The health checker periodically calls the `system_health` JSON-RPC call in order to determine\n * the health of the chain.\n *\n * In addition to this, as long as the health check reports that `isSyncing` is `true`, the\n * health checker also maintains a subscription to new best blocks using `chain_subscribeNewHeads`.\n * Whenever a new block is notified, a health check is performed immediately in order to determine\n * whether `isSyncing` has changed to `false`.\n *\n * Thanks to this subscription, the latency of the report of the switch from `isSyncing: true` to\n * `isSyncing: false` is very low.\n *\n */\nexport function healthChecker() {\n    // `null` if health checker is not started.\n    let checker = null;\n    let sendJsonRpc = null;\n    return {\n        responsePassThrough: (jsonRpcResponse) => {\n            if (checker === null) {\n                return jsonRpcResponse;\n            }\n            return checker.responsePassThrough(jsonRpcResponse);\n        },\n        sendJsonRpc: (request) => {\n            if (!sendJsonRpc) {\n                throw new Error('setSendJsonRpc must be called before sending requests');\n            }\n            if (checker === null) {\n                sendJsonRpc(request);\n            }\n            else {\n                checker.sendJsonRpc(request);\n            }\n        },\n        setSendJsonRpc: (cb) => {\n            sendJsonRpc = cb;\n        },\n        start: (healthCallback) => {\n            if (checker !== null) {\n                throw new Error(\"Can't start the health checker multiple times in parallel\");\n            }\n            else if (!sendJsonRpc) {\n                throw new Error('setSendJsonRpc must be called before starting the health checks');\n            }\n            checker = new InnerChecker(healthCallback, sendJsonRpc);\n            checker.update(true);\n        },\n        stop: () => {\n            if (checker === null) {\n                return;\n            } // Already stopped.\n            checker.destroy();\n            checker = null;\n        }\n    };\n}\nclass InnerChecker {\n    __internal__healthCallback;\n    __internal__currentHealthCheckId = null;\n    __internal__currentHealthTimeout = null;\n    __internal__currentSubunsubRequestId = null;\n    __internal__currentSubscriptionId = null;\n    __internal__requestToSmoldot;\n    __internal__isSyncing = false;\n    __internal__nextRequestId = 0;\n    constructor(healthCallback, requestToSmoldot) {\n        this.__internal__healthCallback = healthCallback;\n        this.__internal__requestToSmoldot = (request) => requestToSmoldot(stringify(request));\n    }\n    sendJsonRpc = (request) => {\n        // Replace the `id` in the request to prefix the request ID with `extern:`.\n        let parsedRequest;\n        try {\n            parsedRequest = JSON.parse(request);\n        }\n        catch {\n            return;\n        }\n        if (parsedRequest.id) {\n            const newId = 'extern:' + stringify(parsedRequest.id);\n            parsedRequest.id = newId;\n        }\n        this.__internal__requestToSmoldot(parsedRequest);\n    };\n    responsePassThrough = (jsonRpcResponse) => {\n        let parsedResponse;\n        try {\n            parsedResponse = JSON.parse(jsonRpcResponse);\n        }\n        catch {\n            return jsonRpcResponse;\n        }\n        // Check whether response is a response to `system_health`.\n        if (parsedResponse.id && this.__internal__currentHealthCheckId === parsedResponse.id) {\n            this.__internal__currentHealthCheckId = null;\n            // Check whether query was successful. It is possible for queries to fail for\n            // various reasons, such as the client being overloaded.\n            if (!parsedResponse.result) {\n                this.update(false);\n                return null;\n            }\n            this.__internal__healthCallback(parsedResponse.result);\n            this.__internal__isSyncing = parsedResponse.result.isSyncing;\n            this.update(false);\n            return null;\n        }\n        // Check whether response is a response to the subscription or unsubscription.\n        if (parsedResponse.id &&\n            this.__internal__currentSubunsubRequestId === parsedResponse.id) {\n            this.__internal__currentSubunsubRequestId = null;\n            // Check whether query was successful. It is possible for queries to fail for\n            // various reasons, such as the client being overloaded.\n            if (!parsedResponse.result) {\n                this.update(false);\n                return null;\n            }\n            if (this.__internal__currentSubscriptionId) {\n                this.__internal__currentSubscriptionId = null;\n            }\n            else {\n                this.__internal__currentSubscriptionId = parsedResponse.result;\n            }\n            this.update(false);\n            return null;\n        }\n        // Check whether response is a notification to a subscription.\n        if (parsedResponse.params &&\n            this.__internal__currentSubscriptionId &&\n            parsedResponse.params.subscription === this.__internal__currentSubscriptionId) {\n            // Note that after a successful subscription, a notification containing\n            // the current best block is always returned. Considering that a\n            // subscription is performed in response to a health check, calling\n            // `startHealthCheck()` here will lead to a second health check.\n            // It might seem redundant to perform two health checks in a quick\n            // succession, but doing so doesn't lead to any problem, and it is\n            // actually possible for the health to have changed in between as the\n            // current best block might have been updated during the subscription\n            // request.\n            this.update(true);\n            return null;\n        }\n        // Response doesn't concern us.\n        if (parsedResponse.id) {\n            const id = parsedResponse.id;\n            // Need to remove the `extern:` prefix.\n            if (!id.startsWith('extern:')) {\n                throw new Error('State inconsistency in health checker');\n            }\n            const newId = JSON.parse(id.slice('extern:'.length));\n            parsedResponse.id = newId;\n        }\n        return stringify(parsedResponse);\n    };\n    update = (startNow) => {\n        // If `startNow`, clear `#currentHealthTimeout` so that it is set below.\n        if (startNow && this.__internal__currentHealthTimeout) {\n            clearTimeout(this.__internal__currentHealthTimeout);\n            this.__internal__currentHealthTimeout = null;\n        }\n        if (!this.__internal__currentHealthTimeout) {\n            const startHealthRequest = () => {\n                this.__internal__currentHealthTimeout = null;\n                // No matter what, don't start a health request if there is already one in progress.\n                // This is sane to do because receiving a response to a health request calls `update()`.\n                if (this.__internal__currentHealthCheckId) {\n                    return;\n                }\n                // Actual request starting.\n                this.__internal__currentHealthCheckId = `health-checker:${this.__internal__nextRequestId}`;\n                this.__internal__nextRequestId += 1;\n                this.__internal__requestToSmoldot({\n                    id: this.__internal__currentHealthCheckId,\n                    jsonrpc: '2.0',\n                    method: 'system_health',\n                    params: []\n                });\n            };\n            if (startNow) {\n                startHealthRequest();\n            }\n            else {\n                this.__internal__currentHealthTimeout = setTimeout(startHealthRequest, 1000);\n            }\n        }\n        if (this.__internal__isSyncing &&\n            !this.__internal__currentSubscriptionId &&\n            !this.__internal__currentSubunsubRequestId) {\n            this.startSubscription();\n        }\n        if (!this.__internal__isSyncing &&\n            this.__internal__currentSubscriptionId &&\n            !this.__internal__currentSubunsubRequestId) {\n            this.endSubscription();\n        }\n    };\n    startSubscription = () => {\n        if (this.__internal__currentSubunsubRequestId || this.__internal__currentSubscriptionId) {\n            throw new Error('Internal error in health checker');\n        }\n        this.__internal__currentSubunsubRequestId = `health-checker:${this.__internal__nextRequestId}`;\n        this.__internal__nextRequestId += 1;\n        this.__internal__requestToSmoldot({\n            id: this.__internal__currentSubunsubRequestId,\n            jsonrpc: '2.0',\n            method: 'chain_subscribeNewHeads',\n            params: []\n        });\n    };\n    endSubscription = () => {\n        if (this.__internal__currentSubunsubRequestId || !this.__internal__currentSubscriptionId) {\n            throw new Error('Internal error in health checker');\n        }\n        this.__internal__currentSubunsubRequestId = `health-checker:${this.__internal__nextRequestId}`;\n        this.__internal__nextRequestId += 1;\n        this.__internal__requestToSmoldot({\n            id: this.__internal__currentSubunsubRequestId,\n            jsonrpc: '2.0',\n            method: 'chain_unsubscribeNewHeads',\n            params: [this.__internal__currentSubscriptionId]\n        });\n    };\n    destroy = () => {\n        if (this.__internal__currentHealthTimeout) {\n            clearTimeout(this.__internal__currentHealthTimeout);\n            this.__internal__currentHealthTimeout = null;\n        }\n    };\n}\nexport class HealthCheckError extends Error {\n    __internal__cause;\n    getCause() {\n        return this.__internal__cause;\n    }\n    constructor(response, message = 'Got error response asking for system health') {\n        super(message);\n        this.__internal__cause = response;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}