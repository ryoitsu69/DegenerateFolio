{"ast":null,"code":"import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { BatchGeometry } from '../../../rendering/batcher/gpu/BatchGeometry.mjs';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nimport { Batcher } from '../../../rendering/batcher/shared/Batcher.mjs';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { buildContextBatches } from './utils/buildContextBatches.mjs';\n\"use strict\";\nclass GpuGraphicsContext {\n  constructor() {\n    this.batches = [];\n    this.geometryData = {\n      vertices: [],\n      uvs: [],\n      indices: []\n    };\n  }\n}\nclass GraphicsContextRenderData {\n  constructor() {\n    this.geometry = new BatchGeometry();\n    this.instructions = new InstructionSet();\n  }\n  init() {\n    this.instructions.reset();\n  }\n}\nconst _GraphicsContextSystem = class _GraphicsContextSystem {\n  constructor() {\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    this._activeBatchers = [];\n    this._gpuContextHash = {};\n    // used for non-batchable graphics\n    this._graphicsDataContextHash = /* @__PURE__ */Object.create(null);\n    this._needsContextNeedsRebuild = [];\n  }\n  /**\n   * Runner init called, update the default options\n   * @ignore\n   */\n  init(options) {\n    _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;\n  }\n  prerender() {\n    this._returnActiveBatchers();\n  }\n  getContextRenderData(context) {\n    return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n  }\n  // Context management functions\n  updateGpuContext(context) {\n    let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);\n    if (context.dirty) {\n      if (gpuContext) {\n        this._cleanGraphicsContextData(context);\n      } else {\n        gpuContext = this._initContext(context);\n      }\n      buildContextBatches(context, gpuContext);\n      const batchMode = context.batchMode;\n      if (context.customShader || batchMode === \"no-batch\") {\n        gpuContext.isBatchable = false;\n      } else if (batchMode === \"auto\") {\n        gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;\n      }\n      context.dirty = false;\n    }\n    return gpuContext;\n  }\n  getGpuContext(context) {\n    return this._gpuContextHash[context.uid] || this._initContext(context);\n  }\n  _returnActiveBatchers() {\n    for (let i = 0; i < this._activeBatchers.length; i++) {\n      BigPool.return(this._activeBatchers[i]);\n    }\n    this._activeBatchers.length = 0;\n  }\n  _initContextRenderData(context) {\n    const graphicsData = BigPool.get(GraphicsContextRenderData);\n    const {\n      batches,\n      geometryData\n    } = this._gpuContextHash[context.uid];\n    const vertexSize = geometryData.vertices.length;\n    const indexSize = geometryData.indices.length;\n    for (let i = 0; i < batches.length; i++) {\n      batches[i].applyTransform = false;\n    }\n    const batcher = BigPool.get(Batcher);\n    this._activeBatchers.push(batcher);\n    batcher.ensureAttributeBuffer(vertexSize);\n    batcher.ensureIndexBuffer(indexSize);\n    batcher.begin();\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batcher.add(batch);\n    }\n    batcher.finish(graphicsData.instructions);\n    const geometry = graphicsData.geometry;\n    geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n    geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n    const drawBatches = batcher.batches;\n    for (let i = 0; i < drawBatches.length; i++) {\n      const batch = drawBatches[i];\n      batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);\n    }\n    this._graphicsDataContextHash[context.uid] = graphicsData;\n    return graphicsData;\n  }\n  _initContext(context) {\n    const gpuContext = new GpuGraphicsContext();\n    this._gpuContextHash[context.uid] = gpuContext;\n    context.on(\"update\", this.onGraphicsContextUpdate, this);\n    context.on(\"destroy\", this.onGraphicsContextDestroy, this);\n    return this._gpuContextHash[context.uid];\n  }\n  onGraphicsContextUpdate(context) {\n    this._needsContextNeedsRebuild.push(context);\n  }\n  onGraphicsContextDestroy(context) {\n    this._cleanGraphicsContextData(context);\n    context.off(\"update\", this.onGraphicsContextUpdate, this);\n    context.off(\"destroy\", this.onGraphicsContextDestroy, this);\n    this._gpuContextHash[context.uid] = null;\n  }\n  _cleanGraphicsContextData(context) {\n    const gpuContext = this._gpuContextHash[context.uid];\n    if (!gpuContext.isBatchable) {\n      if (this._graphicsDataContextHash[context.uid]) {\n        BigPool.return(this.getContextRenderData(context));\n        this._graphicsDataContextHash[context.uid] = null;\n      }\n    }\n    if (gpuContext.batches) {\n      gpuContext.batches.forEach(batch => {\n        BigPool.return(batch);\n      });\n    }\n  }\n  destroy() {\n    for (const context of this._needsContextNeedsRebuild) {\n      if (this._gpuContextHash[context.uid]) {\n        this.onGraphicsContextDestroy(context);\n      }\n    }\n    this._needsContextNeedsRebuild.length = 0;\n  }\n};\n/** @ignore */\n_GraphicsContextSystem.extension = {\n  type: [ExtensionType.WebGLSystem, ExtensionType.WebGPUSystem, ExtensionType.CanvasSystem],\n  name: \"graphicsContext\"\n};\n/** The default options for the GraphicsContextSystem. */\n_GraphicsContextSystem.defaultOptions = {\n  /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */\n  bezierSmoothness: 0.5\n};\nlet GraphicsContextSystem = _GraphicsContextSystem;\nexport { GpuGraphicsContext, GraphicsContextRenderData, GraphicsContextSystem };","map":{"version":3,"names":["GpuGraphicsContext","constructor","batches","geometryData","vertices","uvs","indices","GraphicsContextRenderData","geometry","BatchGeometry","instructions","InstructionSet","init","reset","_GraphicsContextSystem","_activeBatchers","_gpuContextHash","_graphicsDataContextHash","Object","create","_needsContextNeedsRebuild","options","defaultOptions","bezierSmoothness","prerender","_returnActiveBatchers","getContextRenderData","context","uid","_initContextRenderData","updateGpuContext","gpuContext","_initContext","dirty","_cleanGraphicsContextData","buildContextBatches","batchMode","customShader","isBatchable","length","getGpuContext","i","BigPool","return","graphicsData","get","vertexSize","indexSize","applyTransform","batcher","Batcher","push","ensureAttributeBuffer","ensureIndexBuffer","begin","batch","add","finish","indexBuffer","setDataWithSize","buffers","attributeBuffer","float32View","attributeSize","drawBatches","bindGroup","getTextureBatchBindGroup","textures","count","on","onGraphicsContextUpdate","onGraphicsContextDestroy","off","forEach","destroy","extension","type","ExtensionType","WebGLSystem","WebGPUSystem","CanvasSystem","name","GraphicsContextSystem"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/graphics/shared/GraphicsContextSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { BatchGeometry } from '../../../rendering/batcher/gpu/BatchGeometry';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { buildContextBatches } from './utils/buildContextBatches';\n\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { BatchableGraphics } from './BatchableGraphics';\nimport type { GraphicsContext } from './GraphicsContext';\n\ninterface GeometryData\n{\n    vertices: number[];\n    uvs: number[];\n    indices: number[];\n}\n\n/**\n * A class that holds batchable graphics data for a GraphicsContext.\n * @memberof rendering\n * @ignore\n */\nexport class GpuGraphicsContext\n{\n    public isBatchable: boolean;\n    public batches: BatchableGraphics[] = [];\n    public geometryData: GeometryData = {\n        vertices: [],\n        uvs: [],\n        indices: [],\n    };\n    public graphicsData: GraphicsContextRenderData;\n}\n\n/**\n * A class that holds the render data for a GraphicsContext.\n * @memberof rendering\n * @ignore\n */\nexport class GraphicsContextRenderData\n{\n    public geometry = new BatchGeometry();\n    public instructions = new InstructionSet();\n\n    public init()\n    {\n        this.instructions.reset();\n    }\n}\n\n/**\n * Options for the GraphicsContextSystem.\n * @memberof rendering\n */\nexport interface GraphicsContextSystemOptions\n{\n    /** A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother) */\n    bezierSmoothness?: number;\n}\n\n/**\n * A system that manages the rendering of GraphicsContexts.\n * @memberof rendering\n */\nexport class GraphicsContextSystem implements System<GraphicsContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'graphicsContext'\n    } as const;\n\n    /** The default options for the GraphicsContextSystem. */\n    public static readonly defaultOptions: GraphicsContextSystemOptions = {\n        /**\n         * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n         * @default 0.5\n         */\n        bezierSmoothness: 0.5,\n    };\n\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    private readonly _activeBatchers: Batcher[] = [];\n    private _gpuContextHash: Record<number, GpuGraphicsContext> = {};\n    // used for non-batchable graphics\n    private _graphicsDataContextHash: Record<number, GraphicsContextRenderData> = Object.create(null);\n    private readonly _needsContextNeedsRebuild: GraphicsContext[] = [];\n\n    /**\n     * Runner init called, update the default options\n     * @ignore\n     */\n    public init(options?: GraphicsContextSystemOptions)\n    {\n        GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness\n            ?? GraphicsContextSystem.defaultOptions.bezierSmoothness;\n    }\n\n    protected prerender()\n    {\n        this._returnActiveBatchers();\n    }\n\n    public getContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n    }\n\n    // Context management functions\n    public updateGpuContext(context: GraphicsContext)\n    {\n        let gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid]\n\n            || this._initContext(context);\n\n        if (context.dirty)\n        {\n            if (gpuContext)\n            {\n                this._cleanGraphicsContextData(context);\n            }\n            else\n            {\n                gpuContext = this._initContext(context);\n            }\n\n            buildContextBatches(context, gpuContext);\n\n            const batchMode = context.batchMode;\n\n            if (context.customShader || batchMode === 'no-batch')\n            {\n                gpuContext.isBatchable = false;\n            }\n            else if (batchMode === 'auto')\n            {\n                gpuContext.isBatchable = (gpuContext.geometryData.vertices.length < 400);\n            }\n\n            context.dirty = false;\n        }\n\n        return gpuContext;\n    }\n\n    public getGpuContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        return this._gpuContextHash[context.uid] || this._initContext(context);\n    }\n\n    private _returnActiveBatchers()\n    {\n        for (let i = 0; i < this._activeBatchers.length; i++)\n        {\n            BigPool.return(this._activeBatchers[i] as PoolItem);\n        }\n\n        this._activeBatchers.length = 0;\n    }\n\n    private _initContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        const graphicsData: GraphicsContextRenderData = BigPool.get(GraphicsContextRenderData);// ();\n\n        const { batches, geometryData } = this._gpuContextHash[context.uid];\n\n        const vertexSize = geometryData.vertices.length;\n        const indexSize = geometryData.indices.length;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            batches[i].applyTransform = false;\n        }\n\n        const batcher = BigPool.get(Batcher);\n\n        this._activeBatchers.push(batcher);\n\n        batcher.ensureAttributeBuffer(vertexSize);\n        batcher.ensureIndexBuffer(indexSize);\n\n        batcher.begin();\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batcher.add(batch);\n        }\n\n        batcher.finish(graphicsData.instructions);\n\n        const geometry = graphicsData.geometry;\n\n        // not to self - this works as we are assigning the batchers array buffer\n        // once its up loaded - this buffer is then put back in the pool to be reused.\n        // this mean we don't have to creating new Batchers for each graphics items\n        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n\n        const drawBatches = batcher.batches;\n\n        for (let i = 0; i < drawBatches.length; i++)\n        {\n            const batch = drawBatches[i];\n\n            batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);\n        }\n\n        this._graphicsDataContextHash[context.uid] = graphicsData;\n\n        return graphicsData;\n    }\n\n    private _initContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        const gpuContext = new GpuGraphicsContext();\n\n        this._gpuContextHash[context.uid] = gpuContext;\n\n        context.on('update', this.onGraphicsContextUpdate, this);\n        context.on('destroy', this.onGraphicsContextDestroy, this);\n\n        return this._gpuContextHash[context.uid];\n    }\n\n    protected onGraphicsContextUpdate(context: GraphicsContext)\n    {\n        this._needsContextNeedsRebuild.push(context);\n    }\n\n    protected onGraphicsContextDestroy(context: GraphicsContext)\n    {\n        this._cleanGraphicsContextData(context);\n\n        context.off('update', this.onGraphicsContextUpdate, this);\n        context.off('destroy', this.onGraphicsContextDestroy, this);\n\n        this._gpuContextHash[context.uid] = null;\n    }\n\n    private _cleanGraphicsContextData(context: GraphicsContext)\n    {\n        const gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid];\n\n        if (!gpuContext.isBatchable)\n        {\n            if (this._graphicsDataContextHash[context.uid])\n            {\n                BigPool.return(this.getContextRenderData(context) as PoolItem);\n\n                // we will rebuild this...\n                this._graphicsDataContextHash[context.uid] = null;\n            }\n        }\n\n        if (gpuContext.batches)\n        {\n            gpuContext.batches.forEach((batch) =>\n            {\n                BigPool.return(batch as PoolItem);\n            });\n        }\n    }\n\n    public destroy()\n    {\n        // Clean up all graphics contexts\n        for (const context of this._needsContextNeedsRebuild)\n        {\n            // only clean if it exists\n            if (this._gpuContextHash[context.uid])\n            {\n                this.onGraphicsContextDestroy(context);\n            }\n        }\n\n        this._needsContextNeedsRebuild.length = 0;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}