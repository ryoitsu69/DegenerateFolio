{"ast":null,"code":"/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/*\n * Module dependencies.\n */\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\nconst crypto = require('crypto');\nconst _c = {\n  fs: fs.constants,\n  os: os.constants\n};\n\n/*\n * The working inner variables.\n */\nconst\n  // the random characters to choose from\n  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  TEMPLATE_PATTERN = /XXXXXX/,\n  DEFAULT_TRIES = 3,\n  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n  // constants are off on the windows platform and will not match the actual errno codes\n  IS_WIN32 = os.platform() === 'win32',\n  EBADF = _c.EBADF || _c.os.errno.EBADF,\n  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,\n  DIR_MODE = 0o700 /* 448 */,\n  FILE_MODE = 0o600 /* 384 */,\n  EXIT = 'exit',\n  // this will hold the objects need to be removed on exit\n  _removeObjects = [],\n  // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback\n  FN_RMDIR_SYNC = fs.rmdirSync.bind(fs);\nlet _gracefulCleanup = false;\n\n/**\n * Recursively remove a directory and its contents.\n *\n * @param {string} dirPath path of directory to remove\n * @param {Function} callback\n * @private\n */\nfunction rimraf(dirPath, callback) {\n  return fs.rm(dirPath, {\n    recursive: true\n  }, callback);\n}\n\n/**\n * Recursively remove a directory and its contents, synchronously.\n *\n * @param {string} dirPath path of directory to remove\n * @private\n */\nfunction FN_RIMRAF_SYNC(dirPath) {\n  return fs.rmSync(dirPath, {\n    recursive: true\n  });\n}\n\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */\nfunction tmpName(options, callback) {\n  const args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n  try {\n    _assertAndSanitizeOptions(opts);\n  } catch (err) {\n    return cb(err);\n  }\n  let tries = opts.tries;\n  (function _getUniqueName() {\n    try {\n      const name = _generateTmpName(opts);\n\n      // check whether the path exists then retry if needed\n      fs.stat(name, function (err) {\n        /* istanbul ignore else */\n        if (!err) {\n          /* istanbul ignore else */\n          if (tries-- > 0) return _getUniqueName();\n          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n        }\n        cb(null, name);\n      });\n    } catch (err) {\n      cb(err);\n    }\n  })();\n}\n\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */\nfunction tmpNameSync(options) {\n  const args = _parseArguments(options),\n    opts = args[0];\n  _assertAndSanitizeOptions(opts);\n  let tries = opts.tries;\n  do {\n    const name = _generateTmpName(opts);\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined\n * @param {?fileCallback} callback\n */\nfunction file(options, callback) {\n  const args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create and open the file\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      /* istanbu ignore else */\n      if (err) return cb(err);\n      if (opts.discardDescriptor) {\n        return fs.close(fd, function _discardCallback(possibleErr) {\n          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only\n          return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));\n        });\n      } else {\n        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care\n        // about the descriptor\n        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));\n      }\n    });\n  });\n}\n\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */\nfunction fileSync(options) {\n  const args = _parseArguments(options),\n    opts = args[0];\n  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n  const name = tmpNameSync(opts);\n  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  /* istanbul ignore else */\n  if (opts.discardDescriptor) {\n    fs.closeSync(fd);\n    fd = undefined;\n  }\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)\n  };\n}\n\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */\nfunction dir(options, callback) {\n  const args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create the directory\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));\n    });\n  });\n}\n\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */\nfunction dirSync(options) {\n  const args = _parseArguments(options),\n    opts = args[0];\n  const name = tmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)\n  };\n}\n\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */\nfunction _removeFileAsync(fdPath, next) {\n  const _handler = function (err) {\n    if (err && !_isENOENT(err)) {\n      // reraise any unanticipated error\n      return next(err);\n    }\n    next();\n  };\n  if (0 <= fdPath[0]) fs.close(fdPath[0], function () {\n    fs.unlink(fdPath[1], _handler);\n  });else fs.unlink(fdPath[1], _handler);\n}\n\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */\nfunction _removeFileSync(fdPath) {\n  let rethrownException = null;\n  try {\n    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n  } catch (e) {\n    // reraise any unanticipated error\n    if (!_isEBADF(e) && !_isENOENT(e)) throw e;\n  } finally {\n    try {\n      fs.unlinkSync(fdPath[1]);\n    } catch (e) {\n      // reraise any unanticipated error\n      if (!_isENOENT(e)) rethrownException = e;\n    }\n  }\n  if (rethrownException !== null) {\n    throw rethrownException;\n  }\n}\n\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * Returns either a sync callback or a async callback depending on whether\n * fileSync or file was called, which is expressed by the sync parameter.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {fileCallback | fileCallbackSync}\n * @private\n */\nfunction _prepareTmpFileRemoveCallback(name, fd, opts, sync) {\n  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);\n  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * Returns either a sync callback or a async callback depending on whether\n * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.\n *\n * @param {string} name\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {Function} the callback\n * @private\n */\nfunction _prepareTmpDirRemoveCallback(name, opts, sync) {\n  const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);\n  const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;\n  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);\n  const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * The cleanup callback is save to be called multiple times.\n * Subsequent invocations will be ignored.\n *\n * @param {Function} removeFunction\n * @param {string} fileOrDirName\n * @param {boolean} sync\n * @param {cleanupCallbackSync?} cleanupCallbackSync\n * @returns {cleanupCallback | cleanupCallbackSync}\n * @private\n */\nfunction _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {\n  let called = false;\n\n  // if sync is true, the next parameter will be ignored\n  return function _cleanupCallback(next) {\n    /* istanbul ignore else */\n    if (!called) {\n      // remove cleanupCallback from cache\n      const toRemove = cleanupCallbackSync || _cleanupCallback;\n      const index = _removeObjects.indexOf(toRemove);\n      /* istanbul ignore else */\n      if (index >= 0) _removeObjects.splice(index, 1);\n      called = true;\n      if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {\n        return removeFunction(fileOrDirName);\n      } else {\n        return removeFunction(fileOrDirName, next || function () {});\n      }\n    }\n  };\n}\n\n/**\n * The garbage collector.\n *\n * @private\n */\nfunction _garbageCollector() {\n  /* istanbul ignore else */\n  if (!_gracefulCleanup) return;\n\n  // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0]();\n    } catch (e) {\n      // already removed?\n    }\n  }\n}\n\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */\nfunction _randomChars(howMany) {\n  let value = [],\n    rnd = null;\n\n  // make sure that we do not fail because we ran out of entropy\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n  for (var i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n  return value.join('');\n}\n\n/**\n * Helper which determines whether a string s is blank, that is undefined, or empty or null.\n *\n * @private\n * @param {string} s\n * @returns {Boolean} true whether the string s is blank, false otherwise\n */\nfunction _isBlank(s) {\n  return s === null || _isUndefined(s) || !s.trim();\n}\n\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|null|undefined|Function)} options\n * @param {?Function} callback\n * @returns {Array} parsed arguments\n * @private\n */\nfunction _parseArguments(options, callback) {\n  /* istanbul ignore else */\n  if (typeof options === 'function') {\n    return [{}, options];\n  }\n\n  /* istanbul ignore else */\n  if (_isUndefined(options)) {\n    return [{}, callback];\n  }\n\n  // copy options so we do not leak the changes we make internally\n  const actualOptions = {};\n  for (const key of Object.getOwnPropertyNames(options)) {\n    actualOptions[key] = options[key];\n  }\n  return [actualOptions, callback];\n}\n\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */\nfunction _generateTmpName(opts) {\n  const tmpDir = opts.tmpdir;\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.name)) return path.join(tmpDir, opts.dir, opts.name);\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.template)) return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));\n\n  // prefix and postfix\n  const name = [opts.prefix ? opts.prefix : 'tmp', '-', process.pid, '-', _randomChars(12), opts.postfix ? '-' + opts.postfix : ''].join('');\n  return path.join(tmpDir, opts.dir, name);\n}\n\n/**\n * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing\n * options.\n *\n * @param {Options} options\n * @private\n */\nfunction _assertAndSanitizeOptions(options) {\n  options.tmpdir = _getTmpDir(options);\n  const tmpDir = options.tmpdir;\n\n  /* istanbul ignore else */\n  if (!_isUndefined(options.name)) _assertIsRelative(options.name, 'name', tmpDir);\n  /* istanbul ignore else */\n  if (!_isUndefined(options.dir)) _assertIsRelative(options.dir, 'dir', tmpDir);\n  /* istanbul ignore else */\n  if (!_isUndefined(options.template)) {\n    _assertIsRelative(options.template, 'template', tmpDir);\n    if (!options.template.match(TEMPLATE_PATTERN)) throw new Error(`Invalid template, found \"${options.template}\".`);\n  }\n  /* istanbul ignore else */\n  if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0) throw new Error(`Invalid tries, found \"${options.tries}\".`);\n\n  // if a name was specified we will try once\n  options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;\n  options.keep = !!options.keep;\n  options.detachDescriptor = !!options.detachDescriptor;\n  options.discardDescriptor = !!options.discardDescriptor;\n  options.unsafeCleanup = !!options.unsafeCleanup;\n\n  // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to\n  options.dir = _isUndefined(options.dir) ? '' : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));\n  options.template = _isUndefined(options.template) ? undefined : path.relative(tmpDir, _resolvePath(options.template, tmpDir));\n  // sanitize further if template is relative to options.dir\n  options.template = _isBlank(options.template) ? undefined : path.relative(options.dir, options.template);\n\n  // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to\n  options.name = _isUndefined(options.name) ? undefined : options.name;\n  options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;\n  options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;\n}\n\n/**\n * Resolve the specified path name in respect to tmpDir.\n *\n * The specified name might include relative path components, e.g. ../\n * so we need to resolve in order to be sure that is is located inside tmpDir\n *\n * @param name\n * @param tmpDir\n * @returns {string}\n * @private\n */\nfunction _resolvePath(name, tmpDir) {\n  if (name.startsWith(tmpDir)) {\n    return path.resolve(name);\n  } else {\n    return path.resolve(path.join(tmpDir, name));\n  }\n}\n\n/**\n * Asserts whether specified name is relative to the specified tmpDir.\n *\n * @param {string} name\n * @param {string} option\n * @param {string} tmpDir\n * @throws {Error}\n * @private\n */\nfunction _assertIsRelative(name, option, tmpDir) {\n  if (option === 'name') {\n    // assert that name is not absolute and does not contain a path\n    if (path.isAbsolute(name)) throw new Error(`${option} option must not contain an absolute path, found \"${name}\".`);\n    // must not fail on valid .<name> or ..<name> or similar such constructs\n    let basename = path.basename(name);\n    if (basename === '..' || basename === '.' || basename !== name) throw new Error(`${option} option must not contain a path, found \"${name}\".`);\n  } else {\n    // if (option === 'dir' || option === 'template') {\n    // assert that dir or template are relative to tmpDir\n    if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {\n      throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${name}\".`);\n    }\n    let resolvedPath = _resolvePath(name, tmpDir);\n    if (!resolvedPath.startsWith(tmpDir)) throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${resolvedPath}\".`);\n  }\n}\n\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isEBADF(error) {\n  return _isExpectedError(error, -EBADF, 'EBADF');\n}\n\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isENOENT(error) {\n  return _isExpectedError(error, -ENOENT, 'ENOENT');\n}\n\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {number} any numerical value will be negated\n *\n * CAVEAT\n *\n * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT\n * is no different here.\n *\n * @param {SystemError} error\n * @param {number} errno\n * @param {string} code\n * @private\n */\nfunction _isExpectedError(error, errno, code) {\n  return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;\n}\n\n/**\n * Sets the graceful cleanup.\n *\n * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the\n * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary\n * object removals.\n */\nfunction setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n * @param {?Options} options\n * @returns {string} the currently configured tmp dir\n */\nfunction _getTmpDir(options) {\n  return path.resolve(options && options.tmpdir || os.tmpdir());\n}\n\n// Install process exit listener\nprocess.addListener(EXIT, _garbageCollector);\n\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected\n * @property {?number} tries the number of tries before give up the name generation\n * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fixed name relative to tmpdir or the specified dir option\n * @property {?string} dir tmp directory relative to the root tmp directory in use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection\n * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection\n */\n\n/**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor or -1 if the fd has been discarded\n * @property {fileCallback} removeCallback the callback function to remove the file\n */\n\n/**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */\n\n/**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */\n\n/**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback fileCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallbackSync\n */\n\n/**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */\n\n// exporting all the needed methods\n\n// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\nObject.defineProperty(module.exports, 'tmpdir', {\n  enumerable: true,\n  configurable: false,\n  get: function () {\n    return _getTmpDir();\n  }\n});\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\nmodule.exports.setGracefulCleanup = setGracefulCleanup;","map":{"version":3,"names":["fs","require","os","path","crypto","_c","constants","RANDOM_CHARS","TEMPLATE_PATTERN","DEFAULT_TRIES","CREATE_FLAGS","O_CREAT","O_EXCL","O_RDWR","IS_WIN32","platform","EBADF","errno","ENOENT","DIR_MODE","FILE_MODE","EXIT","_removeObjects","FN_RMDIR_SYNC","rmdirSync","bind","_gracefulCleanup","rimraf","dirPath","callback","rm","recursive","FN_RIMRAF_SYNC","rmSync","tmpName","options","args","_parseArguments","opts","cb","_assertAndSanitizeOptions","err","tries","_getUniqueName","name","_generateTmpName","stat","Error","tmpNameSync","statSync","e","file","_tmpNameCreated","open","mode","_fileCreated","fd","discardDescriptor","close","_discardCallback","possibleErr","undefined","_prepareTmpFileRemoveCallback","discardOrDetachDescriptor","detachDescriptor","fileSync","openSync","closeSync","removeCallback","dir","mkdir","_dirCreated","_prepareTmpDirRemoveCallback","dirSync","mkdirSync","_removeFileAsync","fdPath","next","_handler","_isENOENT","unlink","_removeFileSync","rethrownException","_isEBADF","unlinkSync","sync","removeCallbackSync","_prepareRemoveCallback","keep","unshift","removeFunction","unsafeCleanup","rmdir","removeFunctionSync","fileOrDirName","cleanupCallbackSync","called","_cleanupCallback","toRemove","index","indexOf","splice","_garbageCollector","length","_randomChars","howMany","value","rnd","randomBytes","pseudoRandomBytes","i","push","join","_isBlank","s","_isUndefined","trim","obj","actualOptions","key","Object","getOwnPropertyNames","tmpDir","tmpdir","template","replace","prefix","process","pid","postfix","_getTmpDir","_assertIsRelative","match","isNaN","relative","_resolvePath","startsWith","resolve","option","isAbsolute","basename","resolvedPath","error","_isExpectedError","code","setGracefulCleanup","addListener","defineProperty","module","exports","enumerable","configurable","get"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/tmp/lib/tmp.js"],"sourcesContent":["/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/*\n * Module dependencies.\n */\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\nconst crypto = require('crypto');\nconst _c = { fs: fs.constants, os: os.constants };\n\n/*\n * The working inner variables.\n */\nconst\n  // the random characters to choose from\n  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\n  TEMPLATE_PATTERN = /XXXXXX/,\n\n  DEFAULT_TRIES = 3,\n\n  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n\n  // constants are off on the windows platform and will not match the actual errno codes\n  IS_WIN32 = os.platform() === 'win32',\n  EBADF = _c.EBADF || _c.os.errno.EBADF,\n  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,\n\n  DIR_MODE = 0o700 /* 448 */,\n  FILE_MODE = 0o600 /* 384 */,\n\n  EXIT = 'exit',\n\n  // this will hold the objects need to be removed on exit\n  _removeObjects = [],\n\n  // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback\n  FN_RMDIR_SYNC = fs.rmdirSync.bind(fs);\n\nlet\n  _gracefulCleanup = false;\n\n/**\n * Recursively remove a directory and its contents.\n *\n * @param {string} dirPath path of directory to remove\n * @param {Function} callback\n * @private\n */\nfunction rimraf(dirPath, callback) {\n  return fs.rm(dirPath, { recursive: true }, callback);\n}\n\n/**\n * Recursively remove a directory and its contents, synchronously.\n *\n * @param {string} dirPath path of directory to remove\n * @private\n */\nfunction FN_RIMRAF_SYNC(dirPath) {\n  return fs.rmSync(dirPath, { recursive: true });\n}\n\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */\nfunction tmpName(options, callback) {\n  const\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  try {\n    _assertAndSanitizeOptions(opts);\n  } catch (err) {\n    return cb(err);\n  }\n\n  let tries = opts.tries;\n  (function _getUniqueName() {\n    try {\n      const name = _generateTmpName(opts);\n\n      // check whether the path exists then retry if needed\n      fs.stat(name, function (err) {\n        /* istanbul ignore else */\n        if (!err) {\n          /* istanbul ignore else */\n          if (tries-- > 0) return _getUniqueName();\n\n          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n        }\n\n        cb(null, name);\n      });\n    } catch (err) {\n      cb(err);\n    }\n  }());\n}\n\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */\nfunction tmpNameSync(options) {\n  const\n    args = _parseArguments(options),\n    opts = args[0];\n\n  _assertAndSanitizeOptions(opts);\n\n  let tries = opts.tries;\n  do {\n    const name = _generateTmpName(opts);\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined\n * @param {?fileCallback} callback\n */\nfunction file(options, callback) {\n  const\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create and open the file\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      /* istanbu ignore else */\n      if (err) return cb(err);\n\n      if (opts.discardDescriptor) {\n        return fs.close(fd, function _discardCallback(possibleErr) {\n          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only\n          return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));\n        });\n      } else {\n        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care\n        // about the descriptor\n        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));\n      }\n    });\n  });\n}\n\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */\nfunction fileSync(options) {\n  const\n    args = _parseArguments(options),\n    opts = args[0];\n\n  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n  const name = tmpNameSync(opts);\n  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  /* istanbul ignore else */\n  if (opts.discardDescriptor) {\n    fs.closeSync(fd);\n    fd = undefined;\n  }\n\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)\n  };\n}\n\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */\nfunction dir(options, callback) {\n  const\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create the directory\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));\n    });\n  });\n}\n\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */\nfunction dirSync(options) {\n  const\n    args = _parseArguments(options),\n    opts = args[0];\n\n  const name = tmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)\n  };\n}\n\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */\nfunction _removeFileAsync(fdPath, next) {\n  const _handler = function (err) {\n    if (err && !_isENOENT(err)) {\n      // reraise any unanticipated error\n      return next(err);\n    }\n    next();\n  };\n\n  if (0 <= fdPath[0])\n    fs.close(fdPath[0], function () {\n      fs.unlink(fdPath[1], _handler);\n    });\n  else fs.unlink(fdPath[1], _handler);\n}\n\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */\nfunction _removeFileSync(fdPath) {\n  let rethrownException = null;\n  try {\n    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n  } catch (e) {\n    // reraise any unanticipated error\n    if (!_isEBADF(e) && !_isENOENT(e)) throw e;\n  } finally {\n    try {\n      fs.unlinkSync(fdPath[1]);\n    }\n    catch (e) {\n      // reraise any unanticipated error\n      if (!_isENOENT(e)) rethrownException = e;\n    }\n  }\n  if (rethrownException !== null) {\n    throw rethrownException;\n  }\n}\n\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * Returns either a sync callback or a async callback depending on whether\n * fileSync or file was called, which is expressed by the sync parameter.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {fileCallback | fileCallbackSync}\n * @private\n */\nfunction _prepareTmpFileRemoveCallback(name, fd, opts, sync) {\n  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);\n  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);\n\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * Returns either a sync callback or a async callback depending on whether\n * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.\n *\n * @param {string} name\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {Function} the callback\n * @private\n */\nfunction _prepareTmpDirRemoveCallback(name, opts, sync) {\n  const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);\n  const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;\n  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);\n  const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * The cleanup callback is save to be called multiple times.\n * Subsequent invocations will be ignored.\n *\n * @param {Function} removeFunction\n * @param {string} fileOrDirName\n * @param {boolean} sync\n * @param {cleanupCallbackSync?} cleanupCallbackSync\n * @returns {cleanupCallback | cleanupCallbackSync}\n * @private\n */\nfunction _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {\n  let called = false;\n\n  // if sync is true, the next parameter will be ignored\n  return function _cleanupCallback(next) {\n\n    /* istanbul ignore else */\n    if (!called) {\n      // remove cleanupCallback from cache\n      const toRemove = cleanupCallbackSync || _cleanupCallback;\n      const index = _removeObjects.indexOf(toRemove);\n      /* istanbul ignore else */\n      if (index >= 0) _removeObjects.splice(index, 1);\n\n      called = true;\n      if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {\n        return removeFunction(fileOrDirName);\n      } else {\n        return removeFunction(fileOrDirName, next || function() {});\n      }\n    }\n  };\n}\n\n/**\n * The garbage collector.\n *\n * @private\n */\nfunction _garbageCollector() {\n  /* istanbul ignore else */\n  if (!_gracefulCleanup) return;\n\n  // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0]();\n    } catch (e) {\n      // already removed?\n    }\n  }\n}\n\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */\nfunction _randomChars(howMany) {\n  let\n    value = [],\n    rnd = null;\n\n  // make sure that we do not fail because we ran out of entropy\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n\n  for (var i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n\n  return value.join('');\n}\n\n/**\n * Helper which determines whether a string s is blank, that is undefined, or empty or null.\n *\n * @private\n * @param {string} s\n * @returns {Boolean} true whether the string s is blank, false otherwise\n */\nfunction _isBlank(s) {\n  return s === null || _isUndefined(s) || !s.trim();\n}\n\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|null|undefined|Function)} options\n * @param {?Function} callback\n * @returns {Array} parsed arguments\n * @private\n */\nfunction _parseArguments(options, callback) {\n  /* istanbul ignore else */\n  if (typeof options === 'function') {\n    return [{}, options];\n  }\n\n  /* istanbul ignore else */\n  if (_isUndefined(options)) {\n    return [{}, callback];\n  }\n\n  // copy options so we do not leak the changes we make internally\n  const actualOptions = {};\n  for (const key of Object.getOwnPropertyNames(options)) {\n    actualOptions[key] = options[key];\n  }\n\n  return [actualOptions, callback];\n}\n\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */\nfunction _generateTmpName(opts) {\n\n  const tmpDir = opts.tmpdir;\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.name))\n    return path.join(tmpDir, opts.dir, opts.name);\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.template))\n    return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));\n\n  // prefix and postfix\n  const name = [\n    opts.prefix ? opts.prefix : 'tmp',\n    '-',\n    process.pid,\n    '-',\n    _randomChars(12),\n    opts.postfix ? '-' + opts.postfix : ''\n  ].join('');\n\n  return path.join(tmpDir, opts.dir, name);\n}\n\n/**\n * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing\n * options.\n *\n * @param {Options} options\n * @private\n */\nfunction _assertAndSanitizeOptions(options) {\n\n  options.tmpdir = _getTmpDir(options);\n\n  const tmpDir = options.tmpdir;\n\n  /* istanbul ignore else */\n  if (!_isUndefined(options.name))\n    _assertIsRelative(options.name, 'name', tmpDir);\n  /* istanbul ignore else */\n  if (!_isUndefined(options.dir))\n    _assertIsRelative(options.dir, 'dir', tmpDir);\n  /* istanbul ignore else */\n  if (!_isUndefined(options.template)) {\n    _assertIsRelative(options.template, 'template', tmpDir);\n    if (!options.template.match(TEMPLATE_PATTERN))\n      throw new Error(`Invalid template, found \"${options.template}\".`);\n  }\n  /* istanbul ignore else */\n  if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0)\n    throw new Error(`Invalid tries, found \"${options.tries}\".`);\n\n  // if a name was specified we will try once\n  options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;\n  options.keep = !!options.keep;\n  options.detachDescriptor = !!options.detachDescriptor;\n  options.discardDescriptor = !!options.discardDescriptor;\n  options.unsafeCleanup = !!options.unsafeCleanup;\n\n  // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to\n  options.dir = _isUndefined(options.dir) ? '' : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));\n  options.template = _isUndefined(options.template) ? undefined : path.relative(tmpDir, _resolvePath(options.template, tmpDir));\n  // sanitize further if template is relative to options.dir\n  options.template = _isBlank(options.template) ? undefined : path.relative(options.dir, options.template);\n\n  // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to\n  options.name = _isUndefined(options.name) ? undefined : options.name;\n  options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;\n  options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;\n}\n\n/**\n * Resolve the specified path name in respect to tmpDir.\n *\n * The specified name might include relative path components, e.g. ../\n * so we need to resolve in order to be sure that is is located inside tmpDir\n *\n * @param name\n * @param tmpDir\n * @returns {string}\n * @private\n */\nfunction _resolvePath(name, tmpDir) {\n  if (name.startsWith(tmpDir)) {\n    return path.resolve(name);\n  } else {\n    return path.resolve(path.join(tmpDir, name));\n  }\n}\n\n/**\n * Asserts whether specified name is relative to the specified tmpDir.\n *\n * @param {string} name\n * @param {string} option\n * @param {string} tmpDir\n * @throws {Error}\n * @private\n */\nfunction _assertIsRelative(name, option, tmpDir) {\n  if (option === 'name') {\n    // assert that name is not absolute and does not contain a path\n    if (path.isAbsolute(name))\n      throw new Error(`${option} option must not contain an absolute path, found \"${name}\".`);\n    // must not fail on valid .<name> or ..<name> or similar such constructs\n    let basename = path.basename(name);\n    if (basename === '..' || basename === '.' || basename !== name)\n      throw new Error(`${option} option must not contain a path, found \"${name}\".`);\n  }\n  else { // if (option === 'dir' || option === 'template') {\n    // assert that dir or template are relative to tmpDir\n    if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {\n      throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${name}\".`);\n    }\n    let resolvedPath = _resolvePath(name, tmpDir);\n    if (!resolvedPath.startsWith(tmpDir))\n      throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${resolvedPath}\".`);\n  }\n}\n\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isEBADF(error) {\n  return _isExpectedError(error, -EBADF, 'EBADF');\n}\n\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isENOENT(error) {\n  return _isExpectedError(error, -ENOENT, 'ENOENT');\n}\n\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {number} any numerical value will be negated\n *\n * CAVEAT\n *\n * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT\n * is no different here.\n *\n * @param {SystemError} error\n * @param {number} errno\n * @param {string} code\n * @private\n */\nfunction _isExpectedError(error, errno, code) {\n  return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;\n}\n\n/**\n * Sets the graceful cleanup.\n *\n * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the\n * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary\n * object removals.\n */\nfunction setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n * @param {?Options} options\n * @returns {string} the currently configured tmp dir\n */\nfunction _getTmpDir(options) {\n  return path.resolve(options && options.tmpdir || os.tmpdir());\n}\n\n// Install process exit listener\nprocess.addListener(EXIT, _garbageCollector);\n\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected\n * @property {?number} tries the number of tries before give up the name generation\n * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fixed name relative to tmpdir or the specified dir option\n * @property {?string} dir tmp directory relative to the root tmp directory in use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection\n * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection\n */\n\n/**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor or -1 if the fd has been discarded\n * @property {fileCallback} removeCallback the callback function to remove the file\n */\n\n/**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */\n\n/**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */\n\n/**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback fileCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallbackSync\n */\n\n/**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */\n\n// exporting all the needed methods\n\n// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\nObject.defineProperty(module.exports, 'tmpdir', {\n  enumerable: true,\n  configurable: false,\n  get: function () {\n    return _getTmpDir();\n  }\n});\n\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\n\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\n\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\n\nmodule.exports.setGracefulCleanup = setGracefulCleanup;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}