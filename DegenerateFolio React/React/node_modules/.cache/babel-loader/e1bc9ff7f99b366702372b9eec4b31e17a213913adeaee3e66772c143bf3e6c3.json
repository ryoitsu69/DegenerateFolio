{"ast":null,"code":"import EventEmitter from 'eventemitter3';\nimport { Color } from '../../color/Color.mjs';\nimport { cullingMixin } from '../../culling/cullingMixin.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { RAD_TO_DEG, DEG_TO_RAD } from '../../maths/misc/const.mjs';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { uid } from '../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { childrenHelperMixin } from './container-mixins/childrenHelperMixin.mjs';\nimport { effectsMixin } from './container-mixins/effectsMixin.mjs';\nimport { findMixin } from './container-mixins/findMixin.mjs';\nimport { measureMixin } from './container-mixins/measureMixin.mjs';\nimport { onRenderMixin } from './container-mixins/onRenderMixin.mjs';\nimport { sortMixin } from './container-mixins/sortMixin.mjs';\nimport { toLocalGlobalMixin } from './container-mixins/toLocalGlobalMixin.mjs';\nimport { RenderGroup } from './RenderGroup.mjs';\nimport { assignWithIgnore } from './utils/assignWithIgnore.mjs';\n\"use strict\";\nconst defaultSkew = new ObservablePoint(null);\nconst defaultPivot = new ObservablePoint(null);\nconst defaultScale = new ObservablePoint(null, 1, 1);\nconst UPDATE_COLOR = 1;\nconst UPDATE_BLEND = 2;\nconst UPDATE_VISIBLE = 4;\nconst UPDATE_TRANSFORM = 8;\nclass Container extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    /** @private */\n    this.uid = uid(\"renderable\");\n    /** @private */\n    this._updateFlags = 15;\n    // the render group this container owns\n    /** @private */\n    this.renderGroup = null;\n    // the render group this container belongs to\n    /** @private */\n    this.parentRenderGroup = null;\n    // the index of the container in the render group\n    /** @private */\n    this.parentRenderGroupIndex = 0;\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    this.didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    this.didViewUpdate = false;\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    this.relativeRenderGroupDepth = 0;\n    /**\n     * The array of children of this container.\n     * @readonly\n     */\n    this.children = [];\n    /** The display object container that contains this display object. */\n    this.parent = null;\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    this.includeInBuild = true;\n    /** @private */\n    this.measurable = true;\n    /** @private */\n    this.isSimple = true;\n    // / /////////////Transform related props//////////////\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /**\n     * @internal\n     * @ignore\n     */\n    this.updateTick = -1;\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    this.localTransform = new Matrix();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */\n    this.relativeGroupTransform = new Matrix();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */\n    this.groupTransform = this.relativeGroupTransform;\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    this.destroyed = false;\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */\n    this._position = new ObservablePoint(this, 0, 0);\n    /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */\n    this._scale = defaultScale;\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */\n    this._pivot = defaultPivot;\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */\n    this._skew = defaultSkew;\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cx = 1;\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sx = 0;\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cy = 0;\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sy = 1;\n    /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */\n    this._rotation = 0;\n    // / COLOR related props //////////////\n    // color stored as ABGR\n    this.localColor = 16777215;\n    this.localAlpha = 1;\n    this.groupAlpha = 1;\n    // A\n    this.groupColor = 16777215;\n    // BGR\n    this.groupColorAlpha = 4294967295;\n    // ABGR\n    // / BLEND related props //////////////\n    /**\n     * @internal\n     * @ignore\n     */\n    this.localBlendMode = \"inherit\";\n    /**\n     * @internal\n     * @ignore\n     */\n    this.groupBlendMode = \"normal\";\n    // / VISIBILITY related props //////////////\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = renderable, 1 = not renderable) 0b001\n     * @internal\n     * @ignore\n     */\n    this.localDisplayStatus = 7;\n    // 0b11 | 0b10 | 0b01 | 0b00\n    /**\n     * @internal\n     * @ignore\n     */\n    this.globalDisplayStatus = 7;\n    /**\n     * A value that increments each time the container is modified\n     * the first 12 bits represent the container changes (eg transform, alpha, visible etc)\n     * the second 12 bits represent:\n     *      - for view changes (eg texture swap, geometry change etc)\n     *      - containers changes (eg children added, removed etc)\n     *\n     *  view          container\n     * [000000000000][00000000000]\n     * @ignore\n     */\n    this._didChangeId = 0;\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    this._didLocalTransformChangeId = -1;\n    assignWithIgnore(this, options, {\n      children: true,\n      parent: true,\n      effects: true\n    });\n    options.children?.forEach(child => this.addChild(child));\n    this.effects = [];\n    options.parent?.addChild(this);\n  }\n  /**\n   * Mixes all enumerable properties and methods from a source object to Container.\n   * @param source - The source of properties and methods to mix in.\n   */\n  static mixin(source) {\n    Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source));\n  }\n  /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   * @param {...Container} children - The Container(s) to add to the container\n   * @returns {Container} - The first child that was added.\n   */\n  addChild(...children) {\n    if (!this.allowChildren) {\n      deprecation(v8_0_0, \"addChild: Only Containers will be allowed to add children in v8.0.0\");\n    }\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.addChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    if (child.parent === this) {\n      this.children.splice(this.children.indexOf(child), 1);\n      this.children.push(child);\n      if (this.parentRenderGroup) {\n        this.parentRenderGroup.structureDidChange = true;\n      }\n      return child;\n    }\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    this.children.push(child);\n    if (this.sortableChildren) this.sortDirty = true;\n    child.parent = this;\n    child.didChange = true;\n    child.didViewUpdate = false;\n    child._updateFlags = 15;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.addChild(child);\n    }\n    this.emit(\"childAdded\", child, this, this.children.length - 1);\n    child.emit(\"added\", this);\n    this._didChangeId += 1 << 12;\n    if (child._zIndex !== 0) {\n      child.depthOfChildModified();\n    }\n    return child;\n  }\n  /**\n   * Removes one or more children from the container.\n   * @param {...Container} children - The Container(s) to remove\n   * @returns {Container} The first child that was removed.\n   */\n  removeChild(...children) {\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    const index = this.children.indexOf(child);\n    if (index > -1) {\n      this._didChangeId += 1 << 12;\n      this.children.splice(index, 1);\n      if (this.renderGroup) {\n        this.renderGroup.removeChild(child);\n      } else if (this.parentRenderGroup) {\n        this.parentRenderGroup.removeChild(child);\n      }\n      child.parent = null;\n      this.emit(\"childRemoved\", child, this, index);\n      child.emit(\"removed\", this);\n    }\n    return child;\n  }\n  /** @ignore */\n  _onUpdate(point) {\n    if (point) {\n      if (point === this._skew) {\n        this._updateSkew();\n      }\n    }\n    this._didChangeId++;\n    if (this.didChange) return;\n    this.didChange = true;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.onChildUpdate(this);\n    }\n  }\n  set isRenderGroup(value) {\n    if (this.renderGroup && value === false) {\n      throw new Error(\"[Pixi] cannot undo a render group just yet\");\n    }\n    if (value) {\n      this.enableRenderGroup();\n    }\n  }\n  /**\n   * Returns true if this container is a render group.\n   * This means that it will be rendered as a separate pass, with its own set of instructions\n   */\n  get isRenderGroup() {\n    return !!this.renderGroup;\n  }\n  /** This enables the container to be rendered as a render group. */\n  enableRenderGroup() {\n    if (this.renderGroup) return;\n    const parentRenderGroup = this.parentRenderGroup;\n    if (parentRenderGroup) {\n      parentRenderGroup.removeChild(this);\n    }\n    this.renderGroup = new RenderGroup(this);\n    if (parentRenderGroup) {\n      parentRenderGroup.addChild(this);\n    }\n    this._updateIsSimple();\n    this.groupTransform = Matrix.IDENTITY;\n  }\n  /** @ignore */\n  _updateIsSimple() {\n    this.isSimple = !this.renderGroup && this.effects.length === 0;\n  }\n  /**\n   * Current transform of the object based on world (parent) factors.\n   * @readonly\n   */\n  get worldTransform() {\n    this._worldTransform || (this._worldTransform = new Matrix());\n    if (this.renderGroup) {\n      this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n    } else if (this.parentRenderGroup) {\n      this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);\n    }\n    return this._worldTransform;\n  }\n  // / ////// transform related stuff\n  /**\n   * The position of the container on the x axis relative to the local coordinates of the parent.\n   * An alias to position.x\n   */\n  get x() {\n    return this._position.x;\n  }\n  set x(value) {\n    this._position.x = value;\n  }\n  /**\n   * The position of the container on the y axis relative to the local coordinates of the parent.\n   * An alias to position.y\n   */\n  get y() {\n    return this._position.y;\n  }\n  set y(value) {\n    this._position.y = value;\n  }\n  /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   * @since 4.0.0\n   */\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    this._position.copyFrom(value);\n  }\n  /**\n   * The rotation of the object in radians.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(value) {\n    if (this._rotation !== value) {\n      this._rotation = value;\n      this._onUpdate(this._skew);\n    }\n  }\n  /**\n   * The angle of the object in degrees.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get angle() {\n    return this.rotation * RAD_TO_DEG;\n  }\n  set angle(value) {\n    this.rotation = value * DEG_TO_RAD;\n  }\n  /**\n   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n   * is the projection of `pivot` in the parent's local space.\n   *\n   * By default, the pivot is the origin (0, 0).\n   * @since 4.0.0\n   */\n  get pivot() {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint(this, 0, 0);\n    }\n    return this._pivot;\n  }\n  set pivot(value) {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint(this, 0, 0);\n    }\n    typeof value === \"number\" ? this._pivot.set(value) : this._pivot.copyFrom(value);\n  }\n  /**\n   * The skew factor for the object in radians.\n   * @since 4.0.0\n   */\n  get skew() {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint(this, 0, 0);\n    }\n    return this._skew;\n  }\n  set skew(value) {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint(this, 0, 0);\n    }\n    this._skew.copyFrom(value);\n  }\n  /**\n   * The scale factors of this object along the local coordinate axes.\n   *\n   * The default scale is (1, 1).\n   * @since 4.0.0\n   */\n  get scale() {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint(this, 1, 1);\n    }\n    return this._scale;\n  }\n  set scale(value) {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint(this, 0, 0);\n    }\n    typeof value === \"number\" ? this._scale.set(value) : this._scale.copyFrom(value);\n  }\n  /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get width() {\n    return Math.abs(this.scale.x * this.getLocalBounds().width);\n  }\n  set width(value) {\n    const localWidth = this.getLocalBounds().width;\n    this._setWidth(value, localWidth);\n  }\n  /**\n   * The height of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get height() {\n    return Math.abs(this.scale.y * this.getLocalBounds().height);\n  }\n  set height(value) {\n    const localHeight = this.getLocalBounds().height;\n    this._setHeight(value, localHeight);\n  }\n  /**\n   * Retrieves the size of the container as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the container.\n   * @memberof scene.Container#\n   */\n  getSize(out) {\n    if (!out) {\n      out = {};\n    }\n    const bounds = this.getLocalBounds();\n    out.width = Math.abs(this.scale.x * bounds.width);\n    out.height = Math.abs(this.scale.y * bounds.height);\n    return out;\n  }\n  /**\n   * Sets the size of the container to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   * @memberof scene.Container#\n   */\n  setSize(value, height) {\n    const size = this.getLocalBounds();\n    let convertedWidth;\n    let convertedHeight;\n    if (typeof value !== \"object\") {\n      convertedWidth = value;\n      convertedHeight = height ?? value;\n    } else {\n      convertedWidth = value.width;\n      convertedHeight = value.height ?? value.width;\n    }\n    if (convertedWidth !== void 0) {\n      this._setWidth(convertedWidth, size.width);\n    }\n    if (convertedHeight !== void 0) {\n      this._setHeight(convertedHeight, size.height);\n    }\n  }\n  /** Called when the skew or the rotation changes. */\n  _updateSkew() {\n    const rotation = this._rotation;\n    const skew = this._skew;\n    this._cx = Math.cos(rotation + skew._y);\n    this._sx = Math.sin(rotation + skew._y);\n    this._cy = -Math.sin(rotation - skew._x);\n    this._sy = Math.cos(rotation - skew._x);\n  }\n  /**\n   * Updates the transform properties of the container (accepts partial values).\n   * @param {object} opts - The options for updating the transform.\n   * @param {number} opts.x - The x position of the container.\n   * @param {number} opts.y - The y position of the container.\n   * @param {number} opts.scaleX - The scale factor on the x-axis.\n   * @param {number} opts.scaleY - The scale factor on the y-axis.\n   * @param {number} opts.rotation - The rotation of the container, in radians.\n   * @param {number} opts.skewX - The skew factor on the x-axis.\n   * @param {number} opts.skewY - The skew factor on the y-axis.\n   * @param {number} opts.pivotX - The x coordinate of the pivot point.\n   * @param {number} opts.pivotY - The y coordinate of the pivot point.\n   */\n  updateTransform(opts) {\n    this.position.set(typeof opts.x === \"number\" ? opts.x : this.position.x, typeof opts.y === \"number\" ? opts.y : this.position.y);\n    this.scale.set(typeof opts.scaleX === \"number\" ? opts.scaleX || 1 : this.scale.x, typeof opts.scaleY === \"number\" ? opts.scaleY || 1 : this.scale.y);\n    this.rotation = typeof opts.rotation === \"number\" ? opts.rotation : this.rotation;\n    this.skew.set(typeof opts.skewX === \"number\" ? opts.skewX : this.skew.x, typeof opts.skewY === \"number\" ? opts.skewY : this.skew.y);\n    this.pivot.set(typeof opts.pivotX === \"number\" ? opts.pivotX : this.pivot.x, typeof opts.pivotY === \"number\" ? opts.pivotY : this.pivot.y);\n    return this;\n  }\n  /**\n   * Updates the local transform using the given matrix.\n   * @param matrix - The matrix to use for updating the transform.\n   */\n  setFromMatrix(matrix) {\n    matrix.decompose(this);\n  }\n  /** Updates the local transform. */\n  updateLocalTransform() {\n    if ((this._didLocalTransformChangeId & 15) === this._didChangeId) return;\n    this._didLocalTransformChangeId = this._didChangeId;\n    const lt = this.localTransform;\n    const scale = this._scale;\n    const pivot = this._pivot;\n    const position = this._position;\n    const sx = scale._x;\n    const sy = scale._y;\n    const px = pivot._x;\n    const py = pivot._y;\n    lt.a = this._cx * sx;\n    lt.b = this._sx * sx;\n    lt.c = this._cy * sy;\n    lt.d = this._sy * sy;\n    lt.tx = position._x - (px * lt.a + py * lt.c);\n    lt.ty = position._y - (px * lt.b + py * lt.d);\n  }\n  // / ///// color related stuff\n  set alpha(value) {\n    if (value === this.localAlpha) return;\n    this.localAlpha = value;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /** The opacity of the object. */\n  get alpha() {\n    return this.localAlpha;\n  }\n  set tint(value) {\n    const tempColor = Color.shared.setValue(value ?? 16777215);\n    const bgr = tempColor.toBgrNumber();\n    if (bgr === this.localColor) return;\n    this.localColor = bgr;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /**\n   * The tint applied to the sprite. This is a hex value.\n   *\n   * A value of 0xFFFFFF will remove any tint effect.\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    const bgr = this.localColor;\n    return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);\n  }\n  // / //////////////// blend related stuff\n  set blendMode(value) {\n    if (this.localBlendMode === value) return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_BLEND;\n    this.localBlendMode = value;\n    this._onUpdate();\n  }\n  /**\n   * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this.localBlendMode;\n  }\n  // / ///////// VISIBILITY / RENDERABLE /////////////////\n  /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */\n  get visible() {\n    return !!(this.localDisplayStatus & 2);\n  }\n  set visible(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 2) >> 1 === valueNumber) return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 2;\n    this._onUpdate();\n  }\n  /** @ignore */\n  get culled() {\n    return !(this.localDisplayStatus & 4);\n  }\n  /** @ignore */\n  set culled(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 4) >> 2 === valueNumber) return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 4;\n    this._onUpdate();\n  }\n  /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */\n  get renderable() {\n    return !!(this.localDisplayStatus & 1);\n  }\n  set renderable(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 1) === valueNumber) return;\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 1;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._onUpdate();\n  }\n  /** Whether or not the object should be rendered. */\n  get isRenderable() {\n    return this.localDisplayStatus === 7 && this.groupAlpha > 0;\n  }\n  /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n   * is set to true it should destroy the texture of the child sprite\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true it should destroy the texture source of the child sprite\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true it should destroy the context of the child graphics\n   */\n  destroy(options = false) {\n    if (this.destroyed) return;\n    this.destroyed = true;\n    const oldChildren = this.removeChildren(0, this.children.length);\n    this.removeFromParent();\n    this.parent = null;\n    this._maskEffect = null;\n    this._filterEffect = null;\n    this.effects = null;\n    this._position = null;\n    this._scale = null;\n    this._pivot = null;\n    this._skew = null;\n    this.emit(\"destroyed\", this);\n    this.removeAllListeners();\n    const destroyChildren = typeof options === \"boolean\" ? options : options?.children;\n    if (destroyChildren) {\n      for (let i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n  }\n}\nContainer.mixin(childrenHelperMixin);\nContainer.mixin(toLocalGlobalMixin);\nContainer.mixin(onRenderMixin);\nContainer.mixin(measureMixin);\nContainer.mixin(effectsMixin);\nContainer.mixin(findMixin);\nContainer.mixin(sortMixin);\nContainer.mixin(cullingMixin);\nexport { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_TRANSFORM, UPDATE_VISIBLE };","map":{"version":3,"names":["defaultSkew","ObservablePoint","defaultPivot","defaultScale","UPDATE_COLOR","UPDATE_BLEND","UPDATE_VISIBLE","UPDATE_TRANSFORM","Container","EventEmitter","constructor","options","uid","_updateFlags","renderGroup","parentRenderGroup","parentRenderGroupIndex","didChange","didViewUpdate","relativeRenderGroupDepth","children","parent","includeInBuild","measurable","isSimple","updateTick","localTransform","Matrix","relativeGroupTransform","groupTransform","destroyed","_position","_scale","_pivot","_skew","_cx","_sx","_cy","_sy","_rotation","localColor","localAlpha","groupAlpha","groupColor","groupColorAlpha","localBlendMode","groupBlendMode","localDisplayStatus","globalDisplayStatus","_didChangeId","_didLocalTransformChangeId","assignWithIgnore","effects","forEach","child","addChild","mixin","source","Object","defineProperties","prototype","getOwnPropertyDescriptors","allowChildren","deprecation","v8_0_0","length","i","splice","indexOf","push","structureDidChange","removeChild","sortableChildren","sortDirty","emit","_zIndex","depthOfChildModified","index","_onUpdate","point","_updateSkew","onChildUpdate","isRenderGroup","value","Error","enableRenderGroup","RenderGroup","_updateIsSimple","IDENTITY","worldTransform","_worldTransform","copyFrom","appendFrom","x","y","position","rotation","angle","RAD_TO_DEG","DEG_TO_RAD","pivot","set","skew","scale","width","Math","abs","getLocalBounds","localWidth","_setWidth","height","localHeight","_setHeight","getSize","out","bounds","setSize","size","convertedWidth","convertedHeight","cos","_y","sin","_x","updateTransform","opts","scaleX","scaleY","skewX","skewY","pivotX","pivotY","setFromMatrix","matrix","decompose","updateLocalTransform","lt","sx","sy","px","py","a","b","c","d","tx","ty","alpha","tint","tempColor","Color","shared","setValue","bgr","toBgrNumber","blendMode","visible","valueNumber","culled","renderable","isRenderable","destroy","oldChildren","removeChildren","removeFromParent","_maskEffect","_filterEffect","removeAllListeners","destroyChildren","childrenHelperMixin","toLocalGlobalMixin","onRenderMixin","measureMixin","effectsMixin","findMixin","sortMixin","cullingMixin"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/container/Container.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { cullingMixin } from '../../culling/cullingMixin';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { DEG_TO_RAD, RAD_TO_DEG } from '../../maths/misc/const';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { uid } from '../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { childrenHelperMixin } from './container-mixins/childrenHelperMixin';\nimport { effectsMixin } from './container-mixins/effectsMixin';\nimport { findMixin } from './container-mixins/findMixin';\nimport { measureMixin } from './container-mixins/measureMixin';\nimport { onRenderMixin } from './container-mixins/onRenderMixin';\nimport { sortMixin } from './container-mixins/sortMixin';\nimport { toLocalGlobalMixin } from './container-mixins/toLocalGlobalMixin';\nimport { RenderGroup } from './RenderGroup';\nimport { assignWithIgnore } from './utils/assignWithIgnore';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Rectangle } from '../../maths/shapes/Rectangle';\nimport type { BLEND_MODES } from '../../rendering/renderers/shared/state/const';\nimport type { Dict } from '../../utils/types';\nimport type { Optional } from './container-mixins/measureMixin';\nimport type { DestroyOptions } from './destroyTypes';\n\nexport type ContainerChild = Container;\n\n/**\n * This is where you'll find all the display objects available in Pixi.\n *\n * All display objects inherit from the {@link scene.Container} class. You can use a `Container` for simple grouping of\n * other display objects. Here's all the available display object classes.\n *\n * - {@link scene.Container} is the base class for all display objects that act as a container for other objects.\n *   - {@link scene.Sprite} is a display object that uses a texture\n *      - {@link scene.AnimatedSprite} is a sprite that can play animations\n *   - {@link scene.TilingSprite} a fast way of rendering a tiling image\n *   - {@link scene.NineSliceSprite} allows you to stretch a texture using 9-slice scaling\n *   - {@link scene.Graphics} is a graphic object that can be drawn to the screen.\n *   - {@link scene.Mesh} empowers you to have maximum flexibility to render any kind of visuals you can think of\n *      - {@link scene.MeshSimple} mimics Mesh, providing easy-to-use constructor arguments\n *      - {@link scene.MeshPlane} allows you to draw a texture across several points and then manipulate these points\n *      - {@link scene.MeshRope} allows you to draw a texture across several points and then manipulate these points\n *   - {@link scene.Text} render text using custom fonts\n *      - {@link scene.BitmapText} render text using a bitmap font\n *      - {@link scene.HTMLText} render text using HTML and CSS\n * @namespace scene\n */\n\n// as pivot and skew are the least used properties of a container, we can use this optimisation\n// to avoid allocating lots of unnecessary objects for them.\nconst defaultSkew = new ObservablePoint(null);\nconst defaultPivot = new ObservablePoint(null);\nconst defaultScale = new ObservablePoint(null, 1, 1);\n\nexport interface ContainerEvents<C extends ContainerChild> extends PixiMixins.ContainerEvents\n{\n    added: [container: Container];\n    childAdded: [child: C, container: Container, index: number];\n    removed: [container: Container];\n    childRemoved: [child: C, container: Container, index: number];\n    destroyed: [container: Container];\n}\n\ntype AnyEvent = {\n    // The following is a hack to allow any custom event while maintaining type safety.\n    // For some reason, the tsc compiler gets angry about error TS1023\n    // \"An index signature parameter type must be either 'string' or 'number'.\"\n    // This is really odd since ({}&string) should interpret as string, but then again\n    // there is some black magic behind why this works in the first place.\n    // Closest thing to an explanation:\n    // https://stackoverflow.com/questions/70144348/why-does-a-union-of-type-literals-and-string-cause-ide-code-completion-wh\n    //\n    // Side note, we disable @typescript-eslint/ban-types since {}&string is the only syntax that works.\n    // Nor of the Record/unknown/never alternatives work.\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    [K: ({} & string) | ({} & symbol)]: any;\n};\n\nexport const UPDATE_COLOR = 0b0001;\nexport const UPDATE_BLEND = 0b0010;\nexport const UPDATE_VISIBLE = 0b0100;\nexport const UPDATE_TRANSFORM = 0b1000;\n\nexport interface UpdateTransformOptions\n{\n    x: number;\n    y: number;\n    scaleX: number;\n    scaleY: number;\n    rotation: number;\n    skewX: number;\n    skewY: number;\n    pivotX: number;\n    pivotY: number;\n}\n\n/**\n * Constructor options used for `Container` instances.\n * ```js\n * const container = new Container({\n *    position: new Point(100, 200),\n *    scale: new Point(2, 2),\n *    rotation: Math.PI / 2,\n * });\n * ```\n * @memberof scene\n * @see scene.Container\n */\nexport interface ContainerOptions<C extends ContainerChild = ContainerChild> extends PixiMixins.ContainerOptions\n{\n    /** @see scene.Container#isRenderGroup */\n    isRenderGroup?: boolean;\n\n    /** @see scene.Container#blendMode */\n    blendMode?: BLEND_MODES;\n    /** @see scene.Container#tint */\n    tint?: ColorSource;\n\n    /** @see scene.Container#alpha */\n    alpha?: number;\n    /** @see scene.Container#angle */\n    angle?: number;\n    /** @see scene.Container#children */\n    children?: C[];\n    /** @see scene.Container#parent */\n    parent?: Container;\n    /** @see scene.Container#renderable */\n    renderable?: boolean;\n    /** @see scene.Container#rotation */\n    rotation?: number;\n    /** @see scene.Container#scale */\n    scale?: PointData | number;\n    /** @see scene.Container#pivot */\n    pivot?: PointData | number;\n    /** @see scene.Container#position */\n    position?: PointData;\n    /** @see scene.Container#skew */\n    skew?: PointData;\n    /** @see scene.Container#visible */\n    visible?: boolean;\n    /** @see scene.Container#culled */\n    culled?: boolean;\n    /** @see scene.Container#x */\n    x?: number;\n    /** @see scene.Container#y */\n    y?: number;\n    /** @see scene.Container#boundArea */\n    boundsArea?: Rectangle;\n}\n\nexport interface Container<C extends ContainerChild>\n    extends Omit<PixiMixins.Container<C>, keyof EventEmitter<ContainerEvents<C> & AnyEvent>>,\n    EventEmitter<ContainerEvents<C> & AnyEvent> { }\n\n/**\n * Container is a general-purpose display object that holds children. It also adds built-in support for advanced\n * rendering features like masking and filtering.\n *\n * It is the base class of all display objects that act as a container for other objects, including Graphics\n * and Sprite.\n *\n * <details id=\"transforms\">\n *\n * <summary>Transforms</summary>\n *\n * The [transform]{@link scene.Container#transform} of a display object describes the projection from its\n * local coordinate space to its parent's local coordinate space. The following properties are derived\n * from the transform:\n *\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Property</th>\n *       <th>Description</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>[pivot]{@link scene.Container#pivot}</td>\n *       <td>\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\n *         rotation, scaling, and skewing.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[position]{@link scene.Container#position}</td>\n *       <td>\n *         Translation. This is the position of the [pivot]{@link scene.Container#pivot} in the parent's local\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[scale]{@link scene.Container#scale}</td>\n *       <td>\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\n *         of scaling is the [pivot]{@link scene.Container#pivot}.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[rotation]{@link scene.Container#rotation}</td>\n *       <td>\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[skew]{@link scene.Container#skew}</td>\n *       <td>\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\n *         <p>\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\n *         ⍺ and \"skew.y\" is β, then the line x = 0 will be rotated by ⍺ (y = -x*cot⍺) and the line y = 0 will be\n *         rotated by β (y = x*tanβ). A line y = x*tanϴ (i.e. a line at angle ϴ to the x-axis in local-space) will\n *         be rotated by an angle between ⍺ and β.\n *         </p>\n *         <p>\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\n *         a rotation. Indeed, if \"skew.x\" = -ϴ and \"skew.y\" = ϴ, it will produce an equivalent of \"rotation\" = ϴ.\n *         </p>\n *         <p>\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are commutative operations. Indeed,\n *         because rotation is essentially a careful combination of the two.\n *         </p>\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[angle]{@link scene.Container#angle}</td>\n *       <td>Rotation. This is an alias for [rotation]{@link scene.Container#rotation}, but in degrees.</td>\n *     </tr>\n *     <tr>\n *       <td>[x]{@link scene.Container#x}</td>\n *       <td>Translation. This is an alias for position.x!</td>\n *     </tr>\n *     <tr>\n *       <td>[y]{@link scene.Container#y}</td>\n *       <td>Translation. This is an alias for position.y!</td>\n *     </tr>\n *     <tr>\n *       <td>[width]{@link scene.Container#width}</td>\n *       <td>\n *         Implemented in [Container]{@link scene.Container}. Scaling. The width property calculates scale.x by dividing\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\n *         is no concept of user-defined width.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[height]{@link scene.Container#height}</td>\n *       <td>\n *         Implemented in [Container]{@link scene.Container}. Scaling. The height property calculates scale.y by dividing\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\n *         is no concept of user-defined height.\n *       </td>\n *     </tr>\n *   </tbody>\n * </table>\n * </details>\n *\n * <details id=\"alpha\">\n * <summary>Alpha</summary>\n *\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\n * applied on any ancestor further up the chain).\n * </details>\n *\n * <details id=\"visible\">\n * <summary>Renderable vs Visible</summary>\n *\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\n * be calculated.\n * ```ts\n * import { BlurFilter, Container, Graphics, Sprite } from 'pixi.js';\n *\n * const container = new Container();\n * const sprite = Sprite.from('https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/IaUrttj.png');\n *\n * sprite.width = 512;\n * sprite.height = 512;\n *\n * // Adds a sprite as a child to this container. As a result, the sprite will be rendered whenever the container\n * // is rendered.\n * container.addChild(sprite);\n *\n * // Blurs whatever is rendered by the container\n * container.filters = [new BlurFilter()];\n *\n * // Only the contents within a circle at the center should be rendered onto the screen.\n * container.mask = new Graphics()\n *     .beginFill(0xffffff)\n *     .drawCircle(sprite.width / 2, sprite.height / 2, Math.min(sprite.width, sprite.height) / 2)\n *     .endFill();\n * ```\n *\n * </details>\n *\n * <details id=\"renderGroup\">\n * <summary>RenderGroup</summary>\n *\n * In PixiJS v8, containers can be set to operate in 'render group mode',\n * transforming them into entities akin to a stage in traditional rendering paradigms.\n * A render group is a root renderable entity, similar to a container,\n * but it's rendered in a separate pass with its own unique set of rendering instructions.\n * This approach enhances rendering efficiency and organization, particularly in complex scenes.\n *\n * You can enable render group mode on any container using container.enableRenderGroup()\n * or by initializing a new container with the render group property set to true (new Container({isRenderGroup: true})).\n *  The method you choose depends on your specific use case and setup requirements.\n *\n * An important aspect of PixiJS’s rendering process is the automatic treatment of rendered scenes as render groups.\n * This conversion streamlines the rendering process, but understanding when and how this happens is crucial\n * to fully leverage its benefits.\n *\n * One of the key advantages of using render groups is the performance efficiency in moving them. Since transformations\n *  are applied at the GPU level, moving a render group, even one with complex and numerous children,\n * doesn't require recalculating the rendering instructions or performing transformations on each child.\n * This makes operations like panning a large game world incredibly efficient.\n *\n * However, it's crucial to note that render groups do not batch together.\n * This means that turning every container into a render group could actually slow things down,\n * as each render group is processed separately. It's best to use render groups judiciously, at a broader level,\n * rather than on a per-child basis.\n * This approach ensures you get the performance benefits without overburdening the rendering process.\n *\n * RenderGroups maintain their own set of rendering instructions,\n * ensuring that changes or updates within a render group don't affect the rendering\n * instructions of its parent or other render groups.\n *  This isolation ensures more stable and predictable rendering behavior.\n *\n * Additionally, renderGroups can be nested, allowing for powerful options in organizing different aspects of your scene.\n * This feature is particularly beneficial for separating complex game graphics from UI elements,\n * enabling intricate and efficient scene management in complex applications.\n *\n * This means that Containers have 3 levels of matrix to be mindful of:\n *\n * 1. localTransform, this is the transform of the container based on its own properties\n * 2. groupTransform, this it the transform of the container relative to the renderGroup it belongs too\n * 3. worldTransform, this is the transform of the container relative to the Scene being rendered\n * </details>\n * @memberof scene\n */\nexport class Container<C extends ContainerChild = ContainerChild> extends EventEmitter<ContainerEvents<C> & AnyEvent>\n{\n    /**\n     * Mixes all enumerable properties and methods from a source object to Container.\n     * @param source - The source of properties and methods to mix in.\n     */\n    public static mixin(source: Dict<any>): void\n    {\n        Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source));\n    }\n\n    /** @private */\n    public uid: number = uid('renderable');\n\n    /** @private */\n    public _updateFlags = 0b1111;\n\n    // the render group this container owns\n    /** @private */\n    public renderGroup: RenderGroup = null;\n    // the render group this container belongs to\n    /** @private */\n    public parentRenderGroup: RenderGroup = null;\n    // the index of the container in the render group\n    /** @private */\n    public parentRenderGroupIndex: number = 0;\n\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    public didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    public didViewUpdate = false;\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    public relativeRenderGroupDepth = 0;\n\n    /**\n     * The array of children of this container.\n     * @readonly\n     */\n    public children: C[] = [];\n    /** The display object container that contains this display object. */\n    public parent: Container = null;\n\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    public includeInBuild = true;\n    /** @private */\n    public measurable = true;\n    /** @private */\n    public isSimple = true;\n\n    // / /////////////Transform related props//////////////\n\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /**\n     * @internal\n     * @ignore\n     */\n    public updateTick = -1;\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    public localTransform: Matrix = new Matrix();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */\n    public relativeGroupTransform: Matrix = new Matrix();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */\n    public groupTransform: Matrix = this.relativeGroupTransform;\n\n    // the global transform taking into account the render group and all parents\n    private _worldTransform: Matrix;\n\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    public destroyed = false;\n\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */\n    public _position: ObservablePoint = new ObservablePoint(this, 0, 0);\n\n    /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */\n    public _scale: ObservablePoint = defaultScale;\n\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */\n    public _pivot: ObservablePoint = defaultPivot;\n\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */\n    public _skew: ObservablePoint = defaultSkew;\n\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _cx = 1;\n\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _sx = 0;\n\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _cy = 0;\n\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _sy = 1;\n\n    /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */\n    private _rotation = 0;\n\n    // / COLOR related props //////////////\n\n    // color stored as ABGR\n    public localColor = 0xFFFFFF;\n    public localAlpha = 1;\n\n    public groupAlpha = 1; // A\n    public groupColor = 0xFFFFFF; // BGR\n    public groupColorAlpha = 0xFFFFFFFF; // ABGR\n\n    // / BLEND related props //////////////\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public localBlendMode: BLEND_MODES = 'inherit';\n    /**\n     * @internal\n     * @ignore\n     */\n    public groupBlendMode: BLEND_MODES = 'normal';\n\n    // / VISIBILITY related props //////////////\n\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = renderable, 1 = not renderable) 0b001\n     * @internal\n     * @ignore\n     */\n    public localDisplayStatus = 0b111; // 0b11 | 0b10 | 0b01 | 0b00\n    /**\n     * @internal\n     * @ignore\n     */\n    public globalDisplayStatus = 0b111; // 0b11 | 0b10 | 0b01 | 0b00\n\n    public renderPipeId: string;\n\n    /**\n     * An optional bounds area for this container. Setting this rectangle will stop the renderer\n     * from recursively measuring the bounds of each children and instead use this single boundArea.\n     * This is great for optimisation! If for example you have a 1000 spinning particles and you know they all sit\n     * within a specific bounds, then setting it will mean the renderer will not need to measure the\n     * 1000 children to find the bounds. Instead it will just use the bounds you set.\n     */\n    public boundsArea: Rectangle;\n\n    /**\n     * A value that increments each time the container is modified\n     * the first 12 bits represent the container changes (eg transform, alpha, visible etc)\n     * the second 12 bits represent:\n     *      - for view changes (eg texture swap, geometry change etc)\n     *      - containers changes (eg children added, removed etc)\n     *\n     *  view          container\n     * [000000000000][00000000000]\n     * @ignore\n     */\n    public _didChangeId = 0;\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    private _didLocalTransformChangeId = -1;\n\n    constructor(options: ContainerOptions<C> = {})\n    {\n        super();\n\n        assignWithIgnore(this, options, {\n            children: true,\n            parent: true,\n            effects: true,\n        });\n\n        options.children?.forEach((child) => this.addChild(child));\n        this.effects = [];\n        options.parent?.addChild(this);\n    }\n\n    /**\n     * Adds one or more children to the container.\n     *\n     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n     * @param {...Container} children - The Container(s) to add to the container\n     * @returns {Container} - The first child that was added.\n     */\n    public addChild<U extends C[]>(...children: U): U[0]\n    {\n        // #if _DEBUG\n        if (!this.allowChildren)\n        {\n            deprecation(v8_0_0, 'addChild: Only Containers will be allowed to add children in v8.0.0');\n        }\n        // #endif\n\n        if (children.length > 1)\n        {\n            // loop through the array and add all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.addChild(children[i]);\n            }\n\n            return children[0];\n        }\n\n        const child = children[0];\n\n        if (child.parent === this)\n        {\n            this.children.splice(this.children.indexOf(child), 1);\n            this.children.push(child);\n\n            if (this.parentRenderGroup)\n            {\n                this.parentRenderGroup.structureDidChange = true;\n            }\n\n            return child;\n        }\n\n        if (child.parent)\n        {\n            // TODO Optimisation...if the parent has the same render group, this does not need to change!\n            child.parent.removeChild(child);\n        }\n\n        this.children.push(child);\n\n        if (this.sortableChildren) this.sortDirty = true;\n\n        child.parent = this;\n\n        child.didChange = true;\n        child.didViewUpdate = false;\n\n        // TODO - OPtimise this? could check what the parent has set?\n        child._updateFlags = 0b1111;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.addChild(child);\n        }\n\n        this.emit('childAdded', child, this, this.children.length - 1);\n        child.emit('added', this);\n\n        this._didChangeId += 1 << 12;\n\n        if (child._zIndex !== 0)\n        {\n            child.depthOfChildModified();\n        }\n\n        return child;\n    }\n\n    /**\n     * Removes one or more children from the container.\n     * @param {...Container} children - The Container(s) to remove\n     * @returns {Container} The first child that was removed.\n     */\n    public removeChild<U extends C[]>(...children: U): U[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the arguments property and remove all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n\n            return children[0];\n        }\n\n        const child = children[0];\n\n        const index = this.children.indexOf(child);\n\n        if (index > -1)\n        {\n            this._didChangeId += 1 << 12;\n\n            this.children.splice(index, 1);\n\n            if (this.renderGroup)\n            {\n                this.renderGroup.removeChild(child);\n            }\n            else if (this.parentRenderGroup)\n            {\n                this.parentRenderGroup.removeChild(child);\n            }\n\n            child.parent = null;\n            this.emit('childRemoved', child, this, index);\n            child.emit('removed', this);\n        }\n\n        return child;\n    }\n\n    /** @ignore */\n    public _onUpdate(point?: ObservablePoint)\n    {\n        if (point)\n        {\n            //   this.updateFlags |= UPDATE_TRANSFORM;\n\n            if (point === this._skew)\n            {\n                this._updateSkew();\n            }\n        }\n\n        this._didChangeId++;\n\n        if (this.didChange) return;\n        this.didChange = true;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.onChildUpdate(this);\n        }\n    }\n\n    set isRenderGroup(value: boolean)\n    {\n        if (this.renderGroup && value === false)\n        {\n            throw new Error('[Pixi] cannot undo a render group just yet');\n        }\n\n        if (value)\n        {\n            this.enableRenderGroup();\n        }\n    }\n\n    /**\n     * Returns true if this container is a render group.\n     * This means that it will be rendered as a separate pass, with its own set of instructions\n     */\n    get isRenderGroup(): boolean\n    {\n        return !!this.renderGroup;\n    }\n\n    /** This enables the container to be rendered as a render group. */\n    public enableRenderGroup()\n    {\n        // does it OWN the render group..\n        if (this.renderGroup) return;\n\n        const parentRenderGroup = this.parentRenderGroup;\n\n        if (parentRenderGroup)\n        {\n            parentRenderGroup.removeChild(this);\n        }\n\n        this.renderGroup = new RenderGroup(this);\n\n        if (parentRenderGroup)\n        {\n            parentRenderGroup.addChild(this);\n        }\n\n        this._updateIsSimple();\n\n        // this group matrix will now forever be an identity matrix,\n        // as its own transform will be passed to the GPU\n        this.groupTransform = Matrix.IDENTITY;\n    }\n\n    /** @ignore */\n    public _updateIsSimple()\n    {\n        this.isSimple = !(this.renderGroup) && (this.effects.length === 0);\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors.\n     * @readonly\n     */\n    get worldTransform()\n    {\n        this._worldTransform ||= new Matrix();\n\n        if (this.renderGroup)\n        {\n            this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n        }\n        else if (this.parentRenderGroup)\n        {\n            this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);\n        }\n\n        return this._worldTransform;\n    }\n\n    // / ////// transform related stuff\n\n    /**\n     * The position of the container on the x axis relative to the local coordinates of the parent.\n     * An alias to position.x\n     */\n    get x(): number\n    {\n        return this._position.x;\n    }\n\n    set x(value: number)\n    {\n        this._position.x = value;\n    }\n\n    /**\n     * The position of the container on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     */\n    get y(): number\n    {\n        return this._position.y;\n    }\n\n    set y(value: number)\n    {\n        this._position.y = value;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @since 4.0.0\n     */\n    get position(): ObservablePoint\n    {\n        return this._position;\n    }\n\n    set position(value: PointData)\n    {\n        this._position.copyFrom(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get rotation(): number\n    {\n        return this._rotation;\n    }\n\n    set rotation(value: number)\n    {\n        if (this._rotation !== value)\n        {\n            this._rotation = value;\n            this._onUpdate(this._skew);\n        }\n    }\n\n    /**\n     * The angle of the object in degrees.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get angle(): number\n    {\n        return this.rotation * RAD_TO_DEG;\n    }\n\n    set angle(value: number)\n    {\n        this.rotation = value * DEG_TO_RAD;\n    }\n\n    /**\n     * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n     * is the projection of `pivot` in the parent's local space.\n     *\n     * By default, the pivot is the origin (0, 0).\n     * @since 4.0.0\n     */\n    get pivot(): ObservablePoint\n    {\n        if (this._pivot === defaultPivot)\n        {\n            this._pivot = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._pivot;\n    }\n\n    set pivot(value: PointData | number)\n    {\n        if (this._pivot === defaultPivot)\n        {\n            this._pivot = new ObservablePoint(this, 0, 0);\n        }\n\n        typeof value === 'number' ? this._pivot.set(value) : this._pivot.copyFrom(value);\n    }\n\n    /**\n     * The skew factor for the object in radians.\n     * @since 4.0.0\n     */\n    get skew(): ObservablePoint\n    {\n        if (this._skew === defaultSkew)\n        {\n            this._skew = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._skew;\n    }\n\n    set skew(value: PointData)\n    {\n        if (this._skew === defaultSkew)\n        {\n            this._skew = new ObservablePoint(this, 0, 0);\n        }\n\n        this._skew.copyFrom(value);\n    }\n\n    /**\n     * The scale factors of this object along the local coordinate axes.\n     *\n     * The default scale is (1, 1).\n     * @since 4.0.0\n     */\n    get scale(): ObservablePoint\n    {\n        if (this._scale === defaultScale)\n        {\n            this._scale = new ObservablePoint(this, 1, 1);\n        }\n\n        return this._scale;\n    }\n\n    set scale(value: PointData | number)\n    {\n        if (this._scale === defaultScale)\n        {\n            this._scale = new ObservablePoint(this, 0, 0);\n        }\n\n        typeof value === 'number' ? this._scale.set(value) : this._scale.copyFrom(value);\n    }\n\n    /**\n     * The width of the Container, setting this will actually modify the scale to achieve the value set.\n     * @memberof scene.Container#\n     */\n    get width(): number\n    {\n        return Math.abs(this.scale.x * this.getLocalBounds().width);\n    }\n\n    set width(value: number)\n    {\n        const localWidth = this.getLocalBounds().width;\n\n        this._setWidth(value, localWidth);\n    }\n\n    /**\n     * The height of the Container, setting this will actually modify the scale to achieve the value set.\n     * @memberof scene.Container#\n     */\n    get height(): number\n    {\n        return Math.abs(this.scale.y * this.getLocalBounds().height);\n    }\n\n    set height(value: number)\n    {\n        const localHeight = this.getLocalBounds().height;\n\n        this._setHeight(value, localHeight);\n    }\n\n    /**\n     * Retrieves the size of the container as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the container.\n     * @memberof scene.Container#\n     */\n    public getSize(out?: Size): Size\n    {\n        if (!out)\n        {\n            out = {} as Size;\n        }\n\n        const bounds = this.getLocalBounds();\n\n        out.width = Math.abs(this.scale.x * bounds.width);\n        out.height = Math.abs(this.scale.y * bounds.height);\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the container to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     * @memberof scene.Container#\n     */\n    public setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        const size = this.getLocalBounds();\n        let convertedWidth: number;\n        let convertedHeight: number;\n\n        if (typeof value !== 'object')\n        {\n            convertedWidth = value;\n            convertedHeight = height ?? value;\n        }\n        else\n        {\n            convertedWidth = value.width;\n            convertedHeight = value.height ?? value.width;\n        }\n\n        if (convertedWidth !== undefined)\n        {\n            this._setWidth(convertedWidth, size.width);\n        }\n\n        if (convertedHeight !== undefined)\n        {\n            this._setHeight(convertedHeight, size.height);\n        }\n    }\n\n    /** Called when the skew or the rotation changes. */\n    private _updateSkew(): void\n    {\n        const rotation = this._rotation;\n        const skew = this._skew;\n\n        this._cx = Math.cos(rotation + skew._y);\n        this._sx = Math.sin(rotation + skew._y);\n        this._cy = -Math.sin(rotation - skew._x); // cos, added PI/2\n        this._sy = Math.cos(rotation - skew._x); // sin, added PI/2\n    }\n\n    /**\n     * Updates the transform properties of the container (accepts partial values).\n     * @param {object} opts - The options for updating the transform.\n     * @param {number} opts.x - The x position of the container.\n     * @param {number} opts.y - The y position of the container.\n     * @param {number} opts.scaleX - The scale factor on the x-axis.\n     * @param {number} opts.scaleY - The scale factor on the y-axis.\n     * @param {number} opts.rotation - The rotation of the container, in radians.\n     * @param {number} opts.skewX - The skew factor on the x-axis.\n     * @param {number} opts.skewY - The skew factor on the y-axis.\n     * @param {number} opts.pivotX - The x coordinate of the pivot point.\n     * @param {number} opts.pivotY - The y coordinate of the pivot point.\n     */\n    public updateTransform(opts: Partial<UpdateTransformOptions>): this\n    {\n        this.position.set(\n            typeof opts.x === 'number' ? opts.x : this.position.x,\n            typeof opts.y === 'number' ? opts.y : this.position.y\n        );\n        this.scale.set(\n            typeof opts.scaleX === 'number' ? opts.scaleX || 1 : this.scale.x,\n            typeof opts.scaleY === 'number' ? opts.scaleY || 1 : this.scale.y\n        );\n        this.rotation = typeof opts.rotation === 'number' ? opts.rotation : this.rotation;\n        this.skew.set(\n            typeof opts.skewX === 'number' ? opts.skewX : this.skew.x,\n            typeof opts.skewY === 'number' ? opts.skewY : this.skew.y\n        );\n        this.pivot.set(\n            typeof opts.pivotX === 'number' ? opts.pivotX : this.pivot.x,\n            typeof opts.pivotY === 'number' ? opts.pivotY : this.pivot.y\n        );\n\n        return this;\n    }\n\n    /**\n     * Updates the local transform using the given matrix.\n     * @param matrix - The matrix to use for updating the transform.\n     */\n    public setFromMatrix(matrix: Matrix): void\n    {\n        matrix.decompose(this);\n    }\n\n    /** Updates the local transform. */\n    public updateLocalTransform(): void\n    {\n        if ((this._didLocalTransformChangeId & 0b1111) === this._didChangeId) return;\n\n        this._didLocalTransformChangeId = this._didChangeId;\n        //   this.didChange = false;\n\n        const lt = this.localTransform;\n        const scale = this._scale;\n        const pivot = this._pivot;\n        const position = this._position;\n\n        const sx = scale._x;\n        const sy = scale._y;\n\n        const px = pivot._x;\n        const py = pivot._y;\n\n        // get the matrix values of the container based on its this properties..\n        lt.a = this._cx * sx;\n        lt.b = this._sx * sx;\n        lt.c = this._cy * sy;\n        lt.d = this._sy * sy;\n\n        lt.tx = position._x - ((px * lt.a) + (py * lt.c));\n        lt.ty = position._y - ((px * lt.b) + (py * lt.d));\n    }\n\n    // / ///// color related stuff\n\n    set alpha(value: number)\n    {\n        if (value === this.localAlpha) return;\n\n        this.localAlpha = value;\n\n        this._updateFlags |= UPDATE_COLOR;\n\n        this._onUpdate();\n    }\n\n    /** The opacity of the object. */\n    get alpha(): number\n    {\n        return this.localAlpha;\n    }\n\n    set tint(value: ColorSource)\n    {\n        const tempColor = Color.shared.setValue(value ?? 0xFFFFFF);\n        const bgr = tempColor.toBgrNumber();\n\n        if (bgr === this.localColor) return;\n\n        this.localColor = bgr;\n\n        this._updateFlags |= UPDATE_COLOR;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The tint applied to the sprite. This is a hex value.\n     *\n     * A value of 0xFFFFFF will remove any tint effect.\n     * @default 0xFFFFFF\n     */\n    get tint(): number\n    {\n        const bgr = this.localColor;\n        // convert bgr to rgb..\n\n        return ((bgr & 0xFF) << 16) + (bgr & 0xFF00) + ((bgr >> 16) & 0xFF);\n    }\n\n    // / //////////////// blend related stuff\n\n    set blendMode(value: BLEND_MODES)\n    {\n        if (this.localBlendMode === value) return;\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_BLEND;\n\n        this.localBlendMode = value;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this.localBlendMode;\n    }\n\n    // / ///////// VISIBILITY / RENDERABLE /////////////////\n\n    /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */\n    get visible()\n    {\n        return !!(this.localDisplayStatus & 0b010);\n    }\n\n    set visible(value: boolean)\n    {\n        const valueNumber = value ? 1 : 0;\n\n        if ((this.localDisplayStatus & 0b010) >> 1 === valueNumber) return;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_VISIBLE;\n\n        this.localDisplayStatus ^= 0b010;\n\n        this._onUpdate();\n    }\n\n    /** @ignore */\n    get culled()\n    {\n        return !(this.localDisplayStatus & 0b100);\n    }\n\n    /** @ignore */\n    set culled(value: boolean)\n    {\n        const valueNumber = value ? 1 : 0;\n\n        if ((this.localDisplayStatus & 0b100) >> 2 === valueNumber) return;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_VISIBLE;\n        this.localDisplayStatus ^= 0b100;\n\n        this._onUpdate();\n    }\n\n    /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */\n    get renderable()\n    {\n        return !!(this.localDisplayStatus & 0b001);\n    }\n\n    set renderable(value: boolean)\n    {\n        const valueNumber = value ? 1 : 0;\n\n        if ((this.localDisplayStatus & 0b001) === valueNumber) return;\n\n        this._updateFlags |= UPDATE_VISIBLE;\n        this.localDisplayStatus ^= 0b001;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._onUpdate();\n    }\n\n    /** Whether or not the object should be rendered. */\n    get isRenderable(): boolean\n    {\n        return (this.localDisplayStatus === 0b111 && this.groupAlpha > 0);\n    }\n\n    /**\n     * Removes all internal references and listeners as well as removes children from the display list.\n     * Do not use a Container after calling `destroy`.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *  method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n     * is set to true it should destroy the texture of the child sprite\n     * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n     * If options.children is set to true it should destroy the texture source of the child sprite\n     * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n     * If options.children is set to true it should destroy the context of the child graphics\n     */\n    public destroy(options: DestroyOptions = false): void\n    {\n        if (this.destroyed) return;\n        this.destroyed = true;\n\n        // remove children is faster than removeChild..\n        const oldChildren = this.removeChildren(0, this.children.length);\n\n        this.removeFromParent();\n        this.parent = null;\n        this._maskEffect = null;\n        this._filterEffect = null;\n        this.effects = null;\n        this._position = null;\n        this._scale = null;\n        this._pivot = null;\n        this._skew = null;\n\n        this.emit('destroyed', this);\n\n        this.removeAllListeners();\n\n        const destroyChildren = typeof options === 'boolean' ? options : options?.children;\n\n        if (destroyChildren)\n        {\n            for (let i = 0; i < oldChildren.length; ++i)\n            {\n                oldChildren[i].destroy(options);\n            }\n        }\n    }\n}\n\nContainer.mixin(childrenHelperMixin);\nContainer.mixin(toLocalGlobalMixin);\nContainer.mixin(onRenderMixin);\nContainer.mixin(measureMixin);\nContainer.mixin(effectsMixin);\nContainer.mixin(findMixin);\nContainer.mixin(sortMixin);\nContainer.mixin(cullingMixin);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}