{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nconst {\n  FilterBy\n} = require('./filterBy');\nconst {\n  ConsoleLogEntry,\n  JavascriptLogEntry,\n  GenericLogEntry\n} = require('./logEntries');\nconst LOG = {\n  TYPE_CONSOLE: 'console',\n  TYPE_JS_LOGS: 'javascript'\n};\nclass LogInspector {\n  bidi;\n  ws;\n  constructor(driver, browsingContextIds) {\n    this._driver = driver;\n    this._browsingContextIds = browsingContextIds;\n    this.listener = {};\n  }\n\n  /**\n   * Subscribe to log event\n   * @returns {Promise<void>}\n   */\n  async init() {\n    this.bidi = await this._driver.getBidi();\n    await this.bidi.subscribe('log.entryAdded', this._browsingContextIds);\n  }\n\n  /**\n   * @param kind\n   */\n  logListener(kind) {\n    if (!(kind in this.listener)) {\n      this.listener[kind] = [];\n    }\n  }\n\n  /**\n   * Listen to Console logs\n   * @param callback\n   * @param filterBy\n   * @returns {Promise<void>}\n   */\n  async onConsoleEntry(callback, filterBy = undefined) {\n    if (filterBy !== undefined && !(filterBy instanceof FilterBy)) {\n      throw Error(`Pass valid FilterBy object. Received: ${filterBy}`);\n    }\n    this.ws = await this.bidi.socket;\n    this.ws.on('message', event => {\n      const {\n        params\n      } = JSON.parse(Buffer.from(event.toString()));\n      if (params?.type === LOG.TYPE_CONSOLE) {\n        let consoleEntry = new ConsoleLogEntry(params.level, params.text, params.timestamp, params.type, params.method, params.realm, params.args, params.stackTrace);\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            callback(consoleEntry);\n          }\n          return;\n        }\n        callback(consoleEntry);\n      }\n    });\n  }\n\n  /**\n   * Listen to JS logs\n   * @param callback\n   * @param filterBy\n   * @returns {Promise<void>}\n   */\n  async onJavascriptLog(callback, filterBy = undefined) {\n    if (filterBy !== undefined && !(filterBy instanceof FilterBy)) {\n      throw Error(`Pass valid FilterBy object. Received: ${filterBy}`);\n    }\n    this.ws = await this.bidi.socket;\n    this.ws.on('message', event => {\n      const {\n        params\n      } = JSON.parse(Buffer.from(event.toString()));\n      if (params?.type === LOG.TYPE_JS_LOGS) {\n        let jsEntry = new JavascriptLogEntry(params.level, params.text, params.timestamp, params.type, params.stackTrace);\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            callback(jsEntry);\n          }\n          return;\n        }\n        callback(jsEntry);\n      }\n    });\n  }\n\n  /**\n   * Listen to JS Exceptions\n   * @param callback\n   * @returns {Promise<void>}\n   */\n  async onJavascriptException(callback) {\n    this.ws = await this.bidi.socket;\n    let enabled = LOG.TYPE_JS_EXCEPTION in this.listener || this.logListener(LOG.TYPE_JS_EXCEPTION);\n    this.listener[LOG.TYPE_JS_EXCEPTION].push(callback);\n    if (enabled) {\n      return;\n    }\n    this.ws.on('message', event => {\n      const {\n        params\n      } = JSON.parse(Buffer.from(event.toString()));\n      if (params?.type === 'javascript' && params?.level === 'error') {\n        let jsErrorEntry = new JavascriptLogEntry(params.level, params.text, params.timestamp, params.type, params.stackTrace);\n        this.listener[LOG.TYPE_JS_EXCEPTION].forEach(listener => {\n          listener(jsErrorEntry);\n        });\n      }\n    });\n  }\n\n  /**\n   * Listen to any logs\n   * @param callback\n   * @param filterBy\n   * @returns {Promise<void>}\n   */\n  async onLog(callback, filterBy = undefined) {\n    if (filterBy !== undefined && !(filterBy instanceof FilterBy)) {\n      throw Error(`Pass valid FilterBy object. Received: ${filterBy}`);\n    }\n    this.ws = await this.bidi.socket;\n    this.ws.on('message', event => {\n      const {\n        params\n      } = JSON.parse(Buffer.from(event.toString()));\n      if (params?.type === 'javascript') {\n        let jsEntry = new JavascriptLogEntry(params.level, params.text, params.timestamp, params.type, params.stackTrace);\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            callback(jsEntry);\n          }\n          return;\n        }\n        callback(jsEntry);\n        return;\n      }\n      if (params?.type === 'console') {\n        let consoleEntry = new ConsoleLogEntry(params.level, params.text, params.timestamp, params.type, params.method, params.realm, params.args, params.stackTrace);\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            callback(consoleEntry);\n          }\n          return;\n        }\n        callback(consoleEntry);\n        return;\n      }\n      if (params !== undefined && !['console', 'javascript'].includes(params?.type)) {\n        let genericEntry = new GenericLogEntry(params.level, params.text, params.timestamp, params.type, params.stackTrace);\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            callback(genericEntry);\n          }\n          return;\n        }\n        callback(genericEntry);\n      }\n    });\n  }\n\n  /**\n   * Unsubscribe to log event\n   * @returns {Promise<void>}\n   */\n  async close() {\n    await this.bidi.unsubscribe('log.entryAdded', this._browsingContextIds);\n  }\n}\n\n/**\n * initiate inspector instance and return\n * @param driver\n * @param browsingContextIds\n * @returns {Promise<LogInspector>}\n */\nasync function getLogInspectorInstance(driver, browsingContextIds) {\n  let instance = new LogInspector(driver, browsingContextIds);\n  await instance.init();\n  return instance;\n}\n\n/**\n * API\n * @type {function(*, *): Promise<LogInspector>}\n */\nmodule.exports = getLogInspectorInstance;","map":{"version":3,"names":["FilterBy","require","ConsoleLogEntry","JavascriptLogEntry","GenericLogEntry","LOG","TYPE_CONSOLE","TYPE_JS_LOGS","LogInspector","bidi","ws","constructor","driver","browsingContextIds","_driver","_browsingContextIds","listener","init","getBidi","subscribe","logListener","kind","onConsoleEntry","callback","filterBy","undefined","Error","socket","on","event","params","JSON","parse","Buffer","from","toString","type","consoleEntry","level","text","timestamp","method","realm","args","stackTrace","getLevel","onJavascriptLog","jsEntry","onJavascriptException","enabled","TYPE_JS_EXCEPTION","push","jsErrorEntry","forEach","onLog","includes","genericEntry","close","unsubscribe","getLogInspectorInstance","instance","module","exports"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/selenium-webdriver/bidi/logInspector.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nconst { FilterBy } = require('./filterBy')\nconst { ConsoleLogEntry, JavascriptLogEntry, GenericLogEntry } = require('./logEntries')\n\nconst LOG = {\n  TYPE_CONSOLE: 'console',\n  TYPE_JS_LOGS: 'javascript',\n}\n\nclass LogInspector {\n  bidi\n  ws\n\n  constructor(driver, browsingContextIds) {\n    this._driver = driver\n    this._browsingContextIds = browsingContextIds\n    this.listener = {}\n  }\n\n  /**\n   * Subscribe to log event\n   * @returns {Promise<void>}\n   */\n  async init() {\n    this.bidi = await this._driver.getBidi()\n    await this.bidi.subscribe('log.entryAdded', this._browsingContextIds)\n  }\n\n  /**\n   * @param kind\n   */\n  logListener(kind) {\n    if (!(kind in this.listener)) {\n      this.listener[kind] = []\n    }\n  }\n\n  /**\n   * Listen to Console logs\n   * @param callback\n   * @param filterBy\n   * @returns {Promise<void>}\n   */\n  async onConsoleEntry(callback, filterBy = undefined) {\n    if (filterBy !== undefined && !(filterBy instanceof FilterBy)) {\n      throw Error(`Pass valid FilterBy object. Received: ${filterBy}`)\n    }\n\n    this.ws = await this.bidi.socket\n\n    this.ws.on('message', (event) => {\n      const { params } = JSON.parse(Buffer.from(event.toString()))\n\n      if (params?.type === LOG.TYPE_CONSOLE) {\n        let consoleEntry = new ConsoleLogEntry(\n          params.level,\n          params.text,\n          params.timestamp,\n          params.type,\n          params.method,\n          params.realm,\n          params.args,\n          params.stackTrace,\n        )\n\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            callback(consoleEntry)\n          }\n          return\n        }\n\n        callback(consoleEntry)\n      }\n    })\n  }\n\n  /**\n   * Listen to JS logs\n   * @param callback\n   * @param filterBy\n   * @returns {Promise<void>}\n   */\n  async onJavascriptLog(callback, filterBy = undefined) {\n    if (filterBy !== undefined && !(filterBy instanceof FilterBy)) {\n      throw Error(`Pass valid FilterBy object. Received: ${filterBy}`)\n    }\n\n    this.ws = await this.bidi.socket\n\n    this.ws.on('message', (event) => {\n      const { params } = JSON.parse(Buffer.from(event.toString()))\n\n      if (params?.type === LOG.TYPE_JS_LOGS) {\n        let jsEntry = new JavascriptLogEntry(\n          params.level,\n          params.text,\n          params.timestamp,\n          params.type,\n          params.stackTrace,\n        )\n\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            callback(jsEntry)\n          }\n          return\n        }\n\n        callback(jsEntry)\n      }\n    })\n  }\n\n  /**\n   * Listen to JS Exceptions\n   * @param callback\n   * @returns {Promise<void>}\n   */\n  async onJavascriptException(callback) {\n    this.ws = await this.bidi.socket\n    let enabled = LOG.TYPE_JS_EXCEPTION in this.listener || this.logListener(LOG.TYPE_JS_EXCEPTION)\n    this.listener[LOG.TYPE_JS_EXCEPTION].push(callback)\n\n    if (enabled) {\n      return\n    }\n\n    this.ws.on('message', (event) => {\n      const { params } = JSON.parse(Buffer.from(event.toString()))\n      if (params?.type === 'javascript' && params?.level === 'error') {\n        let jsErrorEntry = new JavascriptLogEntry(\n          params.level,\n          params.text,\n          params.timestamp,\n          params.type,\n          params.stackTrace,\n        )\n\n        this.listener[LOG.TYPE_JS_EXCEPTION].forEach((listener) => {\n          listener(jsErrorEntry)\n        })\n      }\n    })\n  }\n\n  /**\n   * Listen to any logs\n   * @param callback\n   * @param filterBy\n   * @returns {Promise<void>}\n   */\n  async onLog(callback, filterBy = undefined) {\n    if (filterBy !== undefined && !(filterBy instanceof FilterBy)) {\n      throw Error(`Pass valid FilterBy object. Received: ${filterBy}`)\n    }\n\n    this.ws = await this.bidi.socket\n\n    this.ws.on('message', (event) => {\n      const { params } = JSON.parse(Buffer.from(event.toString()))\n      if (params?.type === 'javascript') {\n        let jsEntry = new JavascriptLogEntry(\n          params.level,\n          params.text,\n          params.timestamp,\n          params.type,\n          params.stackTrace,\n        )\n\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            callback(jsEntry)\n          }\n          return\n        }\n\n        callback(jsEntry)\n        return\n      }\n\n      if (params?.type === 'console') {\n        let consoleEntry = new ConsoleLogEntry(\n          params.level,\n          params.text,\n          params.timestamp,\n          params.type,\n          params.method,\n          params.realm,\n          params.args,\n          params.stackTrace,\n        )\n\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            callback(consoleEntry)\n          }\n          return\n        }\n\n        callback(consoleEntry)\n        return\n      }\n\n      if (params !== undefined && !['console', 'javascript'].includes(params?.type)) {\n        let genericEntry = new GenericLogEntry(\n          params.level,\n          params.text,\n          params.timestamp,\n          params.type,\n          params.stackTrace,\n        )\n\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            callback(genericEntry)\n          }\n          return\n        }\n\n        callback(genericEntry)\n      }\n    })\n  }\n\n  /**\n   * Unsubscribe to log event\n   * @returns {Promise<void>}\n   */\n  async close() {\n    await this.bidi.unsubscribe('log.entryAdded', this._browsingContextIds)\n  }\n}\n\n/**\n * initiate inspector instance and return\n * @param driver\n * @param browsingContextIds\n * @returns {Promise<LogInspector>}\n */\nasync function getLogInspectorInstance(driver, browsingContextIds) {\n  let instance = new LogInspector(driver, browsingContextIds)\n  await instance.init()\n  return instance\n}\n\n/**\n * API\n * @type {function(*, *): Promise<LogInspector>}\n */\nmodule.exports = getLogInspectorInstance\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}