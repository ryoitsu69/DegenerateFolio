{"ast":null,"code":"import { AbstractBase } from '@polkadot/types-codec';\nimport { u8aToHex } from '@polkadot/util';\nimport { DEFAULT_VERSION } from './constants.js';\nconst VERSIONS = ['ExtrinsicPayloadUnknown',\n// v0 is unknown\n'ExtrinsicPayloadUnknown', 'ExtrinsicPayloadUnknown', 'ExtrinsicPayloadUnknown', 'ExtrinsicPayloadV4'];\n/** @internal */\nfunction decodeExtrinsicPayload(registry, value) {\n  let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_VERSION;\n  if (value instanceof GenericExtrinsicPayload) {\n    return value.unwrap();\n  }\n  return registry.createTypeUnsafe(VERSIONS[version] || VERSIONS[0], [value, {\n    version\n  }]);\n}\n/**\n * @name GenericExtrinsicPayload\n * @description\n * A signing payload for an [[Extrinsic]]. For the final encoding, it is variable length based\n * on the contents included\n */\nexport class GenericExtrinsicPayload extends AbstractBase {\n  constructor(registry, value) {\n    let {\n      version\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(registry, decodeExtrinsicPayload(registry, value, version));\n  }\n  /**\n   * @description The block [[BlockHash]] the signature applies to (mortal/immortal)\n   */\n  get blockHash() {\n    return this.inner.blockHash;\n  }\n  /**\n   * @description The [[ExtrinsicEra]]\n   */\n  get era() {\n    return this.inner.era;\n  }\n  /**\n   * @description The genesis block [[BlockHash]] the signature applies to\n   */\n  get genesisHash() {\n    // NOTE only v3+\n    return this.inner.genesisHash || this.registry.createTypeUnsafe('Hash', []);\n  }\n  /**\n   * @description The [[Bytes]] contained in the payload\n   */\n  get method() {\n    return this.inner.method;\n  }\n  /**\n   * @description The [[Index]]\n   */\n  get nonce() {\n    return this.inner.nonce;\n  }\n  /**\n   * @description The specVersion as a [[u32]] for this payload\n   */\n  get specVersion() {\n    // NOTE only v3+\n    return this.inner.specVersion || this.registry.createTypeUnsafe('u32', []);\n  }\n  /**\n   * @description The [[Balance]]\n   */\n  get tip() {\n    // NOTE from v2+\n    return this.inner.tip || this.registry.createTypeUnsafe('Compact<Balance>', []);\n  }\n  /**\n   * @description The transaction version as a [[u32]] for this payload\n   */\n  get transactionVersion() {\n    // NOTE only v4+\n    return this.inner.transactionVersion || this.registry.createTypeUnsafe('u32', []);\n  }\n  /**\n   * @description The (optional) asset id as a [[u32]] or [[MultiLocation]] for this payload\n   */\n  get assetId() {\n    return this.inner.assetId;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return this.inner.eq(other);\n  }\n  /**\n   * @description Sign the payload with the keypair\n   */\n  sign(signerPair) {\n    const signature = this.inner.sign(signerPair);\n    // This is extensible, so we could quite readily extend to send back extra\n    // information, such as for instance the payload, i.e. `payload: this.toHex()`\n    // For the case here we sign via the extrinsic, we ignore the return, so generally\n    // this is applicable for external signing\n    return {\n      signature: u8aToHex(signature)\n    };\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExtended, disableAscii) {\n    return this.inner.toHuman(isExtended, disableAscii);\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'ExtrinsicPayload';\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return this.toHex();\n  }\n  /**\n   * @description Returns a serialized u8a form\n   */\n  toU8a(isBare) {\n    // call our parent, with only the method stripped\n    return super.toU8a(isBare ? {\n      method: true\n    } : false);\n  }\n}","map":{"version":3,"names":["AbstractBase","u8aToHex","DEFAULT_VERSION","VERSIONS","decodeExtrinsicPayload","registry","value","version","arguments","length","undefined","GenericExtrinsicPayload","unwrap","createTypeUnsafe","constructor","blockHash","inner","era","genesisHash","method","nonce","specVersion","tip","transactionVersion","assetId","eq","other","sign","signerPair","signature","toHuman","isExtended","disableAscii","toJSON","toHex","toRawType","toString","toU8a","isBare"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/extrinsic/ExtrinsicPayload.js"],"sourcesContent":["import { AbstractBase } from '@polkadot/types-codec';\nimport { u8aToHex } from '@polkadot/util';\nimport { DEFAULT_VERSION } from './constants.js';\nconst VERSIONS = [\n    'ExtrinsicPayloadUnknown', // v0 is unknown\n    'ExtrinsicPayloadUnknown',\n    'ExtrinsicPayloadUnknown',\n    'ExtrinsicPayloadUnknown',\n    'ExtrinsicPayloadV4'\n];\n/** @internal */\nfunction decodeExtrinsicPayload(registry, value, version = DEFAULT_VERSION) {\n    if (value instanceof GenericExtrinsicPayload) {\n        return value.unwrap();\n    }\n    return registry.createTypeUnsafe(VERSIONS[version] || VERSIONS[0], [value, { version }]);\n}\n/**\n * @name GenericExtrinsicPayload\n * @description\n * A signing payload for an [[Extrinsic]]. For the final encoding, it is variable length based\n * on the contents included\n */\nexport class GenericExtrinsicPayload extends AbstractBase {\n    constructor(registry, value, { version } = {}) {\n        super(registry, decodeExtrinsicPayload(registry, value, version));\n    }\n    /**\n     * @description The block [[BlockHash]] the signature applies to (mortal/immortal)\n     */\n    get blockHash() {\n        return this.inner.blockHash;\n    }\n    /**\n     * @description The [[ExtrinsicEra]]\n     */\n    get era() {\n        return this.inner.era;\n    }\n    /**\n     * @description The genesis block [[BlockHash]] the signature applies to\n     */\n    get genesisHash() {\n        // NOTE only v3+\n        return this.inner.genesisHash || this.registry.createTypeUnsafe('Hash', []);\n    }\n    /**\n     * @description The [[Bytes]] contained in the payload\n     */\n    get method() {\n        return this.inner.method;\n    }\n    /**\n     * @description The [[Index]]\n     */\n    get nonce() {\n        return this.inner.nonce;\n    }\n    /**\n     * @description The specVersion as a [[u32]] for this payload\n     */\n    get specVersion() {\n        // NOTE only v3+\n        return this.inner.specVersion || this.registry.createTypeUnsafe('u32', []);\n    }\n    /**\n     * @description The [[Balance]]\n     */\n    get tip() {\n        // NOTE from v2+\n        return this.inner.tip || this.registry.createTypeUnsafe('Compact<Balance>', []);\n    }\n    /**\n     * @description The transaction version as a [[u32]] for this payload\n     */\n    get transactionVersion() {\n        // NOTE only v4+\n        return this.inner.transactionVersion || this.registry.createTypeUnsafe('u32', []);\n    }\n    /**\n     * @description The (optional) asset id as a [[u32]] or [[MultiLocation]] for this payload\n     */\n    get assetId() {\n        return this.inner.assetId;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return this.inner.eq(other);\n    }\n    /**\n     * @description Sign the payload with the keypair\n     */\n    sign(signerPair) {\n        const signature = this.inner.sign(signerPair);\n        // This is extensible, so we could quite readily extend to send back extra\n        // information, such as for instance the payload, i.e. `payload: this.toHex()`\n        // For the case here we sign via the extrinsic, we ignore the return, so generally\n        // this is applicable for external signing\n        return {\n            signature: u8aToHex(signature)\n        };\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExtended, disableAscii) {\n        return this.inner.toHuman(isExtended, disableAscii);\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return this.toHex();\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'ExtrinsicPayload';\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return this.toHex();\n    }\n    /**\n     * @description Returns a serialized u8a form\n     */\n    toU8a(isBare) {\n        // call our parent, with only the method stripped\n        return super.toU8a(isBare ? { method: true } : false);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}