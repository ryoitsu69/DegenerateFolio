{"ast":null,"code":"import { stringToU8a, u8aToU8a } from '@polkadot/util';\nimport { pbkdf2Encode } from '../pbkdf2/index.js';\nimport { randomAsU8a } from '../random/index.js';\nimport { sha256AsU8a } from '../sha/index.js';\nimport DEFAULT_WORDLIST from './wordlists/en.js';\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\n/** @internal */\nfunction normalize(str) {\n  return (str || '').normalize('NFKD');\n}\n/** @internal */\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\n/** @internal */\nfunction bytesToBinary(bytes) {\n  return bytes.map(x => x.toString(2).padStart(8, '0')).join('');\n}\n/** @internal */\nfunction deriveChecksumBits(entropyBuffer) {\n  return bytesToBinary(Array.from(sha256AsU8a(entropyBuffer))).slice(0, entropyBuffer.length * 8 / 32);\n}\nexport function mnemonicToSeedSync(mnemonic, password) {\n  return pbkdf2Encode(stringToU8a(normalize(mnemonic)), stringToU8a(\"mnemonic\".concat(normalize(password)))).password;\n}\nexport function mnemonicToEntropy(mnemonic) {\n  let wordlist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_WORDLIST;\n  const words = normalize(mnemonic).split(' ');\n  if (words.length % 3 !== 0) {\n    throw new Error(INVALID_MNEMONIC);\n  }\n  // convert word indices to 11 bit binary strings\n  const bits = words.map(word => {\n    const index = wordlist.indexOf(word);\n    if (index === -1) {\n      throw new Error(INVALID_MNEMONIC);\n    }\n    return index.toString(2).padStart(11, '0');\n  }).join('');\n  // split the binary string into ENT/CS\n  const dividerIndex = Math.floor(bits.length / 33) * 32;\n  const entropyBits = bits.slice(0, dividerIndex);\n  const checksumBits = bits.slice(dividerIndex);\n  // calculate the checksum and compare\n  const matched = entropyBits.match(/(.{1,8})/g);\n  const entropyBytes = matched === null || matched === void 0 ? void 0 : matched.map(binaryToByte);\n  if (!entropyBytes || entropyBytes.length % 4 !== 0 || entropyBytes.length < 16 || entropyBytes.length > 32) {\n    throw new Error(INVALID_ENTROPY);\n  }\n  const entropy = u8aToU8a(entropyBytes);\n  if (deriveChecksumBits(entropy) !== checksumBits) {\n    throw new Error(INVALID_CHECKSUM);\n  }\n  return entropy;\n}\nexport function entropyToMnemonic(entropy) {\n  let wordlist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_WORDLIST;\n  // 128 <= ENT <= 256\n  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {\n    throw new Error(INVALID_ENTROPY);\n  }\n  const matched = \"\".concat(bytesToBinary(Array.from(entropy))).concat(deriveChecksumBits(entropy)).match(/(.{1,11})/g);\n  const mapped = matched === null || matched === void 0 ? void 0 : matched.map(b => wordlist[binaryToByte(b)]);\n  if (!mapped || mapped.length < 12) {\n    throw new Error('Unable to map entropy to mnemonic');\n  }\n  return mapped.join(' ');\n}\nexport function generateMnemonic(numWords, wordlist) {\n  return entropyToMnemonic(randomAsU8a(numWords / 3 * 4), wordlist);\n}\nexport function validateMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n  } catch {\n    return false;\n  }\n  return true;\n}","map":{"version":3,"names":["stringToU8a","u8aToU8a","pbkdf2Encode","randomAsU8a","sha256AsU8a","DEFAULT_WORDLIST","INVALID_MNEMONIC","INVALID_ENTROPY","INVALID_CHECKSUM","normalize","str","binaryToByte","bin","parseInt","bytesToBinary","bytes","map","x","toString","padStart","join","deriveChecksumBits","entropyBuffer","Array","from","slice","length","mnemonicToSeedSync","mnemonic","password","concat","mnemonicToEntropy","wordlist","arguments","undefined","words","split","Error","bits","word","index","indexOf","dividerIndex","Math","floor","entropyBits","checksumBits","matched","match","entropyBytes","entropy","entropyToMnemonic","mapped","b","generateMnemonic","numWords","validateMnemonic"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util-crypto/mnemonic/bip39.js"],"sourcesContent":["import { stringToU8a, u8aToU8a } from '@polkadot/util';\nimport { pbkdf2Encode } from '../pbkdf2/index.js';\nimport { randomAsU8a } from '../random/index.js';\nimport { sha256AsU8a } from '../sha/index.js';\nimport DEFAULT_WORDLIST from './wordlists/en.js';\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\n/** @internal */\nfunction normalize(str) {\n    return (str || '').normalize('NFKD');\n}\n/** @internal */\nfunction binaryToByte(bin) {\n    return parseInt(bin, 2);\n}\n/** @internal */\nfunction bytesToBinary(bytes) {\n    return bytes.map((x) => x.toString(2).padStart(8, '0')).join('');\n}\n/** @internal */\nfunction deriveChecksumBits(entropyBuffer) {\n    return bytesToBinary(Array.from(sha256AsU8a(entropyBuffer))).slice(0, (entropyBuffer.length * 8) / 32);\n}\nexport function mnemonicToSeedSync(mnemonic, password) {\n    return pbkdf2Encode(stringToU8a(normalize(mnemonic)), stringToU8a(`mnemonic${normalize(password)}`)).password;\n}\nexport function mnemonicToEntropy(mnemonic, wordlist = DEFAULT_WORDLIST) {\n    const words = normalize(mnemonic).split(' ');\n    if (words.length % 3 !== 0) {\n        throw new Error(INVALID_MNEMONIC);\n    }\n    // convert word indices to 11 bit binary strings\n    const bits = words\n        .map((word) => {\n        const index = wordlist.indexOf(word);\n        if (index === -1) {\n            throw new Error(INVALID_MNEMONIC);\n        }\n        return index.toString(2).padStart(11, '0');\n    })\n        .join('');\n    // split the binary string into ENT/CS\n    const dividerIndex = Math.floor(bits.length / 33) * 32;\n    const entropyBits = bits.slice(0, dividerIndex);\n    const checksumBits = bits.slice(dividerIndex);\n    // calculate the checksum and compare\n    const matched = entropyBits.match(/(.{1,8})/g);\n    const entropyBytes = matched?.map(binaryToByte);\n    if (!entropyBytes || (entropyBytes.length % 4 !== 0) || (entropyBytes.length < 16) || (entropyBytes.length > 32)) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    const entropy = u8aToU8a(entropyBytes);\n    if (deriveChecksumBits(entropy) !== checksumBits) {\n        throw new Error(INVALID_CHECKSUM);\n    }\n    return entropy;\n}\nexport function entropyToMnemonic(entropy, wordlist = DEFAULT_WORDLIST) {\n    // 128 <= ENT <= 256\n    if ((entropy.length % 4 !== 0) || (entropy.length < 16) || (entropy.length > 32)) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    const matched = `${bytesToBinary(Array.from(entropy))}${deriveChecksumBits(entropy)}`.match(/(.{1,11})/g);\n    const mapped = matched?.map((b) => wordlist[binaryToByte(b)]);\n    if (!mapped || (mapped.length < 12)) {\n        throw new Error('Unable to map entropy to mnemonic');\n    }\n    return mapped.join(' ');\n}\nexport function generateMnemonic(numWords, wordlist) {\n    return entropyToMnemonic(randomAsU8a((numWords / 3) * 4), wordlist);\n}\nexport function validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch {\n        return false;\n    }\n    return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}