{"ast":null,"code":"import { Cache } from '../../assets/cache/Cache.mjs';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { Transform } from '../../utils/misc/Transform.mjs';\nimport { Container } from '../container/Container.mjs';\n\"use strict\";\nconst _TilingSprite = class _TilingSprite extends Container {\n  constructor(...args) {\n    let options = args[0] || {};\n    if (options instanceof Texture) {\n      options = {\n        texture: options\n      };\n    }\n    if (args.length > 1) {\n      deprecation(v8_0_0, \"use new TilingSprite({ texture, width:100, height:100 }) instead\");\n      options.width = args[1];\n      options.height = args[2];\n    }\n    options = {\n      ..._TilingSprite.defaultOptions,\n      ...options\n    };\n    const {\n      texture,\n      anchor,\n      tilePosition,\n      tileScale,\n      tileRotation,\n      width,\n      height,\n      applyAnchorToTexture,\n      roundPixels,\n      ...rest\n    } = options ?? {};\n    super({\n      label: \"TilingSprite\",\n      ...rest\n    });\n    this.renderPipeId = \"tilingSprite\";\n    this.canBundle = true;\n    this.batched = true;\n    this._roundPixels = 0;\n    this._bounds = {\n      minX: 0,\n      maxX: 1,\n      minY: 0,\n      maxY: 0\n    };\n    this._boundsDirty = true;\n    this.allowChildren = false;\n    this._anchor = new ObservablePoint({\n      _onUpdate: () => {\n        this.onViewUpdate();\n      }\n    });\n    this._applyAnchorToTexture = applyAnchorToTexture;\n    this.texture = texture;\n    this._width = width ?? texture.width;\n    this._height = height ?? texture.height;\n    this._tileTransform = new Transform({\n      observer: {\n        _onUpdate: () => this.onViewUpdate()\n      }\n    });\n    if (anchor) this.anchor = anchor;\n    this.tilePosition = tilePosition;\n    this.tileScale = tileScale;\n    this.tileRotation = tileRotation;\n    this.roundPixels = roundPixels ?? false;\n  }\n  /**\n   * Creates a new tiling sprite.\n   * @param source - The source to create the texture from.\n   * @param options - The options for creating the tiling sprite.\n   * @returns A new tiling sprite.\n   */\n  static from(source, options = {}) {\n    if (typeof source === \"string\") {\n      return new _TilingSprite({\n        texture: Cache.get(source),\n        ...options\n      });\n    }\n    return new _TilingSprite({\n      texture: source,\n      ...options\n    });\n  }\n  /**\n   * Changes frame clamping in corresponding textureMatrix\n   * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n   * @default 0.5\n   * @member {number}\n   */\n  get clampMargin() {\n    return this._texture.textureMatrix.clampMargin;\n  }\n  set clampMargin(value) {\n    this._texture.textureMatrix.clampMargin = value;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { TilingSprite } from 'pixi.js';\n   *\n   * const sprite = new TilingSprite({texture: Texture.WHITE});\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /** The offset of the image that is being tiled. */\n  get tilePosition() {\n    return this._tileTransform.position;\n  }\n  set tilePosition(value) {\n    this._tileTransform.position.copyFrom(value);\n  }\n  /** The scaling of the image that is being tiled. */\n  get tileScale() {\n    return this._tileTransform.scale;\n  }\n  set tileScale(value) {\n    typeof value === \"number\" ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);\n  }\n  set tileRotation(value) {\n    this._tileTransform.rotation = value;\n  }\n  /** The rotation of the image that is being tiled. */\n  get tileRotation() {\n    return this._tileTransform.rotation;\n  }\n  /** The transform of the image that is being tiled. */\n  get tileTransform() {\n    return this._tileTransform;\n  }\n  /**\n   *  Whether or not to round the x/y position of the sprite.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  /**\n   * The local bounds of the sprite.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    if (this._boundsDirty) {\n      this._updateBounds();\n      this._boundsDirty = false;\n    }\n    return this._bounds;\n  }\n  set texture(value) {\n    value || (value = Texture.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value) return;\n    if (currentTexture && currentTexture.dynamic) currentTexture.off(\"update\", this.onViewUpdate, this);\n    if (value.dynamic) value.on(\"update\", this.onViewUpdate, this);\n    this._texture = value;\n    this.onViewUpdate();\n  }\n  /** The texture that the sprite is using. */\n  get texture() {\n    return this._texture;\n  }\n  /** The width of the tiling area. */\n  set width(value) {\n    this._width = value;\n    this.onViewUpdate();\n  }\n  get width() {\n    return this._width;\n  }\n  set height(value) {\n    this._height = value;\n    this.onViewUpdate();\n  }\n  /** The height of the tiling area. */\n  get height() {\n    return this._height;\n  }\n  _updateBounds() {\n    const bounds = this._bounds;\n    const anchor = this._anchor;\n    const width = this._width;\n    const height = this._height;\n    bounds.maxX = -anchor._x * width;\n    bounds.minX = bounds.maxX + width;\n    bounds.maxY = -anchor._y * height;\n    bounds.minY = bounds.maxY + height;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    const _bounds = this.bounds;\n    bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const width = this.bounds.minX;\n    const height = this.bounds.minY;\n    const x1 = -width * this._anchor._x;\n    let y1 = 0;\n    if (point.x >= x1 && point.x <= x1 + width) {\n      y1 = -height * this._anchor._y;\n      if (point.y >= y1 && point.y <= y1 + height) return true;\n    }\n    return false;\n  }\n  onViewUpdate() {\n    this._boundsDirty = true;\n    this._didTilingSpriteUpdate = true;\n    this._didChangeId += 1 << 12;\n    if (this.didViewUpdate) return;\n    this.didViewUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    this._anchor = null;\n    this._tileTransform = null;\n    this._bounds = null;\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n  }\n};\n/** default options for the TilingSprite */\n_TilingSprite.defaultOptions = {\n  /** The texture to use for the sprite. */\n  texture: Texture.EMPTY,\n  /** The anchor point of the sprite */\n  anchor: {\n    x: 0,\n    y: 0\n  },\n  /** The offset of the image that is being tiled. */\n  tilePosition: {\n    x: 0,\n    y: 0\n  },\n  /** Scaling of the image that is being tiled. */\n  tileScale: {\n    x: 1,\n    y: 1\n  },\n  /** The rotation of the image that is being tiled. */\n  tileRotation: 0,\n  /** TODO */\n  applyAnchorToTexture: false\n};\nlet TilingSprite = _TilingSprite;\nexport { TilingSprite };","map":{"version":3,"names":["_TilingSprite","Container","constructor","args","options","Texture","texture","length","deprecation","v8_0_0","width","height","defaultOptions","anchor","tilePosition","tileScale","tileRotation","applyAnchorToTexture","roundPixels","rest","label","renderPipeId","canBundle","batched","_roundPixels","_bounds","minX","maxX","minY","maxY","_boundsDirty","allowChildren","_anchor","ObservablePoint","_onUpdate","onViewUpdate","_applyAnchorToTexture","_width","_height","_tileTransform","Transform","observer","from","source","Cache","get","clampMargin","_texture","textureMatrix","value","set","copyFrom","position","scale","rotation","tileTransform","bounds","_updateBounds","EMPTY","currentTexture","dynamic","off","on","_x","_y","addBounds","addFrame","containsPoint","point","x1","y1","x","y","_didTilingSpriteUpdate","_didChangeId","didViewUpdate","renderGroup","parentRenderGroup","onChildViewUpdate","destroy","destroyTexture","destroyTextureSource","textureSource","TilingSprite"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/sprite-tiling/TilingSprite.ts"],"sourcesContent":["import { Cache } from '../../assets/cache/Cache';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { Transform } from '../../utils/misc/Transform';\nimport { Container } from '../container/Container';\n\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { Bounds, BoundsData } from '../container/bounds/Bounds';\nimport type { ContainerOptions } from '../container/Container';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Constructor options used for `TilingSprite` instances. Extends {@link scene.TilingSpriteViewOptions}\n * ```js\n * const tilingSprite = new TilingSprite({\n *    texture: Texture.from('assets/image.png'),\n *    width: 100,\n *    height: 100,\n *    tilePosition: { x: 100, y: 100 },\n *    tileScale: { x: 2, y: 2 },\n * });\n * ```\n * @see {@link scene.TilingSprite}\n * @see {@link scene.TilingSpriteViewOptions}\n * @memberof scene\n */\nexport interface TilingSpriteOptions extends ContainerOptions\n{\n    /**\n     * The anchor point of the sprite\n     * @default {x: 0, y: 0}\n     */\n    anchor?: PointData\n    /**\n     * The offset of the image that is being tiled.\n     * @default {x: 0, y: 0}\n     */\n    tilePosition?: PointData\n    /**\n     * Scaling of the image that is being tiled.\n     * @default {x: 1, y: 1}\n     */\n    tileScale?: PointData\n    /**\n     * The rotation of the image that is being tiled.\n     * @default 0\n     */\n    tileRotation?: number\n    /**\n     * The texture to use for the sprite.\n     * @default Texture.WHITE\n     */\n    texture?: Texture\n    /**\n     * The width of the tiling sprite. #\n     * @default 256\n     */\n    width?: number\n    /**\n     * The height of the tiling sprite.\n     * @default 256\n     */\n    height?: number\n    // TODO needs a better name..\n    /**\n     * @todo\n     * @default false\n     */\n    applyAnchorToTexture?: boolean\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image.\n * @example\n * const tilingSprite = new TilingSprite({\n *    texture: Texture.from('assets/image.png'),\n *    width: 100,\n *    height: 100,\n * });\n *\n * tilingSprite.tilePosition.x = 100;\n * tilingSprite.tilePosition.y = 100;\n *\n * app.stage.addChild(tilingSprite);\n * @memberof scene\n * @extends scene.Container\n */\nexport class TilingSprite extends Container implements View, Instruction\n{\n    /**\n     * Creates a new tiling sprite.\n     * @param source - The source to create the texture from.\n     * @param options - The options for creating the tiling sprite.\n     * @returns A new tiling sprite.\n     */\n    public static from(source: Texture | string, options: TilingSpriteOptions = {})\n    {\n        if (typeof source === 'string')\n        {\n            return new TilingSprite({\n                texture: Cache.get(source),\n                ...options,\n            });\n        }\n\n        return new TilingSprite({\n            texture: source,\n            ...options,\n        });\n    }\n\n    /** default options for the TilingSprite */\n    public static defaultOptions: TilingSpriteOptions = {\n        /** The texture to use for the sprite. */\n        texture: Texture.EMPTY,\n        /** The anchor point of the sprite */\n        anchor: { x: 0, y: 0 },\n        /** The offset of the image that is being tiled. */\n        tilePosition: { x: 0, y: 0 },\n        /** Scaling of the image that is being tiled. */\n        tileScale: { x: 1, y: 1 },\n        /** The rotation of the image that is being tiled. */\n        tileRotation: 0,\n        /** TODO */\n        applyAnchorToTexture: false,\n    };\n\n    public readonly renderPipeId = 'tilingSprite';\n    public readonly canBundle = true;\n    public readonly batched = true;\n\n    public _anchor: ObservablePoint;\n\n    public _tileTransform: Transform;\n    public _texture: Texture;\n    public _applyAnchorToTexture: boolean;\n    public _didTilingSpriteUpdate: boolean;\n\n    public _roundPixels: 0 | 1 = 0;\n\n    private _bounds: BoundsData = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    private _boundsDirty = true;\n    private _width: number;\n    private _height: number;\n\n    /**\n     * @param {rendering.Texture | scene.TilingSpriteOptions} options - The options for creating the tiling sprite.\n     */\n    constructor(options?: Texture | TilingSpriteOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(texture: Texture, width: number, height: number);\n    constructor(...args: [(Texture | TilingSpriteOptions)?] | [Texture, number, number])\n    {\n        let options = args[0] || {};\n\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        if (args.length > 1)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new TilingSprite({ texture, width:100, height:100 }) instead');\n            // #endif\n\n            options.width = args[1];\n            options.height = args[2];\n        }\n\n        options = { ...TilingSprite.defaultOptions, ...options };\n\n        const {\n            texture,\n            anchor,\n            tilePosition,\n            tileScale,\n            tileRotation,\n            width,\n            height,\n            applyAnchorToTexture,\n            roundPixels,\n            ...rest\n        } = options ?? {};\n\n        super({\n\n            label: 'TilingSprite',\n            ...rest\n        });\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        this._applyAnchorToTexture = applyAnchorToTexture;\n\n        this.texture = texture;\n        this._width = width ?? texture.width;\n        this._height = height ?? texture.height;\n\n        this._tileTransform = new Transform({\n            observer: {\n                _onUpdate: () => this.onViewUpdate(),\n            }\n        });\n\n        if (anchor) this.anchor = anchor;\n        this.tilePosition = tilePosition;\n        this.tileScale = tileScale;\n        this.tileRotation = tileRotation;\n\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    /**\n     * Changes frame clamping in corresponding textureMatrix\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     * @member {number}\n     */\n    get clampMargin()\n    {\n        return this._texture.textureMatrix.clampMargin;\n    }\n\n    set clampMargin(value: number)\n    {\n        this._texture.textureMatrix.clampMargin = value;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * The default is `(0,0)`, this means the sprite's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { TilingSprite } from 'pixi.js';\n     *\n     * const sprite = new TilingSprite({texture: Texture.WHITE});\n     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /** The offset of the image that is being tiled. */\n    get tilePosition(): ObservablePoint\n    {\n        return this._tileTransform.position;\n    }\n\n    set tilePosition(value: PointData)\n    {\n        this._tileTransform.position.copyFrom(value);\n    }\n\n    /** The scaling of the image that is being tiled. */\n    get tileScale(): ObservablePoint\n    {\n        return this._tileTransform.scale;\n    }\n\n    set tileScale(value: PointData | number)\n    {\n        typeof value === 'number' ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);\n    }\n\n    set tileRotation(value)\n    {\n        this._tileTransform.rotation = value;\n    }\n\n    /** The rotation of the image that is being tiled. */\n    get tileRotation()\n    {\n        return this._tileTransform.rotation;\n    }\n\n    /** The transform of the image that is being tiled. */\n    get tileTransform()\n    {\n        return this._tileTransform;\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the sprite.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    /**\n     * The local bounds of the sprite.\n     * @type {rendering.Bounds}\n     */\n    get bounds()\n    {\n        if (this._boundsDirty)\n        {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n\n        return this._bounds;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        this.onViewUpdate();\n    }\n\n    /** The texture that the sprite is using. */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /** The width of the tiling area. */\n    set width(value: number)\n    {\n        this._width = value;\n        this.onViewUpdate();\n    }\n\n    get width()\n    {\n        return this._width;\n    }\n\n    set height(value: number)\n    {\n        this._height = value;\n        this.onViewUpdate();\n    }\n\n    /** The height of the tiling area. */\n    get height()\n    {\n        return this._height;\n    }\n\n    private _updateBounds()\n    {\n        const bounds = this._bounds;\n\n        const anchor = this._anchor;\n\n        const width = this._width;\n        const height = this._height;\n\n        bounds.maxX = -anchor._x * width;\n        bounds.minX = bounds.maxX + width;\n\n        bounds.maxY = -anchor._y * height;\n        bounds.minY = bounds.maxY + height;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this.bounds;\n\n        bounds.addFrame(\n            _bounds.minX,\n            _bounds.minY,\n            _bounds.maxX,\n            _bounds.maxY,\n        );\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        const width = this.bounds.minX;\n        const height = this.bounds.minY;\n        const x1 = -width * this._anchor._x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this._anchor._y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    public onViewUpdate()\n    {\n        this._boundsDirty = true;\n        this._didTilingSpriteUpdate = true;\n\n        this._didChangeId += 1 << 12;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        this._anchor = null;\n        this._tileTransform = null;\n        this._bounds = null;\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n    }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}