{"ast":null,"code":"import { xglobal } from '@polkadot/x-global';\nimport { formatDate } from './format/formatDate.js';\nimport { isBn } from './is/bn.js';\nimport { isBuffer } from './is/buffer.js';\nimport { isFunction } from './is/function.js';\nimport { isObject } from './is/object.js';\nimport { isU8a } from './is/u8a.js';\nimport { u8aToHex } from './u8a/toHex.js';\nimport { u8aToU8a } from './u8a/toU8a.js';\nimport { noop } from './noop.js';\nconst logTo = {\n  debug: 'log',\n  error: 'error',\n  log: 'log',\n  warn: 'warn'\n};\nfunction formatOther(value) {\n  if (value && isObject(value) && value.constructor === Object) {\n    const result = {};\n    for (const [k, v] of Object.entries(value)) {\n      result[k] = loggerFormat(v);\n    }\n    return result;\n  }\n  return value;\n}\nexport function loggerFormat(value) {\n  if (Array.isArray(value)) {\n    return value.map(loggerFormat);\n  } else if (isBn(value)) {\n    return value.toString();\n  } else if (isU8a(value) || isBuffer(value)) {\n    return u8aToHex(u8aToU8a(value));\n  }\n  return formatOther(value);\n}\nfunction formatWithLength(maxLength) {\n  return v => {\n    if (maxLength <= 0) {\n      return v;\n    }\n    const r = `${v}`;\n    return r.length < maxLength ? v : `${r.substring(0, maxLength)} ...`;\n  };\n}\nfunction apply(log, type, values, maxSize = -1) {\n  if (values.length === 1 && isFunction(values[0])) {\n    const fnResult = values[0]();\n    return apply(log, type, Array.isArray(fnResult) ? fnResult : [fnResult], maxSize);\n  }\n  console[logTo[log]](formatDate(new Date()), type, ...values.map(loggerFormat).map(formatWithLength(maxSize)));\n}\nfunction isDebugOn(e, type) {\n  return !!e && (e === '*' || type === e || e.endsWith('*') && type.startsWith(e.slice(0, -1)));\n}\nfunction isDebugOff(e, type) {\n  return !!e && e.startsWith('-') && (type === e.slice(1) || e.endsWith('*') && type.startsWith(e.slice(1, -1)));\n}\nfunction getDebugFlag(env, type) {\n  let flag = false;\n  for (const e of env) {\n    if (isDebugOn(e, type)) {\n      flag = true;\n    } else if (isDebugOff(e, type)) {\n      flag = false;\n    }\n  }\n  return flag;\n}\nfunction parseEnv(type) {\n  const maxSize = parseInt(xglobal.process?.env?.['DEBUG_MAX'] || '-1', 10);\n  return [getDebugFlag((xglobal.process?.env?.['DEBUG'] || '').toLowerCase().split(','), type), isNaN(maxSize) ? -1 : maxSize];\n}\n/**\n * @name Logger\n * @summary Creates a consistent log interface for messages\n * @description\n * Returns a `Logger` that has `.log`, `.error`, `.warn` and `.debug` (controlled with environment `DEBUG=typeA,typeB`) methods. Logging is done with a consistent prefix (type of logger, date) followed by the actual message using the underlying console.\n * @example\n * <BR>\n *\n * ```javascript\n * import { logger } from '@polkadot/util';\n *\n * const l = logger('test');\n * ```\n */\nexport function logger(origin) {\n  const type = `${origin.toUpperCase()}:`.padStart(16);\n  const [isDebug, maxSize] = parseEnv(origin.toLowerCase());\n  return {\n    debug: isDebug ? (...values) => apply('debug', type, values, maxSize) : noop,\n    error: (...values) => apply('error', type, values),\n    log: (...values) => apply('log', type, values),\n    noop,\n    warn: (...values) => apply('warn', type, values)\n  };\n}","map":{"version":3,"names":["xglobal","formatDate","isBn","isBuffer","isFunction","isObject","isU8a","u8aToHex","u8aToU8a","noop","logTo","debug","error","log","warn","formatOther","value","constructor","Object","result","k","v","entries","loggerFormat","Array","isArray","map","toString","formatWithLength","maxLength","r","length","substring","apply","type","values","maxSize","fnResult","console","Date","isDebugOn","e","endsWith","startsWith","slice","isDebugOff","getDebugFlag","env","flag","parseEnv","parseInt","process","toLowerCase","split","isNaN","logger","origin","toUpperCase","padStart","isDebug"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util/logger.js"],"sourcesContent":["import { xglobal } from '@polkadot/x-global';\nimport { formatDate } from './format/formatDate.js';\nimport { isBn } from './is/bn.js';\nimport { isBuffer } from './is/buffer.js';\nimport { isFunction } from './is/function.js';\nimport { isObject } from './is/object.js';\nimport { isU8a } from './is/u8a.js';\nimport { u8aToHex } from './u8a/toHex.js';\nimport { u8aToU8a } from './u8a/toU8a.js';\nimport { noop } from './noop.js';\nconst logTo = {\n    debug: 'log',\n    error: 'error',\n    log: 'log',\n    warn: 'warn'\n};\nfunction formatOther(value) {\n    if (value && isObject(value) && value.constructor === Object) {\n        const result = {};\n        for (const [k, v] of Object.entries(value)) {\n            result[k] = loggerFormat(v);\n        }\n        return result;\n    }\n    return value;\n}\nexport function loggerFormat(value) {\n    if (Array.isArray(value)) {\n        return value.map(loggerFormat);\n    }\n    else if (isBn(value)) {\n        return value.toString();\n    }\n    else if (isU8a(value) || isBuffer(value)) {\n        return u8aToHex(u8aToU8a(value));\n    }\n    return formatOther(value);\n}\nfunction formatWithLength(maxLength) {\n    return (v) => {\n        if (maxLength <= 0) {\n            return v;\n        }\n        const r = `${v}`;\n        return r.length < maxLength\n            ? v\n            : `${r.substring(0, maxLength)} ...`;\n    };\n}\nfunction apply(log, type, values, maxSize = -1) {\n    if (values.length === 1 && isFunction(values[0])) {\n        const fnResult = values[0]();\n        return apply(log, type, Array.isArray(fnResult) ? fnResult : [fnResult], maxSize);\n    }\n    console[logTo[log]](formatDate(new Date()), type, ...values\n        .map(loggerFormat)\n        .map(formatWithLength(maxSize)));\n}\nfunction isDebugOn(e, type) {\n    return !!e && (e === '*' ||\n        type === e ||\n        (e.endsWith('*') &&\n            type.startsWith(e.slice(0, -1))));\n}\nfunction isDebugOff(e, type) {\n    return !!e && (e.startsWith('-') &&\n        (type === e.slice(1) ||\n            (e.endsWith('*') &&\n                type.startsWith(e.slice(1, -1)))));\n}\nfunction getDebugFlag(env, type) {\n    let flag = false;\n    for (const e of env) {\n        if (isDebugOn(e, type)) {\n            flag = true;\n        }\n        else if (isDebugOff(e, type)) {\n            flag = false;\n        }\n    }\n    return flag;\n}\nfunction parseEnv(type) {\n    const maxSize = parseInt(xglobal.process?.env?.['DEBUG_MAX'] || '-1', 10);\n    return [\n        getDebugFlag((xglobal.process?.env?.['DEBUG'] || '').toLowerCase().split(','), type),\n        isNaN(maxSize)\n            ? -1\n            : maxSize\n    ];\n}\n/**\n * @name Logger\n * @summary Creates a consistent log interface for messages\n * @description\n * Returns a `Logger` that has `.log`, `.error`, `.warn` and `.debug` (controlled with environment `DEBUG=typeA,typeB`) methods. Logging is done with a consistent prefix (type of logger, date) followed by the actual message using the underlying console.\n * @example\n * <BR>\n *\n * ```javascript\n * import { logger } from '@polkadot/util';\n *\n * const l = logger('test');\n * ```\n */\nexport function logger(origin) {\n    const type = `${origin.toUpperCase()}:`.padStart(16);\n    const [isDebug, maxSize] = parseEnv(origin.toLowerCase());\n    return {\n        debug: isDebug\n            ? (...values) => apply('debug', type, values, maxSize)\n            : noop,\n        error: (...values) => apply('error', type, values),\n        log: (...values) => apply('log', type, values),\n        noop,\n        warn: (...values) => apply('warn', type, values)\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}