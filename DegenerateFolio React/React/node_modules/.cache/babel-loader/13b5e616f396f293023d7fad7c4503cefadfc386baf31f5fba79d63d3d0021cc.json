{"ast":null,"code":"import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\nimport { Geometry } from '../shared/geometry/Geometry.mjs';\nimport { Shader } from '../shared/shader/Shader.mjs';\nimport { State } from '../shared/state/State.mjs';\nimport { TextureSource } from '../shared/texture/sources/TextureSource.mjs';\nimport { Texture } from '../shared/texture/Texture.mjs';\nimport { GlProgram } from './shader/GlProgram.mjs';\n\"use strict\";\nconst bigTriangleGeometry = new Geometry({\n  attributes: {\n    aPosition: [-1, -1,\n    // Bottom left corner\n    3, -1,\n    // Bottom right corner, extending beyond right edge\n    -1, 3\n    // Top left corner, extending beyond top edge\n    ]\n  }\n});\nconst _GlBackBufferSystem = class _GlBackBufferSystem {\n  constructor(renderer) {\n    /** if true, the back buffer is used */\n    this.useBackBuffer = false;\n    this._useBackBufferThisRender = false;\n    this._renderer = renderer;\n  }\n  init(options = {}) {\n    const {\n      useBackBuffer,\n      antialias\n    } = {\n      ..._GlBackBufferSystem.defaultOptions,\n      ...options\n    };\n    this.useBackBuffer = useBackBuffer;\n    this._antialias = antialias;\n    if (!this._renderer.context.supports.msaa) {\n      warn(\"antialiasing, is not supported on when using the back buffer\");\n      this._antialias = false;\n    }\n    this._state = State.for2d();\n    const bigTriangleProgram = new GlProgram({\n      vertex: `\n                attribute vec2 aPosition;\n                out vec2 vUv;\n\n                void main() {\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n                    vUv = (aPosition + 1.0) / 2.0;\n\n                    // flip dem UVs\n                    vUv.y = 1.0 - vUv.y;\n                }`,\n      fragment: `\n                in vec2 vUv;\n                out vec4 finalColor;\n\n                uniform sampler2D uTexture;\n\n                void main() {\n                    finalColor = texture(uTexture, vUv);\n                }`,\n      name: \"big-triangle\"\n    });\n    this._bigTriangleShader = new Shader({\n      glProgram: bigTriangleProgram,\n      resources: {\n        uTexture: Texture.WHITE.source\n      }\n    });\n  }\n  /**\n   * This is called before the RenderTargetSystem is started. This is where\n   * we replace the target with the back buffer if required.\n   * @param options - The options for this render.\n   */\n  renderStart(options) {\n    const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n    this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;\n    if (this._useBackBufferThisRender) {\n      const renderTarget2 = this._renderer.renderTarget.getRenderTarget(options.target);\n      this._targetTexture = renderTarget2.colorTexture;\n      options.target = this._getBackBufferTexture(renderTarget2.colorTexture);\n    }\n  }\n  renderEnd() {\n    this._presentBackBuffer();\n  }\n  _presentBackBuffer() {\n    const renderer = this._renderer;\n    renderer.renderTarget.finishRenderPass();\n    if (!this._useBackBufferThisRender) return;\n    renderer.renderTarget.bind(this._targetTexture, false);\n    this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;\n    renderer.encoder.draw({\n      geometry: bigTriangleGeometry,\n      shader: this._bigTriangleShader,\n      state: this._state\n    });\n  }\n  _getBackBufferTexture(targetSourceTexture) {\n    this._backBufferTexture = this._backBufferTexture || new Texture({\n      source: new TextureSource({\n        width: targetSourceTexture.width,\n        height: targetSourceTexture.height,\n        resolution: targetSourceTexture._resolution,\n        antialias: this._antialias\n      })\n    });\n    this._backBufferTexture.source.resize(targetSourceTexture.width, targetSourceTexture.height, targetSourceTexture._resolution);\n    return this._backBufferTexture;\n  }\n  /** destroys the back buffer */\n  destroy() {\n    if (this._backBufferTexture) {\n      this._backBufferTexture.destroy();\n      this._backBufferTexture = null;\n    }\n  }\n};\n/** @ignore */\n_GlBackBufferSystem.extension = {\n  type: [ExtensionType.WebGLSystem],\n  name: \"backBuffer\",\n  priority: 1\n};\n/** default options for the back buffer system */\n_GlBackBufferSystem.defaultOptions = {\n  /** if true will use the back buffer where required */\n  useBackBuffer: false\n};\nlet GlBackBufferSystem = _GlBackBufferSystem;\nexport { GlBackBufferSystem };","map":{"version":3,"names":["bigTriangleGeometry","Geometry","attributes","aPosition","_GlBackBufferSystem","constructor","renderer","useBackBuffer","_useBackBufferThisRender","_renderer","init","options","antialias","defaultOptions","_antialias","context","supports","msaa","warn","_state","State","for2d","bigTriangleProgram","GlProgram","vertex","fragment","name","_bigTriangleShader","Shader","glProgram","resources","uTexture","Texture","WHITE","source","renderStart","renderTarget","getRenderTarget","target","isRoot","renderTarget2","_targetTexture","colorTexture","_getBackBufferTexture","renderEnd","_presentBackBuffer","finishRenderPass","bind","_backBufferTexture","encoder","draw","geometry","shader","state","targetSourceTexture","TextureSource","width","height","resolution","_resolution","resize","destroy","extension","type","ExtensionType","WebGLSystem","priority","GlBackBufferSystem"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gl/GlBackBufferSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { warn } from '../../../utils/logging/warn';\nimport { Geometry } from '../shared/geometry/Geometry';\nimport { Shader } from '../shared/shader/Shader';\nimport { State } from '../shared/state/State';\nimport { TextureSource } from '../shared/texture/sources/TextureSource';\nimport { Texture } from '../shared/texture/Texture';\nimport { GlProgram } from './shader/GlProgram';\n\nimport type { RenderOptions } from '../shared/system/AbstractRenderer';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\nconst bigTriangleGeometry = new Geometry({\n    attributes: {\n        aPosition: [\n            -1.0, -1.0, // Bottom left corner\n            3.0, -1.0, // Bottom right corner, extending beyond right edge\n            -1.0, 3.0 // Top left corner, extending beyond top edge\n        ],\n    },\n});\n\n/**\n * The options for the back buffer system.\n * @memberof rendering\n * @property {boolean} [useBackBuffer=false] - if true will use the back buffer where required\n * @property {boolean} [antialias=false] - if true will ensure the texture is antialiased\n */\nexport interface GlBackBufferOptions\n{\n    /**\n     * if true will use the back buffer where required\n     * @default false\n     * @memberof rendering.WebGLOptions\n     */\n    useBackBuffer?: boolean;\n    /** if true will ensure the texture is antialiased */\n    antialias?: boolean;\n}\n\n/**\n * For blend modes you need to know what pixels you are actually drawing to. For this to be possible in WebGL\n * we need to render to a texture and then present that texture to the screen. This system manages that process.\n *\n * As the main scene is rendered to a texture, it means we can sample it anc copy its pixels,\n * something not possible on the main canvas.\n *\n * If antialiasing is set to to true and useBackBuffer is set to true, then the back buffer will be antialiased.\n * and the main gl context will not.\n *\n * You only need to activate this back buffer if you are using a blend mode that requires it.\n *\n * to activate is simple, you pass `useBackBuffer:true` to your render options\n * @memberof rendering\n */\nexport class GlBackBufferSystem implements System<GlBackBufferOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'backBuffer',\n        priority: 1\n    } as const;\n\n    /** default options for the back buffer system */\n    public static defaultOptions: GlBackBufferOptions = {\n        /** if true will use the back buffer where required */\n        useBackBuffer: false,\n    };\n\n    /** if true, the back buffer is used */\n    public useBackBuffer = false;\n\n    private _backBufferTexture: Texture;\n    private readonly _renderer: WebGLRenderer;\n    private _targetTexture: TextureSource;\n    private _useBackBufferThisRender = false;\n    private _antialias: boolean;\n    private _state: State;\n    private _bigTriangleShader: Shader;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public init(options: GlBackBufferOptions = {})\n    {\n        const { useBackBuffer, antialias } = { ...GlBackBufferSystem.defaultOptions, ...options };\n\n        this.useBackBuffer = useBackBuffer;\n\n        this._antialias = antialias;\n\n        if (!this._renderer.context.supports.msaa)\n        {\n            warn('antialiasing, is not supported on when using the back buffer');\n\n            this._antialias = false;\n        }\n\n        this._state = State.for2d();\n\n        const bigTriangleProgram = new GlProgram({\n            vertex: `\n                attribute vec2 aPosition;\n                out vec2 vUv;\n\n                void main() {\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n                    vUv = (aPosition + 1.0) / 2.0;\n\n                    // flip dem UVs\n                    vUv.y = 1.0 - vUv.y;\n                }`,\n            fragment: `\n                in vec2 vUv;\n                out vec4 finalColor;\n\n                uniform sampler2D uTexture;\n\n                void main() {\n                    finalColor = texture(uTexture, vUv);\n                }`,\n            name: 'big-triangle',\n        });\n\n        this._bigTriangleShader = new Shader({\n            glProgram: bigTriangleProgram,\n            resources: {\n                uTexture: Texture.WHITE.source,\n            },\n        });\n    }\n\n    /**\n     * This is called before the RenderTargetSystem is started. This is where\n     * we replace the target with the back buffer if required.\n     * @param options - The options for this render.\n     */\n    protected renderStart(options: RenderOptions)\n    {\n        const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n\n        this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;\n\n        if (this._useBackBufferThisRender)\n        {\n            const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n\n            this._targetTexture = renderTarget.colorTexture;\n\n            options.target = this._getBackBufferTexture(renderTarget.colorTexture);\n        }\n    }\n\n    protected renderEnd()\n    {\n        this._presentBackBuffer();\n    }\n\n    private _presentBackBuffer()\n    {\n        const renderer = this._renderer;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (!this._useBackBufferThisRender) return;\n\n        renderer.renderTarget.bind(this._targetTexture, false);\n\n        this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;\n\n        renderer.encoder.draw({\n            geometry: bigTriangleGeometry,\n            shader: this._bigTriangleShader,\n            state: this._state,\n        });\n    }\n\n    private _getBackBufferTexture(targetSourceTexture: TextureSource)\n    {\n        this._backBufferTexture = this._backBufferTexture || new Texture({\n            source: new TextureSource({\n                width: targetSourceTexture.width,\n                height: targetSourceTexture.height,\n                resolution: targetSourceTexture._resolution,\n                antialias: this._antialias,\n            }),\n        });\n\n        // this will not resize if its the same size already! No extra check required\n        this._backBufferTexture.source.resize(\n            targetSourceTexture.width,\n            targetSourceTexture.height,\n            targetSourceTexture._resolution,\n        );\n\n        return this._backBufferTexture;\n    }\n\n    /** destroys the back buffer */\n    public destroy()\n    {\n        if (this._backBufferTexture)\n        {\n            this._backBufferTexture.destroy();\n            this._backBufferTexture = null;\n        }\n    }\n}\n"],"mappings":";;;;;;;;;AAaA,MAAMA,mBAAA,GAAsB,IAAIC,QAAS;EACrCC,UAAY;IACRC,SAAW,GACP,IAAM;IAAA;IACN,GAAK;IAAA;IACL,IAAM;IAAA;IAAA;EACV;AAER,CAAC;AAmCM,MAAMC,mBAAA,GAAN,MAAMA,mBACb;EA2BIC,YAAYC,QACZ;IAXA;IAAA,KAAOC,aAAgB;IAKvB,KAAQC,wBAA2B;IAO/B,KAAKC,SAAY,GAAAH,QAAA;EAAA;EAGdI,KAAKC,OAA+B,KAC3C;IACU;MAAEJ,aAAA;MAAeK;IAAU,IAAI;MAAE,GAAGR,mBAAA,CAAmBS,cAAgB;MAAA,GAAGF;IAAQ;IAExF,KAAKJ,aAAgB,GAAAA,aAAA;IAErB,KAAKO,UAAa,GAAAF,SAAA;IAElB,IAAI,CAAC,KAAKH,SAAU,CAAAM,OAAA,CAAQC,QAAA,CAASC,IACrC;MACIC,IAAA,CAAK,8DAA8D;MAEnE,KAAKJ,UAAa;IAAA;IAGjB,KAAAK,MAAA,GAASC,KAAA,CAAMC,KAAM;IAEpB,MAAAC,kBAAA,GAAqB,IAAIC,SAAU;MACrCC,MAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;MAYRC,QAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;MASVC,IAAM;IAAA,CACT;IAEI,KAAAC,kBAAA,GAAqB,IAAIC,MAAO;MACjCC,SAAW,EAAAP,kBAAA;MACXQ,SAAW;QACPC,QAAA,EAAUC,OAAA,CAAQC,KAAM,CAAAC;MAAA;IAC5B,CACH;EAAA;EACL;AAAA;AAAA;AAAA;AAAA;EAOUC,YAAYxB,OACtB;IACI,MAAMyB,YAAA,GAAe,IAAK,CAAA3B,SAAA,CAAU2B,YAAa,CAAAC,eAAA,CAAgB1B,OAAA,CAAQ2B,MAAM;IAE/E,KAAK9B,wBAA2B,QAAKD,aAAiB,KAAC,CAAC6B,YAAa,CAAAG,MAAA;IAErE,IAAI,KAAK/B,wBACT;MACI,MAAMgC,aAAA,GAAe,IAAK,CAAA/B,SAAA,CAAU2B,YAAa,CAAAC,eAAA,CAAgB1B,OAAA,CAAQ2B,MAAM;MAE/E,KAAKG,cAAA,GAAiBD,aAAa,CAAAE,YAAA;MAEnC/B,OAAA,CAAQ2B,MAAS,QAAKK,qBAAsB,CAAAH,aAAA,CAAaE,YAAY;IAAA;EACzE;EAGME,SACVA,CAAA;IACI,KAAKC,kBAAmB;EAAA;EAGpBA,kBACRA,CAAA;IACI,MAAMvC,QAAA,GAAW,IAAK,CAAAG,SAAA;IAEtBH,QAAA,CAAS8B,YAAA,CAAaU,gBAAiB;IAEvC,IAAI,CAAC,IAAK,CAAAtC,wBAAA,EAA0B;IAEpCF,QAAA,CAAS8B,YAAa,CAAAW,IAAA,CAAK,IAAK,CAAAN,cAAA,EAAgB,KAAK;IAErD,KAAKd,kBAAmB,CAAAG,SAAA,CAAUC,QAAW,QAAKiB,kBAAmB,CAAAd,MAAA;IAErE5B,QAAA,CAAS2C,OAAA,CAAQC,IAAK;MAClBC,QAAU,EAAAnD,mBAAA;MACVoD,MAAA,EAAQ,IAAK,CAAAzB,kBAAA;MACb0B,KAAA,EAAO,IAAK,CAAAlC;IAAA,CACf;EAAA;EAGGwB,sBAAsBW,mBAC9B;IACI,KAAKN,kBAAqB,QAAKA,kBAAsB,QAAIhB,OAAQ;MAC7DE,MAAA,EAAQ,IAAIqB,aAAc;QACtBC,KAAA,EAAOF,mBAAoB,CAAAE,KAAA;QAC3BC,MAAA,EAAQH,mBAAoB,CAAAG,MAAA;QAC5BC,UAAA,EAAYJ,mBAAoB,CAAAK,WAAA;QAChC/C,SAAA,EAAW,IAAK,CAAAE;MAAA,CACnB;IAAA,CACJ;IAGD,KAAKkC,kBAAA,CAAmBd,MAAO,CAAA0B,MAAA,CAC3BN,mBAAoB,CAAAE,KAAA,EACpBF,mBAAoB,CAAAG,MAAA,EACpBH,mBAAoB,CAAAK,WAAA,CACxB;IAEA,OAAO,IAAK,CAAAX,kBAAA;EAAA;EAChB;EAGOa,OACPA,CAAA;IACI,IAAI,KAAKb,kBACT;MACI,KAAKA,kBAAA,CAAmBa,OAAQ;MAChC,KAAKb,kBAAqB;IAAA;EAC9B;AAER;AAAA;AA9Ja5C,mBAAA,CAGK0D,SAAY;EACtBC,IAAM,GACFC,aAAc,CAAAC,WAAA,CAClB;EACAvC,IAAM;EACNwC,QAAU;AACd;AAAA;AATS9D,mBAAA,CAYKS,cAAsC;EAAA;EAEhDN,aAAe;AACnB;AAfG,IAAM4D,kBAAN,GAAA/D,mBAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}