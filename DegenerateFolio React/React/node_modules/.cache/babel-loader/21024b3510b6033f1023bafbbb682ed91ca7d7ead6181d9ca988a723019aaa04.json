{"ast":null,"code":"import { map, of } from 'rxjs';\nimport { objectSpread } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nimport { didUpdateToBool } from './util.js';\nfunction parseActive(id, active) {\n  const found = active.find(([paraId]) => paraId === id);\n  if (found && found[1].isSome) {\n    const [collatorId, retriable] = found[1].unwrap();\n    return objectSpread({\n      collatorId\n    }, retriable.isWithRetries ? {\n      isRetriable: true,\n      retries: retriable.asWithRetries.toNumber()\n    } : {\n      isRetriable: false,\n      retries: 0\n    });\n  }\n  return null;\n}\nfunction parseCollators(id, collatorQueue) {\n  return collatorQueue.map(queue => {\n    const found = queue.find(([paraId]) => paraId === id);\n    return found ? found[1] : null;\n  });\n}\nfunction parse(id, [active, retryQueue, selectedThreads, didUpdate, info, pendingSwap, heads, relayDispatchQueue]) {\n  if (info.isNone) {\n    return null;\n  }\n  return {\n    active: parseActive(id, active),\n    didUpdate: didUpdateToBool(didUpdate, id),\n    heads,\n    id,\n    info: objectSpread({\n      id\n    }, info.unwrap()),\n    pendingSwapId: pendingSwap.unwrapOr(null),\n    relayDispatchQueue,\n    retryCollators: parseCollators(id, retryQueue),\n    selectedCollators: parseCollators(id, selectedThreads)\n  };\n}\nexport function info(instanceId, api) {\n  return memo(instanceId, id => api.query['registrar'] && api.query['parachains'] ? api.queryMulti([api.query['registrar']['active'], api.query['registrar']['retryQueue'], api.query['registrar']['selectedThreads'], api.query['parachains']['didUpdate'], [api.query['registrar']['paras'], id], [api.query['registrar']['pendingSwap'], id], [api.query['parachains']['heads'], id], [api.query['parachains']['relayDispatchQueue'], id]]).pipe(map(result => parse(api.registry.createType('ParaId', id), result))) : of(null));\n}","map":{"version":3,"names":["map","of","objectSpread","memo","didUpdateToBool","parseActive","id","active","found","find","paraId","isSome","collatorId","retriable","unwrap","isWithRetries","isRetriable","retries","asWithRetries","toNumber","parseCollators","collatorQueue","queue","parse","retryQueue","selectedThreads","didUpdate","info","pendingSwap","heads","relayDispatchQueue","isNone","pendingSwapId","unwrapOr","retryCollators","selectedCollators","instanceId","api","query","queryMulti","pipe","result","registry","createType"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api-derive/parachains/info.js"],"sourcesContent":["import { map, of } from 'rxjs';\nimport { objectSpread } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nimport { didUpdateToBool } from './util.js';\nfunction parseActive(id, active) {\n    const found = active.find(([paraId]) => paraId === id);\n    if (found && found[1].isSome) {\n        const [collatorId, retriable] = found[1].unwrap();\n        return objectSpread({ collatorId }, retriable.isWithRetries\n            ? {\n                isRetriable: true,\n                retries: retriable.asWithRetries.toNumber()\n            }\n            : {\n                isRetriable: false,\n                retries: 0\n            });\n    }\n    return null;\n}\nfunction parseCollators(id, collatorQueue) {\n    return collatorQueue.map((queue) => {\n        const found = queue.find(([paraId]) => paraId === id);\n        return found ? found[1] : null;\n    });\n}\nfunction parse(id, [active, retryQueue, selectedThreads, didUpdate, info, pendingSwap, heads, relayDispatchQueue]) {\n    if (info.isNone) {\n        return null;\n    }\n    return {\n        active: parseActive(id, active),\n        didUpdate: didUpdateToBool(didUpdate, id),\n        heads,\n        id,\n        info: objectSpread({ id }, info.unwrap()),\n        pendingSwapId: pendingSwap.unwrapOr(null),\n        relayDispatchQueue,\n        retryCollators: parseCollators(id, retryQueue),\n        selectedCollators: parseCollators(id, selectedThreads)\n    };\n}\nexport function info(instanceId, api) {\n    return memo(instanceId, (id) => api.query['registrar'] && api.query['parachains']\n        ? api.queryMulti([\n            api.query['registrar']['active'],\n            api.query['registrar']['retryQueue'],\n            api.query['registrar']['selectedThreads'],\n            api.query['parachains']['didUpdate'],\n            [api.query['registrar']['paras'], id],\n            [api.query['registrar']['pendingSwap'], id],\n            [api.query['parachains']['heads'], id],\n            [api.query['parachains']['relayDispatchQueue'], id]\n        ])\n            .pipe(map((result) => parse(api.registry.createType('ParaId', id), result)))\n        : of(null));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}