{"ast":null,"code":"import { combineLatest, map, mergeMap, of, switchMap } from 'rxjs';\nimport { memo, unwrapBlockNumber } from '../util/index.js';\nexport function createBlockNumberDerive(fn) {\n  return (instanceId, api) => memo(instanceId, () => fn(api).pipe(map(unwrapBlockNumber)));\n}\n/** @internal */\nfunction getAuthorDetailsWithAt(header, queryAt) {\n  const validators = queryAt.session?.validators ? queryAt.session.validators() : of(null);\n  // nimbus consensus stores the session key of the block author in header logs\n  const {\n    logs: [log]\n  } = header.digest;\n  const loggedAuthor = log && (log.isConsensus && log.asConsensus[0].isNimbus && log.asConsensus[1] || log.isPreRuntime && log.asPreRuntime[0].isNimbus && log.asPreRuntime[1]);\n  if (loggedAuthor) {\n    // use the author mapping pallet, if available (ie: moonbeam, moonriver), to map session (nimbus) key to author (collator/validator) key\n    if (queryAt['authorMapping']?.['mappingWithDeposit']) {\n      return combineLatest([of(header), validators, queryAt['authorMapping']['mappingWithDeposit'](loggedAuthor).pipe(map(o => o.unwrapOr({\n        account: null\n      }).account))]);\n    }\n    // fall back to session and parachain staking pallets, if available (ie: manta, calamari), to map session (nimbus) key to author (collator) key\n    if (queryAt['parachainStaking']?.['selectedCandidates'] && queryAt.session?.nextKeys) {\n      const loggedHex = loggedAuthor.toHex();\n      return combineLatest([of(header), validators, queryAt['parachainStaking']['selectedCandidates']().pipe(mergeMap(selectedCandidates => combineLatest([of(selectedCandidates), queryAt.session.nextKeys.multi(selectedCandidates).pipe(map(nextKeys => nextKeys.findIndex(o => o.unwrapOrDefault().nimbus.toHex() === loggedHex)))])), map(([selectedCandidates, index]) => index === -1 ? null : selectedCandidates[index]))]);\n    }\n  }\n  // normal operation, non-mapping\n  return combineLatest([of(header), validators, of(null)]);\n}\nexport function getAuthorDetails(api, header, blockHash) {\n  // For on-chain state, we need to retrieve it as per the start\n  // of the block being constructed, i.e. session validators would\n  // be at the point of the block construction, not when all operations\n  // has been supplied.\n  //\n  // However for the first block (no parentHash available), we would\n  // just use the as-is\n  return api.queryAt(header.parentHash.isEmpty ? blockHash || header.hash : header.parentHash).pipe(switchMap(queryAt => getAuthorDetailsWithAt(header, queryAt)));\n}","map":{"version":3,"names":["combineLatest","map","mergeMap","of","switchMap","memo","unwrapBlockNumber","createBlockNumberDerive","fn","instanceId","api","pipe","getAuthorDetailsWithAt","header","queryAt","validators","session","logs","log","digest","loggedAuthor","isConsensus","asConsensus","isNimbus","isPreRuntime","asPreRuntime","o","unwrapOr","account","nextKeys","loggedHex","toHex","selectedCandidates","multi","findIndex","unwrapOrDefault","nimbus","index","getAuthorDetails","blockHash","parentHash","isEmpty","hash"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api-derive/chain/util.js"],"sourcesContent":["import { combineLatest, map, mergeMap, of, switchMap } from 'rxjs';\nimport { memo, unwrapBlockNumber } from '../util/index.js';\nexport function createBlockNumberDerive(fn) {\n    return (instanceId, api) => memo(instanceId, () => fn(api).pipe(map(unwrapBlockNumber)));\n}\n/** @internal */\nfunction getAuthorDetailsWithAt(header, queryAt) {\n    const validators = queryAt.session?.validators\n        ? queryAt.session.validators()\n        : of(null);\n    // nimbus consensus stores the session key of the block author in header logs\n    const { logs: [log] } = header.digest;\n    const loggedAuthor = (log && ((log.isConsensus && log.asConsensus[0].isNimbus && log.asConsensus[1]) ||\n        (log.isPreRuntime && log.asPreRuntime[0].isNimbus && log.asPreRuntime[1])));\n    if (loggedAuthor) {\n        // use the author mapping pallet, if available (ie: moonbeam, moonriver), to map session (nimbus) key to author (collator/validator) key\n        if (queryAt['authorMapping']?.['mappingWithDeposit']) {\n            return combineLatest([\n                of(header),\n                validators,\n                queryAt['authorMapping']['mappingWithDeposit'](loggedAuthor).pipe(map((o) => o.unwrapOr({ account: null }).account))\n            ]);\n        }\n        // fall back to session and parachain staking pallets, if available (ie: manta, calamari), to map session (nimbus) key to author (collator) key\n        if (queryAt['parachainStaking']?.['selectedCandidates'] && queryAt.session?.nextKeys) {\n            const loggedHex = loggedAuthor.toHex();\n            return combineLatest([\n                of(header),\n                validators,\n                queryAt['parachainStaking']['selectedCandidates']().pipe(mergeMap((selectedCandidates) => combineLatest([\n                    of(selectedCandidates),\n                    queryAt.session.nextKeys.multi(selectedCandidates).pipe(map((nextKeys) => nextKeys.findIndex((o) => o.unwrapOrDefault().nimbus.toHex() === loggedHex)))\n                ])), map(([selectedCandidates, index]) => index === -1\n                    ? null\n                    : selectedCandidates[index]))\n            ]);\n        }\n    }\n    // normal operation, non-mapping\n    return combineLatest([\n        of(header),\n        validators,\n        of(null)\n    ]);\n}\nexport function getAuthorDetails(api, header, blockHash) {\n    // For on-chain state, we need to retrieve it as per the start\n    // of the block being constructed, i.e. session validators would\n    // be at the point of the block construction, not when all operations\n    // has been supplied.\n    //\n    // However for the first block (no parentHash available), we would\n    // just use the as-is\n    return api.queryAt(header.parentHash.isEmpty\n        ? blockHash || header.hash\n        : header.parentHash).pipe(switchMap((queryAt) => getAuthorDetailsWithAt(header, queryAt)));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}