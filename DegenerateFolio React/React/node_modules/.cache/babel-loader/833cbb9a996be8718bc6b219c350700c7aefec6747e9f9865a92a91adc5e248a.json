{"ast":null,"code":"import { u8aToBn } from '@polkadot/util';\nimport { BN_LE_OPTS } from '../bn.js';\nimport { DEFAULT_PARAMS } from './defaults.js';\nexport function scryptFromU8a(data) {\n  const salt = data.subarray(0, 32);\n  const N = u8aToBn(data.subarray(32 + 0, 32 + 4), BN_LE_OPTS).toNumber();\n  const p = u8aToBn(data.subarray(32 + 4, 32 + 8), BN_LE_OPTS).toNumber();\n  const r = u8aToBn(data.subarray(32 + 8, 32 + 12), BN_LE_OPTS).toNumber();\n  // FIXME At this moment we assume these to be fixed params, this is not a great idea\n  // since we lose flexibility and updates for greater security. However we need some\n  // protection against carefully-crafted params that can eat up CPU since these are user\n  // inputs. So we need to get very clever here, but atm we only allow the defaults\n  // and if no match, bail out\n  if (N !== DEFAULT_PARAMS.N || p !== DEFAULT_PARAMS.p || r !== DEFAULT_PARAMS.r) {\n    throw new Error('Invalid injected scrypt params found');\n  }\n  return {\n    params: {\n      N,\n      p,\n      r\n    },\n    salt\n  };\n}","map":{"version":3,"names":["u8aToBn","BN_LE_OPTS","DEFAULT_PARAMS","scryptFromU8a","data","salt","subarray","N","toNumber","p","r","Error","params"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util-crypto/scrypt/fromU8a.js"],"sourcesContent":["import { u8aToBn } from '@polkadot/util';\nimport { BN_LE_OPTS } from '../bn.js';\nimport { DEFAULT_PARAMS } from './defaults.js';\nexport function scryptFromU8a(data) {\n    const salt = data.subarray(0, 32);\n    const N = u8aToBn(data.subarray(32 + 0, 32 + 4), BN_LE_OPTS).toNumber();\n    const p = u8aToBn(data.subarray(32 + 4, 32 + 8), BN_LE_OPTS).toNumber();\n    const r = u8aToBn(data.subarray(32 + 8, 32 + 12), BN_LE_OPTS).toNumber();\n    // FIXME At this moment we assume these to be fixed params, this is not a great idea\n    // since we lose flexibility and updates for greater security. However we need some\n    // protection against carefully-crafted params that can eat up CPU since these are user\n    // inputs. So we need to get very clever here, but atm we only allow the defaults\n    // and if no match, bail out\n    if (N !== DEFAULT_PARAMS.N || p !== DEFAULT_PARAMS.p || r !== DEFAULT_PARAMS.r) {\n        throw new Error('Invalid injected scrypt params found');\n    }\n    return { params: { N, p, r }, salt };\n}\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,gBAAgB;AACxC,SAASC,UAAU,QAAQ,UAAU;AACrC,SAASC,cAAc,QAAQ,eAAe;AAC9C,OAAO,SAASC,aAAaA,CAACC,IAAI,EAAE;EAChC,MAAMC,IAAI,GAAGD,IAAI,CAACE,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC;EACjC,MAAMC,CAAC,GAAGP,OAAO,CAACI,IAAI,CAACE,QAAQ,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAEL,UAAU,CAAC,CAACO,QAAQ,CAAC,CAAC;EACvE,MAAMC,CAAC,GAAGT,OAAO,CAACI,IAAI,CAACE,QAAQ,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAEL,UAAU,CAAC,CAACO,QAAQ,CAAC,CAAC;EACvE,MAAME,CAAC,GAAGV,OAAO,CAACI,IAAI,CAACE,QAAQ,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,EAAE,CAAC,EAAEL,UAAU,CAAC,CAACO,QAAQ,CAAC,CAAC;EACxE;EACA;EACA;EACA;EACA;EACA,IAAID,CAAC,KAAKL,cAAc,CAACK,CAAC,IAAIE,CAAC,KAAKP,cAAc,CAACO,CAAC,IAAIC,CAAC,KAAKR,cAAc,CAACQ,CAAC,EAAE;IAC5E,MAAM,IAAIC,KAAK,CAAC,sCAAsC,CAAC;EAC3D;EACA,OAAO;IAAEC,MAAM,EAAE;MAAEL,CAAC;MAAEE,CAAC;MAAEC;IAAE,CAAC;IAAEL;EAAK,CAAC;AACxC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}