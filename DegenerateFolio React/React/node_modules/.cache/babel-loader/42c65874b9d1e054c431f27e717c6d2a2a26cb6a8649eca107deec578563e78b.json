{"ast":null,"code":"import { secp256k1 } from '@noble/curves/secp256k1';\nimport { bnToU8a, hasBigInt, u8aConcat } from '@polkadot/util';\nimport { isReady, secp256k1Sign as wasm } from '@polkadot/wasm-crypto';\nimport { BN_BE_256_OPTS } from '../bn.js';\nimport { hasher } from './hasher.js';\n/**\n * @name secp256k1Sign\n * @description Returns message signature of `message`, using the supplied pair\n */\nexport function secp256k1Sign(message, _ref) {\n  let {\n    secretKey\n  } = _ref;\n  let hashType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'blake2';\n  let onlyJs = arguments.length > 3 ? arguments[3] : undefined;\n  if ((secretKey === null || secretKey === void 0 ? void 0 : secretKey.length) !== 32) {\n    throw new Error('Expected valid secp256k1 secretKey, 32-bytes');\n  }\n  const data = hasher(hashType, message, onlyJs);\n  if (!hasBigInt || !onlyJs && isReady()) {\n    return wasm(data, secretKey);\n  }\n  const signature = secp256k1.sign(data, secretKey, {\n    lowS: true\n  });\n  return u8aConcat(bnToU8a(signature.r, BN_BE_256_OPTS), bnToU8a(signature.s, BN_BE_256_OPTS), new Uint8Array([signature.recovery || 0]));\n}","map":{"version":3,"names":["secp256k1","bnToU8a","hasBigInt","u8aConcat","isReady","secp256k1Sign","wasm","BN_BE_256_OPTS","hasher","message","_ref","secretKey","hashType","arguments","length","undefined","onlyJs","Error","data","signature","sign","lowS","r","s","Uint8Array","recovery"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util-crypto/secp256k1/sign.js"],"sourcesContent":["import { secp256k1 } from '@noble/curves/secp256k1';\nimport { bnToU8a, hasBigInt, u8aConcat } from '@polkadot/util';\nimport { isReady, secp256k1Sign as wasm } from '@polkadot/wasm-crypto';\nimport { BN_BE_256_OPTS } from '../bn.js';\nimport { hasher } from './hasher.js';\n/**\n * @name secp256k1Sign\n * @description Returns message signature of `message`, using the supplied pair\n */\nexport function secp256k1Sign(message, { secretKey }, hashType = 'blake2', onlyJs) {\n    if (secretKey?.length !== 32) {\n        throw new Error('Expected valid secp256k1 secretKey, 32-bytes');\n    }\n    const data = hasher(hashType, message, onlyJs);\n    if (!hasBigInt || (!onlyJs && isReady())) {\n        return wasm(data, secretKey);\n    }\n    const signature = secp256k1.sign(data, secretKey, { lowS: true });\n    return u8aConcat(bnToU8a(signature.r, BN_BE_256_OPTS), bnToU8a(signature.s, BN_BE_256_OPTS), new Uint8Array([signature.recovery || 0]));\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,yBAAyB;AACnD,SAASC,OAAO,EAAEC,SAAS,EAAEC,SAAS,QAAQ,gBAAgB;AAC9D,SAASC,OAAO,EAAEC,aAAa,IAAIC,IAAI,QAAQ,uBAAuB;AACtE,SAASC,cAAc,QAAQ,UAAU;AACzC,SAASC,MAAM,QAAQ,aAAa;AACpC;AACA;AACA;AACA;AACA,OAAO,SAASH,aAAaA,CAACI,OAAO,EAAAC,IAAA,EAA8C;EAAA,IAA5C;IAAEC;EAAU,CAAC,GAAAD,IAAA;EAAA,IAAEE,QAAQ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,QAAQ;EAAA,IAAEG,MAAM,GAAAH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAC7E,IAAI,CAAAJ,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEG,MAAM,MAAK,EAAE,EAAE;IAC1B,MAAM,IAAIG,KAAK,CAAC,8CAA8C,CAAC;EACnE;EACA,MAAMC,IAAI,GAAGV,MAAM,CAACI,QAAQ,EAAEH,OAAO,EAAEO,MAAM,CAAC;EAC9C,IAAI,CAACd,SAAS,IAAK,CAACc,MAAM,IAAIZ,OAAO,CAAC,CAAE,EAAE;IACtC,OAAOE,IAAI,CAACY,IAAI,EAAEP,SAAS,CAAC;EAChC;EACA,MAAMQ,SAAS,GAAGnB,SAAS,CAACoB,IAAI,CAACF,IAAI,EAAEP,SAAS,EAAE;IAAEU,IAAI,EAAE;EAAK,CAAC,CAAC;EACjE,OAAOlB,SAAS,CAACF,OAAO,CAACkB,SAAS,CAACG,CAAC,EAAEf,cAAc,CAAC,EAAEN,OAAO,CAACkB,SAAS,CAACI,CAAC,EAAEhB,cAAc,CAAC,EAAE,IAAIiB,UAAU,CAAC,CAACL,SAAS,CAACM,QAAQ,IAAI,CAAC,CAAC,CAAC,CAAC;AAC3I","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}