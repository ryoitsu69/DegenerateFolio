{"ast":null,"code":"\"use strict\";\n\nconst localUniformMSDFBit = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: ( /* wgsl */\n    `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `),\n    main: ( /* wgsl */\n    `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `),\n    end: ( /* wgsl */\n    `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `)\n  },\n  fragment: {\n    header: ( /* wgsl */\n    `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `),\n    main: ( /* wgsl */\n    ` \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        `)\n  }\n};\nconst localUniformMSDFBitGl = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: ( /* glsl */\n    `\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `),\n    main: ( /* glsl */\n    `\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `),\n    end: ( /* glsl */\n    `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `)\n  },\n  fragment: {\n    header: ( /* glsl */\n    `\n            uniform float uDistance;\n         `),\n    main: ( /* glsl */\n    ` \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        `)\n  }\n};\nexport { localUniformMSDFBit, localUniformMSDFBitGl };","map":{"version":3,"names":["localUniformMSDFBit","name","vertex","header","main","end","fragment","localUniformMSDFBitGl"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts"],"sourcesContent":["// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */` \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        `\n\n    }\n};\n\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */` \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        `\n\n    }\n};\n"],"mappings":";;AAGO,MAAMA,mBAAsB;EAC/BC,IAAM;EACNC,MAAQ;IACJC,MAAA;IAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAUlBC,IAAA;IAAgB;AAAA;AAAA;AAAA;IAIhBC,GAAA;IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;EAAA,CAMnB;EACAC,QAAU;IACNH,MAAA;IAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IASlBC,IAAA;IAAgB;AAAA;AAAA;EAAA;AAKxB;AAEO,MAAMG,qBAAwB;EACjCN,IAAM;EACNC,MAAQ;IACJC,MAAA;IAAkB;AAAA;AAAA;AAAA;AAAA;IAKlBC,IAAA;IAAgB;AAAA;AAAA;AAAA;IAIhBC,GAAA;IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;EAAA,CAMnB;EACAC,QAAU;IACNH,MAAA;IAAkB;AAAA;AAAA;IAGlBC,IAAA;IAAgB;AAAA;AAAA;EAAA;AAKxB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}