{"ast":null,"code":"import { Option } from '@polkadot/types-codec';\nimport { isHex, isU8a, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { createClassUnsafe } from './class.js';\nfunction checkInstance(created, matcher) {\n  const u8a = created.toU8a();\n  const rawType = created.toRawType();\n  const isOk =\n  // full match, all ok\n  u8aEq(u8a, matcher) ||\n  // on a length-prefixed type, just check the actual length\n  ['Bytes', 'Text', 'Type'].includes(rawType) && matcher.length === created.length ||\n  // when the created is empty and matcher is also empty, let it slide...\n  created.isEmpty && matcher.every(v => !v);\n  if (!isOk) {\n    throw new Error(\"\".concat(rawType, \":: Decoded input doesn't match input, received \").concat(u8aToHex(matcher, 512), \" (\").concat(matcher.length, \" bytes), created \").concat(u8aToHex(u8a, 512), \" (\").concat(u8a.length, \" bytes)\"));\n  }\n}\nfunction checkPedantic(created, _ref) {\n  let [value] = _ref;\n  if (isU8a(value)) {\n    checkInstance(created, value);\n  } else if (isHex(value)) {\n    checkInstance(created, u8aToU8a(value));\n  }\n}\nfunction initType(registry, Type) {\n  let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let {\n    blockHash,\n    isFallback,\n    isOptional,\n    isPedantic\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const created = new (isOptional ? Option.with(Type) : Type)(registry, ...params);\n  isPedantic && checkPedantic(created, params);\n  if (blockHash) {\n    created.createdAtHash = createTypeUnsafe(registry, 'BlockHash', [blockHash]);\n  }\n  if (isFallback) {\n    created.isStorageFallback = true;\n  }\n  return created;\n}\nexport function createTypeUnsafe(registry, type) {\n  var _Clazz;\n  let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let Clazz = null;\n  let firstError = null;\n  try {\n    Clazz = createClassUnsafe(registry, type);\n    return initType(registry, Clazz, params, options);\n  } catch (error) {\n    firstError = new Error(\"createType(\".concat(type, \"):: \").concat(error.message));\n  }\n  if ((_Clazz = Clazz) !== null && _Clazz !== void 0 && _Clazz.__fallbackType) {\n    try {\n      Clazz = createClassUnsafe(registry, Clazz.__fallbackType);\n      return initType(registry, Clazz, params, options);\n    } catch {\n      // swallow, we will throw the first error again\n    }\n  }\n  throw firstError;\n}","map":{"version":3,"names":["Option","isHex","isU8a","u8aEq","u8aToHex","u8aToU8a","createClassUnsafe","checkInstance","created","matcher","u8a","toU8a","rawType","toRawType","isOk","includes","length","isEmpty","every","v","Error","concat","checkPedantic","_ref","value","initType","registry","Type","params","arguments","undefined","blockHash","isFallback","isOptional","isPedantic","with","createdAtHash","createTypeUnsafe","isStorageFallback","type","_Clazz","options","Clazz","firstError","error","message","__fallbackType"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-create/create/type.js"],"sourcesContent":["import { Option } from '@polkadot/types-codec';\nimport { isHex, isU8a, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { createClassUnsafe } from './class.js';\nfunction checkInstance(created, matcher) {\n    const u8a = created.toU8a();\n    const rawType = created.toRawType();\n    const isOk = (\n    // full match, all ok\n    u8aEq(u8a, matcher) ||\n        (\n        // on a length-prefixed type, just check the actual length\n        ['Bytes', 'Text', 'Type'].includes(rawType) &&\n            matcher.length === created.length) ||\n        (\n        // when the created is empty and matcher is also empty, let it slide...\n        created.isEmpty &&\n            matcher.every((v) => !v)));\n    if (!isOk) {\n        throw new Error(`${rawType}:: Decoded input doesn't match input, received ${u8aToHex(matcher, 512)} (${matcher.length} bytes), created ${u8aToHex(u8a, 512)} (${u8a.length} bytes)`);\n    }\n}\nfunction checkPedantic(created, [value]) {\n    if (isU8a(value)) {\n        checkInstance(created, value);\n    }\n    else if (isHex(value)) {\n        checkInstance(created, u8aToU8a(value));\n    }\n}\nfunction initType(registry, Type, params = [], { blockHash, isFallback, isOptional, isPedantic } = {}) {\n    const created = new (isOptional\n        ? Option.with(Type)\n        : Type)(registry, ...params);\n    isPedantic && checkPedantic(created, params);\n    if (blockHash) {\n        created.createdAtHash = createTypeUnsafe(registry, 'BlockHash', [blockHash]);\n    }\n    if (isFallback) {\n        created.isStorageFallback = true;\n    }\n    return created;\n}\nexport function createTypeUnsafe(registry, type, params = [], options = {}) {\n    let Clazz = null;\n    let firstError = null;\n    try {\n        Clazz = createClassUnsafe(registry, type);\n        return initType(registry, Clazz, params, options);\n    }\n    catch (error) {\n        firstError = new Error(`createType(${type}):: ${error.message}`);\n    }\n    if (Clazz?.__fallbackType) {\n        try {\n            Clazz = createClassUnsafe(registry, Clazz.__fallbackType);\n            return initType(registry, Clazz, params, options);\n        }\n        catch {\n            // swallow, we will throw the first error again\n        }\n    }\n    throw firstError;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}