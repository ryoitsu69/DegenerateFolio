{"ast":null,"code":"import { CLEAR_MODES, DRAW_MODES, MSAA_QUALITY } from \"@pixi/constants\";\nimport { ExtensionType, extensions } from \"@pixi/extensions\";\nimport { Point, Matrix, Rectangle } from \"@pixi/math\";\nimport { RenderTexturePool } from \"../renderTexture/RenderTexturePool.mjs\";\nimport { UniformGroup } from \"../shader/UniformGroup.mjs\";\nimport { Quad } from \"../utils/Quad.mjs\";\nimport { QuadUv } from \"../utils/QuadUv.mjs\";\nimport { FilterState } from \"./FilterState.mjs\";\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()],\n  tempMatrix = new Matrix();\nclass FilterSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.defaultFilterStack = [{}], this.texturePool = new RenderTexturePool(), this.statePool = [], this.quad = new Quad(), this.quadUv = new QuadUv(), this.tempRect = new Rectangle(), this.activeState = {}, this.globalUniforms = new UniformGroup({\n      outputFrame: new Rectangle(),\n      inputSize: new Float32Array(4),\n      inputPixel: new Float32Array(4),\n      inputClamp: new Float32Array(4),\n      resolution: 1,\n      // legacy variables\n      filterArea: new Float32Array(4),\n      filterClamp: new Float32Array(4)\n    }, !0), this.forceClear = !1, this.useMaxPadding = !1;\n  }\n  init() {\n    this.texturePool.setScreenSize(this.renderer.view);\n  }\n  /**\n   * Pushes a set of filters to be applied later to the system. This will redirect further rendering into an\n   * input render-texture for the rest of the filtering pipeline.\n   * @param {PIXI.DisplayObject} target - The target of the filter to render.\n   * @param filters - The filters to apply.\n   */\n  push(target, filters) {\n    const renderer = this.renderer,\n      filterStack = this.defaultFilterStack,\n      state = this.statePool.pop() || new FilterState(),\n      renderTextureSystem = renderer.renderTexture;\n    let currentResolution, currentMultisample;\n    if (renderTextureSystem.current) {\n      const renderTexture = renderTextureSystem.current;\n      currentResolution = renderTexture.resolution, currentMultisample = renderTexture.multisample;\n    } else currentResolution = renderer.resolution, currentMultisample = renderer.multisample;\n    let resolution = filters[0].resolution || currentResolution,\n      multisample = filters[0].multisample ?? currentMultisample,\n      padding = filters[0].padding,\n      autoFit = filters[0].autoFit,\n      legacy = filters[0].legacy ?? !0;\n    for (let i = 1; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution || currentResolution), multisample = Math.min(multisample, filter.multisample ?? currentMultisample), padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding, autoFit = autoFit && filter.autoFit, legacy = legacy || (filter.legacy ?? !0);\n    }\n    filterStack.length === 1 && (this.defaultFilterStack[0].renderTexture = renderTextureSystem.current), filterStack.push(state), state.resolution = resolution, state.multisample = multisample, state.legacy = legacy, state.target = target, state.sourceFrame.copyFrom(target.filterArea || target.getBounds(!0)), state.sourceFrame.pad(padding);\n    const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);\n    renderer.projection.transform && this.transformAABB(tempMatrix.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected), autoFit ? (state.sourceFrame.fit(sourceFrameProjected), (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) && (state.sourceFrame.width = 0, state.sourceFrame.height = 0)) : state.sourceFrame.intersects(sourceFrameProjected) || (state.sourceFrame.width = 0, state.sourceFrame.height = 0), this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform), state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample), state.filters = filters, state.destinationFrame.width = state.renderTexture.width, state.destinationFrame.height = state.renderTexture.height;\n    const destinationFrame = this.tempRect;\n    destinationFrame.x = 0, destinationFrame.y = 0, destinationFrame.width = state.sourceFrame.width, destinationFrame.height = state.sourceFrame.height, state.renderTexture.filterFrame = state.sourceFrame, state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame), state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame), state.transform = renderer.projection.transform, renderer.projection.transform = null, renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame), renderer.framebuffer.clear(0, 0, 0, 0);\n  }\n  /** Pops off the filter and applies it. */\n  pop() {\n    const filterStack = this.defaultFilterStack,\n      state = filterStack.pop(),\n      filters = state.filters;\n    this.activeState = state;\n    const globalUniforms = this.globalUniforms.uniforms;\n    globalUniforms.outputFrame = state.sourceFrame, globalUniforms.resolution = state.resolution;\n    const inputSize = globalUniforms.inputSize,\n      inputPixel = globalUniforms.inputPixel,\n      inputClamp = globalUniforms.inputClamp;\n    if (inputSize[0] = state.destinationFrame.width, inputSize[1] = state.destinationFrame.height, inputSize[2] = 1 / inputSize[0], inputSize[3] = 1 / inputSize[1], inputPixel[0] = Math.round(inputSize[0] * state.resolution), inputPixel[1] = Math.round(inputSize[1] * state.resolution), inputPixel[2] = 1 / inputPixel[0], inputPixel[3] = 1 / inputPixel[1], inputClamp[0] = 0.5 * inputPixel[2], inputClamp[1] = 0.5 * inputPixel[3], inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2], inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3], state.legacy) {\n      const filterArea = globalUniforms.filterArea;\n      filterArea[0] = state.destinationFrame.width, filterArea[1] = state.destinationFrame.height, filterArea[2] = state.sourceFrame.x, filterArea[3] = state.sourceFrame.y, globalUniforms.filterClamp = globalUniforms.inputClamp;\n    }\n    this.globalUniforms.update();\n    const lastState = filterStack[filterStack.length - 1];\n    if (this.renderer.framebuffer.blit(), filters.length === 1) filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state), this.returnFilterTexture(state.renderTexture);else {\n      let flip = state.renderTexture,\n        flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);\n      flop.filterFrame = flip.filterFrame;\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        i === 1 && state.multisample > 1 && (flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution), flop.filterFrame = flip.filterFrame), filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);\n        const t = flip;\n        flip = flop, flop = t;\n      }\n      filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state), i > 1 && state.multisample > 1 && this.returnFilterTexture(state.renderTexture), this.returnFilterTexture(flip), this.returnFilterTexture(flop);\n    }\n    state.clear(), this.statePool.push(state);\n  }\n  /**\n   * Binds a renderTexture with corresponding `filterFrame`, clears it if mode corresponds.\n   * @param filterTexture - renderTexture to bind, should belong to filter pool or filter stack\n   * @param clearMode - clearMode, by default its CLEAR/YES. See {@link PIXI.CLEAR_MODES}\n   */\n  bindAndClear(filterTexture, clearMode = CLEAR_MODES.CLEAR) {\n    const {\n      renderTexture: renderTextureSystem,\n      state: stateSystem\n    } = this.renderer;\n    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, filterTexture?.filterFrame) {\n      const destinationFrame = this.tempRect;\n      destinationFrame.x = 0, destinationFrame.y = 0, destinationFrame.width = filterTexture.filterFrame.width, destinationFrame.height = filterTexture.filterFrame.height, renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);\n    } else filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? renderTextureSystem.bind(filterTexture) : this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);\n    const autoClear = stateSystem.stateId & 1 || this.forceClear;\n    (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) && this.renderer.framebuffer.clear(0, 0, 0, 0);\n  }\n  /**\n   * Draws a filter using the default rendering process.\n   *\n   * This should be called only by {@link PIXI.Filter#apply}.\n   * @param filter - The filter to draw.\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  applyFilter(filter, input, output, clearMode) {\n    const renderer = this.renderer;\n    renderer.state.set(filter.state), this.bindAndClear(output, clearMode), filter.uniforms.uSampler = input, filter.uniforms.filterGlobals = this.globalUniforms, renderer.shader.bind(filter), filter.legacy = !!filter.program.attributeData.aTextureCoord, filter.legacy ? (this.quadUv.map(input._frame, input.filterFrame), renderer.geometry.bind(this.quadUv), renderer.geometry.draw(DRAW_MODES.TRIANGLES)) : (renderer.geometry.bind(this.quad), renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP));\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {PIXI.Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const {\n        sourceFrame,\n        destinationFrame\n      } = this.activeState,\n      {\n        orig\n      } = sprite._texture,\n      mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y),\n      worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);\n    return worldTransform.invert(), mappedMatrix.prepend(worldTransform), mappedMatrix.scale(1 / orig.width, 1 / orig.height), mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y), mappedMatrix;\n  }\n  /** Destroys this Filter System. */\n  destroy() {\n    this.renderer = null, this.texturePool.clear(!1);\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture in real pixels.\n   * @param minHeight - The minimum height of the render texture in real pixels.\n   * @param resolution - The resolution of the render texture.\n   * @param multisample - Number of samples of the render texture.\n   * @returns - The new render texture.\n   */\n  getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {\n    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);\n  }\n  /**\n   * Gets extra render texture to use inside current filter\n   * To be compliant with older filters, you can use params in any order\n   * @param input - renderTexture from which size and resolution will be copied\n   * @param resolution - override resolution of the renderTexture\n   * @param multisample - number of samples of the renderTexture\n   */\n  getFilterTexture(input, resolution, multisample) {\n    if (typeof input == \"number\") {\n      const swap = input;\n      input = resolution, resolution = swap;\n    }\n    input = input || this.activeState.renderTexture;\n    const filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);\n    return filterTexture.filterFrame = input.filterFrame, filterTexture;\n  }\n  /**\n   * Frees a render texture back into the pool.\n   * @param renderTexture - The renderTarget to free\n   */\n  returnFilterTexture(renderTexture) {\n    this.texturePool.returnTexture(renderTexture);\n  }\n  /** Empties the texture pool. */\n  emptyPool() {\n    this.texturePool.clear(!0);\n  }\n  /** Calls `texturePool.resize()`, affects fullScreen renderTextures. */\n  resize() {\n    this.texturePool.setScreenSize(this.renderer.view);\n  }\n  /**\n   * @param matrix - first param\n   * @param rect - second param\n   */\n  transformAABB(matrix, rect) {\n    const lt = tempPoints[0],\n      lb = tempPoints[1],\n      rt = tempPoints[2],\n      rb = tempPoints[3];\n    lt.set(rect.left, rect.top), lb.set(rect.left, rect.bottom), rt.set(rect.right, rect.top), rb.set(rect.right, rect.bottom), matrix.apply(lt, lt), matrix.apply(lb, lb), matrix.apply(rt, rt), matrix.apply(rb, rb);\n    const x0 = Math.min(lt.x, lb.x, rt.x, rb.x),\n      y0 = Math.min(lt.y, lb.y, rt.y, rb.y),\n      x1 = Math.max(lt.x, lb.x, rt.x, rb.x),\n      y1 = Math.max(lt.y, lb.y, rt.y, rb.y);\n    rect.x = x0, rect.y = y0, rect.width = x1 - x0, rect.height = y1 - y0;\n  }\n  roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n    if (!(frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0)) {\n      if (transform) {\n        const {\n          a,\n          b,\n          c,\n          d\n        } = transform;\n        if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4)) return;\n      }\n      transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity(), transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y), this.transformAABB(transform, frame), frame.ceil(resolution), this.transformAABB(transform.invert(), frame);\n    }\n  }\n}\nFilterSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"filter\"\n};\nextensions.add(FilterSystem);\nexport { FilterSystem };","map":{"version":3,"names":["tempPoints","Point","tempMatrix","Matrix","FilterSystem","constructor","renderer","defaultFilterStack","texturePool","RenderTexturePool","statePool","quad","Quad","quadUv","QuadUv","tempRect","Rectangle","activeState","globalUniforms","UniformGroup","outputFrame","inputSize","Float32Array","inputPixel","inputClamp","resolution","filterArea","filterClamp","forceClear","useMaxPadding","init","setScreenSize","view","push","target","filters","filterStack","state","pop","FilterState","renderTextureSystem","renderTexture","currentResolution","currentMultisample","current","multisample","padding","autoFit","legacy","i","length","filter","Math","min","max","sourceFrame","copyFrom","getBounds","pad","sourceFrameProjected","projection","transform","transformAABB","invert","fit","width","height","intersects","roundFrame","destinationFrame","getOptimalFilterTexture","x","y","filterFrame","bindingSourceFrame","bindingDestinationFrame","bind","framebuffer","clear","uniforms","round","update","lastState","blit","apply","CLEAR_MODES","BLEND","returnFilterTexture","flip","flop","CLEAR","t","bindAndClear","filterTexture","clearMode","stateSystem","autoClear","stateId","BLIT","applyFilter","input","output","set","uSampler","filterGlobals","shader","program","attributeData","aTextureCoord","map","_frame","geometry","draw","DRAW_MODES","TRIANGLES","TRIANGLE_STRIP","calculateSpriteMatrix","outputMatrix","sprite","orig","_texture","mappedMatrix","worldTransform","copyTo","TEMP_MATRIX","prepend","scale","translate","anchor","destroy","minWidth","minHeight","MSAA_QUALITY","NONE","getOptimalTexture","getFilterTexture","swap","returnTexture","emptyPool","resize","matrix","rect","lt","lb","rt","rb","left","top","bottom","right","x0","y0","x1","y1","frame","a","b","c","d","abs","identity","ceil","extension","type","ExtensionType","RendererSystem","name","extensions","add"],"sources":["/home/ryoitsu/node_modules/@pixi/core/src/filters/FilterSystem.ts"],"sourcesContent":["import { CLEAR_MODES, DRAW_MODES, MSAA_QUALITY } from '@pixi/constants';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport { Matrix, Point, Rectangle } from '@pixi/math';\nimport { RenderTexturePool } from '../renderTexture/RenderTexturePool';\nimport { UniformGroup } from '../shader/UniformGroup';\nimport { Quad } from '../utils/Quad';\nimport { QuadUv } from '../utils/QuadUv';\nimport { FilterState } from './FilterState';\n\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { Renderer } from '../Renderer';\nimport type { RenderTexture } from '../renderTexture/RenderTexture';\nimport type { ISystem } from '../system/ISystem';\nimport type { Filter } from './Filter';\nimport type { IFilterTarget } from './IFilterTarget';\nimport type { ISpriteMaskTarget } from './spriteMask/SpriteMaskFilter';\n\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\nconst tempMatrix = new Matrix();\n\n/**\n * System plugin to the renderer to manage filters.\n *\n * ## Pipeline\n *\n * The FilterSystem executes the filtering pipeline by rendering the display-object into a texture, applying its\n * [filters]{@link PIXI.Filter} in series, and the last filter outputs into the final render-target.\n *\n * The filter-frame is the rectangle in world space being filtered, and those contents are mapped into\n * `(0, 0, filterFrame.width, filterFrame.height)` into the filter render-texture. The filter-frame is also called\n * the source-frame, as it is used to bind the filter render-textures. The last filter outputs to the `filterFrame`\n * in the final render-target.\n *\n * ## Usage\n *\n * {@link PIXI.Container#renderAdvanced} is an example of how to use the filter system. It is a 3 step process:\n *\n * **push**: Use {@link PIXI.FilterSystem#push} to push the set of filters to be applied on a filter-target.\n * **render**: Render the contents to be filtered using the renderer. The filter-system will only capture the contents\n *      inside the bounds of the filter-target. NOTE: Using {@link PIXI.Renderer#render} is\n *      illegal during an existing render cycle, and it may reset the filter system.\n * **pop**: Use {@link PIXI.FilterSystem#pop} to pop & execute the filters you initially pushed. It will apply them\n *      serially and output to the bounds of the filter-target.\n * @memberof PIXI\n */\nexport class FilterSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'filter',\n    };\n\n    /**\n     * List of filters for the FilterSystem\n     * @member {object[]}\n     */\n    public readonly defaultFilterStack: Array<FilterState>;\n\n    /** A pool for storing filter states, save us creating new ones each tick. */\n    public statePool: Array<FilterState>;\n\n    /** Stores a bunch of POT textures used for filtering. */\n    public texturePool: RenderTexturePool;\n\n    /** Whether to clear output renderTexture in AUTO/BLIT mode. See {@link PIXI.CLEAR_MODES}. */\n    public forceClear: boolean;\n\n    /**\n     * Old padding behavior is to use the max amount instead of sum padding.\n     * Use this flag if you need the old behavior.\n     * @default false\n     */\n    public useMaxPadding: boolean;\n\n    /** A very simple geometry used when drawing a filter effect to the screen. */\n    protected quad: Quad;\n\n    /** Quad UVs */\n    protected quadUv: QuadUv;\n\n    /**\n     * Active state\n     * @member {object}\n     */\n    protected activeState: FilterState;\n\n    /**\n     * This uniform group is attached to filter uniforms when used.\n     * @property {PIXI.Rectangle} outputFrame -\n     * @property {Float32Array} inputSize -\n     * @property {Float32Array} inputPixel -\n     * @property {Float32Array} inputClamp -\n     * @property {number} resolution -\n     * @property {Float32Array} filterArea -\n     * @property {Float32Array} filterClamp -\n     */\n    protected globalUniforms: UniformGroup;\n\n    /** Temporary rect for math. */\n    private tempRect: Rectangle;\n    public renderer: Renderer;\n\n    /**\n     * @param renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n\n        this.defaultFilterStack = [{}] as any;\n\n        this.texturePool = new RenderTexturePool();\n\n        this.statePool = [];\n\n        this.quad = new Quad();\n        this.quadUv = new QuadUv();\n        this.tempRect = new Rectangle();\n        this.activeState = {} as any;\n\n        this.globalUniforms = new UniformGroup({\n            outputFrame: new Rectangle(),\n            inputSize: new Float32Array(4),\n            inputPixel: new Float32Array(4),\n            inputClamp: new Float32Array(4),\n            resolution: 1,\n\n            // legacy variables\n            filterArea: new Float32Array(4),\n            filterClamp: new Float32Array(4),\n        }, true);\n\n        this.forceClear = false;\n        this.useMaxPadding = false;\n    }\n\n    init(): void\n    {\n        this.texturePool.setScreenSize(this.renderer.view);\n    }\n\n    /**\n     * Pushes a set of filters to be applied later to the system. This will redirect further rendering into an\n     * input render-texture for the rest of the filtering pipeline.\n     * @param {PIXI.DisplayObject} target - The target of the filter to render.\n     * @param filters - The filters to apply.\n     */\n    push(target: IFilterTarget, filters: Array<Filter>): void\n    {\n        const renderer = this.renderer;\n        const filterStack = this.defaultFilterStack;\n        const state = this.statePool.pop() || new FilterState();\n        const renderTextureSystem = renderer.renderTexture;\n        let currentResolution: number;\n        let currentMultisample: MSAA_QUALITY;\n\n        if (renderTextureSystem.current)\n        {\n            const renderTexture = renderTextureSystem.current;\n\n            currentResolution = renderTexture.resolution;\n            currentMultisample = renderTexture.multisample;\n        }\n        else\n        {\n            currentResolution = renderer.resolution;\n            currentMultisample = renderer.multisample;\n        }\n\n        let resolution = filters[0].resolution || currentResolution;\n        let multisample = filters[0].multisample ?? currentMultisample;\n        let padding = filters[0].padding;\n        let autoFit = filters[0].autoFit;\n        // We don't know whether it's a legacy filter until it was bound for the first time,\n        // therefore we have to assume that it is if legacy is undefined.\n        let legacy = filters[0].legacy ?? true;\n\n        for (let i = 1; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            // let's use the lowest resolution\n            resolution = Math.min(resolution, filter.resolution || currentResolution);\n            // let's use the lowest number of samples\n            multisample = Math.min(multisample, filter.multisample ?? currentMultisample);\n            // figure out the padding required for filters\n            padding = this.useMaxPadding\n                // old behavior: use largest amount of padding!\n                ? Math.max(padding, filter.padding)\n                // new behavior: sum the padding\n                : padding + filter.padding;\n            // only auto fit if all filters are autofit\n            autoFit = autoFit && filter.autoFit;\n\n            legacy = legacy || (filter.legacy ?? true);\n        }\n\n        if (filterStack.length === 1)\n        {\n            this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;\n        }\n\n        filterStack.push(state);\n\n        state.resolution = resolution;\n        state.multisample = multisample;\n\n        state.legacy = legacy;\n\n        state.target = target;\n        state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));\n\n        state.sourceFrame.pad(padding);\n\n        const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);\n\n        // Project source frame into world space (if projection is applied)\n        if (renderer.projection.transform)\n        {\n            this.transformAABB(\n                tempMatrix.copyFrom(renderer.projection.transform).invert(),\n                sourceFrameProjected\n            );\n        }\n\n        if (autoFit)\n        {\n            state.sourceFrame.fit(sourceFrameProjected);\n\n            if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0)\n            {\n                state.sourceFrame.width = 0;\n                state.sourceFrame.height = 0;\n            }\n        }\n        else if (!state.sourceFrame.intersects(sourceFrameProjected))\n        {\n            state.sourceFrame.width = 0;\n            state.sourceFrame.height = 0;\n        }\n\n        // Round sourceFrame in screen space based on render-texture.\n        this.roundFrame(\n            state.sourceFrame,\n            renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,\n            renderTextureSystem.sourceFrame,\n            renderTextureSystem.destinationFrame,\n            renderer.projection.transform,\n        );\n\n        state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height,\n            resolution, multisample);\n        state.filters = filters;\n\n        state.destinationFrame.width = state.renderTexture.width;\n        state.destinationFrame.height = state.renderTexture.height;\n\n        const destinationFrame = this.tempRect;\n\n        destinationFrame.x = 0;\n        destinationFrame.y = 0;\n        destinationFrame.width = state.sourceFrame.width;\n        destinationFrame.height = state.sourceFrame.height;\n\n        state.renderTexture.filterFrame = state.sourceFrame;\n        state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);\n        state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);\n\n        state.transform = renderer.projection.transform;\n        renderer.projection.transform = null;\n        renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);\n        renderer.framebuffer.clear(0, 0, 0, 0);\n    }\n\n    /** Pops off the filter and applies it. */\n    pop(): void\n    {\n        const filterStack = this.defaultFilterStack;\n        const state = filterStack.pop();\n        const filters = state.filters;\n\n        this.activeState = state;\n\n        const globalUniforms = this.globalUniforms.uniforms;\n\n        globalUniforms.outputFrame = state.sourceFrame;\n        globalUniforms.resolution = state.resolution;\n\n        const inputSize = globalUniforms.inputSize;\n        const inputPixel = globalUniforms.inputPixel;\n        const inputClamp = globalUniforms.inputClamp;\n\n        inputSize[0] = state.destinationFrame.width;\n        inputSize[1] = state.destinationFrame.height;\n        inputSize[2] = 1.0 / inputSize[0];\n        inputSize[3] = 1.0 / inputSize[1];\n\n        inputPixel[0] = Math.round(inputSize[0] * state.resolution);\n        inputPixel[1] = Math.round(inputSize[1] * state.resolution);\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (state.sourceFrame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (state.sourceFrame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        // only update the rect if its legacy..\n        if (state.legacy)\n        {\n            const filterArea = globalUniforms.filterArea;\n\n            filterArea[0] = state.destinationFrame.width;\n            filterArea[1] = state.destinationFrame.height;\n            filterArea[2] = state.sourceFrame.x;\n            filterArea[3] = state.sourceFrame.y;\n\n            globalUniforms.filterClamp = globalUniforms.inputClamp;\n        }\n\n        this.globalUniforms.update();\n\n        const lastState = filterStack[filterStack.length - 1];\n\n        this.renderer.framebuffer.blit();\n\n        if (filters.length === 1)\n        {\n            filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);\n\n            this.returnFilterTexture(state.renderTexture);\n        }\n        else\n        {\n            let flip = state.renderTexture;\n            let flop = this.getOptimalFilterTexture(\n                flip.width,\n                flip.height,\n                state.resolution\n            );\n\n            flop.filterFrame = flip.filterFrame;\n\n            let i = 0;\n\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                if (i === 1 && state.multisample > 1)\n                {\n                    flop = this.getOptimalFilterTexture(\n                        flip.width,\n                        flip.height,\n                        state.resolution\n                    );\n\n                    flop.filterFrame = flip.filterFrame;\n                }\n\n                filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);\n\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);\n\n            if (i > 1 && state.multisample > 1)\n            {\n                this.returnFilterTexture(state.renderTexture);\n            }\n\n            this.returnFilterTexture(flip);\n            this.returnFilterTexture(flop);\n        }\n\n        // lastState.renderTexture is blitted when lastState is popped\n\n        state.clear();\n        this.statePool.push(state);\n    }\n\n    /**\n     * Binds a renderTexture with corresponding `filterFrame`, clears it if mode corresponds.\n     * @param filterTexture - renderTexture to bind, should belong to filter pool or filter stack\n     * @param clearMode - clearMode, by default its CLEAR/YES. See {@link PIXI.CLEAR_MODES}\n     */\n    bindAndClear(filterTexture: RenderTexture, clearMode: CLEAR_MODES = CLEAR_MODES.CLEAR): void\n    {\n        const {\n            renderTexture: renderTextureSystem,\n            state: stateSystem,\n        } = this.renderer;\n\n        if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture)\n        {\n            // Restore projection transform if rendering into the output render-target.\n            this.renderer.projection.transform = this.activeState.transform;\n        }\n        else\n        {\n            // Prevent projection within filtering pipeline.\n            this.renderer.projection.transform = null;\n        }\n\n        if (filterTexture?.filterFrame)\n        {\n            const destinationFrame = this.tempRect;\n\n            destinationFrame.x = 0;\n            destinationFrame.y = 0;\n            destinationFrame.width = filterTexture.filterFrame.width;\n            destinationFrame.height = filterTexture.filterFrame.height;\n\n            renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);\n        }\n        else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture)\n        {\n            renderTextureSystem.bind(filterTexture);\n        }\n        else\n        {\n            // Restore binding for output render-target.\n            this.renderer.renderTexture.bind(\n                filterTexture,\n                this.activeState.bindingSourceFrame,\n                this.activeState.bindingDestinationFrame\n            );\n        }\n\n        // Clear the texture in BLIT mode if blending is disabled or the forceClear flag is set. The blending\n        // is stored in the 0th bit of the state.\n        const autoClear = (stateSystem.stateId & 1) || this.forceClear;\n\n        if (clearMode === CLEAR_MODES.CLEAR\n            || (clearMode === CLEAR_MODES.BLIT && autoClear))\n        {\n            // Use framebuffer.clear because we want to clear the whole filter texture, not just the filtering\n            // area over which the shaders are run. This is because filters may sampling outside of it (e.g. blur)\n            // instead of clamping their arithmetic.\n            this.renderer.framebuffer.clear(0, 0, 0, 0);\n        }\n    }\n\n    /**\n     * Draws a filter using the default rendering process.\n     *\n     * This should be called only by {@link PIXI.Filter#apply}.\n     * @param filter - The filter to draw.\n     * @param input - The input render target.\n     * @param output - The target to output to.\n     * @param clearMode - Should the output be cleared before rendering to it\n     */\n    applyFilter(filter: Filter, input: RenderTexture, output: RenderTexture, clearMode?: CLEAR_MODES): void\n    {\n        const renderer = this.renderer;\n\n        // Set state before binding, so bindAndClear gets the blend mode.\n        renderer.state.set(filter.state);\n        this.bindAndClear(output, clearMode);\n\n        // set the uniforms..\n        filter.uniforms.uSampler = input;\n        filter.uniforms.filterGlobals = this.globalUniforms;\n\n        // TODO make it so that the order of this does not matter..\n        // because it does at the moment cos of global uniforms.\n        // they need to get resynced\n        renderer.shader.bind(filter);\n\n        // check to see if the filter is a legacy one..\n        filter.legacy = !!filter.program.attributeData.aTextureCoord;\n\n        if (filter.legacy)\n        {\n            this.quadUv.map(input._frame, input.filterFrame);\n\n            renderer.geometry.bind(this.quadUv);\n            renderer.geometry.draw(DRAW_MODES.TRIANGLES);\n        }\n        else\n        {\n            renderer.geometry.bind(this.quad);\n            renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);\n        }\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {PIXI.Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    calculateSpriteMatrix(outputMatrix: Matrix, sprite: ISpriteMaskTarget): Matrix\n    {\n        const { sourceFrame, destinationFrame } = this.activeState;\n        const { orig } = sprite._texture;\n        const mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0,\n            destinationFrame.height, sourceFrame.x, sourceFrame.y);\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(1.0 / orig.width, 1.0 / orig.height);\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    /** Destroys this Filter System. */\n    destroy(): void\n    {\n        this.renderer = null;\n\n        // Those textures has to be destroyed by RenderTextureSystem or FramebufferSystem\n        this.texturePool.clear(false);\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture in real pixels.\n     * @param minHeight - The minimum height of the render texture in real pixels.\n     * @param resolution - The resolution of the render texture.\n     * @param multisample - Number of samples of the render texture.\n     * @returns - The new render texture.\n     */\n    protected getOptimalFilterTexture(minWidth: number, minHeight: number, resolution = 1,\n        multisample: MSAA_QUALITY = MSAA_QUALITY.NONE): RenderTexture\n    {\n        return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);\n    }\n\n    /**\n     * Gets extra render texture to use inside current filter\n     * To be compliant with older filters, you can use params in any order\n     * @param input - renderTexture from which size and resolution will be copied\n     * @param resolution - override resolution of the renderTexture\n     * @param multisample - number of samples of the renderTexture\n     */\n    getFilterTexture(input?: RenderTexture, resolution?: number, multisample?: MSAA_QUALITY): RenderTexture\n    {\n        if (typeof input === 'number')\n        {\n            const swap = input;\n\n            input = resolution as any;\n            resolution = swap;\n        }\n\n        input = input || this.activeState.renderTexture;\n\n        const filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution,\n            multisample || MSAA_QUALITY.NONE);\n\n        filterTexture.filterFrame = input.filterFrame;\n\n        return filterTexture;\n    }\n\n    /**\n     * Frees a render texture back into the pool.\n     * @param renderTexture - The renderTarget to free\n     */\n    returnFilterTexture(renderTexture: RenderTexture): void\n    {\n        this.texturePool.returnTexture(renderTexture);\n    }\n\n    /** Empties the texture pool. */\n    emptyPool(): void\n    {\n        this.texturePool.clear(true);\n    }\n\n    /** Calls `texturePool.resize()`, affects fullScreen renderTextures. */\n    resize(): void\n    {\n        this.texturePool.setScreenSize(this.renderer.view);\n    }\n\n    /**\n     * @param matrix - first param\n     * @param rect - second param\n     */\n    private transformAABB(matrix: Matrix, rect: Rectangle): void\n    {\n        const lt = tempPoints[0];\n        const lb = tempPoints[1];\n        const rt = tempPoints[2];\n        const rb = tempPoints[3];\n\n        lt.set(rect.left, rect.top);\n        lb.set(rect.left, rect.bottom);\n        rt.set(rect.right, rect.top);\n        rb.set(rect.right, rect.bottom);\n\n        matrix.apply(lt, lt);\n        matrix.apply(lb, lb);\n        matrix.apply(rt, rt);\n        matrix.apply(rb, rb);\n\n        const x0 = Math.min(lt.x, lb.x, rt.x, rb.x);\n        const y0 = Math.min(lt.y, lb.y, rt.y, rb.y);\n        const x1 = Math.max(lt.x, lb.x, rt.x, rb.x);\n        const y1 = Math.max(lt.y, lb.y, rt.y, rb.y);\n\n        rect.x = x0;\n        rect.y = y0;\n        rect.width = x1 - x0;\n        rect.height = y1 - y0;\n    }\n\n    private roundFrame(\n        frame: Rectangle,\n        resolution: number,\n        bindingSourceFrame: Rectangle,\n        bindingDestinationFrame: Rectangle,\n        transform?: Matrix\n    )\n    {\n        if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0)\n        {\n            return;\n        }\n\n        if (transform)\n        {\n            const { a, b, c, d } = transform;\n\n            // Skip if skew/rotation present in matrix, except for multiple of 90° rotation. If rotation\n            // is a multiple of 90°, then either pair of (b,c) or (a,d) will be (0,0).\n            if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4)\n                && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4))\n            {\n                return;\n            }\n        }\n\n        transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();\n\n        // Get forward transform from world space to screen space\n        transform\n            .translate(-bindingSourceFrame.x, -bindingSourceFrame.y)\n            .scale(\n                bindingDestinationFrame.width / bindingSourceFrame.width,\n                bindingDestinationFrame.height / bindingSourceFrame.height)\n            .translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n\n        // Convert frame to screen space\n        this.transformAABB(transform, frame);\n\n        // Round frame in screen space\n        frame.ceil(resolution);\n\n        // Project back into world space.\n        this.transformAABB(transform.invert(), frame);\n    }\n}\n\nextensions.add(FilterSystem);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}