{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n'use strict';\n\nconst os = require('os');\nfunction getLoInterface() {\n  let name;\n  if (process.platform === 'darwin') {\n    name = 'lo0';\n  } else if (process.platform === 'linux') {\n    name = 'lo';\n  }\n  return name ? os.networkInterfaces()[name] : null;\n}\n\n/**\n * Queries the system network interfaces for an IP address.\n * @param {boolean} loopback Whether to find a loopback address.\n * @param {string} family The IP family (IPv4 or IPv6). Defaults to IPv4.\n * @return {(string|undefined)} The located IP address or undefined.\n */\nfunction getIPAddress(loopback, family) {\n  let interfaces;\n  if (loopback) {\n    const lo = getLoInterface();\n    interfaces = lo ? [lo] : null;\n  }\n  interfaces = interfaces || os.networkInterfaces();\n  for (let key in interfaces) {\n    if (!Object.prototype.hasOwnProperty.call(interfaces, key)) {\n      continue;\n    }\n    for (let ipAddress of interfaces[key]) {\n      if ((ipAddress.family === family || `IPv${ipAddress.family}` === family) && ipAddress.internal === loopback) {\n        return ipAddress.address;\n      }\n    }\n  }\n  return undefined;\n}\n\n// PUBLIC API\n\n/**\n * Retrieves the external IP address for this host.\n * @param {string=} family The IP family to retrieve. Defaults to \"IPv4\".\n * @return {(string|undefined)} The IP address or undefined if not available.\n */\nfunction getAddress(family = 'IPv4') {\n  return getIPAddress(false, family);\n}\n\n/**\n * Retrieves a loopback address for this machine.\n * @param {string=} family The IP family to retrieve. Defaults to \"IPv4\".\n * @return {(string|undefined)} The IP address or undefined if not available.\n */\nfunction getLoopbackAddress(family = 'IPv4') {\n  return getIPAddress(true, family);\n}\n\n/**\n * Splits a hostport string, e.g. \"www.example.com:80\", into its component\n * parts.\n *\n * @param {string} hostport The string to split.\n * @return {{host: string, port: ?number}} A host and port. If no port is\n *     present in the argument `hostport`, port is null.\n */\nfunction splitHostAndPort(hostport) {\n  let lastIndex = hostport.lastIndexOf(':');\n  if (lastIndex < 0) {\n    return {\n      host: hostport,\n      port: null\n    };\n  }\n  let firstIndex = hostport.indexOf(':');\n  if (firstIndex != lastIndex && !hostport.includes('[')) {\n    // Multiple colons but no brackets, so assume the string is an IPv6 address\n    // with no port (e.g. \"1234:5678:9:0:1234:5678:9:0\").\n    return {\n      host: hostport,\n      port: null\n    };\n  }\n  let host = hostport.slice(0, lastIndex);\n  if (host.startsWith('[') && host.endsWith(']')) {\n    host = host.slice(1, -1);\n  }\n  let port = parseInt(hostport.slice(lastIndex + 1), 10);\n  return {\n    host,\n    port\n  };\n}\n\n// PUBLIC API\nmodule.exports = {\n  splitHostAndPort,\n  getLoopbackAddress,\n  getAddress\n};","map":{"version":3,"names":["os","require","getLoInterface","name","process","platform","networkInterfaces","getIPAddress","loopback","family","interfaces","lo","key","Object","prototype","hasOwnProperty","call","ipAddress","internal","address","undefined","getAddress","getLoopbackAddress","splitHostAndPort","hostport","lastIndex","lastIndexOf","host","port","firstIndex","indexOf","includes","slice","startsWith","endsWith","parseInt","module","exports"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/selenium-webdriver/net/index.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n'use strict'\n\nconst os = require('os')\n\nfunction getLoInterface() {\n  let name\n  if (process.platform === 'darwin') {\n    name = 'lo0'\n  } else if (process.platform === 'linux') {\n    name = 'lo'\n  }\n  return name ? os.networkInterfaces()[name] : null\n}\n\n/**\n * Queries the system network interfaces for an IP address.\n * @param {boolean} loopback Whether to find a loopback address.\n * @param {string} family The IP family (IPv4 or IPv6). Defaults to IPv4.\n * @return {(string|undefined)} The located IP address or undefined.\n */\nfunction getIPAddress(loopback, family) {\n  let interfaces\n  if (loopback) {\n    const lo = getLoInterface()\n    interfaces = lo ? [lo] : null\n  }\n  interfaces = interfaces || os.networkInterfaces()\n  for (let key in interfaces) {\n    if (!Object.prototype.hasOwnProperty.call(interfaces, key)) {\n      continue\n    }\n\n    for (let ipAddress of interfaces[key]) {\n      if ((ipAddress.family === family || `IPv${ipAddress.family}` === family) && ipAddress.internal === loopback) {\n        return ipAddress.address\n      }\n    }\n  }\n  return undefined\n}\n\n// PUBLIC API\n\n/**\n * Retrieves the external IP address for this host.\n * @param {string=} family The IP family to retrieve. Defaults to \"IPv4\".\n * @return {(string|undefined)} The IP address or undefined if not available.\n */\nfunction getAddress(family = 'IPv4') {\n  return getIPAddress(false, family)\n}\n\n/**\n * Retrieves a loopback address for this machine.\n * @param {string=} family The IP family to retrieve. Defaults to \"IPv4\".\n * @return {(string|undefined)} The IP address or undefined if not available.\n */\nfunction getLoopbackAddress(family = 'IPv4') {\n  return getIPAddress(true, family)\n}\n\n/**\n * Splits a hostport string, e.g. \"www.example.com:80\", into its component\n * parts.\n *\n * @param {string} hostport The string to split.\n * @return {{host: string, port: ?number}} A host and port. If no port is\n *     present in the argument `hostport`, port is null.\n */\nfunction splitHostAndPort(hostport) {\n  let lastIndex = hostport.lastIndexOf(':')\n  if (lastIndex < 0) {\n    return { host: hostport, port: null }\n  }\n\n  let firstIndex = hostport.indexOf(':')\n  if (firstIndex != lastIndex && !hostport.includes('[')) {\n    // Multiple colons but no brackets, so assume the string is an IPv6 address\n    // with no port (e.g. \"1234:5678:9:0:1234:5678:9:0\").\n    return { host: hostport, port: null }\n  }\n\n  let host = hostport.slice(0, lastIndex)\n  if (host.startsWith('[') && host.endsWith(']')) {\n    host = host.slice(1, -1)\n  }\n\n  let port = parseInt(hostport.slice(lastIndex + 1), 10)\n  return { host, port }\n}\n\n// PUBLIC API\nmodule.exports = {\n  splitHostAndPort,\n  getLoopbackAddress,\n  getAddress,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}