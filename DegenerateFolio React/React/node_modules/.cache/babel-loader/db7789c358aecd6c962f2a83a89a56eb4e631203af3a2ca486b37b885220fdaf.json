{"ast":null,"code":"import { TARGETS } from \"@pixi/constants\";\nimport { AbstractMultiResource } from \"./AbstractMultiResource.mjs\";\nclass ArrayResource extends AbstractMultiResource {\n  /**\n   * @param source - Number of items in array or the collection\n   *        of image URLs to use. Can also be resources, image elements, canvas, etc.\n   * @param options - Options to apply to {@link PIXI.autoDetectResource}\n   * @param {number} [options.width] - Width of the resource\n   * @param {number} [options.height] - Height of the resource\n   */\n  constructor(source, options) {\n    const {\n      width,\n      height\n    } = options || {};\n    let urls, length;\n    Array.isArray(source) ? (urls = source, length = source.length) : length = source, super(length, {\n      width,\n      height\n    }), urls && this.initFromArray(urls, options);\n  }\n  /**\n   * Set a baseTexture by ID,\n   * ArrayResource just takes resource from it, nothing more\n   * @param baseTexture\n   * @param index - Zero-based index of resource to set\n   * @returns - Instance for chaining\n   */\n  addBaseTextureAt(baseTexture, index) {\n    if (baseTexture.resource) this.addResourceAt(baseTexture.resource, index);else throw new Error(\"ArrayResource does not support RenderTexture\");\n    return this;\n  }\n  /**\n   * Add binding\n   * @param baseTexture\n   */\n  bind(baseTexture) {\n    super.bind(baseTexture), baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;\n  }\n  /**\n   * Upload the resources to the GPU.\n   * @param renderer\n   * @param texture\n   * @param glTexture\n   * @returns - whether texture was uploaded\n   */\n  upload(renderer, texture, glTexture) {\n    const {\n        length,\n        itemDirtyIds,\n        items\n      } = this,\n      {\n        gl\n      } = renderer;\n    glTexture.dirtyId < 0 && gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);\n    for (let i = 0; i < length; i++) {\n      const item = items[i];\n      itemDirtyIds[i] < item.dirtyId && (itemDirtyIds[i] = item.dirtyId, item.valid && gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0,\n      // xoffset\n      0,\n      // yoffset\n      i,\n      // zoffset\n      item.resource.width, item.resource.height, 1, texture.format, glTexture.type, item.resource.source));\n    }\n    return !0;\n  }\n}\nexport { ArrayResource };","map":{"version":3,"names":["ArrayResource","AbstractMultiResource","constructor","source","options","width","height","urls","length","Array","isArray","initFromArray","addBaseTextureAt","baseTexture","index","resource","addResourceAt","Error","bind","target","TARGETS","TEXTURE_2D_ARRAY","upload","renderer","texture","glTexture","itemDirtyIds","items","gl","dirtyId","texImage3D","internalFormat","_width","_height","format","type","i","item","valid","texSubImage3D"],"sources":["/home/ryoitsu/node_modules/@pixi/core/src/textures/resources/ArrayResource.ts"],"sourcesContent":["import { TARGETS } from '@pixi/constants';\nimport { AbstractMultiResource } from './AbstractMultiResource';\n\nimport type { ISize } from '@pixi/math';\nimport type { Renderer } from '../../Renderer';\nimport type { BaseTexture } from '../BaseTexture';\nimport type { GLTexture } from '../GLTexture';\nimport type { BaseImageResource } from './BaseImageResource';\n\n/**\n * A resource that contains a number of sources.\n * @memberof PIXI\n */\nexport class ArrayResource extends AbstractMultiResource\n{\n    /**\n     * @param source - Number of items in array or the collection\n     *        of image URLs to use. Can also be resources, image elements, canvas, etc.\n     * @param options - Options to apply to {@link PIXI.autoDetectResource}\n     * @param {number} [options.width] - Width of the resource\n     * @param {number} [options.height] - Height of the resource\n     */\n    constructor(source: number | Array<any>, options?: ISize)\n    {\n        const { width, height } = options || {};\n\n        let urls;\n        let length: number;\n\n        if (Array.isArray(source))\n        {\n            urls = source;\n            length = source.length;\n        }\n        else\n        {\n            length = source;\n        }\n\n        super(length, { width, height });\n\n        if (urls)\n        {\n            this.initFromArray(urls, options);\n        }\n    }\n\n    /**\n     * Set a baseTexture by ID,\n     * ArrayResource just takes resource from it, nothing more\n     * @param baseTexture\n     * @param index - Zero-based index of resource to set\n     * @returns - Instance for chaining\n     */\n    addBaseTextureAt(baseTexture: BaseTexture, index: number): this\n    {\n        if (baseTexture.resource)\n        {\n            this.addResourceAt(baseTexture.resource, index);\n        }\n        else\n        {\n            throw new Error('ArrayResource does not support RenderTexture');\n        }\n\n        return this;\n    }\n\n    /**\n     * Add binding\n     * @param baseTexture\n     */\n    bind(baseTexture: BaseTexture): void\n    {\n        super.bind(baseTexture);\n\n        baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;\n    }\n\n    /**\n     * Upload the resources to the GPU.\n     * @param renderer\n     * @param texture\n     * @param glTexture\n     * @returns - whether texture was uploaded\n     */\n    upload(renderer: Renderer, texture: BaseTexture, glTexture: GLTexture): boolean\n    {\n        const { length, itemDirtyIds, items } = this;\n        const { gl } = renderer;\n\n        if (glTexture.dirtyId < 0)\n        {\n            gl.texImage3D(\n                gl.TEXTURE_2D_ARRAY,\n                0,\n                glTexture.internalFormat,\n                this._width,\n                this._height,\n                length,\n                0,\n                texture.format,\n                glTexture.type,\n                null\n            );\n        }\n\n        for (let i = 0; i < length; i++)\n        {\n            const item = items[i];\n\n            if (itemDirtyIds[i] < item.dirtyId)\n            {\n                itemDirtyIds[i] = item.dirtyId;\n                if (item.valid)\n                {\n                    gl.texSubImage3D(\n                        gl.TEXTURE_2D_ARRAY,\n                        0,\n                        0, // xoffset\n                        0, // yoffset\n                        i, // zoffset\n                        item.resource.width,\n                        item.resource.height,\n                        1,\n                        texture.format,\n                        glTexture.type,\n                        (item.resource as BaseImageResource).source\n                    );\n                }\n            }\n        }\n\n        return true;\n    }\n}\n"],"mappings":";;AAaO,MAAMA,aAAA,SAAsBC,qBAAA,CACnC;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQIC,YAAYC,MAAA,EAA6BC,OAAA,EACzC;IACI,MAAM;MAAEC,KAAA;MAAOC;IAAA,IAAWF,OAAA,IAAW;IAErC,IAAIG,IAAA,EACAC,MAAA;IAEAC,KAAA,CAAMC,OAAA,CAAQP,MAAM,KAEpBI,IAAA,GAAOJ,MAAA,EACPK,MAAA,GAASL,MAAA,CAAOK,MAAA,IAIhBA,MAAA,GAASL,MAAA,EAGb,MAAMK,MAAA,EAAQ;MAAEH,KAAA;MAAOC;IAAA,CAAQ,GAE3BC,IAAA,IAEA,KAAKI,aAAA,CAAcJ,IAAA,EAAMH,OAAO;EAExC;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASAQ,iBAAiBC,WAAA,EAA0BC,KAAA,EAC3C;IACI,IAAID,WAAA,CAAYE,QAAA,EAEP,KAAAC,aAAA,CAAcH,WAAA,CAAYE,QAAA,EAAUD,KAAK,OAIxC,UAAIG,KAAA,CAAM,8CAA8C;IAG3D;EACX;EAAA;AAAA;AAAA;AAAA;EAMAC,KAAKL,WAAA,EACL;IACI,MAAMK,IAAA,CAAKL,WAAW,GAEtBA,WAAA,CAAYM,MAAA,GAASC,OAAA,CAAQC,gBAAA;EACjC;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASAC,OAAOC,QAAA,EAAoBC,OAAA,EAAsBC,SAAA,EACjD;IACU;QAAEjB,MAAA;QAAQkB,YAAA;QAAcC;MAAA,IAAU;MAClC;QAAEC;MAAO,IAAAL,QAAA;IAEXE,SAAA,CAAUI,OAAA,GAAU,KAEpBD,EAAA,CAAGE,UAAA,CACCF,EAAA,CAAGP,gBAAA,EACH,GACAI,SAAA,CAAUM,cAAA,EACV,KAAKC,MAAA,EACL,KAAKC,OAAA,EACLzB,MAAA,EACA,GACAgB,OAAA,CAAQU,MAAA,EACRT,SAAA,CAAUU,IAAA,EACV;IAIR,SAASC,CAAA,GAAI,GAAGA,CAAA,GAAI5B,MAAA,EAAQ4B,CAAA,IAC5B;MACU,MAAAC,IAAA,GAAOV,KAAA,CAAMS,CAAC;MAEhBV,YAAA,CAAaU,CAAC,IAAIC,IAAA,CAAKR,OAAA,KAEvBH,YAAA,CAAaU,CAAC,IAAIC,IAAA,CAAKR,OAAA,EACnBQ,IAAA,CAAKC,KAAA,IAELV,EAAA,CAAGW,aAAA,CACCX,EAAA,CAAGP,gBAAA,EACH,GACA;MAAA;MACA;MAAA;MACAe,CAAA;MAAA;MACAC,IAAA,CAAKtB,QAAA,CAASV,KAAA,EACdgC,IAAA,CAAKtB,QAAA,CAAST,MAAA,EACd,GACAkB,OAAA,CAAQU,MAAA,EACRT,SAAA,CAAUU,IAAA,EACTE,IAAA,CAAKtB,QAAA,CAA+BZ,MAAA;IAIrD;IAEO;EACX;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}