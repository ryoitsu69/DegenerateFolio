{"ast":null,"code":"import { uid } from '../../../../utils/data/uid.mjs';\nimport { TextureSource } from '../texture/sources/TextureSource.mjs';\nimport { Texture } from '../texture/Texture.mjs';\n\"use strict\";\nconst _RenderTarget = class _RenderTarget {\n  /**\n   * @param [descriptor] - Options for creating a render target.\n   */\n  constructor(descriptor = {}) {\n    this.uid = uid(\"renderTarget\");\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    this.colorTextures = [];\n    this.dirtyId = 0;\n    this.isRoot = false;\n    this._size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    this._managedColorTextures = false;\n    descriptor = {\n      ..._RenderTarget.defaultOptions,\n      ...descriptor\n    };\n    this.stencil = descriptor.stencil;\n    this.depth = descriptor.depth;\n    this.isRoot = descriptor.isRoot;\n    if (typeof descriptor.colorTextures === \"number\") {\n      this._managedColorTextures = true;\n      for (let i = 0; i < descriptor.colorTextures; i++) {\n        this.colorTextures.push(new TextureSource({\n          width: descriptor.width,\n          height: descriptor.height,\n          resolution: descriptor.resolution,\n          antialias: descriptor.antialias\n        }));\n      }\n    } else {\n      this.colorTextures = [...descriptor.colorTextures.map(texture => texture.source)];\n      const colorSource = this.colorTexture.source;\n      this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n    }\n    this.colorTexture.source.on(\"resize\", this.onSourceResize, this);\n    if (descriptor.depthStencilTexture || this.stencil) {\n      if (descriptor.depthStencilTexture instanceof Texture || descriptor.depthStencilTexture instanceof TextureSource) {\n        this.depthStencilTexture = descriptor.depthStencilTexture.source;\n      } else {\n        this.ensureDepthStencilTexture();\n      }\n    }\n  }\n  get size() {\n    const _size = this._size;\n    _size[0] = this.pixelWidth;\n    _size[1] = this.pixelHeight;\n    return _size;\n  }\n  get width() {\n    return this.colorTexture.source.width;\n  }\n  get height() {\n    return this.colorTexture.source.height;\n  }\n  get pixelWidth() {\n    return this.colorTexture.source.pixelWidth;\n  }\n  get pixelHeight() {\n    return this.colorTexture.source.pixelHeight;\n  }\n  get resolution() {\n    return this.colorTexture.source._resolution;\n  }\n  get colorTexture() {\n    return this.colorTextures[0];\n  }\n  onSourceResize(source) {\n    this.resize(source.width, source.height, source._resolution, true);\n  }\n  /**\n   * This will ensure a depthStencil texture is created for this render target.\n   * Most likely called by the mask system to make sure we have stencil buffer added.\n   * @internal\n   * @ignore\n   */\n  ensureDepthStencilTexture() {\n    if (!this.depthStencilTexture) {\n      this.depthStencilTexture = new TextureSource({\n        width: this.width,\n        height: this.height,\n        resolution: this.resolution,\n        format: \"depth24plus-stencil8\",\n        autoGenerateMipmaps: false,\n        antialias: false,\n        mipLevelCount: 1\n        // sampleCount: handled by the render target system..\n      });\n    }\n  }\n  resize(width, height, resolution = this.resolution, skipColorTexture = false) {\n    this.dirtyId++;\n    this.colorTextures.forEach((colorTexture, i) => {\n      if (skipColorTexture && i === 0) return;\n      colorTexture.source.resize(width, height, resolution);\n    });\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.source.resize(width, height, resolution);\n    }\n  }\n  destroy() {\n    this.colorTexture.source.off(\"resize\", this.onSourceResize, this);\n    if (this._managedColorTextures) {\n      this.colorTextures.forEach(texture => {\n        texture.destroy();\n      });\n    }\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.destroy();\n      delete this.depthStencilTexture;\n    }\n  }\n};\n/** The default options for a render target */\n_RenderTarget.defaultOptions = {\n  /** the width of the RenderTarget */\n  width: 0,\n  /** the height of the RenderTarget */\n  height: 0,\n  /** the resolution of the RenderTarget */\n  resolution: 1,\n  /** an array of textures, or a number indicating how many color textures there should be */\n  colorTextures: 1,\n  /** should this render target have a stencil buffer? */\n  stencil: false,\n  /** should this render target have a depth buffer? */\n  depth: false,\n  /** should this render target be antialiased? */\n  antialias: false,\n  // save on perf by default!\n  /** is this a root element, true if this is gl context owners render target */\n  isRoot: false\n};\nlet RenderTarget = _RenderTarget;\nexport { RenderTarget };","map":{"version":3,"names":["_RenderTarget","constructor","descriptor","uid","colorTextures","dirtyId","isRoot","_size","Float32Array","_managedColorTextures","defaultOptions","stencil","depth","i","push","TextureSource","width","height","resolution","antialias","map","texture","source","colorSource","colorTexture","resize","_resolution","on","onSourceResize","depthStencilTexture","Texture","ensureDepthStencilTexture","size","pixelWidth","pixelHeight","format","autoGenerateMipmaps","mipLevelCount","skipColorTexture","forEach","destroy","off","RenderTarget"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTarget.ts"],"sourcesContent":["// what we are building is a platform and a framework.\n// import { Matrix } from '../../shared/maths/Matrix';\nimport { uid } from '../../../../utils/data/uid';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\n\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * Options for creating a render target.\n * @memberof rendering\n */\nexport interface RenderTargetOptions\n{\n    /** the width of the RenderTarget */\n    width?: number;\n    /** the height of the RenderTarget */\n    height?: number;\n    /** the resolution of the RenderTarget */\n    resolution?: number;\n    /** an array of textures, or a number indicating how many color textures there should be */\n    colorTextures?: BindableTexture[] | number;\n    /** should this render target have a stencil buffer? */\n    stencil?: boolean;\n    /** should this render target have a depth buffer? */\n    depth?: boolean;\n    /** a depth stencil texture that the depth and stencil outputs will be written to */\n    depthStencilTexture?: BindableTexture | boolean;\n    /** should this render target be antialiased? */\n    antialias?: boolean;\n    /** is this a root element, true if this is gl context owners render target */\n    isRoot?: boolean;\n}\n\n/**\n * A class that describes what the renderers are rendering to.\n * This can be as simple as a Texture, or as complex as a multi-texture, multi-sampled render target.\n * Support for stencil and depth buffers is also included.\n *\n * If you need something more complex than a Texture to render to, you should use this class.\n * Under the hood, all textures you render to have a RenderTarget created on their behalf.\n * @memberof rendering\n */\nexport class RenderTarget\n{\n    /** The default options for a render target */\n    public static defaultOptions: RenderTargetOptions = {\n        /** the width of the RenderTarget */\n        width: 0,\n        /** the height of the RenderTarget */\n        height: 0,\n        /** the resolution of the RenderTarget */\n        resolution: 1,\n        /** an array of textures, or a number indicating how many color textures there should be */\n        colorTextures: 1,\n        /** should this render target have a stencil buffer? */\n        stencil: false,\n        /** should this render target have a depth buffer? */\n        depth: false,\n        /** should this render target be antialiased? */\n        antialias: false, // save on perf by default!\n        /** is this a root element, true if this is gl context owners render target */\n        isRoot: false\n    };\n\n    public uid = uid('renderTarget');\n\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    public colorTextures: TextureSource[] = [];\n    /** the stencil and depth buffer will right to this texture in WebGPU */\n    public depthStencilTexture: TextureSource;\n    /** if true, will ensure a stencil buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public stencil: boolean;\n    /** if true, will ensure a depth buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public depth: boolean;\n\n    public dirtyId = 0;\n    public isRoot = false;\n\n    private readonly _size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    private readonly _managedColorTextures: boolean = false;\n\n    /**\n     * @param [descriptor] - Options for creating a render target.\n     */\n    constructor(descriptor: RenderTargetOptions = {})\n    {\n        descriptor = { ...RenderTarget.defaultOptions, ...descriptor };\n\n        this.stencil = descriptor.stencil;\n        this.depth = descriptor.depth;\n        this.isRoot = descriptor.isRoot;\n\n        if (typeof descriptor.colorTextures === 'number')\n        {\n            this._managedColorTextures = true;\n\n            for (let i = 0; i < descriptor.colorTextures; i++)\n            {\n                this.colorTextures.push(new TextureSource({\n                    width: descriptor.width,\n                    height: descriptor.height,\n                    resolution: descriptor.resolution,\n                    antialias: descriptor.antialias,\n                })\n                );\n            }\n        }\n        else\n        {\n            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n\n            const colorSource = this.colorTexture.source;\n\n            this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n        }\n\n        // the first color texture drives the size of all others..\n        this.colorTexture.source.on('resize', this.onSourceResize, this);\n\n        // TODO should listen for texture destroyed?\n\n        if (descriptor.depthStencilTexture || this.stencil)\n        {\n            // TODO add a test\n            if (descriptor.depthStencilTexture instanceof Texture\n                || descriptor.depthStencilTexture instanceof TextureSource)\n            {\n                this.depthStencilTexture = descriptor.depthStencilTexture.source;\n            }\n            else\n            {\n                this.ensureDepthStencilTexture();\n            }\n        }\n    }\n\n    get size(): [number, number]\n    {\n        const _size = this._size;\n\n        _size[0] = this.pixelWidth;\n        _size[1] = this.pixelHeight;\n\n        return _size as any as [number, number];\n    }\n\n    get width(): number\n    {\n        return this.colorTexture.source.width;\n    }\n\n    get height(): number\n    {\n        return this.colorTexture.source.height;\n    }\n    get pixelWidth(): number\n    {\n        return this.colorTexture.source.pixelWidth;\n    }\n\n    get pixelHeight(): number\n    {\n        return this.colorTexture.source.pixelHeight;\n    }\n\n    get resolution(): number\n    {\n        return this.colorTexture.source._resolution;\n    }\n\n    get colorTexture(): TextureSource\n    {\n        return this.colorTextures[0];\n    }\n\n    protected onSourceResize(source: TextureSource)\n    {\n        this.resize(source.width, source.height, source._resolution, true);\n    }\n\n    /**\n     * This will ensure a depthStencil texture is created for this render target.\n     * Most likely called by the mask system to make sure we have stencil buffer added.\n     * @internal\n     * @ignore\n     */\n    public ensureDepthStencilTexture()\n    {\n        if (!this.depthStencilTexture)\n        {\n            this.depthStencilTexture = new TextureSource({\n                width: this.width,\n                height: this.height,\n                resolution: this.resolution,\n                format: 'depth24plus-stencil8',\n                autoGenerateMipmaps: false,\n                antialias: false,\n                mipLevelCount: 1,\n                // sampleCount: handled by the render target system..\n            });\n        }\n    }\n\n    public resize(width: number, height: number, resolution = this.resolution, skipColorTexture = false)\n    {\n        this.dirtyId++;\n\n        this.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (skipColorTexture && i === 0) return;\n\n            colorTexture.source.resize(width, height, resolution);\n        });\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.source.resize(width, height, resolution);\n        }\n    }\n\n    public destroy()\n    {\n        this.colorTexture.source.off('resize', this.onSourceResize, this);\n\n        if (this._managedColorTextures)\n        {\n            this.colorTextures.forEach((texture) =>\n            {\n                texture.destroy();\n            });\n        }\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.destroy();\n            delete this.depthStencilTexture;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}