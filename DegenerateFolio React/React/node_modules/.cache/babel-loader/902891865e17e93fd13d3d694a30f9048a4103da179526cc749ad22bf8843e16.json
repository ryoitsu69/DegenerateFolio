{"ast":null,"code":"import _defineProperty from \"/home/ryoitsu/Documents/test/react-todo-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { firstValueFrom, map, of, switchMap } from 'rxjs';\nimport { Metadata, TypeRegistry } from '@polkadot/types';\nimport { getSpecAlias, getSpecExtensions, getSpecHasher, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assertReturn, BN_ZERO, isUndefined, logger, noop, objectSpread, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { Decorate } from './Decorate.js';\nconst KEEPALIVE_INTERVAL = 10000;\nconst WITH_VERSION_SHORTCUT = false;\nconst l = logger('api/init');\nfunction textToString(t) {\n  return t.toString();\n}\nexport class Init extends Decorate {\n  constructor(options, type, decorateMethod) {\n    super(options, type, decorateMethod);\n    // all injected types added to the registry for overrides\n    _defineProperty(this, \"__internal__atLast\", null);\n    _defineProperty(this, \"__internal__healthTimer\", null);\n    _defineProperty(this, \"__internal__registries\", []);\n    _defineProperty(this, \"__internal__updateSub\", null);\n    _defineProperty(this, \"__internal__waitingRegistries\", {});\n    this.registry.setKnownTypes(options);\n    // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n    if (!options.source) {\n      this.registerTypes(options.types);\n    } else {\n      this.__internal__registries = options.source.__internal__registries;\n    }\n    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n    if (this.supportMulti) {\n      this._queryMulti = this._decorateMulti(this._decorateMethod);\n      this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n    }\n    this._rx.signer = options.signer;\n    this._rpcCore.setRegistrySwap(blockHash => this.getBlockRegistry(blockHash));\n    this._rpcCore.setResolveBlockHash(blockNumber => firstValueFrom(this._rpcCore.chain.getBlockHash(blockNumber)));\n    if (this.hasSubscriptions) {\n      this._rpcCore.provider.on('disconnected', () => this.__internal__onProviderDisconnect());\n      this._rpcCore.provider.on('error', e => this.__internal__onProviderError(e));\n      this._rpcCore.provider.on('connected', () => this.__internal__onProviderConnect());\n    } else if (!this._options.noInitWarn) {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    }\n    // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n    if (this._rpcCore.provider.isConnected) {\n      this.__internal__onProviderConnect().catch(noop);\n    }\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n  _initRegistry(registry, chain, version, metadata, chainProps) {\n    registry.clearCache();\n    registry.setChainProperties(chainProps || this.registry.getChainProperties());\n    registry.setKnownTypes(this._options);\n    registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion));\n    registry.setHasher(getSpecHasher(registry, chain, version.specName));\n    // for bundled types, pull through the aliases defined\n    if (registry.knownTypes.typesBundle) {\n      registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n    }\n    registry.setMetadata(metadata, undefined, objectSpread({}, getSpecExtensions(registry, chain, version.specName), this._options.signedExtensions), this._options.noInitWarn);\n  }\n  /**\n   * @description Returns the default versioned registry\n   */\n  _getDefaultRegistry() {\n    return assertReturn(this.__internal__registries.find(_ref => {\n      let {\n        isDefault\n      } = _ref;\n      return isDefault;\n    }), 'Initialization error, cannot find the default registry');\n  }\n  /**\n   * @description Returns a decorated API instance at a specific point in time\n   */\n  async at(blockHash, knownVersion) {\n    const u8aHash = u8aToU8a(blockHash);\n    const u8aHex = u8aToHex(u8aHash);\n    const registry = await this.getBlockRegistry(u8aHash, knownVersion);\n    if (!this.__internal__atLast || this.__internal__atLast[0] !== u8aHex) {\n      // always create a new decoration - since we are pointing to a specific hash, this\n      // means that all queries needs to use that hash (not a previous one already existing)\n      this.__internal__atLast = [u8aHex, this._createDecorated(registry, true, null, u8aHash).decoratedApi];\n    }\n    return this.__internal__atLast[1];\n  }\n  async _createBlockRegistry(blockHash, header, version) {\n    const registry = new TypeRegistry(blockHash);\n    const metadata = new Metadata(registry, await firstValueFrom(this._rpcCore.state.getMetadata.raw(header.parentHash)));\n    const runtimeChain = this._runtimeChain;\n    if (!runtimeChain) {\n      throw new Error('Invalid initializion order, runtimeChain is not available');\n    }\n    this._initRegistry(registry, runtimeChain, version, metadata);\n    // add our new registry\n    const result = {\n      counter: 0,\n      lastBlockHash: blockHash,\n      metadata,\n      registry,\n      runtimeVersion: version\n    };\n    this.__internal__registries.push(result);\n    return result;\n  }\n  _cacheBlockRegistryProgress(key, creator) {\n    // look for waiting resolves\n    let waiting = this.__internal__waitingRegistries[key];\n    if (isUndefined(waiting)) {\n      // nothing waiting, construct new\n      waiting = this.__internal__waitingRegistries[key] = new Promise((resolve, reject) => {\n        creator().then(registry => {\n          delete this.__internal__waitingRegistries[key];\n          resolve(registry);\n        }).catch(error => {\n          delete this.__internal__waitingRegistries[key];\n          reject(error);\n        });\n      });\n    }\n    return waiting;\n  }\n  _getBlockRegistryViaVersion(blockHash, version) {\n    if (version) {\n      // check for pre-existing registries. We also check specName, e.g. it\n      // could be changed like in Westmint with upgrade from shell -> westmint\n      const existingViaVersion = this.__internal__registries.find(_ref2 => {\n        let {\n          runtimeVersion: {\n            specName,\n            specVersion\n          }\n        } = _ref2;\n        return specName.eq(version.specName) && specVersion.eq(version.specVersion);\n      });\n      if (existingViaVersion) {\n        existingViaVersion.counter++;\n        existingViaVersion.lastBlockHash = blockHash;\n        return existingViaVersion;\n      }\n    }\n    return null;\n  }\n  async _getBlockRegistryViaHash(blockHash) {\n    // ensure we have everything required\n    if (!this._genesisHash || !this._runtimeVersion) {\n      throw new Error('Cannot retrieve data on an uninitialized chain');\n    }\n    // We have to assume that on the RPC layer the calls used here does not call back into\n    // the registry swap, so getHeader & getRuntimeVersion should not be historic\n    const header = this.registry.createType('HeaderPartial', this._genesisHash.eq(blockHash) ? {\n      number: BN_ZERO,\n      parentHash: this._genesisHash\n    } : await firstValueFrom(this._rpcCore.chain.getHeader.raw(blockHash)));\n    if (header.parentHash.isEmpty) {\n      throw new Error('Unable to retrieve header and parent from supplied hash');\n    }\n    // get the runtime version, either on-chain or via an known upgrade history\n    const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number);\n    const version = this.registry.createType('RuntimeVersionPartial', WITH_VERSION_SHORTCUT && firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {\n      apis: firstVersion.apis,\n      specName: this._runtimeVersion.specName,\n      specVersion: firstVersion.specVersion\n    } : await firstValueFrom(this._rpcCore.state.getRuntimeVersion.raw(header.parentHash)));\n    return (\n      // try to find via version\n      this._getBlockRegistryViaVersion(blockHash, version) || (\n      // return new or in-flight result\n      await this._cacheBlockRegistryProgress(version.toHex(), () => this._createBlockRegistry(blockHash, header, version)))\n    );\n  }\n  /**\n   * @description Sets up a registry based on the block hash defined\n   */\n  async getBlockRegistry(blockHash, knownVersion) {\n    return (\n      // try to find via blockHash\n      this.__internal__registries.find(_ref3 => {\n        let {\n          lastBlockHash\n        } = _ref3;\n        return lastBlockHash && u8aEq(lastBlockHash, blockHash);\n      }) ||\n      // try to find via version\n      this._getBlockRegistryViaVersion(blockHash, knownVersion) || (\n      // return new or in-flight result\n      await this._cacheBlockRegistryProgress(u8aToHex(blockHash), () => this._getBlockRegistryViaHash(blockHash)))\n    );\n  }\n  async _loadMeta() {\n    var _this$_options$source;\n    // on re-connection to the same chain, we don't want to re-do everything from chain again\n    if (this._isReady) {\n      return true;\n    }\n    this._unsubscribeUpdates();\n    // only load from on-chain if we are not a clone (default path), alternatively\n    // just use the values from the source instance provided\n    [this._genesisHash, this._runtimeMetadata] = (_this$_options$source = this._options.source) !== null && _this$_options$source !== void 0 && _this$_options$source._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata);\n    return this._initFromMeta(this._runtimeMetadata);\n  }\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async _metaFromSource(source) {\n    this._extrinsicType = source.extrinsicVersion;\n    this._runtimeChain = source.runtimeChain;\n    this._runtimeVersion = source.runtimeVersion;\n    // manually build a list of all available methods in this RPC, we are\n    // going to filter on it to align the cloned RPC without making a call\n    const sections = Object.keys(source.rpc);\n    const rpcs = [];\n    for (let s = 0, scount = sections.length; s < scount; s++) {\n      const section = sections[s];\n      const methods = Object.keys(source.rpc[section]);\n      for (let m = 0, mcount = methods.length; m < mcount; m++) {\n        rpcs.push(\"\".concat(section, \"_\").concat(methods[m]));\n      }\n    }\n    this._filterRpc(rpcs, getSpecRpc(this.registry, source.runtimeChain, source.runtimeVersion.specName));\n    return [source.genesisHash, source.runtimeMetadata];\n  }\n  // subscribe to metadata updates, inject the types on changes\n  _subscribeUpdates() {\n    if (this.__internal__updateSub || !this.hasSubscriptions) {\n      return;\n    }\n    this.__internal__updateSub = this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap(version => {\n      var _this$_runtimeVersion;\n      return (\n        // only retrieve the metadata when the on-chain version has been changed\n        (_this$_runtimeVersion = this._runtimeVersion) !== null && _this$_runtimeVersion !== void 0 && _this$_runtimeVersion.specVersion.eq(version.specVersion) ? of(false) : this._rpcCore.state.getMetadata().pipe(map(metadata => {\n          l.log(\"Runtime version updated to spec=\".concat(version.specVersion.toString(), \", tx=\").concat(version.transactionVersion.toString()));\n          this._runtimeMetadata = metadata;\n          this._runtimeVersion = version;\n          this._rx.runtimeVersion = version;\n          // update the default registry version\n          const thisRegistry = this._getDefaultRegistry();\n          const runtimeChain = this._runtimeChain;\n          if (!runtimeChain) {\n            throw new Error('Invalid initializion order, runtimeChain is not available');\n          }\n          // setup the data as per the current versions\n          thisRegistry.metadata = metadata;\n          thisRegistry.runtimeVersion = version;\n          this._initRegistry(this.registry, runtimeChain, version, metadata);\n          this._injectMetadata(thisRegistry, true);\n          return true;\n        }))\n      );\n    })).subscribe();\n  }\n  async _metaFromChain(optMetadata) {\n    const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata] = await Promise.all([firstValueFrom(this._rpcCore.chain.getBlockHash(0)), firstValueFrom(this._rpcCore.state.getRuntimeVersion()), firstValueFrom(this._rpcCore.system.chain()), firstValueFrom(this._rpcCore.system.properties()), firstValueFrom(this._rpcCore.rpc.methods()), optMetadata ? Promise.resolve(null) : firstValueFrom(this._rpcCore.state.getMetadata())]);\n    // set our chain version & genesisHash as returned\n    this._runtimeChain = chain;\n    this._runtimeVersion = runtimeVersion;\n    this._rx.runtimeVersion = runtimeVersion;\n    // retrieve metadata, either from chain  or as pass-in via options\n    const metadataKey = \"\".concat(genesisHash.toHex() || '0x', \"-\").concat(runtimeVersion.specVersion.toString());\n    const metadata = chainMetadata || (optMetadata !== null && optMetadata !== void 0 && optMetadata[metadataKey] ? new Metadata(this.registry, optMetadata[metadataKey]) : await firstValueFrom(this._rpcCore.state.getMetadata()));\n    // initializes the registry & RPC\n    this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n    this._filterRpc(rpcMethods.methods.map(textToString), getSpecRpc(this.registry, chain, runtimeVersion.specName));\n    this._subscribeUpdates();\n    // setup the initial registry, when we have none\n    if (!this.__internal__registries.length) {\n      this.__internal__registries.push({\n        counter: 0,\n        isDefault: true,\n        metadata,\n        registry: this.registry,\n        runtimeVersion\n      });\n    }\n    // get unique types & validate\n    metadata.getUniqTypes(this._options.throwOnUnknown || false);\n    return [genesisHash, metadata];\n  }\n  _initFromMeta(metadata) {\n    const runtimeVersion = this._runtimeVersion;\n    if (!runtimeVersion) {\n      throw new Error('Invalid initializion order, runtimeVersion is not available');\n    }\n    this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();\n    this._rx.extrinsicType = this._extrinsicType;\n    this._rx.genesisHash = this._genesisHash;\n    this._rx.runtimeVersion = runtimeVersion;\n    // inject metadata and adjust the types as detected\n    this._injectMetadata(this._getDefaultRegistry(), true);\n    // derive is last, since it uses the decorated rx\n    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n    this._derive = this._decorateDerive(this._decorateMethod);\n    return true;\n  }\n  _subscribeHealth() {\n    this._unsubscribeHealth();\n    // Only enable the health keepalive on WS, not needed on HTTP\n    this.__internal__healthTimer = this.hasSubscriptions ? setInterval(() => {\n      firstValueFrom(this._rpcCore.system.health.raw()).catch(noop);\n    }, KEEPALIVE_INTERVAL) : null;\n  }\n  _unsubscribeHealth() {\n    if (this.__internal__healthTimer) {\n      clearInterval(this.__internal__healthTimer);\n      this.__internal__healthTimer = null;\n    }\n  }\n  _unsubscribeUpdates() {\n    if (this.__internal__updateSub) {\n      this.__internal__updateSub.unsubscribe();\n      this.__internal__updateSub = null;\n    }\n  }\n  _unsubscribe() {\n    this._unsubscribeHealth();\n    this._unsubscribeUpdates();\n  }\n  async __internal__onProviderConnect() {\n    this._isConnected.next(true);\n    this.emit('connected');\n    try {\n      const cryptoReady = this._options.initWasm === false ? true : await cryptoWaitReady();\n      const hasMeta = await this._loadMeta();\n      this._subscribeHealth();\n      if (hasMeta && !this._isReady && cryptoReady) {\n        this._isReady = true;\n        this.emit('ready', this);\n      }\n    } catch (_error) {\n      const error = new Error(\"FATAL: Unable to initialize the API: \".concat(_error.message));\n      l.error(error);\n      this.emit('error', error);\n    }\n  }\n  __internal__onProviderDisconnect() {\n    this._isConnected.next(false);\n    this._unsubscribe();\n    this.emit('disconnected');\n  }\n  __internal__onProviderError(error) {\n    this.emit('error', error);\n  }\n}","map":{"version":3,"names":["firstValueFrom","map","of","switchMap","Metadata","TypeRegistry","getSpecAlias","getSpecExtensions","getSpecHasher","getSpecRpc","getSpecTypes","getUpgradeVersion","assertReturn","BN_ZERO","isUndefined","logger","noop","objectSpread","u8aEq","u8aToHex","u8aToU8a","cryptoWaitReady","Decorate","KEEPALIVE_INTERVAL","WITH_VERSION_SHORTCUT","l","textToString","t","toString","Init","constructor","options","type","decorateMethod","_defineProperty","registry","setKnownTypes","source","registerTypes","types","__internal__registries","_rpc","_decorateRpc","_rpcCore","_decorateMethod","_rx","rpc","_rxDecorateMethod","supportMulti","_queryMulti","_decorateMulti","queryMulti","signer","setRegistrySwap","blockHash","getBlockRegistry","setResolveBlockHash","blockNumber","chain","getBlockHash","hasSubscriptions","provider","on","__internal__onProviderDisconnect","e","__internal__onProviderError","__internal__onProviderConnect","_options","noInitWarn","warn","isConnected","catch","_initRegistry","version","metadata","chainProps","clearCache","setChainProperties","getChainProperties","register","specName","specVersion","setHasher","knownTypes","typesBundle","typesAlias","setMetadata","undefined","signedExtensions","_getDefaultRegistry","find","_ref","isDefault","at","knownVersion","u8aHash","u8aHex","__internal__atLast","_createDecorated","decoratedApi","_createBlockRegistry","header","state","getMetadata","raw","parentHash","runtimeChain","_runtimeChain","Error","result","counter","lastBlockHash","runtimeVersion","push","_cacheBlockRegistryProgress","key","creator","waiting","__internal__waitingRegistries","Promise","resolve","reject","then","error","_getBlockRegistryViaVersion","existingViaVersion","_ref2","eq","_getBlockRegistryViaHash","_genesisHash","_runtimeVersion","createType","number","getHeader","isEmpty","firstVersion","lastVersion","apis","getRuntimeVersion","toHex","_ref3","_loadMeta","_this$_options$source","_isReady","_unsubscribeUpdates","_runtimeMetadata","_metaFromSource","_metaFromChain","_initFromMeta","_extrinsicType","extrinsicVersion","sections","Object","keys","rpcs","s","scount","length","section","methods","m","mcount","concat","_filterRpc","genesisHash","runtimeMetadata","_subscribeUpdates","__internal__updateSub","subscribeRuntimeVersion","pipe","_this$_runtimeVersion","log","transactionVersion","thisRegistry","_injectMetadata","subscribe","optMetadata","rpcMethods","chainMetadata","all","system","properties","metadataKey","getUniqTypes","throwOnUnknown","asLatest","extrinsic","toNumber","extrinsicType","derive","_decorateDeriveRx","_derive","_decorateDerive","_subscribeHealth","_unsubscribeHealth","__internal__healthTimer","setInterval","health","clearInterval","unsubscribe","_unsubscribe","_isConnected","next","emit","cryptoReady","initWasm","hasMeta","_error","message"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api/base/Init.js"],"sourcesContent":["import { firstValueFrom, map, of, switchMap } from 'rxjs';\nimport { Metadata, TypeRegistry } from '@polkadot/types';\nimport { getSpecAlias, getSpecExtensions, getSpecHasher, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assertReturn, BN_ZERO, isUndefined, logger, noop, objectSpread, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { Decorate } from './Decorate.js';\nconst KEEPALIVE_INTERVAL = 10000;\nconst WITH_VERSION_SHORTCUT = false;\nconst l = logger('api/init');\nfunction textToString(t) {\n    return t.toString();\n}\nexport class Init extends Decorate {\n    __internal__atLast = null;\n    __internal__healthTimer = null;\n    __internal__registries = [];\n    __internal__updateSub = null;\n    __internal__waitingRegistries = {};\n    constructor(options, type, decorateMethod) {\n        super(options, type, decorateMethod);\n        // all injected types added to the registry for overrides\n        this.registry.setKnownTypes(options);\n        // We only register the types (global) if this is not a cloned instance.\n        // Do right up-front, so we get in the user types before we are actually\n        // doing anything on-chain, this ensures we have the overrides in-place\n        if (!options.source) {\n            this.registerTypes(options.types);\n        }\n        else {\n            this.__internal__registries = options.source.__internal__registries;\n        }\n        this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n        this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n        if (this.supportMulti) {\n            this._queryMulti = this._decorateMulti(this._decorateMethod);\n            this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n        }\n        this._rx.signer = options.signer;\n        this._rpcCore.setRegistrySwap((blockHash) => this.getBlockRegistry(blockHash));\n        this._rpcCore.setResolveBlockHash((blockNumber) => firstValueFrom(this._rpcCore.chain.getBlockHash(blockNumber)));\n        if (this.hasSubscriptions) {\n            this._rpcCore.provider.on('disconnected', () => this.__internal__onProviderDisconnect());\n            this._rpcCore.provider.on('error', (e) => this.__internal__onProviderError(e));\n            this._rpcCore.provider.on('connected', () => this.__internal__onProviderConnect());\n        }\n        else if (!this._options.noInitWarn) {\n            l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n        }\n        // If the provider was instantiated earlier, and has already emitted a\n        // 'connected' event, then the `on('connected')` won't fire anymore. To\n        // cater for this case, we call manually `this._onProviderConnect`.\n        if (this._rpcCore.provider.isConnected) {\n            this.__internal__onProviderConnect().catch(noop);\n        }\n    }\n    /**\n     * @description Decorates a registry based on the runtime version\n     */\n    _initRegistry(registry, chain, version, metadata, chainProps) {\n        registry.clearCache();\n        registry.setChainProperties(chainProps || this.registry.getChainProperties());\n        registry.setKnownTypes(this._options);\n        registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion));\n        registry.setHasher(getSpecHasher(registry, chain, version.specName));\n        // for bundled types, pull through the aliases defined\n        if (registry.knownTypes.typesBundle) {\n            registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n        }\n        registry.setMetadata(metadata, undefined, objectSpread({}, getSpecExtensions(registry, chain, version.specName), this._options.signedExtensions), this._options.noInitWarn);\n    }\n    /**\n     * @description Returns the default versioned registry\n     */\n    _getDefaultRegistry() {\n        return assertReturn(this.__internal__registries.find(({ isDefault }) => isDefault), 'Initialization error, cannot find the default registry');\n    }\n    /**\n     * @description Returns a decorated API instance at a specific point in time\n     */\n    async at(blockHash, knownVersion) {\n        const u8aHash = u8aToU8a(blockHash);\n        const u8aHex = u8aToHex(u8aHash);\n        const registry = await this.getBlockRegistry(u8aHash, knownVersion);\n        if (!this.__internal__atLast || this.__internal__atLast[0] !== u8aHex) {\n            // always create a new decoration - since we are pointing to a specific hash, this\n            // means that all queries needs to use that hash (not a previous one already existing)\n            this.__internal__atLast = [u8aHex, this._createDecorated(registry, true, null, u8aHash).decoratedApi];\n        }\n        return this.__internal__atLast[1];\n    }\n    async _createBlockRegistry(blockHash, header, version) {\n        const registry = new TypeRegistry(blockHash);\n        const metadata = new Metadata(registry, await firstValueFrom(this._rpcCore.state.getMetadata.raw(header.parentHash)));\n        const runtimeChain = this._runtimeChain;\n        if (!runtimeChain) {\n            throw new Error('Invalid initializion order, runtimeChain is not available');\n        }\n        this._initRegistry(registry, runtimeChain, version, metadata);\n        // add our new registry\n        const result = { counter: 0, lastBlockHash: blockHash, metadata, registry, runtimeVersion: version };\n        this.__internal__registries.push(result);\n        return result;\n    }\n    _cacheBlockRegistryProgress(key, creator) {\n        // look for waiting resolves\n        let waiting = this.__internal__waitingRegistries[key];\n        if (isUndefined(waiting)) {\n            // nothing waiting, construct new\n            waiting = this.__internal__waitingRegistries[key] = new Promise((resolve, reject) => {\n                creator()\n                    .then((registry) => {\n                    delete this.__internal__waitingRegistries[key];\n                    resolve(registry);\n                })\n                    .catch((error) => {\n                    delete this.__internal__waitingRegistries[key];\n                    reject(error);\n                });\n            });\n        }\n        return waiting;\n    }\n    _getBlockRegistryViaVersion(blockHash, version) {\n        if (version) {\n            // check for pre-existing registries. We also check specName, e.g. it\n            // could be changed like in Westmint with upgrade from shell -> westmint\n            const existingViaVersion = this.__internal__registries.find(({ runtimeVersion: { specName, specVersion } }) => specName.eq(version.specName) &&\n                specVersion.eq(version.specVersion));\n            if (existingViaVersion) {\n                existingViaVersion.counter++;\n                existingViaVersion.lastBlockHash = blockHash;\n                return existingViaVersion;\n            }\n        }\n        return null;\n    }\n    async _getBlockRegistryViaHash(blockHash) {\n        // ensure we have everything required\n        if (!this._genesisHash || !this._runtimeVersion) {\n            throw new Error('Cannot retrieve data on an uninitialized chain');\n        }\n        // We have to assume that on the RPC layer the calls used here does not call back into\n        // the registry swap, so getHeader & getRuntimeVersion should not be historic\n        const header = this.registry.createType('HeaderPartial', this._genesisHash.eq(blockHash)\n            ? { number: BN_ZERO, parentHash: this._genesisHash }\n            : await firstValueFrom(this._rpcCore.chain.getHeader.raw(blockHash)));\n        if (header.parentHash.isEmpty) {\n            throw new Error('Unable to retrieve header and parent from supplied hash');\n        }\n        // get the runtime version, either on-chain or via an known upgrade history\n        const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number);\n        const version = this.registry.createType('RuntimeVersionPartial', WITH_VERSION_SHORTCUT && (firstVersion && (lastVersion ||\n            firstVersion.specVersion.eq(this._runtimeVersion.specVersion)))\n            ? { apis: firstVersion.apis, specName: this._runtimeVersion.specName, specVersion: firstVersion.specVersion }\n            : await firstValueFrom(this._rpcCore.state.getRuntimeVersion.raw(header.parentHash)));\n        return (\n        // try to find via version\n        this._getBlockRegistryViaVersion(blockHash, version) ||\n            // return new or in-flight result\n            await this._cacheBlockRegistryProgress(version.toHex(), () => this._createBlockRegistry(blockHash, header, version)));\n    }\n    /**\n     * @description Sets up a registry based on the block hash defined\n     */\n    async getBlockRegistry(blockHash, knownVersion) {\n        return (\n        // try to find via blockHash\n        this.__internal__registries.find(({ lastBlockHash }) => lastBlockHash && u8aEq(lastBlockHash, blockHash)) ||\n            // try to find via version\n            this._getBlockRegistryViaVersion(blockHash, knownVersion) ||\n            // return new or in-flight result\n            await this._cacheBlockRegistryProgress(u8aToHex(blockHash), () => this._getBlockRegistryViaHash(blockHash)));\n    }\n    async _loadMeta() {\n        // on re-connection to the same chain, we don't want to re-do everything from chain again\n        if (this._isReady) {\n            return true;\n        }\n        this._unsubscribeUpdates();\n        // only load from on-chain if we are not a clone (default path), alternatively\n        // just use the values from the source instance provided\n        [this._genesisHash, this._runtimeMetadata] = this._options.source?._isReady\n            ? await this._metaFromSource(this._options.source)\n            : await this._metaFromChain(this._options.metadata);\n        return this._initFromMeta(this._runtimeMetadata);\n    }\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async _metaFromSource(source) {\n        this._extrinsicType = source.extrinsicVersion;\n        this._runtimeChain = source.runtimeChain;\n        this._runtimeVersion = source.runtimeVersion;\n        // manually build a list of all available methods in this RPC, we are\n        // going to filter on it to align the cloned RPC without making a call\n        const sections = Object.keys(source.rpc);\n        const rpcs = [];\n        for (let s = 0, scount = sections.length; s < scount; s++) {\n            const section = sections[s];\n            const methods = Object.keys(source.rpc[section]);\n            for (let m = 0, mcount = methods.length; m < mcount; m++) {\n                rpcs.push(`${section}_${methods[m]}`);\n            }\n        }\n        this._filterRpc(rpcs, getSpecRpc(this.registry, source.runtimeChain, source.runtimeVersion.specName));\n        return [source.genesisHash, source.runtimeMetadata];\n    }\n    // subscribe to metadata updates, inject the types on changes\n    _subscribeUpdates() {\n        if (this.__internal__updateSub || !this.hasSubscriptions) {\n            return;\n        }\n        this.__internal__updateSub = this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap((version) => \n        // only retrieve the metadata when the on-chain version has been changed\n        this._runtimeVersion?.specVersion.eq(version.specVersion)\n            ? of(false)\n            : this._rpcCore.state.getMetadata().pipe(map((metadata) => {\n                l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n                this._runtimeMetadata = metadata;\n                this._runtimeVersion = version;\n                this._rx.runtimeVersion = version;\n                // update the default registry version\n                const thisRegistry = this._getDefaultRegistry();\n                const runtimeChain = this._runtimeChain;\n                if (!runtimeChain) {\n                    throw new Error('Invalid initializion order, runtimeChain is not available');\n                }\n                // setup the data as per the current versions\n                thisRegistry.metadata = metadata;\n                thisRegistry.runtimeVersion = version;\n                this._initRegistry(this.registry, runtimeChain, version, metadata);\n                this._injectMetadata(thisRegistry, true);\n                return true;\n            })))).subscribe();\n    }\n    async _metaFromChain(optMetadata) {\n        const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata] = await Promise.all([\n            firstValueFrom(this._rpcCore.chain.getBlockHash(0)),\n            firstValueFrom(this._rpcCore.state.getRuntimeVersion()),\n            firstValueFrom(this._rpcCore.system.chain()),\n            firstValueFrom(this._rpcCore.system.properties()),\n            firstValueFrom(this._rpcCore.rpc.methods()),\n            optMetadata\n                ? Promise.resolve(null)\n                : firstValueFrom(this._rpcCore.state.getMetadata())\n        ]);\n        // set our chain version & genesisHash as returned\n        this._runtimeChain = chain;\n        this._runtimeVersion = runtimeVersion;\n        this._rx.runtimeVersion = runtimeVersion;\n        // retrieve metadata, either from chain  or as pass-in via options\n        const metadataKey = `${genesisHash.toHex() || '0x'}-${runtimeVersion.specVersion.toString()}`;\n        const metadata = chainMetadata || (optMetadata?.[metadataKey]\n            ? new Metadata(this.registry, optMetadata[metadataKey])\n            : await firstValueFrom(this._rpcCore.state.getMetadata()));\n        // initializes the registry & RPC\n        this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n        this._filterRpc(rpcMethods.methods.map(textToString), getSpecRpc(this.registry, chain, runtimeVersion.specName));\n        this._subscribeUpdates();\n        // setup the initial registry, when we have none\n        if (!this.__internal__registries.length) {\n            this.__internal__registries.push({ counter: 0, isDefault: true, metadata, registry: this.registry, runtimeVersion });\n        }\n        // get unique types & validate\n        metadata.getUniqTypes(this._options.throwOnUnknown || false);\n        return [genesisHash, metadata];\n    }\n    _initFromMeta(metadata) {\n        const runtimeVersion = this._runtimeVersion;\n        if (!runtimeVersion) {\n            throw new Error('Invalid initializion order, runtimeVersion is not available');\n        }\n        this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();\n        this._rx.extrinsicType = this._extrinsicType;\n        this._rx.genesisHash = this._genesisHash;\n        this._rx.runtimeVersion = runtimeVersion;\n        // inject metadata and adjust the types as detected\n        this._injectMetadata(this._getDefaultRegistry(), true);\n        // derive is last, since it uses the decorated rx\n        this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n        this._derive = this._decorateDerive(this._decorateMethod);\n        return true;\n    }\n    _subscribeHealth() {\n        this._unsubscribeHealth();\n        // Only enable the health keepalive on WS, not needed on HTTP\n        this.__internal__healthTimer = this.hasSubscriptions\n            ? setInterval(() => {\n                firstValueFrom(this._rpcCore.system.health.raw()).catch(noop);\n            }, KEEPALIVE_INTERVAL)\n            : null;\n    }\n    _unsubscribeHealth() {\n        if (this.__internal__healthTimer) {\n            clearInterval(this.__internal__healthTimer);\n            this.__internal__healthTimer = null;\n        }\n    }\n    _unsubscribeUpdates() {\n        if (this.__internal__updateSub) {\n            this.__internal__updateSub.unsubscribe();\n            this.__internal__updateSub = null;\n        }\n    }\n    _unsubscribe() {\n        this._unsubscribeHealth();\n        this._unsubscribeUpdates();\n    }\n    async __internal__onProviderConnect() {\n        this._isConnected.next(true);\n        this.emit('connected');\n        try {\n            const cryptoReady = this._options.initWasm === false\n                ? true\n                : await cryptoWaitReady();\n            const hasMeta = await this._loadMeta();\n            this._subscribeHealth();\n            if (hasMeta && !this._isReady && cryptoReady) {\n                this._isReady = true;\n                this.emit('ready', this);\n            }\n        }\n        catch (_error) {\n            const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n            l.error(error);\n            this.emit('error', error);\n        }\n    }\n    __internal__onProviderDisconnect() {\n        this._isConnected.next(false);\n        this._unsubscribe();\n        this.emit('disconnected');\n    }\n    __internal__onProviderError(error) {\n        this.emit('error', error);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}