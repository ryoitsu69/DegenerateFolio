{"ast":null,"code":"import { Rectangle } from '../maths/shapes/Rectangle.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\n\"use strict\";\nconst _Spritesheet = class _Spritesheet {\n  /**\n   * @param texture - Reference to the source BaseTexture object.\n   * @param {object} data - Spritesheet image data.\n   */\n  constructor(texture, data) {\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    this.linkedSheets = [];\n    this._texture = texture instanceof Texture ? texture : null;\n    this.textureSource = texture.source;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    const metaResolution = parseFloat(data.meta.scale);\n    if (metaResolution) {\n      this.resolution = metaResolution;\n      texture.source.resolution = this.resolution;\n    } else {\n      this.resolution = texture.source._resolution;\n    }\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   */\n  parse() {\n    return new Promise(resolve => {\n      this._callback = resolve;\n      this._batchIndex = 0;\n      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n        this._processFrames(0);\n        this._processAnimations();\n        this._parseComplete();\n      } else {\n        this._nextBatch();\n      }\n    });\n  }\n  /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */\n  _processFrames(initialFrameIndex) {\n    let frameIndex = initialFrameIndex;\n    const maxFrames = _Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      const i = this._frameKeys[frameIndex];\n      const data = this._frames[i];\n      const rect = data.frame;\n      if (rect) {\n        let frame = null;\n        let trim = null;\n        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        const orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);\n        if (data.rotated) {\n          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);\n        } else {\n          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n        }\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n        }\n        this.textures[i] = new Texture({\n          source: this.textureSource,\n          frame,\n          orig,\n          trim,\n          rotate: data.rotated ? 2 : 0,\n          defaultAnchor: data.anchor,\n          defaultBorders: data.borders,\n          label: i.toString()\n        });\n      }\n      frameIndex++;\n    }\n  }\n  /** Parse animations config. */\n  _processAnimations() {\n    const animations = this.data.animations || {};\n    for (const animName in animations) {\n      this.animations[animName] = [];\n      for (let i = 0; i < animations[animName].length; i++) {\n        const frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  }\n  /** The parse has completed. */\n  _parseComplete() {\n    const callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  }\n  /** Begin the next batch of textures. */\n  _nextBatch() {\n    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(() => {\n      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {\n        this._nextBatch();\n      } else {\n        this._processAnimations();\n        this._parseComplete();\n      }\n    }, 0);\n  }\n  /**\n   * Destroy Spritesheet and don't use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */\n  destroy(destroyBase = false) {\n    for (const i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      this._texture?.destroy();\n      this.textureSource.destroy();\n    }\n    this._texture = null;\n    this.textureSource = null;\n    this.linkedSheets = [];\n  }\n};\n/** The maximum number of Textures to build per process. */\n_Spritesheet.BATCH_SIZE = 1e3;\nlet Spritesheet = _Spritesheet;\nexport { Spritesheet };","map":{"version":3,"names":["_Spritesheet","constructor","texture","data","linkedSheets","_texture","Texture","textureSource","source","textures","animations","metaResolution","parseFloat","meta","scale","resolution","_resolution","_frames","frames","_frameKeys","Object","keys","_batchIndex","_callback","parse","Promise","resolve","length","BATCH_SIZE","_processFrames","_processAnimations","_parseComplete","_nextBatch","initialFrameIndex","frameIndex","maxFrames","i","rect","frame","trim","sourceSize","trimmed","orig","Rectangle","Math","floor","w","h","rotated","x","y","spriteSourceSize","rotate","defaultAnchor","anchor","defaultBorders","borders","label","toString","animName","frameName","push","callback","call","setTimeout","destroy","destroyBase","Spritesheet"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/spritesheet/Spritesheet.ts"],"sourcesContent":["import { Rectangle } from '../maths/shapes/Rectangle';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\n\nimport type { PointData } from '../maths/point/PointData';\nimport type { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { BindableTexture, TextureBorders } from '../rendering/renderers/shared/texture/Texture';\nimport type { Dict } from '../utils/types';\n\n/**\n * Represents the JSON data for a spritesheet atlas.\n * @memberof assets\n */\nexport interface SpritesheetFrameData\n{\n    /** The frame rectangle of the texture. */\n    frame: {\n        x: number;\n        y: number;\n        w: number;\n        h: number;\n    };\n    /** Whether the texture is trimmed. */\n    trimmed?: boolean;\n    /** Whether the texture is rotated. */\n    rotated?: boolean;\n    /** The source size of the texture. */\n    sourceSize?: {\n        w: number;\n        h: number;\n    };\n    /** The sprite source size. */\n    spriteSourceSize?: {\n        h?: number;\n        w?: number;\n        x: number;\n        y: number;\n    };\n    /** The anchor point of the texture. */\n    anchor?: PointData;\n    /** The 9-slice borders of the texture. */\n    borders?: TextureBorders\n}\n\n/**\n * Atlas format.\n * @memberof assets\n */\nexport interface SpritesheetData\n{\n    /** The frames of the atlas. */\n    frames: Dict<SpritesheetFrameData>;\n    /** The animations of the atlas. */\n    animations?: Dict<string[]>;\n    /** The meta data of the atlas. */\n    meta: {\n        app?: string;\n        format?: string;\n        frameTags?: {\n            from: number;\n            name: string;\n            to: number;\n            direction: string;\n        }[];\n        image?: string;\n        layers?: {\n            blendMode: string;\n            name: string;\n            opacity: number;\n        }[];\n        scale: number | string;\n        size?: {\n            h: number;\n            w: number;\n        };\n        slices?: {\n            color: string;\n            name: string;\n            keys: {\n                frame: number,\n                bounds: {\n                    x: number;\n                    y: number;\n                    w: number;\n                    h: number;\n                };\n            }[];\n        }[];\n        // eslint-disable-next-line camelcase\n        related_multi_packs?: string[];\n        version?: string;\n    };\n}\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code you may pass its JSON data file to Pixi's loader:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('images/spritesheet.json');\n * ```\n *\n * Alternately, you may circumvent the loader by instantiating the Spritesheet directly:\n *\n * ```js\n * import { Spritesheet } from 'pixi.js';\n *\n * const sheet = new Spritesheet(texture, spritesheetData);\n * await sheet.parse();\n * console.log('Spritesheet ready to use!');\n * ```\n *\n * With the `sheet.textures` you can create Sprite objects, and `sheet.animations` can be used to create an AnimatedSprite.\n *\n * Here's an example of a sprite sheet JSON data file:\n * ```json\n * {\n *     \"frames\": {\n *         \"enemy1.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":1,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":16,\"y\":16}\n *         },\n *         \"enemy2.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":35,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":16,\"y\":16}\n *         },\n *         \"button.png\":\n *         {\n *             \"frame\": {\"x\":1,\"y\":1,\"w\":100,\"h\":100},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":100,\"h\":100},\n *             \"sourceSize\": {\"w\":100,\"h\":100},\n *             \"anchor\": {\"x\":0,\"y\":0},\n *             \"borders\": {\"left\":35,\"top\":35,\"right\":35,\"bottom\":35}\n *         }\n *     },\n *\n *     \"animations\": {\n *         \"enemy\": [\"enemy1.png\",\"enemy2.png\"]\n *     },\n *\n *     \"meta\": {\n *         \"image\": \"sheet.png\",\n *         \"format\": \"RGBA8888\",\n *         \"size\": {\"w\":136,\"h\":102},\n *         \"scale\": \"1\"\n *     }\n * }\n * ```\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link Texture#defaultAnchor}), default 9-slice borders\n * (see {@link Texture#defaultBorders}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * Alternative ways for loading spritesheet image if you need more control:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheetTexture = await Assets.load('images/spritesheet.png');\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {texture: sheetTexture} // using of preloaded texture\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n *\n * or:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {imageFilename: 'my-spritesheet.2x.avif'} // using of custom filename located in \"images/my-spritesheet.2x.avif\"\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n * @memberof assets\n */\nexport class Spritesheet<S extends SpritesheetData = SpritesheetData>\n{\n    /** The maximum number of Textures to build per process. */\n    public static readonly BATCH_SIZE = 1000;\n\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    public linkedSheets: Spritesheet<S>[] = [];\n\n    /** Reference to ths source texture. */\n    public textureSource: TextureSource;\n\n    /**\n     * A map containing all textures of the sprite sheet.\n     * Can be used to create a {@link Sprite|Sprite}:\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * new Sprite(sheet.textures['image.png']);\n     */\n    public textures: Record<keyof S['frames'], Texture>;\n\n    /**\n     * A map containing the textures for each animation.\n     * Can be used to create an {@link AnimatedSprite|AnimatedSprite}:\n     * @example\n     * import { AnimatedSprite } from 'pixi.js';\n     *\n     * new AnimatedSprite(sheet.animations['anim_name']);\n     */\n    public animations: Record<keyof NonNullable<S['animations']>, Texture[]>;\n\n    /**\n     * Reference to the original JSON data.\n     * @type {object}\n     */\n    public data: S;\n\n    /** The resolution of the spritesheet. */\n    public resolution: number;\n\n    /**\n     * Reference to original source image from the Loader. This reference is retained so we\n     * can destroy the Texture later on. It is never used internally.\n     */\n    private _texture: Texture;\n\n    /**\n     * Map of spritesheet frames.\n     * @type {object}\n     */\n    private _frames: S['frames'];\n\n    /** Collection of frame names. */\n    private _frameKeys: (keyof S['frames'])[];\n\n    /** Current batch index being processed. */\n    private _batchIndex: number;\n\n    /**\n     * Callback when parse is completed.\n     * @type {Function}\n     */\n    private _callback: (textures: Dict<Texture>) => void;\n\n    /**\n     * @param texture - Reference to the source BaseTexture object.\n     * @param {object} data - Spritesheet image data.\n     */\n    constructor(texture: BindableTexture, data: S)\n    {\n        this._texture = texture instanceof Texture ? texture : null;\n        this.textureSource = texture.source;\n        this.textures = {} as Record<keyof S['frames'], Texture>;\n        this.animations = {} as Record<keyof NonNullable<S['animations']>, Texture[]>;\n        this.data = data;\n\n        const metaResolution = parseFloat(data.meta.scale as string);\n\n        if (metaResolution)\n        {\n            this.resolution = metaResolution;\n            texture.source.resolution = this.resolution;\n        }\n        else\n        {\n            this.resolution = texture.source._resolution;\n        }\n\n        this._frames = this.data.frames;\n        this._frameKeys = Object.keys(this._frames);\n        this._batchIndex = 0;\n        this._callback = null;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     */\n    public parse(): Promise<Record<string, Texture>>\n    {\n        return new Promise((resolve) =>\n        {\n            this._callback = resolve;\n            this._batchIndex = 0;\n\n            if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n            {\n                this._processFrames(0);\n                this._processAnimations();\n                this._parseComplete();\n            }\n            else\n            {\n                this._nextBatch();\n            }\n        });\n    }\n\n    /**\n     * Process a batch of frames\n     * @param initialFrameIndex - The index of frame to start.\n     */\n    private _processFrames(initialFrameIndex: number): void\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w) / this.resolution,\n                    Math.floor(sourceSize.h) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.h) / this.resolution,\n                        Math.floor(rect.w) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture({\n                    source: this.textureSource,\n\n                    frame,\n                    orig,\n                    trim,\n                    rotate: data.rotated ? 2 : 0,\n                    defaultAnchor: data.anchor,\n                    defaultBorders: data.borders,\n\n                    label: i.toString(),\n                });\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /** Parse animations config. */\n    private _processAnimations(): void\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName as keyof S['animations']] = [];\n            for (let i = 0; i < animations[animName].length; i++)\n            {\n                const frameName = animations[animName][i];\n\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /** The parse has completed. */\n    private _parseComplete(): void\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /** Begin the next batch of textures. */\n    private _nextBatch(): void\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n     */\n    public destroy(destroyBase = false): void\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this._texture?.destroy();\n            this.textureSource.destroy();\n        }\n        this._texture = null;\n        this.textureSource = null;\n        this.linkedSheets = [];\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}