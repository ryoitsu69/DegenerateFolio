{"ast":null,"code":"import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { Matrix } from '../maths/matrix/Matrix.mjs';\nimport { Point } from '../maths/point/Point.mjs';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../rendering/renderers/types.mjs';\nimport { Bounds } from '../scene/container/bounds/Bounds.mjs';\nimport { getFastGlobalBounds } from '../scene/container/bounds/getFastGlobalBounds.mjs';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\n\"use strict\";\nconst quadGeometry = new Geometry({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      location: 0,\n      format: \"float32x2\",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup({\n      uInputSize: {\n        value: new Float32Array(4),\n        type: \"vec4<f32>\"\n      },\n      uInputPixel: {\n        value: new Float32Array(4),\n        type: \"vec4<f32>\"\n      },\n      uInputClamp: {\n        value: new Float32Array(4),\n        type: \"vec4<f32>\"\n      },\n      uOutputFrame: {\n        value: new Float32Array(4),\n        type: \"vec4<f32>\"\n      },\n      uGlobalFrame: {\n        value: new Float32Array(4),\n        type: \"vec4<f32>\"\n      },\n      uOutputTexture: {\n        value: new Float32Array(4),\n        type: \"vec4<f32>\"\n      }\n    });\n    this._globalFilterBindGroup = new BindGroup({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    if (!this._filterStack[this._filterStackIndex]) {\n      this._filterStack[this._filterStackIndex] = this._getFilterData();\n    }\n    const filterData = this._filterStack[this._filterStackIndex];\n    this._filterStackIndex++;\n    if (filters.length === 0) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    if (instruction.renderables) {\n      getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      getFastGlobalBounds(instruction.container, bounds);\n    }\n    const colorTextureSource = renderer.renderTarget.rootRenderTarget.colorTexture.source;\n    let resolution = colorTextureSource._resolution;\n    let padding = 0;\n    let antialias = colorTextureSource.antialias;\n    let blendRequired = false;\n    let enabled = false;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias !== \"inherit\") {\n        if (filter.antialias === \"on\") {\n          antialias = true;\n        } else {\n          antialias = false;\n        }\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        warn(\"Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.\");\n        enabled = false;\n        break;\n      }\n      enabled = filter.enabled || enabled;\n      blendRequired = blendRequired || filter.blendRequired;\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    const viewPort = renderer.renderTarget.rootViewPort;\n    bounds.scale(resolution).fitBounds(0, viewPort.width, 0, viewPort.height).scale(1 / resolution).pad(padding).ceil();\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.skip = false;\n    filterData.bounds = bounds;\n    filterData.blendRequired = blendRequired;\n    filterData.container = instruction.container;\n    filterData.filterEffect = instruction.filterEffect;\n    filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n    filterData.inputTexture = TexturePool.getOptimalTexture(bounds.width, bounds.height, resolution, antialias);\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  pop() {\n    const renderer = this.renderer;\n    this._filterStackIndex--;\n    const filterData = this._filterStack[this._filterStackIndex];\n    if (filterData.skip) {\n      return;\n    }\n    this._activeFilterData = filterData;\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    let backTexture = Texture.EMPTY;\n    renderer.renderTarget.finishRenderPass();\n    if (filterData.blendRequired) {\n      const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n      backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n    }\n    filterData.backTexture = backTexture;\n    const filters = filterData.filterEffect.filters;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(backTexture.source, 3);\n    renderer.globalUniforms.pop();\n    if (filters.length === 1) {\n      filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n      TexturePool.returnTexture(inputTexture);\n    } else {\n      let flip = filterData.inputTexture;\n      let flop = TexturePool.getOptimalTexture(bounds.width, bounds.height, flip.source._resolution, false);\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        const filter = filters[i];\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n      TexturePool.returnTexture(flip);\n      TexturePool.returnTexture(flop);\n    }\n    if (filterData.blendRequired) {\n      TexturePool.returnTexture(backTexture);\n    }\n  }\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool.getOptimalTexture(bounds.width, bounds.height, backgroundResolution, false);\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(lastRenderSurface, backTexture, {\n      x,\n      y\n    }, {\n      width,\n      height\n    }, {\n      x: 0,\n      y: 0\n    });\n    return backTexture;\n  }\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._filterStack[this._filterStackIndex];\n    const bounds = filterData.bounds;\n    const offset = Point.shared;\n    const previousRenderSurface = filterData.previousRenderSurface;\n    const isFinalTarget = previousRenderSurface === output;\n    let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n    let currentIndex = this._filterStackIndex - 1;\n    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {\n      --currentIndex;\n    }\n    if (currentIndex > 0) {\n      resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n    }\n    const filterUniforms = this._filterGlobalUniforms;\n    const uniforms = filterUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (isFinalTarget) {\n      let lastIndex = this._filterStackIndex;\n      while (lastIndex > 0) {\n        lastIndex--;\n        const filterData2 = this._filterStack[this._filterStackIndex - 1];\n        if (!filterData2.skip) {\n          offset.x = filterData2.bounds.minX;\n          offset.y = filterData2.bounds.minY;\n          break;\n        }\n      }\n      outputFrame[0] = bounds.minX - offset.x;\n      outputFrame[1] = bounds.minY - offset.y;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n    globalFrame[0] = offset.x * resolution;\n    globalFrame[1] = offset.y * resolution;\n    globalFrame[2] = rootTexture.source.width * resolution;\n    globalFrame[3] = rootTexture.source.height * resolution;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    filterUniforms.update();\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(filterUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: \"triangle-list\"\n    });\n    if (renderer.type === RendererType.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  _getFilterData() {\n    return {\n      skip: false,\n      inputTexture: null,\n      bounds: new Bounds(),\n      container: null,\n      filterEffect: null,\n      blendRequired: false,\n      previousRenderSurface: null\n    };\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(data.inputTexture._source.width, 0, 0, data.inputTexture._source.height, data.bounds.minX, data.bounds.minY);\n    const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(1 / sprite.texture.frame.width, 1 / sprite.texture.frame.height);\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [ExtensionType.WebGLSystem, ExtensionType.WebGPUSystem],\n  name: \"filter\"\n};\nexport { FilterSystem };","map":{"version":3,"names":["quadGeometry","Geometry","attributes","aPosition","buffer","Float32Array","location","format","stride","offset","indexBuffer","Uint32Array","FilterSystem","constructor","renderer","_filterStackIndex","_filterStack","_filterGlobalUniforms","UniformGroup","uInputSize","value","type","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","BindGroup","activeBackTexture","_activeFilterData","backTexture","push","instruction","filters","filterEffect","_getFilterData","filterData","length","skip","bounds","renderables","getGlobalRenderableBounds","filterArea","clear","addRect","applyMatrix","container","worldTransform","getFastGlobalBounds","colorTextureSource","renderTarget","rootRenderTarget","colorTexture","source","resolution","_resolution","padding","antialias","blendRequired","enabled","i","filter","Math","min","isCompatible","compatibleRenderers","backBuffer","useBackBuffer","warn","viewPort","rootViewPort","scale","fitBounds","width","height","pad","ceil","isPositive","previousRenderSurface","renderSurface","inputTexture","TexturePool","getOptimalTexture","bind","globalUniforms","pop","Texture","EMPTY","finishRenderPass","previousBounds","getRenderTarget","getBackTexture","setResource","style","apply","returnTexture","flip","flop","t","lastRenderSurface","backgroundResolution","x","minX","y","minY","floor","copyToTexture","applyFilter","input","output","Point","shared","isFinalTarget","currentIndex","filterUniforms","uniforms","outputFrame","inputSize","inputPixel","inputClamp","globalFrame","outputTexture","lastIndex","filterData2","frame","pixelWidth","pixelHeight","rootTexture","isRoot","update","renderPipes","uniformBatch","batchUniforms","getUboResource","groups","encoder","draw","geometry","shader","state","_state","topology","RendererType","WEBGL","Bounds","calculateSpriteMatrix","outputMatrix","sprite","data","mappedMatrix","set","_source","copyTo","Matrix","invert","prepend","texture","translate","anchor","extension","ExtensionType","WebGLSystem","WebGPUSystem","name"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/filters/FilterSystem.ts"],"sourcesContent":["import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { Point } from '../maths/point/Point';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getFastGlobalBounds } from '../scene/container/bounds/getFastGlobalBounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\ntype FilterAction = 'pushFilter' | 'popFilter';\n\n//\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            location: 0,\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: FilterAction,\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\nexport interface FilterData\n{\n    skip: boolean;\n    enabledLength?: number;\n    inputTexture: Texture\n    bounds: Bounds,\n    blendRequired: boolean,\n    container: Container,\n    filterEffect: FilterEffect,\n    previousRenderSurface: RenderSurface,\n    backTexture?: Texture,\n}\n\n/**\n * System that manages the filter pipeline\n * @memberof rendering\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        if (!this._filterStack[this._filterStackIndex])\n        {\n            this._filterStack[this._filterStackIndex] = this._getFilterData();\n        }\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        this._filterStackIndex++;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds: Bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            getFastGlobalBounds(instruction.container, bounds);\n        }\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        const colorTextureSource = renderer.renderTarget.rootRenderTarget.colorTexture.source;\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = colorTextureSource._resolution;\n\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for any filter, it should be true\n        let antialias = colorTextureSource.antialias;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias !== 'inherit')\n            {\n                if (filter.antialias === 'on')\n                {\n                    antialias = true;\n                }\n                else\n                {\n                    antialias = false;\n                }\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired = blendRequired || filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const viewPort = renderer.renderTarget.rootViewPort;\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        // need to factor in resolutions also..\n        bounds.scale(resolution)\n            .fitBounds(0, viewPort.width, 0, viewPort.height)\n            .scale(1 / resolution)\n            .pad(padding)\n            .ceil();\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set all the filter data\n        filterData.skip = false;\n\n        filterData.bounds = bounds;\n        filterData.blendRequired = blendRequired;\n        filterData.container = instruction.container;\n        filterData.filterEffect = instruction.filterEffect;\n\n        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            resolution,\n            antialias,\n        );\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        // set the global uniforms to take into account the bounds offset required\n\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        this._filterStackIndex--;\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        this._activeFilterData = filterData;\n\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        let backTexture = Texture.EMPTY;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (filterData.blendRequired)\n        {\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n\n            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n        }\n\n        filterData.backTexture = backTexture;\n\n        const filters = filterData.filterEffect.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        // eslint-disable-next-line max-len\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(backTexture.source, 3);\n\n        renderer.globalUniforms.pop();\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            // this.applyFilter(filters[0], inputTexture, filterData.previousRenderSurface, false);\n            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n\n            // return the texture to the pool so we can reuse the next frame\n            TexturePool.returnTexture(inputTexture);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            // get another texture that we will render the next filter too\n            let flop = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n\n            // return those textures for later!\n            TexturePool.returnTexture(flip);\n            TexturePool.returnTexture(flop);\n        }\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(backTexture);\n        }\n    }\n\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        const bounds = filterData.bounds;\n\n        const offset = Point.shared;\n        const previousRenderSurface = filterData.previousRenderSurface;\n\n        const isFinalTarget = previousRenderSurface === output;\n\n        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n\n        // to find the previous resolution we need to account for the skipped filters\n        // the following will find the last non skipped filter...\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        if (currentIndex > 0)\n        {\n            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n        }\n\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            let lastIndex = this._filterStackIndex;\n\n            // get previous bounds.. we must take into account skipped filters also..\n            while (lastIndex > 0)\n            {\n                lastIndex--;\n                const filterData = this._filterStack[this._filterStackIndex - 1];\n\n                if (!filterData.skip)\n                {\n                    offset.x = filterData.bounds.minX;\n                    offset.y = filterData.bounds.minY;\n\n                    break;\n                }\n            }\n\n            outputFrame[0] = bounds.minX - offset.x;\n            outputFrame[1] = bounds.minY - offset.y;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offset.x * resolution;\n        globalFrame[1] = offset.y * resolution;\n\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // set the output texture - this is where we are going to render to\n\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n        filterUniforms.update();\n\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(filterUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    private _getFilterData(): FilterData\n    {\n        return {\n            skip: false,\n            inputTexture: null,\n            bounds: new Bounds(),\n            container: null,\n            filterEffect: null,\n            blendRequired: false,\n            previousRenderSurface: null,\n        };\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.frame.width,\n            1.0 / sprite.texture.frame.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy?: () => void;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}