{"ast":null,"code":"import { Bounds } from '../scene/container/bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../scene/container/bounds/getGlobalBounds.mjs';\n\"use strict\";\nconst tempBounds = new Bounds();\nconst _Culler = class _Culler {\n  /**\n   * Culls the children of a specific container based on the given view. This will also cull items that are not\n   * being explicitly managed by the culler.\n   * @param container - The container to cull.\n   * @param view - The view rectangle.\n   * @param skipUpdateTransform - Whether to skip updating the transform.\n   */\n  cull(container, view, skipUpdateTransform = true) {\n    this._cullRecursive(container, view, skipUpdateTransform);\n  }\n  _cullRecursive(container, view, skipUpdateTransform = true) {\n    if (container.cullable && container.measurable && container.includeInBuild) {\n      const bounds = container.cullArea ?? getGlobalBounds(container, skipUpdateTransform, tempBounds);\n      container.culled = !(bounds.x >= view.x + view.width || bounds.y >= view.y + view.height || bounds.x + bounds.width <= view.x || bounds.y + bounds.height <= view.y);\n    }\n    if (!container.cullableChildren || container.culled || !container.renderable || !container.measurable || !container.includeInBuild) return;\n    for (let i = 0; i < container.children.length; i++) {\n      this._cullRecursive(container.children[i], view, skipUpdateTransform);\n    }\n  }\n};\n/** A shared instance of the Culler class. */\n_Culler.shared = new _Culler();\nlet Culler = _Culler;\nexport { Culler };","map":{"version":3,"names":["tempBounds","Bounds","_Culler","cull","container","view","skipUpdateTransform","_cullRecursive","cullable","measurable","includeInBuild","bounds","cullArea","getGlobalBounds","culled","x","width","y","height","cullableChildren","renderable","i","children","length","shared","Culler"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/culling/Culler.ts"],"sourcesContent":["import { Bounds } from '../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../scene/container/bounds/getGlobalBounds';\n\nimport type { Container } from '../scene/container/Container';\n\nconst tempBounds = new Bounds();\n\ntype RectangleLike = {x: number, y: number, width: number, height: number};\n\n/**\n * The Culler class is responsible for managing and culling containers.\n *\n *\n * Culled containers will not be rendered, and their children will not be processed. This can be useful for\n * performance optimization when dealing with large scenes.\n * @example\n * import { Culler, Container } from 'pixi.js';\n *\n * const culler = new Culler();\n * const stage = new Container();\n *\n * ... set up stage ...\n *\n * culler.cull(stage, { x: 0, y: 0, width: 800, height: 600 });\n * renderer.render(stage);\n * @memberof scene\n */\nexport class Culler\n{\n    /**\n     * Culls the children of a specific container based on the given view. This will also cull items that are not\n     * being explicitly managed by the culler.\n     * @param container - The container to cull.\n     * @param view - The view rectangle.\n     * @param skipUpdateTransform - Whether to skip updating the transform.\n     */\n    public cull(container: Container, view: RectangleLike, skipUpdateTransform = true)\n    {\n        this._cullRecursive(container, view, skipUpdateTransform);\n    }\n\n    private _cullRecursive(container: Container, view: RectangleLike, skipUpdateTransform = true)\n    {\n        if (container.cullable && container.measurable && container.includeInBuild)\n        {\n            const bounds = container.cullArea ?? getGlobalBounds(container, skipUpdateTransform, tempBounds);\n\n            // check view intersection..\n            container.culled = !(bounds.x >= view.x + view.width\n                || bounds.y >= view.y + view.height\n                || bounds.x + bounds.width <= view.x\n                || bounds.y + bounds.height <= view.y);\n        }\n\n        // dont process children if not needed\n        if (\n            !container.cullableChildren\n            || container.culled\n            || !container.renderable\n            || !container.measurable\n            || !container.includeInBuild\n        ) return;\n\n        for (let i = 0; i < container.children.length; i++)\n        {\n            this._cullRecursive(container.children[i], view, skipUpdateTransform);\n        }\n    }\n\n    /** A shared instance of the Culler class. */\n    public static shared = new Culler();\n}\n"],"mappings":";;;AAKA,MAAMA,UAAA,GAAa,IAAIC,MAAO;AAsBvB,MAAMC,OAAA,GAAN,MAAMA,OACb;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQWC,IAAKA,CAAAC,SAAA,EAAsBC,IAAqB,EAAAC,mBAAA,GAAsB,IAC7E;IACS,KAAAC,cAAA,CAAeH,SAAW,EAAAC,IAAA,EAAMC,mBAAmB;EAAA;EAGpDC,cAAeA,CAAAH,SAAA,EAAsBC,IAAqB,EAAAC,mBAAA,GAAsB,IACxF;IACI,IAAIF,SAAU,CAAAI,QAAA,IAAYJ,SAAU,CAAAK,UAAA,IAAcL,SAAA,CAAUM,cAC5D;MACI,MAAMC,MAAA,GAASP,SAAU,CAAAQ,QAAA,IAAYC,eAAgB,CAAAT,SAAA,EAAWE,mBAAA,EAAqBN,UAAU;MAGrFI,SAAA,CAAAU,MAAA,GAAS,EAAEH,MAAA,CAAOI,CAAK,IAAAV,IAAA,CAAKU,CAAA,GAAIV,IAAK,CAAAW,KAAA,IACxCL,MAAO,CAAAM,CAAA,IAAKZ,IAAK,CAAAY,CAAA,GAAIZ,IAAA,CAAKa,MAC1B,IAAAP,MAAA,CAAOI,CAAI,GAAAJ,MAAA,CAAOK,KAAS,IAAAX,IAAA,CAAKU,CAAA,IAChCJ,MAAO,CAAAM,CAAA,GAAIN,MAAO,CAAAO,MAAA,IAAUb,IAAK,CAAAY,CAAA;IAAA;IAI5C,IACI,CAACb,SAAA,CAAUe,gBACR,IAAAf,SAAA,CAAUU,MACV,KAACV,SAAU,CAAAgB,UAAA,IACX,CAAChB,SAAA,CAAUK,UACX,KAACL,SAAU,CAAAM,cAAA,EAChB;IAEF,SAASW,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAIjB,SAAU,CAAAkB,QAAA,CAASC,MAAA,EAAQF,CAC/C;MACI,KAAKd,cAAA,CAAeH,SAAU,CAAAkB,QAAA,CAASD,CAAC,GAAGhB,IAAA,EAAMC,mBAAmB;IAAA;EACxE;AAKR;AAAA;AA5CaJ,OA2CK,CAAAsB,MAAA,GAAS,IAAItB,OAAO;AA3C/B,IAAMuB,MAAN,GAAAvB,OAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}