{"ast":null,"code":"import { MASK_TYPES } from \"@pixi/constants\";\nimport { Filter } from \"../filters/Filter.mjs\";\nclass MaskData {\n  /**\n   * Create MaskData\n   * @param {PIXI.DisplayObject} [maskObject=null] - object that describes the mask\n   */\n  constructor(maskObject = null) {\n    this.type = MASK_TYPES.NONE, this.autoDetect = !0, this.maskObject = maskObject || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = Filter.defaultMultisample, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;\n  }\n  /**\n   * The sprite mask filter.\n   * If set to `null`, the default sprite mask filter is used.\n   * @default null\n   */\n  get filter() {\n    return this._filters ? this._filters[0] : null;\n  }\n  set filter(value) {\n    value ? this._filters ? this._filters[0] = value : this._filters = [value] : this._filters = null;\n  }\n  /** Resets the mask data after popMask(). */\n  reset() {\n    this.pooled && (this.maskObject = null, this.type = MASK_TYPES.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null;\n  }\n  /**\n   * Copies counters from maskData above, called from pushMask().\n   * @param maskAbove\n   */\n  copyCountersOrReset(maskAbove) {\n    maskAbove ? (this._stencilCounter = maskAbove._stencilCounter, this._scissorCounter = maskAbove._scissorCounter, this._scissorRect = maskAbove._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);\n  }\n}\nexport { MaskData };","map":{"version":3,"names":["MaskData","constructor","maskObject","type","MASK_TYPES","NONE","autoDetect","pooled","isMaskData","resolution","multisample","Filter","defaultMultisample","enabled","colorMask","_filters","_stencilCounter","_scissorCounter","_scissorRect","_scissorRectLocal","_colorMask","_target","filter","value","reset","copyCountersOrReset","maskAbove"],"sources":["/home/ryoitsu/node_modules/@pixi/core/src/mask/MaskData.ts"],"sourcesContent":["import { MASK_TYPES } from '@pixi/constants';\nimport { Filter } from '../filters/Filter';\n\nimport type { MSAA_QUALITY } from '@pixi/constants';\nimport type { Matrix, Rectangle } from '@pixi/math';\nimport type { IFilterTarget } from '../filters/IFilterTarget';\nimport type { ISpriteMaskFilter } from '../filters/spriteMask/SpriteMaskFilter';\nimport type { Renderer } from '../Renderer';\n\nexport interface IMaskTarget extends IFilterTarget\n{\n    renderable: boolean;\n    isSprite?: boolean;\n    worldTransform: Matrix;\n    isFastRect?(): boolean;\n    getBounds(skipUpdate?: boolean, rect?: Rectangle): Rectangle;\n    render(renderer: Renderer): void;\n}\n/**\n * Component for masked elements.\n *\n * Holds mask mode and temporary data about current mask.\n * @memberof PIXI\n */\nexport class MaskData\n{\n    /** Mask type */\n    public type: MASK_TYPES;\n\n    /**\n     * Whether we know the mask type beforehand\n     * @default true\n     */\n    public autoDetect: boolean;\n\n    /**\n     * Which element we use to mask\n     * @member {PIXI.DisplayObject}\n     */\n    public maskObject: IMaskTarget;\n\n    /** Whether it belongs to MaskSystem pool */\n    public pooled: boolean;\n\n    /** Indicator of the type (always true for {@link PIXI.MaskData} objects) */\n    public isMaskData: boolean;// webdoc crashes if the type is true because reasons... (will fix)\n\n    /**\n     * Resolution of the sprite mask filter.\n     * If set to `null` or `0`, the resolution of the current render target is used.\n     * @default null\n     */\n    public resolution: number | null;\n\n    /**\n     * Number of samples of the sprite mask filter.\n     * If set to `null`, the sample count of the current render target is used.\n     * @default PIXI.Filter.defaultMultisample\n     */\n    public multisample: MSAA_QUALITY | null;\n\n    /** If enabled is true the mask is applied, if false it will not. */\n    public enabled: boolean;\n\n    /**\n     * Color mask.\n     * @see PIXI.COLOR_MASK_BITS\n     */\n    public colorMask: number;\n\n    /**\n     * The sprite mask filter wrapped in an array.\n     * @private\n     */\n    _filters: ISpriteMaskFilter[];\n\n    /**\n     * Stencil counter above the mask in stack\n     * @private\n     */\n    _stencilCounter: number;\n\n    /**\n     * Scissor counter above the mask in stack\n     * @private\n     */\n    _scissorCounter: number;\n\n    /**\n     * Scissor operation above the mask in stack.\n     * Null if _scissorCounter is zero, rectangle instance if positive.\n     * @private\n     */\n    _scissorRect: Rectangle;\n\n    /**\n     * pre-computed scissor rect\n     * does become _scissorRect when mask is actually pushed\n     * @private\n     */\n    _scissorRectLocal: Rectangle;\n\n    /**\n     * pre-computed color mask\n     * @private\n     */\n    _colorMask: number;\n\n    /**\n     * Targeted element. Temporary variable set by MaskSystem\n     * @member {PIXI.DisplayObject}\n     * @private\n     */\n    _target: IMaskTarget;\n\n    /**\n     * Create MaskData\n     * @param {PIXI.DisplayObject} [maskObject=null] - object that describes the mask\n     */\n    constructor(maskObject: IMaskTarget = null)\n    {\n        this.type = MASK_TYPES.NONE;\n        this.autoDetect = true;\n        this.maskObject = maskObject || null;\n        this.pooled = false;\n        this.isMaskData = true;\n        this.resolution = null;\n        this.multisample = Filter.defaultMultisample;\n        this.enabled = true;\n        this.colorMask = 0xf;\n        this._filters = null;\n        this._stencilCounter = 0;\n        this._scissorCounter = 0;\n        this._scissorRect = null;\n        this._scissorRectLocal = null;\n        this._colorMask = 0xf;\n        this._target = null;\n    }\n\n    /**\n     * The sprite mask filter.\n     * If set to `null`, the default sprite mask filter is used.\n     * @default null\n     */\n    get filter(): ISpriteMaskFilter\n    {\n        return this._filters ? this._filters[0] : null;\n    }\n\n    set filter(value: ISpriteMaskFilter)\n    {\n        if (value)\n        {\n            if (this._filters)\n            {\n                this._filters[0] = value;\n            }\n            else\n            {\n                this._filters = [value];\n            }\n        }\n        else\n        {\n            this._filters = null;\n        }\n    }\n\n    /** Resets the mask data after popMask(). */\n    reset(): void\n    {\n        if (this.pooled)\n        {\n            this.maskObject = null;\n\n            this.type = MASK_TYPES.NONE;\n\n            this.autoDetect = true;\n        }\n\n        this._target = null;\n        this._scissorRectLocal = null;\n    }\n\n    /**\n     * Copies counters from maskData above, called from pushMask().\n     * @param maskAbove\n     */\n    copyCountersOrReset(maskAbove?: MaskData): void\n    {\n        if (maskAbove)\n        {\n            this._stencilCounter = maskAbove._stencilCounter;\n            this._scissorCounter = maskAbove._scissorCounter;\n            this._scissorRect = maskAbove._scissorRect;\n        }\n        else\n        {\n            this._stencilCounter = 0;\n            this._scissorCounter = 0;\n            this._scissorRect = null;\n        }\n    }\n}\n"],"mappings":";;AAwBO,MAAMA,QAAA,CACb;EAAA;AAAA;AAAA;AAAA;EA8FIC,YAAYC,UAAA,GAA0B,MACtC;IACS,KAAAC,IAAA,GAAOC,UAAA,CAAWC,IAAA,EACvB,KAAKC,UAAA,GAAa,IAClB,KAAKJ,UAAA,GAAaA,UAAA,IAAc,MAChC,KAAKK,MAAA,GAAS,IACd,KAAKC,UAAA,GAAa,IAClB,KAAKC,UAAA,GAAa,MAClB,KAAKC,WAAA,GAAcC,MAAA,CAAOC,kBAAA,EAC1B,KAAKC,OAAA,GAAU,IACf,KAAKC,SAAA,GAAY,IACjB,KAAKC,QAAA,GAAW,MAChB,KAAKC,eAAA,GAAkB,GACvB,KAAKC,eAAA,GAAkB,GACvB,KAAKC,YAAA,GAAe,MACpB,KAAKC,iBAAA,GAAoB,MACzB,KAAKC,UAAA,GAAa,IAClB,KAAKC,OAAA,GAAU;EACnB;EAAA;AAAA;AAAA;AAAA;AAAA;EAOA,IAAIC,OAAA,EACJ;IACI,OAAO,KAAKP,QAAA,GAAW,KAAKA,QAAA,CAAS,CAAC,IAAI;EAC9C;EAEA,IAAIO,OAAOC,KAAA,EACX;IACQA,KAAA,GAEI,KAAKR,QAAA,GAEL,KAAKA,QAAA,CAAS,CAAC,IAAIQ,KAAA,GAInB,KAAKR,QAAA,GAAW,CAACQ,KAAK,IAK1B,KAAKR,QAAA,GAAW;EAExB;EAAA;EAGAS,MAAA,EACA;IACQ,KAAKjB,MAAA,KAEL,KAAKL,UAAA,GAAa,MAElB,KAAKC,IAAA,GAAOC,UAAA,CAAWC,IAAA,EAEvB,KAAKC,UAAA,GAAa,KAGtB,KAAKe,OAAA,GAAU,MACf,KAAKF,iBAAA,GAAoB;EAC7B;EAAA;AAAA;AAAA;AAAA;EAMAM,oBAAoBC,SAAA,EACpB;IACQA,SAAA,IAEA,KAAKV,eAAA,GAAkBU,SAAA,CAAUV,eAAA,EACjC,KAAKC,eAAA,GAAkBS,SAAA,CAAUT,eAAA,EACjC,KAAKC,YAAA,GAAeQ,SAAA,CAAUR,YAAA,KAI9B,KAAKF,eAAA,GAAkB,GACvB,KAAKC,eAAA,GAAkB,GACvB,KAAKC,YAAA,GAAe;EAE5B;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}