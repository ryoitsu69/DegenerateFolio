{"ast":null,"code":"import { getTypeDef } from '@polkadot/types-create';\nimport { createFunction } from './createFunction.js';\nfunction findSiPrimitive(registry, type) {\n  const prim = type.toLowerCase();\n  return registry.lookup.types.find(t => t.type.def.isPrimitive && t.type.def.asPrimitive.toString().toLowerCase() === prim || t.type.def.isHistoricMetaCompat && t.type.def.asHistoricMetaCompat.toString().toLowerCase() === prim);\n}\nfunction findSiType(registry, type) {\n  let portable = findSiPrimitive(registry, type);\n  // some types are either Sequence or Arrays, cater for these\n  // specifically (these all come from the base substrate known keys)\n  if (!portable && (type === 'Bytes' || type.startsWith('[u8;'))) {\n    const u8 = findSiPrimitive(registry, 'u8');\n    if (u8) {\n      if (type === 'Bytes') {\n        portable = registry.lookup.types.find(t => t.type.def.isSequence && t.type.def.asSequence.type.eq(u8.id) || t.type.def.isHistoricMetaCompat && t.type.def.asHistoricMetaCompat.eq(type));\n      } else {\n        const td = getTypeDef(type);\n        portable = registry.lookup.types.find(t => t.type.def.isArray && t.type.def.asArray.eq({\n          len: td.length,\n          type: u8.id\n        }) || t.type.def.isHistoricMetaCompat && t.type.def.asHistoricMetaCompat.eq(type));\n      }\n    }\n  }\n  if (!portable) {\n    // Not fatal, however if this happens the storage key using this\n    // type will not return valid values, rather it will most probably\n    // be decoded incorrectly\n    console.warn(`Unable to map ${type} to a lookup index`);\n  }\n  return portable;\n}\n/** @internal */\nexport function createRuntimeFunction({\n  method,\n  prefix,\n  section\n}, key, {\n  docs,\n  type\n}) {\n  return registry => createFunction(registry, {\n    meta: registry.createTypeUnsafe('StorageEntryMetadataLatest', [{\n      docs: registry.createTypeUnsafe('Vec<Text>', [[docs]]),\n      modifier: registry.createTypeUnsafe('StorageEntryModifierLatest', ['Required']),\n      name: registry.createTypeUnsafe('Text', [method]),\n      toJSON: () => key,\n      type: registry.createTypeUnsafe('StorageEntryTypeLatest', [{\n        Plain: findSiType(registry, type)?.id || 0\n      }])\n    }]),\n    method,\n    prefix,\n    section\n  }, {\n    key,\n    skipHashing: true\n  });\n}","map":{"version":3,"names":["getTypeDef","createFunction","findSiPrimitive","registry","type","prim","toLowerCase","lookup","types","find","t","def","isPrimitive","asPrimitive","toString","isHistoricMetaCompat","asHistoricMetaCompat","findSiType","portable","startsWith","u8","isSequence","asSequence","eq","id","td","isArray","asArray","len","length","console","warn","createRuntimeFunction","method","prefix","section","key","docs","meta","createTypeUnsafe","modifier","name","toJSON","Plain","skipHashing"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/metadata/decorate/storage/util.js"],"sourcesContent":["import { getTypeDef } from '@polkadot/types-create';\nimport { createFunction } from './createFunction.js';\nfunction findSiPrimitive(registry, type) {\n    const prim = type.toLowerCase();\n    return registry.lookup.types.find((t) => (t.type.def.isPrimitive &&\n        t.type.def.asPrimitive.toString().toLowerCase() === prim) || (t.type.def.isHistoricMetaCompat &&\n        t.type.def.asHistoricMetaCompat.toString().toLowerCase() === prim));\n}\nfunction findSiType(registry, type) {\n    let portable = findSiPrimitive(registry, type);\n    // some types are either Sequence or Arrays, cater for these\n    // specifically (these all come from the base substrate known keys)\n    if (!portable && (type === 'Bytes' || type.startsWith('[u8;'))) {\n        const u8 = findSiPrimitive(registry, 'u8');\n        if (u8) {\n            if (type === 'Bytes') {\n                portable = registry.lookup.types.find((t) => (t.type.def.isSequence &&\n                    t.type.def.asSequence.type.eq(u8.id)) || (t.type.def.isHistoricMetaCompat &&\n                    t.type.def.asHistoricMetaCompat.eq(type)));\n            }\n            else {\n                const td = getTypeDef(type);\n                portable = registry.lookup.types.find((t) => (t.type.def.isArray &&\n                    t.type.def.asArray.eq({\n                        len: td.length,\n                        type: u8.id\n                    })) || (t.type.def.isHistoricMetaCompat &&\n                    t.type.def.asHistoricMetaCompat.eq(type)));\n            }\n        }\n    }\n    if (!portable) {\n        // Not fatal, however if this happens the storage key using this\n        // type will not return valid values, rather it will most probably\n        // be decoded incorrectly\n        console.warn(`Unable to map ${type} to a lookup index`);\n    }\n    return portable;\n}\n/** @internal */\nexport function createRuntimeFunction({ method, prefix, section }, key, { docs, type }) {\n    return (registry) => createFunction(registry, {\n        meta: registry.createTypeUnsafe('StorageEntryMetadataLatest', [{\n                docs: registry.createTypeUnsafe('Vec<Text>', [[docs]]),\n                modifier: registry.createTypeUnsafe('StorageEntryModifierLatest', ['Required']),\n                name: registry.createTypeUnsafe('Text', [method]),\n                toJSON: () => key,\n                type: registry.createTypeUnsafe('StorageEntryTypeLatest', [{ Plain: findSiType(registry, type)?.id || 0 }])\n            }]),\n        method,\n        prefix,\n        section\n    }, { key, skipHashing: true });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}