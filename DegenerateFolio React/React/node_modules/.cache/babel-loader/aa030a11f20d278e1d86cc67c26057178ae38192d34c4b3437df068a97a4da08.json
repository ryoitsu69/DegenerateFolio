{"ast":null,"code":"import { U8aFixed } from '@polkadot/types-codec';\nimport { hexToU8a, isHex, isString, isU8a, u8aToU8a } from '@polkadot/util';\nimport { ethereumEncode, isEthereumAddress } from '@polkadot/util-crypto';\n/** @internal */\nfunction decodeAccountId(value) {\n  if (isU8a(value) || Array.isArray(value)) {\n    return u8aToU8a(value);\n  } else if (isHex(value) || isEthereumAddress(value.toString())) {\n    return hexToU8a(value.toString());\n  } else if (isString(value)) {\n    return u8aToU8a(value);\n  }\n  return value;\n}\n/**\n * @name GenericEthereumAccountId\n * @description\n * A wrapper around an Ethereum-compatible AccountId. Since we are dealing with\n * underlying addresses (20 bytes in length), we extend from U8aFixed which is\n * just a Uint8Array wrapper with a fixed length.\n */\nexport class GenericEthereumAccountId extends U8aFixed {\n  constructor(registry) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Uint8Array();\n    super(registry, decodeAccountId(value), 160);\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return !!other && super.eq(decodeAccountId(other));\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman() {\n    return this.toJSON();\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    return this.toString();\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive() {\n    return this.toJSON();\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return ethereumEncode(this);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'AccountId';\n  }\n}","map":{"version":3,"names":["U8aFixed","hexToU8a","isHex","isString","isU8a","u8aToU8a","ethereumEncode","isEthereumAddress","decodeAccountId","value","Array","isArray","toString","GenericEthereumAccountId","constructor","registry","arguments","length","undefined","Uint8Array","eq","other","toHuman","toJSON","toPrimitive","toRawType"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/ethereum/AccountId.js"],"sourcesContent":["import { U8aFixed } from '@polkadot/types-codec';\nimport { hexToU8a, isHex, isString, isU8a, u8aToU8a } from '@polkadot/util';\nimport { ethereumEncode, isEthereumAddress } from '@polkadot/util-crypto';\n/** @internal */\nfunction decodeAccountId(value) {\n    if (isU8a(value) || Array.isArray(value)) {\n        return u8aToU8a(value);\n    }\n    else if (isHex(value) || isEthereumAddress(value.toString())) {\n        return hexToU8a(value.toString());\n    }\n    else if (isString(value)) {\n        return u8aToU8a(value);\n    }\n    return value;\n}\n/**\n * @name GenericEthereumAccountId\n * @description\n * A wrapper around an Ethereum-compatible AccountId. Since we are dealing with\n * underlying addresses (20 bytes in length), we extend from U8aFixed which is\n * just a Uint8Array wrapper with a fixed length.\n */\nexport class GenericEthereumAccountId extends U8aFixed {\n    constructor(registry, value = new Uint8Array()) {\n        super(registry, decodeAccountId(value), 160);\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return !!other && super.eq(decodeAccountId(other));\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman() {\n        return this.toJSON();\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive() {\n        return this.toJSON();\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return ethereumEncode(this);\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'AccountId';\n    }\n}\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,uBAAuB;AAChD,SAASC,QAAQ,EAAEC,KAAK,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,QAAQ,QAAQ,gBAAgB;AAC3E,SAASC,cAAc,EAAEC,iBAAiB,QAAQ,uBAAuB;AACzE;AACA,SAASC,eAAeA,CAACC,KAAK,EAAE;EAC5B,IAAIL,KAAK,CAACK,KAAK,CAAC,IAAIC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;IACtC,OAAOJ,QAAQ,CAACI,KAAK,CAAC;EAC1B,CAAC,MACI,IAAIP,KAAK,CAACO,KAAK,CAAC,IAAIF,iBAAiB,CAACE,KAAK,CAACG,QAAQ,CAAC,CAAC,CAAC,EAAE;IAC1D,OAAOX,QAAQ,CAACQ,KAAK,CAACG,QAAQ,CAAC,CAAC,CAAC;EACrC,CAAC,MACI,IAAIT,QAAQ,CAACM,KAAK,CAAC,EAAE;IACtB,OAAOJ,QAAQ,CAACI,KAAK,CAAC;EAC1B;EACA,OAAOA,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMI,wBAAwB,SAASb,QAAQ,CAAC;EACnDc,WAAWA,CAACC,QAAQ,EAA4B;IAAA,IAA1BN,KAAK,GAAAO,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAIG,UAAU,CAAC,CAAC;IAC1C,KAAK,CAACJ,QAAQ,EAAEP,eAAe,CAACC,KAAK,CAAC,EAAE,GAAG,CAAC;EAChD;EACA;AACJ;AACA;EACIW,EAAEA,CAACC,KAAK,EAAE;IACN,OAAO,CAAC,CAACA,KAAK,IAAI,KAAK,CAACD,EAAE,CAACZ,eAAe,CAACa,KAAK,CAAC,CAAC;EACtD;EACA;AACJ;AACA;EACIC,OAAOA,CAAA,EAAG;IACN,OAAO,IAAI,CAACC,MAAM,CAAC,CAAC;EACxB;EACA;AACJ;AACA;EACIA,MAAMA,CAAA,EAAG;IACL,OAAO,IAAI,CAACX,QAAQ,CAAC,CAAC;EAC1B;EACA;AACJ;AACA;EACIY,WAAWA,CAAA,EAAG;IACV,OAAO,IAAI,CAACD,MAAM,CAAC,CAAC;EACxB;EACA;AACJ;AACA;EACIX,QAAQA,CAAA,EAAG;IACP,OAAON,cAAc,CAAC,IAAI,CAAC;EAC/B;EACA;AACJ;AACA;EACImB,SAASA,CAAA,EAAG;IACR,OAAO,WAAW;EACtB;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}