{"ast":null,"code":"import { getBufferType } from \"./getBufferType.mjs\";\nconst map = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array\n};\nfunction interleaveTypedArrays(arrays, sizes) {\n  let outSize = 0,\n    stride = 0;\n  const views = {};\n  for (let i = 0; i < arrays.length; i++) stride += sizes[i], outSize += arrays[i].length;\n  const buffer = new ArrayBuffer(outSize * 4);\n  let out = null,\n    littleOffset = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const size = sizes[i],\n      array = arrays[i],\n      type = getBufferType(array);\n    views[type] || (views[type] = new map[type](buffer)), out = views[type];\n    for (let j = 0; j < array.length; j++) {\n      const indexStart = (j / size | 0) * stride + littleOffset,\n        index = j % size;\n      out[indexStart + index] = array[j];\n    }\n    littleOffset += size;\n  }\n  return new Float32Array(buffer);\n}\nexport { interleaveTypedArrays };","map":{"version":3,"names":["map","Float32Array","Uint32Array","Int32Array","Uint8Array","interleaveTypedArrays","arrays","sizes","outSize","stride","views","i","length","buffer","ArrayBuffer","out","littleOffset","size","array","type","getBufferType","j","indexStart","index"],"sources":["/home/ryoitsu/node_modules/@pixi/utils/src/data/interleaveTypedArrays.ts"],"sourcesContent":["import { getBufferType } from './getBufferType';\n\n/* eslint-disable object-shorthand */\nconst map = { Float32Array: Float32Array, Uint32Array: Uint32Array, Int32Array: Int32Array, Uint8Array: Uint8Array };\n\ntype PackedArray = Float32Array | Uint32Array | Int32Array | Uint8Array;\n\nexport function interleaveTypedArrays(arrays: PackedArray[], sizes: number[]): Float32Array\n{\n    let outSize = 0;\n    let stride = 0;\n    const views: {[key: string]: PackedArray} = {};\n\n    for (let i = 0; i < arrays.length; i++)\n    {\n        stride += sizes[i];\n        outSize += arrays[i].length;\n    }\n\n    const buffer = new ArrayBuffer(outSize * 4);\n\n    let out = null;\n    let littleOffset = 0;\n\n    for (let i = 0; i < arrays.length; i++)\n    {\n        const size = sizes[i];\n        const array = arrays[i];\n\n        /*\n        @todo This is unsafe casting but consistent with how the code worked previously. Should it stay this way\n              or should and `getBufferTypeUnsafe` function be exposed that throws an Error if unsupported type is passed?\n         */\n        const type = getBufferType(array) as keyof typeof map;\n\n        if (!views[type])\n        {\n            views[type] = new map[type](buffer);\n        }\n\n        out = views[type];\n\n        for (let j = 0; j < array.length; j++)\n        {\n            const indexStart = ((j / size | 0) * stride) + littleOffset;\n            const index = j % size;\n\n            out[indexStart + index] = array[j];\n        }\n\n        littleOffset += size;\n    }\n\n    return new Float32Array(buffer);\n}\n"],"mappings":";AAGA,MAAMA,GAAA,GAAM;EAAEC,YAAA;EAA4BC,WAAA;EAA0BC,UAAA;EAAwBC;AAAuB;AAInG,SAAAC,sBAAsBC,MAAA,EAAuBC,KAAA,EAC7D;EACQ,IAAAC,OAAA,GAAU;IACVC,MAAA,GAAS;EACb,MAAMC,KAAA,GAAsC;EAE5C,SAASC,CAAA,GAAI,GAAGA,CAAA,GAAIL,MAAA,CAAOM,MAAA,EAAQD,CAAA,IAE/BF,MAAA,IAAUF,KAAA,CAAMI,CAAC,GACjBH,OAAA,IAAWF,MAAA,CAAOK,CAAC,EAAEC,MAAA;EAGzB,MAAMC,MAAA,GAAS,IAAIC,WAAA,CAAYN,OAAA,GAAU,CAAC;EAEtC,IAAAO,GAAA,GAAM;IACNC,YAAA,GAAe;EAEnB,SAASL,CAAA,GAAI,GAAGA,CAAA,GAAIL,MAAA,CAAOM,MAAA,EAAQD,CAAA,IACnC;IACU,MAAAM,IAAA,GAAOV,KAAA,CAAMI,CAAC;MACdO,KAAA,GAAQZ,MAAA,CAAOK,CAAC;MAMhBQ,IAAA,GAAOC,aAAA,CAAcF,KAAK;IAE3BR,KAAA,CAAMS,IAAI,MAEXT,KAAA,CAAMS,IAAI,IAAI,IAAInB,GAAA,CAAImB,IAAI,EAAEN,MAAM,IAGtCE,GAAA,GAAML,KAAA,CAAMS,IAAI;IAEhB,SAASE,CAAA,GAAI,GAAGA,CAAA,GAAIH,KAAA,CAAMN,MAAA,EAAQS,CAAA,IAClC;MACI,MAAMC,UAAA,IAAeD,CAAA,GAAIJ,IAAA,GAAO,KAAKR,MAAA,GAAUO,YAAA;QACzCO,KAAA,GAAQF,CAAA,GAAIJ,IAAA;MAElBF,GAAA,CAAIO,UAAA,GAAaC,KAAK,IAAIL,KAAA,CAAMG,CAAC;IACrC;IAEgBL,YAAA,IAAAC,IAAA;EACpB;EAEO,WAAIhB,YAAA,CAAaY,MAAM;AAClC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}