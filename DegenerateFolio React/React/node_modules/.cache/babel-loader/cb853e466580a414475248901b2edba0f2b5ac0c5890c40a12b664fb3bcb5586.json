{"ast":null,"code":"import { Enum } from '@polkadot/types-codec';\nimport { isString, isU8a, u8aToU8a } from '@polkadot/util';\n/** @internal */\nfunction decodeDataU8a(registry, value) {\n  const indicator = value[0];\n  if (!indicator) {\n    return [undefined, undefined];\n  } else if (indicator >= 1 && indicator <= 33) {\n    const length = indicator - 1;\n    const data = value.subarray(1, length + 1);\n    // in this case, we are passing a Raw back (since we have no length)\n    return [registry.createTypeUnsafe('Raw', [data]), 1];\n  } else if (indicator >= 34 && indicator <= 37) {\n    return [value.subarray(1, 32 + 1), indicator - 32]; // 34 becomes 2\n  }\n  throw new Error(`Unable to decode Data, invalid indicator byte ${indicator}`);\n}\n/** @internal */\nfunction decodeData(registry, value) {\n  if (isU8a(value) || isString(value)) {\n    return decodeDataU8a(registry, u8aToU8a(value));\n  } else if (!value) {\n    return [undefined, undefined];\n  }\n  // assume we have an Enum or an  object input, handle this via the normal Enum decoding\n  return [value, undefined];\n}\n/**\n * @name Data\n * @description\n * A [[Data]] container with node, raw or hashed data\n */\nexport class Data extends Enum {\n  constructor(registry, value) {\n    super(registry, {\n      None: 'Null',\n      // 0\n      Raw: 'Bytes',\n      // 1\n      // eslint-disable-next-line sort-keys\n      BlakeTwo256: 'H256',\n      // 2\n      Sha256: 'H256',\n      // 3\n      // eslint-disable-next-line sort-keys\n      Keccak256: 'H256',\n      // 4\n      ShaThree256: 'H256' // 5\n    }, ...decodeData(registry, value));\n    if (this.isRaw && this.asRaw.length > 32) {\n      throw new Error('Data.Raw values are limited to a maximum length of 32 bytes');\n    }\n  }\n  get asBlakeTwo256() {\n    return this.value;\n  }\n  get asKeccak256() {\n    return this.value;\n  }\n  get asRaw() {\n    return this.value;\n  }\n  get asSha256() {\n    return this.value;\n  }\n  get asShaThree256() {\n    return this.value;\n  }\n  get isBlakeTwo256() {\n    return this.index === 2;\n  }\n  get isKeccak256() {\n    return this.index === 4;\n  }\n  get isNone() {\n    return this.index === 0;\n  }\n  get isRaw() {\n    return this.index === 1;\n  }\n  get isSha256() {\n    return this.index === 3;\n  }\n  get isShaThree256() {\n    return this.index === 5;\n  }\n  /**\n   * @description The encoded length\n   */\n  get encodedLength() {\n    return this.toU8a().length;\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   */\n  toU8a() {\n    if (this.index === 0) {\n      return new Uint8Array(1);\n    } else if (this.index === 1) {\n      // don't add the length, just the data\n      const data = this.value.toU8a(true);\n      const length = Math.min(data.length, 32);\n      const u8a = new Uint8Array(length + 1);\n      u8a.set([length + 1], 0);\n      u8a.set(data.subarray(0, length), 1);\n      return u8a;\n    }\n    // otherwise we simply have a hash\n    const u8a = new Uint8Array(33);\n    u8a.set([this.index + 32], 0);\n    u8a.set(this.value.toU8a(), 1);\n    return u8a;\n  }\n}","map":{"version":3,"names":["Enum","isString","isU8a","u8aToU8a","decodeDataU8a","registry","value","indicator","undefined","length","data","subarray","createTypeUnsafe","Error","decodeData","Data","constructor","None","Raw","BlakeTwo256","Sha256","Keccak256","ShaThree256","isRaw","asRaw","asBlakeTwo256","asKeccak256","asSha256","asShaThree256","isBlakeTwo256","index","isKeccak256","isNone","isSha256","isShaThree256","encodedLength","toU8a","Uint8Array","Math","min","u8a","set"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/primitive/Data.js"],"sourcesContent":["import { Enum } from '@polkadot/types-codec';\nimport { isString, isU8a, u8aToU8a } from '@polkadot/util';\n/** @internal */\nfunction decodeDataU8a(registry, value) {\n    const indicator = value[0];\n    if (!indicator) {\n        return [undefined, undefined];\n    }\n    else if (indicator >= 1 && indicator <= 33) {\n        const length = indicator - 1;\n        const data = value.subarray(1, length + 1);\n        // in this case, we are passing a Raw back (since we have no length)\n        return [registry.createTypeUnsafe('Raw', [data]), 1];\n    }\n    else if (indicator >= 34 && indicator <= 37) {\n        return [value.subarray(1, 32 + 1), indicator - 32]; // 34 becomes 2\n    }\n    throw new Error(`Unable to decode Data, invalid indicator byte ${indicator}`);\n}\n/** @internal */\nfunction decodeData(registry, value) {\n    if (isU8a(value) || isString(value)) {\n        return decodeDataU8a(registry, u8aToU8a(value));\n    }\n    else if (!value) {\n        return [undefined, undefined];\n    }\n    // assume we have an Enum or an  object input, handle this via the normal Enum decoding\n    return [value, undefined];\n}\n/**\n * @name Data\n * @description\n * A [[Data]] container with node, raw or hashed data\n */\nexport class Data extends Enum {\n    constructor(registry, value) {\n        super(registry, {\n            None: 'Null', // 0\n            Raw: 'Bytes', // 1\n            // eslint-disable-next-line sort-keys\n            BlakeTwo256: 'H256', // 2\n            Sha256: 'H256', // 3\n            // eslint-disable-next-line sort-keys\n            Keccak256: 'H256', // 4\n            ShaThree256: 'H256' // 5\n        }, ...decodeData(registry, value));\n        if (this.isRaw && this.asRaw.length > 32) {\n            throw new Error('Data.Raw values are limited to a maximum length of 32 bytes');\n        }\n    }\n    get asBlakeTwo256() {\n        return this.value;\n    }\n    get asKeccak256() {\n        return this.value;\n    }\n    get asRaw() {\n        return this.value;\n    }\n    get asSha256() {\n        return this.value;\n    }\n    get asShaThree256() {\n        return this.value;\n    }\n    get isBlakeTwo256() {\n        return this.index === 2;\n    }\n    get isKeccak256() {\n        return this.index === 4;\n    }\n    get isNone() {\n        return this.index === 0;\n    }\n    get isRaw() {\n        return this.index === 1;\n    }\n    get isSha256() {\n        return this.index === 3;\n    }\n    get isShaThree256() {\n        return this.index === 5;\n    }\n    /**\n     * @description The encoded length\n     */\n    get encodedLength() {\n        return this.toU8a().length;\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     */\n    toU8a() {\n        if (this.index === 0) {\n            return new Uint8Array(1);\n        }\n        else if (this.index === 1) {\n            // don't add the length, just the data\n            const data = this.value.toU8a(true);\n            const length = Math.min(data.length, 32);\n            const u8a = new Uint8Array(length + 1);\n            u8a.set([length + 1], 0);\n            u8a.set(data.subarray(0, length), 1);\n            return u8a;\n        }\n        // otherwise we simply have a hash\n        const u8a = new Uint8Array(33);\n        u8a.set([this.index + 32], 0);\n        u8a.set(this.value.toU8a(), 1);\n        return u8a;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}