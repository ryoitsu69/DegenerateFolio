{"ast":null,"code":"import { warn } from '../../utils/logging/warn.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\n\"use strict\";\nclass CacheClass {\n  constructor() {\n    this._parsers = [];\n    this._cache = /* @__PURE__ */new Map();\n    this._cacheMap = /* @__PURE__ */new Map();\n  }\n  /** Clear all entries. */\n  reset() {\n    this._cacheMap.clear();\n    this._cache.clear();\n  }\n  /**\n   * Check if the key exists\n   * @param key - The key to check\n   */\n  has(key) {\n    return this._cache.has(key);\n  }\n  /**\n   * Fetch entry by key\n   * @param key - The key of the entry to get\n   */\n  get(key) {\n    const result = this._cache.get(key);\n    if (!result) {\n      warn(`[Assets] Asset id ${key} was not found in the Cache`);\n    }\n    return result;\n  }\n  /**\n   * Set a value by key or keys name\n   * @param key - The key or keys to set\n   * @param value - The value to store in the cache or from which cacheable assets will be derived.\n   */\n  set(key, value) {\n    const keys = convertToList(key);\n    let cacheableAssets;\n    for (let i = 0; i < this.parsers.length; i++) {\n      const parser = this.parsers[i];\n      if (parser.test(value)) {\n        cacheableAssets = parser.getCacheableAssets(keys, value);\n        break;\n      }\n    }\n    const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n    if (!cacheableAssets) {\n      keys.forEach(key2 => {\n        cacheableMap.set(key2, value);\n      });\n    }\n    const cacheKeys = [...cacheableMap.keys()];\n    const cachedAssets = {\n      cacheKeys,\n      keys\n    };\n    keys.forEach(key2 => {\n      this._cacheMap.set(key2, cachedAssets);\n    });\n    cacheKeys.forEach(key2 => {\n      const val = cacheableAssets ? cacheableAssets[key2] : value;\n      if (this._cache.has(key2) && this._cache.get(key2) !== val) {\n        warn(\"[Cache] already has key:\", key2);\n      }\n      this._cache.set(key2, cacheableMap.get(key2));\n    });\n  }\n  /**\n   * Remove entry by key\n   *\n   * This function will also remove any associated alias from the cache also.\n   * @param key - The key of the entry to remove\n   */\n  remove(key) {\n    if (!this._cacheMap.has(key)) {\n      warn(`[Assets] Asset id ${key} was not found in the Cache`);\n      return;\n    }\n    const cacheMap = this._cacheMap.get(key);\n    const cacheKeys = cacheMap.cacheKeys;\n    cacheKeys.forEach(key2 => {\n      this._cache.delete(key2);\n    });\n    cacheMap.keys.forEach(key2 => {\n      this._cacheMap.delete(key2);\n    });\n  }\n  /** All loader parsers registered */\n  get parsers() {\n    return this._parsers;\n  }\n}\nconst Cache = new CacheClass();\nexport { Cache };","map":{"version":3,"names":["CacheClass","constructor","_parsers","_cache","Map","_cacheMap","reset","clear","has","key","get","result","warn","set","value","keys","convertToList","cacheableAssets","i","parsers","length","parser","test","getCacheableAssets","cacheableMap","Object","entries","forEach","key2","cacheKeys","cachedAssets","val","remove","cacheMap","delete","Cache"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/assets/cache/Cache.ts"],"sourcesContent":["import { warn } from '../../utils/logging/warn';\nimport { convertToList } from '../utils/convertToList';\n\nimport type { CacheParser } from './CacheParser';\n\n/**\n * A single Cache for all assets.\n *\n * When assets are added to the cache via set they normally are added to the cache as key-value pairs.\n *\n * With this cache, you can add parsers that will take the object and convert it to a list of assets that can be cached.\n * for example a cacheSpritesheet parser will add all of the textures found within its sprite sheet directly to the cache.\n *\n * This gives devs the flexibility to cache any type of object however we want.\n *\n * It is not intended that this class is created by developers - it is part of the Asset package.\n * This is the first major system of PixiJS' main Assets class.\n * @example\n * import { Cache } from 'pixi.js';\n *\n * Cache.set('bunny', bunnyTexture);\n * @class Cache\n * @memberof assets\n */\nclass CacheClass\n{\n    private readonly _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<any, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: any): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: any): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set(key: any | any[], value: unknown): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        // convert cacheable assets to a map of key-value pairs\n        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n\n        if (!cacheableAssets)\n        {\n            keys.forEach((key) =>\n            {\n                cacheableMap.set(key, value);\n            });\n        }\n\n        const cacheKeys = [...cacheableMap.keys()];\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets as any);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            const val = cacheableAssets ? cacheableAssets[key] : value;\n\n            if (this._cache.has(key) && this._cache.get(key) !== val)\n            {\n                // #if _DEBUG\n                warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableMap.get(key));\n        });\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: any): void\n    {\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\nexport const Cache = new CacheClass();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}