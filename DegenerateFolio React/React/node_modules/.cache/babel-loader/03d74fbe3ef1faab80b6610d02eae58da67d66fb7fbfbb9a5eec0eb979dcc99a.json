{"ast":null,"code":"import { objectSpread, u8aConcat, u8aEmpty, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { blake2AsU8a, ed25519PairFromSeed as ed25519FromSeed, ed25519Sign, ethereumEncode, keccakAsU8a, keyExtractPath, keyFromPath, secp256k1Compress, secp256k1Expand, secp256k1PairFromSeed as secp256k1FromSeed, secp256k1Sign, signatureVerify, sr25519PairFromSeed as sr25519FromSeed, sr25519Sign, sr25519VrfSign, sr25519VrfVerify } from '@polkadot/util-crypto';\nimport { decodePair } from './decode.js';\nimport { encodePair } from './encode.js';\nimport { pairToJson } from './toJson.js';\nconst SIG_TYPE_NONE = new Uint8Array();\nconst TYPE_FROM_SEED = {\n  ecdsa: secp256k1FromSeed,\n  ed25519: ed25519FromSeed,\n  ethereum: secp256k1FromSeed,\n  sr25519: sr25519FromSeed\n};\nconst TYPE_PREFIX = {\n  ecdsa: new Uint8Array([2]),\n  ed25519: new Uint8Array([0]),\n  ethereum: new Uint8Array([2]),\n  sr25519: new Uint8Array([1])\n};\nconst TYPE_SIGNATURE = {\n  ecdsa: (m, p) => secp256k1Sign(m, p, 'blake2'),\n  ed25519: ed25519Sign,\n  ethereum: (m, p) => secp256k1Sign(m, p, 'keccak'),\n  sr25519: sr25519Sign\n};\nconst TYPE_ADDRESS = {\n  ecdsa: p => p.length > 32 ? blake2AsU8a(p) : p,\n  ed25519: p => p,\n  ethereum: p => p.length === 20 ? p : keccakAsU8a(secp256k1Expand(p)),\n  sr25519: p => p\n};\nfunction isLocked(secretKey) {\n  return !secretKey || u8aEmpty(secretKey);\n}\nfunction vrfHash(proof, context, extra) {\n  return blake2AsU8a(u8aConcat(context || '', extra || '', proof));\n}\n/**\n * @name createPair\n * @summary Creates a keyring pair object\n * @description Creates a keyring pair object with provided account public key, metadata, and encoded arguments.\n * The keyring pair stores the account state including the encoded address and associated metadata.\n *\n * It has properties whose values are functions that may be called to perform account actions:\n *\n * - `address` function retrieves the address associated with the account.\n * - `decodedPkcs8` function is called with the account passphrase and account encoded public key.\n * It decodes the encoded public key using the passphrase provided to obtain the decoded account public key\n * and associated secret key that are then available in memory, and changes the account address stored in the\n * state of the pair to correspond to the address of the decoded public key.\n * - `encodePkcs8` function when provided with the correct passphrase associated with the account pair\n * and when the secret key is in memory (when the account pair is not locked) it returns an encoded\n * public key of the account.\n * - `meta` is the metadata that is stored in the state of the pair, either when it was originally\n * created or set via `setMeta`.\n * - `publicKey` returns the public key stored in memory for the pair.\n * - `sign` may be used to return a signature by signing a provided message with the secret\n * key (if it is in memory) using Nacl.\n * - `toJson` calls another `toJson` function and provides the state of the pair,\n * it generates arguments to be passed to the other `toJson` function including an encoded public key of the account\n * that it generates using the secret key from memory (if it has been made available in memory)\n * and the optionally provided passphrase argument. It passes a third boolean argument to `toJson`\n * indicating whether the public key has been encoded or not (if a passphrase argument was provided then it is encoded).\n * The `toJson` function that it calls returns a JSON object with properties including the `address`\n * and `meta` that are assigned with the values stored in the corresponding state variables of the account pair,\n * an `encoded` property that is assigned with the encoded public key in hex format, and an `encoding`\n * property that indicates whether the public key value of the `encoded` property is encoded or not.\n */\nexport function createPair({\n  toSS58,\n  type\n}, {\n  publicKey,\n  secretKey\n}, meta = {}, encoded = null, encTypes) {\n  const decodePkcs8 = (passphrase, userEncoded) => {\n    const decoded = decodePair(passphrase, userEncoded || encoded, encTypes);\n    if (decoded.secretKey.length === 64) {\n      publicKey = decoded.publicKey;\n      secretKey = decoded.secretKey;\n    } else {\n      const pair = TYPE_FROM_SEED[type](decoded.secretKey);\n      publicKey = pair.publicKey;\n      secretKey = pair.secretKey;\n    }\n  };\n  const recode = passphrase => {\n    isLocked(secretKey) && encoded && decodePkcs8(passphrase, encoded);\n    encoded = encodePair({\n      publicKey,\n      secretKey\n    }, passphrase); // re-encode, latest version\n    encTypes = undefined; // swap to defaults, latest version follows\n    return encoded;\n  };\n  const encodeAddress = () => {\n    const raw = TYPE_ADDRESS[type](publicKey);\n    return type === 'ethereum' ? ethereumEncode(raw) : toSS58(raw);\n  };\n  return {\n    get address() {\n      return encodeAddress();\n    },\n    get addressRaw() {\n      const raw = TYPE_ADDRESS[type](publicKey);\n      return type === 'ethereum' ? raw.slice(-20) : raw;\n    },\n    get isLocked() {\n      return isLocked(secretKey);\n    },\n    get meta() {\n      return meta;\n    },\n    get publicKey() {\n      return publicKey;\n    },\n    get type() {\n      return type;\n    },\n    // eslint-disable-next-line sort-keys\n    decodePkcs8,\n    derive: (suri, meta) => {\n      if (type === 'ethereum') {\n        throw new Error('Unable to derive on this keypair');\n      } else if (isLocked(secretKey)) {\n        throw new Error('Cannot derive on a locked keypair');\n      }\n      const {\n        path\n      } = keyExtractPath(suri);\n      const derived = keyFromPath({\n        publicKey,\n        secretKey\n      }, path, type);\n      return createPair({\n        toSS58,\n        type\n      }, derived, meta, null);\n    },\n    encodePkcs8: passphrase => {\n      return recode(passphrase);\n    },\n    lock: () => {\n      secretKey = new Uint8Array();\n    },\n    setMeta: additional => {\n      meta = objectSpread({}, meta, additional);\n    },\n    sign: (message, options = {}) => {\n      if (isLocked(secretKey)) {\n        throw new Error('Cannot sign with a locked key pair');\n      }\n      return u8aConcat(options.withType ? TYPE_PREFIX[type] : SIG_TYPE_NONE, TYPE_SIGNATURE[type](u8aToU8a(message), {\n        publicKey,\n        secretKey\n      }));\n    },\n    toJson: passphrase => {\n      // NOTE: For ecdsa and ethereum, the publicKey cannot be extracted from the address. For these\n      // pass the hex-encoded publicKey through to the address portion of the JSON (before decoding)\n      // unless the publicKey is already an address\n      const address = ['ecdsa', 'ethereum'].includes(type) ? publicKey.length === 20 ? u8aToHex(publicKey) : u8aToHex(secp256k1Compress(publicKey)) : encodeAddress();\n      return pairToJson(type, {\n        address,\n        meta\n      }, recode(passphrase), !!passphrase);\n    },\n    unlock: passphrase => {\n      return decodePkcs8(passphrase);\n    },\n    verify: (message, signature, signerPublic) => {\n      return signatureVerify(message, signature, TYPE_ADDRESS[type](u8aToU8a(signerPublic))).isValid;\n    },\n    vrfSign: (message, context, extra) => {\n      if (isLocked(secretKey)) {\n        throw new Error('Cannot sign with a locked key pair');\n      }\n      if (type === 'sr25519') {\n        return sr25519VrfSign(message, {\n          secretKey\n        }, context, extra);\n      }\n      const proof = TYPE_SIGNATURE[type](u8aToU8a(message), {\n        publicKey,\n        secretKey\n      });\n      return u8aConcat(vrfHash(proof, context, extra), proof);\n    },\n    vrfVerify: (message, vrfResult, signerPublic, context, extra) => {\n      if (type === 'sr25519') {\n        return sr25519VrfVerify(message, vrfResult, publicKey, context, extra);\n      }\n      const result = signatureVerify(message, u8aConcat(TYPE_PREFIX[type], vrfResult.subarray(32)), TYPE_ADDRESS[type](u8aToU8a(signerPublic)));\n      return result.isValid && u8aEq(vrfResult.subarray(0, 32), vrfHash(vrfResult.subarray(32), context, extra));\n    }\n  };\n}","map":{"version":3,"names":["objectSpread","u8aConcat","u8aEmpty","u8aEq","u8aToHex","u8aToU8a","blake2AsU8a","ed25519PairFromSeed","ed25519FromSeed","ed25519Sign","ethereumEncode","keccakAsU8a","keyExtractPath","keyFromPath","secp256k1Compress","secp256k1Expand","secp256k1PairFromSeed","secp256k1FromSeed","secp256k1Sign","signatureVerify","sr25519PairFromSeed","sr25519FromSeed","sr25519Sign","sr25519VrfSign","sr25519VrfVerify","decodePair","encodePair","pairToJson","SIG_TYPE_NONE","Uint8Array","TYPE_FROM_SEED","ecdsa","ed25519","ethereum","sr25519","TYPE_PREFIX","TYPE_SIGNATURE","m","p","TYPE_ADDRESS","length","isLocked","secretKey","vrfHash","proof","context","extra","createPair","toSS58","type","publicKey","meta","encoded","encTypes","decodePkcs8","passphrase","userEncoded","decoded","pair","recode","undefined","encodeAddress","raw","address","addressRaw","slice","derive","suri","Error","path","derived","encodePkcs8","lock","setMeta","additional","sign","message","options","withType","toJson","includes","unlock","verify","signature","signerPublic","isValid","vrfSign","vrfVerify","vrfResult","result","subarray"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/keyring/pair/index.js"],"sourcesContent":["import { objectSpread, u8aConcat, u8aEmpty, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { blake2AsU8a, ed25519PairFromSeed as ed25519FromSeed, ed25519Sign, ethereumEncode, keccakAsU8a, keyExtractPath, keyFromPath, secp256k1Compress, secp256k1Expand, secp256k1PairFromSeed as secp256k1FromSeed, secp256k1Sign, signatureVerify, sr25519PairFromSeed as sr25519FromSeed, sr25519Sign, sr25519VrfSign, sr25519VrfVerify } from '@polkadot/util-crypto';\nimport { decodePair } from './decode.js';\nimport { encodePair } from './encode.js';\nimport { pairToJson } from './toJson.js';\nconst SIG_TYPE_NONE = new Uint8Array();\nconst TYPE_FROM_SEED = {\n    ecdsa: secp256k1FromSeed,\n    ed25519: ed25519FromSeed,\n    ethereum: secp256k1FromSeed,\n    sr25519: sr25519FromSeed\n};\nconst TYPE_PREFIX = {\n    ecdsa: new Uint8Array([2]),\n    ed25519: new Uint8Array([0]),\n    ethereum: new Uint8Array([2]),\n    sr25519: new Uint8Array([1])\n};\nconst TYPE_SIGNATURE = {\n    ecdsa: (m, p) => secp256k1Sign(m, p, 'blake2'),\n    ed25519: ed25519Sign,\n    ethereum: (m, p) => secp256k1Sign(m, p, 'keccak'),\n    sr25519: sr25519Sign\n};\nconst TYPE_ADDRESS = {\n    ecdsa: (p) => p.length > 32 ? blake2AsU8a(p) : p,\n    ed25519: (p) => p,\n    ethereum: (p) => p.length === 20 ? p : keccakAsU8a(secp256k1Expand(p)),\n    sr25519: (p) => p\n};\nfunction isLocked(secretKey) {\n    return !secretKey || u8aEmpty(secretKey);\n}\nfunction vrfHash(proof, context, extra) {\n    return blake2AsU8a(u8aConcat(context || '', extra || '', proof));\n}\n/**\n * @name createPair\n * @summary Creates a keyring pair object\n * @description Creates a keyring pair object with provided account public key, metadata, and encoded arguments.\n * The keyring pair stores the account state including the encoded address and associated metadata.\n *\n * It has properties whose values are functions that may be called to perform account actions:\n *\n * - `address` function retrieves the address associated with the account.\n * - `decodedPkcs8` function is called with the account passphrase and account encoded public key.\n * It decodes the encoded public key using the passphrase provided to obtain the decoded account public key\n * and associated secret key that are then available in memory, and changes the account address stored in the\n * state of the pair to correspond to the address of the decoded public key.\n * - `encodePkcs8` function when provided with the correct passphrase associated with the account pair\n * and when the secret key is in memory (when the account pair is not locked) it returns an encoded\n * public key of the account.\n * - `meta` is the metadata that is stored in the state of the pair, either when it was originally\n * created or set via `setMeta`.\n * - `publicKey` returns the public key stored in memory for the pair.\n * - `sign` may be used to return a signature by signing a provided message with the secret\n * key (if it is in memory) using Nacl.\n * - `toJson` calls another `toJson` function and provides the state of the pair,\n * it generates arguments to be passed to the other `toJson` function including an encoded public key of the account\n * that it generates using the secret key from memory (if it has been made available in memory)\n * and the optionally provided passphrase argument. It passes a third boolean argument to `toJson`\n * indicating whether the public key has been encoded or not (if a passphrase argument was provided then it is encoded).\n * The `toJson` function that it calls returns a JSON object with properties including the `address`\n * and `meta` that are assigned with the values stored in the corresponding state variables of the account pair,\n * an `encoded` property that is assigned with the encoded public key in hex format, and an `encoding`\n * property that indicates whether the public key value of the `encoded` property is encoded or not.\n */\nexport function createPair({ toSS58, type }, { publicKey, secretKey }, meta = {}, encoded = null, encTypes) {\n    const decodePkcs8 = (passphrase, userEncoded) => {\n        const decoded = decodePair(passphrase, userEncoded || encoded, encTypes);\n        if (decoded.secretKey.length === 64) {\n            publicKey = decoded.publicKey;\n            secretKey = decoded.secretKey;\n        }\n        else {\n            const pair = TYPE_FROM_SEED[type](decoded.secretKey);\n            publicKey = pair.publicKey;\n            secretKey = pair.secretKey;\n        }\n    };\n    const recode = (passphrase) => {\n        isLocked(secretKey) && encoded && decodePkcs8(passphrase, encoded);\n        encoded = encodePair({ publicKey, secretKey }, passphrase); // re-encode, latest version\n        encTypes = undefined; // swap to defaults, latest version follows\n        return encoded;\n    };\n    const encodeAddress = () => {\n        const raw = TYPE_ADDRESS[type](publicKey);\n        return type === 'ethereum'\n            ? ethereumEncode(raw)\n            : toSS58(raw);\n    };\n    return {\n        get address() {\n            return encodeAddress();\n        },\n        get addressRaw() {\n            const raw = TYPE_ADDRESS[type](publicKey);\n            return type === 'ethereum'\n                ? raw.slice(-20)\n                : raw;\n        },\n        get isLocked() {\n            return isLocked(secretKey);\n        },\n        get meta() {\n            return meta;\n        },\n        get publicKey() {\n            return publicKey;\n        },\n        get type() {\n            return type;\n        },\n        // eslint-disable-next-line sort-keys\n        decodePkcs8,\n        derive: (suri, meta) => {\n            if (type === 'ethereum') {\n                throw new Error('Unable to derive on this keypair');\n            }\n            else if (isLocked(secretKey)) {\n                throw new Error('Cannot derive on a locked keypair');\n            }\n            const { path } = keyExtractPath(suri);\n            const derived = keyFromPath({ publicKey, secretKey }, path, type);\n            return createPair({ toSS58, type }, derived, meta, null);\n        },\n        encodePkcs8: (passphrase) => {\n            return recode(passphrase);\n        },\n        lock: () => {\n            secretKey = new Uint8Array();\n        },\n        setMeta: (additional) => {\n            meta = objectSpread({}, meta, additional);\n        },\n        sign: (message, options = {}) => {\n            if (isLocked(secretKey)) {\n                throw new Error('Cannot sign with a locked key pair');\n            }\n            return u8aConcat(options.withType\n                ? TYPE_PREFIX[type]\n                : SIG_TYPE_NONE, TYPE_SIGNATURE[type](u8aToU8a(message), { publicKey, secretKey }));\n        },\n        toJson: (passphrase) => {\n            // NOTE: For ecdsa and ethereum, the publicKey cannot be extracted from the address. For these\n            // pass the hex-encoded publicKey through to the address portion of the JSON (before decoding)\n            // unless the publicKey is already an address\n            const address = ['ecdsa', 'ethereum'].includes(type)\n                ? publicKey.length === 20\n                    ? u8aToHex(publicKey)\n                    : u8aToHex(secp256k1Compress(publicKey))\n                : encodeAddress();\n            return pairToJson(type, { address, meta }, recode(passphrase), !!passphrase);\n        },\n        unlock: (passphrase) => {\n            return decodePkcs8(passphrase);\n        },\n        verify: (message, signature, signerPublic) => {\n            return signatureVerify(message, signature, TYPE_ADDRESS[type](u8aToU8a(signerPublic))).isValid;\n        },\n        vrfSign: (message, context, extra) => {\n            if (isLocked(secretKey)) {\n                throw new Error('Cannot sign with a locked key pair');\n            }\n            if (type === 'sr25519') {\n                return sr25519VrfSign(message, { secretKey }, context, extra);\n            }\n            const proof = TYPE_SIGNATURE[type](u8aToU8a(message), { publicKey, secretKey });\n            return u8aConcat(vrfHash(proof, context, extra), proof);\n        },\n        vrfVerify: (message, vrfResult, signerPublic, context, extra) => {\n            if (type === 'sr25519') {\n                return sr25519VrfVerify(message, vrfResult, publicKey, context, extra);\n            }\n            const result = signatureVerify(message, u8aConcat(TYPE_PREFIX[type], vrfResult.subarray(32)), TYPE_ADDRESS[type](u8aToU8a(signerPublic)));\n            return result.isValid && u8aEq(vrfResult.subarray(0, 32), vrfHash(vrfResult.subarray(32), context, extra));\n        }\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}