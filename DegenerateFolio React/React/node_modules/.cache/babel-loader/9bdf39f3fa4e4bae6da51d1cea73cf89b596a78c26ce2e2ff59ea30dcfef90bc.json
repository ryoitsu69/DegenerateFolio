{"ast":null,"code":"const BOUNDED = ['BTreeMap', 'BTreeSet', 'HashMap', 'Vec'];\nconst ALLOWED_BOXES = BOUNDED.concat(['Compact', 'DoNotConstruct', 'Int', 'Linkage', 'Range', 'RangeInclusive', 'Result', 'Opaque', 'Option', 'UInt', 'WrapperKeepOpaque', 'WrapperOpaque']);\nconst BOX_PRECEDING = ['<', '(', '[', '\"', ',', ' ']; // start of vec, tuple, fixed array, part of struct def or in tuple\nconst mappings = [\n// alias <T::InherentOfflineReport as InherentOfflineReport>::Inherent -> InherentOfflineReport\nalias('<T::InherentOfflineReport as InherentOfflineReport>::Inherent', 'InherentOfflineReport', false), alias('VecDeque<', 'Vec<', false),\n// <T::Balance as HasCompact>\ncleanupCompact(),\n// Change BoundedVec<Type, Size> to Vec<Type>\nremoveExtensions('Bounded', true),\n// Change WeakVec<Type> to Vec<Type>\nremoveExtensions('Weak', false),\n// Remove all the trait prefixes\nremoveTraits(),\n// remove PairOf<T> -> (T, T)\nremovePairOf(),\n// remove boxing, `Box<Proposal>` -> `Proposal`\nremoveWrap('Box<'),\n// remove generics, `MisbehaviorReport<Hash, BlockNumber>` -> `MisbehaviorReport`\nremoveGenerics(),\n// alias String -> Text (compat with jsonrpc methods)\nalias('String', 'Text'),\n// alias Vec<u8> -> Bytes\nalias('Vec<u8>', 'Bytes'), alias('&\\\\[u8\\\\]', 'Bytes'), alias(\"&'static\\\\[u8\\\\]\", 'Bytes'),\n// alias RawAddress -> Address\nalias('RawAddress', 'Address'),\n// lookups, mapped to Address/AccountId as appropriate in runtime\nalias('Lookup::Source', 'LookupSource'), alias('Lookup::Target', 'LookupTarget'),\n// HACK duplication between contracts & primitives, however contracts prefixed with exec\nalias('exec::StorageKey', 'ContractStorageKey'),\n// flattens tuples with one value, `(AccountId)` -> `AccountId`\nflattenSingleTuple(),\n// converts ::Type to Type, <T as Trait<I>>::Proposal -> Proposal\nremoveColons(),\n// remove all trailing spaces - this should always be the last\ntrim()];\nexport function trim() {\n  return value => value.trim();\n}\nexport function findClosing(value, start) {\n  let depth = 0;\n  for (let i = start, count = value.length; i < count; i++) {\n    if (value[i] === '>') {\n      if (!depth) {\n        return i;\n      }\n      depth--;\n    } else if (value[i] === '<') {\n      depth++;\n    }\n  }\n  throw new Error(`Unable to find closing matching <> on '${value}' (start ${start})`);\n}\nexport function alias(src, dest, withChecks = true) {\n  const from = new RegExp(`(^${src}|${BOX_PRECEDING.map(box => `\\\\${box}${src}`).join('|')})`, 'g');\n  const to = src => {\n    from.lastIndex = 0;\n    return withChecks && BOX_PRECEDING.includes(src[0]) ? `${src[0]}${dest}` : dest;\n  };\n  return value => value.replace(from, to);\n}\nexport function cleanupCompact() {\n  return value => {\n    if (value.includes(' as HasCompact')) {\n      for (let i = 0, count = value.length; i < count; i++) {\n        if (value[i] === '<') {\n          const end = findClosing(value, i + 1) - 14;\n          if (value.substring(end, end + 14) === ' as HasCompact') {\n            value = `Compact<${value.substring(i + 1, end)}>`;\n          }\n        }\n      }\n    }\n    return value;\n  };\n}\nexport function flattenSingleTuple() {\n  const from1 = /,\\)/g;\n  const from2 = /\\(([^,]+)\\)/;\n  return value => {\n    from1.lastIndex = 0;\n    return value\n    // tuples may have trailing commas, e.g. (u32, BlockNumber, )\n    .replace(from1, ')')\n    // change (u32) -> u32\n    .replace(from2, '$1');\n  };\n}\nfunction replaceTagWith(value, matcher, replacer) {\n  let index = -1;\n  while (true) {\n    index = value.indexOf(matcher, index + 1);\n    if (index === -1) {\n      return value;\n    }\n    const start = index + matcher.length;\n    const end = findClosing(value, start);\n    value = `${value.substring(0, index)}${replacer(value.substring(start, end))}${value.substring(end + 1)}`;\n  }\n}\nexport function removeExtensions(type, isSized) {\n  return value => {\n    for (let i = 0, count = BOUNDED.length; i < count; i++) {\n      const tag = BOUNDED[i];\n      value = replaceTagWith(value, `${type}${tag}<`, v => {\n        const parts = v.split(',').map(s => s.trim()).filter(s => s);\n        if (isSized) {\n          parts.pop();\n        }\n        return `${tag}<${parts.join(',')}>`;\n      });\n    }\n    return value;\n  };\n}\nexport function removeColons() {\n  return value => {\n    let index = 0;\n    while (index !== -1) {\n      index = value.indexOf('::');\n      if (index === 0) {\n        value = value.substring(2);\n      } else if (index !== -1) {\n        let start = index;\n        while (start !== -1 && !BOX_PRECEDING.includes(value[start])) {\n          start--;\n        }\n        value = `${value.substring(0, start + 1)}${value.substring(index + 2)}`;\n      }\n    }\n    return value;\n  };\n}\nexport function removeGenerics() {\n  return value => {\n    for (let i = 0, count = value.length; i < count; i++) {\n      if (value[i] === '<') {\n        // check against the allowed wrappers, be it Vec<..>, Option<...> ...\n        const box = ALLOWED_BOXES.find(box => {\n          const start = i - box.length;\n          return start >= 0 && value.substring(start, i) === box && (\n          // make sure it is stand-alone, i.e. don't catch ElectionResult<...> as Result<...>\n          start === 0 || BOX_PRECEDING.includes(value[start - 1]));\n        });\n        // we have not found anything, unwrap generic innards\n        if (!box) {\n          const end = findClosing(value, i + 1);\n          value = `${value.substring(0, i)}${value.substring(end + 1)}`;\n        }\n      }\n    }\n    return value;\n  };\n}\nexport function removePairOf() {\n  const replacer = v => `(${v},${v})`;\n  return value => replaceTagWith(value, 'PairOf<', replacer);\n}\nexport function removeTraits() {\n  const from1 = /\\s/g;\n  const from2 = /(T|Self)::/g;\n  const from3 = /<(T|Self)asTrait>::/g;\n  const from4 = /<Tas[a-z]+::Trait>::/g;\n  const from5 = /<LookupasStaticLookup>/g;\n  const from6 = /::Type/g;\n  return value => {\n    from1.lastIndex = 0;\n    from2.lastIndex = 0;\n    from3.lastIndex = 0;\n    from4.lastIndex = 0;\n    from5.lastIndex = 0;\n    from6.lastIndex = 0;\n    return value\n    // remove all whitespaces\n    .replace(from1, '')\n    // anything `T::<type>` to end up as `<type>`\n    .replace(from2, '')\n    // replace `<T as Trait>::` (whitespaces were removed above)\n    .replace(from3, '')\n    // replace `<T as something::Trait>::` (whitespaces were removed above)\n    .replace(from4, '')\n    // replace <Lookup as StaticLookup>\n    .replace(from5, 'Lookup')\n    // replace `<...>::Type`\n    .replace(from6, '');\n  };\n}\nexport function removeWrap(check) {\n  const replacer = v => v;\n  return value => replaceTagWith(value, check, replacer);\n}\nconst sanitizeMap = new Map();\nexport function sanitize(value) {\n  const startValue = value.toString();\n  const memoized = sanitizeMap.get(startValue);\n  if (memoized) {\n    return memoized;\n  }\n  let result = startValue;\n  for (let i = 0, count = mappings.length; i < count; i++) {\n    result = mappings[i](result);\n  }\n  sanitizeMap.set(startValue, result);\n  return result;\n}","map":{"version":3,"names":["BOUNDED","ALLOWED_BOXES","concat","BOX_PRECEDING","mappings","alias","cleanupCompact","removeExtensions","removeTraits","removePairOf","removeWrap","removeGenerics","flattenSingleTuple","removeColons","trim","value","findClosing","start","depth","i","count","length","Error","src","dest","withChecks","from","RegExp","map","box","join","to","lastIndex","includes","replace","end","substring","from1","from2","replaceTagWith","matcher","replacer","index","indexOf","type","isSized","tag","v","parts","split","s","filter","pop","find","from3","from4","from5","from6","check","sanitizeMap","Map","sanitize","startValue","toString","memoized","get","result","set"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/utils/sanitize.js"],"sourcesContent":["const BOUNDED = ['BTreeMap', 'BTreeSet', 'HashMap', 'Vec'];\nconst ALLOWED_BOXES = BOUNDED.concat(['Compact', 'DoNotConstruct', 'Int', 'Linkage', 'Range', 'RangeInclusive', 'Result', 'Opaque', 'Option', 'UInt', 'WrapperKeepOpaque', 'WrapperOpaque']);\nconst BOX_PRECEDING = ['<', '(', '[', '\"', ',', ' ']; // start of vec, tuple, fixed array, part of struct def or in tuple\nconst mappings = [\n    // alias <T::InherentOfflineReport as InherentOfflineReport>::Inherent -> InherentOfflineReport\n    alias('<T::InherentOfflineReport as InherentOfflineReport>::Inherent', 'InherentOfflineReport', false),\n    alias('VecDeque<', 'Vec<', false),\n    // <T::Balance as HasCompact>\n    cleanupCompact(),\n    // Change BoundedVec<Type, Size> to Vec<Type>\n    removeExtensions('Bounded', true),\n    // Change WeakVec<Type> to Vec<Type>\n    removeExtensions('Weak', false),\n    // Remove all the trait prefixes\n    removeTraits(),\n    // remove PairOf<T> -> (T, T)\n    removePairOf(),\n    // remove boxing, `Box<Proposal>` -> `Proposal`\n    removeWrap('Box<'),\n    // remove generics, `MisbehaviorReport<Hash, BlockNumber>` -> `MisbehaviorReport`\n    removeGenerics(),\n    // alias String -> Text (compat with jsonrpc methods)\n    alias('String', 'Text'),\n    // alias Vec<u8> -> Bytes\n    alias('Vec<u8>', 'Bytes'),\n    alias('&\\\\[u8\\\\]', 'Bytes'),\n    alias(\"&'static\\\\[u8\\\\]\", 'Bytes'),\n    // alias RawAddress -> Address\n    alias('RawAddress', 'Address'),\n    // lookups, mapped to Address/AccountId as appropriate in runtime\n    alias('Lookup::Source', 'LookupSource'),\n    alias('Lookup::Target', 'LookupTarget'),\n    // HACK duplication between contracts & primitives, however contracts prefixed with exec\n    alias('exec::StorageKey', 'ContractStorageKey'),\n    // flattens tuples with one value, `(AccountId)` -> `AccountId`\n    flattenSingleTuple(),\n    // converts ::Type to Type, <T as Trait<I>>::Proposal -> Proposal\n    removeColons(),\n    // remove all trailing spaces - this should always be the last\n    trim()\n];\nexport function trim() {\n    return (value) => value.trim();\n}\nexport function findClosing(value, start) {\n    let depth = 0;\n    for (let i = start, count = value.length; i < count; i++) {\n        if (value[i] === '>') {\n            if (!depth) {\n                return i;\n            }\n            depth--;\n        }\n        else if (value[i] === '<') {\n            depth++;\n        }\n    }\n    throw new Error(`Unable to find closing matching <> on '${value}' (start ${start})`);\n}\nexport function alias(src, dest, withChecks = true) {\n    const from = new RegExp(`(^${src}|${BOX_PRECEDING.map((box) => `\\\\${box}${src}`).join('|')})`, 'g');\n    const to = (src) => {\n        from.lastIndex = 0;\n        return withChecks && BOX_PRECEDING.includes(src[0])\n            ? `${src[0]}${dest}`\n            : dest;\n    };\n    return (value) => value.replace(from, to);\n}\nexport function cleanupCompact() {\n    return (value) => {\n        if (value.includes(' as HasCompact')) {\n            for (let i = 0, count = value.length; i < count; i++) {\n                if (value[i] === '<') {\n                    const end = findClosing(value, i + 1) - 14;\n                    if (value.substring(end, end + 14) === ' as HasCompact') {\n                        value = `Compact<${value.substring(i + 1, end)}>`;\n                    }\n                }\n            }\n        }\n        return value;\n    };\n}\nexport function flattenSingleTuple() {\n    const from1 = /,\\)/g;\n    const from2 = /\\(([^,]+)\\)/;\n    return (value) => {\n        from1.lastIndex = 0;\n        return value\n            // tuples may have trailing commas, e.g. (u32, BlockNumber, )\n            .replace(from1, ')')\n            // change (u32) -> u32\n            .replace(from2, '$1');\n    };\n}\nfunction replaceTagWith(value, matcher, replacer) {\n    let index = -1;\n    while (true) {\n        index = value.indexOf(matcher, index + 1);\n        if (index === -1) {\n            return value;\n        }\n        const start = index + matcher.length;\n        const end = findClosing(value, start);\n        value = `${value.substring(0, index)}${replacer(value.substring(start, end))}${value.substring(end + 1)}`;\n    }\n}\nexport function removeExtensions(type, isSized) {\n    return (value) => {\n        for (let i = 0, count = BOUNDED.length; i < count; i++) {\n            const tag = BOUNDED[i];\n            value = replaceTagWith(value, `${type}${tag}<`, (v) => {\n                const parts = v\n                    .split(',')\n                    .map((s) => s.trim())\n                    .filter((s) => s);\n                if (isSized) {\n                    parts.pop();\n                }\n                return `${tag}<${parts.join(',')}>`;\n            });\n        }\n        return value;\n    };\n}\nexport function removeColons() {\n    return (value) => {\n        let index = 0;\n        while (index !== -1) {\n            index = value.indexOf('::');\n            if (index === 0) {\n                value = value.substring(2);\n            }\n            else if (index !== -1) {\n                let start = index;\n                while (start !== -1 && !BOX_PRECEDING.includes(value[start])) {\n                    start--;\n                }\n                value = `${value.substring(0, start + 1)}${value.substring(index + 2)}`;\n            }\n        }\n        return value;\n    };\n}\nexport function removeGenerics() {\n    return (value) => {\n        for (let i = 0, count = value.length; i < count; i++) {\n            if (value[i] === '<') {\n                // check against the allowed wrappers, be it Vec<..>, Option<...> ...\n                const box = ALLOWED_BOXES.find((box) => {\n                    const start = i - box.length;\n                    return ((start >= 0 &&\n                        value.substring(start, i) === box) && (\n                    // make sure it is stand-alone, i.e. don't catch ElectionResult<...> as Result<...>\n                    start === 0 ||\n                        BOX_PRECEDING.includes(value[start - 1])));\n                });\n                // we have not found anything, unwrap generic innards\n                if (!box) {\n                    const end = findClosing(value, i + 1);\n                    value = `${value.substring(0, i)}${value.substring(end + 1)}`;\n                }\n            }\n        }\n        return value;\n    };\n}\nexport function removePairOf() {\n    const replacer = (v) => `(${v},${v})`;\n    return (value) => replaceTagWith(value, 'PairOf<', replacer);\n}\nexport function removeTraits() {\n    const from1 = /\\s/g;\n    const from2 = /(T|Self)::/g;\n    const from3 = /<(T|Self)asTrait>::/g;\n    const from4 = /<Tas[a-z]+::Trait>::/g;\n    const from5 = /<LookupasStaticLookup>/g;\n    const from6 = /::Type/g;\n    return (value) => {\n        from1.lastIndex = 0;\n        from2.lastIndex = 0;\n        from3.lastIndex = 0;\n        from4.lastIndex = 0;\n        from5.lastIndex = 0;\n        from6.lastIndex = 0;\n        return value\n            // remove all whitespaces\n            .replace(from1, '')\n            // anything `T::<type>` to end up as `<type>`\n            .replace(from2, '')\n            // replace `<T as Trait>::` (whitespaces were removed above)\n            .replace(from3, '')\n            // replace `<T as something::Trait>::` (whitespaces were removed above)\n            .replace(from4, '')\n            // replace <Lookup as StaticLookup>\n            .replace(from5, 'Lookup')\n            // replace `<...>::Type`\n            .replace(from6, '');\n    };\n}\nexport function removeWrap(check) {\n    const replacer = (v) => v;\n    return (value) => replaceTagWith(value, check, replacer);\n}\nconst sanitizeMap = new Map();\nexport function sanitize(value) {\n    const startValue = value.toString();\n    const memoized = sanitizeMap.get(startValue);\n    if (memoized) {\n        return memoized;\n    }\n    let result = startValue;\n    for (let i = 0, count = mappings.length; i < count; i++) {\n        result = mappings[i](result);\n    }\n    sanitizeMap.set(startValue, result);\n    return result;\n}\n"],"mappings":"AAAA,MAAMA,OAAO,GAAG,CAAC,UAAU,EAAE,UAAU,EAAE,SAAS,EAAE,KAAK,CAAC;AAC1D,MAAMC,aAAa,GAAGD,OAAO,CAACE,MAAM,CAAC,CAAC,SAAS,EAAE,gBAAgB,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,gBAAgB,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,mBAAmB,EAAE,eAAe,CAAC,CAAC;AAC5L,MAAMC,aAAa,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;AACtD,MAAMC,QAAQ,GAAG;AACb;AACAC,KAAK,CAAC,+DAA+D,EAAE,uBAAuB,EAAE,KAAK,CAAC,EACtGA,KAAK,CAAC,WAAW,EAAE,MAAM,EAAE,KAAK,CAAC;AACjC;AACAC,cAAc,CAAC,CAAC;AAChB;AACAC,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAAC;AACjC;AACAA,gBAAgB,CAAC,MAAM,EAAE,KAAK,CAAC;AAC/B;AACAC,YAAY,CAAC,CAAC;AACd;AACAC,YAAY,CAAC,CAAC;AACd;AACAC,UAAU,CAAC,MAAM,CAAC;AAClB;AACAC,cAAc,CAAC,CAAC;AAChB;AACAN,KAAK,CAAC,QAAQ,EAAE,MAAM,CAAC;AACvB;AACAA,KAAK,CAAC,SAAS,EAAE,OAAO,CAAC,EACzBA,KAAK,CAAC,WAAW,EAAE,OAAO,CAAC,EAC3BA,KAAK,CAAC,kBAAkB,EAAE,OAAO,CAAC;AAClC;AACAA,KAAK,CAAC,YAAY,EAAE,SAAS,CAAC;AAC9B;AACAA,KAAK,CAAC,gBAAgB,EAAE,cAAc,CAAC,EACvCA,KAAK,CAAC,gBAAgB,EAAE,cAAc,CAAC;AACvC;AACAA,KAAK,CAAC,kBAAkB,EAAE,oBAAoB,CAAC;AAC/C;AACAO,kBAAkB,CAAC,CAAC;AACpB;AACAC,YAAY,CAAC,CAAC;AACd;AACAC,IAAI,CAAC,CAAC,CACT;AACD,OAAO,SAASA,IAAIA,CAAA,EAAG;EACnB,OAAQC,KAAK,IAAKA,KAAK,CAACD,IAAI,CAAC,CAAC;AAClC;AACA,OAAO,SAASE,WAAWA,CAACD,KAAK,EAAEE,KAAK,EAAE;EACtC,IAAIC,KAAK,GAAG,CAAC;EACb,KAAK,IAAIC,CAAC,GAAGF,KAAK,EAAEG,KAAK,GAAGL,KAAK,CAACM,MAAM,EAAEF,CAAC,GAAGC,KAAK,EAAED,CAAC,EAAE,EAAE;IACtD,IAAIJ,KAAK,CAACI,CAAC,CAAC,KAAK,GAAG,EAAE;MAClB,IAAI,CAACD,KAAK,EAAE;QACR,OAAOC,CAAC;MACZ;MACAD,KAAK,EAAE;IACX,CAAC,MACI,IAAIH,KAAK,CAACI,CAAC,CAAC,KAAK,GAAG,EAAE;MACvBD,KAAK,EAAE;IACX;EACJ;EACA,MAAM,IAAII,KAAK,CAAE,0CAAyCP,KAAM,YAAWE,KAAM,GAAE,CAAC;AACxF;AACA,OAAO,SAASZ,KAAKA,CAACkB,GAAG,EAAEC,IAAI,EAAEC,UAAU,GAAG,IAAI,EAAE;EAChD,MAAMC,IAAI,GAAG,IAAIC,MAAM,CAAE,KAAIJ,GAAI,IAAGpB,aAAa,CAACyB,GAAG,CAAEC,GAAG,IAAM,KAAIA,GAAI,GAAEN,GAAI,EAAC,CAAC,CAACO,IAAI,CAAC,GAAG,CAAE,GAAE,EAAE,GAAG,CAAC;EACnG,MAAMC,EAAE,GAAIR,GAAG,IAAK;IAChBG,IAAI,CAACM,SAAS,GAAG,CAAC;IAClB,OAAOP,UAAU,IAAItB,aAAa,CAAC8B,QAAQ,CAACV,GAAG,CAAC,CAAC,CAAC,CAAC,GAC5C,GAAEA,GAAG,CAAC,CAAC,CAAE,GAAEC,IAAK,EAAC,GAClBA,IAAI;EACd,CAAC;EACD,OAAQT,KAAK,IAAKA,KAAK,CAACmB,OAAO,CAACR,IAAI,EAAEK,EAAE,CAAC;AAC7C;AACA,OAAO,SAASzB,cAAcA,CAAA,EAAG;EAC7B,OAAQS,KAAK,IAAK;IACd,IAAIA,KAAK,CAACkB,QAAQ,CAAC,gBAAgB,CAAC,EAAE;MAClC,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEC,KAAK,GAAGL,KAAK,CAACM,MAAM,EAAEF,CAAC,GAAGC,KAAK,EAAED,CAAC,EAAE,EAAE;QAClD,IAAIJ,KAAK,CAACI,CAAC,CAAC,KAAK,GAAG,EAAE;UAClB,MAAMgB,GAAG,GAAGnB,WAAW,CAACD,KAAK,EAAEI,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE;UAC1C,IAAIJ,KAAK,CAACqB,SAAS,CAACD,GAAG,EAAEA,GAAG,GAAG,EAAE,CAAC,KAAK,gBAAgB,EAAE;YACrDpB,KAAK,GAAI,WAAUA,KAAK,CAACqB,SAAS,CAACjB,CAAC,GAAG,CAAC,EAAEgB,GAAG,CAAE,GAAE;UACrD;QACJ;MACJ;IACJ;IACA,OAAOpB,KAAK;EAChB,CAAC;AACL;AACA,OAAO,SAASH,kBAAkBA,CAAA,EAAG;EACjC,MAAMyB,KAAK,GAAG,MAAM;EACpB,MAAMC,KAAK,GAAG,aAAa;EAC3B,OAAQvB,KAAK,IAAK;IACdsB,KAAK,CAACL,SAAS,GAAG,CAAC;IACnB,OAAOjB;IACH;IAAA,CACCmB,OAAO,CAACG,KAAK,EAAE,GAAG;IACnB;IAAA,CACCH,OAAO,CAACI,KAAK,EAAE,IAAI,CAAC;EAC7B,CAAC;AACL;AACA,SAASC,cAAcA,CAACxB,KAAK,EAAEyB,OAAO,EAAEC,QAAQ,EAAE;EAC9C,IAAIC,KAAK,GAAG,CAAC,CAAC;EACd,OAAO,IAAI,EAAE;IACTA,KAAK,GAAG3B,KAAK,CAAC4B,OAAO,CAACH,OAAO,EAAEE,KAAK,GAAG,CAAC,CAAC;IACzC,IAAIA,KAAK,KAAK,CAAC,CAAC,EAAE;MACd,OAAO3B,KAAK;IAChB;IACA,MAAME,KAAK,GAAGyB,KAAK,GAAGF,OAAO,CAACnB,MAAM;IACpC,MAAMc,GAAG,GAAGnB,WAAW,CAACD,KAAK,EAAEE,KAAK,CAAC;IACrCF,KAAK,GAAI,GAAEA,KAAK,CAACqB,SAAS,CAAC,CAAC,EAAEM,KAAK,CAAE,GAAED,QAAQ,CAAC1B,KAAK,CAACqB,SAAS,CAACnB,KAAK,EAAEkB,GAAG,CAAC,CAAE,GAAEpB,KAAK,CAACqB,SAAS,CAACD,GAAG,GAAG,CAAC,CAAE,EAAC;EAC7G;AACJ;AACA,OAAO,SAAS5B,gBAAgBA,CAACqC,IAAI,EAAEC,OAAO,EAAE;EAC5C,OAAQ9B,KAAK,IAAK;IACd,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEC,KAAK,GAAGpB,OAAO,CAACqB,MAAM,EAAEF,CAAC,GAAGC,KAAK,EAAED,CAAC,EAAE,EAAE;MACpD,MAAM2B,GAAG,GAAG9C,OAAO,CAACmB,CAAC,CAAC;MACtBJ,KAAK,GAAGwB,cAAc,CAACxB,KAAK,EAAG,GAAE6B,IAAK,GAAEE,GAAI,GAAE,EAAGC,CAAC,IAAK;QACnD,MAAMC,KAAK,GAAGD,CAAC,CACVE,KAAK,CAAC,GAAG,CAAC,CACVrB,GAAG,CAAEsB,CAAC,IAAKA,CAAC,CAACpC,IAAI,CAAC,CAAC,CAAC,CACpBqC,MAAM,CAAED,CAAC,IAAKA,CAAC,CAAC;QACrB,IAAIL,OAAO,EAAE;UACTG,KAAK,CAACI,GAAG,CAAC,CAAC;QACf;QACA,OAAQ,GAAEN,GAAI,IAAGE,KAAK,CAAClB,IAAI,CAAC,GAAG,CAAE,GAAE;MACvC,CAAC,CAAC;IACN;IACA,OAAOf,KAAK;EAChB,CAAC;AACL;AACA,OAAO,SAASF,YAAYA,CAAA,EAAG;EAC3B,OAAQE,KAAK,IAAK;IACd,IAAI2B,KAAK,GAAG,CAAC;IACb,OAAOA,KAAK,KAAK,CAAC,CAAC,EAAE;MACjBA,KAAK,GAAG3B,KAAK,CAAC4B,OAAO,CAAC,IAAI,CAAC;MAC3B,IAAID,KAAK,KAAK,CAAC,EAAE;QACb3B,KAAK,GAAGA,KAAK,CAACqB,SAAS,CAAC,CAAC,CAAC;MAC9B,CAAC,MACI,IAAIM,KAAK,KAAK,CAAC,CAAC,EAAE;QACnB,IAAIzB,KAAK,GAAGyB,KAAK;QACjB,OAAOzB,KAAK,KAAK,CAAC,CAAC,IAAI,CAACd,aAAa,CAAC8B,QAAQ,CAAClB,KAAK,CAACE,KAAK,CAAC,CAAC,EAAE;UAC1DA,KAAK,EAAE;QACX;QACAF,KAAK,GAAI,GAAEA,KAAK,CAACqB,SAAS,CAAC,CAAC,EAAEnB,KAAK,GAAG,CAAC,CAAE,GAAEF,KAAK,CAACqB,SAAS,CAACM,KAAK,GAAG,CAAC,CAAE,EAAC;MAC3E;IACJ;IACA,OAAO3B,KAAK;EAChB,CAAC;AACL;AACA,OAAO,SAASJ,cAAcA,CAAA,EAAG;EAC7B,OAAQI,KAAK,IAAK;IACd,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEC,KAAK,GAAGL,KAAK,CAACM,MAAM,EAAEF,CAAC,GAAGC,KAAK,EAAED,CAAC,EAAE,EAAE;MAClD,IAAIJ,KAAK,CAACI,CAAC,CAAC,KAAK,GAAG,EAAE;QAClB;QACA,MAAMU,GAAG,GAAG5B,aAAa,CAACoD,IAAI,CAAExB,GAAG,IAAK;UACpC,MAAMZ,KAAK,GAAGE,CAAC,GAAGU,GAAG,CAACR,MAAM;UAC5B,OAASJ,KAAK,IAAI,CAAC,IACfF,KAAK,CAACqB,SAAS,CAACnB,KAAK,EAAEE,CAAC,CAAC,KAAKU,GAAG;UACrC;UACAZ,KAAK,KAAK,CAAC,IACPd,aAAa,CAAC8B,QAAQ,CAAClB,KAAK,CAACE,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC;QACjD,CAAC,CAAC;QACF;QACA,IAAI,CAACY,GAAG,EAAE;UACN,MAAMM,GAAG,GAAGnB,WAAW,CAACD,KAAK,EAAEI,CAAC,GAAG,CAAC,CAAC;UACrCJ,KAAK,GAAI,GAAEA,KAAK,CAACqB,SAAS,CAAC,CAAC,EAAEjB,CAAC,CAAE,GAAEJ,KAAK,CAACqB,SAAS,CAACD,GAAG,GAAG,CAAC,CAAE,EAAC;QACjE;MACJ;IACJ;IACA,OAAOpB,KAAK;EAChB,CAAC;AACL;AACA,OAAO,SAASN,YAAYA,CAAA,EAAG;EAC3B,MAAMgC,QAAQ,GAAIM,CAAC,IAAM,IAAGA,CAAE,IAAGA,CAAE,GAAE;EACrC,OAAQhC,KAAK,IAAKwB,cAAc,CAACxB,KAAK,EAAE,SAAS,EAAE0B,QAAQ,CAAC;AAChE;AACA,OAAO,SAASjC,YAAYA,CAAA,EAAG;EAC3B,MAAM6B,KAAK,GAAG,KAAK;EACnB,MAAMC,KAAK,GAAG,aAAa;EAC3B,MAAMgB,KAAK,GAAG,sBAAsB;EACpC,MAAMC,KAAK,GAAG,uBAAuB;EACrC,MAAMC,KAAK,GAAG,yBAAyB;EACvC,MAAMC,KAAK,GAAG,SAAS;EACvB,OAAQ1C,KAAK,IAAK;IACdsB,KAAK,CAACL,SAAS,GAAG,CAAC;IACnBM,KAAK,CAACN,SAAS,GAAG,CAAC;IACnBsB,KAAK,CAACtB,SAAS,GAAG,CAAC;IACnBuB,KAAK,CAACvB,SAAS,GAAG,CAAC;IACnBwB,KAAK,CAACxB,SAAS,GAAG,CAAC;IACnByB,KAAK,CAACzB,SAAS,GAAG,CAAC;IACnB,OAAOjB;IACH;IAAA,CACCmB,OAAO,CAACG,KAAK,EAAE,EAAE;IAClB;IAAA,CACCH,OAAO,CAACI,KAAK,EAAE,EAAE;IAClB;IAAA,CACCJ,OAAO,CAACoB,KAAK,EAAE,EAAE;IAClB;IAAA,CACCpB,OAAO,CAACqB,KAAK,EAAE,EAAE;IAClB;IAAA,CACCrB,OAAO,CAACsB,KAAK,EAAE,QAAQ;IACxB;IAAA,CACCtB,OAAO,CAACuB,KAAK,EAAE,EAAE,CAAC;EAC3B,CAAC;AACL;AACA,OAAO,SAAS/C,UAAUA,CAACgD,KAAK,EAAE;EAC9B,MAAMjB,QAAQ,GAAIM,CAAC,IAAKA,CAAC;EACzB,OAAQhC,KAAK,IAAKwB,cAAc,CAACxB,KAAK,EAAE2C,KAAK,EAAEjB,QAAQ,CAAC;AAC5D;AACA,MAAMkB,WAAW,GAAG,IAAIC,GAAG,CAAC,CAAC;AAC7B,OAAO,SAASC,QAAQA,CAAC9C,KAAK,EAAE;EAC5B,MAAM+C,UAAU,GAAG/C,KAAK,CAACgD,QAAQ,CAAC,CAAC;EACnC,MAAMC,QAAQ,GAAGL,WAAW,CAACM,GAAG,CAACH,UAAU,CAAC;EAC5C,IAAIE,QAAQ,EAAE;IACV,OAAOA,QAAQ;EACnB;EACA,IAAIE,MAAM,GAAGJ,UAAU;EACvB,KAAK,IAAI3C,CAAC,GAAG,CAAC,EAAEC,KAAK,GAAGhB,QAAQ,CAACiB,MAAM,EAAEF,CAAC,GAAGC,KAAK,EAAED,CAAC,EAAE,EAAE;IACrD+C,MAAM,GAAG9D,QAAQ,CAACe,CAAC,CAAC,CAAC+C,MAAM,CAAC;EAChC;EACAP,WAAW,CAACQ,GAAG,CAACL,UAAU,EAAEI,MAAM,CAAC;EACnC,OAAOA,MAAM;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}