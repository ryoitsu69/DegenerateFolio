{"ast":null,"code":"\"use strict\";\n\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateNoLeadingZeroes = exports.isHexPrefixed = exports.isHexString32Bytes = exports.isHexString8Bytes = exports.isHex = exports.isHexString = exports.isHexStrict = exports.isString = void 0;\n/**\n * checks input if typeof data is valid string input\n */\nconst isString = value => typeof value === 'string';\nexports.isString = isString;\nconst isHexStrict = hex => typeof hex === 'string' && /^((-)?0x[0-9a-f]+|(0x))$/i.test(hex);\nexports.isHexStrict = isHexStrict;\n/**\n * Is the string a hex string.\n *\n * @param  value\n * @param  length\n * @returns  output the string is a hex string\n */\nfunction isHexString(value, length) {\n  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) return false;\n  if (typeof length !== 'undefined' && length > 0 && value.length !== 2 + 2 * length) return false;\n  return true;\n}\nexports.isHexString = isHexString;\nconst isHex = hex => typeof hex === 'number' || typeof hex === 'bigint' || typeof hex === 'string' && /^((-0x|0x|-)?[0-9a-f]+|(0x))$/i.test(hex);\nexports.isHex = isHex;\nconst isHexString8Bytes = function (value) {\n  let prefixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return prefixed ? (0, exports.isHexStrict)(value) && value.length === 18 : (0, exports.isHex)(value) && value.length === 16;\n};\nexports.isHexString8Bytes = isHexString8Bytes;\nconst isHexString32Bytes = function (value) {\n  let prefixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return prefixed ? (0, exports.isHexStrict)(value) && value.length === 66 : (0, exports.isHex)(value) && value.length === 64;\n};\nexports.isHexString32Bytes = isHexString32Bytes;\n/**\n * Returns a `Boolean` on whether or not the a `String` starts with '0x'\n * @param str the string input value\n * @return a boolean if it is or is not hex prefixed\n * @throws if the str input is not a string\n */\nfunction isHexPrefixed(str) {\n  if (typeof str !== 'string') {\n    throw new Error(\"[isHexPrefixed] input must be type 'string', received type \".concat(typeof str));\n  }\n  return str.startsWith('0x');\n}\nexports.isHexPrefixed = isHexPrefixed;\n/**\n * Checks provided Uint8Array for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Uint8Array values\n * @throws if any provided value is found to have leading zero bytes\n */\nconst validateNoLeadingZeroes = function (values) {\n  for (const [k, v] of Object.entries(values)) {\n    if (v !== undefined && v.length > 0 && v[0] === 0) {\n      throw new Error(\"\".concat(k, \" cannot have leading zeroes, received: \").concat(v.toString()));\n    }\n  }\n};\nexports.validateNoLeadingZeroes = validateNoLeadingZeroes;","map":{"version":3,"names":["isString","value","exports","isHexStrict","hex","test","isHexString","length","match","isHex","isHexString8Bytes","prefixed","arguments","undefined","isHexString32Bytes","isHexPrefixed","str","Error","concat","startsWith","validateNoLeadingZeroes","values","k","v","Object","entries","toString"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/web3-validator/src/validation/string.ts"],"sourcesContent":["ï»¿/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { ValidInputTypes } from '../types.js';\n\n/**\n * checks input if typeof data is valid string input\n */\nexport const isString = (value: ValidInputTypes) => typeof value === 'string';\n\nexport const isHexStrict = (hex: ValidInputTypes) =>\n\ttypeof hex === 'string' && /^((-)?0x[0-9a-f]+|(0x))$/i.test(hex);\n\n/**\n * Is the string a hex string.\n *\n * @param  value\n * @param  length\n * @returns  output the string is a hex string\n */\nexport function isHexString(value: string, length?: number): boolean {\n\tif (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) return false;\n\n\tif (typeof length !== 'undefined' && length > 0 && value.length !== 2 + 2 * length)\n\t\treturn false;\n\n\treturn true;\n}\n\nexport const isHex = (hex: ValidInputTypes): boolean =>\n\ttypeof hex === 'number' ||\n\ttypeof hex === 'bigint' ||\n\t(typeof hex === 'string' && /^((-0x|0x|-)?[0-9a-f]+|(0x))$/i.test(hex));\n\nexport const isHexString8Bytes = (value: string, prefixed = true) =>\n\tprefixed ? isHexStrict(value) && value.length === 18 : isHex(value) && value.length === 16;\n\nexport const isHexString32Bytes = (value: string, prefixed = true) =>\n\tprefixed ? isHexStrict(value) && value.length === 66 : isHex(value) && value.length === 64;\n\n/**\n * Returns a `Boolean` on whether or not the a `String` starts with '0x'\n * @param str the string input value\n * @return a boolean if it is or is not hex prefixed\n * @throws if the str input is not a string\n */\nexport function isHexPrefixed(str: string): boolean {\n\tif (typeof str !== 'string') {\n\t\tthrow new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);\n\t}\n\n\treturn str.startsWith('0x');\n}\n\n/**\n * Checks provided Uint8Array for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Uint8Array values\n * @throws if any provided value is found to have leading zero bytes\n */\nexport const validateNoLeadingZeroes = function (values: {\n\t[key: string]: Uint8Array | undefined;\n}) {\n\tfor (const [k, v] of Object.entries(values)) {\n\t\tif (v !== undefined && v.length > 0 && v[0] === 0) {\n\t\t\tthrow new Error(`${k} cannot have leading zeroes, received: ${v.toString()}`);\n\t\t}\n\t}\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}