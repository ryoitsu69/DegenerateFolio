{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines the {@linkplain Driver WebDriver} client for Firefox.\n * Before using this module, you must download the latest\n * [geckodriver release] and ensure it can be found on your system [PATH].\n *\n * Each FirefoxDriver instance will be created with an anonymous profile,\n * ensuring browser historys do not share session data (cookies, history, cache,\n * offline storage, etc.)\n *\n * __Customizing the Firefox Profile__\n *\n * The profile used for each WebDriver session may be configured using the\n * {@linkplain Options} class. For example, you may install an extension, like\n * Firebug:\n *\n *     const {Builder} = require('selenium-webdriver');\n *     const firefox = require('selenium-webdriver/firefox');\n *\n *     let options = new firefox.Options()\n *         .addExtensions('/path/to/firebug.xpi')\n *         .setPreference('extensions.firebug.showChromeErrors', true);\n *\n *     let driver = new Builder()\n *         .forBrowser('firefox')\n *         .setFirefoxOptions(options)\n *         .build();\n *\n * The {@linkplain Options} class may also be used to configure WebDriver based\n * on a pre-existing browser profile:\n *\n *     let profile = '/usr/local/home/bob/.mozilla/firefox/3fgog75h.testing';\n *     let options = new firefox.Options().setProfile(profile);\n *\n * The FirefoxDriver will _never_ modify a pre-existing profile; instead it will\n * create a copy for it to modify. By extension, there are certain browser\n * preferences that are required for WebDriver to function properly and they\n * will always be overwritten.\n *\n * __Using a Custom Firefox Binary__\n *\n * On Windows and MacOS, the FirefoxDriver will search for Firefox in its\n * default installation location:\n *\n * - Windows: C:\\Program Files and C:\\Program Files (x86).\n * - MacOS: /Applications/Firefox.app\n *\n * For Linux, Firefox will always be located on the PATH: `$(where firefox)`.\n *\n * You can provide a custom location for Firefox by setting the binary in the\n * {@link Options}:setBinary method.\n *\n *     const {Builder} = require('selenium-webdriver');\n *     const firefox = require('selenium-webdriver/firefox');\n *\n *    let options = new firefox.Options()\n *         .setBinary('/my/firefox/install/dir/firefox');\n *     let driver = new Builder()\n *         .forBrowser('firefox')\n *         .setFirefoxOptions(options)\n *         .build();\n *\n * __Remote Testing__\n *\n * You may customize the Firefox binary and profile when running against a\n * remote Selenium server. Your custom profile will be packaged as a zip and\n * transferred to the remote host for use. The profile will be transferred\n * _once for each new session_. The performance impact should be minimal if\n * you've only configured a few extra browser preferences. If you have a large\n * profile with several extensions, you should consider installing it on the\n * remote host and defining its path via the {@link Options} class. Custom\n * binaries are never copied to remote machines and must be referenced by\n * installation path.\n *\n *     const {Builder} = require('selenium-webdriver');\n *     const firefox = require('selenium-webdriver/firefox');\n *\n *     let options = new firefox.Options()\n *         .setProfile('/profile/path/on/remote/host')\n *         .setBinary('/install/dir/on/remote/host/firefox');\n *\n *     let driver = new Builder()\n *         .forBrowser('firefox')\n *         .usingServer('http://127.0.0.1:4444/wd/hub')\n *         .setFirefoxOptions(options)\n *         .build();\n *\n * [geckodriver release]: https://github.com/mozilla/geckodriver/releases/\n * [PATH]: http://en.wikipedia.org/wiki/PATH_%28variable%29\n */\n\n'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst Symbols = require('./lib/symbols');\nconst command = require('./lib/command');\nconst http = require('./http');\nconst io = require('./io');\nconst remote = require('./remote');\nconst webdriver = require('./lib/webdriver');\nconst zip = require('./io/zip');\nconst {\n  Browser,\n  Capabilities\n} = require('./lib/capabilities');\nconst {\n  Zip\n} = require('./io/zip');\nconst {\n  getPath\n} = require('./common/driverFinder');\nconst FIREFOX_CAPABILITY_KEY = 'moz:firefoxOptions';\n\n/**\n * Thrown when there an add-on is malformed.\n * @final\n */\nclass AddonFormatError extends Error {\n  /** @param {string} msg The error message. */\n  constructor(msg) {\n    super(msg);\n    /** @override */\n    this.name = this.constructor.name;\n  }\n}\n\n/**\n * Installs an extension to the given directory.\n * @param {string} extension Path to the xpi extension file to install.\n * @param {string} dir Path to the directory to install the extension in.\n * @return {!Promise<string>} A promise for the add-on ID once\n *     installed.\n */\nasync function installExtension(extension, dir) {\n  const ext = extension.slice(-4);\n  if (ext !== '.xpi' && ext !== '.zip') {\n    throw Error('File name does not end in \".zip\" or \".xpi\": ' + ext);\n  }\n  let archive = await zip.load(extension);\n  if (!archive.has('manifest.json')) {\n    throw new AddonFormatError(`Couldn't find manifest.json in ${extension}`);\n  }\n  let buf = await archive.getFile('manifest.json');\n  let parsedJSON = JSON.parse(buf.toString('utf8'));\n  let {\n    browser_specific_settings\n  } = /** @type {{browser_specific_settings:{gecko:{id:string}}}} */\n  parsedJSON;\n  if (browser_specific_settings && browser_specific_settings.gecko) {\n    /* browser_specific_settings is an alternative to applications\n     * It is meant to facilitate cross-browser plugins since Firefox48\n     * see https://bugzilla.mozilla.org/show_bug.cgi?id=1262005\n     */\n    parsedJSON.applications = browser_specific_settings;\n  }\n  let {\n    applications\n  } = /** @type {{applications:{gecko:{id:string}}}} */\n  parsedJSON;\n  if (!(applications && applications.gecko && applications.gecko.id)) {\n    throw new AddonFormatError(`Could not find add-on ID for ${extension}`);\n  }\n  await io.copy(extension, `${path.join(dir, applications.gecko.id)}.xpi`);\n  return applications.gecko.id;\n}\nclass Profile {\n  constructor() {\n    /** @private {?string} */\n    this.template_ = null;\n\n    /** @private {!Array<string>} */\n    this.extensions_ = [];\n  }\n  addExtensions( /** !Array<string> */paths) {\n    this.extensions_ = this.extensions_.concat(...paths);\n  }\n\n  /**\n   * @return {(!Promise<string>|undefined)} a promise for a base64 encoded\n   *     profile, or undefined if there's no data to include.\n   */\n  [Symbols.serialize]() {\n    if (this.template_ || this.extensions_.length) {\n      return buildProfile(this.template_, this.extensions_);\n    }\n    return undefined;\n  }\n}\n\n/**\n * @param {?string} template path to an existing profile to use as a template.\n * @param {!Array<string>} extensions paths to extensions to install in the new\n *     profile.\n * @return {!Promise<string>} a promise for the base64 encoded profile.\n */\nasync function buildProfile(template, extensions) {\n  let dir = template;\n  if (extensions.length) {\n    dir = await io.tmpDir();\n    if (template) {\n      await io.copyDir( /** @type {string} */template, dir, /(parent\\.lock|lock|\\.parentlock)/);\n    }\n    const extensionsDir = path.join(dir, 'extensions');\n    await io.mkdir(extensionsDir);\n    for (let i = 0; i < extensions.length; i++) {\n      await installExtension(extensions[i], extensionsDir);\n    }\n  }\n  let zip = new Zip();\n  return zip.addDir(dir).then(() => zip.toBuffer()).then(buf => buf.toString('base64'));\n}\n\n/**\n * Configuration options for the FirefoxDriver.\n */\nclass Options extends Capabilities {\n  /**\n   * @param {(Capabilities|Map<string, ?>|Object)=} other Another set of\n   *     capabilities to initialize this instance from.\n   */\n  constructor(other) {\n    super(other);\n    this.setBrowserName(Browser.FIREFOX);\n  }\n\n  /**\n   * @return {!Object}\n   * @private\n   */\n  firefoxOptions_() {\n    let options = this.get(FIREFOX_CAPABILITY_KEY);\n    if (!options) {\n      options = {};\n      this.set(FIREFOX_CAPABILITY_KEY, options);\n    }\n    return options;\n  }\n\n  /**\n   * @return {!Profile}\n   * @private\n   */\n  profile_() {\n    let options = this.firefoxOptions_();\n    if (!options.profile) {\n      options.profile = new Profile();\n    }\n    return options.profile;\n  }\n\n  /**\n   * Specify additional command line arguments that should be used when starting\n   * the Firefox browser.\n   *\n   * @param {...(string|!Array<string>)} args The arguments to include.\n   * @return {!Options} A self reference.\n   */\n  addArguments(...args) {\n    if (args.length) {\n      let options = this.firefoxOptions_();\n      options.args = options.args ? options.args.concat(...args) : args;\n    }\n    return this;\n  }\n\n  /**\n   * Sets the initial window size\n   *\n   * @param {{width: number, height: number}} size The desired window size.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} if width or height is unspecified, not a number, or\n   *     less than or equal to 0.\n   */\n  windowSize({\n    width,\n    height\n  }) {\n    function checkArg(arg) {\n      if (typeof arg !== 'number' || arg <= 0) {\n        throw TypeError('Arguments must be {width, height} with numbers > 0');\n      }\n    }\n    checkArg(width);\n    checkArg(height);\n    return this.addArguments(`--width=${width}`, `--height=${height}`);\n  }\n\n  /**\n   * Add extensions that should be installed when starting Firefox.\n   *\n   * @param {...string} paths The paths to the extension XPI files to install.\n   * @return {!Options} A self reference.\n   */\n  addExtensions(...paths) {\n    this.profile_().addExtensions(paths);\n    return this;\n  }\n\n  /**\n   * @param {string} key the preference key.\n   * @param {(string|number|boolean)} value the preference value.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} if either the key or value has an invalid type.\n   */\n  setPreference(key, value) {\n    if (typeof key !== 'string') {\n      throw TypeError(`key must be a string, but got ${typeof key}`);\n    }\n    if (typeof value !== 'string' && typeof value !== 'number' && typeof value !== 'boolean') {\n      throw TypeError(`value must be a string, number, or boolean, but got ${typeof value}`);\n    }\n    let options = this.firefoxOptions_();\n    options.prefs = options.prefs || {};\n    options.prefs[key] = value;\n    return this;\n  }\n\n  /**\n   * Sets the path to an existing profile to use as a template for new browser\n   * sessions. This profile will be copied for each new session - changes will\n   * not be applied to the profile itself.\n   *\n   * @param {string} profile The profile to use.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} if profile is not a string.\n   */\n  setProfile(profile) {\n    if (typeof profile !== 'string') {\n      throw TypeError(`profile must be a string, but got ${typeof profile}`);\n    }\n    this.profile_().template_ = profile;\n    return this;\n  }\n\n  /**\n   * Sets the binary to use. The binary may be specified as the path to a\n   * Firefox executable.\n   *\n   * @param {(string)} binary The binary to use.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} If `binary` is an invalid type.\n   */\n  setBinary(binary) {\n    if (binary instanceof Channel || typeof binary === 'string') {\n      this.firefoxOptions_().binary = binary;\n      return this;\n    }\n    throw TypeError('binary must be a string path ');\n  }\n\n  /**\n   * Enables Mobile start up features\n   *\n   * @param {string} androidPackage The package to use\n   * @return {!Options} A self reference\n   */\n  enableMobile(androidPackage = 'org.mozilla.firefox', androidActivity = null, deviceSerial = null) {\n    this.firefoxOptions_().androidPackage = androidPackage;\n    if (androidActivity) {\n      this.firefoxOptions_().androidActivity = androidActivity;\n    }\n    if (deviceSerial) {\n      this.firefoxOptions_().deviceSerial = deviceSerial;\n    }\n    return this;\n  }\n\n  /**\n   * Enables moz:debuggerAddress for firefox cdp\n   */\n  enableDebugger() {\n    return this.set('moz:debuggerAddress', true);\n  }\n\n  /**\n   * Enable bidi connection\n   * @returns {!Capabilities}\n   */\n  enableBidi() {\n    return this.set('webSocketUrl', true);\n  }\n}\n\n/**\n * Enum of available command contexts.\n *\n * Command contexts are specific to Marionette, and may be used with the\n * {@link #context=} method. Contexts allow you to direct all subsequent\n * commands to either \"content\" (default) or \"chrome\". The latter gives\n * you elevated security permissions.\n *\n * @enum {string}\n */\nconst Context = {\n  CONTENT: 'content',\n  CHROME: 'chrome'\n};\n\n/**\n * @param {string} file Path to the file to find, relative to the program files\n *     root.\n * @return {!Promise<?string>} A promise for the located executable.\n *     The promise will resolve to {@code null} if Firefox was not found.\n */\nfunction findInProgramFiles(file) {\n  let files = [process.env['PROGRAMFILES'] || 'C:\\\\Program Files', process.env['PROGRAMFILES(X86)'] || 'C:\\\\Program Files (x86)'].map(prefix => path.join(prefix, file));\n  return io.exists(files[0]).then(function (exists) {\n    return exists ? files[0] : io.exists(files[1]).then(function (exists) {\n      return exists ? files[1] : null;\n    });\n  });\n}\n\n/** @enum {string} */\nconst ExtensionCommand = {\n  GET_CONTEXT: 'getContext',\n  SET_CONTEXT: 'setContext',\n  INSTALL_ADDON: 'install addon',\n  UNINSTALL_ADDON: 'uninstall addon'\n};\n\n/**\n * Creates a command executor with support for Marionette's custom commands.\n * @param {!Promise<string>} serverUrl The server's URL.\n * @return {!command.Executor} The new command executor.\n */\nfunction createExecutor(serverUrl) {\n  let client = serverUrl.then(url => new http.HttpClient(url));\n  let executor = new http.Executor(client);\n  configureExecutor(executor);\n  return executor;\n}\n\n/**\n * Configures the given executor with Firefox-specific commands.\n * @param {!http.Executor} executor the executor to configure.\n */\nfunction configureExecutor(executor) {\n  executor.defineCommand(ExtensionCommand.GET_CONTEXT, 'GET', '/session/:sessionId/moz/context');\n  executor.defineCommand(ExtensionCommand.SET_CONTEXT, 'POST', '/session/:sessionId/moz/context');\n  executor.defineCommand(ExtensionCommand.INSTALL_ADDON, 'POST', '/session/:sessionId/moz/addon/install');\n  executor.defineCommand(ExtensionCommand.UNINSTALL_ADDON, 'POST', '/session/:sessionId/moz/addon/uninstall');\n}\n\n/**\n * Creates {@link selenium-webdriver/remote.DriverService} instances that manage\n * a [geckodriver](https://github.com/mozilla/geckodriver) server in a child\n * process.\n */\nclass ServiceBuilder extends remote.DriverService.Builder {\n  /**\n   * @param {string=} opt_exe Path to the server executable to use. If omitted,\n   *     the builder will attempt to locate the geckodriver on the system PATH.\n   */\n  constructor(opt_exe) {\n    super(opt_exe);\n    this.setLoopback(true); // Required.\n  }\n\n  /**\n   * Enables verbose logging.\n   *\n   * @param {boolean=} opt_trace Whether to enable trace-level logging. By\n   *     default, only debug logging is enabled.\n   * @return {!ServiceBuilder} A self reference.\n   */\n  enableVerboseLogging(opt_trace) {\n    return this.addArguments(opt_trace ? '-vv' : '-v');\n  }\n}\n\n/**\n * A WebDriver client for Firefox.\n */\nclass Driver extends webdriver.WebDriver {\n  /**\n   * Creates a new Firefox session.\n   *\n   * @param {(Options|Capabilities|Object)=} opt_config The\n   *    configuration options for this driver, specified as either an\n   *    {@link Options} or {@link Capabilities}, or as a raw hash object.\n   * @param {(http.Executor|remote.DriverService)=} opt_executor Either a\n   *   pre-configured command executor to use for communicating with an\n   *   externally managed remote end (which is assumed to already be running),\n   *   or the `DriverService` to use to start the geckodriver in a child\n   *   process.\n   *\n   *   If an executor is provided, care should e taken not to use reuse it with\n   *   other clients as its internal command mappings will be updated to support\n   *   Firefox-specific commands.\n   *\n   *   _This parameter may only be used with Mozilla's GeckoDriver._\n   *\n   * @throws {Error} If a custom command executor is provided and the driver is\n   *     configured to use the legacy FirefoxDriver from the Selenium project.\n   * @return {!Driver} A new driver instance.\n   */\n  static createSession(opt_config, opt_executor) {\n    let caps = opt_config instanceof Capabilities ? opt_config : new Options(opt_config);\n    let firefoxBrowserPath = null;\n    let executor;\n    let onQuit;\n    if (opt_executor instanceof http.Executor) {\n      executor = opt_executor;\n      configureExecutor(executor);\n    } else if (opt_executor instanceof remote.DriverService) {\n      if (!opt_executor.getExecutable()) {\n        const {\n          driverPath,\n          browserPath\n        } = getPath(caps);\n        opt_executor.setExecutable(driverPath);\n        firefoxBrowserPath = browserPath;\n      }\n      executor = createExecutor(opt_executor.start());\n      onQuit = () => opt_executor.kill();\n    } else {\n      let service = new ServiceBuilder().build();\n      if (!service.getExecutable()) {\n        const {\n          driverPath,\n          browserPath\n        } = getPath(caps);\n        service.setExecutable(driverPath);\n        firefoxBrowserPath = browserPath;\n      }\n      executor = createExecutor(service.start());\n      onQuit = () => service.kill();\n    }\n    if (firefoxBrowserPath) {\n      const vendorOptions = caps.get(FIREFOX_CAPABILITY_KEY);\n      if (vendorOptions) {\n        vendorOptions['binary'] = firefoxBrowserPath;\n        caps.set(FIREFOX_CAPABILITY_KEY, vendorOptions);\n      } else {\n        caps.set(FIREFOX_CAPABILITY_KEY, {\n          binary: firefoxBrowserPath\n        });\n      }\n    }\n    return /** @type {!Driver} */super.createSession(executor, caps, onQuit);\n  }\n\n  /**\n   * This function is a no-op as file detectors are not supported by this\n   * implementation.\n   * @override\n   */\n  setFileDetector() {}\n\n  /**\n   * Get the context that is currently in effect.\n   *\n   * @return {!Promise<Context>} Current context.\n   */\n  getContext() {\n    return this.execute(new command.Command(ExtensionCommand.GET_CONTEXT));\n  }\n\n  /**\n   * Changes target context for commands between chrome- and content.\n   *\n   * Changing the current context has a stateful impact on all subsequent\n   * commands. The {@link Context.CONTENT} context has normal web\n   * platform document permissions, as if you would evaluate arbitrary\n   * JavaScript. The {@link Context.CHROME} context gets elevated\n   * permissions that lets you manipulate the browser chrome itself,\n   * with full access to the XUL toolkit.\n   *\n   * Use your powers wisely.\n   *\n   * @param {!Promise<void>} ctx The context to switch to.\n   */\n  setContext(ctx) {\n    return this.execute(new command.Command(ExtensionCommand.SET_CONTEXT).setParameter('context', ctx));\n  }\n\n  /**\n   * Installs a new addon with the current session. This function will return an\n   * ID that may later be used to {@linkplain #uninstallAddon uninstall} the\n   * addon.\n   *\n   *\n   * @param {string} path Path on the local filesystem to the web extension to\n   *     install.\n   * @param {boolean} temporary Flag indicating whether the extension should be\n   *     installed temporarily - gets removed on restart\n   * @return {!Promise<string>} A promise that will resolve to an ID for the\n   *     newly installed addon.\n   * @see #uninstallAddon\n   */\n  async installAddon(path, temporary = false) {\n    let stats = fs.statSync(path);\n    let buf;\n    if (stats.isDirectory()) {\n      let zip = new Zip();\n      await zip.addDir(path);\n      buf = await zip.toBuffer('DEFLATE');\n    } else {\n      buf = await io.read(path);\n    }\n    return this.execute(new command.Command(ExtensionCommand.INSTALL_ADDON).setParameter('addon', buf.toString('base64')).setParameter('temporary', temporary));\n  }\n\n  /**\n   * Uninstalls an addon from the current browser session's profile.\n   *\n   * @param {(string|!Promise<string>)} id ID of the addon to uninstall.\n   * @return {!Promise} A promise that will resolve when the operation has\n   *     completed.\n   * @see #installAddon\n   */\n  async uninstallAddon(id) {\n    id = await Promise.resolve(id);\n    return this.execute(new command.Command(ExtensionCommand.UNINSTALL_ADDON).setParameter('id', id));\n  }\n}\n\n/**\n * Provides methods for locating the executable for a Firefox release channel\n * on Windows and MacOS. For other systems (i.e. Linux), Firefox will always\n * be located on the system PATH.\n * @deprecated Instead of using this class, you should configure the\n *    {@link Options} with the appropriate binary location or let Selenium\n *    Manager handle it for you.\n * @final\n */\nclass Channel {\n  /**\n   * @param {string} darwin The path to check when running on MacOS.\n   * @param {string} win32 The path to check when running on Windows.\n   */\n  constructor(darwin, win32) {\n    /** @private @const */this.darwin_ = darwin;\n    /** @private @const */\n    this.win32_ = win32;\n    /** @private {Promise<string>} */\n    this.found_ = null;\n  }\n\n  /**\n   * Attempts to locate the Firefox executable for this release channel. This\n   * will first check the default installation location for the channel before\n   * checking the user's PATH. The returned promise will be rejected if Firefox\n   * can not be found.\n   *\n   * @return {!Promise<string>} A promise for the location of the located\n   *     Firefox executable.\n   */\n  locate() {\n    if (this.found_) {\n      return this.found_;\n    }\n    let found;\n    switch (process.platform) {\n      case 'darwin':\n        found = io.exists(this.darwin_).then(exists => exists ? this.darwin_ : io.findInPath('firefox'));\n        break;\n      case 'win32':\n        found = findInProgramFiles(this.win32_).then(found => found || io.findInPath('firefox.exe'));\n        break;\n      default:\n        found = Promise.resolve(io.findInPath('firefox'));\n        break;\n    }\n    this.found_ = found.then(found => {\n      if (found) {\n        // TODO: verify version info.\n        return found;\n      }\n      throw Error('Could not locate Firefox on the current system');\n    });\n    return this.found_;\n  }\n\n  /** @return {!Promise<string>} */\n  [Symbols.serialize]() {\n    return this.locate();\n  }\n}\n\n/**\n * Firefox's developer channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/channel/desktop/#developer>\n */\nChannel.DEV = new Channel('/Applications/Firefox Developer Edition.app/Contents/MacOS/firefox', 'Firefox Developer Edition\\\\firefox.exe');\n\n/**\n * Firefox's beta channel. Note this is provided mainly for convenience as\n * the beta channel has the same installation location as the main release\n * channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/channel/desktop/#beta>\n */\nChannel.BETA = new Channel('/Applications/Firefox.app/Contents/MacOS/firefox', 'Mozilla Firefox\\\\firefox.exe');\n\n/**\n * Firefox's release channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/desktop/>\n */\nChannel.RELEASE = new Channel('/Applications/Firefox.app/Contents/MacOS/firefox', 'Mozilla Firefox\\\\firefox.exe');\n\n/**\n * Firefox's nightly release channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/channel/desktop/#nightly>\n */\nChannel.NIGHTLY = new Channel('/Applications/Firefox Nightly.app/Contents/MacOS/firefox', 'Nightly\\\\firefox.exe');\n\n// PUBLIC API\n\nmodule.exports = {\n  Channel,\n  Context,\n  Driver,\n  Options,\n  ServiceBuilder\n};","map":{"version":3,"names":["fs","require","path","Symbols","command","http","io","remote","webdriver","zip","Browser","Capabilities","Zip","getPath","FIREFOX_CAPABILITY_KEY","AddonFormatError","Error","constructor","msg","name","installExtension","extension","dir","ext","slice","archive","load","has","buf","getFile","parsedJSON","JSON","parse","toString","browser_specific_settings","gecko","applications","id","copy","join","Profile","template_","extensions_","addExtensions","paths","concat","serialize","length","buildProfile","undefined","template","extensions","tmpDir","copyDir","extensionsDir","mkdir","i","addDir","then","toBuffer","Options","other","setBrowserName","FIREFOX","firefoxOptions_","options","get","set","profile_","profile","addArguments","args","windowSize","width","height","checkArg","arg","TypeError","setPreference","key","value","prefs","setProfile","setBinary","binary","Channel","enableMobile","androidPackage","androidActivity","deviceSerial","enableDebugger","enableBidi","Context","CONTENT","CHROME","findInProgramFiles","file","files","process","env","map","prefix","exists","ExtensionCommand","GET_CONTEXT","SET_CONTEXT","INSTALL_ADDON","UNINSTALL_ADDON","createExecutor","serverUrl","client","url","HttpClient","executor","Executor","configureExecutor","defineCommand","ServiceBuilder","DriverService","Builder","opt_exe","setLoopback","enableVerboseLogging","opt_trace","Driver","WebDriver","createSession","opt_config","opt_executor","caps","firefoxBrowserPath","onQuit","getExecutable","driverPath","browserPath","setExecutable","start","kill","service","build","vendorOptions","setFileDetector","getContext","execute","Command","setContext","ctx","setParameter","installAddon","temporary","stats","statSync","isDirectory","read","uninstallAddon","Promise","resolve","darwin","win32","darwin_","win32_","found_","locate","found","platform","findInPath","DEV","BETA","RELEASE","NIGHTLY","module","exports"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/selenium-webdriver/firefox.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines the {@linkplain Driver WebDriver} client for Firefox.\n * Before using this module, you must download the latest\n * [geckodriver release] and ensure it can be found on your system [PATH].\n *\n * Each FirefoxDriver instance will be created with an anonymous profile,\n * ensuring browser historys do not share session data (cookies, history, cache,\n * offline storage, etc.)\n *\n * __Customizing the Firefox Profile__\n *\n * The profile used for each WebDriver session may be configured using the\n * {@linkplain Options} class. For example, you may install an extension, like\n * Firebug:\n *\n *     const {Builder} = require('selenium-webdriver');\n *     const firefox = require('selenium-webdriver/firefox');\n *\n *     let options = new firefox.Options()\n *         .addExtensions('/path/to/firebug.xpi')\n *         .setPreference('extensions.firebug.showChromeErrors', true);\n *\n *     let driver = new Builder()\n *         .forBrowser('firefox')\n *         .setFirefoxOptions(options)\n *         .build();\n *\n * The {@linkplain Options} class may also be used to configure WebDriver based\n * on a pre-existing browser profile:\n *\n *     let profile = '/usr/local/home/bob/.mozilla/firefox/3fgog75h.testing';\n *     let options = new firefox.Options().setProfile(profile);\n *\n * The FirefoxDriver will _never_ modify a pre-existing profile; instead it will\n * create a copy for it to modify. By extension, there are certain browser\n * preferences that are required for WebDriver to function properly and they\n * will always be overwritten.\n *\n * __Using a Custom Firefox Binary__\n *\n * On Windows and MacOS, the FirefoxDriver will search for Firefox in its\n * default installation location:\n *\n * - Windows: C:\\Program Files and C:\\Program Files (x86).\n * - MacOS: /Applications/Firefox.app\n *\n * For Linux, Firefox will always be located on the PATH: `$(where firefox)`.\n *\n * You can provide a custom location for Firefox by setting the binary in the\n * {@link Options}:setBinary method.\n *\n *     const {Builder} = require('selenium-webdriver');\n *     const firefox = require('selenium-webdriver/firefox');\n *\n *    let options = new firefox.Options()\n *         .setBinary('/my/firefox/install/dir/firefox');\n *     let driver = new Builder()\n *         .forBrowser('firefox')\n *         .setFirefoxOptions(options)\n *         .build();\n *\n * __Remote Testing__\n *\n * You may customize the Firefox binary and profile when running against a\n * remote Selenium server. Your custom profile will be packaged as a zip and\n * transferred to the remote host for use. The profile will be transferred\n * _once for each new session_. The performance impact should be minimal if\n * you've only configured a few extra browser preferences. If you have a large\n * profile with several extensions, you should consider installing it on the\n * remote host and defining its path via the {@link Options} class. Custom\n * binaries are never copied to remote machines and must be referenced by\n * installation path.\n *\n *     const {Builder} = require('selenium-webdriver');\n *     const firefox = require('selenium-webdriver/firefox');\n *\n *     let options = new firefox.Options()\n *         .setProfile('/profile/path/on/remote/host')\n *         .setBinary('/install/dir/on/remote/host/firefox');\n *\n *     let driver = new Builder()\n *         .forBrowser('firefox')\n *         .usingServer('http://127.0.0.1:4444/wd/hub')\n *         .setFirefoxOptions(options)\n *         .build();\n *\n * [geckodriver release]: https://github.com/mozilla/geckodriver/releases/\n * [PATH]: http://en.wikipedia.org/wiki/PATH_%28variable%29\n */\n\n'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\nconst Symbols = require('./lib/symbols')\nconst command = require('./lib/command')\nconst http = require('./http')\nconst io = require('./io')\nconst remote = require('./remote')\nconst webdriver = require('./lib/webdriver')\nconst zip = require('./io/zip')\nconst { Browser, Capabilities } = require('./lib/capabilities')\nconst { Zip } = require('./io/zip')\nconst { getPath } = require('./common/driverFinder')\nconst FIREFOX_CAPABILITY_KEY = 'moz:firefoxOptions'\n\n/**\n * Thrown when there an add-on is malformed.\n * @final\n */\nclass AddonFormatError extends Error {\n  /** @param {string} msg The error message. */\n  constructor(msg) {\n    super(msg)\n    /** @override */\n    this.name = this.constructor.name\n  }\n}\n\n/**\n * Installs an extension to the given directory.\n * @param {string} extension Path to the xpi extension file to install.\n * @param {string} dir Path to the directory to install the extension in.\n * @return {!Promise<string>} A promise for the add-on ID once\n *     installed.\n */\nasync function installExtension(extension, dir) {\n  const ext = extension.slice(-4)\n  if (ext !== '.xpi' && ext !== '.zip') {\n    throw Error('File name does not end in \".zip\" or \".xpi\": ' + ext)\n  }\n\n  let archive = await zip.load(extension)\n  if (!archive.has('manifest.json')) {\n    throw new AddonFormatError(`Couldn't find manifest.json in ${extension}`)\n  }\n\n  let buf = await archive.getFile('manifest.json')\n  let parsedJSON = JSON.parse(buf.toString('utf8'))\n\n  let { browser_specific_settings } =\n    /** @type {{browser_specific_settings:{gecko:{id:string}}}} */\n    parsedJSON\n\n  if (browser_specific_settings && browser_specific_settings.gecko) {\n    /* browser_specific_settings is an alternative to applications\n     * It is meant to facilitate cross-browser plugins since Firefox48\n     * see https://bugzilla.mozilla.org/show_bug.cgi?id=1262005\n     */\n    parsedJSON.applications = browser_specific_settings\n  }\n\n  let { applications } =\n    /** @type {{applications:{gecko:{id:string}}}} */\n    parsedJSON\n  if (!(applications && applications.gecko && applications.gecko.id)) {\n    throw new AddonFormatError(`Could not find add-on ID for ${extension}`)\n  }\n\n  await io.copy(extension, `${path.join(dir, applications.gecko.id)}.xpi`)\n  return applications.gecko.id\n}\n\nclass Profile {\n  constructor() {\n    /** @private {?string} */\n    this.template_ = null\n\n    /** @private {!Array<string>} */\n    this.extensions_ = []\n  }\n\n  addExtensions(/** !Array<string> */ paths) {\n    this.extensions_ = this.extensions_.concat(...paths)\n  }\n\n  /**\n   * @return {(!Promise<string>|undefined)} a promise for a base64 encoded\n   *     profile, or undefined if there's no data to include.\n   */\n  [Symbols.serialize]() {\n    if (this.template_ || this.extensions_.length) {\n      return buildProfile(this.template_, this.extensions_)\n    }\n    return undefined\n  }\n}\n\n/**\n * @param {?string} template path to an existing profile to use as a template.\n * @param {!Array<string>} extensions paths to extensions to install in the new\n *     profile.\n * @return {!Promise<string>} a promise for the base64 encoded profile.\n */\nasync function buildProfile(template, extensions) {\n  let dir = template\n\n  if (extensions.length) {\n    dir = await io.tmpDir()\n    if (template) {\n      await io.copyDir(/** @type {string} */ (template), dir, /(parent\\.lock|lock|\\.parentlock)/)\n    }\n\n    const extensionsDir = path.join(dir, 'extensions')\n    await io.mkdir(extensionsDir)\n\n    for (let i = 0; i < extensions.length; i++) {\n      await installExtension(extensions[i], extensionsDir)\n    }\n  }\n\n  let zip = new Zip()\n  return zip\n    .addDir(dir)\n    .then(() => zip.toBuffer())\n    .then((buf) => buf.toString('base64'))\n}\n\n/**\n * Configuration options for the FirefoxDriver.\n */\nclass Options extends Capabilities {\n  /**\n   * @param {(Capabilities|Map<string, ?>|Object)=} other Another set of\n   *     capabilities to initialize this instance from.\n   */\n  constructor(other) {\n    super(other)\n    this.setBrowserName(Browser.FIREFOX)\n  }\n\n  /**\n   * @return {!Object}\n   * @private\n   */\n  firefoxOptions_() {\n    let options = this.get(FIREFOX_CAPABILITY_KEY)\n    if (!options) {\n      options = {}\n      this.set(FIREFOX_CAPABILITY_KEY, options)\n    }\n    return options\n  }\n\n  /**\n   * @return {!Profile}\n   * @private\n   */\n  profile_() {\n    let options = this.firefoxOptions_()\n    if (!options.profile) {\n      options.profile = new Profile()\n    }\n    return options.profile\n  }\n\n  /**\n   * Specify additional command line arguments that should be used when starting\n   * the Firefox browser.\n   *\n   * @param {...(string|!Array<string>)} args The arguments to include.\n   * @return {!Options} A self reference.\n   */\n  addArguments(...args) {\n    if (args.length) {\n      let options = this.firefoxOptions_()\n      options.args = options.args ? options.args.concat(...args) : args\n    }\n    return this\n  }\n\n  /**\n   * Sets the initial window size\n   *\n   * @param {{width: number, height: number}} size The desired window size.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} if width or height is unspecified, not a number, or\n   *     less than or equal to 0.\n   */\n  windowSize({ width, height }) {\n    function checkArg(arg) {\n      if (typeof arg !== 'number' || arg <= 0) {\n        throw TypeError('Arguments must be {width, height} with numbers > 0')\n      }\n    }\n\n    checkArg(width)\n    checkArg(height)\n    return this.addArguments(`--width=${width}`, `--height=${height}`)\n  }\n\n  /**\n   * Add extensions that should be installed when starting Firefox.\n   *\n   * @param {...string} paths The paths to the extension XPI files to install.\n   * @return {!Options} A self reference.\n   */\n  addExtensions(...paths) {\n    this.profile_().addExtensions(paths)\n    return this\n  }\n\n  /**\n   * @param {string} key the preference key.\n   * @param {(string|number|boolean)} value the preference value.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} if either the key or value has an invalid type.\n   */\n  setPreference(key, value) {\n    if (typeof key !== 'string') {\n      throw TypeError(`key must be a string, but got ${typeof key}`)\n    }\n    if (typeof value !== 'string' && typeof value !== 'number' && typeof value !== 'boolean') {\n      throw TypeError(`value must be a string, number, or boolean, but got ${typeof value}`)\n    }\n    let options = this.firefoxOptions_()\n    options.prefs = options.prefs || {}\n    options.prefs[key] = value\n    return this\n  }\n\n  /**\n   * Sets the path to an existing profile to use as a template for new browser\n   * sessions. This profile will be copied for each new session - changes will\n   * not be applied to the profile itself.\n   *\n   * @param {string} profile The profile to use.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} if profile is not a string.\n   */\n  setProfile(profile) {\n    if (typeof profile !== 'string') {\n      throw TypeError(`profile must be a string, but got ${typeof profile}`)\n    }\n    this.profile_().template_ = profile\n    return this\n  }\n\n  /**\n   * Sets the binary to use. The binary may be specified as the path to a\n   * Firefox executable.\n   *\n   * @param {(string)} binary The binary to use.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} If `binary` is an invalid type.\n   */\n  setBinary(binary) {\n    if (binary instanceof Channel || typeof binary === 'string') {\n      this.firefoxOptions_().binary = binary\n      return this\n    }\n    throw TypeError('binary must be a string path ')\n  }\n\n  /**\n   * Enables Mobile start up features\n   *\n   * @param {string} androidPackage The package to use\n   * @return {!Options} A self reference\n   */\n  enableMobile(androidPackage = 'org.mozilla.firefox', androidActivity = null, deviceSerial = null) {\n    this.firefoxOptions_().androidPackage = androidPackage\n\n    if (androidActivity) {\n      this.firefoxOptions_().androidActivity = androidActivity\n    }\n    if (deviceSerial) {\n      this.firefoxOptions_().deviceSerial = deviceSerial\n    }\n    return this\n  }\n\n  /**\n   * Enables moz:debuggerAddress for firefox cdp\n   */\n  enableDebugger() {\n    return this.set('moz:debuggerAddress', true)\n  }\n\n  /**\n   * Enable bidi connection\n   * @returns {!Capabilities}\n   */\n  enableBidi() {\n    return this.set('webSocketUrl', true)\n  }\n}\n\n/**\n * Enum of available command contexts.\n *\n * Command contexts are specific to Marionette, and may be used with the\n * {@link #context=} method. Contexts allow you to direct all subsequent\n * commands to either \"content\" (default) or \"chrome\". The latter gives\n * you elevated security permissions.\n *\n * @enum {string}\n */\nconst Context = {\n  CONTENT: 'content',\n  CHROME: 'chrome',\n}\n\n/**\n * @param {string} file Path to the file to find, relative to the program files\n *     root.\n * @return {!Promise<?string>} A promise for the located executable.\n *     The promise will resolve to {@code null} if Firefox was not found.\n */\nfunction findInProgramFiles(file) {\n  let files = [\n    process.env['PROGRAMFILES'] || 'C:\\\\Program Files',\n    process.env['PROGRAMFILES(X86)'] || 'C:\\\\Program Files (x86)',\n  ].map((prefix) => path.join(prefix, file))\n  return io.exists(files[0]).then(function (exists) {\n    return exists\n      ? files[0]\n      : io.exists(files[1]).then(function (exists) {\n          return exists ? files[1] : null\n        })\n  })\n}\n\n/** @enum {string} */\nconst ExtensionCommand = {\n  GET_CONTEXT: 'getContext',\n  SET_CONTEXT: 'setContext',\n  INSTALL_ADDON: 'install addon',\n  UNINSTALL_ADDON: 'uninstall addon',\n}\n\n/**\n * Creates a command executor with support for Marionette's custom commands.\n * @param {!Promise<string>} serverUrl The server's URL.\n * @return {!command.Executor} The new command executor.\n */\nfunction createExecutor(serverUrl) {\n  let client = serverUrl.then((url) => new http.HttpClient(url))\n  let executor = new http.Executor(client)\n  configureExecutor(executor)\n  return executor\n}\n\n/**\n * Configures the given executor with Firefox-specific commands.\n * @param {!http.Executor} executor the executor to configure.\n */\nfunction configureExecutor(executor) {\n  executor.defineCommand(ExtensionCommand.GET_CONTEXT, 'GET', '/session/:sessionId/moz/context')\n\n  executor.defineCommand(ExtensionCommand.SET_CONTEXT, 'POST', '/session/:sessionId/moz/context')\n\n  executor.defineCommand(ExtensionCommand.INSTALL_ADDON, 'POST', '/session/:sessionId/moz/addon/install')\n\n  executor.defineCommand(ExtensionCommand.UNINSTALL_ADDON, 'POST', '/session/:sessionId/moz/addon/uninstall')\n}\n\n/**\n * Creates {@link selenium-webdriver/remote.DriverService} instances that manage\n * a [geckodriver](https://github.com/mozilla/geckodriver) server in a child\n * process.\n */\nclass ServiceBuilder extends remote.DriverService.Builder {\n  /**\n   * @param {string=} opt_exe Path to the server executable to use. If omitted,\n   *     the builder will attempt to locate the geckodriver on the system PATH.\n   */\n  constructor(opt_exe) {\n    super(opt_exe)\n    this.setLoopback(true) // Required.\n  }\n\n  /**\n   * Enables verbose logging.\n   *\n   * @param {boolean=} opt_trace Whether to enable trace-level logging. By\n   *     default, only debug logging is enabled.\n   * @return {!ServiceBuilder} A self reference.\n   */\n  enableVerboseLogging(opt_trace) {\n    return this.addArguments(opt_trace ? '-vv' : '-v')\n  }\n}\n\n/**\n * A WebDriver client for Firefox.\n */\nclass Driver extends webdriver.WebDriver {\n  /**\n   * Creates a new Firefox session.\n   *\n   * @param {(Options|Capabilities|Object)=} opt_config The\n   *    configuration options for this driver, specified as either an\n   *    {@link Options} or {@link Capabilities}, or as a raw hash object.\n   * @param {(http.Executor|remote.DriverService)=} opt_executor Either a\n   *   pre-configured command executor to use for communicating with an\n   *   externally managed remote end (which is assumed to already be running),\n   *   or the `DriverService` to use to start the geckodriver in a child\n   *   process.\n   *\n   *   If an executor is provided, care should e taken not to use reuse it with\n   *   other clients as its internal command mappings will be updated to support\n   *   Firefox-specific commands.\n   *\n   *   _This parameter may only be used with Mozilla's GeckoDriver._\n   *\n   * @throws {Error} If a custom command executor is provided and the driver is\n   *     configured to use the legacy FirefoxDriver from the Selenium project.\n   * @return {!Driver} A new driver instance.\n   */\n  static createSession(opt_config, opt_executor) {\n    let caps = opt_config instanceof Capabilities ? opt_config : new Options(opt_config)\n\n    let firefoxBrowserPath = null\n\n    let executor\n    let onQuit\n\n    if (opt_executor instanceof http.Executor) {\n      executor = opt_executor\n      configureExecutor(executor)\n    } else if (opt_executor instanceof remote.DriverService) {\n      if (!opt_executor.getExecutable()) {\n        const { driverPath, browserPath } = getPath(caps)\n        opt_executor.setExecutable(driverPath)\n        firefoxBrowserPath = browserPath\n      }\n      executor = createExecutor(opt_executor.start())\n      onQuit = () => opt_executor.kill()\n    } else {\n      let service = new ServiceBuilder().build()\n      if (!service.getExecutable()) {\n        const { driverPath, browserPath } = getPath(caps)\n        service.setExecutable(driverPath)\n        firefoxBrowserPath = browserPath\n      }\n      executor = createExecutor(service.start())\n      onQuit = () => service.kill()\n    }\n\n    if (firefoxBrowserPath) {\n      const vendorOptions = caps.get(FIREFOX_CAPABILITY_KEY)\n      if (vendorOptions) {\n        vendorOptions['binary'] = firefoxBrowserPath\n        caps.set(FIREFOX_CAPABILITY_KEY, vendorOptions)\n      } else {\n        caps.set(FIREFOX_CAPABILITY_KEY, { binary: firefoxBrowserPath })\n      }\n    }\n\n    return /** @type {!Driver} */ (super.createSession(executor, caps, onQuit))\n  }\n\n  /**\n   * This function is a no-op as file detectors are not supported by this\n   * implementation.\n   * @override\n   */\n  setFileDetector() {}\n\n  /**\n   * Get the context that is currently in effect.\n   *\n   * @return {!Promise<Context>} Current context.\n   */\n  getContext() {\n    return this.execute(new command.Command(ExtensionCommand.GET_CONTEXT))\n  }\n\n  /**\n   * Changes target context for commands between chrome- and content.\n   *\n   * Changing the current context has a stateful impact on all subsequent\n   * commands. The {@link Context.CONTENT} context has normal web\n   * platform document permissions, as if you would evaluate arbitrary\n   * JavaScript. The {@link Context.CHROME} context gets elevated\n   * permissions that lets you manipulate the browser chrome itself,\n   * with full access to the XUL toolkit.\n   *\n   * Use your powers wisely.\n   *\n   * @param {!Promise<void>} ctx The context to switch to.\n   */\n  setContext(ctx) {\n    return this.execute(new command.Command(ExtensionCommand.SET_CONTEXT).setParameter('context', ctx))\n  }\n\n  /**\n   * Installs a new addon with the current session. This function will return an\n   * ID that may later be used to {@linkplain #uninstallAddon uninstall} the\n   * addon.\n   *\n   *\n   * @param {string} path Path on the local filesystem to the web extension to\n   *     install.\n   * @param {boolean} temporary Flag indicating whether the extension should be\n   *     installed temporarily - gets removed on restart\n   * @return {!Promise<string>} A promise that will resolve to an ID for the\n   *     newly installed addon.\n   * @see #uninstallAddon\n   */\n  async installAddon(path, temporary = false) {\n    let stats = fs.statSync(path)\n    let buf\n    if (stats.isDirectory()) {\n      let zip = new Zip()\n      await zip.addDir(path)\n      buf = await zip.toBuffer('DEFLATE')\n    } else {\n      buf = await io.read(path)\n    }\n    return this.execute(\n      new command.Command(ExtensionCommand.INSTALL_ADDON)\n        .setParameter('addon', buf.toString('base64'))\n        .setParameter('temporary', temporary),\n    )\n  }\n\n  /**\n   * Uninstalls an addon from the current browser session's profile.\n   *\n   * @param {(string|!Promise<string>)} id ID of the addon to uninstall.\n   * @return {!Promise} A promise that will resolve when the operation has\n   *     completed.\n   * @see #installAddon\n   */\n  async uninstallAddon(id) {\n    id = await Promise.resolve(id)\n    return this.execute(new command.Command(ExtensionCommand.UNINSTALL_ADDON).setParameter('id', id))\n  }\n}\n\n/**\n * Provides methods for locating the executable for a Firefox release channel\n * on Windows and MacOS. For other systems (i.e. Linux), Firefox will always\n * be located on the system PATH.\n * @deprecated Instead of using this class, you should configure the\n *    {@link Options} with the appropriate binary location or let Selenium\n *    Manager handle it for you.\n * @final\n */\nclass Channel {\n  /**\n   * @param {string} darwin The path to check when running on MacOS.\n   * @param {string} win32 The path to check when running on Windows.\n   */\n  constructor(darwin, win32) {\n    /** @private @const */ this.darwin_ = darwin\n    /** @private @const */ this.win32_ = win32\n    /** @private {Promise<string>} */\n    this.found_ = null\n  }\n\n  /**\n   * Attempts to locate the Firefox executable for this release channel. This\n   * will first check the default installation location for the channel before\n   * checking the user's PATH. The returned promise will be rejected if Firefox\n   * can not be found.\n   *\n   * @return {!Promise<string>} A promise for the location of the located\n   *     Firefox executable.\n   */\n  locate() {\n    if (this.found_) {\n      return this.found_\n    }\n\n    let found\n    switch (process.platform) {\n      case 'darwin':\n        found = io.exists(this.darwin_).then((exists) => (exists ? this.darwin_ : io.findInPath('firefox')))\n        break\n\n      case 'win32':\n        found = findInProgramFiles(this.win32_).then((found) => found || io.findInPath('firefox.exe'))\n        break\n\n      default:\n        found = Promise.resolve(io.findInPath('firefox'))\n        break\n    }\n\n    this.found_ = found.then((found) => {\n      if (found) {\n        // TODO: verify version info.\n        return found\n      }\n      throw Error('Could not locate Firefox on the current system')\n    })\n    return this.found_\n  }\n\n  /** @return {!Promise<string>} */\n  [Symbols.serialize]() {\n    return this.locate()\n  }\n}\n\n/**\n * Firefox's developer channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/channel/desktop/#developer>\n */\nChannel.DEV = new Channel(\n  '/Applications/Firefox Developer Edition.app/Contents/MacOS/firefox',\n  'Firefox Developer Edition\\\\firefox.exe',\n)\n\n/**\n * Firefox's beta channel. Note this is provided mainly for convenience as\n * the beta channel has the same installation location as the main release\n * channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/channel/desktop/#beta>\n */\nChannel.BETA = new Channel('/Applications/Firefox.app/Contents/MacOS/firefox', 'Mozilla Firefox\\\\firefox.exe')\n\n/**\n * Firefox's release channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/desktop/>\n */\nChannel.RELEASE = new Channel('/Applications/Firefox.app/Contents/MacOS/firefox', 'Mozilla Firefox\\\\firefox.exe')\n\n/**\n * Firefox's nightly release channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/channel/desktop/#nightly>\n */\nChannel.NIGHTLY = new Channel('/Applications/Firefox Nightly.app/Contents/MacOS/firefox', 'Nightly\\\\firefox.exe')\n\n// PUBLIC API\n\nmodule.exports = {\n  Channel,\n  Context,\n  Driver,\n  Options,\n  ServiceBuilder,\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAI,CAAC;AACxB,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAME,OAAO,GAAGF,OAAO,CAAC,eAAe,CAAC;AACxC,MAAMG,OAAO,GAAGH,OAAO,CAAC,eAAe,CAAC;AACxC,MAAMI,IAAI,GAAGJ,OAAO,CAAC,QAAQ,CAAC;AAC9B,MAAMK,EAAE,GAAGL,OAAO,CAAC,MAAM,CAAC;AAC1B,MAAMM,MAAM,GAAGN,OAAO,CAAC,UAAU,CAAC;AAClC,MAAMO,SAAS,GAAGP,OAAO,CAAC,iBAAiB,CAAC;AAC5C,MAAMQ,GAAG,GAAGR,OAAO,CAAC,UAAU,CAAC;AAC/B,MAAM;EAAES,OAAO;EAAEC;AAAa,CAAC,GAAGV,OAAO,CAAC,oBAAoB,CAAC;AAC/D,MAAM;EAAEW;AAAI,CAAC,GAAGX,OAAO,CAAC,UAAU,CAAC;AACnC,MAAM;EAAEY;AAAQ,CAAC,GAAGZ,OAAO,CAAC,uBAAuB,CAAC;AACpD,MAAMa,sBAAsB,GAAG,oBAAoB;;AAEnD;AACA;AACA;AACA;AACA,MAAMC,gBAAgB,SAASC,KAAK,CAAC;EACnC;EACAC,W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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}