{"ast":null,"code":"import { pointInTriangle } from '../../../maths/point/pointInTriangle.mjs';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { State } from '../../../rendering/renderers/shared/state/State.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { Container } from '../../container/Container.mjs';\nimport { MeshGeometry } from './MeshGeometry.mjs';\n\"use strict\";\nclass Mesh extends Container {\n  constructor(...args) {\n    let options = args[0];\n    if (options instanceof Geometry) {\n      deprecation(v8_0_0, \"Mesh: use new Mesh({ geometry, shader }) instead\");\n      options = {\n        geometry: options,\n        shader: args[1]\n      };\n      if (args[3]) {\n        deprecation(v8_0_0, \"Mesh: drawMode argument has been removed, use geometry.topology instead\");\n        options.geometry.topology = args[3];\n      }\n    }\n    const {\n      geometry,\n      shader,\n      texture,\n      roundPixels,\n      state,\n      ...rest\n    } = options;\n    super({\n      label: \"Mesh\",\n      ...rest\n    });\n    this.renderPipeId = \"mesh\";\n    this.canBundle = true;\n    this._roundPixels = 0;\n    this.allowChildren = false;\n    this.shader = shader;\n    this.texture = texture ?? shader?.texture ?? Texture.WHITE;\n    this.state = state ?? State.for2d();\n    this._geometry = geometry;\n    this._geometry.on(\"update\", this.onViewUpdate, this);\n    this.roundPixels = roundPixels ?? false;\n  }\n  /**\n   *  Whether or not to round the x/y position of the mesh.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  /** Alias for {@link scene.Mesh#shader}. */\n  get material() {\n    deprecation(v8_0_0, \"mesh.material property has been removed, use mesh.shader instead\");\n    return this._shader;\n  }\n  /**\n   * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n   * Can be shared between multiple Mesh objects.\n   */\n  set shader(value) {\n    if (this._shader === value) return;\n    this._shader = value;\n    this.onViewUpdate();\n  }\n  get shader() {\n    return this._shader;\n  }\n  /**\n   * Includes vertex positions, face indices, colors, UVs, and\n   * custom attributes within buffers, reducing the cost of passing all\n   * this data to the GPU. Can be shared between multiple Mesh objects.\n   */\n  set geometry(value) {\n    if (this._geometry === value) return;\n    this._geometry?.off(\"update\", this.onViewUpdate, this);\n    value.on(\"update\", this.onViewUpdate, this);\n    this._geometry = value;\n    this.onViewUpdate();\n  }\n  get geometry() {\n    return this._geometry;\n  }\n  /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n  set texture(value) {\n    value || (value = Texture.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value) return;\n    if (currentTexture && currentTexture.dynamic) currentTexture.off(\"update\", this.onViewUpdate, this);\n    if (value.dynamic) value.on(\"update\", this.onViewUpdate, this);\n    if (this.shader) {\n      this.shader.texture = value;\n    }\n    this._texture = value;\n    this.onViewUpdate();\n  }\n  get texture() {\n    return this._texture;\n  }\n  get batched() {\n    if (this._shader) return false;\n    if (this._geometry instanceof MeshGeometry) {\n      if (this._geometry.batchMode === \"auto\") {\n        return this._geometry.positions.length / 2 <= 100;\n      }\n      return this._geometry.batchMode === \"batch\";\n    }\n    return false;\n  }\n  /**\n   * The local bounds of the mesh.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    return this._geometry.bounds;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    bounds.addBounds(this.geometry.bounds);\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const {\n      x,\n      y\n    } = point;\n    if (!this.bounds.containsPoint(x, y)) return false;\n    const vertices = this.geometry.getBuffer(\"aPosition\").data;\n    const step = this.geometry.topology === \"triangle-strip\" ? 3 : 1;\n    if (this.geometry.getIndex()) {\n      const indices = this.geometry.getIndex().data;\n      const len = indices.length;\n      for (let i = 0; i + 2 < len; i += step) {\n        const ind0 = indices[i] * 2;\n        const ind1 = indices[i + 1] * 2;\n        const ind2 = indices[i + 2] * 2;\n        if (pointInTriangle(x, y, vertices[ind0], vertices[ind0 + 1], vertices[ind1], vertices[ind1 + 1], vertices[ind2], vertices[ind2 + 1])) {\n          return true;\n        }\n      }\n    } else {\n      const len = vertices.length / 2;\n      for (let i = 0; i + 2 < len; i += step) {\n        const ind0 = i * 2;\n        const ind1 = (i + 1) * 2;\n        const ind2 = (i + 2) * 2;\n        if (pointInTriangle(x, y, vertices[ind0], vertices[ind0 + 1], vertices[ind1], vertices[ind1 + 1], vertices[ind2], vertices[ind2 + 1])) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /** @ignore */\n  onViewUpdate() {\n    this._didChangeId += 1 << 12;\n    if (this.didViewUpdate) return;\n    this.didViewUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  destroy(options) {\n    super.destroy(options);\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._geometry?.off(\"update\", this.onViewUpdate, this);\n    this._texture = null;\n    this._geometry = null;\n    this._shader = null;\n  }\n}\nexport { Mesh };","map":{"version":3,"names":["Mesh","Container","constructor","args","options","Geometry","deprecation","v8_0_0","geometry","shader","topology","texture","roundPixels","state","rest","label","renderPipeId","canBundle","_roundPixels","allowChildren","Texture","WHITE","State","for2d","_geometry","on","onViewUpdate","value","material","_shader","off","EMPTY","currentTexture","_texture","dynamic","batched","MeshGeometry","batchMode","positions","length","bounds","addBounds","containsPoint","point","x","y","vertices","getBuffer","data","step","getIndex","indices","len","i","ind0","ind1","ind2","pointInTriangle","_didChangeId","didViewUpdate","renderGroup","parentRenderGroup","onChildViewUpdate","destroy","destroyTexture","destroyTextureSource","textureSource"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/mesh/shared/Mesh.ts"],"sourcesContent":["import { pointInTriangle } from '../../../maths/point/pointInTriangle';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Container } from '../../container/Container';\nimport { MeshGeometry } from './MeshGeometry';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { View } from '../../../rendering/renderers/shared/view/View';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContainerOptions } from '../../container/Container';\nimport type { DestroyOptions } from '../../container/destroyTypes';\n\nexport interface TextureShader extends Shader\n{\n    texture: Texture;\n}\n\n/**\n * Constructor options used for `Mesh` instances. Extends {@link scene.MeshViewOptions}\n * ```js\n * const mesh = new Mesh({\n *    texture: Texture.from('assets/image.png'),\n *    geometry: new PlaneGeometry(),\n *    shader: Shader.from(VERTEX, FRAGMENT),\n * });\n * ```\n * @see {@link scene.Mesh}\n * @see {@link scene.MeshViewOptions}\n * @memberof scene\n */\n\n/**\n * @memberof scene\n */\nexport interface MeshOptions<\n    GEOMETRY extends Geometry = MeshGeometry,\n    SHADER extends Shader = TextureShader\n> extends ContainerOptions\n{\n    /**\n     * Includes vertex positions, face indices, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh objects.\n     */\n    geometry: GEOMETRY;\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Mesh objects.\n     */\n    shader?: SHADER;\n    /** The state of WebGL required to render the mesh. */\n    state?: State;\n    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n    texture?: Texture;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n/**\n * Base mesh class.\n *\n * This class empowers you to have maximum flexibility to render any kind of WebGL/WebGPU visuals you can think of.\n * This class assumes a certain level of WebGL/WebGPU knowledge.\n * If you know a bit this should abstract enough away to make your life easier!\n *\n * Pretty much ALL WebGL/WebGPU can be broken down into the following:\n * - Geometry - The structure and data for the mesh. This can include anything from positions, uvs, normals, colors etc..\n * - Shader - This is the shader that PixiJS will render the geometry with (attributes in the shader must match the geometry)\n * - State - This is the state of WebGL required to render the mesh.\n *\n * Through a combination of the above elements you can render anything you want, 2D or 3D!\n * @memberof scene\n */\nexport class Mesh<\n    GEOMETRY extends Geometry = MeshGeometry,\n    SHADER extends Shader = TextureShader\n> extends Container implements View, Instruction\n{\n    public readonly renderPipeId = 'mesh';\n    public readonly canBundle = true;\n    public state: State;\n\n    /** @ignore */\n    public _texture: Texture;\n    /** @ignore */\n    public _geometry: GEOMETRY;\n    /** @ignore */\n    public _shader?: SHADER;\n\n    public _roundPixels: 0 | 1 = 0;\n\n    /**\n     * @param {scene.MeshOptions} options - options for the mesh instance\n     */\n    constructor(options: MeshOptions<GEOMETRY, SHADER>);\n    /** @deprecated since 8.0.0 */\n    constructor(geometry: GEOMETRY, shader: SHADER, state?: State, drawMode?: Topology);\n    constructor(...args: [MeshOptions<GEOMETRY, SHADER>] | [GEOMETRY, SHADER, State?, Topology?])\n    {\n        let options = args[0];\n\n        if (options instanceof Geometry)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'Mesh: use new Mesh({ geometry, shader }) instead');\n            // #endif\n\n            options = {\n                geometry: options,\n                shader: args[1],\n            } as MeshOptions<GEOMETRY, SHADER>;\n\n            if (args[3])\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'Mesh: drawMode argument has been removed, use geometry.topology instead');\n                // #endif\n\n                options.geometry.topology = args[3];\n            }\n        }\n\n        const { geometry, shader, texture, roundPixels, state, ...rest } = options;\n\n        super({\n            label: 'Mesh',\n            ...rest\n        });\n\n        this.allowChildren = false;\n\n        this.shader = shader;\n        this.texture = texture ?? (shader as unknown as TextureShader)?.texture ?? Texture.WHITE;\n        this.state = state ?? State.for2d();\n\n        this._geometry = geometry;\n        this._geometry.on('update', this.onViewUpdate, this);\n\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the mesh.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    /** Alias for {@link scene.Mesh#shader}. */\n    get material()\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'mesh.material property has been removed, use mesh.shader instead');\n        // #endif\n\n        return this._shader;\n    }\n\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Mesh objects.\n     */\n    set shader(value: SHADER)\n    {\n        if (this._shader === value) return;\n\n        this._shader = value;\n        this.onViewUpdate();\n    }\n\n    get shader()\n    {\n        return this._shader;\n    }\n\n    /**\n     * Includes vertex positions, face indices, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh objects.\n     */\n    set geometry(value: GEOMETRY)\n    {\n        if (this._geometry === value) return;\n\n        this._geometry?.off('update', this.onViewUpdate, this);\n        value.on('update', this.onViewUpdate, this);\n\n        this._geometry = value;\n        this.onViewUpdate();\n    }\n\n    get geometry()\n    {\n        return this._geometry;\n    }\n\n    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        if (this.shader)\n        {\n            (this.shader as unknown as TextureShader).texture = value;\n        }\n\n        this._texture = value;\n        this.onViewUpdate();\n    }\n\n    get texture()\n    {\n        return this._texture;\n    }\n\n    get batched()\n    {\n        if (this._shader) return false;\n\n        if (this._geometry instanceof MeshGeometry)\n        {\n            if (this._geometry.batchMode === 'auto')\n            {\n                return this._geometry.positions.length / 2 <= 100;\n            }\n\n            return this._geometry.batchMode === 'batch';\n        }\n\n        return false;\n    }\n\n    /**\n     * The local bounds of the mesh.\n     * @type {rendering.Bounds}\n     */\n    get bounds()\n    {\n        return this._geometry.bounds;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        bounds.addBounds(this.geometry.bounds);\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        const { x, y } = point;\n\n        if (!this.bounds.containsPoint(x, y)) return false;\n\n        const vertices = this.geometry.getBuffer('aPosition').data;\n\n        const step = this.geometry.topology === 'triangle-strip' ? 3 : 1;\n\n        if (this.geometry.getIndex())\n        {\n            const indices = this.geometry.getIndex().data;\n            const len = indices.length;\n\n            for (let i = 0; i + 2 < len; i += step)\n            {\n                const ind0 = indices[i] * 2;\n                const ind1 = indices[i + 1] * 2;\n                const ind2 = indices[i + 2] * 2;\n\n                if (pointInTriangle(\n                    x, y,\n                    vertices[ind0],\n                    vertices[ind0 + 1],\n                    vertices[ind1],\n                    vertices[ind1 + 1],\n                    vertices[ind2],\n                    vertices[ind2 + 1],\n                ))\n                {\n                    return true;\n                }\n            }\n        }\n        else\n        {\n            const len = vertices.length / 2; // Each vertex has 2 coordinates, x and y\n\n            for (let i = 0; i + 2 < len; i += step)\n            {\n                const ind0 = i * 2;\n                const ind1 = (i + 1) * 2;\n                const ind2 = (i + 2) * 2;\n\n                if (pointInTriangle(\n                    x, y,\n                    vertices[ind0],\n                    vertices[ind0 + 1],\n                    vertices[ind1],\n                    vertices[ind1 + 1],\n                    vertices[ind2],\n                    vertices[ind2 + 1],\n                ))\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /** @ignore */\n    public onViewUpdate()\n    {\n        // increment from the 12th bit!\n        this._didChangeId += 1 << 12;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public destroy(options?: DestroyOptions): void\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._geometry?.off('update', this.onViewUpdate, this);\n\n        this._texture = null;\n        this._geometry = null;\n        this._shader = null;\n    }\n}\n"],"mappings":";;;;;;;;AA6EO,MAAMA,IAAA,SAGHC,SACV;EAoBIC,YAAA,GAAeC,IACf;IACQ,IAAAC,OAAA,GAAUD,IAAA,CAAK,CAAC;IAEpB,IAAIC,OAAA,YAAmBC,QACvB;MAEIC,WAAA,CAAYC,MAAA,EAAQ,kDAAkD;MAG5DH,OAAA;QACNI,QAAU,EAAAJ,OAAA;QACVK,MAAA,EAAQN,IAAA,CAAK,CAAC;MAAA,CAClB;MAEI,IAAAA,IAAA,CAAK,CAAC,CACV;QAEIG,WAAA,CAAYC,MAAA,EAAQ,yEAAyE;QAGrFH,OAAA,CAAAI,QAAA,CAASE,QAAW,GAAAP,IAAA,CAAK,CAAC;MAAA;IACtC;IAGE;MAAEK,QAAA;MAAUC,MAAQ;MAAAE,OAAA;MAASC,WAAA;MAAaC,KAAO;MAAA,GAAGC;IAAA,CAAS,GAAAV,OAAA;IAE7D;MACFW,KAAO;MACP,GAAGD;IAAA,CACN;IAjDL,KAAgBE,YAAe;IAC/B,KAAgBC,SAAY;IAU5B,KAAOC,YAAsB;IAwCzB,KAAKC,aAAgB;IAErB,KAAKV,MAAS,GAAAA,MAAA;IACd,KAAKE,OAAU,GAAAA,OAAA,IAAYF,MAAqC,EAAAE,OAAA,IAAWS,OAAQ,CAAAC,KAAA;IAC9E,KAAAR,KAAA,GAAQA,KAAS,IAAAS,KAAA,CAAMC,KAAM;IAElC,KAAKC,SAAY,GAAAhB,QAAA;IACjB,KAAKgB,SAAU,CAAAC,EAAA,CAAG,QAAU,OAAKC,YAAA,EAAc,IAAI;IAEnD,KAAKd,WAAA,GAAcA,WAAe;EAAA;EACtC;AAAA;AAAA;AAAA;EAMA,IAAIA,WACJA,CAAA;IACW,QAAC,CAAC,IAAK,CAAAM,YAAA;EAAA;EAGlB,IAAIN,YAAYe,KAChB;IACS,KAAAT,YAAA,GAAeS,KAAA,GAAQ,CAAI;EAAA;EACpC;EAGA,IAAIC,QACJA,CAAA;IAEItB,WAAA,CAAYC,MAAA,EAAQ,kEAAkE;IAGtF,OAAO,IAAK,CAAAsB,OAAA;EAAA;EAChB;AAAA;AAAA;AAAA;EAMA,IAAIpB,OAAOkB,KACX;IACI,IAAI,KAAKE,OAAY,KAAAF,KAAA,EAAO;IAE5B,KAAKE,OAAU,GAAAF,KAAA;IACf,KAAKD,YAAa;EAAA;EAGtB,IAAIjB,MACJA,CAAA;IACI,OAAO,IAAK,CAAAoB,OAAA;EAAA;EAChB;AAAA;AAAA;AAAA;AAAA;EAOA,IAAIrB,SAASmB,KACb;IACI,IAAI,KAAKH,SAAc,KAAAG,KAAA,EAAO;IAE9B,KAAKH,SAAW,EAAAM,GAAA,CAAI,QAAU,OAAKJ,YAAA,EAAc,IAAI;IACrDC,KAAA,CAAMF,EAAG,WAAU,IAAK,CAAAC,YAAA,EAAc,IAAI;IAE1C,KAAKF,SAAY,GAAAG,KAAA;IACjB,KAAKD,YAAa;EAAA;EAGtB,IAAIlB,QACJA,CAAA;IACI,OAAO,IAAK,CAAAgB,SAAA;EAAA;EAChB;EAGA,IAAIb,QAAQgB,KACZ;IACIA,KAAA,KAAAA,KAAA,GAAUP,OAAQ,CAAAW,KAAA;IAElB,MAAMC,cAAA,GAAiB,IAAK,CAAAC,QAAA;IAE5B,IAAID,cAAmB,KAAAL,KAAA,EAAO;IAE9B,IAAIK,cAAA,IAAkBA,cAAe,CAAAE,OAAA,EAASF,cAAA,CAAeF,GAAI,WAAU,IAAK,CAAAJ,YAAA,EAAc,IAAI;IAClG,IAAIC,KAAM,CAAAO,OAAA,EAASP,KAAA,CAAMF,EAAG,WAAU,IAAK,CAAAC,YAAA,EAAc,IAAI;IAE7D,IAAI,KAAKjB,MACT;MACK,KAAKA,MAAA,CAAoCE,OAAU,GAAAgB,KAAA;IAAA;IAGxD,KAAKM,QAAW,GAAAN,KAAA;IAChB,KAAKD,YAAa;EAAA;EAGtB,IAAIf,OACJA,CAAA;IACI,OAAO,IAAK,CAAAsB,QAAA;EAAA;EAGhB,IAAIE,OACJA,CAAA;IACI,IAAI,IAAK,CAAAN,OAAA,EAAgB;IAErB,SAAKL,SAAA,YAAqBY,YAC9B;MACQ,SAAKZ,SAAU,CAAAa,SAAA,KAAc,MACjC;QACI,OAAO,IAAK,CAAAb,SAAA,CAAUc,SAAU,CAAAC,MAAA,GAAS,CAAK;MAAA;MAG3C,YAAKf,SAAA,CAAUa,SAAc;IAAA;IAGjC;EAAA;EACX;AAAA;AAAA;AAAA;EAMA,IAAIG,MACJA,CAAA;IACI,OAAO,KAAKhB,SAAU,CAAAgB,MAAA;EAAA;EAC1B;AAAA;AAAA;AAAA;EAMOC,UAAUD,MACjB;IACWA,MAAA,CAAAC,SAAA,CAAU,IAAK,CAAAjC,QAAA,CAASgC,MAAM;EAAA;EACzC;AAAA;AAAA;AAAA;EAMOE,cAAcC,KACrB;IACU;MAAEC,CAAG;MAAAC;IAAA,CAAM,GAAAF,KAAA;IAEjB,IAAI,CAAC,KAAKH,MAAO,CAAAE,aAAA,CAAcE,CAAA,EAAGC,CAAC,GAAU;IAE7C,MAAMC,QAAW,QAAKtC,QAAS,CAAAuC,SAAA,CAAU,WAAW,CAAE,CAAAC,IAAA;IAEtD,MAAMC,IAAO,QAAKzC,QAAS,CAAAE,QAAA,KAAa,mBAAmB,CAAI;IAE3D,SAAKF,QAAS,CAAA0C,QAAA,EAClB;MACI,MAAMC,OAAU,QAAK3C,QAAS,CAAA0C,QAAA,EAAW,CAAAF,IAAA;MACzC,MAAMI,GAAA,GAAMD,OAAQ,CAAAZ,MAAA;MAEpB,SAASc,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAI,CAAI,GAAAD,GAAA,EAAKC,CAAA,IAAKJ,IAClC;QACU,MAAAK,IAAA,GAAOH,OAAQ,CAAAE,CAAC,CAAI;QAC1B,MAAME,IAAO,GAAAJ,OAAA,CAAQE,CAAI,IAAC,CAAI;QAC9B,MAAMG,IAAO,GAAAL,OAAA,CAAQE,CAAI,IAAC,CAAI;QAE1B,IAAAI,eAAA,CACAb,CAAA,EAAGC,CAAA,EACHC,QAAA,CAASQ,IAAI,GACbR,QAAA,CAASQ,IAAA,GAAO,CAAC,GACjBR,QAAA,CAASS,IAAI,GACbT,QAAA,CAASS,IAAA,GAAO,CAAC,GACjBT,QAAA,CAASU,IAAI,GACbV,QAAA,CAASU,IAAA,GAAO,CAAC,EAErB;UACW;QAAA;MACX;IACJ,CAGJ;MACU,MAAAJ,GAAA,GAAMN,QAAA,CAASP,MAAS;MAE9B,SAASc,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAI,CAAI,GAAAD,GAAA,EAAKC,CAAA,IAAKJ,IAClC;QACI,MAAMK,IAAA,GAAOD,CAAI;QACX,MAAAE,IAAA,IAAQF,CAAA,GAAI,CAAK;QACjB,MAAAG,IAAA,IAAQH,CAAA,GAAI,CAAK;QAEnB,IAAAI,eAAA,CACAb,CAAA,EAAGC,CAAA,EACHC,QAAA,CAASQ,IAAI,GACbR,QAAA,CAASQ,IAAA,GAAO,CAAC,GACjBR,QAAA,CAASS,IAAI,GACbT,QAAA,CAASS,IAAA,GAAO,CAAC,GACjBT,QAAA,CAASU,IAAI,GACbV,QAAA,CAASU,IAAA,GAAO,CAAC,EAErB;UACW;QAAA;MACX;IACJ;IAGG;EAAA;EACX;EAGO9B,YACPA,CAAA;IAEI,KAAKgC,YAAA,IAAgB,CAAK;IAE1B,IAAI,IAAK,CAAAC,aAAA,EAAe;IACxB,KAAKA,aAAgB;IAEf,MAAAC,WAAA,GAAc,IAAK,CAAAA,WAAA,IAAe,IAAK,CAAAC,iBAAA;IAE7C,IAAID,WACJ;MACIA,WAAA,CAAYE,iBAAA,CAAkB,IAAI;IAAA;EACtC;EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASOC,QAAQ3D,OACf;IACI,MAAM2D,OAAA,CAAQ3D,OAAO;IAErB,MAAM4D,cAAiB,UAAO5D,OAAY,iBAAYA,OAAA,GAAUA,OAAS,EAAAO,OAAA;IAEzE,IAAIqD,cACJ;MACI,MAAMC,oBAAuB,UAAO7D,OAAY,iBAAYA,OAAA,GAAUA,OAAS,EAAA8D,aAAA;MAE1E,KAAAjC,QAAA,CAAS8B,OAAA,CAAQE,oBAAoB;IAAA;IAG9C,KAAKzC,SAAW,EAAAM,GAAA,CAAI,QAAU,OAAKJ,YAAA,EAAc,IAAI;IAErD,KAAKO,QAAW;IAChB,KAAKT,SAAY;IACjB,KAAKK,OAAU;EAAA;AAEvB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}