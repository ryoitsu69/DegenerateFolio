{"ast":null,"code":"import { secp256k1 } from '@noble/curves/secp256k1';\nimport { hasBigInt, u8aToU8a } from '@polkadot/util';\nimport { isReady, secp256k1Recover as wasm } from '@polkadot/wasm-crypto';\nimport { secp256k1Compress } from './compress.js';\nimport { secp256k1Expand } from './expand.js';\n/**\n * @name secp256k1Recover\n * @description Recovers a publicKey from the supplied signature\n */\nexport function secp256k1Recover(msgHash, signature, recovery) {\n  let hashType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'blake2';\n  let onlyJs = arguments.length > 4 ? arguments[4] : undefined;\n  const sig = u8aToU8a(signature).subarray(0, 64);\n  const msg = u8aToU8a(msgHash);\n  const publicKey = !hasBigInt || !onlyJs && isReady() ? wasm(msg, sig, recovery) : secp256k1.Signature.fromCompact(sig).addRecoveryBit(recovery).recoverPublicKey(msg).toRawBytes();\n  if (!publicKey) {\n    throw new Error('Unable to recover publicKey from signature');\n  }\n  return hashType === 'keccak' ? secp256k1Expand(publicKey, onlyJs) : secp256k1Compress(publicKey, onlyJs);\n}","map":{"version":3,"names":["secp256k1","hasBigInt","u8aToU8a","isReady","secp256k1Recover","wasm","secp256k1Compress","secp256k1Expand","msgHash","signature","recovery","hashType","arguments","length","undefined","onlyJs","sig","subarray","msg","publicKey","Signature","fromCompact","addRecoveryBit","recoverPublicKey","toRawBytes","Error"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util-crypto/secp256k1/recover.js"],"sourcesContent":["import { secp256k1 } from '@noble/curves/secp256k1';\nimport { hasBigInt, u8aToU8a } from '@polkadot/util';\nimport { isReady, secp256k1Recover as wasm } from '@polkadot/wasm-crypto';\nimport { secp256k1Compress } from './compress.js';\nimport { secp256k1Expand } from './expand.js';\n/**\n * @name secp256k1Recover\n * @description Recovers a publicKey from the supplied signature\n */\nexport function secp256k1Recover(msgHash, signature, recovery, hashType = 'blake2', onlyJs) {\n    const sig = u8aToU8a(signature).subarray(0, 64);\n    const msg = u8aToU8a(msgHash);\n    const publicKey = !hasBigInt || (!onlyJs && isReady())\n        ? wasm(msg, sig, recovery)\n        : secp256k1.Signature\n            .fromCompact(sig)\n            .addRecoveryBit(recovery)\n            .recoverPublicKey(msg)\n            .toRawBytes();\n    if (!publicKey) {\n        throw new Error('Unable to recover publicKey from signature');\n    }\n    return hashType === 'keccak'\n        ? secp256k1Expand(publicKey, onlyJs)\n        : secp256k1Compress(publicKey, onlyJs);\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,yBAAyB;AACnD,SAASC,SAAS,EAAEC,QAAQ,QAAQ,gBAAgB;AACpD,SAASC,OAAO,EAAEC,gBAAgB,IAAIC,IAAI,QAAQ,uBAAuB;AACzE,SAASC,iBAAiB,QAAQ,eAAe;AACjD,SAASC,eAAe,QAAQ,aAAa;AAC7C;AACA;AACA;AACA;AACA,OAAO,SAASH,gBAAgBA,CAACI,OAAO,EAAEC,SAAS,EAAEC,QAAQ,EAA+B;EAAA,IAA7BC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,QAAQ;EAAA,IAAEG,MAAM,GAAAH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EACtF,MAAME,GAAG,GAAGd,QAAQ,CAACO,SAAS,CAAC,CAACQ,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC;EAC/C,MAAMC,GAAG,GAAGhB,QAAQ,CAACM,OAAO,CAAC;EAC7B,MAAMW,SAAS,GAAG,CAAClB,SAAS,IAAK,CAACc,MAAM,IAAIZ,OAAO,CAAC,CAAE,GAChDE,IAAI,CAACa,GAAG,EAAEF,GAAG,EAAEN,QAAQ,CAAC,GACxBV,SAAS,CAACoB,SAAS,CAChBC,WAAW,CAACL,GAAG,CAAC,CAChBM,cAAc,CAACZ,QAAQ,CAAC,CACxBa,gBAAgB,CAACL,GAAG,CAAC,CACrBM,UAAU,CAAC,CAAC;EACrB,IAAI,CAACL,SAAS,EAAE;IACZ,MAAM,IAAIM,KAAK,CAAC,4CAA4C,CAAC;EACjE;EACA,OAAOd,QAAQ,KAAK,QAAQ,GACtBJ,eAAe,CAACY,SAAS,EAAEJ,MAAM,CAAC,GAClCT,iBAAiB,CAACa,SAAS,EAAEJ,MAAM,CAAC;AAC9C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}