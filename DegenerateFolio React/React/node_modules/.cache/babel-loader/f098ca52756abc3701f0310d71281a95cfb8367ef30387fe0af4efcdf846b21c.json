{"ast":null,"code":"import { getTypeDef } from '@polkadot/types-create';\nimport { createFunction } from './createFunction.js';\nfunction findSiPrimitive(registry, type) {\n  const prim = type.toLowerCase();\n  return registry.lookup.types.find(t => t.type.def.isPrimitive && t.type.def.asPrimitive.toString().toLowerCase() === prim || t.type.def.isHistoricMetaCompat && t.type.def.asHistoricMetaCompat.toString().toLowerCase() === prim);\n}\nfunction findSiType(registry, type) {\n  let portable = findSiPrimitive(registry, type);\n  // some types are either Sequence or Arrays, cater for these\n  // specifically (these all come from the base substrate known keys)\n  if (!portable && (type === 'Bytes' || type.startsWith('[u8;'))) {\n    const u8 = findSiPrimitive(registry, 'u8');\n    if (u8) {\n      if (type === 'Bytes') {\n        portable = registry.lookup.types.find(t => t.type.def.isSequence && t.type.def.asSequence.type.eq(u8.id) || t.type.def.isHistoricMetaCompat && t.type.def.asHistoricMetaCompat.eq(type));\n      } else {\n        const td = getTypeDef(type);\n        portable = registry.lookup.types.find(t => t.type.def.isArray && t.type.def.asArray.eq({\n          len: td.length,\n          type: u8.id\n        }) || t.type.def.isHistoricMetaCompat && t.type.def.asHistoricMetaCompat.eq(type));\n      }\n    }\n  }\n  if (!portable) {\n    // Not fatal, however if this happens the storage key using this\n    // type will not return valid values, rather it will most probably\n    // be decoded incorrectly\n    console.warn(\"Unable to map \".concat(type, \" to a lookup index\"));\n  }\n  return portable;\n}\n/** @internal */\nexport function createRuntimeFunction(_ref, key, _ref2) {\n  let {\n    method,\n    prefix,\n    section\n  } = _ref;\n  let {\n    docs,\n    type\n  } = _ref2;\n  return registry => {\n    var _findSiType;\n    return createFunction(registry, {\n      meta: registry.createTypeUnsafe('StorageEntryMetadataLatest', [{\n        docs: registry.createTypeUnsafe('Vec<Text>', [[docs]]),\n        modifier: registry.createTypeUnsafe('StorageEntryModifierLatest', ['Required']),\n        name: registry.createTypeUnsafe('Text', [method]),\n        toJSON: () => key,\n        type: registry.createTypeUnsafe('StorageEntryTypeLatest', [{\n          Plain: ((_findSiType = findSiType(registry, type)) === null || _findSiType === void 0 ? void 0 : _findSiType.id) || 0\n        }])\n      }]),\n      method,\n      prefix,\n      section\n    }, {\n      key,\n      skipHashing: true\n    });\n  };\n}","map":{"version":3,"names":["getTypeDef","createFunction","findSiPrimitive","registry","type","prim","toLowerCase","lookup","types","find","t","def","isPrimitive","asPrimitive","toString","isHistoricMetaCompat","asHistoricMetaCompat","findSiType","portable","startsWith","u8","isSequence","asSequence","eq","id","td","isArray","asArray","len","length","console","warn","concat","createRuntimeFunction","_ref","key","_ref2","method","prefix","section","docs","_findSiType","meta","createTypeUnsafe","modifier","name","toJSON","Plain","skipHashing"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/metadata/decorate/storage/util.js"],"sourcesContent":["import { getTypeDef } from '@polkadot/types-create';\nimport { createFunction } from './createFunction.js';\nfunction findSiPrimitive(registry, type) {\n    const prim = type.toLowerCase();\n    return registry.lookup.types.find((t) => (t.type.def.isPrimitive &&\n        t.type.def.asPrimitive.toString().toLowerCase() === prim) || (t.type.def.isHistoricMetaCompat &&\n        t.type.def.asHistoricMetaCompat.toString().toLowerCase() === prim));\n}\nfunction findSiType(registry, type) {\n    let portable = findSiPrimitive(registry, type);\n    // some types are either Sequence or Arrays, cater for these\n    // specifically (these all come from the base substrate known keys)\n    if (!portable && (type === 'Bytes' || type.startsWith('[u8;'))) {\n        const u8 = findSiPrimitive(registry, 'u8');\n        if (u8) {\n            if (type === 'Bytes') {\n                portable = registry.lookup.types.find((t) => (t.type.def.isSequence &&\n                    t.type.def.asSequence.type.eq(u8.id)) || (t.type.def.isHistoricMetaCompat &&\n                    t.type.def.asHistoricMetaCompat.eq(type)));\n            }\n            else {\n                const td = getTypeDef(type);\n                portable = registry.lookup.types.find((t) => (t.type.def.isArray &&\n                    t.type.def.asArray.eq({\n                        len: td.length,\n                        type: u8.id\n                    })) || (t.type.def.isHistoricMetaCompat &&\n                    t.type.def.asHistoricMetaCompat.eq(type)));\n            }\n        }\n    }\n    if (!portable) {\n        // Not fatal, however if this happens the storage key using this\n        // type will not return valid values, rather it will most probably\n        // be decoded incorrectly\n        console.warn(`Unable to map ${type} to a lookup index`);\n    }\n    return portable;\n}\n/** @internal */\nexport function createRuntimeFunction({ method, prefix, section }, key, { docs, type }) {\n    return (registry) => createFunction(registry, {\n        meta: registry.createTypeUnsafe('StorageEntryMetadataLatest', [{\n                docs: registry.createTypeUnsafe('Vec<Text>', [[docs]]),\n                modifier: registry.createTypeUnsafe('StorageEntryModifierLatest', ['Required']),\n                name: registry.createTypeUnsafe('Text', [method]),\n                toJSON: () => key,\n                type: registry.createTypeUnsafe('StorageEntryTypeLatest', [{ Plain: findSiType(registry, type)?.id || 0 }])\n            }]),\n        method,\n        prefix,\n        section\n    }, { key, skipHashing: true });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}