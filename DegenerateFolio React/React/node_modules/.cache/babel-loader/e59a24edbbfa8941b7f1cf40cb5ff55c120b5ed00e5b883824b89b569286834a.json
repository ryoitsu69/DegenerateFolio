{"ast":null,"code":"import { isString, objectSpread, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { Getters } from './Getters.js';\nexport class ApiBase extends Getters {\n  /**\n   * @description Create an instance of the class\n   *\n   * @param options Options object to create API instance or a Provider instance\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * import Api from '@polkadot/api/promise';\n   *\n   * const api = new Api().isReady();\n   *\n   * api.rpc.subscribeNewHeads((header) => {\n   *   console.log(`new block #${header.number.toNumber()}`);\n   * });\n   * ```\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let type = arguments.length > 1 ? arguments[1] : undefined;\n    let decorateMethod = arguments.length > 2 ? arguments[2] : undefined;\n    super(options, type, decorateMethod);\n  }\n  /**\n   * @description Connect from the underlying provider, halting all network traffic\n   */\n  connect() {\n    return this._rpcCore.connect();\n  }\n  /**\n   * @description Disconnect from the underlying provider, halting all network traffic\n   */\n  disconnect() {\n    this._unsubscribe();\n    return this._rpcCore.disconnect();\n  }\n  /**\n   * @description Set an external signer which will be used to sign extrinsic when account passed in is not KeyringPair\n   */\n  setSigner(signer) {\n    this._rx.signer = signer;\n  }\n  /**\n   * @description Signs a raw signer payload, string or Uint8Array\n   */\n  async sign(address, data) {\n    let {\n      signer\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (isString(address)) {\n      const _signer = signer || this._rx.signer;\n      if (!(_signer !== null && _signer !== void 0 && _signer.signRaw)) {\n        throw new Error('No signer exists with a signRaw interface. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.');\n      }\n      return (await _signer.signRaw(objectSpread({\n        type: 'bytes'\n      }, data, {\n        address\n      }))).signature;\n    }\n    return u8aToHex(address.sign(u8aToU8a(data.data)));\n  }\n}","map":{"version":3,"names":["isString","objectSpread","u8aToHex","u8aToU8a","Getters","ApiBase","constructor","options","arguments","length","undefined","type","decorateMethod","connect","_rpcCore","disconnect","_unsubscribe","setSigner","signer","_rx","sign","address","data","_signer","signRaw","Error","signature"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api/base/index.js"],"sourcesContent":["import { isString, objectSpread, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { Getters } from './Getters.js';\nexport class ApiBase extends Getters {\n    /**\n     * @description Create an instance of the class\n     *\n     * @param options Options object to create API instance or a Provider instance\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * import Api from '@polkadot/api/promise';\n     *\n     * const api = new Api().isReady();\n     *\n     * api.rpc.subscribeNewHeads((header) => {\n     *   console.log(`new block #${header.number.toNumber()}`);\n     * });\n     * ```\n     */\n    constructor(options = {}, type, decorateMethod) {\n        super(options, type, decorateMethod);\n    }\n    /**\n     * @description Connect from the underlying provider, halting all network traffic\n     */\n    connect() {\n        return this._rpcCore.connect();\n    }\n    /**\n     * @description Disconnect from the underlying provider, halting all network traffic\n     */\n    disconnect() {\n        this._unsubscribe();\n        return this._rpcCore.disconnect();\n    }\n    /**\n     * @description Set an external signer which will be used to sign extrinsic when account passed in is not KeyringPair\n     */\n    setSigner(signer) {\n        this._rx.signer = signer;\n    }\n    /**\n     * @description Signs a raw signer payload, string or Uint8Array\n     */\n    async sign(address, data, { signer } = {}) {\n        if (isString(address)) {\n            const _signer = signer || this._rx.signer;\n            if (!_signer?.signRaw) {\n                throw new Error('No signer exists with a signRaw interface. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.');\n            }\n            return (await _signer.signRaw(objectSpread({ type: 'bytes' }, data, { address }))).signature;\n        }\n        return u8aToHex(address.sign(u8aToU8a(data.data)));\n    }\n}\n"],"mappings":"AAAA,SAASA,QAAQ,EAAEC,YAAY,EAAEC,QAAQ,EAAEC,QAAQ,QAAQ,gBAAgB;AAC3E,SAASC,OAAO,QAAQ,cAAc;AACtC,OAAO,MAAMC,OAAO,SAASD,OAAO,CAAC;EACjC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,WAAWA,CAAA,EAAqC;IAAA,IAApCC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IAAA,IAAEG,IAAI,GAAAH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IAAA,IAAEE,cAAc,GAAAJ,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IAC1C,KAAK,CAACH,OAAO,EAAEI,IAAI,EAAEC,cAAc,CAAC;EACxC;EACA;AACJ;AACA;EACIC,OAAOA,CAAA,EAAG;IACN,OAAO,IAAI,CAACC,QAAQ,CAACD,OAAO,CAAC,CAAC;EAClC;EACA;AACJ;AACA;EACIE,UAAUA,CAAA,EAAG;IACT,IAAI,CAACC,YAAY,CAAC,CAAC;IACnB,OAAO,IAAI,CAACF,QAAQ,CAACC,UAAU,CAAC,CAAC;EACrC;EACA;AACJ;AACA;EACIE,SAASA,CAACC,MAAM,EAAE;IACd,IAAI,CAACC,GAAG,CAACD,MAAM,GAAGA,MAAM;EAC5B;EACA;AACJ;AACA;EACI,MAAME,IAAIA,CAACC,OAAO,EAAEC,IAAI,EAAmB;IAAA,IAAjB;MAAEJ;IAAO,CAAC,GAAAV,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IACrC,IAAIR,QAAQ,CAACqB,OAAO,CAAC,EAAE;MACnB,MAAME,OAAO,GAAGL,MAAM,IAAI,IAAI,CAACC,GAAG,CAACD,MAAM;MACzC,IAAI,EAACK,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAEC,OAAO,GAAE;QACnB,MAAM,IAAIC,KAAK,CAAC,gJAAgJ,CAAC;MACrK;MACA,OAAO,CAAC,MAAMF,OAAO,CAACC,OAAO,CAACvB,YAAY,CAAC;QAAEU,IAAI,EAAE;MAAQ,CAAC,EAAEW,IAAI,EAAE;QAAED;MAAQ,CAAC,CAAC,CAAC,EAAEK,SAAS;IAChG;IACA,OAAOxB,QAAQ,CAACmB,OAAO,CAACD,IAAI,CAACjB,QAAQ,CAACmB,IAAI,CAACA,IAAI,CAAC,CAAC,CAAC;EACtD;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}