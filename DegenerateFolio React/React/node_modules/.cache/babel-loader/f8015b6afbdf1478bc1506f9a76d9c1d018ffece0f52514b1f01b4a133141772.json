{"ast":null,"code":"import { Container } from '../scene/container/Container.mjs';\nimport { UPDATE_PRIORITY } from '../ticker/const.mjs';\nimport { Ticker } from '../ticker/Ticker.mjs';\n\"use strict\";\nconst _PrepareBase = class _PrepareBase {\n  /**\n   * * @param {Renderer} renderer - A reference to the current renderer\n   * @param renderer\n   */\n  constructor(renderer) {\n    /** called per frame by the ticker, defer processing to next tick */\n    this._tick = () => {\n      this.timeout = setTimeout(this._processQueue, 0);\n    };\n    /** process the queue up to max item limit per frame */\n    this._processQueue = () => {\n      const {\n        queue\n      } = this;\n      let itemsProcessed = 0;\n      while (queue.length && itemsProcessed < _PrepareBase.uploadsPerFrame) {\n        const queueItem = queue.shift();\n        this.uploadQueueItem(queueItem);\n        itemsProcessed++;\n      }\n      if (queue.length) {\n        Ticker.system.addOnce(this._tick, this, UPDATE_PRIORITY.UTILITY);\n      } else {\n        this._resolve();\n      }\n    };\n    this.renderer = renderer;\n    this.queue = [];\n    this.resolves = [];\n  }\n  /**\n   * Return a copy of the queue\n   * @returns {PrepareQueueItem[]} The queue\n   */\n  getQueue() {\n    return [...this.queue];\n  }\n  /**\n   * Add a textures or graphics resource to the queue\n   * @param {PrepareSourceItem | PrepareSourceItem[]} resource\n   */\n  add(resource) {\n    const resourceArray = Array.isArray(resource) ? resource : [resource];\n    for (const resourceItem of resourceArray) {\n      if (resourceItem instanceof Container) {\n        this._addContainer(resourceItem);\n      } else {\n        this.resolveQueueItem(resourceItem, this.queue);\n      }\n    }\n    return this;\n  }\n  /**\n   * Recursively add a container and its children to the queue\n   * @param {Container} container - The container to add to the queue\n   */\n  _addContainer(container) {\n    this.resolveQueueItem(container, this.queue);\n    for (const child of container.children) {\n      this._addContainer(child);\n    }\n  }\n  /**\n   * Upload all the textures and graphics to the GPU (optionally add more resources to the queue first)\n   * @param {PrepareSourceItem | PrepareSourceItem[] | undefined} resource\n   */\n  upload(resource) {\n    if (resource) {\n      this.add(resource);\n    }\n    return new Promise(resolve => {\n      if (this.queue.length) {\n        this.resolves.push(resolve);\n        this.dedupeQueue();\n        Ticker.system.addOnce(this._tick, this, UPDATE_PRIORITY.UTILITY);\n      } else {\n        resolve();\n      }\n    });\n  }\n  /** eliminate duplicates before processing */\n  dedupeQueue() {\n    const hash = /* @__PURE__ */Object.create(null);\n    let nextUnique = 0;\n    for (let i = 0; i < this.queue.length; i++) {\n      const current = this.queue[i];\n      if (!hash[current.uid]) {\n        hash[current.uid] = true;\n        this.queue[nextUnique++] = current;\n      }\n    }\n    this.queue.length = nextUnique;\n  }\n  /** Call all the resolve callbacks */\n  _resolve() {\n    const {\n      resolves\n    } = this;\n    const array = resolves.slice(0);\n    resolves.length = 0;\n    for (const resolve of array) {\n      resolve();\n    }\n  }\n};\n/** The number of uploads to process per frame */\n_PrepareBase.uploadsPerFrame = 4;\nlet PrepareBase = _PrepareBase;\nexport { PrepareBase };","map":{"version":3,"names":["_PrepareBase","constructor","renderer","_tick","timeout","setTimeout","_processQueue","queue","itemsProcessed","length","uploadsPerFrame","queueItem","shift","uploadQueueItem","Ticker","system","addOnce","UPDATE_PRIORITY","UTILITY","_resolve","resolves","getQueue","add","resource","resourceArray","Array","isArray","resourceItem","Container","_addContainer","resolveQueueItem","container","child","children","upload","Promise","resolve","push","dedupeQueue","hash","Object","create","nextUnique","i","current","uid","array","slice","PrepareBase"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/prepare/PrepareBase.ts"],"sourcesContent":["import { Container } from '../scene/container/Container';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { GraphicsContext } from '../scene/graphics/shared/GraphicsContext';\nimport type { Text } from '../scene/text/Text';\n\n/** The accepted types to pass to the prepare system */\nexport type PrepareSourceItem = Container | TextureSource | Texture | GraphicsContext;\n\n/** The valid types resolved to the queue ready for upload */\nexport type PrepareQueueItem = TextureSource | Text | GraphicsContext;\n\n/**\n * Part of the prepare system. Responsible for uploading all the items to the GPU.\n * This class provides the base functionality and handles processing the queue asynchronously.\n * @memberof rendering\n */\nexport abstract class PrepareBase\n{\n    /** The number of uploads to process per frame */\n    public static uploadsPerFrame = 4;\n\n    /** Reference to the renderer */\n    protected renderer: Renderer;\n\n    /** The queue to process over a async timer */\n    protected queue: PrepareQueueItem[];\n\n    /** Collection of callbacks to call when the uploads are finished */\n    protected resolves: ((value: void | PromiseLike<void>) => void)[];\n\n    /** Timeout id for next processing call */\n    protected timeout?: number;\n\n    /**\n     * * @param {Renderer} renderer - A reference to the current renderer\n     * @param renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this.queue = [];\n        this.resolves = [];\n    }\n\n    /** Resolve the given resource type and return an item for the queue */\n    protected abstract resolveQueueItem(source: PrepareSourceItem, queue: PrepareQueueItem[]): void;\n    protected abstract uploadQueueItem(item: PrepareQueueItem): void;\n\n    /**\n     * Return a copy of the queue\n     * @returns {PrepareQueueItem[]} The queue\n     */\n    public getQueue(): PrepareQueueItem[]\n    {\n        return [...this.queue];\n    }\n\n    /**\n     * Add a textures or graphics resource to the queue\n     * @param {PrepareSourceItem | PrepareSourceItem[]} resource\n     */\n    public add(resource: PrepareSourceItem | PrepareSourceItem[]): this\n    {\n        const resourceArray = Array.isArray(resource) ? resource : [resource];\n\n        for (const resourceItem of resourceArray)\n        {\n            // handle containers and their children\n            if (resourceItem instanceof Container)\n            {\n                this._addContainer(resourceItem);\n            }\n            else\n            {\n                this.resolveQueueItem(resourceItem, this.queue);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Recursively add a container and its children to the queue\n     * @param {Container} container - The container to add to the queue\n     */\n    private _addContainer(container: Container): void\n    {\n        this.resolveQueueItem(container, this.queue);\n\n        // recursively add children\n        for (const child of container.children)\n        {\n            this._addContainer(child);\n        }\n    }\n\n    /**\n     * Upload all the textures and graphics to the GPU (optionally add more resources to the queue first)\n     * @param {PrepareSourceItem | PrepareSourceItem[] | undefined} resource\n     */\n    public upload(resource?: PrepareSourceItem | PrepareSourceItem[]): Promise<void>\n    {\n        if (resource)\n        {\n            this.add(resource);\n        }\n\n        return new Promise((resolve) =>\n        {\n            if (this.queue.length)\n            {\n                // add resolve callback to the collection\n                this.resolves.push(resolve);\n\n                // eliminate duplicates first\n                this.dedupeQueue();\n\n                // launch first tick\n                Ticker.system.addOnce(this._tick, this, UPDATE_PRIORITY.UTILITY);\n            }\n            else\n            {\n                // queue is empty, resolve immediately\n                resolve();\n            }\n        });\n    }\n\n    /** eliminate duplicates before processing */\n    public dedupeQueue(): void\n    {\n        const hash = Object.create(null);\n        let nextUnique = 0;\n\n        for (let i = 0; i < this.queue.length; i++)\n        {\n            const current = this.queue[i];\n\n            if (!hash[current.uid])\n            {\n                hash[current.uid] = true;\n                this.queue[nextUnique++] = current;\n            }\n        }\n\n        this.queue.length = nextUnique;\n    }\n\n    /** called per frame by the ticker, defer processing to next tick */\n    private readonly _tick = () =>\n    {\n        this.timeout = setTimeout(this._processQueue, 0) as unknown as number;\n    };\n\n    /** process the queue up to max item limit per frame */\n    private readonly _processQueue = () =>\n    {\n        const { queue } = this;\n        let itemsProcessed = 0;\n\n        // process the maximum number of items per frame\n        while (queue.length && itemsProcessed < PrepareBase.uploadsPerFrame)\n        {\n            const queueItem = queue.shift();\n\n            this.uploadQueueItem(queueItem);\n\n            itemsProcessed++;\n        }\n\n        if (queue.length)\n        {\n            // queue is not empty, continue processing on next frame\n            Ticker.system.addOnce(this._tick, this, UPDATE_PRIORITY.UTILITY);\n        }\n        else\n        {\n            // queue is empty, resolve immediately\n            this._resolve();\n        }\n    };\n\n    /** Call all the resolve callbacks */\n    private _resolve(): void\n    {\n        const { resolves } = this;\n\n        // call all resolve callbacks\n        const array = resolves.slice(0);\n\n        resolves.length = 0;\n\n        for (const resolve of array)\n        {\n            resolve();\n        }\n    }\n}\n"],"mappings":";;;;AAqBO,MAAeA,YAAA,GAAf,MAAeA,YACtB;EAAA;AAAA;AAAA;AAAA;EAoBIC,YAAYC,QACZ;IA+GA;IAAA,KAAiBC,KAAA,GAAQ,MACzB;MACI,KAAKC,OAAU,GAAAC,UAAA,CAAW,IAAK,CAAAC,aAAA,EAAe,CAAC;IAAA,CACnD;IAGA;IAAA,KAAiBA,aAAA,GAAgB,MACjC;MACU;QAAEC;MAAA,CAAU;MAClB,IAAIC,cAAiB;MAGrB,OAAOD,KAAM,CAAAE,MAAA,IAAUD,cAAiB,GAAAR,YAAA,CAAYU,eACpD;QACU,MAAAC,SAAA,GAAYJ,KAAA,CAAMK,KAAM;QAE9B,KAAKC,eAAA,CAAgBF,SAAS;QAE9BH,cAAA;MAAA;MAGJ,IAAID,KAAA,CAAME,MACV;QAEIK,MAAA,CAAOC,MAAA,CAAOC,OAAQ,MAAKb,KAAO,QAAMc,eAAA,CAAgBC,OAAO;MAAA,CAGnE;QAEI,KAAKC,QAAS;MAAA;IAClB,CACJ;IA7II,KAAKjB,QAAW,GAAAA,QAAA;IAChB,KAAKK,KAAA,GAAQ,EAAC;IACd,KAAKa,QAAA,GAAW,EAAC;EAAA;EACrB;AAAA;AAAA;AAAA;EAUOC,QACPA,CAAA;IACW,QAAC,GAAG,KAAKd,KAAK;EAAA;EACzB;AAAA;AAAA;AAAA;EAMOe,IAAIC,QACX;IACI,MAAMC,aAAA,GAAgBC,KAAM,CAAAC,OAAA,CAAQH,QAAQ,CAAI,GAAAA,QAAA,GAAW,CAACA,QAAQ;IAEpE,WAAWI,YAAA,IAAgBH,aAC3B;MAEI,IAAIG,YAAA,YAAwBC,SAC5B;QACI,KAAKC,aAAA,CAAcF,YAAY;MAAA,CAGnC;QACS,KAAAG,gBAAA,CAAiBH,YAAc,OAAKpB,KAAK;MAAA;IAClD;IAGG;EAAA;EACX;AAAA;AAAA;AAAA;EAMQsB,cAAcE,SACtB;IACS,KAAAD,gBAAA,CAAiBC,SAAW,OAAKxB,KAAK;IAGhC,WAAAyB,KAAA,IAASD,SAAA,CAAUE,QAC9B;MACI,KAAKJ,aAAA,CAAcG,KAAK;IAAA;EAC5B;EACJ;AAAA;AAAA;AAAA;EAMOE,OAAOX,QACd;IACI,IAAIA,QACJ;MACI,KAAKD,GAAA,CAAIC,QAAQ;IAAA;IAGd,WAAIY,OAAQ,CAACC,OACpB;MACQ,SAAK7B,KAAA,CAAME,MACf;QAES,KAAAW,QAAA,CAASiB,IAAA,CAAKD,OAAO;QAG1B,KAAKE,WAAY;QAGjBxB,MAAA,CAAOC,MAAA,CAAOC,OAAQ,MAAKb,KAAO,QAAMc,eAAA,CAAgBC,OAAO;MAAA,CAGnE;QAEYkB,OAAA;MAAA;IACZ,CACH;EAAA;EACL;EAGOE,WACPA,CAAA;IACU,MAAAC,IAAA,kBAAcC,MAAA,CAAAC,MAAA,CAAO,IAAI;IAC/B,IAAIC,UAAa;IAEjB,SAASC,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAI,IAAK,CAAApC,KAAA,CAAME,MAAA,EAAQkC,CACvC;MACU,MAAAC,OAAA,GAAU,IAAK,CAAArC,KAAA,CAAMoC,CAAC;MAE5B,IAAI,CAACJ,IAAA,CAAKK,OAAQ,CAAAC,GAAG,CACrB;QACSN,IAAA,CAAAK,OAAA,CAAQC,GAAG,CAAI;QACf,KAAAtC,KAAA,CAAMmC,UAAA,EAAY,CAAI,GAAAE,OAAA;MAAA;IAC/B;IAGJ,KAAKrC,KAAA,CAAME,MAAS,GAAAiC,UAAA;EAAA;EACxB;EAqCQvB,QACRA,CAAA;IACU;MAAEC;IAAA,CAAa;IAGf,MAAA0B,KAAA,GAAQ1B,QAAS,CAAA2B,KAAA,CAAM,CAAC;IAE9B3B,QAAA,CAASX,MAAS;IAElB,WAAW2B,OAAA,IAAWU,KACtB;MACYV,OAAA;IAAA;EACZ;AAER;AAAA;AArLsBpC,YAAA,CAGJU,eAAkB;AAH7B,IAAesC,WAAf,GAAAhD,YAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}