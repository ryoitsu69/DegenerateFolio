{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeAddress = exports.encodeAddress = void 0;\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nconst web3_errors_1 = require(\"web3-errors\");\nconst web3_utils_1 = require(\"web3-utils\");\nconst web3_validator_1 = require(\"web3-validator\");\nconst utils_js_1 = require(\"../utils.js\");\nconst ADDRESS_BYTES_COUNT = 20;\nconst ADDRESS_OFFSET = utils_js_1.WORD_SIZE - ADDRESS_BYTES_COUNT;\nfunction encodeAddress(param, input) {\n  if (typeof input !== 'string') {\n    throw new web3_errors_1.AbiError('address type expects string as input type', {\n      value: input,\n      name: param.name,\n      type: param.type\n    });\n  }\n  let address = input.toLowerCase();\n  if (!address.startsWith('0x')) {\n    address = `0x${address}`;\n  }\n  if (!(0, web3_validator_1.isAddress)(address)) {\n    throw new web3_errors_1.AbiError('provided input is not valid address', {\n      value: input,\n      name: param.name,\n      type: param.type\n    });\n  }\n  // for better performance, we could convert hex to destination bytes directly (encoded var)\n  const addressBytes = web3_validator_1.utils.hexToUint8Array(address);\n  // expand address to WORD_SIZE\n  const encoded = (0, utils_js_1.alloc)(utils_js_1.WORD_SIZE);\n  encoded.set(addressBytes, ADDRESS_OFFSET);\n  return {\n    dynamic: false,\n    encoded\n  };\n}\nexports.encodeAddress = encodeAddress;\nfunction decodeAddress(_param, bytes) {\n  const addressBytes = bytes.subarray(ADDRESS_OFFSET, utils_js_1.WORD_SIZE);\n  if (addressBytes.length !== ADDRESS_BYTES_COUNT) {\n    throw new web3_errors_1.AbiError('Invalid decoding input, not enough bytes to decode address', {\n      bytes\n    });\n  }\n  const result = web3_validator_1.utils.uint8ArrayToHexString(addressBytes);\n  // should we check is decoded value is valid address?\n  // if(!isAddress(result)) {\n  //     throw new AbiError(\"encoded data is not valid address\", {\n  //         address: result,\n  //     });\n  // }\n  return {\n    result: (0, web3_utils_1.toChecksumAddress)(result),\n    encoded: bytes.subarray(utils_js_1.WORD_SIZE),\n    consumed: utils_js_1.WORD_SIZE\n  };\n}\nexports.decodeAddress = decodeAddress;","map":{"version":3,"names":["web3_errors_1","require","web3_utils_1","web3_validator_1","utils_js_1","ADDRESS_BYTES_COUNT","ADDRESS_OFFSET","WORD_SIZE","encodeAddress","param","input","AbiError","value","name","type","address","toLowerCase","startsWith","isAddress","addressBytes","utils","hexToUint8Array","encoded","alloc","set","dynamic","exports","decodeAddress","_param","bytes","subarray","length","result","uint8ArrayToHexString","toChecksumAddress","consumed"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/web3-eth-abi/src/coders/base/address.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { AbiError } from 'web3-errors';\nimport { AbiParameter } from 'web3-types';\nimport { toChecksumAddress } from 'web3-utils';\nimport { isAddress, utils } from 'web3-validator';\nimport { DecoderResult, EncoderResult } from '../types.js';\nimport { alloc, WORD_SIZE } from '../utils.js';\n\nconst ADDRESS_BYTES_COUNT = 20;\nconst ADDRESS_OFFSET = WORD_SIZE - ADDRESS_BYTES_COUNT;\n\nexport function encodeAddress(param: AbiParameter, input: unknown): EncoderResult {\n\tif (typeof input !== 'string') {\n\t\tthrow new AbiError('address type expects string as input type', {\n\t\t\tvalue: input,\n\t\t\tname: param.name,\n\t\t\ttype: param.type,\n\t\t});\n\t}\n\tlet address = input.toLowerCase();\n\tif (!address.startsWith('0x')) {\n\t\taddress = `0x${address}`;\n\t}\n\tif (!isAddress(address)) {\n\t\tthrow new AbiError('provided input is not valid address', {\n\t\t\tvalue: input,\n\t\t\tname: param.name,\n\t\t\ttype: param.type,\n\t\t});\n\t}\n\t// for better performance, we could convert hex to destination bytes directly (encoded var)\n\tconst addressBytes = utils.hexToUint8Array(address);\n\t// expand address to WORD_SIZE\n\tconst encoded = alloc(WORD_SIZE);\n\tencoded.set(addressBytes, ADDRESS_OFFSET);\n\treturn {\n\t\tdynamic: false,\n\t\tencoded,\n\t};\n}\n\nexport function decodeAddress(_param: AbiParameter, bytes: Uint8Array): DecoderResult<string> {\n\tconst addressBytes = bytes.subarray(ADDRESS_OFFSET, WORD_SIZE);\n\tif (addressBytes.length !== ADDRESS_BYTES_COUNT) {\n\t\tthrow new AbiError('Invalid decoding input, not enough bytes to decode address', { bytes });\n\t}\n\tconst result = utils.uint8ArrayToHexString(addressBytes);\n\n\t// should we check is decoded value is valid address?\n\t// if(!isAddress(result)) {\n\t//     throw new AbiError(\"encoded data is not valid address\", {\n\t//         address: result,\n\t//     });\n\t// }\n\treturn {\n\t\tresult: toChecksumAddress(result),\n\t\tencoded: bytes.subarray(WORD_SIZE),\n\t\tconsumed: WORD_SIZE,\n\t};\n}\n"],"mappings":";;;;;;AAAA;;;;;;;;;;;;;;;;AAgBA,MAAAA,aAAA,GAAAC,OAAA;AAEA,MAAAC,YAAA,GAAAD,OAAA;AACA,MAAAE,gBAAA,GAAAF,OAAA;AAEA,MAAAG,UAAA,GAAAH,OAAA;AAEA,MAAMI,mBAAmB,GAAG,EAAE;AAC9B,MAAMC,cAAc,GAAGF,UAAA,CAAAG,SAAS,GAAGF,mBAAmB;AAEtD,SAAgBG,aAAaA,CAACC,KAAmB,EAAEC,KAAc;EAChE,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC9B,MAAM,IAAIV,aAAA,CAAAW,QAAQ,CAAC,2CAA2C,EAAE;MAC/DC,KAAK,EAAEF,KAAK;MACZG,IAAI,EAAEJ,KAAK,CAACI,IAAI;MAChBC,IAAI,EAAEL,KAAK,CAACK;KACZ,CAAC;;EAEH,IAAIC,OAAO,GAAGL,KAAK,CAACM,WAAW,EAAE;EACjC,IAAI,CAACD,OAAO,CAACE,UAAU,CAAC,IAAI,CAAC,EAAE;IAC9BF,OAAO,GAAG,KAAKA,OAAO,EAAE;;EAEzB,IAAI,CAAC,IAAAZ,gBAAA,CAAAe,SAAS,EAACH,OAAO,CAAC,EAAE;IACxB,MAAM,IAAIf,aAAA,CAAAW,QAAQ,CAAC,qCAAqC,EAAE;MACzDC,KAAK,EAAEF,KAAK;MACZG,IAAI,EAAEJ,KAAK,CAACI,IAAI;MAChBC,IAAI,EAAEL,KAAK,CAACK;KACZ,CAAC;;EAEH;EACA,MAAMK,YAAY,GAAGhB,gBAAA,CAAAiB,KAAK,CAACC,eAAe,CAACN,OAAO,CAAC;EACnD;EACA,MAAMO,OAAO,GAAG,IAAAlB,UAAA,CAAAmB,KAAK,EAACnB,UAAA,CAAAG,SAAS,CAAC;EAChCe,OAAO,CAACE,GAAG,CAACL,YAAY,EAAEb,cAAc,CAAC;EACzC,OAAO;IACNmB,OAAO,EAAE,KAAK;IACdH;GACA;AACF;AA5BAI,OAAA,CAAAlB,aAAA,GAAAA,aAAA;AA8BA,SAAgBmB,aAAaA,CAACC,MAAoB,EAAEC,KAAiB;EACpE,MAAMV,YAAY,GAAGU,KAAK,CAACC,QAAQ,CAACxB,cAAc,EAAEF,UAAA,CAAAG,SAAS,CAAC;EAC9D,IAAIY,YAAY,CAACY,MAAM,KAAK1B,mBAAmB,EAAE;IAChD,MAAM,IAAIL,aAAA,CAAAW,QAAQ,CAAC,4DAA4D,EAAE;MAAEkB;IAAK,CAAE,CAAC;;EAE5F,MAAMG,MAAM,GAAG7B,gBAAA,CAAAiB,KAAK,CAACa,qBAAqB,CAACd,YAAY,CAAC;EAExD;EACA;EACA;EACA;EACA;EACA;EACA,OAAO;IACNa,MAAM,EAAE,IAAA9B,YAAA,CAAAgC,iBAAiB,EAACF,MAAM,CAAC;IACjCV,OAAO,EAAEO,KAAK,CAACC,QAAQ,CAAC1B,UAAA,CAAAG,SAAS,CAAC;IAClC4B,QAAQ,EAAE/B,UAAA,CAAAG;GACV;AACF;AAlBAmB,OAAA,CAAAC,aAAA,GAAAA,aAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}