{"ast":null,"code":"import { isFunction, objectProperties, stringify } from '@polkadot/util';\nimport { compareMap } from '../utils/index.js';\n/** @internal */\nfunction decodeJson(value) {\n  return Object.entries(value || {});\n}\n/**\n * @name Json\n * @description\n * Wraps the a JSON structure retrieve via RPC. It extends the standard JS Map with. While it\n * implements a Codec, it is limited in that it can only be used with input objects via RPC,\n * i.e. no hex decoding. Unlike a struct, this waps a JSON object with unknown keys\n * @noInheritDoc\n */\nexport class Json extends Map {\n  registry;\n  createdAtHash;\n  initialU8aLength;\n  isStorageFallback;\n  constructor(registry, value) {\n    const decoded = decodeJson(value);\n    super(decoded);\n    this.registry = registry;\n    objectProperties(this, decoded.map(([k]) => k), k => this.get(k));\n  }\n  /**\n   * @description Always 0, never encodes as a Uint8Array\n   */\n  get encodedLength() {\n    return 0 | 0;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n  get isEmpty() {\n    return [...this.keys()].length === 0;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return compareMap(this, other);\n  }\n  /**\n   * @description Returns a typed value from the internal map\n   */\n  getT(key) {\n    return this.get(key);\n  }\n  /**\n   * @description Unimplemented, will throw\n   */\n  inspect() {\n    throw new Error('Unimplemented');\n  }\n  /**\n   * @description Unimplemented, will throw\n   */\n  toHex() {\n    throw new Error('Unimplemented');\n  }\n  /**\n   * @description Converts the Object to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman() {\n    return [...this.entries()].reduce((json, [key, value]) => {\n      json[key] = isFunction(value?.toHuman) ? value.toHuman() : value;\n      return json;\n    }, {});\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    return [...this.entries()].reduce((json, [key, value]) => {\n      json[key] = value;\n      return json;\n    }, {});\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive(disableAscii) {\n    return [...this.entries()].reduce((json, [key, value]) => {\n      json[key] = isFunction(value.toPrimitive) ? value.toPrimitive(disableAscii) : value;\n      return json;\n    }, {});\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'Json';\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return stringify(this.toJSON());\n  }\n  /**\n   * @description Unimplemented, will throw\n   */\n  toU8a(_isBare) {\n    throw new Error('Unimplemented');\n  }\n}","map":{"version":3,"names":["isFunction","objectProperties","stringify","compareMap","decodeJson","value","Object","entries","Json","Map","registry","createdAtHash","initialU8aLength","isStorageFallback","constructor","decoded","map","k","get","encodedLength","hash","toU8a","isEmpty","keys","length","eq","other","getT","key","inspect","Error","toHex","toHuman","reduce","json","toJSON","toPrimitive","disableAscii","toRawType","toString","_isBare"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/native/Json.js"],"sourcesContent":["import { isFunction, objectProperties, stringify } from '@polkadot/util';\nimport { compareMap } from '../utils/index.js';\n/** @internal */\nfunction decodeJson(value) {\n    return Object.entries(value || {});\n}\n/**\n * @name Json\n * @description\n * Wraps the a JSON structure retrieve via RPC. It extends the standard JS Map with. While it\n * implements a Codec, it is limited in that it can only be used with input objects via RPC,\n * i.e. no hex decoding. Unlike a struct, this waps a JSON object with unknown keys\n * @noInheritDoc\n */\nexport class Json extends Map {\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    constructor(registry, value) {\n        const decoded = decodeJson(value);\n        super(decoded);\n        this.registry = registry;\n        objectProperties(this, decoded.map(([k]) => k), (k) => this.get(k));\n    }\n    /**\n     * @description Always 0, never encodes as a Uint8Array\n     */\n    get encodedLength() {\n        return 0 | 0;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        return [...this.keys()].length === 0;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return compareMap(this, other);\n    }\n    /**\n     * @description Returns a typed value from the internal map\n     */\n    getT(key) {\n        return this.get(key);\n    }\n    /**\n     * @description Unimplemented, will throw\n     */\n    inspect() {\n        throw new Error('Unimplemented');\n    }\n    /**\n     * @description Unimplemented, will throw\n     */\n    toHex() {\n        throw new Error('Unimplemented');\n    }\n    /**\n     * @description Converts the Object to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman() {\n        return [...this.entries()].reduce((json, [key, value]) => {\n            json[key] = isFunction(value?.toHuman)\n                ? value.toHuman()\n                : value;\n            return json;\n        }, {});\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return [...this.entries()].reduce((json, [key, value]) => {\n            json[key] = value;\n            return json;\n        }, {});\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive(disableAscii) {\n        return [...this.entries()].reduce((json, [key, value]) => {\n            json[key] = isFunction(value.toPrimitive)\n                ? value.toPrimitive(disableAscii)\n                : value;\n            return json;\n        }, {});\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'Json';\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return stringify(this.toJSON());\n    }\n    /**\n     * @description Unimplemented, will throw\n     */\n    toU8a(_isBare) {\n        throw new Error('Unimplemented');\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}