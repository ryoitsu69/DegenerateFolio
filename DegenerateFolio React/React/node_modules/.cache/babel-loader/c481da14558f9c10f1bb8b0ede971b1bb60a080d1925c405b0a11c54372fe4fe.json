{"ast":null,"code":"import _defineProperty from \"/home/ryoitsu/Documents/test/react-todo-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { Struct, U8aFixed } from '@polkadot/types-codec';\nimport { isHex, isObject, isU8a, objectSpread, u8aToU8a } from '@polkadot/util';\n/**\n * Get a mapping of `argument name -> argument type` for the function, from\n * its metadata.\n *\n * @param meta - The function metadata used to get the definition.\n * @internal\n */\nfunction getArgsDef(registry, meta) {\n  return meta.fields.reduce((result, _ref, index) => {\n    let {\n      name,\n      type\n    } = _ref;\n    result[name.unwrapOr(\"param\".concat(index)).toString()] = registry.createLookupType(type);\n    return result;\n  }, {});\n}\n/** @internal */\nfunction decodeCallViaObject(registry, value, _meta) {\n  // we only pass args/methodsIndex out\n  const {\n    args,\n    callIndex\n  } = value;\n  // Get the correct lookupIndex\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  const lookupIndex = callIndex instanceof GenericCallIndex ? callIndex.toU8a() : callIndex;\n  // Find metadata with callIndex\n  const meta = _meta || registry.findMetaCall(lookupIndex).meta;\n  return {\n    args,\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/** @internal */\nfunction decodeCallViaU8a(registry, value, _meta) {\n  // We need 2 bytes for the callIndex\n  const callIndex = registry.firstCallIndex.slice();\n  callIndex.set(value.subarray(0, 2), 0);\n  // Find metadata with callIndex\n  const meta = _meta || registry.findMetaCall(callIndex).meta;\n  return {\n    args: value.subarray(2),\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param value - Value to decode, one of:\n * - hex\n * - Uint8Array\n * - {@see DecodeMethodInput}\n * @param _meta - Metadata to use, so that `injectMethods` lookup is not\n * necessary.\n * @internal\n */\nfunction decodeCall(registry) {\n  let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Uint8Array();\n  let _meta = arguments.length > 2 ? arguments[2] : undefined;\n  if (isU8a(value) || isHex(value)) {\n    return decodeCallViaU8a(registry, u8aToU8a(value), _meta);\n  } else if (isObject(value) && value.callIndex && value.args) {\n    return decodeCallViaObject(registry, value, _meta);\n  }\n  throw new Error(\"Call: Cannot decode value '\".concat(value, \"' of type \").concat(typeof value));\n}\n/**\n * @name GenericCallIndex\n * @description\n * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method\n */\nexport class GenericCallIndex extends U8aFixed {\n  constructor(registry, value) {\n    super(registry, value, 16);\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive() {\n    return this.toHex();\n  }\n}\n/**\n * @name GenericCall\n * @description\n * Extrinsic function descriptor\n */\nexport class GenericCall extends Struct {\n  constructor(registry, value, meta) {\n    const decoded = decodeCall(registry, value, meta);\n    try {\n      super(registry, {\n        callIndex: GenericCallIndex,\n        // eslint-disable-next-line sort-keys\n        args: Struct.with(decoded.argsDef)\n      }, decoded);\n      _defineProperty(this, \"_meta\", void 0);\n    } catch (error) {\n      let method = 'unknown.unknown';\n      try {\n        const c = registry.findMetaCall(decoded.callIndex);\n        method = \"\".concat(c.section, \".\").concat(c.method);\n      } catch {\n        // ignore\n      }\n      throw new Error(\"Call: failed decoding \".concat(method, \":: \").concat(error.message));\n    }\n    this._meta = decoded.meta;\n  }\n  /**\n   * @description The arguments for the function call\n   */\n  get args() {\n    return [...this.getT('args').values()];\n  }\n  /**\n   * @description The argument definitions\n   */\n  get argsDef() {\n    return getArgsDef(this.registry, this.meta);\n  }\n  /**\n   * @description The argument entries\n   */\n  get argsEntries() {\n    return [...this.getT('args').entries()];\n  }\n  /**\n   * @description The encoded `[sectionIndex, methodIndex]` identifier\n   */\n  get callIndex() {\n    return this.getT('callIndex').toU8a();\n  }\n  /**\n   * @description The encoded data\n   */\n  get data() {\n    return this.getT('args').toU8a();\n  }\n  /**\n   * @description The [[FunctionMetadata]]\n   */\n  get meta() {\n    return this._meta;\n  }\n  /**\n   * @description Returns the name of the method\n   */\n  get method() {\n    return this.registry.findMetaCall(this.callIndex).method;\n  }\n  /**\n   * @description Returns the module containing the method\n   */\n  get section() {\n    return this.registry.findMetaCall(this.callIndex).section;\n  }\n  /**\n   * @description Checks if the source matches this in type\n   */\n  is(other) {\n    return other.callIndex[0] === this.callIndex[0] && other.callIndex[1] === this.callIndex[1];\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExpanded, disableAscii) {\n    var _call, _call2;\n    let call;\n    try {\n      call = this.registry.findMetaCall(this.callIndex);\n    } catch {\n      // swallow\n    }\n    return objectSpread({\n      args: this.argsEntries.reduce((args, _ref2) => {\n        let [n, a] = _ref2;\n        return objectSpread(args, {\n          [n]: a.toHuman(isExpanded, disableAscii)\n        });\n      }, {}),\n      method: (_call = call) === null || _call === void 0 ? void 0 : _call.method,\n      section: (_call2 = call) === null || _call2 === void 0 ? void 0 : _call2.section\n    }, isExpanded && call ? {\n      docs: call.meta.docs.map(d => d.toString())\n    } : null);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'Call';\n  }\n}","map":{"version":3,"names":["Struct","U8aFixed","isHex","isObject","isU8a","objectSpread","u8aToU8a","getArgsDef","registry","meta","fields","reduce","result","_ref","index","name","type","unwrapOr","concat","toString","createLookupType","decodeCallViaObject","value","_meta","args","callIndex","lookupIndex","GenericCallIndex","toU8a","findMetaCall","argsDef","decodeCallViaU8a","firstCallIndex","slice","set","subarray","decodeCall","arguments","length","undefined","Uint8Array","Error","constructor","toPrimitive","toHex","GenericCall","decoded","with","_defineProperty","error","method","c","section","message","getT","values","argsEntries","entries","data","is","other","toHuman","isExpanded","disableAscii","_call","_call2","call","_ref2","n","a","docs","map","d","toRawType"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/generic/Call.js"],"sourcesContent":["import { Struct, U8aFixed } from '@polkadot/types-codec';\nimport { isHex, isObject, isU8a, objectSpread, u8aToU8a } from '@polkadot/util';\n/**\n * Get a mapping of `argument name -> argument type` for the function, from\n * its metadata.\n *\n * @param meta - The function metadata used to get the definition.\n * @internal\n */\nfunction getArgsDef(registry, meta) {\n    return meta.fields.reduce((result, { name, type }, index) => {\n        result[name.unwrapOr(`param${index}`).toString()] = registry.createLookupType(type);\n        return result;\n    }, {});\n}\n/** @internal */\nfunction decodeCallViaObject(registry, value, _meta) {\n    // we only pass args/methodsIndex out\n    const { args, callIndex } = value;\n    // Get the correct lookupIndex\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const lookupIndex = callIndex instanceof GenericCallIndex\n        ? callIndex.toU8a()\n        : callIndex;\n    // Find metadata with callIndex\n    const meta = _meta || registry.findMetaCall(lookupIndex).meta;\n    return {\n        args,\n        argsDef: getArgsDef(registry, meta),\n        callIndex,\n        meta\n    };\n}\n/** @internal */\nfunction decodeCallViaU8a(registry, value, _meta) {\n    // We need 2 bytes for the callIndex\n    const callIndex = registry.firstCallIndex.slice();\n    callIndex.set(value.subarray(0, 2), 0);\n    // Find metadata with callIndex\n    const meta = _meta || registry.findMetaCall(callIndex).meta;\n    return {\n        args: value.subarray(2),\n        argsDef: getArgsDef(registry, meta),\n        callIndex,\n        meta\n    };\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param value - Value to decode, one of:\n * - hex\n * - Uint8Array\n * - {@see DecodeMethodInput}\n * @param _meta - Metadata to use, so that `injectMethods` lookup is not\n * necessary.\n * @internal\n */\nfunction decodeCall(registry, value = new Uint8Array(), _meta) {\n    if (isU8a(value) || isHex(value)) {\n        return decodeCallViaU8a(registry, u8aToU8a(value), _meta);\n    }\n    else if (isObject(value) && value.callIndex && value.args) {\n        return decodeCallViaObject(registry, value, _meta);\n    }\n    throw new Error(`Call: Cannot decode value '${value}' of type ${typeof value}`);\n}\n/**\n * @name GenericCallIndex\n * @description\n * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method\n */\nexport class GenericCallIndex extends U8aFixed {\n    constructor(registry, value) {\n        super(registry, value, 16);\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive() {\n        return this.toHex();\n    }\n}\n/**\n * @name GenericCall\n * @description\n * Extrinsic function descriptor\n */\nexport class GenericCall extends Struct {\n    _meta;\n    constructor(registry, value, meta) {\n        const decoded = decodeCall(registry, value, meta);\n        try {\n            super(registry, {\n                callIndex: GenericCallIndex,\n                // eslint-disable-next-line sort-keys\n                args: Struct.with(decoded.argsDef)\n            }, decoded);\n        }\n        catch (error) {\n            let method = 'unknown.unknown';\n            try {\n                const c = registry.findMetaCall(decoded.callIndex);\n                method = `${c.section}.${c.method}`;\n            }\n            catch {\n                // ignore\n            }\n            throw new Error(`Call: failed decoding ${method}:: ${error.message}`);\n        }\n        this._meta = decoded.meta;\n    }\n    /**\n     * @description The arguments for the function call\n     */\n    get args() {\n        return [...this.getT('args').values()];\n    }\n    /**\n     * @description The argument definitions\n     */\n    get argsDef() {\n        return getArgsDef(this.registry, this.meta);\n    }\n    /**\n     * @description The argument entries\n     */\n    get argsEntries() {\n        return [...this.getT('args').entries()];\n    }\n    /**\n     * @description The encoded `[sectionIndex, methodIndex]` identifier\n     */\n    get callIndex() {\n        return this.getT('callIndex').toU8a();\n    }\n    /**\n     * @description The encoded data\n     */\n    get data() {\n        return this.getT('args').toU8a();\n    }\n    /**\n     * @description The [[FunctionMetadata]]\n     */\n    get meta() {\n        return this._meta;\n    }\n    /**\n     * @description Returns the name of the method\n     */\n    get method() {\n        return this.registry.findMetaCall(this.callIndex).method;\n    }\n    /**\n     * @description Returns the module containing the method\n     */\n    get section() {\n        return this.registry.findMetaCall(this.callIndex).section;\n    }\n    /**\n     * @description Checks if the source matches this in type\n     */\n    is(other) {\n        return other.callIndex[0] === this.callIndex[0] && other.callIndex[1] === this.callIndex[1];\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExpanded, disableAscii) {\n        let call;\n        try {\n            call = this.registry.findMetaCall(this.callIndex);\n        }\n        catch {\n            // swallow\n        }\n        return objectSpread({\n            args: this.argsEntries.reduce((args, [n, a]) => objectSpread(args, { [n]: a.toHuman(isExpanded, disableAscii) }), {}),\n            method: call?.method,\n            section: call?.section\n        }, isExpanded && call\n            ? { docs: call.meta.docs.map((d) => d.toString()) }\n            : null);\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'Call';\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}