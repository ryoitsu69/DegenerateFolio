{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NO_IL = exports.NO = exports.MemoryStream = exports.Stream = void 0;\nvar ponyfill_1 = require(\"symbol-observable/ponyfill\");\nvar globalthis_1 = require(\"globalthis\");\nvar $$observable = ponyfill_1.default(globalthis_1.getPolyfill());\nvar NO = {};\nexports.NO = NO;\nfunction noop() {}\nfunction cp(a) {\n  var l = a.length;\n  var b = Array(l);\n  for (var i = 0; i < l; ++i) b[i] = a[i];\n  return b;\n}\nfunction and(f1, f2) {\n  return function andFn(t) {\n    return f1(t) && f2(t);\n  };\n}\nfunction _try(c, t, u) {\n  try {\n    return c.f(t);\n  } catch (e) {\n    u._e(e);\n    return NO;\n  }\n}\nvar NO_IL = {\n  _n: noop,\n  _e: noop,\n  _c: noop\n};\nexports.NO_IL = NO_IL;\n// mutates the input\nfunction internalizeProducer(producer) {\n  producer._start = function _start(il) {\n    il.next = il._n;\n    il.error = il._e;\n    il.complete = il._c;\n    this.start(il);\n  };\n  producer._stop = producer.stop;\n}\nvar StreamSub = /** @class */function () {\n  function StreamSub(_stream, _listener) {\n    this._stream = _stream;\n    this._listener = _listener;\n  }\n  StreamSub.prototype.unsubscribe = function () {\n    this._stream._remove(this._listener);\n  };\n  return StreamSub;\n}();\nvar Observer = /** @class */function () {\n  function Observer(_listener) {\n    this._listener = _listener;\n  }\n  Observer.prototype.next = function (value) {\n    this._listener._n(value);\n  };\n  Observer.prototype.error = function (err) {\n    this._listener._e(err);\n  };\n  Observer.prototype.complete = function () {\n    this._listener._c();\n  };\n  return Observer;\n}();\nvar FromObservable = /** @class */function () {\n  function FromObservable(observable) {\n    this.type = 'fromObservable';\n    this.ins = observable;\n    this.active = false;\n  }\n  FromObservable.prototype._start = function (out) {\n    this.out = out;\n    this.active = true;\n    this._sub = this.ins.subscribe(new Observer(out));\n    if (!this.active) this._sub.unsubscribe();\n  };\n  FromObservable.prototype._stop = function () {\n    if (this._sub) this._sub.unsubscribe();\n    this.active = false;\n  };\n  return FromObservable;\n}();\nvar Merge = /** @class */function () {\n  function Merge(insArr) {\n    this.type = 'merge';\n    this.insArr = insArr;\n    this.out = NO;\n    this.ac = 0;\n  }\n  Merge.prototype._start = function (out) {\n    this.out = out;\n    var s = this.insArr;\n    var L = s.length;\n    this.ac = L;\n    for (var i = 0; i < L; i++) s[i]._add(this);\n  };\n  Merge.prototype._stop = function () {\n    var s = this.insArr;\n    var L = s.length;\n    for (var i = 0; i < L; i++) s[i]._remove(this);\n    this.out = NO;\n  };\n  Merge.prototype._n = function (t) {\n    var u = this.out;\n    if (u === NO) return;\n    u._n(t);\n  };\n  Merge.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  };\n  Merge.prototype._c = function () {\n    if (--this.ac <= 0) {\n      var u = this.out;\n      if (u === NO) return;\n      u._c();\n    }\n  };\n  return Merge;\n}();\nvar CombineListener = /** @class */function () {\n  function CombineListener(i, out, p) {\n    this.i = i;\n    this.out = out;\n    this.p = p;\n    p.ils.push(this);\n  }\n  CombineListener.prototype._n = function (t) {\n    var p = this.p,\n      out = this.out;\n    if (out === NO) return;\n    if (p.up(t, this.i)) {\n      var b = cp(p.vals);\n      out._n(b);\n    }\n  };\n  CombineListener.prototype._e = function (err) {\n    var out = this.out;\n    if (out === NO) return;\n    out._e(err);\n  };\n  CombineListener.prototype._c = function () {\n    var p = this.p;\n    if (p.out === NO) return;\n    if (--p.Nc === 0) p.out._c();\n  };\n  return CombineListener;\n}();\nvar Combine = /** @class */function () {\n  function Combine(insArr) {\n    this.type = 'combine';\n    this.insArr = insArr;\n    this.out = NO;\n    this.ils = [];\n    this.Nc = this.Nn = 0;\n    this.vals = [];\n  }\n  Combine.prototype.up = function (t, i) {\n    var v = this.vals[i];\n    var Nn = !this.Nn ? 0 : v === NO ? --this.Nn : this.Nn;\n    this.vals[i] = t;\n    return Nn === 0;\n  };\n  Combine.prototype._start = function (out) {\n    this.out = out;\n    var s = this.insArr;\n    var n = this.Nc = this.Nn = s.length;\n    var vals = this.vals = new Array(n);\n    if (n === 0) {\n      out._n([]);\n      out._c();\n    } else {\n      for (var i = 0; i < n; i++) {\n        vals[i] = NO;\n        s[i]._add(new CombineListener(i, out, this));\n      }\n    }\n  };\n  Combine.prototype._stop = function () {\n    var s = this.insArr;\n    var n = s.length;\n    var ils = this.ils;\n    for (var i = 0; i < n; i++) s[i]._remove(ils[i]);\n    this.out = NO;\n    this.ils = [];\n    this.vals = [];\n  };\n  return Combine;\n}();\nvar FromArray = /** @class */function () {\n  function FromArray(a) {\n    this.type = 'fromArray';\n    this.a = a;\n  }\n  FromArray.prototype._start = function (out) {\n    var a = this.a;\n    for (var i = 0, n = a.length; i < n; i++) out._n(a[i]);\n    out._c();\n  };\n  FromArray.prototype._stop = function () {};\n  return FromArray;\n}();\nvar FromPromise = /** @class */function () {\n  function FromPromise(p) {\n    this.type = 'fromPromise';\n    this.on = false;\n    this.p = p;\n  }\n  FromPromise.prototype._start = function (out) {\n    var prod = this;\n    this.on = true;\n    this.p.then(function (v) {\n      if (prod.on) {\n        out._n(v);\n        out._c();\n      }\n    }, function (e) {\n      out._e(e);\n    }).then(noop, function (err) {\n      setTimeout(function () {\n        throw err;\n      });\n    });\n  };\n  FromPromise.prototype._stop = function () {\n    this.on = false;\n  };\n  return FromPromise;\n}();\nvar Periodic = /** @class */function () {\n  function Periodic(period) {\n    this.type = 'periodic';\n    this.period = period;\n    this.intervalID = -1;\n    this.i = 0;\n  }\n  Periodic.prototype._start = function (out) {\n    var self = this;\n    function intervalHandler() {\n      out._n(self.i++);\n    }\n    this.intervalID = setInterval(intervalHandler, this.period);\n  };\n  Periodic.prototype._stop = function () {\n    if (this.intervalID !== -1) clearInterval(this.intervalID);\n    this.intervalID = -1;\n    this.i = 0;\n  };\n  return Periodic;\n}();\nvar Debug = /** @class */function () {\n  function Debug(ins, arg) {\n    this.type = 'debug';\n    this.ins = ins;\n    this.out = NO;\n    this.s = noop;\n    this.l = '';\n    if (typeof arg === 'string') this.l = arg;else if (typeof arg === 'function') this.s = arg;\n  }\n  Debug.prototype._start = function (out) {\n    this.out = out;\n    this.ins._add(this);\n  };\n  Debug.prototype._stop = function () {\n    this.ins._remove(this);\n    this.out = NO;\n  };\n  Debug.prototype._n = function (t) {\n    var u = this.out;\n    if (u === NO) return;\n    var s = this.s,\n      l = this.l;\n    if (s !== noop) {\n      try {\n        s(t);\n      } catch (e) {\n        u._e(e);\n      }\n    } else if (l) console.log(l + ':', t);else console.log(t);\n    u._n(t);\n  };\n  Debug.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  };\n  Debug.prototype._c = function () {\n    var u = this.out;\n    if (u === NO) return;\n    u._c();\n  };\n  return Debug;\n}();\nvar Drop = /** @class */function () {\n  function Drop(max, ins) {\n    this.type = 'drop';\n    this.ins = ins;\n    this.out = NO;\n    this.max = max;\n    this.dropped = 0;\n  }\n  Drop.prototype._start = function (out) {\n    this.out = out;\n    this.dropped = 0;\n    this.ins._add(this);\n  };\n  Drop.prototype._stop = function () {\n    this.ins._remove(this);\n    this.out = NO;\n  };\n  Drop.prototype._n = function (t) {\n    var u = this.out;\n    if (u === NO) return;\n    if (this.dropped++ >= this.max) u._n(t);\n  };\n  Drop.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  };\n  Drop.prototype._c = function () {\n    var u = this.out;\n    if (u === NO) return;\n    u._c();\n  };\n  return Drop;\n}();\nvar EndWhenListener = /** @class */function () {\n  function EndWhenListener(out, op) {\n    this.out = out;\n    this.op = op;\n  }\n  EndWhenListener.prototype._n = function () {\n    this.op.end();\n  };\n  EndWhenListener.prototype._e = function (err) {\n    this.out._e(err);\n  };\n  EndWhenListener.prototype._c = function () {\n    this.op.end();\n  };\n  return EndWhenListener;\n}();\nvar EndWhen = /** @class */function () {\n  function EndWhen(o, ins) {\n    this.type = 'endWhen';\n    this.ins = ins;\n    this.out = NO;\n    this.o = o;\n    this.oil = NO_IL;\n  }\n  EndWhen.prototype._start = function (out) {\n    this.out = out;\n    this.o._add(this.oil = new EndWhenListener(out, this));\n    this.ins._add(this);\n  };\n  EndWhen.prototype._stop = function () {\n    this.ins._remove(this);\n    this.o._remove(this.oil);\n    this.out = NO;\n    this.oil = NO_IL;\n  };\n  EndWhen.prototype.end = function () {\n    var u = this.out;\n    if (u === NO) return;\n    u._c();\n  };\n  EndWhen.prototype._n = function (t) {\n    var u = this.out;\n    if (u === NO) return;\n    u._n(t);\n  };\n  EndWhen.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  };\n  EndWhen.prototype._c = function () {\n    this.end();\n  };\n  return EndWhen;\n}();\nvar Filter = /** @class */function () {\n  function Filter(passes, ins) {\n    this.type = 'filter';\n    this.ins = ins;\n    this.out = NO;\n    this.f = passes;\n  }\n  Filter.prototype._start = function (out) {\n    this.out = out;\n    this.ins._add(this);\n  };\n  Filter.prototype._stop = function () {\n    this.ins._remove(this);\n    this.out = NO;\n  };\n  Filter.prototype._n = function (t) {\n    var u = this.out;\n    if (u === NO) return;\n    var r = _try(this, t, u);\n    if (r === NO || !r) return;\n    u._n(t);\n  };\n  Filter.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  };\n  Filter.prototype._c = function () {\n    var u = this.out;\n    if (u === NO) return;\n    u._c();\n  };\n  return Filter;\n}();\nvar FlattenListener = /** @class */function () {\n  function FlattenListener(out, op) {\n    this.out = out;\n    this.op = op;\n  }\n  FlattenListener.prototype._n = function (t) {\n    this.out._n(t);\n  };\n  FlattenListener.prototype._e = function (err) {\n    this.out._e(err);\n  };\n  FlattenListener.prototype._c = function () {\n    this.op.inner = NO;\n    this.op.less();\n  };\n  return FlattenListener;\n}();\nvar Flatten = /** @class */function () {\n  function Flatten(ins) {\n    this.type = 'flatten';\n    this.ins = ins;\n    this.out = NO;\n    this.open = true;\n    this.inner = NO;\n    this.il = NO_IL;\n  }\n  Flatten.prototype._start = function (out) {\n    this.out = out;\n    this.open = true;\n    this.inner = NO;\n    this.il = NO_IL;\n    this.ins._add(this);\n  };\n  Flatten.prototype._stop = function () {\n    this.ins._remove(this);\n    if (this.inner !== NO) this.inner._remove(this.il);\n    this.out = NO;\n    this.open = true;\n    this.inner = NO;\n    this.il = NO_IL;\n  };\n  Flatten.prototype.less = function () {\n    var u = this.out;\n    if (u === NO) return;\n    if (!this.open && this.inner === NO) u._c();\n  };\n  Flatten.prototype._n = function (s) {\n    var u = this.out;\n    if (u === NO) return;\n    var _a = this,\n      inner = _a.inner,\n      il = _a.il;\n    if (inner !== NO && il !== NO_IL) inner._remove(il);\n    (this.inner = s)._add(this.il = new FlattenListener(u, this));\n  };\n  Flatten.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  };\n  Flatten.prototype._c = function () {\n    this.open = false;\n    this.less();\n  };\n  return Flatten;\n}();\nvar Fold = /** @class */function () {\n  function Fold(f, seed, ins) {\n    var _this = this;\n    this.type = 'fold';\n    this.ins = ins;\n    this.out = NO;\n    this.f = function (t) {\n      return f(_this.acc, t);\n    };\n    this.acc = this.seed = seed;\n  }\n  Fold.prototype._start = function (out) {\n    this.out = out;\n    this.acc = this.seed;\n    out._n(this.acc);\n    this.ins._add(this);\n  };\n  Fold.prototype._stop = function () {\n    this.ins._remove(this);\n    this.out = NO;\n    this.acc = this.seed;\n  };\n  Fold.prototype._n = function (t) {\n    var u = this.out;\n    if (u === NO) return;\n    var r = _try(this, t, u);\n    if (r === NO) return;\n    u._n(this.acc = r);\n  };\n  Fold.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  };\n  Fold.prototype._c = function () {\n    var u = this.out;\n    if (u === NO) return;\n    u._c();\n  };\n  return Fold;\n}();\nvar Last = /** @class */function () {\n  function Last(ins) {\n    this.type = 'last';\n    this.ins = ins;\n    this.out = NO;\n    this.has = false;\n    this.val = NO;\n  }\n  Last.prototype._start = function (out) {\n    this.out = out;\n    this.has = false;\n    this.ins._add(this);\n  };\n  Last.prototype._stop = function () {\n    this.ins._remove(this);\n    this.out = NO;\n    this.val = NO;\n  };\n  Last.prototype._n = function (t) {\n    this.has = true;\n    this.val = t;\n  };\n  Last.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  };\n  Last.prototype._c = function () {\n    var u = this.out;\n    if (u === NO) return;\n    if (this.has) {\n      u._n(this.val);\n      u._c();\n    } else u._e(new Error('last() failed because input stream completed'));\n  };\n  return Last;\n}();\nvar MapOp = /** @class */function () {\n  function MapOp(project, ins) {\n    this.type = 'map';\n    this.ins = ins;\n    this.out = NO;\n    this.f = project;\n  }\n  MapOp.prototype._start = function (out) {\n    this.out = out;\n    this.ins._add(this);\n  };\n  MapOp.prototype._stop = function () {\n    this.ins._remove(this);\n    this.out = NO;\n  };\n  MapOp.prototype._n = function (t) {\n    var u = this.out;\n    if (u === NO) return;\n    var r = _try(this, t, u);\n    if (r === NO) return;\n    u._n(r);\n  };\n  MapOp.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  };\n  MapOp.prototype._c = function () {\n    var u = this.out;\n    if (u === NO) return;\n    u._c();\n  };\n  return MapOp;\n}();\nvar Remember = /** @class */function () {\n  function Remember(ins) {\n    this.type = 'remember';\n    this.ins = ins;\n    this.out = NO;\n  }\n  Remember.prototype._start = function (out) {\n    this.out = out;\n    this.ins._add(out);\n  };\n  Remember.prototype._stop = function () {\n    this.ins._remove(this.out);\n    this.out = NO;\n  };\n  return Remember;\n}();\nvar ReplaceError = /** @class */function () {\n  function ReplaceError(replacer, ins) {\n    this.type = 'replaceError';\n    this.ins = ins;\n    this.out = NO;\n    this.f = replacer;\n  }\n  ReplaceError.prototype._start = function (out) {\n    this.out = out;\n    this.ins._add(this);\n  };\n  ReplaceError.prototype._stop = function () {\n    this.ins._remove(this);\n    this.out = NO;\n  };\n  ReplaceError.prototype._n = function (t) {\n    var u = this.out;\n    if (u === NO) return;\n    u._n(t);\n  };\n  ReplaceError.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n    try {\n      this.ins._remove(this);\n      (this.ins = this.f(err))._add(this);\n    } catch (e) {\n      u._e(e);\n    }\n  };\n  ReplaceError.prototype._c = function () {\n    var u = this.out;\n    if (u === NO) return;\n    u._c();\n  };\n  return ReplaceError;\n}();\nvar StartWith = /** @class */function () {\n  function StartWith(ins, val) {\n    this.type = 'startWith';\n    this.ins = ins;\n    this.out = NO;\n    this.val = val;\n  }\n  StartWith.prototype._start = function (out) {\n    this.out = out;\n    this.out._n(this.val);\n    this.ins._add(out);\n  };\n  StartWith.prototype._stop = function () {\n    this.ins._remove(this.out);\n    this.out = NO;\n  };\n  return StartWith;\n}();\nvar Take = /** @class */function () {\n  function Take(max, ins) {\n    this.type = 'take';\n    this.ins = ins;\n    this.out = NO;\n    this.max = max;\n    this.taken = 0;\n  }\n  Take.prototype._start = function (out) {\n    this.out = out;\n    this.taken = 0;\n    if (this.max <= 0) out._c();else this.ins._add(this);\n  };\n  Take.prototype._stop = function () {\n    this.ins._remove(this);\n    this.out = NO;\n  };\n  Take.prototype._n = function (t) {\n    var u = this.out;\n    if (u === NO) return;\n    var m = ++this.taken;\n    if (m < this.max) u._n(t);else if (m === this.max) {\n      u._n(t);\n      u._c();\n    }\n  };\n  Take.prototype._e = function (err) {\n    var u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  };\n  Take.prototype._c = function () {\n    var u = this.out;\n    if (u === NO) return;\n    u._c();\n  };\n  return Take;\n}();\nvar Stream = /** @class */function () {\n  function Stream(producer) {\n    this._prod = producer || NO;\n    this._ils = [];\n    this._stopID = NO;\n    this._dl = NO;\n    this._d = false;\n    this._target = null;\n    this._err = NO;\n  }\n  Stream.prototype._n = function (t) {\n    var a = this._ils;\n    var L = a.length;\n    if (this._d) this._dl._n(t);\n    if (L == 1) a[0]._n(t);else if (L == 0) return;else {\n      var b = cp(a);\n      for (var i = 0; i < L; i++) b[i]._n(t);\n    }\n  };\n  Stream.prototype._e = function (err) {\n    if (this._err !== NO) return;\n    this._err = err;\n    var a = this._ils;\n    var L = a.length;\n    this._x();\n    if (this._d) this._dl._e(err);\n    if (L == 1) a[0]._e(err);else if (L == 0) return;else {\n      var b = cp(a);\n      for (var i = 0; i < L; i++) b[i]._e(err);\n    }\n    if (!this._d && L == 0) throw this._err;\n  };\n  Stream.prototype._c = function () {\n    var a = this._ils;\n    var L = a.length;\n    this._x();\n    if (this._d) this._dl._c();\n    if (L == 1) a[0]._c();else if (L == 0) return;else {\n      var b = cp(a);\n      for (var i = 0; i < L; i++) b[i]._c();\n    }\n  };\n  Stream.prototype._x = function () {\n    if (this._ils.length === 0) return;\n    if (this._prod !== NO) this._prod._stop();\n    this._err = NO;\n    this._ils = [];\n  };\n  Stream.prototype._stopNow = function () {\n    // WARNING: code that calls this method should\n    // first check if this._prod is valid (not `NO`)\n    this._prod._stop();\n    this._err = NO;\n    this._stopID = NO;\n  };\n  Stream.prototype._add = function (il) {\n    var ta = this._target;\n    if (ta) return ta._add(il);\n    var a = this._ils;\n    a.push(il);\n    if (a.length > 1) return;\n    if (this._stopID !== NO) {\n      clearTimeout(this._stopID);\n      this._stopID = NO;\n    } else {\n      var p = this._prod;\n      if (p !== NO) p._start(this);\n    }\n  };\n  Stream.prototype._remove = function (il) {\n    var _this = this;\n    var ta = this._target;\n    if (ta) return ta._remove(il);\n    var a = this._ils;\n    var i = a.indexOf(il);\n    if (i > -1) {\n      a.splice(i, 1);\n      if (this._prod !== NO && a.length <= 0) {\n        this._err = NO;\n        this._stopID = setTimeout(function () {\n          return _this._stopNow();\n        });\n      } else if (a.length === 1) {\n        this._pruneCycles();\n      }\n    }\n  };\n  // If all paths stemming from `this` stream eventually end at `this`\n  // stream, then we remove the single listener of `this` stream, to\n  // force it to end its execution and dispose resources. This method\n  // assumes as a precondition that this._ils has just one listener.\n  Stream.prototype._pruneCycles = function () {\n    if (this._hasNoSinks(this, [])) this._remove(this._ils[0]);\n  };\n  // Checks whether *there is no* path starting from `x` that leads to an end\n  // listener (sink) in the stream graph, following edges A->B where B is a\n  // listener of A. This means these paths constitute a cycle somehow. Is given\n  // a trace of all visited nodes so far.\n  Stream.prototype._hasNoSinks = function (x, trace) {\n    if (trace.indexOf(x) !== -1) return true;else if (x.out === this) return true;else if (x.out && x.out !== NO) return this._hasNoSinks(x.out, trace.concat(x));else if (x._ils) {\n      for (var i = 0, N = x._ils.length; i < N; i++) if (!this._hasNoSinks(x._ils[i], trace.concat(x))) return false;\n      return true;\n    } else return false;\n  };\n  Stream.prototype.ctor = function () {\n    return this instanceof MemoryStream ? MemoryStream : Stream;\n  };\n  /**\n   * Adds a Listener to the Stream.\n   *\n   * @param {Listener} listener\n   */\n  Stream.prototype.addListener = function (listener) {\n    listener._n = listener.next || noop;\n    listener._e = listener.error || noop;\n    listener._c = listener.complete || noop;\n    this._add(listener);\n  };\n  /**\n   * Removes a Listener from the Stream, assuming the Listener was added to it.\n   *\n   * @param {Listener<T>} listener\n   */\n  Stream.prototype.removeListener = function (listener) {\n    this._remove(listener);\n  };\n  /**\n   * Adds a Listener to the Stream returning a Subscription to remove that\n   * listener.\n   *\n   * @param {Listener} listener\n   * @returns {Subscription}\n   */\n  Stream.prototype.subscribe = function (listener) {\n    this.addListener(listener);\n    return new StreamSub(this, listener);\n  };\n  /**\n   * Add interop between most.js and RxJS 5\n   *\n   * @returns {Stream}\n   */\n  Stream.prototype[$$observable] = function () {\n    return this;\n  };\n  /**\n   * Creates a new Stream given a Producer.\n   *\n   * @factory true\n   * @param {Producer} producer An optional Producer that dictates how to\n   * start, generate events, and stop the Stream.\n   * @return {Stream}\n   */\n  Stream.create = function (producer) {\n    if (producer) {\n      if (typeof producer.start !== 'function' || typeof producer.stop !== 'function') throw new Error('producer requires both start and stop functions');\n      internalizeProducer(producer); // mutates the input\n    }\n    return new Stream(producer);\n  };\n  /**\n   * Creates a new MemoryStream given a Producer.\n   *\n   * @factory true\n   * @param {Producer} producer An optional Producer that dictates how to\n   * start, generate events, and stop the Stream.\n   * @return {MemoryStream}\n   */\n  Stream.createWithMemory = function (producer) {\n    if (producer) internalizeProducer(producer); // mutates the input\n    return new MemoryStream(producer);\n  };\n  /**\n   * Creates a Stream that does nothing when started. It never emits any event.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   *          never\n   * -----------------------\n   * ```\n   *\n   * @factory true\n   * @return {Stream}\n   */\n  Stream.never = function () {\n    return new Stream({\n      _start: noop,\n      _stop: noop\n    });\n  };\n  /**\n   * Creates a Stream that immediately emits the \"complete\" notification when\n   * started, and that's it.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * empty\n   * -|\n   * ```\n   *\n   * @factory true\n   * @return {Stream}\n   */\n  Stream.empty = function () {\n    return new Stream({\n      _start: function (il) {\n        il._c();\n      },\n      _stop: noop\n    });\n  };\n  /**\n   * Creates a Stream that immediately emits an \"error\" notification with the\n   * value you passed as the `error` argument when the stream starts, and that's\n   * it.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * throw(X)\n   * -X\n   * ```\n   *\n   * @factory true\n   * @param error The error event to emit on the created stream.\n   * @return {Stream}\n   */\n  Stream.throw = function (error) {\n    return new Stream({\n      _start: function (il) {\n        il._e(error);\n      },\n      _stop: noop\n    });\n  };\n  /**\n   * Creates a stream from an Array, Promise, or an Observable.\n   *\n   * @factory true\n   * @param {Array|PromiseLike|Observable} input The input to make a stream from.\n   * @return {Stream}\n   */\n  Stream.from = function (input) {\n    if (typeof input[$$observable] === 'function') return Stream.fromObservable(input);else if (typeof input.then === 'function') return Stream.fromPromise(input);else if (Array.isArray(input)) return Stream.fromArray(input);\n    throw new TypeError(\"Type of input to from() must be an Array, Promise, or Observable\");\n  };\n  /**\n   * Creates a Stream that immediately emits the arguments that you give to\n   * *of*, then completes.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * of(1,2,3)\n   * 123|\n   * ```\n   *\n   * @factory true\n   * @param a The first value you want to emit as an event on the stream.\n   * @param b The second value you want to emit as an event on the stream. One\n   * or more of these values may be given as arguments.\n   * @return {Stream}\n   */\n  Stream.of = function () {\n    var items = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      items[_i] = arguments[_i];\n    }\n    return Stream.fromArray(items);\n  };\n  /**\n   * Converts an array to a stream. The returned stream will emit synchronously\n   * all the items in the array, and then complete.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * fromArray([1,2,3])\n   * 123|\n   * ```\n   *\n   * @factory true\n   * @param {Array} array The array to be converted as a stream.\n   * @return {Stream}\n   */\n  Stream.fromArray = function (array) {\n    return new Stream(new FromArray(array));\n  };\n  /**\n   * Converts a promise to a stream. The returned stream will emit the resolved\n   * value of the promise, and then complete. However, if the promise is\n   * rejected, the stream will emit the corresponding error.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * fromPromise( ----42 )\n   * -----------------42|\n   * ```\n   *\n   * @factory true\n   * @param {PromiseLike} promise The promise to be converted as a stream.\n   * @return {Stream}\n   */\n  Stream.fromPromise = function (promise) {\n    return new Stream(new FromPromise(promise));\n  };\n  /**\n   * Converts an Observable into a Stream.\n   *\n   * @factory true\n   * @param {any} observable The observable to be converted as a stream.\n   * @return {Stream}\n   */\n  Stream.fromObservable = function (obs) {\n    if (obs.endWhen !== undefined) return obs;\n    var o = typeof obs[$$observable] === 'function' ? obs[$$observable]() : obs;\n    return new Stream(new FromObservable(o));\n  };\n  /**\n   * Creates a stream that periodically emits incremental numbers, every\n   * `period` milliseconds.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   *     periodic(1000)\n   * ---0---1---2---3---4---...\n   * ```\n   *\n   * @factory true\n   * @param {number} period The interval in milliseconds to use as a rate of\n   * emission.\n   * @return {Stream}\n   */\n  Stream.periodic = function (period) {\n    return new Stream(new Periodic(period));\n  };\n  Stream.prototype._map = function (project) {\n    return new (this.ctor())(new MapOp(project, this));\n  };\n  /**\n   * Transforms each event from the input Stream through a `project` function,\n   * to get a Stream that emits those transformed events.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---3--5-----7------\n   *    map(i => i * 10)\n   * --10--30-50----70-----\n   * ```\n   *\n   * @param {Function} project A function of type `(t: T) => U` that takes event\n   * `t` of type `T` from the input Stream and produces an event of type `U`, to\n   * be emitted on the output Stream.\n   * @return {Stream}\n   */\n  Stream.prototype.map = function (project) {\n    return this._map(project);\n  };\n  /**\n   * It's like `map`, but transforms each input event to always the same\n   * constant value on the output Stream.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---3--5-----7-----\n   *       mapTo(10)\n   * --10--10-10----10----\n   * ```\n   *\n   * @param projectedValue A value to emit on the output Stream whenever the\n   * input Stream emits any value.\n   * @return {Stream}\n   */\n  Stream.prototype.mapTo = function (projectedValue) {\n    var s = this.map(function () {\n      return projectedValue;\n    });\n    var op = s._prod;\n    op.type = 'mapTo';\n    return s;\n  };\n  /**\n   * Only allows events that pass the test given by the `passes` argument.\n   *\n   * Each event from the input stream is given to the `passes` function. If the\n   * function returns `true`, the event is forwarded to the output stream,\n   * otherwise it is ignored and not forwarded.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---2--3-----4-----5---6--7-8--\n   *     filter(i => i % 2 === 0)\n   * ------2--------4---------6----8--\n   * ```\n   *\n   * @param {Function} passes A function of type `(t: T) => boolean` that takes\n   * an event from the input stream and checks if it passes, by returning a\n   * boolean.\n   * @return {Stream}\n   */\n  Stream.prototype.filter = function (passes) {\n    var p = this._prod;\n    if (p instanceof Filter) return new Stream(new Filter(and(p.f, passes), p.ins));\n    return new Stream(new Filter(passes, this));\n  };\n  /**\n   * Lets the first `amount` many events from the input stream pass to the\n   * output stream, then makes the output stream complete.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --a---b--c----d---e--\n   *    take(3)\n   * --a---b--c|\n   * ```\n   *\n   * @param {number} amount How many events to allow from the input stream\n   * before completing the output stream.\n   * @return {Stream}\n   */\n  Stream.prototype.take = function (amount) {\n    return new (this.ctor())(new Take(amount, this));\n  };\n  /**\n   * Ignores the first `amount` many events from the input stream, and then\n   * after that starts forwarding events from the input stream to the output\n   * stream.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --a---b--c----d---e--\n   *       drop(3)\n   * --------------d---e--\n   * ```\n   *\n   * @param {number} amount How many events to ignore from the input stream\n   * before forwarding all events from the input stream to the output stream.\n   * @return {Stream}\n   */\n  Stream.prototype.drop = function (amount) {\n    return new Stream(new Drop(amount, this));\n  };\n  /**\n   * When the input stream completes, the output stream will emit the last event\n   * emitted by the input stream, and then will also complete.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --a---b--c--d----|\n   *       last()\n   * -----------------d|\n   * ```\n   *\n   * @return {Stream}\n   */\n  Stream.prototype.last = function () {\n    return new Stream(new Last(this));\n  };\n  /**\n   * Prepends the given `initial` value to the sequence of events emitted by the\n   * input stream. The returned stream is a MemoryStream, which means it is\n   * already `remember()`'d.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * ---1---2-----3---\n   *   startWith(0)\n   * 0--1---2-----3---\n   * ```\n   *\n   * @param initial The value or event to prepend.\n   * @return {MemoryStream}\n   */\n  Stream.prototype.startWith = function (initial) {\n    return new MemoryStream(new StartWith(this, initial));\n  };\n  /**\n   * Uses another stream to determine when to complete the current stream.\n   *\n   * When the given `other` stream emits an event or completes, the output\n   * stream will complete. Before that happens, the output stream will behaves\n   * like the input stream.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * ---1---2-----3--4----5----6---\n   *   endWhen( --------a--b--| )\n   * ---1---2-----3--4--|\n   * ```\n   *\n   * @param other Some other stream that is used to know when should the output\n   * stream of this operator complete.\n   * @return {Stream}\n   */\n  Stream.prototype.endWhen = function (other) {\n    return new (this.ctor())(new EndWhen(other, this));\n  };\n  /**\n   * \"Folds\" the stream onto itself.\n   *\n   * Combines events from the past throughout\n   * the entire execution of the input stream, allowing you to accumulate them\n   * together. It's essentially like `Array.prototype.reduce`. The returned\n   * stream is a MemoryStream, which means it is already `remember()`'d.\n   *\n   * The output stream starts by emitting the `seed` which you give as argument.\n   * Then, when an event happens on the input stream, it is combined with that\n   * seed value through the `accumulate` function, and the output value is\n   * emitted on the output stream. `fold` remembers that output value as `acc`\n   * (\"accumulator\"), and then when a new input event `t` happens, `acc` will be\n   * combined with that to produce the new `acc` and so forth.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * ------1-----1--2----1----1------\n   *   fold((acc, x) => acc + x, 3)\n   * 3-----4-----5--7----8----9------\n   * ```\n   *\n   * @param {Function} accumulate A function of type `(acc: R, t: T) => R` that\n   * takes the previous accumulated value `acc` and the incoming event from the\n   * input stream and produces the new accumulated value.\n   * @param seed The initial accumulated value, of type `R`.\n   * @return {MemoryStream}\n   */\n  Stream.prototype.fold = function (accumulate, seed) {\n    return new MemoryStream(new Fold(accumulate, seed, this));\n  };\n  /**\n   * Replaces an error with another stream.\n   *\n   * When (and if) an error happens on the input stream, instead of forwarding\n   * that error to the output stream, *replaceError* will call the `replace`\n   * function which returns the stream that the output stream will replicate.\n   * And, in case that new stream also emits an error, `replace` will be called\n   * again to get another stream to start replicating.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---2-----3--4-----X\n   *   replaceError( () => --10--| )\n   * --1---2-----3--4--------10--|\n   * ```\n   *\n   * @param {Function} replace A function of type `(err) => Stream` that takes\n   * the error that occurred on the input stream or on the previous replacement\n   * stream and returns a new stream. The output stream will behave like the\n   * stream that this function returns.\n   * @return {Stream}\n   */\n  Stream.prototype.replaceError = function (replace) {\n    return new (this.ctor())(new ReplaceError(replace, this));\n  };\n  /**\n   * Flattens a \"stream of streams\", handling only one nested stream at a time\n   * (no concurrency).\n   *\n   * If the input stream is a stream that emits streams, then this operator will\n   * return an output stream which is a flat stream: emits regular events. The\n   * flattening happens without concurrency. It works like this: when the input\n   * stream emits a nested stream, *flatten* will start imitating that nested\n   * one. However, as soon as the next nested stream is emitted on the input\n   * stream, *flatten* will forget the previous nested one it was imitating, and\n   * will start imitating the new nested one.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --+--------+---------------\n   *   \\        \\\n   *    \\       ----1----2---3--\n   *    --a--b----c----d--------\n   *           flatten\n   * -----a--b------1----2---3--\n   * ```\n   *\n   * @return {Stream}\n   */\n  Stream.prototype.flatten = function () {\n    return new Stream(new Flatten(this));\n  };\n  /**\n   * Passes the input stream to a custom operator, to produce an output stream.\n   *\n   * *compose* is a handy way of using an existing function in a chained style.\n   * Instead of writing `outStream = f(inStream)` you can write\n   * `outStream = inStream.compose(f)`.\n   *\n   * @param {function} operator A function that takes a stream as input and\n   * returns a stream as well.\n   * @return {Stream}\n   */\n  Stream.prototype.compose = function (operator) {\n    return operator(this);\n  };\n  /**\n   * Returns an output stream that behaves like the input stream, but also\n   * remembers the most recent event that happens on the input stream, so that a\n   * newly added listener will immediately receive that memorised event.\n   *\n   * @return {MemoryStream}\n   */\n  Stream.prototype.remember = function () {\n    return new MemoryStream(new Remember(this));\n  };\n  /**\n   * Returns an output stream that identically behaves like the input stream,\n   * but also runs a `spy` function for each event, to help you debug your app.\n   *\n   * *debug* takes a `spy` function as argument, and runs that for each event\n   * happening on the input stream. If you don't provide the `spy` argument,\n   * then *debug* will just `console.log` each event. This helps you to\n   * understand the flow of events through some operator chain.\n   *\n   * Please note that if the output stream has no listeners, then it will not\n   * start, which means `spy` will never run because no actual event happens in\n   * that case.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1----2-----3-----4--\n   *         debug\n   * --1----2-----3-----4--\n   * ```\n   *\n   * @param {function} labelOrSpy A string to use as the label when printing\n   * debug information on the console, or a 'spy' function that takes an event\n   * as argument, and does not need to return anything.\n   * @return {Stream}\n   */\n  Stream.prototype.debug = function (labelOrSpy) {\n    return new (this.ctor())(new Debug(this, labelOrSpy));\n  };\n  /**\n   * *imitate* changes this current Stream to emit the same events that the\n   * `other` given Stream does. This method returns nothing.\n   *\n   * This method exists to allow one thing: **circular dependency of streams**.\n   * For instance, let's imagine that for some reason you need to create a\n   * circular dependency where stream `first$` depends on stream `second$`\n   * which in turn depends on `first$`:\n   *\n   * <!-- skip-example -->\n   * ```js\n   * import delay from 'xstream/extra/delay'\n   *\n   * var first$ = second$.map(x => x * 10).take(3);\n   * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));\n   * ```\n   *\n   * However, that is invalid JavaScript, because `second$` is undefined\n   * on the first line. This is how *imitate* can help solve it:\n   *\n   * ```js\n   * import delay from 'xstream/extra/delay'\n   *\n   * var secondProxy$ = xs.create();\n   * var first$ = secondProxy$.map(x => x * 10).take(3);\n   * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));\n   * secondProxy$.imitate(second$);\n   * ```\n   *\n   * We create `secondProxy$` before the others, so it can be used in the\n   * declaration of `first$`. Then, after both `first$` and `second$` are\n   * defined, we hook `secondProxy$` with `second$` with `imitate()` to tell\n   * that they are \"the same\". `imitate` will not trigger the start of any\n   * stream, it just binds `secondProxy$` and `second$` together.\n   *\n   * The following is an example where `imitate()` is important in Cycle.js\n   * applications. A parent component contains some child components. A child\n   * has an action stream which is given to the parent to define its state:\n   *\n   * <!-- skip-example -->\n   * ```js\n   * const childActionProxy$ = xs.create();\n   * const parent = Parent({...sources, childAction$: childActionProxy$});\n   * const childAction$ = parent.state$.map(s => s.child.action$).flatten();\n   * childActionProxy$.imitate(childAction$);\n   * ```\n   *\n   * Note, though, that **`imitate()` does not support MemoryStreams**. If we\n   * would attempt to imitate a MemoryStream in a circular dependency, we would\n   * either get a race condition (where the symptom would be \"nothing happens\")\n   * or an infinite cyclic emission of values. It's useful to think about\n   * MemoryStreams as cells in a spreadsheet. It doesn't make any sense to\n   * define a spreadsheet cell `A1` with a formula that depends on `B1` and\n   * cell `B1` defined with a formula that depends on `A1`.\n   *\n   * If you find yourself wanting to use `imitate()` with a\n   * MemoryStream, you should rework your code around `imitate()` to use a\n   * Stream instead. Look for the stream in the circular dependency that\n   * represents an event stream, and that would be a candidate for creating a\n   * proxy Stream which then imitates the target Stream.\n   *\n   * @param {Stream} target The other stream to imitate on the current one. Must\n   * not be a MemoryStream.\n   */\n  Stream.prototype.imitate = function (target) {\n    if (target instanceof MemoryStream) throw new Error('A MemoryStream was given to imitate(), but it only ' + 'supports a Stream. Read more about this restriction here: ' + 'https://github.com/staltz/xstream#faq');\n    this._target = target;\n    for (var ils = this._ils, N = ils.length, i = 0; i < N; i++) target._add(ils[i]);\n    this._ils = [];\n  };\n  /**\n   * Forces the Stream to emit the given value to its listeners.\n   *\n   * As the name indicates, if you use this, you are most likely doing something\n   * The Wrong Way. Please try to understand the reactive way before using this\n   * method. Use it only when you know what you are doing.\n   *\n   * @param value The \"next\" value you want to broadcast to all listeners of\n   * this Stream.\n   */\n  Stream.prototype.shamefullySendNext = function (value) {\n    this._n(value);\n  };\n  /**\n   * Forces the Stream to emit the given error to its listeners.\n   *\n   * As the name indicates, if you use this, you are most likely doing something\n   * The Wrong Way. Please try to understand the reactive way before using this\n   * method. Use it only when you know what you are doing.\n   *\n   * @param {any} error The error you want to broadcast to all the listeners of\n   * this Stream.\n   */\n  Stream.prototype.shamefullySendError = function (error) {\n    this._e(error);\n  };\n  /**\n   * Forces the Stream to emit the \"completed\" event to its listeners.\n   *\n   * As the name indicates, if you use this, you are most likely doing something\n   * The Wrong Way. Please try to understand the reactive way before using this\n   * method. Use it only when you know what you are doing.\n   */\n  Stream.prototype.shamefullySendComplete = function () {\n    this._c();\n  };\n  /**\n   * Adds a \"debug\" listener to the stream. There can only be one debug\n   * listener, that's why this is 'setDebugListener'. To remove the debug\n   * listener, just call setDebugListener(null).\n   *\n   * A debug listener is like any other listener. The only difference is that a\n   * debug listener is \"stealthy\": its presence/absence does not trigger the\n   * start/stop of the stream (or the producer inside the stream). This is\n   * useful so you can inspect what is going on without changing the behavior\n   * of the program. If you have an idle stream and you add a normal listener to\n   * it, the stream will start executing. But if you set a debug listener on an\n   * idle stream, it won't start executing (not until the first normal listener\n   * is added).\n   *\n   * As the name indicates, we don't recommend using this method to build app\n   * logic. In fact, in most cases the debug operator works just fine. Only use\n   * this one if you know what you're doing.\n   *\n   * @param {Listener<T>} listener\n   */\n  Stream.prototype.setDebugListener = function (listener) {\n    if (!listener) {\n      this._d = false;\n      this._dl = NO;\n    } else {\n      this._d = true;\n      listener._n = listener.next || noop;\n      listener._e = listener.error || noop;\n      listener._c = listener.complete || noop;\n      this._dl = listener;\n    }\n  };\n  /**\n   * Blends multiple streams together, emitting events from all of them\n   * concurrently.\n   *\n   * *merge* takes multiple streams as arguments, and creates a stream that\n   * behaves like each of the argument streams, in parallel.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1----2-----3--------4---\n   * ----a-----b----c---d------\n   *            merge\n   * --1-a--2--b--3-c---d--4---\n   * ```\n   *\n   * @factory true\n   * @param {Stream} stream1 A stream to merge together with other streams.\n   * @param {Stream} stream2 A stream to merge together with other streams. Two\n   * or more streams may be given as arguments.\n   * @return {Stream}\n   */\n  Stream.merge = function merge() {\n    var streams = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      streams[_i] = arguments[_i];\n    }\n    return new Stream(new Merge(streams));\n  };\n  /**\n   * Combines multiple input streams together to return a stream whose events\n   * are arrays that collect the latest events from each input stream.\n   *\n   * *combine* internally remembers the most recent event from each of the input\n   * streams. When any of the input streams emits an event, that event together\n   * with all the other saved events are combined into an array. That array will\n   * be emitted on the output stream. It's essentially a way of joining together\n   * the events from multiple streams.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1----2-----3--------4---\n   * ----a-----b-----c--d------\n   *          combine\n   * ----1a-2a-2b-3b-3c-3d-4d--\n   * ```\n   *\n   * @factory true\n   * @param {Stream} stream1 A stream to combine together with other streams.\n   * @param {Stream} stream2 A stream to combine together with other streams.\n   * Multiple streams, not just two, may be given as arguments.\n   * @return {Stream}\n   */\n  Stream.combine = function combine() {\n    var streams = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      streams[_i] = arguments[_i];\n    }\n    return new Stream(new Combine(streams));\n  };\n  return Stream;\n}();\nexports.Stream = Stream;\nvar MemoryStream = /** @class */function (_super) {\n  __extends(MemoryStream, _super);\n  function MemoryStream(producer) {\n    var _this = _super.call(this, producer) || this;\n    _this._has = false;\n    return _this;\n  }\n  MemoryStream.prototype._n = function (x) {\n    this._v = x;\n    this._has = true;\n    _super.prototype._n.call(this, x);\n  };\n  MemoryStream.prototype._add = function (il) {\n    var ta = this._target;\n    if (ta) return ta._add(il);\n    var a = this._ils;\n    a.push(il);\n    if (a.length > 1) {\n      if (this._has) il._n(this._v);\n      return;\n    }\n    if (this._stopID !== NO) {\n      if (this._has) il._n(this._v);\n      clearTimeout(this._stopID);\n      this._stopID = NO;\n    } else if (this._has) il._n(this._v);else {\n      var p = this._prod;\n      if (p !== NO) p._start(this);\n    }\n  };\n  MemoryStream.prototype._stopNow = function () {\n    this._has = false;\n    _super.prototype._stopNow.call(this);\n  };\n  MemoryStream.prototype._x = function () {\n    this._has = false;\n    _super.prototype._x.call(this);\n  };\n  MemoryStream.prototype.map = function (project) {\n    return this._map(project);\n  };\n  MemoryStream.prototype.mapTo = function (projectedValue) {\n    return _super.prototype.mapTo.call(this, projectedValue);\n  };\n  MemoryStream.prototype.take = function (amount) {\n    return _super.prototype.take.call(this, amount);\n  };\n  MemoryStream.prototype.endWhen = function (other) {\n    return _super.prototype.endWhen.call(this, other);\n  };\n  MemoryStream.prototype.replaceError = function (replace) {\n    return _super.prototype.replaceError.call(this, replace);\n  };\n  MemoryStream.prototype.remember = function () {\n    return this;\n  };\n  MemoryStream.prototype.debug = function (labelOrSpy) {\n    return _super.prototype.debug.call(this, labelOrSpy);\n  };\n  return MemoryStream;\n}(Stream);\nexports.MemoryStream = MemoryStream;\nvar xs = Stream;\nexports.default = xs;","map":{"version":3,"names":["ponyfill_1","require","globalthis_1","$$observable","default","getPolyfill","NO","exports","noop","cp","a","l","length","b","Array","i","and","f1","f2","andFn","t","_try","c","u","f","e","_e","NO_IL","_n","_c","internalizeProducer","producer","_start","il","next","error","complete","start","_stop","stop","StreamSub","_stream","_listener","prototype","unsubscribe","_remove","Observer","value","err","FromObservable","observable","type","ins","active","out","_sub","subscribe","Merge","insArr","ac","s","L","_add","CombineListener","p","ils","push","up","vals","Nc","Combine","Nn","v","n","FromArray","FromPromise","on","prod","then","setTimeout","Periodic","period","intervalID","self","intervalHandler","setInterval","clearInterval","Debug","arg","console","log","Drop","max","dropped","EndWhenListener","op","end","EndWhen","o","oil","Filter","passes","r","FlattenListener","inner","less","Flatten","open","_a","Fold","seed","_this","acc","Last","has","val","Error","MapOp","project","Remember","ReplaceError","replacer","StartWith","Take","taken","m","Stream","_prod","_ils","_stopID","_dl","_d","_target","_err","_x","_stopNow","ta","clearTimeout","indexOf","splice","_pruneCycles","_hasNoSinks","x","trace","concat","N","ctor","MemoryStream","addListener","listener","removeListener","create","createWithMemory","never","empty","throw","from","input","fromObservable","fromPromise","isArray","fromArray","TypeError","of","items","_i","arguments","array","promise","obs","endWhen","undefined","periodic","_map","map","mapTo","projectedValue","filter","take","amount","drop","last","startWith","initial","other","fold","accumulate","replaceError","replace","flatten","compose","operator","remember","debug","labelOrSpy","imitate","target","shamefullySendNext","shamefullySendError","shamefullySendComplete","setDebugListener","merge","streams","combine","_super","__extends","call","_has","_v","xs"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/xstream/src/index.ts"],"sourcesContent":["import ponyfillSymbolObservable from 'symbol-observable/ponyfill';\nimport { getPolyfill as getGlobalThis } from 'globalthis';\n\nconst $$observable = ponyfillSymbolObservable(getGlobalThis());\n\nconst NO = {};\nfunction noop() { }\n\nfunction cp<T>(a: Array<T>): Array<T> {\n  const l = a.length;\n  const b = Array(l);\n  for (let i = 0; i < l; ++i) b[i] = a[i];\n  return b;\n}\n\nfunction and<T>(f1: (t: T) => boolean, f2: (t: T) => boolean): (t: T) => boolean {\n  return function andFn(t: T): boolean {\n    return f1(t) && f2(t);\n  };\n}\n\ninterface FContainer<T, R> {\n  f(t: T): R;\n}\n\nfunction _try<T, R>(c: FContainer<T, R>, t: T, u: Stream<any>): R | {} {\n  try {\n    return c.f(t);\n  } catch (e) {\n    u._e(e);\n    return NO;\n  }\n}\n\nexport interface InternalListener<T> {\n  _n: (v: T) => void;\n  _e: (err: any) => void;\n  _c: () => void;\n}\n\nconst NO_IL: InternalListener<any> = {\n  _n: noop,\n  _e: noop,\n  _c: noop,\n};\n\nexport interface InternalProducer<T> {\n  _start(listener: InternalListener<T>): void;\n  _stop: () => void;\n}\n\nexport interface OutSender<T> {\n  out: Stream<T>;\n}\n\nexport interface Operator<T, R> extends InternalProducer<R>, InternalListener<T>, OutSender<R> {\n  type: string;\n  ins: Stream<T>;\n  _start(out: Stream<R>): void;\n}\n\nexport interface Aggregator<T, U> extends InternalProducer<U>, OutSender<U> {\n  type: string;\n  insArr: Array<Stream<T>>;\n  _start(out: Stream<U>): void;\n}\n\nexport interface Producer<T> {\n  start: (listener: Listener<T>) => void;\n  stop: () => void;\n}\n\nexport interface Listener<T> {\n  next: (x: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\nexport interface Subscription {\n  unsubscribe(): void;\n}\n\nexport interface Observable<T> {\n  subscribe(listener: Listener<T>): Subscription;\n}\n\n// mutates the input\nfunction internalizeProducer<T>(producer: Producer<T> & Partial<InternalProducer<T>>) {\n  producer._start = function _start(il: InternalListener<T> & Partial<Listener<T>>) {\n    il.next = il._n;\n    il.error = il._e;\n    il.complete = il._c;\n    this.start(il as Listener<T>);\n  };\n  producer._stop = producer.stop;\n}\n\nclass StreamSub<T> implements Subscription {\n  constructor(private _stream: Stream<T>, private _listener: InternalListener<T>) { }\n\n  unsubscribe(): void {\n    this._stream._remove(this._listener);\n  }\n}\n\nclass Observer<T> implements Listener<T> {\n  constructor(private _listener: InternalListener<T>) { }\n\n  next(value: T) {\n    this._listener._n(value);\n  }\n\n  error(err: any) {\n    this._listener._e(err);\n  }\n\n  complete() {\n    this._listener._c();\n  }\n}\n\nclass FromObservable<T> implements InternalProducer<T> {\n  public type = 'fromObservable';\n  public ins: Observable<T>;\n  public out?: Stream<T>;\n  private active: boolean;\n  private _sub: Subscription | undefined;\n\n  constructor(observable: Observable<T>) {\n    this.ins = observable;\n    this.active = false;\n  }\n\n  _start(out: Stream<T>) {\n    this.out = out;\n    this.active = true;\n    this._sub = this.ins.subscribe(new Observer(out));\n    if (!this.active) this._sub.unsubscribe();\n  }\n\n  _stop() {\n    if (this._sub) this._sub.unsubscribe();\n    this.active = false;\n  }\n}\n\nexport interface MergeSignature {\n  (): Stream<any>;\n  <T1>(s1: Stream<T1>): Stream<T1>;\n  <T1, T2>(\n    s1: Stream<T1>,\n    s2: Stream<T2>): Stream<T1 | T2>;\n  <T1, T2, T3>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>): Stream<T1 | T2 | T3>;\n  <T1, T2, T3, T4>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>): Stream<T1 | T2 | T3 | T4>;\n  <T1, T2, T3, T4, T5>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>): Stream<T1 | T2 | T3 | T4 | T5>;\n  <T1, T2, T3, T4, T5, T6>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>): Stream<T1 | T2 | T3 | T4 | T5 | T6>;\n  <T1, T2, T3, T4, T5, T6, T7>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>): Stream<T1 | T2 | T3 | T4 | T5 | T6 | T7>;\n  <T1, T2, T3, T4, T5, T6, T7, T8>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>): Stream<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8>;\n  <T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>,\n    s9: Stream<T9>): Stream<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;\n  <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>,\n    s9: Stream<T9>,\n    s10: Stream<T10>): Stream<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10>;\n  <T>(...stream: Array<Stream<T>>): Stream<T>;\n}\n\nclass Merge<T> implements Aggregator<T, T>, InternalListener<T> {\n  public type = 'merge';\n  public insArr: Array<Stream<T>>;\n  public out: Stream<T>;\n  private ac: number; // ac is activeCount\n\n  constructor(insArr: Array<Stream<T>>) {\n    this.insArr = insArr;\n    this.out = NO as Stream<T>;\n    this.ac = 0;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    const s = this.insArr;\n    const L = s.length;\n    this.ac = L;\n    for (let i = 0; i < L; i++) s[i]._add(this);\n  }\n\n  _stop(): void {\n    const s = this.insArr;\n    const L = s.length;\n    for (let i = 0; i < L; i++) s[i]._remove(this);\n    this.out = NO as Stream<T>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    if (--this.ac <= 0) {\n      const u = this.out;\n      if (u === NO) return;\n      u._c();\n    }\n  }\n}\n\nexport interface CombineSignature {\n  (): Stream<Array<any>>;\n  <T1>(s1: Stream<T1>): Stream<[T1]>;\n  <T1, T2>(\n    s1: Stream<T1>,\n    s2: Stream<T2>): Stream<[T1, T2]>;\n  <T1, T2, T3>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>): Stream<[T1, T2, T3]>;\n  <T1, T2, T3, T4>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>): Stream<[T1, T2, T3, T4]>;\n  <T1, T2, T3, T4, T5>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>): Stream<[T1, T2, T3, T4, T5]>;\n  <T1, T2, T3, T4, T5, T6>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>): Stream<[T1, T2, T3, T4, T5, T6]>;\n  <T1, T2, T3, T4, T5, T6, T7>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>): Stream<[T1, T2, T3, T4, T5, T6, T7]>;\n  <T1, T2, T3, T4, T5, T6, T7, T8>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>): Stream<[T1, T2, T3, T4, T5, T6, T7, T8]>;\n  <T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>,\n    s9: Stream<T9>): Stream<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;\n  <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>,\n    s9: Stream<T9>,\n    s10: Stream<T10>): Stream<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;\n  <T>(...stream: Array<Stream<T>>): Stream<Array<T>>;\n  (...stream: Array<Stream<any>>): Stream<Array<any>>;\n}\n\nclass CombineListener<T> implements InternalListener<T>, OutSender<Array<T>> {\n  private i: number;\n  public out: Stream<Array<T>>;\n  private p: Combine<T>;\n\n  constructor(i: number, out: Stream<Array<T>>, p: Combine<T>) {\n    this.i = i;\n    this.out = out;\n    this.p = p;\n    p.ils.push(this);\n  }\n\n  _n(t: T): void {\n    const p = this.p, out = this.out;\n    if (out === NO) return;\n    if (p.up(t, this.i)) {\n      const b = cp(p.vals);\n      out._n(b);\n    }\n  }\n\n  _e(err: any): void {\n    const out = this.out;\n    if (out === NO) return;\n    out._e(err);\n  }\n\n  _c(): void {\n    const p = this.p;\n    if (p.out === NO) return;\n    if (--p.Nc === 0) p.out._c();\n  }\n}\n\nclass Combine<R> implements Aggregator<any, Array<R>> {\n  public type = 'combine';\n  public insArr: Array<Stream<any>>;\n  public out: Stream<Array<R>>;\n  public ils: Array<CombineListener<any>>;\n  public Nc: number; // *N*umber of streams still to send *c*omplete\n  public Nn: number; // *N*umber of streams still to send *n*ext\n  public vals: Array<R>;\n\n  constructor(insArr: Array<Stream<any>>) {\n    this.insArr = insArr;\n    this.out = NO as Stream<Array<R>>;\n    this.ils = [];\n    this.Nc = this.Nn = 0;\n    this.vals = [];\n  }\n\n  up(t: any, i: number): boolean {\n    const v = this.vals[i];\n    const Nn = !this.Nn ? 0 : v === NO ? --this.Nn : this.Nn;\n    this.vals[i] = t;\n    return Nn === 0;\n  }\n\n  _start(out: Stream<Array<R>>): void {\n    this.out = out;\n    const s = this.insArr;\n    const n = this.Nc = this.Nn = s.length;\n    const vals = this.vals = new Array(n);\n    if (n === 0) {\n      out._n([]);\n      out._c();\n    } else {\n      for (let i = 0; i < n; i++) {\n        vals[i] = NO;\n        s[i]._add(new CombineListener(i, out, this));\n      }\n    }\n  }\n\n  _stop(): void {\n    const s = this.insArr;\n    const n = s.length;\n    const ils = this.ils;\n    for (let i = 0; i < n; i++) s[i]._remove(ils[i]);\n    this.out = NO as Stream<Array<R>>;\n    this.ils = [];\n    this.vals = [];\n  }\n}\n\nclass FromArray<T> implements InternalProducer<T> {\n  public type = 'fromArray';\n  public a: Array<T>;\n\n  constructor(a: Array<T>) {\n    this.a = a;\n  }\n\n  _start(out: InternalListener<T>): void {\n    const a = this.a;\n    for (let i = 0, n = a.length; i < n; i++) out._n(a[i]);\n    out._c();\n  }\n\n  _stop(): void {\n  }\n}\n\nclass FromPromise<T> implements InternalProducer<T> {\n  public type = 'fromPromise';\n  public on: boolean;\n  public p: PromiseLike<T>;\n\n  constructor(p: PromiseLike<T>) {\n    this.on = false;\n    this.p = p;\n  }\n\n  _start(out: InternalListener<T>): void {\n    const prod = this;\n    this.on = true;\n    this.p.then(\n      (v: T) => {\n        if (prod.on) {\n          out._n(v);\n          out._c();\n        }\n      },\n      (e: any) => {\n        out._e(e);\n      },\n    ).then(noop, (err: any) => {\n      setTimeout(() => { throw err; });\n    });\n  }\n\n  _stop(): void {\n    this.on = false;\n  }\n}\n\nclass Periodic implements InternalProducer<number> {\n  public type = 'periodic';\n  public period: number;\n  private intervalID: any;\n  private i: number;\n\n  constructor(period: number) {\n    this.period = period;\n    this.intervalID = -1;\n    this.i = 0;\n  }\n\n  _start(out: InternalListener<number>): void {\n    const self = this;\n    function intervalHandler() { out._n(self.i++); }\n    this.intervalID = setInterval(intervalHandler, this.period);\n  }\n\n  _stop(): void {\n    if (this.intervalID !== -1) clearInterval(this.intervalID);\n    this.intervalID = -1;\n    this.i = 0;\n  }\n}\n\nclass Debug<T> implements Operator<T, T> {\n  public type = 'debug';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  private s: (t: T) => any; // spy\n  private l: string; // label\n\n  constructor(ins: Stream<T>);\n  constructor(ins: Stream<T>, arg?: string);\n  constructor(ins: Stream<T>, arg?: (t: T) => any);\n  constructor(ins: Stream<T>, arg?: string | ((t: T) => any));\n  constructor(ins: Stream<T>, arg?: string | ((t: T) => any) | undefined) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.s = noop;\n    this.l = '';\n    if (typeof arg === 'string') this.l = arg; else if (typeof arg === 'function') this.s = arg;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<T>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    const s = this.s, l = this.l;\n    if (s !== noop) {\n      try {\n        s(t);\n      } catch (e) {\n        u._e(e);\n      }\n    } else if (l) console.log(l + ':', t); else console.log(t);\n    u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nclass Drop<T> implements Operator<T, T> {\n  public type = 'drop';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  public max: number;\n  private dropped: number;\n\n  constructor(max: number, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.max = max;\n    this.dropped = 0;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.dropped = 0;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<T>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    if (this.dropped++ >= this.max) u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nclass EndWhenListener<T> implements InternalListener<any> {\n  private out: Stream<T>;\n  private op: EndWhen<T>;\n\n  constructor(out: Stream<T>, op: EndWhen<T>) {\n    this.out = out;\n    this.op = op;\n  }\n\n  _n() {\n    this.op.end();\n  }\n\n  _e(err: any) {\n    this.out._e(err);\n  }\n\n  _c() {\n    this.op.end();\n  }\n}\n\nclass EndWhen<T> implements Operator<T, T> {\n  public type = 'endWhen';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  public o: Stream<any>; // o = other\n  private oil: InternalListener<any>; // oil = other InternalListener\n\n  constructor(o: Stream<any>, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.o = o;\n    this.oil = NO_IL;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.o._add(this.oil = new EndWhenListener(out, this));\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.o._remove(this.oil);\n    this.out = NO as Stream<T>;\n    this.oil = NO_IL;\n  }\n\n  end(): void {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    this.end();\n  }\n}\n\nclass Filter<T> implements Operator<T, T> {\n  public type = 'filter';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  public f: (t: T) => boolean;\n\n  constructor(passes: (t: T) => boolean, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.f = passes;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<T>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    const r = _try(this, t, u);\n    if (r === NO || !r) return;\n    u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nclass FlattenListener<T> implements InternalListener<T> {\n  private out: Stream<T>;\n  private op: Flatten<T>;\n\n  constructor(out: Stream<T>, op: Flatten<T>) {\n    this.out = out;\n    this.op = op;\n  }\n\n  _n(t: T) {\n    this.out._n(t);\n  }\n\n  _e(err: any) {\n    this.out._e(err);\n  }\n\n  _c() {\n    this.op.inner = NO as Stream<T>;\n    this.op.less();\n  }\n}\n\nclass Flatten<T> implements Operator<Stream<T>, T> {\n  public type = 'flatten';\n  public ins: Stream<Stream<T>>;\n  public out: Stream<T>;\n  private open: boolean;\n  public inner: Stream<T>; // Current inner Stream\n  private il: InternalListener<T>; // Current inner InternalListener\n\n  constructor(ins: Stream<Stream<T>>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.open = true;\n    this.inner = NO as Stream<T>;\n    this.il = NO_IL;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.open = true;\n    this.inner = NO as Stream<T>;\n    this.il = NO_IL;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    if (this.inner !== NO) this.inner._remove(this.il);\n    this.out = NO as Stream<T>;\n    this.open = true;\n    this.inner = NO as Stream<T>;\n    this.il = NO_IL;\n  }\n\n  less(): void {\n    const u = this.out;\n    if (u === NO) return;\n    if (!this.open && this.inner === NO) u._c();\n  }\n\n  _n(s: Stream<T>) {\n    const u = this.out;\n    if (u === NO) return;\n    const { inner, il } = this;\n    if (inner !== NO && il !== NO_IL) inner._remove(il);\n    (this.inner = s)._add(this.il = new FlattenListener(u, this));\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    this.open = false;\n    this.less();\n  }\n}\n\nclass Fold<T, R> implements Operator<T, R> {\n  public type = 'fold';\n  public ins: Stream<T>;\n  public out: Stream<R>;\n  public f: (t: T) => R;\n  public seed: R;\n  private acc: R; // initialized as seed\n\n  constructor(f: (acc: R, t: T) => R, seed: R, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<R>;\n    this.f = (t: T) => f(this.acc, t);\n    this.acc = this.seed = seed;\n  }\n\n  _start(out: Stream<R>): void {\n    this.out = out;\n    this.acc = this.seed;\n    out._n(this.acc);\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<R>;\n    this.acc = this.seed;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    const r = _try(this, t, u);\n    if (r === NO) return;\n    u._n(this.acc = r as R);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nclass Last<T> implements Operator<T, T> {\n  public type = 'last';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  private has: boolean;\n  private val: T;\n\n  constructor(ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.has = false;\n    this.val = NO as T;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.has = false;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<T>;\n    this.val = NO as T;\n  }\n\n  _n(t: T) {\n    this.has = true;\n    this.val = t;\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    if (this.has) {\n      u._n(this.val);\n      u._c();\n    } else u._e(new Error('last() failed because input stream completed'));\n  }\n}\n\nclass MapOp<T, R> implements Operator<T, R> {\n  public type = 'map';\n  public ins: Stream<T>;\n  public out: Stream<R>;\n  public f: (t: T) => R;\n\n  constructor(project: (t: T) => R, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<R>;\n    this.f = project;\n  }\n\n  _start(out: Stream<R>): void {\n    this.out = out;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<R>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    const r = _try(this, t, u);\n    if (r === NO) return;\n    u._n(r as R);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nclass Remember<T> implements InternalProducer<T> {\n  public type = 'remember';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n\n  constructor(ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.ins._add(out);\n  }\n\n  _stop(): void {\n    this.ins._remove(this.out);\n    this.out = NO as Stream<T>;\n  }\n}\n\nclass ReplaceError<T> implements Operator<T, T> {\n  public type = 'replaceError';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  public f: (err: any) => Stream<T>;\n\n  constructor(replacer: (err: any) => Stream<T>, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.f = replacer;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<T>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    try {\n      this.ins._remove(this);\n      (this.ins = this.f(err))._add(this);\n    } catch (e) {\n      u._e(e);\n    }\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nclass StartWith<T> implements InternalProducer<T> {\n  public type = 'startWith';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  public val: T;\n\n  constructor(ins: Stream<T>, val: T) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.val = val;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.out._n(this.val);\n    this.ins._add(out);\n  }\n\n  _stop(): void {\n    this.ins._remove(this.out);\n    this.out = NO as Stream<T>;\n  }\n}\n\nclass Take<T> implements Operator<T, T> {\n  public type = 'take';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  public max: number;\n  private taken: number;\n\n  constructor(max: number, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.max = max;\n    this.taken = 0;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.taken = 0;\n    if (this.max <= 0) out._c(); else this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<T>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    const m = ++this.taken;\n    if (m < this.max) u._n(t); else if (m === this.max) {\n      u._n(t);\n      u._c();\n    }\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nexport class Stream<T> implements InternalListener<T> {\n  public _prod: InternalProducer<T>;\n  protected _ils: Array<InternalListener<T>>; // 'ils' = Internal listeners\n  protected _stopID: any;\n  protected _dl: InternalListener<T>; // the debug listener\n  protected _d: boolean; // flag indicating the existence of the debug listener\n  protected _target: Stream<T> | null; // imitation target if this Stream will imitate\n  protected _err: any;\n\n  constructor(producer?: InternalProducer<T>) {\n    this._prod = producer || NO as InternalProducer<T>;\n    this._ils = [];\n    this._stopID = NO;\n    this._dl = NO as InternalListener<T>;\n    this._d = false;\n    this._target = null;\n    this._err = NO;\n  }\n\n  _n(t: T): void {\n    const a = this._ils;\n    const L = a.length;\n    if (this._d) this._dl._n(t);\n    if (L == 1) a[0]._n(t); else if (L == 0) return; else {\n      const b = cp(a);\n      for (let i = 0; i < L; i++) b[i]._n(t);\n    }\n  }\n\n  _e(err: any): void {\n    if (this._err !== NO) return;\n    this._err = err;\n    const a = this._ils;\n    const L = a.length;\n    this._x();\n    if (this._d) this._dl._e(err);\n    if (L == 1) a[0]._e(err); else if (L == 0) return; else {\n      const b = cp(a);\n      for (let i = 0; i < L; i++) b[i]._e(err);\n    }\n    if (!this._d && L == 0) throw this._err;\n  }\n\n  _c(): void {\n    const a = this._ils;\n    const L = a.length;\n    this._x();\n    if (this._d) this._dl._c();\n    if (L == 1) a[0]._c(); else if (L == 0) return; else {\n      const b = cp(a);\n      for (let i = 0; i < L; i++) b[i]._c();\n    }\n  }\n\n  _x(): void { // tear down logic, after error or complete\n    if (this._ils.length === 0) return;\n    if (this._prod !== NO) this._prod._stop();\n    this._err = NO;\n    this._ils = [];\n  }\n\n  _stopNow() {\n    // WARNING: code that calls this method should\n    // first check if this._prod is valid (not `NO`)\n    this._prod._stop();\n    this._err = NO;\n    this._stopID = NO;\n  }\n\n  _add(il: InternalListener<T>): void {\n    const ta = this._target;\n    if (ta) return ta._add(il);\n    const a = this._ils;\n    a.push(il);\n    if (a.length > 1) return;\n    if (this._stopID !== NO) {\n      clearTimeout(this._stopID);\n      this._stopID = NO;\n    } else {\n      const p = this._prod;\n      if (p !== NO) p._start(this);\n    }\n  }\n\n  _remove(il: InternalListener<T>): void {\n    const ta = this._target;\n    if (ta) return ta._remove(il);\n    const a = this._ils;\n    const i = a.indexOf(il);\n    if (i > -1) {\n      a.splice(i, 1);\n      if (this._prod !== NO && a.length <= 0) {\n        this._err = NO;\n        this._stopID = setTimeout(() => this._stopNow());\n      } else if (a.length === 1) {\n        this._pruneCycles();\n      }\n    }\n  }\n\n  // If all paths stemming from `this` stream eventually end at `this`\n  // stream, then we remove the single listener of `this` stream, to\n  // force it to end its execution and dispose resources. This method\n  // assumes as a precondition that this._ils has just one listener.\n  _pruneCycles() {\n    if (this._hasNoSinks(this, [])) this._remove(this._ils[0]);\n  }\n\n  // Checks whether *there is no* path starting from `x` that leads to an end\n  // listener (sink) in the stream graph, following edges A->B where B is a\n  // listener of A. This means these paths constitute a cycle somehow. Is given\n  // a trace of all visited nodes so far.\n  _hasNoSinks(x: InternalListener<any>, trace: Array<any>): boolean {\n    if (trace.indexOf(x) !== -1)\n      return true; else\n      if ((x as any as OutSender<any>).out === this)\n        return true; else\n        if ((x as any as OutSender<any>).out && (x as any as OutSender<any>).out !== NO)\n          return this._hasNoSinks((x as any as OutSender<any>).out, trace.concat(x)); else\n          if ((x as Stream<any>)._ils) {\n            for (let i = 0, N = (x as Stream<any>)._ils.length; i < N; i++)\n              if (!this._hasNoSinks((x as Stream<any>)._ils[i], trace.concat(x)))\n                return false;\n            return true;\n          } else return false;\n  }\n\n  private ctor(): typeof Stream {\n    return this instanceof MemoryStream ? MemoryStream : Stream;\n  }\n\n  /**\n   * Adds a Listener to the Stream.\n   *\n   * @param {Listener} listener\n   */\n  addListener(listener: Partial<Listener<T>>): void {\n    (listener as InternalListener<T>)._n = listener.next || noop;\n    (listener as InternalListener<T>)._e = listener.error || noop;\n    (listener as InternalListener<T>)._c = listener.complete || noop;\n    this._add(listener as InternalListener<T>);\n  }\n\n  /**\n   * Removes a Listener from the Stream, assuming the Listener was added to it.\n   *\n   * @param {Listener<T>} listener\n   */\n  removeListener(listener: Partial<Listener<T>>): void {\n    this._remove(listener as InternalListener<T>);\n  }\n\n  /**\n   * Adds a Listener to the Stream returning a Subscription to remove that\n   * listener.\n   *\n   * @param {Listener} listener\n   * @returns {Subscription}\n   */\n  subscribe(listener: Partial<Listener<T>>): Subscription {\n    this.addListener(listener);\n    return new StreamSub<T>(this, listener as InternalListener<T>);\n  }\n\n  /**\n   * Add interop between most.js and RxJS 5\n   *\n   * @returns {Stream}\n   */\n  [$$observable](): Stream<T> {\n    return this;\n  }\n\n  /**\n   * Creates a new Stream given a Producer.\n   *\n   * @factory true\n   * @param {Producer} producer An optional Producer that dictates how to\n   * start, generate events, and stop the Stream.\n   * @return {Stream}\n   */\n  static create<T>(producer?: Producer<T>): Stream<T> {\n    if (producer) {\n      if (typeof producer.start !== 'function'\n        || typeof producer.stop !== 'function')\n        throw new Error('producer requires both start and stop functions');\n      internalizeProducer(producer); // mutates the input\n    }\n    return new Stream(producer as InternalProducer<T> & Producer<T>);\n  }\n\n  /**\n   * Creates a new MemoryStream given a Producer.\n   *\n   * @factory true\n   * @param {Producer} producer An optional Producer that dictates how to\n   * start, generate events, and stop the Stream.\n   * @return {MemoryStream}\n   */\n  static createWithMemory<T>(producer?: Producer<T>): MemoryStream<T> {\n    if (producer) internalizeProducer(producer); // mutates the input\n    return new MemoryStream<T>(producer as InternalProducer<T> & Producer<T>);\n  }\n\n  /**\n   * Creates a Stream that does nothing when started. It never emits any event.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   *          never\n   * -----------------------\n   * ```\n   *\n   * @factory true\n   * @return {Stream}\n   */\n  static never<T = any>(): Stream<T> {\n    return new Stream<T>({ _start: noop, _stop: noop });\n  }\n\n  /**\n   * Creates a Stream that immediately emits the \"complete\" notification when\n   * started, and that's it.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * empty\n   * -|\n   * ```\n   *\n   * @factory true\n   * @return {Stream}\n   */\n  static empty<T = any>(): Stream<T> {\n    return new Stream<T>({\n      _start(il: InternalListener<any>) { il._c(); },\n      _stop: noop,\n    });\n  }\n\n  /**\n   * Creates a Stream that immediately emits an \"error\" notification with the\n   * value you passed as the `error` argument when the stream starts, and that's\n   * it.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * throw(X)\n   * -X\n   * ```\n   *\n   * @factory true\n   * @param error The error event to emit on the created stream.\n   * @return {Stream}\n   */\n  static throw(error: any): Stream<any> {\n    return new Stream<any>({\n      _start(il: InternalListener<any>) { il._e(error); },\n      _stop: noop,\n    });\n  }\n\n  /**\n   * Creates a stream from an Array, Promise, or an Observable.\n   *\n   * @factory true\n   * @param {Array|PromiseLike|Observable} input The input to make a stream from.\n   * @return {Stream}\n   */\n  static from<T>(input: PromiseLike<T> | Stream<T> | Array<T> | Observable<T>): Stream<T> {\n    if (typeof input[$$observable] === 'function')\n      return Stream.fromObservable<T>(input as Observable<T>); else\n      if (typeof (input as PromiseLike<T>).then === 'function')\n        return Stream.fromPromise<T>(input as PromiseLike<T>); else\n        if (Array.isArray(input))\n          return Stream.fromArray<T>(input);\n\n    throw new TypeError(`Type of input to from() must be an Array, Promise, or Observable`);\n  }\n\n  /**\n   * Creates a Stream that immediately emits the arguments that you give to\n   * *of*, then completes.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * of(1,2,3)\n   * 123|\n   * ```\n   *\n   * @factory true\n   * @param a The first value you want to emit as an event on the stream.\n   * @param b The second value you want to emit as an event on the stream. One\n   * or more of these values may be given as arguments.\n   * @return {Stream}\n   */\n  static of<T>(...items: Array<T>): Stream<T> {\n    return Stream.fromArray<T>(items);\n  }\n\n  /**\n   * Converts an array to a stream. The returned stream will emit synchronously\n   * all the items in the array, and then complete.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * fromArray([1,2,3])\n   * 123|\n   * ```\n   *\n   * @factory true\n   * @param {Array} array The array to be converted as a stream.\n   * @return {Stream}\n   */\n  static fromArray<T>(array: Array<T>): Stream<T> {\n    return new Stream<T>(new FromArray<T>(array));\n  }\n\n  /**\n   * Converts a promise to a stream. The returned stream will emit the resolved\n   * value of the promise, and then complete. However, if the promise is\n   * rejected, the stream will emit the corresponding error.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * fromPromise( ----42 )\n   * -----------------42|\n   * ```\n   *\n   * @factory true\n   * @param {PromiseLike} promise The promise to be converted as a stream.\n   * @return {Stream}\n   */\n  static fromPromise<T>(promise: PromiseLike<T>): Stream<T> {\n    return new Stream<T>(new FromPromise<T>(promise));\n  }\n\n  /**\n   * Converts an Observable into a Stream.\n   *\n   * @factory true\n   * @param {any} observable The observable to be converted as a stream.\n   * @return {Stream}\n   */\n  static fromObservable<T>(obs: { subscribe: any }): Stream<T> {\n    if ((obs as Stream<T>).endWhen !== undefined) return obs as Stream<T>;\n    const o = typeof obs[$$observable] === 'function' ? obs[$$observable]() : obs;\n    return new Stream<T>(new FromObservable(o));\n  }\n\n  /**\n   * Creates a stream that periodically emits incremental numbers, every\n   * `period` milliseconds.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   *     periodic(1000)\n   * ---0---1---2---3---4---...\n   * ```\n   *\n   * @factory true\n   * @param {number} period The interval in milliseconds to use as a rate of\n   * emission.\n   * @return {Stream}\n   */\n  static periodic(period: number): Stream<number> {\n    return new Stream<number>(new Periodic(period));\n  }\n\n  /**\n   * Blends multiple streams together, emitting events from all of them\n   * concurrently.\n   *\n   * *merge* takes multiple streams as arguments, and creates a stream that\n   * behaves like each of the argument streams, in parallel.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1----2-----3--------4---\n   * ----a-----b----c---d------\n   *            merge\n   * --1-a--2--b--3-c---d--4---\n   * ```\n   *\n   * @factory true\n   * @param {Stream} stream1 A stream to merge together with other streams.\n   * @param {Stream} stream2 A stream to merge together with other streams. Two\n   * or more streams may be given as arguments.\n   * @return {Stream}\n   */\n  static merge: MergeSignature = function merge(...streams: Array<Stream<any>>) {\n    return new Stream<any>(new Merge(streams));\n  } as MergeSignature;\n\n  /**\n   * Combines multiple input streams together to return a stream whose events\n   * are arrays that collect the latest events from each input stream.\n   *\n   * *combine* internally remembers the most recent event from each of the input\n   * streams. When any of the input streams emits an event, that event together\n   * with all the other saved events are combined into an array. That array will\n   * be emitted on the output stream. It's essentially a way of joining together\n   * the events from multiple streams.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1----2-----3--------4---\n   * ----a-----b-----c--d------\n   *          combine\n   * ----1a-2a-2b-3b-3c-3d-4d--\n   * ```\n   *\n   * @factory true\n   * @param {Stream} stream1 A stream to combine together with other streams.\n   * @param {Stream} stream2 A stream to combine together with other streams.\n   * Multiple streams, not just two, may be given as arguments.\n   * @return {Stream}\n   */\n  static combine: CombineSignature = function combine(...streams: Array<Stream<any>>) {\n    return new Stream<Array<any>>(new Combine<any>(streams));\n  } as CombineSignature;\n\n  protected _map<U>(project: (t: T) => U): Stream<U> | MemoryStream<U> {\n    return new (this.ctor())<U>(new MapOp<T, U>(project, this));\n  }\n\n  /**\n   * Transforms each event from the input Stream through a `project` function,\n   * to get a Stream that emits those transformed events.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---3--5-----7------\n   *    map(i => i * 10)\n   * --10--30-50----70-----\n   * ```\n   *\n   * @param {Function} project A function of type `(t: T) => U` that takes event\n   * `t` of type `T` from the input Stream and produces an event of type `U`, to\n   * be emitted on the output Stream.\n   * @return {Stream}\n   */\n  map<U>(project: (t: T) => U): Stream<U> {\n    return this._map(project);\n  }\n\n  /**\n   * It's like `map`, but transforms each input event to always the same\n   * constant value on the output Stream.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---3--5-----7-----\n   *       mapTo(10)\n   * --10--10-10----10----\n   * ```\n   *\n   * @param projectedValue A value to emit on the output Stream whenever the\n   * input Stream emits any value.\n   * @return {Stream}\n   */\n  mapTo<U>(projectedValue: U): Stream<U> {\n    const s = this.map(() => projectedValue);\n    const op: Operator<T, U> = s._prod as Operator<T, U>;\n    op.type = 'mapTo';\n    return s;\n  }\n\n  filter<S extends T>(passes: (t: T) => t is S): Stream<S>;\n  filter(passes: (t: T) => boolean): Stream<T>;\n  /**\n   * Only allows events that pass the test given by the `passes` argument.\n   *\n   * Each event from the input stream is given to the `passes` function. If the\n   * function returns `true`, the event is forwarded to the output stream,\n   * otherwise it is ignored and not forwarded.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---2--3-----4-----5---6--7-8--\n   *     filter(i => i % 2 === 0)\n   * ------2--------4---------6----8--\n   * ```\n   *\n   * @param {Function} passes A function of type `(t: T) => boolean` that takes\n   * an event from the input stream and checks if it passes, by returning a\n   * boolean.\n   * @return {Stream}\n   */\n  filter(passes: (t: T) => boolean): Stream<T> {\n    const p = this._prod;\n    if (p instanceof Filter)\n      return new Stream<T>(new Filter<T>(\n        and((p as Filter<T>).f, passes),\n        (p as Filter<T>).ins\n      ));\n    return new Stream<T>(new Filter<T>(passes, this));\n  }\n\n  /**\n   * Lets the first `amount` many events from the input stream pass to the\n   * output stream, then makes the output stream complete.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --a---b--c----d---e--\n   *    take(3)\n   * --a---b--c|\n   * ```\n   *\n   * @param {number} amount How many events to allow from the input stream\n   * before completing the output stream.\n   * @return {Stream}\n   */\n  take(amount: number): Stream<T> {\n    return new (this.ctor())<T>(new Take<T>(amount, this));\n  }\n\n  /**\n   * Ignores the first `amount` many events from the input stream, and then\n   * after that starts forwarding events from the input stream to the output\n   * stream.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --a---b--c----d---e--\n   *       drop(3)\n   * --------------d---e--\n   * ```\n   *\n   * @param {number} amount How many events to ignore from the input stream\n   * before forwarding all events from the input stream to the output stream.\n   * @return {Stream}\n   */\n  drop(amount: number): Stream<T> {\n    return new Stream<T>(new Drop<T>(amount, this));\n  }\n\n  /**\n   * When the input stream completes, the output stream will emit the last event\n   * emitted by the input stream, and then will also complete.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --a---b--c--d----|\n   *       last()\n   * -----------------d|\n   * ```\n   *\n   * @return {Stream}\n   */\n  last(): Stream<T> {\n    return new Stream<T>(new Last<T>(this));\n  }\n\n  /**\n   * Prepends the given `initial` value to the sequence of events emitted by the\n   * input stream. The returned stream is a MemoryStream, which means it is\n   * already `remember()`'d.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * ---1---2-----3---\n   *   startWith(0)\n   * 0--1---2-----3---\n   * ```\n   *\n   * @param initial The value or event to prepend.\n   * @return {MemoryStream}\n   */\n  startWith(initial: T): MemoryStream<T> {\n    return new MemoryStream<T>(new StartWith<T>(this, initial));\n  }\n\n  /**\n   * Uses another stream to determine when to complete the current stream.\n   *\n   * When the given `other` stream emits an event or completes, the output\n   * stream will complete. Before that happens, the output stream will behaves\n   * like the input stream.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * ---1---2-----3--4----5----6---\n   *   endWhen( --------a--b--| )\n   * ---1---2-----3--4--|\n   * ```\n   *\n   * @param other Some other stream that is used to know when should the output\n   * stream of this operator complete.\n   * @return {Stream}\n   */\n  endWhen(other: Stream<any>): Stream<T> {\n    return new (this.ctor())<T>(new EndWhen<T>(other, this));\n  }\n\n  /**\n   * \"Folds\" the stream onto itself.\n   *\n   * Combines events from the past throughout\n   * the entire execution of the input stream, allowing you to accumulate them\n   * together. It's essentially like `Array.prototype.reduce`. The returned\n   * stream is a MemoryStream, which means it is already `remember()`'d.\n   *\n   * The output stream starts by emitting the `seed` which you give as argument.\n   * Then, when an event happens on the input stream, it is combined with that\n   * seed value through the `accumulate` function, and the output value is\n   * emitted on the output stream. `fold` remembers that output value as `acc`\n   * (\"accumulator\"), and then when a new input event `t` happens, `acc` will be\n   * combined with that to produce the new `acc` and so forth.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * ------1-----1--2----1----1------\n   *   fold((acc, x) => acc + x, 3)\n   * 3-----4-----5--7----8----9------\n   * ```\n   *\n   * @param {Function} accumulate A function of type `(acc: R, t: T) => R` that\n   * takes the previous accumulated value `acc` and the incoming event from the\n   * input stream and produces the new accumulated value.\n   * @param seed The initial accumulated value, of type `R`.\n   * @return {MemoryStream}\n   */\n  fold<R>(accumulate: (acc: R, t: T) => R, seed: R): MemoryStream<R> {\n    return new MemoryStream<R>(new Fold<T, R>(accumulate, seed, this));\n  }\n\n  /**\n   * Replaces an error with another stream.\n   *\n   * When (and if) an error happens on the input stream, instead of forwarding\n   * that error to the output stream, *replaceError* will call the `replace`\n   * function which returns the stream that the output stream will replicate.\n   * And, in case that new stream also emits an error, `replace` will be called\n   * again to get another stream to start replicating.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---2-----3--4-----X\n   *   replaceError( () => --10--| )\n   * --1---2-----3--4--------10--|\n   * ```\n   *\n   * @param {Function} replace A function of type `(err) => Stream` that takes\n   * the error that occurred on the input stream or on the previous replacement\n   * stream and returns a new stream. The output stream will behave like the\n   * stream that this function returns.\n   * @return {Stream}\n   */\n  replaceError(replace: (err: any) => Stream<T>): Stream<T> {\n    return new (this.ctor())<T>(new ReplaceError<T>(replace, this));\n  }\n\n  /**\n   * Flattens a \"stream of streams\", handling only one nested stream at a time\n   * (no concurrency).\n   *\n   * If the input stream is a stream that emits streams, then this operator will\n   * return an output stream which is a flat stream: emits regular events. The\n   * flattening happens without concurrency. It works like this: when the input\n   * stream emits a nested stream, *flatten* will start imitating that nested\n   * one. However, as soon as the next nested stream is emitted on the input\n   * stream, *flatten* will forget the previous nested one it was imitating, and\n   * will start imitating the new nested one.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --+--------+---------------\n   *   \\        \\\n   *    \\       ----1----2---3--\n   *    --a--b----c----d--------\n   *           flatten\n   * -----a--b------1----2---3--\n   * ```\n   *\n   * @return {Stream}\n   */\n  flatten<R>(this: Stream<Stream<R> | MemoryStream<R>>): Stream<R> {\n    return new Stream<R>(new Flatten(this));\n  }\n\n  /**\n   * Passes the input stream to a custom operator, to produce an output stream.\n   *\n   * *compose* is a handy way of using an existing function in a chained style.\n   * Instead of writing `outStream = f(inStream)` you can write\n   * `outStream = inStream.compose(f)`.\n   *\n   * @param {function} operator A function that takes a stream as input and\n   * returns a stream as well.\n   * @return {Stream}\n   */\n  compose<U>(operator: (stream: Stream<T>) => U): U {\n    return operator(this);\n  }\n\n  /**\n   * Returns an output stream that behaves like the input stream, but also\n   * remembers the most recent event that happens on the input stream, so that a\n   * newly added listener will immediately receive that memorised event.\n   *\n   * @return {MemoryStream}\n   */\n  remember(): MemoryStream<T> {\n    return new MemoryStream<T>(new Remember<T>(this));\n  }\n\n  debug(): Stream<T>;\n  debug(labelOrSpy: string): Stream<T>;\n  debug(labelOrSpy: (t: T) => any): Stream<T>;\n  /**\n   * Returns an output stream that identically behaves like the input stream,\n   * but also runs a `spy` function for each event, to help you debug your app.\n   *\n   * *debug* takes a `spy` function as argument, and runs that for each event\n   * happening on the input stream. If you don't provide the `spy` argument,\n   * then *debug* will just `console.log` each event. This helps you to\n   * understand the flow of events through some operator chain.\n   *\n   * Please note that if the output stream has no listeners, then it will not\n   * start, which means `spy` will never run because no actual event happens in\n   * that case.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1----2-----3-----4--\n   *         debug\n   * --1----2-----3-----4--\n   * ```\n   *\n   * @param {function} labelOrSpy A string to use as the label when printing\n   * debug information on the console, or a 'spy' function that takes an event\n   * as argument, and does not need to return anything.\n   * @return {Stream}\n   */\n  debug(labelOrSpy?: string | ((t: T) => any)): Stream<T> {\n    return new (this.ctor())<T>(new Debug<T>(this, labelOrSpy));\n  }\n\n  /**\n   * *imitate* changes this current Stream to emit the same events that the\n   * `other` given Stream does. This method returns nothing.\n   *\n   * This method exists to allow one thing: **circular dependency of streams**.\n   * For instance, let's imagine that for some reason you need to create a\n   * circular dependency where stream `first$` depends on stream `second$`\n   * which in turn depends on `first$`:\n   *\n   * <!-- skip-example -->\n   * ```js\n   * import delay from 'xstream/extra/delay'\n   *\n   * var first$ = second$.map(x => x * 10).take(3);\n   * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));\n   * ```\n   *\n   * However, that is invalid JavaScript, because `second$` is undefined\n   * on the first line. This is how *imitate* can help solve it:\n   *\n   * ```js\n   * import delay from 'xstream/extra/delay'\n   *\n   * var secondProxy$ = xs.create();\n   * var first$ = secondProxy$.map(x => x * 10).take(3);\n   * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));\n   * secondProxy$.imitate(second$);\n   * ```\n   *\n   * We create `secondProxy$` before the others, so it can be used in the\n   * declaration of `first$`. Then, after both `first$` and `second$` are\n   * defined, we hook `secondProxy$` with `second$` with `imitate()` to tell\n   * that they are \"the same\". `imitate` will not trigger the start of any\n   * stream, it just binds `secondProxy$` and `second$` together.\n   *\n   * The following is an example where `imitate()` is important in Cycle.js\n   * applications. A parent component contains some child components. A child\n   * has an action stream which is given to the parent to define its state:\n   *\n   * <!-- skip-example -->\n   * ```js\n   * const childActionProxy$ = xs.create();\n   * const parent = Parent({...sources, childAction$: childActionProxy$});\n   * const childAction$ = parent.state$.map(s => s.child.action$).flatten();\n   * childActionProxy$.imitate(childAction$);\n   * ```\n   *\n   * Note, though, that **`imitate()` does not support MemoryStreams**. If we\n   * would attempt to imitate a MemoryStream in a circular dependency, we would\n   * either get a race condition (where the symptom would be \"nothing happens\")\n   * or an infinite cyclic emission of values. It's useful to think about\n   * MemoryStreams as cells in a spreadsheet. It doesn't make any sense to\n   * define a spreadsheet cell `A1` with a formula that depends on `B1` and\n   * cell `B1` defined with a formula that depends on `A1`.\n   *\n   * If you find yourself wanting to use `imitate()` with a\n   * MemoryStream, you should rework your code around `imitate()` to use a\n   * Stream instead. Look for the stream in the circular dependency that\n   * represents an event stream, and that would be a candidate for creating a\n   * proxy Stream which then imitates the target Stream.\n   *\n   * @param {Stream} target The other stream to imitate on the current one. Must\n   * not be a MemoryStream.\n   */\n  imitate(target: Stream<T>): void {\n    if (target instanceof MemoryStream)\n      throw new Error('A MemoryStream was given to imitate(), but it only ' +\n        'supports a Stream. Read more about this restriction here: ' +\n        'https://github.com/staltz/xstream#faq');\n    this._target = target;\n    for (let ils = this._ils, N = ils.length, i = 0; i < N; i++) target._add(ils[i]);\n    this._ils = [];\n  }\n\n  /**\n   * Forces the Stream to emit the given value to its listeners.\n   *\n   * As the name indicates, if you use this, you are most likely doing something\n   * The Wrong Way. Please try to understand the reactive way before using this\n   * method. Use it only when you know what you are doing.\n   *\n   * @param value The \"next\" value you want to broadcast to all listeners of\n   * this Stream.\n   */\n  shamefullySendNext(value: T) {\n    this._n(value);\n  }\n\n  /**\n   * Forces the Stream to emit the given error to its listeners.\n   *\n   * As the name indicates, if you use this, you are most likely doing something\n   * The Wrong Way. Please try to understand the reactive way before using this\n   * method. Use it only when you know what you are doing.\n   *\n   * @param {any} error The error you want to broadcast to all the listeners of\n   * this Stream.\n   */\n  shamefullySendError(error: any) {\n    this._e(error);\n  }\n\n  /**\n   * Forces the Stream to emit the \"completed\" event to its listeners.\n   *\n   * As the name indicates, if you use this, you are most likely doing something\n   * The Wrong Way. Please try to understand the reactive way before using this\n   * method. Use it only when you know what you are doing.\n   */\n  shamefullySendComplete() {\n    this._c();\n  }\n\n  /**\n   * Adds a \"debug\" listener to the stream. There can only be one debug\n   * listener, that's why this is 'setDebugListener'. To remove the debug\n   * listener, just call setDebugListener(null).\n   *\n   * A debug listener is like any other listener. The only difference is that a\n   * debug listener is \"stealthy\": its presence/absence does not trigger the\n   * start/stop of the stream (or the producer inside the stream). This is\n   * useful so you can inspect what is going on without changing the behavior\n   * of the program. If you have an idle stream and you add a normal listener to\n   * it, the stream will start executing. But if you set a debug listener on an\n   * idle stream, it won't start executing (not until the first normal listener\n   * is added).\n   *\n   * As the name indicates, we don't recommend using this method to build app\n   * logic. In fact, in most cases the debug operator works just fine. Only use\n   * this one if you know what you're doing.\n   *\n   * @param {Listener<T>} listener\n   */\n  setDebugListener(listener: Partial<Listener<T>> | null | undefined) {\n    if (!listener) {\n      this._d = false;\n      this._dl = NO as InternalListener<T>;\n    } else {\n      this._d = true;\n      (listener as InternalListener<T>)._n = listener.next || noop;\n      (listener as InternalListener<T>)._e = listener.error || noop;\n      (listener as InternalListener<T>)._c = listener.complete || noop;\n      this._dl = listener as InternalListener<T>;\n    }\n  }\n}\n\nexport class MemoryStream<T> extends Stream<T> {\n  private _v?: T;\n  private _has?: boolean = false;\n  constructor(producer: InternalProducer<T>) {\n    super(producer);\n  }\n\n  _n(x: T) {\n    this._v = x;\n    this._has = true;\n    super._n(x);\n  }\n\n  _add(il: InternalListener<T>): void {\n    const ta = this._target;\n    if (ta) return ta._add(il);\n    const a = this._ils;\n    a.push(il);\n    if (a.length > 1) {\n      if (this._has) il._n(this._v!);\n      return;\n    }\n    if (this._stopID !== NO) {\n      if (this._has) il._n(this._v!);\n      clearTimeout(this._stopID);\n      this._stopID = NO;\n    } else if (this._has) il._n(this._v!); else {\n      const p = this._prod;\n      if (p !== NO) p._start(this);\n    }\n  }\n\n  _stopNow() {\n    this._has = false;\n    super._stopNow();\n  }\n\n  _x(): void {\n    this._has = false;\n    super._x();\n  }\n\n  map<U>(project: (t: T) => U): MemoryStream<U> {\n    return this._map(project) as MemoryStream<U>;\n  }\n\n  mapTo<U>(projectedValue: U): MemoryStream<U> {\n    return super.mapTo(projectedValue) as MemoryStream<U>;\n  }\n\n  take(amount: number): MemoryStream<T> {\n    return super.take(amount) as MemoryStream<T>;\n  }\n\n  endWhen(other: Stream<any>): MemoryStream<T> {\n    return super.endWhen(other) as MemoryStream<T>;\n  }\n\n  replaceError(replace: (err: any) => Stream<T>): MemoryStream<T> {\n    return super.replaceError(replace) as MemoryStream<T>;\n  }\n\n  remember(): MemoryStream<T> {\n    return this;\n  }\n\n  debug(): MemoryStream<T>;\n  debug(labelOrSpy: string): MemoryStream<T>;\n  debug(labelOrSpy: (t: T) => any): MemoryStream<T>;\n  debug(labelOrSpy?: string | ((t: T) => any) | undefined): MemoryStream<T> {\n    return super.debug(labelOrSpy as any) as MemoryStream<T>;\n  }\n}\n\nexport { NO, NO_IL };\nconst xs = Stream;\ntype xs<T> = Stream<T>;\nexport default xs;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}