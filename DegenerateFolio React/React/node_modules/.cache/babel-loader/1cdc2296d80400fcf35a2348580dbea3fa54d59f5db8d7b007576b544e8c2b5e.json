{"ast":null,"code":"import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter.mjs';\n\"use strict\";\nclass HardMixBlend extends BlendModeFilter {\n  constructor() {\n    super({\n      gl: {\n        functions: `\n                float hardMix(float base, float blend)\n                {\n                    return (base + blend >= 1.0) ? 1.0 : 0.0;\n                }\n\n                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)\n                {\n                    vec3 blended = vec3(\n                        hardMix(base.r, blend.r),\n                        hardMix(base.g, blend.g),\n                        hardMix(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                finalColor = vec4(blendHardMix(back.rgb, front.rgb, front.a), uBlend);\n            `\n      },\n      gpu: {\n        functions: `\n                fn hardMix(base: f32, blend: f32) -> f32\n                {\n                    return select(0.0, 1.0, base + blend >= 1.0);\n                }\n\n                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended: vec3<f32> = vec3<f32>(\n                        hardMix(base.r, blend.r),\n                        hardMix(base.g, blend.g),\n                        hardMix(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n        main: `\n                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendUniforms.uBlend);\n            `\n      }\n    });\n  }\n}\n/** @ignore */\nHardMixBlend.extension = {\n  name: \"hard-mix\",\n  type: ExtensionType.BlendMode\n};\nexport { HardMixBlend };","map":{"version":3,"names":["HardMixBlend","BlendModeFilter","constructor","gl","functions","main","gpu","extension","name","type","ExtensionType","BlendMode"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/advanced-blend-modes/HardMixBlend.ts"],"sourcesContent":["/* eslint-disable max-len */\n\nimport { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Hard defines each of the color channel values of the blend color to the RGB values of the base color.\n * If the sum of a channel is 255, it receives a value of 255; if less than 255, a value of 0.\n *\n * Available as `container.blendMode = 'hard-mix'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'hard-mix'\n * @memberof filters\n */\nexport class HardMixBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'hard-mix',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float hardMix(float base, float blend)\n                {\n                    return (base + blend >= 1.0) ? 1.0 : 0.0;\n                }\n\n                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)\n                {\n                    vec3 blended = vec3(\n                        hardMix(base.r, blend.r),\n                        hardMix(base.g, blend.g),\n                        hardMix(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                finalColor = vec4(blendHardMix(back.rgb, front.rgb, front.a), uBlend);\n            `\n            },\n            gpu: {\n                functions: `\n                fn hardMix(base: f32, blend: f32) -> f32\n                {\n                    return select(0.0, 1.0, base + blend >= 1.0);\n                }\n\n                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>\n                {\n                    let blended: vec3<f32> = vec3<f32>(\n                        hardMix(base.r, blend.r),\n                        hardMix(base.g, blend.g),\n                        hardMix(base.b, blend.b)\n                    );\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendUniforms.uBlend);\n            `\n            }\n        });\n    }\n}\n"],"mappings":";;;AAoBO,MAAMA,YAAA,SAAqBC,eAClC;EAOIC,WACAA,CAAA;IACU;MACFC,EAAI;QACAC,SAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;QAgBXC,IAAM;AAAA;AAAA;MAAA,CAGV;MACAC,GAAK;QACDF,SAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;QAgBXC,IAAM;AAAA;AAAA;MAAA;IAGV,CACH;EAAA;AAET;AAAA;AAvDaL,YAAA,CAGKO,SAA+B;EACzCC,IAAM;EACNC,IAAA,EAAMC,aAAc,CAAAC;AACxB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}