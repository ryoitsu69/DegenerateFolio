{"ast":null,"code":"\"use strict\";\n\nvar RendererType = /* @__PURE__ */(RendererType2 => {\n  RendererType2[RendererType2[\"WEBGL\"] = 1] = \"WEBGL\";\n  RendererType2[RendererType2[\"WEBGPU\"] = 2] = \"WEBGPU\";\n  RendererType2[RendererType2[\"BOTH\"] = 3] = \"BOTH\";\n  return RendererType2;\n})(RendererType || {});\nexport { RendererType };","map":{"version":3,"names":["RendererType","RendererType2"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/types.ts"],"sourcesContent":["import type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { WebGLOptions, WebGLPipes, WebGLRenderer } from './gl/WebGLRenderer';\nimport type { WebGPUOptions, WebGPUPipes, WebGPURenderer } from './gpu/WebGPURenderer';\n\n/** A generic renderer. */\nexport type Renderer<T extends ICanvas = HTMLCanvasElement> = WebGLRenderer<T> | WebGPURenderer<T>;\nexport type RenderPipes = WebGLPipes | WebGPUPipes;\nexport interface RendererOptions extends WebGLOptions, WebGPUOptions {}\n\n/* eslint-disable @typescript-eslint/indent */\n/**\n * Ids for the different render types.\n * The idea is that you can use bitwise operations to filter weather or not you want to do somthing in a certain render type.\n * Filters for example can be compatible for both webGL or WebGPU but not compatible with canvas.\n * So internally if it works with both we set filter.compatibleRenderers = RendererType.WEBGL | RendererType.WEBGPU\n * if it only works with webgl we set filter.compatibleRenderers = RendererType.WEBGL\n *\n */\nexport enum RendererType\n{\n    WEBGL = 0b01,\n    WEBGPU = 0b10,\n    BOTH = 0b11\n}\n\nexport type GpuPowerPreference = 'low-power' | 'high-performance';\n"],"mappings":";;AAkBY,IAAAA,YAAA,mBAAAC,aAAL;EAEHA,aAAA,CAAAA,aAAA,YAAQ,CAAR;EACAA,aAAA,CAAAA,aAAA,aAAS,CAAT;EACAA,aAAA,CAAAA,aAAA,WAAO,CAAP;EAJQ,OAAAA,aAAA;AAAA,GAAAD,YAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}