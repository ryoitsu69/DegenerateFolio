{"ast":null,"code":"import { identity, isCodec, isNull, isU8a, isUndefined, u8aToHex } from '@polkadot/util';\nimport { typeToConstructor } from '../utils/index.js';\nimport { Null } from './Null.js';\nclass None extends Null {\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'None';\n  }\n}\n/** @internal */\nfunction decodeOption(registry, Type, value) {\n  if (value instanceof Type) {\n    // don't re-create, use as it (which also caters for derived types)\n    return value;\n  } else if (value instanceof Option) {\n    if (value.value instanceof Type) {\n      // same instance, return it\n      return value.value;\n    } else if (value.isNone) {\n      // internal is None, we are also none\n      return new None(registry);\n    }\n    // convert the actual value into known\n    return new Type(registry, value.value);\n  } else if (isNull(value) || isUndefined(value) || value === '0x' || value instanceof None) {\n    // anything empty we pass as-is\n    return new None(registry);\n  } else if (isU8a(value)) {\n    // the isU8a check happens last in the if-tree - since the wrapped value\n    // may be an instance of it, so Type and Option checks go in first\n    return !value.length || value[0] === 0 ? new None(registry) : new Type(registry, value.subarray(1));\n  }\n  return new Type(registry, value);\n}\n/**\n * @name Option\n * @description\n * An Option is an optional field. Basically the first byte indicates that there is\n * is value to follow. If the byte is `1` there is an actual value. So the Option\n * implements that - decodes, checks for optionality and wraps the required structure\n * with a value if/as required/found.\n */\nexport class Option {\n  registry;\n  createdAtHash;\n  initialU8aLength;\n  isStorageFallback;\n  __internal__Type;\n  __internal__raw;\n  constructor(registry, typeName, value, {\n    definition,\n    setDefinition = identity\n  } = {}) {\n    const Type = definition || setDefinition(typeToConstructor(registry, typeName));\n    const decoded = isU8a(value) && value.length && !isCodec(value) ? value[0] === 0 ? new None(registry) : new Type(registry, value.subarray(1)) : decodeOption(registry, Type, value);\n    this.registry = registry;\n    this.__internal__Type = Type;\n    this.__internal__raw = decoded;\n    if (decoded?.initialU8aLength) {\n      this.initialU8aLength = 1 + decoded.initialU8aLength;\n    }\n  }\n  static with(Type) {\n    let definition;\n    const setDefinition = d => {\n      definition = d;\n      return d;\n    };\n    return class extends Option {\n      constructor(registry, value) {\n        super(registry, Type, value, {\n          definition,\n          setDefinition\n        });\n      }\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    // boolean byte (has value, doesn't have) along with wrapped length\n    return 1 + this.__internal__raw.encodedLength;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the Option has no value\n   */\n  get isEmpty() {\n    return this.isNone;\n  }\n  /**\n   * @description Checks if the Option has no value\n   */\n  get isNone() {\n    return this.__internal__raw instanceof None;\n  }\n  /**\n   * @description Checks if the Option has a value\n   */\n  get isSome() {\n    return !this.isNone;\n  }\n  /**\n   * @description The actual value for the Option\n   */\n  get value() {\n    return this.__internal__raw;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    if (other instanceof Option) {\n      return this.isSome === other.isSome && this.value.eq(other.value);\n    }\n    return this.value.eq(other);\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    if (this.isNone) {\n      return {\n        outer: [new Uint8Array([0])]\n      };\n    }\n    const {\n      inner,\n      outer = []\n    } = this.__internal__raw.inspect();\n    return {\n      inner,\n      outer: [new Uint8Array([1]), ...outer]\n    };\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex() {\n    // This attempts to align with the JSON encoding - actually in this case\n    // the isSome value is correct, however the `isNone` may be problematic\n    return this.isNone ? '0x' : u8aToHex(this.toU8a().subarray(1));\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExtended, disableAscii) {\n    return this.__internal__raw.toHuman(isExtended, disableAscii);\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    return this.isNone ? null : this.__internal__raw.toJSON();\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive(disableAscii) {\n    return this.isNone ? null : this.__internal__raw.toPrimitive(disableAscii);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType(isBare) {\n    const wrapped = this.registry.getClassName(this.__internal__Type) || new this.__internal__Type(this.registry).toRawType();\n    return isBare ? wrapped : `Option<${wrapped}>`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return this.__internal__raw.toString();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    if (isBare) {\n      return this.__internal__raw.toU8a(true);\n    }\n    const u8a = new Uint8Array(this.encodedLength);\n    if (this.isSome) {\n      u8a.set([1]);\n      u8a.set(this.__internal__raw.toU8a(), 1);\n    }\n    return u8a;\n  }\n  /**\n   * @description Returns the value that the Option represents (if available), throws if null\n   */\n  unwrap() {\n    if (this.isNone) {\n      throw new Error('Option: unwrapping a None value');\n    }\n    return this.__internal__raw;\n  }\n  /**\n   * @description Returns the value that the Option represents (if available) or defaultValue if none\n   * @param defaultValue The value to return if the option isNone\n   */\n  unwrapOr(defaultValue) {\n    return this.isSome ? this.unwrap() : defaultValue;\n  }\n  /**\n   * @description Returns the value that the Option represents (if available) or defaultValue if none\n   * @param defaultValue The value to return if the option isNone\n   */\n  unwrapOrDefault() {\n    return this.isSome ? this.unwrap() : new this.__internal__Type(this.registry);\n  }\n}","map":{"version":3,"names":["identity","isCodec","isNull","isU8a","isUndefined","u8aToHex","typeToConstructor","Null","None","toRawType","decodeOption","registry","Type","value","Option","isNone","length","subarray","createdAtHash","initialU8aLength","isStorageFallback","__internal__Type","__internal__raw","constructor","typeName","definition","setDefinition","decoded","with","d","encodedLength","hash","toU8a","isEmpty","isSome","eq","other","inspect","outer","Uint8Array","inner","toHex","toHuman","isExtended","disableAscii","toJSON","toPrimitive","isBare","wrapped","getClassName","toString","u8a","set","unwrap","Error","unwrapOr","defaultValue","unwrapOrDefault"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/base/Option.js"],"sourcesContent":["import { identity, isCodec, isNull, isU8a, isUndefined, u8aToHex } from '@polkadot/util';\nimport { typeToConstructor } from '../utils/index.js';\nimport { Null } from './Null.js';\nclass None extends Null {\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'None';\n    }\n}\n/** @internal */\nfunction decodeOption(registry, Type, value) {\n    if (value instanceof Type) {\n        // don't re-create, use as it (which also caters for derived types)\n        return value;\n    }\n    else if (value instanceof Option) {\n        if (value.value instanceof Type) {\n            // same instance, return it\n            return value.value;\n        }\n        else if (value.isNone) {\n            // internal is None, we are also none\n            return new None(registry);\n        }\n        // convert the actual value into known\n        return new Type(registry, value.value);\n    }\n    else if (isNull(value) || isUndefined(value) || value === '0x' || value instanceof None) {\n        // anything empty we pass as-is\n        return new None(registry);\n    }\n    else if (isU8a(value)) {\n        // the isU8a check happens last in the if-tree - since the wrapped value\n        // may be an instance of it, so Type and Option checks go in first\n        return !value.length || value[0] === 0\n            ? new None(registry)\n            : new Type(registry, value.subarray(1));\n    }\n    return new Type(registry, value);\n}\n/**\n * @name Option\n * @description\n * An Option is an optional field. Basically the first byte indicates that there is\n * is value to follow. If the byte is `1` there is an actual value. So the Option\n * implements that - decodes, checks for optionality and wraps the required structure\n * with a value if/as required/found.\n */\nexport class Option {\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    __internal__Type;\n    __internal__raw;\n    constructor(registry, typeName, value, { definition, setDefinition = identity } = {}) {\n        const Type = definition || setDefinition(typeToConstructor(registry, typeName));\n        const decoded = isU8a(value) && value.length && !isCodec(value)\n            ? value[0] === 0\n                ? new None(registry)\n                : new Type(registry, value.subarray(1))\n            : decodeOption(registry, Type, value);\n        this.registry = registry;\n        this.__internal__Type = Type;\n        this.__internal__raw = decoded;\n        if (decoded?.initialU8aLength) {\n            this.initialU8aLength = 1 + decoded.initialU8aLength;\n        }\n    }\n    static with(Type) {\n        let definition;\n        const setDefinition = (d) => {\n            definition = d;\n            return d;\n        };\n        return class extends Option {\n            constructor(registry, value) {\n                super(registry, Type, value, { definition, setDefinition });\n            }\n        };\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        // boolean byte (has value, doesn't have) along with wrapped length\n        return 1 + this.__internal__raw.encodedLength;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the Option has no value\n     */\n    get isEmpty() {\n        return this.isNone;\n    }\n    /**\n     * @description Checks if the Option has no value\n     */\n    get isNone() {\n        return this.__internal__raw instanceof None;\n    }\n    /**\n     * @description Checks if the Option has a value\n     */\n    get isSome() {\n        return !this.isNone;\n    }\n    /**\n     * @description The actual value for the Option\n     */\n    get value() {\n        return this.__internal__raw;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        if (other instanceof Option) {\n            return (this.isSome === other.isSome) && this.value.eq(other.value);\n        }\n        return this.value.eq(other);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        if (this.isNone) {\n            return { outer: [new Uint8Array([0])] };\n        }\n        const { inner, outer = [] } = this.__internal__raw.inspect();\n        return {\n            inner,\n            outer: [new Uint8Array([1]), ...outer]\n        };\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        // This attempts to align with the JSON encoding - actually in this case\n        // the isSome value is correct, however the `isNone` may be problematic\n        return this.isNone\n            ? '0x'\n            : u8aToHex(this.toU8a().subarray(1));\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExtended, disableAscii) {\n        return this.__internal__raw.toHuman(isExtended, disableAscii);\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return this.isNone\n            ? null\n            : this.__internal__raw.toJSON();\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive(disableAscii) {\n        return this.isNone\n            ? null\n            : this.__internal__raw.toPrimitive(disableAscii);\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType(isBare) {\n        const wrapped = this.registry.getClassName(this.__internal__Type) || new this.__internal__Type(this.registry).toRawType();\n        return isBare\n            ? wrapped\n            : `Option<${wrapped}>`;\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return this.__internal__raw.toString();\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        if (isBare) {\n            return this.__internal__raw.toU8a(true);\n        }\n        const u8a = new Uint8Array(this.encodedLength);\n        if (this.isSome) {\n            u8a.set([1]);\n            u8a.set(this.__internal__raw.toU8a(), 1);\n        }\n        return u8a;\n    }\n    /**\n     * @description Returns the value that the Option represents (if available), throws if null\n     */\n    unwrap() {\n        if (this.isNone) {\n            throw new Error('Option: unwrapping a None value');\n        }\n        return this.__internal__raw;\n    }\n    /**\n     * @description Returns the value that the Option represents (if available) or defaultValue if none\n     * @param defaultValue The value to return if the option isNone\n     */\n    unwrapOr(defaultValue) {\n        return this.isSome\n            ? this.unwrap()\n            : defaultValue;\n    }\n    /**\n     * @description Returns the value that the Option represents (if available) or defaultValue if none\n     * @param defaultValue The value to return if the option isNone\n     */\n    unwrapOrDefault() {\n        return this.isSome\n            ? this.unwrap()\n            : new this.__internal__Type(this.registry);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}