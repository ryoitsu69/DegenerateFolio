{"ast":null,"code":"import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\"use strict\";\nconst WGSL_TO_VERTEX_TYPES = {\n  f32: \"float32\",\n  \"vec2<f32>\": \"float32x2\",\n  \"vec3<f32>\": \"float32x3\",\n  \"vec4<f32>\": \"float32x4\",\n  vec2f: \"float32x2\",\n  vec3f: \"float32x3\",\n  vec4f: \"float32x4\",\n  i32: \"sint32\",\n  \"vec2<i32>\": \"sint32x2\",\n  \"vec3<i32>\": \"sint32x3\",\n  \"vec4<i32>\": \"sint32x4\",\n  u32: \"uint32\",\n  \"vec2<u32>\": \"uint32x2\",\n  \"vec3<u32>\": \"uint32x3\",\n  \"vec4<u32>\": \"uint32x4\",\n  bool: \"uint32\",\n  \"vec2<bool>\": \"uint32x2\",\n  \"vec3<bool>\": \"uint32x3\",\n  \"vec4<bool>\": \"uint32x4\"\n};\nfunction extractAttributesFromGpuProgram({\n  source,\n  entryPoint\n}) {\n  const results = {};\n  const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n  if (mainVertStart !== -1) {\n    const arrowFunctionStart = source.indexOf(\"->\", mainVertStart);\n    if (arrowFunctionStart !== -1) {\n      const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n      const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n      let match;\n      while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {\n        const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? \"float32\";\n        results[match[2]] = {\n          location: parseInt(match[1], 10),\n          format,\n          stride: getAttributeInfoFromFormat(format).stride,\n          offset: 0,\n          instance: false,\n          start: 0\n        };\n      }\n    }\n  }\n  return results;\n}\nexport { extractAttributesFromGpuProgram };","map":{"version":3,"names":["WGSL_TO_VERTEX_TYPES","f32","vec2f","vec3f","vec4f","i32","u32","bool","extractAttributesFromGpuProgram","source","entryPoint","results","mainVertStart","indexOf","arrowFunctionStart","functionArgsSubstring","substring","inputsRegex","match","exec","format","location","parseInt","stride","getAttributeInfoFromFormat","offset","instance","start"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.ts"],"sourcesContent":["import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { ExtractedAttributeData } from '../../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { VertexFormat } from '../../../shared/geometry/const';\nimport type { ProgramSource } from '../GpuProgram';\n\nconst WGSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    f32:  'float32',\n    'vec2<f32>': 'float32x2',\n    'vec3<f32>': 'float32x3',\n    'vec4<f32>': 'float32x4',\n    vec2f: 'float32x2',\n    vec3f: 'float32x3',\n    vec4f: 'float32x4',\n\n    i32: 'sint32',\n    'vec2<i32>': 'sint32x2',\n    'vec3<i32>': 'sint32x3',\n    'vec4<i32>': 'sint32x4',\n\n    u32: 'uint32',\n    'vec2<u32>': 'uint32x2',\n    'vec3<u32>': 'uint32x3',\n    'vec4<u32>': 'uint32x4',\n\n    bool: 'uint32',\n    'vec2<bool>': 'uint32x2',\n    'vec3<bool>': 'uint32x3',\n    'vec4<bool>': 'uint32x4',\n};\n\nexport function extractAttributesFromGpuProgram(\n    { source, entryPoint }: ProgramSource\n): Record<string, ExtractedAttributeData>\n{\n    const results: Record<string, ExtractedAttributeData> = {};\n\n    // Step 1: Find the start of the mainVert function using string methods\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n\n    if (mainVertStart !== -1)\n    {\n        // Step 2: Find the index of the next '->' after the start of the mainVert function\n        const arrowFunctionStart = source.indexOf('->', mainVertStart);\n\n        if (arrowFunctionStart !== -1)\n        {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n\n            // Apply the inputs regex directly to the trimmed string\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n\n            while ((match = inputsRegex.exec(functionArgsSubstring)) !== null)\n            {\n                const format = WGSL_TO_VERTEX_TYPES[match[3] as VertexFormat] ?? 'float32';\n\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format,\n                    stride: getAttributeInfoFromFormat(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0,\n                };\n            }\n        }\n    }\n\n    return results;\n}\n"],"mappings":";;AAMA,MAAMA,oBAAqD;EAEvDC,GAAM;EACN,WAAa;EACb,WAAa;EACb,WAAa;EACbC,KAAO;EACPC,KAAO;EACPC,KAAO;EAEPC,GAAK;EACL,WAAa;EACb,WAAa;EACb,WAAa;EAEbC,GAAK;EACL,WAAa;EACb,WAAa;EACb,WAAa;EAEbC,IAAM;EACN,YAAc;EACd,YAAc;EACd,YAAc;AAClB;AAEO,SAASC,+BACZA,CAAA;EAAEC,MAAQ;EAAAC;AAAA,CAEd;EACI,MAAMC,OAAA,GAAkD,EAAC;EAGzD,MAAMC,aAAgB,GAAAH,MAAA,CAAOI,OAAQ,OAAMH,UAAY;EAEvD,IAAIE,aAAA,KAAkB,CACtB;IAEI,MAAME,kBAAqB,GAAAL,MAAA,CAAOI,OAAQ,OAAMD,aAAa;IAE7D,IAAIE,kBAAA,KAAuB,CAC3B;MACI,MAAMC,qBAAwB,GAAAN,MAAA,CAAOO,SAAU,CAAAJ,aAAA,EAAeE,kBAAkB;MAGhF,MAAMG,WAAc;MAChB,IAAAC,KAAA;MAEJ,QAAQA,KAAQ,GAAAD,WAAA,CAAYE,IAAK,CAAAJ,qBAAqB,OAAO,IAC7D;QACI,MAAMK,MAAS,GAAApB,oBAAA,CAAqBkB,KAAM,EAAC,CAAiB,CAAK;QAEzDP,OAAA,CAAAO,KAAA,CAAM,CAAC,CAAC,CAAI;UAChBG,QAAU,EAAAC,QAAA,CAASJ,KAAM,EAAC,GAAG,EAAE;UAC/BE,MAAA;UACAG,MAAA,EAAQC,0BAA2B,CAAAJ,MAAM,CAAE,CAAAG,MAAA;UAC3CE,MAAQ;UACRC,QAAU;UACVC,KAAO;QAAA,CACX;MAAA;IACJ;EACJ;EAGG,OAAAhB,OAAA;AACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}