{"ast":null,"code":"import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { BN, BN_ZERO, bnMax, bnMin, isFunction, objectSpread } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nconst VESTING_ID = '0x76657374696e6720';\nfunction calcLocked(api, bestNumber, locks) {\n  let lockedBalance = api.registry.createType('Balance');\n  let lockedBreakdown = [];\n  let vestingLocked = api.registry.createType('Balance');\n  let allLocked = false;\n  if (Array.isArray(locks)) {\n    // only get the locks that are valid until passed the current block\n    lockedBreakdown = locks.filter(_ref => {\n      let {\n        until\n      } = _ref;\n      return !until || bestNumber && until.gt(bestNumber);\n    });\n    allLocked = lockedBreakdown.some(_ref2 => {\n      let {\n        amount\n      } = _ref2;\n      return amount && amount.isMax();\n    });\n    vestingLocked = api.registry.createType('Balance', lockedBreakdown.filter(_ref3 => {\n      let {\n        id\n      } = _ref3;\n      return id.eq(VESTING_ID);\n    }).reduce((result, _ref4) => {\n      let {\n        amount\n      } = _ref4;\n      return result.iadd(amount);\n    }, new BN(0)));\n    // get the maximum of the locks according to https://github.com/paritytech/substrate/blob/master/srml/balances/src/lib.rs#L699\n    const notAll = lockedBreakdown.filter(_ref5 => {\n      let {\n        amount\n      } = _ref5;\n      return amount && !amount.isMax();\n    });\n    if (notAll.length) {\n      lockedBalance = api.registry.createType('Balance', bnMax(...notAll.map(_ref6 => {\n        let {\n          amount\n        } = _ref6;\n        return amount;\n      })));\n    }\n  }\n  return {\n    allLocked,\n    lockedBalance,\n    lockedBreakdown,\n    vestingLocked\n  };\n}\nfunction calcShared(api, bestNumber, data, locks) {\n  const {\n    allLocked,\n    lockedBalance,\n    lockedBreakdown,\n    vestingLocked\n  } = calcLocked(api, bestNumber, locks);\n  return objectSpread({}, data, {\n    availableBalance: api.registry.createType('Balance', allLocked ? 0 : bnMax(new BN(0), data !== null && data !== void 0 && data.freeBalance ? data.freeBalance.sub(lockedBalance) : new BN(0))),\n    lockedBalance,\n    lockedBreakdown,\n    vestingLocked\n  });\n}\nfunction calcVesting(bestNumber, shared, _vesting) {\n  // Calculate the vesting balances,\n  //  - offset = balance locked at startingBlock\n  //  - perBlock is the unlock amount\n  const vesting = _vesting || [];\n  const isVesting = !shared.vestingLocked.isZero();\n  const vestedBalances = vesting.map(_ref7 => {\n    let {\n      locked,\n      perBlock,\n      startingBlock\n    } = _ref7;\n    return bestNumber.gt(startingBlock) ? bnMin(locked, perBlock.mul(bestNumber.sub(startingBlock))) : BN_ZERO;\n  });\n  const vestedBalance = vestedBalances.reduce((all, value) => all.iadd(value), new BN(0));\n  const vestingTotal = vesting.reduce((all, _ref8) => {\n    let {\n      locked\n    } = _ref8;\n    return all.iadd(locked);\n  }, new BN(0));\n  return {\n    isVesting,\n    vestedBalance,\n    vestedClaimable: isVesting ? shared.vestingLocked.sub(vestingTotal.sub(vestedBalance)) : BN_ZERO,\n    vesting: vesting.map((_ref9, index) => {\n      let {\n        locked,\n        perBlock,\n        startingBlock\n      } = _ref9;\n      return {\n        endBlock: locked.div(perBlock).iadd(startingBlock),\n        locked,\n        perBlock,\n        startingBlock,\n        vested: vestedBalances[index]\n      };\n    }).filter(_ref10 => {\n      let {\n        locked\n      } = _ref10;\n      return !locked.isZero();\n    }),\n    vestingTotal\n  };\n}\nfunction calcBalances(api, result) {\n  const [data, [vesting, allLocks, namedReserves], bestNumber] = result;\n  const shared = calcShared(api, bestNumber, data, allLocks[0]);\n  return objectSpread(shared, calcVesting(bestNumber, shared, vesting), {\n    accountId: data.accountId,\n    accountNonce: data.accountNonce,\n    additional: allLocks.slice(1).map((l, index) => calcShared(api, bestNumber, data.additional[index], l)),\n    namedReserves\n  });\n}\nfunction queryOld(api, accountId) {\n  return combineLatest([api.query.balances.locks(accountId), api.query.balances['vesting'](accountId)]).pipe(map(_ref11 => {\n    let [locks, optVesting] = _ref11;\n    let vestingNew = null;\n    if (optVesting.isSome) {\n      const {\n        offset: locked,\n        perBlock,\n        startingBlock\n      } = optVesting.unwrap();\n      vestingNew = api.registry.createType('VestingInfo', {\n        locked,\n        perBlock,\n        startingBlock\n      });\n    }\n    return [vestingNew ? [vestingNew] : null, [locks], []];\n  }));\n}\nconst isNonNullable = nullable => !!nullable;\nfunction createCalls(calls) {\n  return [calls.map(c => !c), calls.filter(isNonNullable)];\n}\nfunction queryCurrent(api, accountId) {\n  var _api$query$vesting;\n  let balanceInstances = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['balances'];\n  const [lockEmpty, lockQueries] = createCalls(balanceInstances.map(m => {\n    var _api$derive$m, _api$query$m;\n    return ((_api$derive$m = api.derive[m]) === null || _api$derive$m === void 0 ? void 0 : _api$derive$m.customLocks) || ((_api$query$m = api.query[m]) === null || _api$query$m === void 0 ? void 0 : _api$query$m.locks);\n  }));\n  const [reserveEmpty, reserveQueries] = createCalls(balanceInstances.map(m => {\n    var _api$query$m2;\n    return (_api$query$m2 = api.query[m]) === null || _api$query$m2 === void 0 ? void 0 : _api$query$m2.reserves;\n  }));\n  return combineLatest([(_api$query$vesting = api.query.vesting) !== null && _api$query$vesting !== void 0 && _api$query$vesting.vesting ? api.query.vesting.vesting(accountId) : of(api.registry.createType('Option<VestingInfo>')), lockQueries.length ? combineLatest(lockQueries.map(c => c(accountId))) : of([]), reserveQueries.length ? combineLatest(reserveQueries.map(c => c(accountId))) : of([])]).pipe(map(_ref12 => {\n    let [opt, locks, reserves] = _ref12;\n    let offsetLock = -1;\n    let offsetReserve = -1;\n    const vesting = opt.unwrapOr(null);\n    return [vesting ? Array.isArray(vesting) ? vesting : [vesting] : null, lockEmpty.map(e => e ? api.registry.createType('Vec<BalanceLock>') : locks[++offsetLock]), reserveEmpty.map(e => e ? api.registry.createType('Vec<PalletBalancesReserveData>') : reserves[++offsetReserve])];\n  }));\n}\n/**\n * @name all\n * @param {( AccountIndex | AccountId | Address | string )} address - An accounts Id in different formats.\n * @returns An object containing the results of various balance queries\n * @example\n * <BR>\n *\n * ```javascript\n * const ALICE = 'F7Hs';\n *\n * api.derive.balances.all(ALICE, ({ accountId, lockedBalance }) => {\n *   console.log(`The account ${accountId} has a locked balance ${lockedBalance} units.`);\n * });\n * ```\n */\nexport function all(instanceId, api) {\n  const balanceInstances = api.registry.getModuleInstances(api.runtimeVersion.specName, 'balances');\n  return memo(instanceId, address => {\n    var _api$query$system, _api$query$balances;\n    return combineLatest([api.derive.balances.account(address), isFunction((_api$query$system = api.query.system) === null || _api$query$system === void 0 ? void 0 : _api$query$system.account) || isFunction((_api$query$balances = api.query.balances) === null || _api$query$balances === void 0 ? void 0 : _api$query$balances.account) ? queryCurrent(api, address, balanceInstances) : queryOld(api, address)]).pipe(switchMap(_ref13 => {\n      let [account, locks] = _ref13;\n      return combineLatest([of(account), of(locks), api.derive.chain.bestNumber()]);\n    }), map(result => calcBalances(api, result)));\n  });\n}","map":{"version":3,"names":["combineLatest","map","of","switchMap","BN","BN_ZERO","bnMax","bnMin","isFunction","objectSpread","memo","VESTING_ID","calcLocked","api","bestNumber","locks","lockedBalance","registry","createType","lockedBreakdown","vestingLocked","allLocked","Array","isArray","filter","_ref","until","gt","some","_ref2","amount","isMax","_ref3","id","eq","reduce","result","_ref4","iadd","notAll","_ref5","length","_ref6","calcShared","data","availableBalance","freeBalance","sub","calcVesting","shared","_vesting","vesting","isVesting","isZero","vestedBalances","_ref7","locked","perBlock","startingBlock","mul","vestedBalance","all","value","vestingTotal","_ref8","vestedClaimable","_ref9","index","endBlock","div","vested","_ref10","calcBalances","allLocks","namedReserves","accountId","accountNonce","additional","slice","l","queryOld","query","balances","pipe","_ref11","optVesting","vestingNew","isSome","offset","unwrap","isNonNullable","nullable","createCalls","calls","c","queryCurrent","_api$query$vesting","balanceInstances","arguments","undefined","lockEmpty","lockQueries","m","_api$derive$m","_api$query$m","derive","customLocks","reserveEmpty","reserveQueries","_api$query$m2","reserves","_ref12","opt","offsetLock","offsetReserve","unwrapOr","e","instanceId","getModuleInstances","runtimeVersion","specName","address","_api$query$system","_api$query$balances","account","system","_ref13","chain"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api-derive/balances/all.js"],"sourcesContent":["import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { BN, BN_ZERO, bnMax, bnMin, isFunction, objectSpread } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nconst VESTING_ID = '0x76657374696e6720';\nfunction calcLocked(api, bestNumber, locks) {\n    let lockedBalance = api.registry.createType('Balance');\n    let lockedBreakdown = [];\n    let vestingLocked = api.registry.createType('Balance');\n    let allLocked = false;\n    if (Array.isArray(locks)) {\n        // only get the locks that are valid until passed the current block\n        lockedBreakdown = locks.filter(({ until }) => !until || (bestNumber && until.gt(bestNumber)));\n        allLocked = lockedBreakdown.some(({ amount }) => amount && amount.isMax());\n        vestingLocked = api.registry.createType('Balance', lockedBreakdown.filter(({ id }) => id.eq(VESTING_ID)).reduce((result, { amount }) => result.iadd(amount), new BN(0)));\n        // get the maximum of the locks according to https://github.com/paritytech/substrate/blob/master/srml/balances/src/lib.rs#L699\n        const notAll = lockedBreakdown.filter(({ amount }) => amount && !amount.isMax());\n        if (notAll.length) {\n            lockedBalance = api.registry.createType('Balance', bnMax(...notAll.map(({ amount }) => amount)));\n        }\n    }\n    return { allLocked, lockedBalance, lockedBreakdown, vestingLocked };\n}\nfunction calcShared(api, bestNumber, data, locks) {\n    const { allLocked, lockedBalance, lockedBreakdown, vestingLocked } = calcLocked(api, bestNumber, locks);\n    return objectSpread({}, data, {\n        availableBalance: api.registry.createType('Balance', allLocked ? 0 : bnMax(new BN(0), data?.freeBalance ? data.freeBalance.sub(lockedBalance) : new BN(0))),\n        lockedBalance,\n        lockedBreakdown,\n        vestingLocked\n    });\n}\nfunction calcVesting(bestNumber, shared, _vesting) {\n    // Calculate the vesting balances,\n    //  - offset = balance locked at startingBlock\n    //  - perBlock is the unlock amount\n    const vesting = _vesting || [];\n    const isVesting = !shared.vestingLocked.isZero();\n    const vestedBalances = vesting.map(({ locked, perBlock, startingBlock }) => bestNumber.gt(startingBlock)\n        ? bnMin(locked, perBlock.mul(bestNumber.sub(startingBlock)))\n        : BN_ZERO);\n    const vestedBalance = vestedBalances.reduce((all, value) => all.iadd(value), new BN(0));\n    const vestingTotal = vesting.reduce((all, { locked }) => all.iadd(locked), new BN(0));\n    return {\n        isVesting,\n        vestedBalance,\n        vestedClaimable: isVesting\n            ? shared.vestingLocked.sub(vestingTotal.sub(vestedBalance))\n            : BN_ZERO,\n        vesting: vesting\n            .map(({ locked, perBlock, startingBlock }, index) => ({\n            endBlock: locked.div(perBlock).iadd(startingBlock),\n            locked,\n            perBlock,\n            startingBlock,\n            vested: vestedBalances[index]\n        }))\n            .filter(({ locked }) => !locked.isZero()),\n        vestingTotal\n    };\n}\nfunction calcBalances(api, result) {\n    const [data, [vesting, allLocks, namedReserves], bestNumber] = result;\n    const shared = calcShared(api, bestNumber, data, allLocks[0]);\n    return objectSpread(shared, calcVesting(bestNumber, shared, vesting), {\n        accountId: data.accountId,\n        accountNonce: data.accountNonce,\n        additional: allLocks\n            .slice(1)\n            .map((l, index) => calcShared(api, bestNumber, data.additional[index], l)),\n        namedReserves\n    });\n}\nfunction queryOld(api, accountId) {\n    return combineLatest([\n        api.query.balances.locks(accountId),\n        api.query.balances['vesting'](accountId)\n    ]).pipe(map(([locks, optVesting]) => {\n        let vestingNew = null;\n        if (optVesting.isSome) {\n            const { offset: locked, perBlock, startingBlock } = optVesting.unwrap();\n            vestingNew = api.registry.createType('VestingInfo', { locked, perBlock, startingBlock });\n        }\n        return [\n            vestingNew\n                ? [vestingNew]\n                : null,\n            [locks],\n            []\n        ];\n    }));\n}\nconst isNonNullable = (nullable) => !!nullable;\nfunction createCalls(calls) {\n    return [\n        calls.map((c) => !c),\n        calls.filter(isNonNullable)\n    ];\n}\nfunction queryCurrent(api, accountId, balanceInstances = ['balances']) {\n    const [lockEmpty, lockQueries] = createCalls(balanceInstances.map((m) => api.derive[m]?.customLocks || api.query[m]?.locks));\n    const [reserveEmpty, reserveQueries] = createCalls(balanceInstances.map((m) => api.query[m]?.reserves));\n    return combineLatest([\n        api.query.vesting?.vesting\n            ? api.query.vesting.vesting(accountId)\n            : of(api.registry.createType('Option<VestingInfo>')),\n        lockQueries.length\n            ? combineLatest(lockQueries.map((c) => c(accountId)))\n            : of([]),\n        reserveQueries.length\n            ? combineLatest(reserveQueries.map((c) => c(accountId)))\n            : of([])\n    ]).pipe(map(([opt, locks, reserves]) => {\n        let offsetLock = -1;\n        let offsetReserve = -1;\n        const vesting = opt.unwrapOr(null);\n        return [\n            vesting\n                ? Array.isArray(vesting)\n                    ? vesting\n                    : [vesting]\n                : null,\n            lockEmpty.map((e) => e ? api.registry.createType('Vec<BalanceLock>') : locks[++offsetLock]),\n            reserveEmpty.map((e) => e ? api.registry.createType('Vec<PalletBalancesReserveData>') : reserves[++offsetReserve])\n        ];\n    }));\n}\n/**\n * @name all\n * @param {( AccountIndex | AccountId | Address | string )} address - An accounts Id in different formats.\n * @returns An object containing the results of various balance queries\n * @example\n * <BR>\n *\n * ```javascript\n * const ALICE = 'F7Hs';\n *\n * api.derive.balances.all(ALICE, ({ accountId, lockedBalance }) => {\n *   console.log(`The account ${accountId} has a locked balance ${lockedBalance} units.`);\n * });\n * ```\n */\nexport function all(instanceId, api) {\n    const balanceInstances = api.registry.getModuleInstances(api.runtimeVersion.specName, 'balances');\n    return memo(instanceId, (address) => combineLatest([\n        api.derive.balances.account(address),\n        isFunction(api.query.system?.account) || isFunction(api.query.balances?.account)\n            ? queryCurrent(api, address, balanceInstances)\n            : queryOld(api, address)\n    ]).pipe(switchMap(([account, locks]) => combineLatest([\n        of(account),\n        of(locks),\n        api.derive.chain.bestNumber()\n    ])), map((result) => calcBalances(api, result))));\n}\n"],"mappings":"AAAA,SAASA,aAAa,EAAEC,GAAG,EAAEC,EAAE,EAAEC,SAAS,QAAQ,MAAM;AACxD,SAASC,EAAE,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,EAAEC,UAAU,EAAEC,YAAY,QAAQ,gBAAgB;AACpF,SAASC,IAAI,QAAQ,kBAAkB;AACvC,MAAMC,UAAU,GAAG,oBAAoB;AACvC,SAASC,UAAUA,CAACC,GAAG,EAAEC,UAAU,EAAEC,KAAK,EAAE;EACxC,IAAIC,aAAa,GAAGH,GAAG,CAACI,QAAQ,CAACC,UAAU,CAAC,SAAS,CAAC;EACtD,IAAIC,eAAe,GAAG,EAAE;EACxB,IAAIC,aAAa,GAAGP,GAAG,CAACI,QAAQ,CAACC,UAAU,CAAC,SAAS,CAAC;EACtD,IAAIG,SAAS,GAAG,KAAK;EACrB,IAAIC,KAAK,CAACC,OAAO,CAACR,KAAK,CAAC,EAAE;IACtB;IACAI,eAAe,GAAGJ,KAAK,CAACS,MAAM,CAACC,IAAA;MAAA,IAAC;QAAEC;MAAM,CAAC,GAAAD,IAAA;MAAA,OAAK,CAACC,KAAK,IAAKZ,UAAU,IAAIY,KAAK,CAACC,EAAE,CAACb,UAAU,CAAE;IAAA,EAAC;IAC7FO,SAAS,GAAGF,eAAe,CAACS,IAAI,CAACC,KAAA;MAAA,IAAC;QAAEC;MAAO,CAAC,GAAAD,KAAA;MAAA,OAAKC,MAAM,IAAIA,MAAM,CAACC,KAAK,CAAC,CAAC;IAAA,EAAC;IAC1EX,aAAa,GAAGP,GAAG,CAACI,QAAQ,CAACC,UAAU,CAAC,SAAS,EAAEC,eAAe,CAACK,MAAM,CAACQ,KAAA;MAAA,IAAC;QAAEC;MAAG,CAAC,GAAAD,KAAA;MAAA,OAAKC,EAAE,CAACC,EAAE,CAACvB,UAAU,CAAC;IAAA,EAAC,CAACwB,MAAM,CAAC,CAACC,MAAM,EAAAC,KAAA;MAAA,IAAE;QAAEP;MAAO,CAAC,GAAAO,KAAA;MAAA,OAAKD,MAAM,CAACE,IAAI,CAACR,MAAM,CAAC;IAAA,GAAE,IAAI1B,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IACxK;IACA,MAAMmC,MAAM,GAAGpB,eAAe,CAACK,MAAM,CAACgB,KAAA;MAAA,IAAC;QAAEV;MAAO,CAAC,GAAAU,KAAA;MAAA,OAAKV,MAAM,IAAI,CAACA,MAAM,CAACC,KAAK,CAAC,CAAC;IAAA,EAAC;IAChF,IAAIQ,MAAM,CAACE,MAAM,EAAE;MACfzB,aAAa,GAAGH,GAAG,CAACI,QAAQ,CAACC,UAAU,CAAC,SAAS,EAAEZ,KAAK,CAAC,GAAGiC,MAAM,CAACtC,GAAG,CAACyC,KAAA;QAAA,IAAC;UAAEZ;QAAO,CAAC,GAAAY,KAAA;QAAA,OAAKZ,MAAM;MAAA,EAAC,CAAC,CAAC;IACpG;EACJ;EACA,OAAO;IAAET,SAAS;IAAEL,aAAa;IAAEG,eAAe;IAAEC;EAAc,CAAC;AACvE;AACA,SAASuB,UAAUA,CAAC9B,GAAG,EAAEC,UAAU,EAAE8B,IAAI,EAAE7B,KAAK,EAAE;EAC9C,MAAM;IAAEM,SAAS;IAAEL,aAAa;IAAEG,eAAe;IAAEC;EAAc,CAAC,GAAGR,UAAU,CAACC,GAAG,EAAEC,UAAU,EAAEC,KAAK,CAAC;EACvG,OAAON,YAAY,CAAC,CAAC,CAAC,EAAEmC,IAAI,EAAE;IAC1BC,gBAAgB,EAAEhC,GAAG,CAACI,QAAQ,CAACC,UAAU,CAAC,SAAS,EAAEG,SAAS,GAAG,CAAC,GAAGf,KAAK,CAAC,IAAIF,EAAE,CAAC,CAAC,CAAC,EAAEwC,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEE,WAAW,GAAGF,IAAI,CAACE,WAAW,CAACC,GAAG,CAAC/B,aAAa,CAAC,GAAG,IAAIZ,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3JY,aAAa;IACbG,eAAe;IACfC;EACJ,CAAC,CAAC;AACN;AACA,SAAS4B,WAAWA,CAAClC,UAAU,EAAEmC,MAAM,EAAEC,QAAQ,EAAE;EAC/C;EACA;EACA;EACA,MAAMC,OAAO,GAAGD,QAAQ,IAAI,EAAE;EAC9B,MAAME,SAAS,GAAG,CAACH,MAAM,CAAC7B,aAAa,CAACiC,MAAM,CAAC,CAAC;EAChD,MAAMC,cAAc,GAAGH,OAAO,CAAClD,GAAG,CAACsD,KAAA;IAAA,IAAC;MAAEC,MAAM;MAAEC,QAAQ;MAAEC;IAAc,CAAC,GAAAH,KAAA;IAAA,OAAKzC,UAAU,CAACa,EAAE,CAAC+B,aAAa,CAAC,GAClGnD,KAAK,CAACiD,MAAM,EAAEC,QAAQ,CAACE,GAAG,CAAC7C,UAAU,CAACiC,GAAG,CAACW,aAAa,CAAC,CAAC,CAAC,GAC1DrD,OAAO;EAAA,EAAC;EACd,MAAMuD,aAAa,GAAGN,cAAc,CAACnB,MAAM,CAAC,CAAC0B,GAAG,EAAEC,KAAK,KAAKD,GAAG,CAACvB,IAAI,CAACwB,KAAK,CAAC,EAAE,IAAI1D,EAAE,CAAC,CAAC,CAAC,CAAC;EACvF,MAAM2D,YAAY,GAAGZ,OAAO,CAAChB,MAAM,CAAC,CAAC0B,GAAG,EAAAG,KAAA;IAAA,IAAE;MAAER;IAAO,CAAC,GAAAQ,KAAA;IAAA,OAAKH,GAAG,CAACvB,IAAI,CAACkB,MAAM,CAAC;EAAA,GAAE,IAAIpD,EAAE,CAAC,CAAC,CAAC,CAAC;EACrF,OAAO;IACHgD,SAAS;IACTQ,aAAa;IACbK,eAAe,EAAEb,SAAS,GACpBH,MAAM,CAAC7B,aAAa,CAAC2B,GAAG,CAACgB,YAAY,CAAChB,GAAG,CAACa,aAAa,CAAC,CAAC,GACzDvD,OAAO;IACb8C,OAAO,EAAEA,OAAO,CACXlD,GAAG,CAAC,CAAAiE,KAAA,EAAsCC,KAAK;MAAA,IAA1C;QAAEX,MAAM;QAAEC,QAAQ;QAAEC;MAAc,CAAC,GAAAQ,KAAA;MAAA,OAAa;QACtDE,QAAQ,EAAEZ,MAAM,CAACa,GAAG,CAACZ,QAAQ,CAAC,CAACnB,IAAI,CAACoB,aAAa,CAAC;QAClDF,MAAM;QACNC,QAAQ;QACRC,aAAa;QACbY,MAAM,EAAEhB,cAAc,CAACa,KAAK;MAChC,CAAC;IAAA,CAAC,CAAC,CACE3C,MAAM,CAAC+C,MAAA;MAAA,IAAC;QAAEf;MAAO,CAAC,GAAAe,MAAA;MAAA,OAAK,CAACf,MAAM,CAACH,MAAM,CAAC,CAAC;IAAA,EAAC;IAC7CU;EACJ,CAAC;AACL;AACA,SAASS,YAAYA,CAAC3D,GAAG,EAAEuB,MAAM,EAAE;EAC/B,MAAM,CAACQ,IAAI,EAAE,CAACO,OAAO,EAAEsB,QAAQ,EAAEC,aAAa,CAAC,EAAE5D,UAAU,CAAC,GAAGsB,MAAM;EACrE,MAAMa,MAAM,GAAGN,UAAU,CAAC9B,GAAG,EAAEC,UAAU,EAAE8B,IAAI,EAAE6B,QAAQ,CAAC,CAAC,CAAC,CAAC;EAC7D,OAAOhE,YAAY,CAACwC,MAAM,EAAED,WAAW,CAAClC,UAAU,EAAEmC,MAAM,EAAEE,OAAO,CAAC,EAAE;IAClEwB,SAAS,EAAE/B,IAAI,CAAC+B,SAAS;IACzBC,YAAY,EAAEhC,IAAI,CAACgC,YAAY;IAC/BC,UAAU,EAAEJ,QAAQ,CACfK,KAAK,CAAC,CAAC,CAAC,CACR7E,GAAG,CAAC,CAAC8E,CAAC,EAAEZ,KAAK,KAAKxB,UAAU,CAAC9B,GAAG,EAAEC,UAAU,EAAE8B,IAAI,CAACiC,UAAU,CAACV,KAAK,CAAC,EAAEY,CAAC,CAAC,CAAC;IAC9EL;EACJ,CAAC,CAAC;AACN;AACA,SAASM,QAAQA,CAACnE,GAAG,EAAE8D,SAAS,EAAE;EAC9B,OAAO3E,aAAa,CAAC,CACjBa,GAAG,CAACoE,KAAK,CAACC,QAAQ,CAACnE,KAAK,CAAC4D,SAAS,CAAC,EACnC9D,GAAG,CAACoE,KAAK,CAACC,QAAQ,CAAC,SAAS,CAAC,CAACP,SAAS,CAAC,CAC3C,CAAC,CAACQ,IAAI,CAAClF,GAAG,CAACmF,MAAA,IAAyB;IAAA,IAAxB,CAACrE,KAAK,EAAEsE,UAAU,CAAC,GAAAD,MAAA;IAC5B,IAAIE,UAAU,GAAG,IAAI;IACrB,IAAID,UAAU,CAACE,MAAM,EAAE;MACnB,MAAM;QAAEC,MAAM,EAAEhC,MAAM;QAAEC,QAAQ;QAAEC;MAAc,CAAC,GAAG2B,UAAU,CAACI,MAAM,CAAC,CAAC;MACvEH,UAAU,GAAGzE,GAAG,CAACI,QAAQ,CAACC,UAAU,CAAC,aAAa,EAAE;QAAEsC,MAAM;QAAEC,QAAQ;QAAEC;MAAc,CAAC,CAAC;IAC5F;IACA,OAAO,CACH4B,UAAU,GACJ,CAACA,UAAU,CAAC,GACZ,IAAI,EACV,CAACvE,KAAK,CAAC,EACP,EAAE,CACL;EACL,CAAC,CAAC,CAAC;AACP;AACA,MAAM2E,aAAa,GAAIC,QAAQ,IAAK,CAAC,CAACA,QAAQ;AAC9C,SAASC,WAAWA,CAACC,KAAK,EAAE;EACxB,OAAO,CACHA,KAAK,CAAC5F,GAAG,CAAE6F,CAAC,IAAK,CAACA,CAAC,CAAC,EACpBD,KAAK,CAACrE,MAAM,CAACkE,aAAa,CAAC,CAC9B;AACL;AACA,SAASK,YAAYA,CAAClF,GAAG,EAAE8D,SAAS,EAAmC;EAAA,IAAAqB,kBAAA;EAAA,IAAjCC,gBAAgB,GAAAC,SAAA,CAAAzD,MAAA,QAAAyD,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC,UAAU,CAAC;EACjE,MAAM,CAACE,SAAS,EAAEC,WAAW,CAAC,GAAGT,WAAW,CAACK,gBAAgB,CAAChG,GAAG,CAAEqG,CAAC;IAAA,IAAAC,aAAA,EAAAC,YAAA;IAAA,OAAK,EAAAD,aAAA,GAAA1F,GAAG,CAAC4F,MAAM,CAACH,CAAC,CAAC,cAAAC,aAAA,uBAAbA,aAAA,CAAeG,WAAW,OAAAF,YAAA,GAAI3F,GAAG,CAACoE,KAAK,CAACqB,CAAC,CAAC,cAAAE,YAAA,uBAAZA,YAAA,CAAczF,KAAK;EAAA,EAAC,CAAC;EAC5H,MAAM,CAAC4F,YAAY,EAAEC,cAAc,CAAC,GAAGhB,WAAW,CAACK,gBAAgB,CAAChG,GAAG,CAAEqG,CAAC;IAAA,IAAAO,aAAA;IAAA,QAAAA,aAAA,GAAKhG,GAAG,CAACoE,KAAK,CAACqB,CAAC,CAAC,cAAAO,aAAA,uBAAZA,aAAA,CAAcC,QAAQ;EAAA,EAAC,CAAC;EACvG,OAAO9G,aAAa,CAAC,CACjB,CAAAgG,kBAAA,GAAAnF,GAAG,CAACoE,KAAK,CAAC9B,OAAO,cAAA6C,kBAAA,eAAjBA,kBAAA,CAAmB7C,OAAO,GACpBtC,GAAG,CAACoE,KAAK,CAAC9B,OAAO,CAACA,OAAO,CAACwB,SAAS,CAAC,GACpCzE,EAAE,CAACW,GAAG,CAACI,QAAQ,CAACC,UAAU,CAAC,qBAAqB,CAAC,CAAC,EACxDmF,WAAW,CAAC5D,MAAM,GACZzC,aAAa,CAACqG,WAAW,CAACpG,GAAG,CAAE6F,CAAC,IAAKA,CAAC,CAACnB,SAAS,CAAC,CAAC,CAAC,GACnDzE,EAAE,CAAC,EAAE,CAAC,EACZ0G,cAAc,CAACnE,MAAM,GACfzC,aAAa,CAAC4G,cAAc,CAAC3G,GAAG,CAAE6F,CAAC,IAAKA,CAAC,CAACnB,SAAS,CAAC,CAAC,CAAC,GACtDzE,EAAE,CAAC,EAAE,CAAC,CACf,CAAC,CAACiF,IAAI,CAAClF,GAAG,CAAC8G,MAAA,IAA4B;IAAA,IAA3B,CAACC,GAAG,EAAEjG,KAAK,EAAE+F,QAAQ,CAAC,GAAAC,MAAA;IAC/B,IAAIE,UAAU,GAAG,CAAC,CAAC;IACnB,IAAIC,aAAa,GAAG,CAAC,CAAC;IACtB,MAAM/D,OAAO,GAAG6D,GAAG,CAACG,QAAQ,CAAC,IAAI,CAAC;IAClC,OAAO,CACHhE,OAAO,GACD7B,KAAK,CAACC,OAAO,CAAC4B,OAAO,CAAC,GAClBA,OAAO,GACP,CAACA,OAAO,CAAC,GACb,IAAI,EACViD,SAAS,CAACnG,GAAG,CAAEmH,CAAC,IAAKA,CAAC,GAAGvG,GAAG,CAACI,QAAQ,CAACC,UAAU,CAAC,kBAAkB,CAAC,GAAGH,KAAK,CAAC,EAAEkG,UAAU,CAAC,CAAC,EAC3FN,YAAY,CAAC1G,GAAG,CAAEmH,CAAC,IAAKA,CAAC,GAAGvG,GAAG,CAACI,QAAQ,CAACC,UAAU,CAAC,gCAAgC,CAAC,GAAG4F,QAAQ,CAAC,EAAEI,aAAa,CAAC,CAAC,CACrH;EACL,CAAC,CAAC,CAAC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASrD,GAAGA,CAACwD,UAAU,EAAExG,GAAG,EAAE;EACjC,MAAMoF,gBAAgB,GAAGpF,GAAG,CAACI,QAAQ,CAACqG,kBAAkB,CAACzG,GAAG,CAAC0G,cAAc,CAACC,QAAQ,EAAE,UAAU,CAAC;EACjG,OAAO9G,IAAI,CAAC2G,UAAU,EAAGI,OAAO;IAAA,IAAAC,iBAAA,EAAAC,mBAAA;IAAA,OAAK3H,aAAa,CAAC,CAC/Ca,GAAG,CAAC4F,MAAM,CAACvB,QAAQ,CAAC0C,OAAO,CAACH,OAAO,CAAC,EACpCjH,UAAU,EAAAkH,iBAAA,GAAC7G,GAAG,CAACoE,KAAK,CAAC4C,MAAM,cAAAH,iBAAA,uBAAhBA,iBAAA,CAAkBE,OAAO,CAAC,IAAIpH,UAAU,EAAAmH,mBAAA,GAAC9G,GAAG,CAACoE,KAAK,CAACC,QAAQ,cAAAyC,mBAAA,uBAAlBA,mBAAA,CAAoBC,OAAO,CAAC,GAC1E7B,YAAY,CAAClF,GAAG,EAAE4G,OAAO,EAAExB,gBAAgB,CAAC,GAC5CjB,QAAQ,CAACnE,GAAG,EAAE4G,OAAO,CAAC,CAC/B,CAAC,CAACtC,IAAI,CAAChF,SAAS,CAAC2H,MAAA;MAAA,IAAC,CAACF,OAAO,EAAE7G,KAAK,CAAC,GAAA+G,MAAA;MAAA,OAAK9H,aAAa,CAAC,CAClDE,EAAE,CAAC0H,OAAO,CAAC,EACX1H,EAAE,CAACa,KAAK,CAAC,EACTF,GAAG,CAAC4F,MAAM,CAACsB,KAAK,CAACjH,UAAU,CAAC,CAAC,CAChC,CAAC;IAAA,EAAC,EAAEb,GAAG,CAAEmC,MAAM,IAAKoC,YAAY,CAAC3D,GAAG,EAAEuB,MAAM,CAAC,CAAC,CAAC;EAAA,EAAC;AACrD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}