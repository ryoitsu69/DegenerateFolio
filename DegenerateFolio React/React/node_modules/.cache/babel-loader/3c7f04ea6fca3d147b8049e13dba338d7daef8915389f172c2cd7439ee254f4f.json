{"ast":null,"code":"import { ALPHA_MODES } from \"@pixi/constants\";\nimport { settings } from \"@pixi/settings\";\nimport { BaseImageResource } from \"./BaseImageResource.mjs\";\nclass ImageResource extends BaseImageResource {\n  /**\n   * @param source - image source or URL\n   * @param options\n   * @param {boolean} [options.autoLoad=true] - start loading process\n   * @param {boolean} [options.createBitmap=PIXI.settings.CREATE_IMAGE_BITMAP] - whether its required to create\n   *        a bitmap before upload\n   * @param {boolean} [options.crossorigin=true] - Load image using cross origin\n   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.UNPACK] - Premultiply image alpha in bitmap\n   */\n  constructor(source, options) {\n    if (options = options || {}, typeof source == \"string\") {\n      const imageElement = new Image();\n      BaseImageResource.crossOrigin(imageElement, source, options.crossorigin), imageElement.src = source, source = imageElement;\n    }\n    super(source), !source.complete && this._width && this._height && (this._width = 0, this._height = 0), this.url = source.src, this._process = null, this.preserveBitmap = !1, this.createBitmap = (options.createBitmap ?? settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, this.alphaMode = typeof options.alphaMode == \"number\" ? options.alphaMode : null, this.bitmap = null, this._load = null, options.autoLoad !== !1 && this.load();\n  }\n  /**\n   * Returns a promise when image will be loaded and processed.\n   * @param createBitmap - whether process image into bitmap\n   */\n  load(createBitmap) {\n    return this._load ? this._load : (createBitmap !== void 0 && (this.createBitmap = createBitmap), this._load = new Promise((resolve, reject) => {\n      const source = this.source;\n      this.url = source.src;\n      const completed = () => {\n        this.destroyed || (source.onload = null, source.onerror = null, this.update(), this._load = null, this.createBitmap ? resolve(this.process()) : resolve(this));\n      };\n      source.complete && source.src ? completed() : (source.onload = completed, source.onerror = event => {\n        reject(event), this.onError.emit(event);\n      });\n    }), this._load);\n  }\n  /**\n   * Called when we need to convert image into BitmapImage.\n   * Can be called multiple times, real promise is cached inside.\n   * @returns - Cached promise to fill that bitmap\n   */\n  process() {\n    const source = this.source;\n    if (this._process !== null) return this._process;\n    if (this.bitmap !== null || !globalThis.createImageBitmap) return Promise.resolve(this);\n    const createImageBitmap = globalThis.createImageBitmap,\n      cors = !source.crossOrigin || source.crossOrigin === \"anonymous\";\n    return this._process = fetch(source.src, {\n      mode: cors ? \"cors\" : \"no-cors\"\n    }).then(r => r.blob()).then(blob => createImageBitmap(blob, 0, 0, source.width, source.height, {\n      premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? \"premultiply\" : \"none\"\n    })).then(bitmap => this.destroyed ? Promise.reject() : (this.bitmap = bitmap, this.update(), this._process = null, Promise.resolve(this))), this._process;\n  }\n  /**\n   * Upload the image resource to GPU.\n   * @param renderer - Renderer to upload to\n   * @param baseTexture - BaseTexture for this resource\n   * @param glTexture - GLTexture to use\n   * @returns {boolean} true is success\n   */\n  upload(renderer, baseTexture, glTexture) {\n    if (typeof this.alphaMode == \"number\" && (baseTexture.alphaMode = this.alphaMode), !this.createBitmap) return super.upload(renderer, baseTexture, glTexture);\n    if (!this.bitmap && (this.process(), !this.bitmap)) return !1;\n    if (super.upload(renderer, baseTexture, glTexture, this.bitmap), !this.preserveBitmap) {\n      let flag = !0;\n      const glTextures = baseTexture._glTextures;\n      for (const key in glTextures) {\n        const otherTex = glTextures[key];\n        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {\n          flag = !1;\n          break;\n        }\n      }\n      flag && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);\n    }\n    return !0;\n  }\n  /** Destroys this resource. */\n  dispose() {\n    this.source.onload = null, this.source.onerror = null, super.dispose(), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @returns {boolean} `true` if current environment support HTMLImageElement, and source is string or HTMLImageElement\n   */\n  static test(source) {\n    return typeof HTMLImageElement < \"u\" && (typeof source == \"string\" || source instanceof HTMLImageElement);\n  }\n}\nexport { ImageResource };","map":{"version":3,"names":["ImageResource","BaseImageResource","constructor","source","options","imageElement","Image","crossOrigin","crossorigin","src","complete","_width","_height","url","_process","preserveBitmap","createBitmap","settings","CREATE_IMAGE_BITMAP","globalThis","createImageBitmap","alphaMode","bitmap","_load","autoLoad","load","Promise","resolve","reject","completed","destroyed","onload","onerror","update","process","event","onError","emit","cors","fetch","mode","then","r","blob","width","height","premultiplyAlpha","ALPHA_MODES","UNPACK","upload","renderer","baseTexture","glTexture","flag","glTextures","_glTextures","key","otherTex","dirtyId","close","dispose","test","HTMLImageElement"],"sources":["/home/ryoitsu/node_modules/@pixi/core/src/textures/resources/ImageResource.ts"],"sourcesContent":["import { ALPHA_MODES } from '@pixi/constants';\nimport { settings } from '@pixi/settings';\nimport { BaseImageResource } from './BaseImageResource';\n\nimport type { Renderer } from '../../Renderer';\nimport type { BaseTexture } from '../BaseTexture';\nimport type { GLTexture } from '../GLTexture';\n\nexport interface IImageResourceOptions\n{\n    /** Start loading process automatically when constructed. */\n    autoLoad?: boolean;\n\n    /** Whether its required to create a bitmap before upload. */\n    createBitmap?: boolean;\n\n    /** Load image using cross origin. */\n    crossorigin?: boolean | string;\n\n    /** Premultiply image alpha in bitmap. */\n    alphaMode?: ALPHA_MODES;\n}\n\n/**\n * Resource type for HTMLImageElement.\n * @memberof PIXI\n */\nexport class ImageResource extends BaseImageResource\n{\n    /** URL of the image source */\n    url: string;\n\n    /**\n     * If the image should be disposed after upload\n     * @default false\n     */\n    preserveBitmap: boolean;\n\n    /**\n     * If capable, convert the image using createImageBitmap API.\n     * @default PIXI.settings.CREATE_IMAGE_BITMAP\n     */\n    createBitmap: boolean;\n\n    /**\n     * Controls texture alphaMode field\n     * Copies from options\n     * Default is `null`, copies option from baseTexture\n     * @readonly\n     */\n    alphaMode: ALPHA_MODES;\n\n    /**\n     * The ImageBitmap element created for a {@link HTMLImageElement}.\n     * @default null\n     */\n    bitmap: ImageBitmap;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    /** When process is completed */\n    private _process: Promise<this>;\n\n    /**\n     * @param source - image source or URL\n     * @param options\n     * @param {boolean} [options.autoLoad=true] - start loading process\n     * @param {boolean} [options.createBitmap=PIXI.settings.CREATE_IMAGE_BITMAP] - whether its required to create\n     *        a bitmap before upload\n     * @param {boolean} [options.crossorigin=true] - Load image using cross origin\n     * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.UNPACK] - Premultiply image alpha in bitmap\n     */\n    constructor(source: HTMLImageElement | string, options?: IImageResourceOptions)\n    {\n        options = options || {};\n\n        if (typeof source === 'string')\n        {\n            const imageElement = new Image();\n\n            BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);\n\n            imageElement.src = source;\n            source = imageElement;\n        }\n\n        super(source);\n\n        // FireFox 68, and possibly other versions, seems like setting the HTMLImageElement#width and #height\n        // to non-zero values before its loading completes if images are in a cache.\n        // Because of this, need to set the `_width` and the `_height` to zero to avoid uploading incomplete images.\n        // Please refer to the issue #5968 (https://github.com/pixijs/pixijs/issues/5968).\n        if (!source.complete && !!this._width && !!this._height)\n        {\n            this._width = 0;\n            this._height = 0;\n        }\n\n        this.url = source.src;\n\n        this._process = null;\n\n        this.preserveBitmap = false;\n        this.createBitmap = (options.createBitmap ?? settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;\n        this.alphaMode = typeof options.alphaMode === 'number' ? options.alphaMode : null;\n        this.bitmap = null;\n\n        this._load = null;\n\n        if (options.autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    /**\n     * Returns a promise when image will be loaded and processed.\n     * @param createBitmap - whether process image into bitmap\n     */\n    load(createBitmap?: boolean): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        if (createBitmap !== undefined)\n        {\n            this.createBitmap = createBitmap;\n        }\n\n        this._load = new Promise((resolve, reject): void =>\n        {\n            const source = this.source as HTMLImageElement;\n\n            this.url = source.src;\n\n            const completed = (): void =>\n            {\n                if (this.destroyed)\n                {\n                    return;\n                }\n                source.onload = null;\n                source.onerror = null;\n\n                this.update();\n                this._load = null;\n\n                if (this.createBitmap)\n                {\n                    resolve(this.process());\n                }\n                else\n                {\n                    resolve(this);\n                }\n            };\n\n            if (source.complete && source.src)\n            {\n                completed();\n            }\n            else\n            {\n                source.onload = completed;\n                source.onerror = (event): void =>\n                {\n                    // Avoids Promise freezing when resource broken\n                    reject(event);\n                    this.onError.emit(event);\n                };\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Called when we need to convert image into BitmapImage.\n     * Can be called multiple times, real promise is cached inside.\n     * @returns - Cached promise to fill that bitmap\n     */\n    process(): Promise<this>\n    {\n        const source = this.source as HTMLImageElement;\n\n        if (this._process !== null)\n        {\n            return this._process;\n        }\n        if (this.bitmap !== null || !globalThis.createImageBitmap)\n        {\n            return Promise.resolve(this);\n        }\n\n        const createImageBitmap = globalThis.createImageBitmap as any;\n        const cors = !source.crossOrigin || source.crossOrigin === 'anonymous';\n\n        this._process = fetch(source.src,\n            {\n                mode: cors ? 'cors' : 'no-cors'\n            })\n            .then((r) => r.blob())\n            .then((blob) => createImageBitmap(blob,\n                0, 0, source.width, source.height,\n                {\n                    premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK\n                        ? 'premultiply' : 'none',\n                }))\n            .then((bitmap: ImageBitmap) =>\n            {\n                if (this.destroyed)\n                {\n                    return Promise.reject();\n                }\n                this.bitmap = bitmap;\n                this.update();\n                this._process = null;\n\n                return Promise.resolve(this);\n            });\n\n        return this._process;\n    }\n\n    /**\n     * Upload the image resource to GPU.\n     * @param renderer - Renderer to upload to\n     * @param baseTexture - BaseTexture for this resource\n     * @param glTexture - GLTexture to use\n     * @returns {boolean} true is success\n     */\n    override upload(renderer: Renderer, baseTexture: BaseTexture, glTexture: GLTexture): boolean\n    {\n        if (typeof this.alphaMode === 'number')\n        {\n            // bitmap stores unpack premultiply flag, we dont have to notify texImage2D about it\n\n            baseTexture.alphaMode = this.alphaMode;\n        }\n\n        if (!this.createBitmap)\n        {\n            return super.upload(renderer, baseTexture, glTexture);\n        }\n        if (!this.bitmap)\n        {\n            // yeah, ignore the output\n            this.process();\n            if (!this.bitmap)\n            {\n                return false;\n            }\n        }\n\n        super.upload(renderer, baseTexture, glTexture, this.bitmap);\n\n        if (!this.preserveBitmap)\n        {\n            // checks if there are other renderers that possibly need this bitmap\n\n            let flag = true;\n\n            const glTextures = baseTexture._glTextures;\n\n            for (const key in glTextures)\n            {\n                const otherTex = glTextures[key];\n\n                if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId)\n                {\n                    flag = false;\n                    break;\n                }\n            }\n\n            if (flag)\n            {\n                if (this.bitmap.close)\n                {\n                    this.bitmap.close();\n                }\n\n                this.bitmap = null;\n            }\n        }\n\n        return true;\n    }\n\n    /** Destroys this resource. */\n    override dispose(): void\n    {\n        (this.source as HTMLImageElement).onload = null;\n        (this.source as HTMLImageElement).onerror = null;\n\n        super.dispose();\n\n        if (this.bitmap)\n        {\n            this.bitmap.close();\n            this.bitmap = null;\n        }\n        this._process = null;\n        this._load = null;\n    }\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @returns {boolean} `true` if current environment support HTMLImageElement, and source is string or HTMLImageElement\n     */\n    static override test(source: unknown): source is string | HTMLImageElement\n    {\n        return typeof HTMLImageElement !== 'undefined' && (typeof source === 'string' || source instanceof HTMLImageElement);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}