{"ast":null,"code":"import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes.mjs';\nimport { STENCIL_MODES } from '../../shared/state/const.mjs';\nimport { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi.mjs';\n\"use strict\";\nconst topologyStringToId = {\n  \"point-list\": 0,\n  \"line-list\": 1,\n  \"line-strip\": 2,\n  \"triangle-list\": 3,\n  \"triangle-strip\": 4\n};\nfunction getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {\n  return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;\n}\nfunction getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {\n  return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;\n}\nclass PipelineSystem {\n  constructor(renderer) {\n    this._moduleCache = /* @__PURE__ */Object.create(null);\n    this._bufferLayoutsCache = /* @__PURE__ */Object.create(null);\n    this._pipeCache = /* @__PURE__ */Object.create(null);\n    this._pipeStateCaches = /* @__PURE__ */Object.create(null);\n    this._colorMask = 15;\n    this._multisampleCount = 1;\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n    this.setStencilMode(STENCIL_MODES.DISABLED);\n    this._updatePipeHash();\n  }\n  setMultisampleCount(multisampleCount) {\n    if (this._multisampleCount === multisampleCount) return;\n    this._multisampleCount = multisampleCount;\n    this._updatePipeHash();\n  }\n  setRenderTarget(renderTarget) {\n    this._multisampleCount = renderTarget.msaaSamples;\n    this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n    this._updatePipeHash();\n  }\n  setColorMask(colorMask) {\n    if (this._colorMask === colorMask) return;\n    this._colorMask = colorMask;\n    this._updatePipeHash();\n  }\n  setStencilMode(stencilMode) {\n    if (this._stencilMode === stencilMode) return;\n    this._stencilMode = stencilMode;\n    this._stencilState = GpuStencilModesToPixi[stencilMode];\n    this._updatePipeHash();\n  }\n  setPipeline(geometry, program, state, passEncoder) {\n    const pipeline = this.getPipeline(geometry, program, state);\n    passEncoder.setPipeline(pipeline);\n  }\n  getPipeline(geometry, program, state, topology) {\n    if (!geometry._layoutKey) {\n      ensureAttributes(geometry, program.attributeData);\n      this._generateBufferKey(geometry);\n    }\n    topology = topology || geometry.topology;\n    const key = getGraphicsStateKey(geometry._layoutKey, program._layoutKey, state.data, state._blendModeId, topologyStringToId[topology]);\n    if (this._pipeCache[key]) return this._pipeCache[key];\n    this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n    return this._pipeCache[key];\n  }\n  _createPipeline(geometry, program, state, topology) {\n    const device = this._gpu.device;\n    const buffers = this._createVertexBufferLayouts(geometry);\n    const blendModes = this._renderer.state.getColorTargets(state);\n    blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n    const layout = this._renderer.shader.getProgramData(program).pipeline;\n    const descriptor = {\n      // TODO later check if its helpful to create..\n      // layout,\n      vertex: {\n        module: this._getModule(program.vertex.source),\n        entryPoint: program.vertex.entryPoint,\n        // geometry..\n        buffers\n      },\n      fragment: {\n        module: this._getModule(program.fragment.source),\n        entryPoint: program.fragment.entryPoint,\n        targets: blendModes\n      },\n      primitive: {\n        topology,\n        cullMode: state.cullMode\n      },\n      layout,\n      multisample: {\n        count: this._multisampleCount\n      },\n      // depthStencil,\n      label: `PIXI Pipeline`\n    };\n    if (this._depthStencilAttachment) {\n      descriptor.depthStencil = {\n        ...this._stencilState,\n        format: \"depth24plus-stencil8\",\n        depthWriteEnabled: state.depthTest,\n        depthCompare: state.depthTest ? \"less\" : \"always\"\n      };\n    }\n    const pipeline = device.createRenderPipeline(descriptor);\n    return pipeline;\n  }\n  _getModule(code) {\n    return this._moduleCache[code] || this._createModule(code);\n  }\n  _createModule(code) {\n    const device = this._gpu.device;\n    this._moduleCache[code] = device.createShaderModule({\n      code\n    });\n    return this._moduleCache[code];\n  }\n  _generateBufferKey(geometry) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(geometry.attributes).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = geometry.attributes[attributeKeys[i]];\n      keyGen[index++] = attribute.location;\n      keyGen[index++] = attribute.offset;\n      keyGen[index++] = attribute.format;\n      keyGen[index++] = attribute.stride;\n    }\n    const stringKey = keyGen.join(\"\");\n    geometry._layoutKey = createIdFromString(stringKey, \"geometry\");\n    return geometry._layoutKey;\n  }\n  _createVertexBufferLayouts(geometry) {\n    if (this._bufferLayoutsCache[geometry._layoutKey]) {\n      return this._bufferLayoutsCache[geometry._layoutKey];\n    }\n    const vertexBuffersLayout = [];\n    geometry.buffers.forEach(buffer => {\n      const bufferEntry = {\n        arrayStride: 0,\n        stepMode: \"vertex\",\n        attributes: []\n      };\n      const bufferEntryAttributes = bufferEntry.attributes;\n      for (const i in geometry.attributes) {\n        const attribute = geometry.attributes[i];\n        if (attribute.buffer === buffer) {\n          bufferEntry.arrayStride = attribute.stride;\n          bufferEntry.stepMode = attribute.instance ? \"instance\" : \"vertex\";\n          bufferEntryAttributes.push({\n            shaderLocation: attribute.location,\n            offset: attribute.offset,\n            format: attribute.format\n          });\n        }\n      }\n      if (bufferEntryAttributes.length) {\n        vertexBuffersLayout.push(bufferEntry);\n      }\n    });\n    this._bufferLayoutsCache[geometry._layoutKey] = vertexBuffersLayout;\n    return vertexBuffersLayout;\n  }\n  _updatePipeHash() {\n    const key = getGlobalStateKey(this._stencilMode, this._multisampleCount, this._colorMask, this._depthStencilAttachment);\n    if (!this._pipeStateCaches[key]) {\n      this._pipeStateCaches[key] = /* @__PURE__ */Object.create(null);\n    }\n    this._pipeCache = this._pipeStateCaches[key];\n  }\n  destroy() {\n    this._renderer = null;\n    this._bufferLayoutsCache = null;\n  }\n}\n/** @ignore */\nPipelineSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"pipeline\"\n};\nexport { PipelineSystem };","map":{"version":3,"names":["topologyStringToId","getGraphicsStateKey","geometryLayout","shaderKey","state","blendMode","topology","getGlobalStateKey","stencilStateId","multiSampleCount","colorMask","renderTarget","PipelineSystem","constructor","renderer","_moduleCache","Object","create","_bufferLayoutsCache","_pipeCache","_pipeStateCaches","_colorMask","_multisampleCount","_renderer","contextChange","gpu","_gpu","setStencilMode","STENCIL_MODES","DISABLED","_updatePipeHash","setMultisampleCount","multisampleCount","setRenderTarget","msaaSamples","_depthStencilAttachment","descriptor","depthStencilAttachment","setColorMask","stencilMode","_stencilMode","_stencilState","GpuStencilModesToPixi","setPipeline","geometry","program","passEncoder","pipeline","getPipeline","_layoutKey","ensureAttributes","attributeData","_generateBufferKey","key","data","_blendModeId","_createPipeline","device","buffers","_createVertexBufferLayouts","blendModes","getColorTargets","writeMask","RENDERING_MASK_ADD","layout","shader","getProgramData","vertex","module","_getModule","source","entryPoint","fragment","targets","primitive","cullMode","multisample","count","label","depthStencil","format","depthWriteEnabled","depthTest","depthCompare","createRenderPipeline","code","_createModule","createShaderModule","keyGen","index","attributeKeys","keys","attributes","sort","i","length","attribute","location","offset","stride","stringKey","join","createIdFromString","vertexBuffersLayout","forEach","buffer","bufferEntry","arrayStride","stepMode","bufferEntryAttributes","instance","push","shaderLocation","destroy","extension","type","ExtensionType","WebGPUSystem","name"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gpu/pipeline/PipelineSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes';\nimport { STENCIL_MODES } from '../../shared/state/const';\nimport { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { State } from '../../shared/state/State';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuRenderTarget } from '../renderTarget/GpuRenderTarget';\nimport type { GpuProgram } from '../shader/GpuProgram';\nimport type { StencilState } from '../state/GpuStencilModesToPixi';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\nconst topologyStringToId = {\n    'point-list': 0,\n    'line-list': 1,\n    'line-strip': 2,\n    'triangle-list': 3,\n    'triangle-strip': 4,\n};\n\n// geometryLayouts = 256; // 8 bits // 256 states // value 0-255;\n// shaderKeys = 256; // 8 bits // 256 states // value 0-255;\n// state = 64; // 6 bits // 64 states // value 0-63;\n// blendMode = 32; // 5 bits // 32 states // value 0-31;\n// topology = 8; // 3 bits // 8 states // value 0-7;\nfunction getGraphicsStateKey(\n    geometryLayout: number,\n    shaderKey: number,\n    state: number,\n    blendMode: number,\n    topology: number,\n): number\n{\n    return (geometryLayout << 24) // Allocate the 8 bits for geometryLayouts at the top\n         | (shaderKey << 16) // Next 8 bits for shaderKeys\n         | (state << 10) // 6 bits for state\n         | (blendMode << 5) // 5 bits for blendMode\n         | topology; // And 3 bits for topology at the least significant position\n}\n\n// colorMask = 16;// 4 bits // 16 states // value 0-15;\n// stencilState = 8; // 3 bits // 8 states // value 0-7;\n// renderTarget = 1; // 2 bit // 3 states // value 0-3; // none, stencil, depth, depth-stencil\n// multiSampleCount = 1; // 1 bit // 2 states // value 0-1;\nfunction getGlobalStateKey(\n    stencilStateId: number,\n    multiSampleCount: number,\n    colorMask: number,\n    renderTarget: number,\n): number\n{\n    return (colorMask << 6) // Allocate the 4 bits for colorMask at the top\n         | (stencilStateId << 3) // Next 3 bits for stencilStateId\n         | (renderTarget << 1) // 2 bits for renderTarget\n         | multiSampleCount; // And 1 bit for multiSampleCount at the least significant position\n}\n\ntype PipeHash = Record<number, GPURenderPipeline>;\n\n/**\n * A system that creates and manages the GPU pipelines.\n *\n * Caching Mechanism: At its core, the system employs a two-tiered caching strategy to minimize\n * the redundant creation of GPU pipelines (or \"pipes\"). This strategy is based on generating unique\n * keys that represent the state of the graphics settings and the specific requirements of the\n * item being rendered. By caching these pipelines, subsequent draw calls with identical configurations\n * can reuse existing pipelines instead of generating new ones.\n *\n * State Management: The system differentiates between \"global\" state properties (like color masks\n * and stencil masks, which do not change frequently) and properties that may vary between draw calls\n * (such as geometry, shaders, and blend modes). Unique keys are generated for both these categories\n * using getStateKey for global state and getGraphicsStateKey for draw-specific settings. These keys are\n * then then used to caching the pipe. The next time we need a pipe we can check\n * the cache by first looking at the state cache and then the pipe cache.\n * @memberof rendering\n */\nexport class PipelineSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'pipeline',\n    } as const;\n    private readonly _renderer: WebGPURenderer;\n\n    protected CONTEXT_UID: number;\n\n    private _moduleCache: Record<string, GPUShaderModule> = Object.create(null);\n    private _bufferLayoutsCache: Record<number, GPUVertexBufferLayout[]> = Object.create(null);\n\n    private _pipeCache: PipeHash = Object.create(null);\n    private readonly _pipeStateCaches: Record<number, PipeHash> = Object.create(null);\n\n    private _gpu: GPU;\n    private _stencilState: StencilState;\n\n    private _stencilMode: STENCIL_MODES;\n    private _colorMask = 0b1111;\n    private _multisampleCount = 1;\n    private _depthStencilAttachment: 0 | 1;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n        this.setStencilMode(STENCIL_MODES.DISABLED);\n\n        this._updatePipeHash();\n    }\n\n    public setMultisampleCount(multisampleCount: number): void\n    {\n        if (this._multisampleCount === multisampleCount) return;\n\n        this._multisampleCount = multisampleCount;\n\n        this._updatePipeHash();\n    }\n\n    public setRenderTarget(renderTarget: GpuRenderTarget)\n    {\n        this._multisampleCount = renderTarget.msaaSamples;\n        this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n\n        this._updatePipeHash();\n    }\n\n    public setColorMask(colorMask: number): void\n    {\n        if (this._colorMask === colorMask) return;\n\n        this._colorMask = colorMask;\n\n        this._updatePipeHash();\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES): void\n    {\n        if (this._stencilMode === stencilMode) return;\n\n        this._stencilMode = stencilMode;\n        this._stencilState = GpuStencilModesToPixi[stencilMode];\n\n        this._updatePipeHash();\n    }\n\n    public setPipeline(geometry: Geometry, program: GpuProgram, state: State, passEncoder: GPURenderPassEncoder): void\n    {\n        const pipeline = this.getPipeline(geometry, program, state);\n\n        passEncoder.setPipeline(pipeline);\n    }\n\n    public getPipeline(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: State,\n        topology?: Topology,\n    ): GPURenderPipeline\n    {\n        if (!geometry._layoutKey)\n        {\n            ensureAttributes(geometry, program.attributeData);\n\n            // prepare the geometry for the pipeline\n            this._generateBufferKey(geometry);\n        }\n\n        topology = topology || geometry.topology;\n\n        // now we have set the Ids - the key is different...\n        // eslint-disable-next-line max-len\n        const key = getGraphicsStateKey(\n            geometry._layoutKey,\n            program._layoutKey,\n            state.data,\n            state._blendModeId,\n            topologyStringToId[topology],\n        );\n\n        if (this._pipeCache[key]) return this._pipeCache[key];\n\n        this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n\n        return this._pipeCache[key];\n    }\n\n    private _createPipeline(geometry: Geometry, program: GpuProgram, state: State, topology: Topology): GPURenderPipeline\n    {\n        const device = this._gpu.device;\n\n        const buffers = this._createVertexBufferLayouts(geometry);\n\n        const blendModes = this._renderer.state.getColorTargets(state);\n\n        blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n\n        const layout = this._renderer.shader.getProgramData(program).pipeline;\n\n        const descriptor: GPURenderPipelineDescriptor = {\n            // TODO later check if its helpful to create..\n            // layout,\n            vertex: {\n                module: this._getModule(program.vertex.source),\n                entryPoint: program.vertex.entryPoint,\n                // geometry..\n                buffers,\n            },\n            fragment: {\n                module: this._getModule(program.fragment.source),\n                entryPoint: program.fragment.entryPoint,\n                targets: blendModes,\n            },\n            primitive: {\n                topology,\n                cullMode: state.cullMode,\n            },\n            layout,\n            multisample: {\n                count: this._multisampleCount,\n            },\n            // depthStencil,\n            label: `PIXI Pipeline`,\n        };\n\n        // only apply if the texture has stencil or depth\n        if (this._depthStencilAttachment)\n        {\n            // mask states..\n            descriptor.depthStencil = {\n                ...this._stencilState,\n                format: 'depth24plus-stencil8',\n                depthWriteEnabled: state.depthTest,\n                depthCompare: state.depthTest ? 'less' : 'always',\n            };\n        }\n\n        const pipeline = device.createRenderPipeline(descriptor);\n\n        return pipeline;\n    }\n\n    private _getModule(code: string): GPUShaderModule\n    {\n        return this._moduleCache[code] || this._createModule(code);\n    }\n\n    private _createModule(code: string): GPUShaderModule\n    {\n        const device = this._gpu.device;\n\n        this._moduleCache[code] = device.createShaderModule({\n            code,\n        });\n\n        return this._moduleCache[code];\n    }\n\n    private _generateBufferKey(geometry: Geometry): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(geometry.attributes).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = geometry.attributes[attributeKeys[i]];\n\n            keyGen[index++] = attribute.location;\n            keyGen[index++] = attribute.offset;\n            keyGen[index++] = attribute.format;\n            keyGen[index++] = attribute.stride;\n        }\n\n        const stringKey = keyGen.join('');\n\n        geometry._layoutKey = createIdFromString(stringKey, 'geometry');\n\n        return geometry._layoutKey;\n    }\n\n    private _createVertexBufferLayouts(geometry: Geometry): GPUVertexBufferLayout[]\n    {\n        if (this._bufferLayoutsCache[geometry._layoutKey])\n        {\n            return this._bufferLayoutsCache[geometry._layoutKey];\n        }\n\n        const vertexBuffersLayout: GPUVertexBufferLayout[] = [];\n\n        geometry.buffers.forEach((buffer) =>\n        {\n            const bufferEntry: GPUVertexBufferLayout = {\n                arrayStride: 0,\n                stepMode: 'vertex',\n                attributes: [],\n            };\n\n            const bufferEntryAttributes = bufferEntry.attributes as GPUVertexAttribute[];\n\n            for (const i in geometry.attributes)\n            {\n                const attribute = geometry.attributes[i];\n\n                if (attribute.buffer === buffer)\n                {\n                    bufferEntry.arrayStride = attribute.stride;\n                    bufferEntry.stepMode = attribute.instance ? 'instance' : 'vertex';\n\n                    bufferEntryAttributes.push({\n                        shaderLocation: attribute.location,\n                        offset: attribute.offset,\n                        format: attribute.format,\n                    });\n                }\n            }\n\n            if (bufferEntryAttributes.length)\n            {\n                vertexBuffersLayout.push(bufferEntry);\n            }\n        });\n\n        this._bufferLayoutsCache[geometry._layoutKey] = vertexBuffersLayout;\n\n        return vertexBuffersLayout;\n    }\n\n    private _updatePipeHash(): void\n    {\n        const key = getGlobalStateKey(\n            this._stencilMode,\n            this._multisampleCount,\n            this._colorMask,\n            this._depthStencilAttachment\n        );\n\n        if (!this._pipeStateCaches[key])\n        {\n            this._pipeStateCaches[key] = Object.create(null);\n        }\n\n        this._pipeCache = this._pipeStateCaches[key];\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n        this._bufferLayoutsCache = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}