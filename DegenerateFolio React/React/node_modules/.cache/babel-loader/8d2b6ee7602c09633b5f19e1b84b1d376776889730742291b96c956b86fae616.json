{"ast":null,"code":"import { Cache } from '../../assets/cache/Cache.mjs';\nimport { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { Graphics } from '../graphics/shared/Graphics.mjs';\nimport { SdfShader } from '../text/sdfShader/SdfShader.mjs';\nimport { BitmapFontManager } from './BitmapFontManager.mjs';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout.mjs';\n\"use strict\";\nclass BitmapTextPipe {\n  constructor(renderer) {\n    this._gpuBitmapText = {};\n    this._renderer = renderer;\n  }\n  validateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n  }\n  addRenderable(bitmapText, instructionSet) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  destroyRenderable(bitmapText) {\n    this._destroyRenderableByUid(bitmapText.uid);\n  }\n  _destroyRenderableByUid(renderableUid) {\n    BigPool.return(this._gpuBitmapText[renderableUid]);\n    this._gpuBitmapText[renderableUid] = null;\n  }\n  updateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  _updateContext(bitmapText, proxyGraphics) {\n    const {\n      context\n    } = proxyGraphics;\n    const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n    context.clear();\n    if (bitmapFont.distanceField.type !== \"none\") {\n      if (!context.customShader) {\n        if (!this._sdfShader) {\n          this._sdfShader = new SdfShader();\n        }\n        context.customShader = this._sdfShader;\n      }\n    }\n    const chars = Array.from(bitmapText.text);\n    const style = bitmapText._style;\n    let currentY = (style._stroke?.width || 0) / 2;\n    currentY += bitmapFont.baseLineOffset;\n    const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);\n    let index = 0;\n    const padding = style.padding;\n    const scale = bitmapTextLayout.scale;\n    context.translate(-bitmapText._anchor._x * bitmapTextLayout.width - padding, -bitmapText._anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY) - padding).scale(scale, scale);\n    const tint = style._fill.color;\n    for (let i = 0; i < bitmapTextLayout.lines.length; i++) {\n      const line = bitmapTextLayout.lines[i];\n      for (let j = 0; j < line.charPositions.length; j++) {\n        const char = chars[index++];\n        const charData = bitmapFont.chars[char];\n        if (charData?.texture) {\n          context.texture(charData.texture, tint ? tint : \"black\", Math.round(line.charPositions[j] + charData.xOffset), Math.round(currentY + charData.yOffset));\n        }\n      }\n      currentY += bitmapFont.lineHeight;\n    }\n  }\n  _getGpuBitmapText(bitmapText) {\n    return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n  }\n  initGpuText(bitmapText) {\n    const proxyRenderable = BigPool.get(Graphics);\n    this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n    this._updateContext(bitmapText, proxyRenderable);\n    bitmapText.on(\"destroyed\", () => {\n      this.destroyRenderable(bitmapText);\n    });\n    return this._gpuBitmapText[bitmapText.uid];\n  }\n  _updateDistanceField(bitmapText) {\n    const context = this._getGpuBitmapText(bitmapText).context;\n    const fontFamily = bitmapText._style.fontFamily;\n    const dynamicFont = Cache.get(`${fontFamily}-bitmap`);\n    const {\n      a,\n      b,\n      c,\n      d\n    } = bitmapText.groupTransform;\n    const dx = Math.sqrt(a * a + b * b);\n    const dy = Math.sqrt(c * c + d * d);\n    const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n    const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n    const resolution = bitmapText.resolution ?? this._renderer.resolution;\n    const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;\n    context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n  }\n  destroy() {\n    for (const uid in this._gpuBitmapText) {\n      this._destroyRenderableByUid(uid);\n    }\n    this._gpuBitmapText = null;\n    this._sdfShader?.destroy(true);\n    this._sdfShader = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBitmapTextPipe.extension = {\n  type: [ExtensionType.WebGLPipes, ExtensionType.WebGPUPipes, ExtensionType.CanvasPipes],\n  name: \"bitmapText\"\n};\nfunction syncWithProxy(container, proxy) {\n  proxy.groupTransform = container.groupTransform;\n  proxy.groupColorAlpha = container.groupColorAlpha;\n  proxy.groupColor = container.groupColor;\n  proxy.groupBlendMode = container.groupBlendMode;\n  proxy.globalDisplayStatus = container.globalDisplayStatus;\n  proxy.groupTransform = container.groupTransform;\n  proxy.localDisplayStatus = container.localDisplayStatus;\n  proxy.groupAlpha = container.groupAlpha;\n  proxy._roundPixels = container._roundPixels;\n}\nexport { BitmapTextPipe };","map":{"version":3,"names":["BitmapTextPipe","constructor","renderer","_gpuBitmapText","_renderer","validateRenderable","bitmapText","graphicsRenderable","_getGpuBitmapText","_didTextUpdate","_updateContext","renderPipes","graphics","addRenderable","instructionSet","syncWithProxy","context","customShader","_updateDistanceField","destroyRenderable","_destroyRenderableByUid","uid","renderableUid","BigPool","return","updateRenderable","proxyGraphics","bitmapFont","BitmapFontManager","getFont","text","_style","clear","distanceField","type","_sdfShader","SdfShader","chars","Array","from","style","currentY","_stroke","width","baseLineOffset","bitmapTextLayout","getBitmapTextLayout","index","padding","scale","translate","_anchor","_x","_y","height","offsetY","tint","_fill","color","i","lines","length","line","j","charPositions","char","charData","texture","Math","round","xOffset","yOffset","lineHeight","initGpuText","proxyRenderable","get","Graphics","on","fontFamily","dynamicFont","Cache","a","b","c","d","groupTransform","dx","sqrt","dy","worldScale","abs","fontScale","baseRenderedFontSize","fontSize","resolution","distance","range","resources","localUniforms","uniforms","uDistance","destroy","extension","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","name","container","proxy","groupColorAlpha","groupColor","groupBlendMode","globalDisplayStatus","localDisplayStatus","groupAlpha","_roundPixels"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/text-bitmap/BitmapTextPipe.ts"],"sourcesContent":["import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { BitmapText } from './BitmapText';\n\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n    private _gpuBitmapText: Record<number, Graphics> = {};\n    private _sdfShader: SdfShader;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public destroyRenderable(bitmapText: BitmapText)\n    {\n        this._destroyRenderableByUid(bitmapText.uid);\n    }\n\n    private _destroyRenderableByUid(renderableUid: number)\n    {\n        BigPool.return(this._gpuBitmapText[renderableUid] as PoolItem);\n        this._gpuBitmapText[renderableUid] = null;\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                if (!this._sdfShader)\n                {\n                    this._sdfShader = new SdfShader();\n                }\n\n                context.customShader = this._sdfShader;\n            }\n        }\n\n        const chars = Array.from(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = (style._stroke?.width || 0) / 2;\n\n        currentY += bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);\n\n        let index = 0;\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        context\n            .translate(\n                (-bitmapText._anchor._x * bitmapTextLayout.width) - padding,\n                (-bitmapText._anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY)) - padding)\n            .scale(scale, scale);\n\n        const tint = style._fill.color;\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = chars[index++];\n\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    context.texture(\n                        charData.texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset),\n                    );\n                }\n            }\n\n            currentY += bitmapFont.lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that hav the same style!\n        const proxyRenderable = BigPool.get(Graphics);\n\n        this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        bitmapText.on('destroyed', () =>\n        {\n            this.destroyRenderable(bitmapText);\n        });\n\n        return this._gpuBitmapText[bitmapText.uid];\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const resolution = bitmapText.resolution ?? this._renderer.resolution;\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        for (const uid in this._gpuBitmapText)\n        {\n            this._destroyRenderableByUid(uid as unknown as number);\n        }\n\n        this._gpuBitmapText = null;\n\n        this._sdfShader?.destroy(true);\n        this._sdfShader = null;\n\n        this._renderer = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}