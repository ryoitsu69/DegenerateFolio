{"ast":null,"code":"import { Json } from '@polkadot/types-codec';\nimport { isFunction, isNull, isUndefined } from '@polkadot/util';\nfunction createValue(registry, type, value) {\n  let asArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  // We detect codec here as well - when found, generally this is constructed from itself\n  if (value && isFunction(value.unwrapOrDefault)) {\n    return value;\n  }\n  return registry.createTypeUnsafe(type, [asArray ? isNull(value) || isUndefined(value) ? null : Array.isArray(value) ? value : [value] : value]);\n}\nfunction decodeValue(registry, key, value) {\n  return key === 'ss58Format' ? createValue(registry, 'Option<u32>', value, false) : key === 'tokenDecimals' ? createValue(registry, 'Option<Vec<u32>>', value) : key === 'tokenSymbol' ? createValue(registry, 'Option<Vec<Text>>', value) : key === 'isEthereum' ? createValue(registry, 'Bool', value, false) : value;\n}\nfunction decode(registry, value) {\n  return (\n  // allow decoding from a map as well (ourselves)\n  value && isFunction(value.entries) ? [...value.entries()] : Object.entries(value || {})).reduce((all, _ref) => {\n    let [key, value] = _ref;\n    all[key] = decodeValue(registry, key, value);\n    return all;\n  }, {\n    isEthereum: registry.createTypeUnsafe('Bool', []),\n    ss58Format: registry.createTypeUnsafe('Option<u32>', []),\n    tokenDecimals: registry.createTypeUnsafe('Option<Vec<u32>>', []),\n    tokenSymbol: registry.createTypeUnsafe('Option<Vec<Text>>', [])\n  });\n}\nexport class GenericChainProperties extends Json {\n  constructor(registry, value) {\n    super(registry, decode(registry, value));\n  }\n  /**\n   * @description The chain uses Ethereum addresses\n   */\n  get isEthereum() {\n    return this.getT('isEthereum');\n  }\n  /**\n   * @description The chain ss58Format\n   */\n  get ss58Format() {\n    return this.getT('ss58Format');\n  }\n  /**\n   * @description The decimals for each of the tokens\n   */\n  get tokenDecimals() {\n    return this.getT('tokenDecimals');\n  }\n  /**\n   * @description The symbols for the tokens\n   */\n  get tokenSymbol() {\n    return this.getT('tokenSymbol');\n  }\n}","map":{"version":3,"names":["Json","isFunction","isNull","isUndefined","createValue","registry","type","value","asArray","arguments","length","undefined","unwrapOrDefault","createTypeUnsafe","Array","isArray","decodeValue","key","decode","entries","Object","reduce","all","_ref","isEthereum","ss58Format","tokenDecimals","tokenSymbol","GenericChainProperties","constructor","getT"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types/generic/ChainProperties.js"],"sourcesContent":["import { Json } from '@polkadot/types-codec';\nimport { isFunction, isNull, isUndefined } from '@polkadot/util';\nfunction createValue(registry, type, value, asArray = true) {\n    // We detect codec here as well - when found, generally this is constructed from itself\n    if (value && isFunction(value.unwrapOrDefault)) {\n        return value;\n    }\n    return registry.createTypeUnsafe(type, [\n        asArray\n            ? isNull(value) || isUndefined(value)\n                ? null\n                : Array.isArray(value)\n                    ? value\n                    : [value]\n            : value\n    ]);\n}\nfunction decodeValue(registry, key, value) {\n    return key === 'ss58Format'\n        ? createValue(registry, 'Option<u32>', value, false)\n        : key === 'tokenDecimals'\n            ? createValue(registry, 'Option<Vec<u32>>', value)\n            : key === 'tokenSymbol'\n                ? createValue(registry, 'Option<Vec<Text>>', value)\n                : key === 'isEthereum'\n                    ? createValue(registry, 'Bool', value, false)\n                    : value;\n}\nfunction decode(registry, value) {\n    return (\n    // allow decoding from a map as well (ourselves)\n    value && isFunction(value.entries)\n        ? [...value.entries()]\n        : Object.entries(value || {})).reduce((all, [key, value]) => {\n        all[key] = decodeValue(registry, key, value);\n        return all;\n    }, {\n        isEthereum: registry.createTypeUnsafe('Bool', []),\n        ss58Format: registry.createTypeUnsafe('Option<u32>', []),\n        tokenDecimals: registry.createTypeUnsafe('Option<Vec<u32>>', []),\n        tokenSymbol: registry.createTypeUnsafe('Option<Vec<Text>>', [])\n    });\n}\nexport class GenericChainProperties extends Json {\n    constructor(registry, value) {\n        super(registry, decode(registry, value));\n    }\n    /**\n     * @description The chain uses Ethereum addresses\n     */\n    get isEthereum() {\n        return this.getT('isEthereum');\n    }\n    /**\n     * @description The chain ss58Format\n     */\n    get ss58Format() {\n        return this.getT('ss58Format');\n    }\n    /**\n     * @description The decimals for each of the tokens\n     */\n    get tokenDecimals() {\n        return this.getT('tokenDecimals');\n    }\n    /**\n     * @description The symbols for the tokens\n     */\n    get tokenSymbol() {\n        return this.getT('tokenSymbol');\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}