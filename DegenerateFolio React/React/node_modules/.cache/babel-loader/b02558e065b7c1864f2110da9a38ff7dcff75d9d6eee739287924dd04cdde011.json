{"ast":null,"code":"\"use strict\";\n\nfunction extractOutputs(fragmentSource, out) {\n  let match;\n  const regex = /@out\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction extractVariableName(value) {\n  const regex = /\\b(\\w+)\\s*:/g;\n  const match = regex.exec(value);\n  return match ? match[1] : \"\";\n}\nfunction stripVariable(value) {\n  const regex = /@.*?\\s+/g;\n  return value.replace(regex, \"\");\n}\nfunction compileOutputs(fragments, template) {\n  const results = [];\n  extractOutputs(template, results);\n  fragments.forEach(fragment => {\n    if (fragment.header) {\n      extractOutputs(fragment.header, results);\n    }\n  });\n  let index = 0;\n  const mainStruct = results.sort().map(inValue => {\n    if (inValue.indexOf(\"builtin\") > -1) {\n      return inValue;\n    }\n    return `@location(${index++}) ${inValue}`;\n  }).join(\",\\n\");\n  const mainStart = results.sort().map(inValue => `       var ${stripVariable(inValue)};`).join(\"\\n\");\n  const mainEnd = `return VSOutput(\n                ${results.sort().map(inValue => ` ${extractVariableName(inValue)}`).join(\",\\n\")});`;\n  let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n  compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n  compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n  compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n  return compiledCode;\n}\nexport { compileOutputs };","map":{"version":3,"names":["extractOutputs","fragmentSource","out","match","regex","exec","push","extractVariableName","value","stripVariable","replace","compileOutputs","fragments","template","results","forEach","fragment","header","index","mainStruct","sort","map","inValue","indexOf","join","mainStart","mainEnd","compiledCode"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileOutputs.ts"],"sourcesContent":["function extractOutputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nfunction extractVariableName(value: string)\n{\n    const regex = /\\b(\\w+)\\s*:/g;\n\n    const match = regex.exec(value);\n\n    return match ? match[1] : '';\n}\n\nfunction stripVariable(value: string)\n{\n    const regex = /@.*?\\s+/g;\n\n    return value.replace(regex, '');\n}\n\nexport function compileOutputs(fragments: any[], template: string)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractOutputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractOutputs(fragment.header, results);\n        }\n    });\n\n    let index = 0;\n\n    // generate the output struct\n    const mainStruct = results\n        .sort()\n        .map((inValue) =>\n        {\n            if (inValue.indexOf('builtin') > -1)\n            {\n                return inValue;\n            }\n\n            return `@location(${index++}) ${inValue}`;\n        })\n        .join(',\\n');\n\n    // generate the variables we will set:\n    const mainStart = results\n        .sort()\n        .map((inValue) => `       var ${stripVariable(inValue)};`)\n        .join('\\n');\n\n    // generate the return object\n    const mainEnd = `return VSOutput(\n                ${results\n        .sort()\n        .map((inValue) => ` ${extractVariableName(inValue)}`)\n        .join(',\\n')});`;\n\n    // Remove lines from original string\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, '');\n\n    compiledCode = compiledCode.replace('{{struct}}', `\\n${mainStruct}\\n`);\n    compiledCode = compiledCode.replace('{{start}}', `\\n${mainStart}\\n`);\n    compiledCode = compiledCode.replace('{{return}}', `\\n${mainEnd}\\n`);\n\n    return compiledCode;\n}\n"],"mappings":";;AAAA,SAASA,eAAeC,cAAA,EAAwBC,GAChD;EACQ,IAAAC,KAAA;EACJ,MAAMC,KAAQ;EAEd,QAAQD,KAAQ,GAAAC,KAAA,CAAMC,IAAK,CAAAJ,cAAc,OAAO,IAChD;IACQC,GAAA,CAAAI,IAAA,CAAKH,KAAM,EAAC,CAAC;EAAA;AAEzB;AAEA,SAASI,oBAAoBC,KAC7B;EACI,MAAMJ,KAAQ;EAER,MAAAD,KAAA,GAAQC,KAAM,CAAAC,IAAA,CAAKG,KAAK;EAEvB,OAAAL,KAAA,GAAQA,KAAM,EAAC,CAAI;AAC9B;AAEA,SAASM,cAAcD,KACvB;EACI,MAAMJ,KAAQ;EAEP,OAAAI,KAAA,CAAME,OAAQ,CAAAN,KAAA,EAAO,EAAE;AAClC;AAEgB,SAAAO,eAAeC,SAAA,EAAkBC,QACjD;EAEI,MAAMC,OAAA,GAAoB,EAAC;EAE3Bd,cAAA,CAAea,QAAA,EAAUC,OAAO;EAEtBF,SAAA,CAAAG,OAAA,CAASC,QACnB;IACI,IAAIA,QAAA,CAASC,MACb;MACmBjB,cAAA,CAAAgB,QAAA,CAASC,MAAA,EAAQH,OAAO;IAAA;EAC3C,CACH;EAED,IAAII,KAAQ;EAGZ,MAAMC,UAAA,GAAaL,OACd,CAAAM,IAAA,EACA,CAAAC,GAAA,CAAKC,OACN;IACI,IAAIA,OAAQ,CAAAC,OAAA,CAAQ,SAAS,IAAI,CACjC;MACW,OAAAD,OAAA;IAAA;IAGJ,oBAAaJ,KAAO,OAAKI,OAAO;EAAA,CAC1C,CACA,CAAAE,IAAA,CAAK,KAAK;EAGf,MAAMC,SAAY,GAAAX,OAAA,CACbM,IAAK,GACLC,GAAA,CAAKC,OAAA,IAA0B,cAAAb,aAAA,CAAca,OAAO,CAAI,KACxDE,IAAA,CAAK,IAAI;EAGd,MAAME,OAAU;AAAA,kBACFZ,OACT,CAAAM,IAAA,EACA,CAAAC,GAAA,CAAKC,OAAY,QAAIf,mBAAoB,CAAAe,OAAO,CAAC,EAAE,CACnD,CAAAE,IAAA,CAAK,KAAK,CAAC;EAGhB,IAAIG,YAAe,GAAAd,QAAA,CAASH,OAAQ,sBAAqB,EAAE;EAE5CiB,YAAA,GAAAA,YAAA,CAAajB,OAAA,CAAQ,YAAc;AAAA,EAAKS,UAAU;AAAA,CAAI;EACtDQ,YAAA,GAAAA,YAAA,CAAajB,OAAA,CAAQ,WAAa;AAAA,EAAKe,SAAS;AAAA,CAAI;EACpDE,YAAA,GAAAA,YAAA,CAAajB,OAAA,CAAQ,YAAc;AAAA,EAAKgB,OAAO;AAAA,CAAI;EAE3D,OAAAC,YAAA;AACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}