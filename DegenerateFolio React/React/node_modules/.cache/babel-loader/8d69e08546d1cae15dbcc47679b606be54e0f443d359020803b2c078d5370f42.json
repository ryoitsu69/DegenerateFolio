{"ast":null,"code":"import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\"use strict\";\nclass GpuEncoderSystem {\n  constructor(renderer) {\n    this._boundBindGroup = /* @__PURE__ */Object.create(null);\n    this._boundVertexBuffer = /* @__PURE__ */Object.create(null);\n    this._renderer = renderer;\n  }\n  renderStart() {\n    this.commandFinished = new Promise(resolve => {\n      this._resolveCommandFinished = resolve;\n    });\n    this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n  }\n  beginRenderPass(gpuRenderTarget) {\n    this.endRenderPass();\n    this._clearCache();\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n  }\n  endRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n    }\n    this.renderPassEncoder = null;\n  }\n  setViewport(viewport) {\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n  }\n  setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {\n    const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n    this.setPipeline(pipeline);\n  }\n  setPipeline(pipeline) {\n    if (this._boundPipeline === pipeline) return;\n    this._boundPipeline = pipeline;\n    this.renderPassEncoder.setPipeline(pipeline);\n  }\n  _setVertexBuffer(index, buffer) {\n    if (this._boundVertexBuffer[index] === buffer) return;\n    this._boundVertexBuffer[index] = buffer;\n    this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n  }\n  _setIndexBuffer(buffer) {\n    if (this._boundIndexBuffer === buffer) return;\n    this._boundIndexBuffer = buffer;\n    const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? \"uint16\" : \"uint32\";\n    this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n  }\n  resetBindGroup(index) {\n    this._boundBindGroup[index] = null;\n  }\n  setBindGroup(index, bindGroup, program) {\n    if (this._boundBindGroup[index] === bindGroup) return;\n    this._boundBindGroup[index] = bindGroup;\n    bindGroup._touch(this._renderer.textureGC.count);\n    const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n    this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n  }\n  setGeometry(geometry) {\n    for (const i in geometry.attributes) {\n      const attribute = geometry.attributes[i];\n      this._setVertexBuffer(attribute.location, attribute.buffer);\n    }\n    if (geometry.indexBuffer) {\n      this._setIndexBuffer(geometry.indexBuffer);\n    }\n  }\n  _setShaderBindGroups(shader, skipSync) {\n    for (const i in shader.groups) {\n      const bindGroup = shader.groups[i];\n      if (!skipSync) {\n        this._syncBindGroup(bindGroup);\n      }\n      this.setBindGroup(i, bindGroup, shader.gpuProgram);\n    }\n  }\n  _syncBindGroup(bindGroup) {\n    for (const j in bindGroup.resources) {\n      const resource = bindGroup.resources[j];\n      if (resource.isUniformGroup) {\n        this._renderer.ubo.updateUniformGroup(resource);\n      }\n    }\n  }\n  draw(options) {\n    const {\n      geometry,\n      shader,\n      state,\n      topology,\n      size,\n      start,\n      instanceCount,\n      skipSync\n    } = options;\n    this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n    this.setGeometry(geometry);\n    this._setShaderBindGroups(shader, skipSync);\n    if (geometry.indexBuffer) {\n      this.renderPassEncoder.drawIndexed(size || geometry.indexBuffer.data.length, instanceCount || geometry.instanceCount, start || 0);\n    } else {\n      this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount || geometry.instanceCount, start || 0);\n    }\n  }\n  finishRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n      this.renderPassEncoder = null;\n    }\n  }\n  postrender() {\n    this.finishRenderPass();\n    this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n    this._resolveCommandFinished();\n    this.commandEncoder = null;\n  }\n  // restores a render pass if finishRenderPass was called\n  // not optimised as really used for debugging!\n  // used when we want to stop drawing and log a texture..\n  restoreRenderPass() {\n    const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget, false, [0, 0, 0, 1]);\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n    const boundPipeline = this._boundPipeline;\n    const boundVertexBuffer = {\n      ...this._boundVertexBuffer\n    };\n    const boundIndexBuffer = this._boundIndexBuffer;\n    const boundBindGroup = {\n      ...this._boundBindGroup\n    };\n    this._clearCache();\n    const viewport = this._renderer.renderTarget.viewport;\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    this.setPipeline(boundPipeline);\n    for (const i in boundVertexBuffer) {\n      this._setVertexBuffer(i, boundVertexBuffer[i]);\n    }\n    for (const i in boundBindGroup) {\n      this.setBindGroup(i, boundBindGroup[i], null);\n    }\n    this._setIndexBuffer(boundIndexBuffer);\n  }\n  _clearCache() {\n    for (let i = 0; i < 16; i++) {\n      this._boundBindGroup[i] = null;\n      this._boundVertexBuffer[i] = null;\n    }\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  destroy() {\n    this._renderer = null;\n    this._gpu = null;\n    this._boundBindGroup = null;\n    this._boundVertexBuffer = null;\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n}\n/** @ignore */\nGpuEncoderSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"encoder\",\n  priority: 1\n};\nexport { GpuEncoderSystem };","map":{"version":3,"names":["GpuEncoderSystem","constructor","renderer","_boundBindGroup","Object","create","_boundVertexBuffer","_renderer","renderStart","commandFinished","Promise","resolve","_resolveCommandFinished","commandEncoder","gpu","device","createCommandEncoder","beginRenderPass","gpuRenderTarget","endRenderPass","_clearCache","renderPassEncoder","descriptor","end","setViewport","viewport","x","y","width","height","setPipelineFromGeometryProgramAndState","geometry","program","state","topology","pipeline","getPipeline","setPipeline","_boundPipeline","_setVertexBuffer","index","buffer","setVertexBuffer","updateBuffer","_setIndexBuffer","_boundIndexBuffer","indexFormat","data","BYTES_PER_ELEMENT","setIndexBuffer","resetBindGroup","setBindGroup","bindGroup","_touch","textureGC","count","gpuBindGroup","getBindGroup","setGeometry","i","attributes","attribute","location","indexBuffer","_setShaderBindGroups","shader","skipSync","groups","_syncBindGroup","gpuProgram","j","resources","resource","isUniformGroup","ubo","updateUniformGroup","draw","options","size","start","instanceCount","drawIndexed","length","getSize","finishRenderPass","postrender","_gpu","queue","submit","finish","restoreRenderPass","renderTarget","adaptor","getDescriptor","boundPipeline","boundVertexBuffer","boundIndexBuffer","boundBindGroup","destroy","contextChange","extension","type","ExtensionType","WebGPUSystem","name","priority"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gpu/GpuEncoderSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { Topology } from '../shared/geometry/const';\nimport type { Geometry } from '../shared/geometry/Geometry';\nimport type { Shader } from '../shared/shader/Shader';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { State } from '../shared/state/State';\nimport type { System } from '../shared/system/System';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { GpuRenderTarget } from './renderTarget/GpuRenderTarget';\nimport type { GpuRenderTargetAdaptor } from './renderTarget/GpuRenderTargetAdaptor';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles encoding commands for the GPU.\n * @memberof rendering\n */\nexport class GpuEncoderSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'encoder',\n        priority: 1\n    } as const;\n\n    public commandEncoder: GPUCommandEncoder;\n    public renderPassEncoder: GPURenderPassEncoder;\n    public commandFinished: Promise<void>;\n\n    private _resolveCommandFinished: (value: void) => void;\n\n    private _gpu: GPU;\n    private _boundBindGroup: Record<number, BindGroup> = Object.create(null);\n    private _boundVertexBuffer: Record<number, Buffer> = Object.create(null);\n    private _boundIndexBuffer: Buffer;\n    private _boundPipeline: GPURenderPipeline;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public renderStart(): void\n    {\n        this.commandFinished = new Promise((resolve) =>\n        {\n            this._resolveCommandFinished = resolve;\n        });\n\n        // generate a render pass description..\n        // create an encoder..\n        this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    }\n\n    public beginRenderPass(gpuRenderTarget: GpuRenderTarget)\n    {\n        this.endRenderPass();\n\n        this._clearCache();\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n    }\n\n    public endRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n        }\n\n        this.renderPassEncoder = null;\n    }\n\n    public setViewport(viewport: Rectangle): void\n    {\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    }\n\n    public setPipelineFromGeometryProgramAndState(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: any,\n        topology?: Topology,\n    ): void\n    {\n        const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n\n        this.setPipeline(pipeline);\n    }\n\n    public setPipeline(pipeline: GPURenderPipeline)\n    {\n        if (this._boundPipeline === pipeline) return;\n        this._boundPipeline = pipeline;\n\n        this.renderPassEncoder.setPipeline(pipeline);\n    }\n\n    private _setVertexBuffer(index: number, buffer: Buffer)\n    {\n        if (this._boundVertexBuffer[index] === buffer) return;\n\n        this._boundVertexBuffer[index] = buffer;\n\n        this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n    }\n\n    private _setIndexBuffer(buffer: Buffer)\n    {\n        if (this._boundIndexBuffer === buffer) return;\n\n        this._boundIndexBuffer = buffer;\n\n        const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? 'uint16' : 'uint32';\n\n        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n    }\n\n    public resetBindGroup(index: number)\n    {\n        this._boundBindGroup[index] = null;\n    }\n\n    public setBindGroup(index: number, bindGroup: BindGroup, program: GpuProgram)\n    {\n        if (this._boundBindGroup[index] === bindGroup) return;\n        this._boundBindGroup[index] = bindGroup;\n\n        bindGroup._touch(this._renderer.textureGC.count);\n\n        // TODO getting the bind group works as it looks at th e assets and generates a key\n        // should this just be hidden behind a dirty flag?\n        const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n\n        // mark each item as having been used..\n        this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n    }\n\n    public setGeometry(geometry: Geometry)\n    {\n        for (const i in geometry.attributes)\n        {\n            const attribute = geometry.attributes[i];\n\n            this._setVertexBuffer(attribute.location, attribute.buffer);\n        }\n\n        if (geometry.indexBuffer)\n        {\n            this._setIndexBuffer(geometry.indexBuffer);\n        }\n    }\n\n    private _setShaderBindGroups(shader: Shader, skipSync?: boolean)\n    {\n        for (const i in shader.groups)\n        {\n            const bindGroup = shader.groups[i] as BindGroup;\n\n            // update any uniforms?\n            if (!skipSync)\n            {\n                this._syncBindGroup(bindGroup);\n            }\n\n            this.setBindGroup(i as unknown as number, bindGroup, shader.gpuProgram);\n        }\n    }\n\n    private _syncBindGroup(bindGroup: BindGroup)\n    {\n        for (const j in bindGroup.resources)\n        {\n            const resource = bindGroup.resources[j];\n\n            if ((resource as UniformGroup).isUniformGroup)\n            {\n                this._renderer.ubo.updateUniformGroup(resource as UniformGroup);\n            }\n        }\n    }\n\n    public draw(options: {\n        geometry: Geometry;\n        shader: Shader;\n        state?: State;\n        topology?: Topology;\n        size?: number;\n        start?: number;\n        instanceCount?: number;\n        skipSync?: boolean;\n    })\n    {\n        const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n\n        this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n        this.setGeometry(geometry);\n        this._setShaderBindGroups(shader, skipSync);\n\n        if (geometry.indexBuffer)\n        {\n            this.renderPassEncoder.drawIndexed(\n                size || geometry.indexBuffer.data.length,\n                instanceCount || geometry.instanceCount,\n                start || 0\n            );\n        }\n        else\n        {\n            this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount || geometry.instanceCount, start || 0);\n        }\n    }\n\n    public finishRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n            this.renderPassEncoder = null;\n        }\n    }\n\n    public postrender()\n    {\n        this.finishRenderPass();\n\n        this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n\n        this._resolveCommandFinished();\n\n        this.commandEncoder = null;\n    }\n\n    // restores a render pass if finishRenderPass was called\n    // not optimised as really used for debugging!\n    // used when we want to stop drawing and log a texture..\n    public restoreRenderPass()\n    {\n        const descriptor = (this._renderer.renderTarget.adaptor as GpuRenderTargetAdaptor).getDescriptor(\n            this._renderer.renderTarget.renderTarget,\n            false,\n            [0, 0, 0, 1],\n        );\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n\n        const boundPipeline = this._boundPipeline;\n        const boundVertexBuffer = { ...this._boundVertexBuffer };\n        const boundIndexBuffer = this._boundIndexBuffer;\n        const boundBindGroup = { ...this._boundBindGroup };\n\n        this._clearCache();\n\n        const viewport = this._renderer.renderTarget.viewport;\n\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n        // reinstate the cache...\n\n        this.setPipeline(boundPipeline);\n\n        for (const i in boundVertexBuffer)\n        {\n            this._setVertexBuffer(i as unknown as number, boundVertexBuffer[i]);\n        }\n\n        for (const i in boundBindGroup)\n        {\n            this.setBindGroup(i as unknown as number, boundBindGroup[i], null);\n        }\n\n        this._setIndexBuffer(boundIndexBuffer);\n    }\n\n    private _clearCache()\n    {\n        for (let i = 0; i < 16; i++)\n        {\n            this._boundBindGroup[i] = null;\n            this._boundVertexBuffer[i] = null;\n        }\n\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._gpu = null;\n        this._boundBindGroup = null;\n        this._boundVertexBuffer = null;\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}