{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pubkeyToAddress = exports.pubkeyToRawAddress = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nfunction rawEd25519PubkeyToRawAddress(pubkeyData) {\n  if (pubkeyData.length !== 32) {\n    throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);\n  }\n  return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);\n}\nexports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;\nfunction rawSecp256k1PubkeyToRawAddress(pubkeyData) {\n  if (pubkeyData.length !== 33) {\n    throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);\n  }\n  return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));\n}\nexports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;\n/**\n * Returns Tendermint address as bytes.\n *\n * This is for addresses that are derived by the Tendermint keypair (typically Ed25519).\n * Sometimes those addresses are bech32-encoded and contain the term \"cons\" in the presix\n * (\"cosmosvalcons1...\").\n *\n * For secp256k1 this assumes we already have a compressed pubkey, which is the default in Cosmos.\n */\nfunction pubkeyToRawAddress(type, data) {\n  switch (type) {\n    case \"ed25519\":\n      return rawEd25519PubkeyToRawAddress(data);\n    case \"secp256k1\":\n      return rawSecp256k1PubkeyToRawAddress(data);\n    default:\n      // Keep this case here to guard against new types being added but not handled\n      throw new Error(`Pubkey type ${type} not supported`);\n  }\n}\nexports.pubkeyToRawAddress = pubkeyToRawAddress;\n/**\n * Returns Tendermint address in uppercase hex format.\n *\n * This is for addresses that are derived by the Tendermint keypair (typically Ed25519).\n * Sometimes those addresses are bech32-encoded and contain the term \"cons\" in the presix\n * (\"cosmosvalcons1...\").\n *\n * For secp256k1 this assumes we already have a compressed pubkey, which is the default in Cosmos.\n */\nfunction pubkeyToAddress(type, data) {\n  return (0, encoding_1.toHex)(pubkeyToRawAddress(type, data)).toUpperCase();\n}\nexports.pubkeyToAddress = pubkeyToAddress;","map":{"version":3,"names":["crypto_1","require","encoding_1","rawEd25519PubkeyToRawAddress","pubkeyData","length","Error","sha256","slice","exports","rawSecp256k1PubkeyToRawAddress","ripemd160","pubkeyToRawAddress","type","data","pubkeyToAddress","toHex","toUpperCase"],"sources":["../src/addresses.ts"],"sourcesContent":[null],"mappings":";;;;;;AAAA,MAAAA,QAAA,GAAAC,OAAA;AACA,MAAAC,UAAA,GAAAD,OAAA;AAEA,SAAgBE,4BAA4BA,CAACC,UAAsB;EACjE,IAAIA,UAAU,CAACC,MAAM,KAAK,EAAE,EAAE;IAC5B,MAAM,IAAIC,KAAK,CAAC,kCAAkCF,UAAU,CAACC,MAAM,EAAE,CAAC;;EAExE,OAAO,IAAAL,QAAA,CAAAO,MAAM,EAACH,UAAU,CAAC,CAACI,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;AACxC;AALAC,OAAA,CAAAN,4BAAA,GAAAA,4BAAA;AAOA,SAAgBO,8BAA8BA,CAACN,UAAsB;EACnE,IAAIA,UAAU,CAACC,MAAM,KAAK,EAAE,EAAE;IAC5B,MAAM,IAAIC,KAAK,CAAC,iDAAiDF,UAAU,CAACC,MAAM,EAAE,CAAC;;EAEvF,OAAO,IAAAL,QAAA,CAAAW,SAAS,EAAC,IAAAX,QAAA,CAAAO,MAAM,EAACH,UAAU,CAAC,CAAC;AACtC;AALAK,OAAA,CAAAC,8BAAA,GAAAA,8BAAA;AAOA;;;;;;;;;AASA,SAAgBE,kBAAkBA,CAACC,IAA6B,EAAEC,IAAgB;EAChF,QAAQD,IAAI;IACV,KAAK,SAAS;MACZ,OAAOV,4BAA4B,CAACW,IAAI,CAAC;IAC3C,KAAK,WAAW;MACd,OAAOJ,8BAA8B,CAACI,IAAI,CAAC;IAC7C;MACE;MACA,MAAM,IAAIR,KAAK,CAAC,eAAeO,IAAI,gBAAgB,CAAC;;AAE1D;AAVAJ,OAAA,CAAAG,kBAAA,GAAAA,kBAAA;AAYA;;;;;;;;;AASA,SAAgBG,eAAeA,CAACF,IAA6B,EAAEC,IAAgB;EAC7E,OAAO,IAAAZ,UAAA,CAAAc,KAAK,EAACJ,kBAAkB,CAACC,IAAI,EAAEC,IAAI,CAAC,CAAC,CAACG,WAAW,EAAE;AAC5D;AAFAR,OAAA,CAAAM,eAAA,GAAAA,eAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}