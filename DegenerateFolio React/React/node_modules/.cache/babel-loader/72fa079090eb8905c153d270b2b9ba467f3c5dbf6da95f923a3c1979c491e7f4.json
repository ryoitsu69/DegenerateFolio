{"ast":null,"code":"const CHR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst map = new Array(256);\nfor (let i = 0, count = CHR.length; i < count; i++) {\n  map[CHR.charCodeAt(i)] = i;\n}\n/**\n * @name base64Decode\n * @description\n * A base64 decoding function that operates in all environments. Unlike decoding\n * from Buffer (Node.js only) or atob (browser-only) this implementation is\n * slightly slower, but it is platform independent.\n *\n * For our usage, since we have access to the static final size, so we decode\n * to a specified output buffer. This also means we have applied a number of\n * optimizations based on this - checking output position instead of chars.\n */\nexport function base64Decode(data, out) {\n  let byte = 0;\n  let bits = 0;\n  let pos = -1;\n  for (let i = 0, last = out.length - 1; pos !== last; i++) {\n    // each character represents 6 bits\n    byte = byte << 6 | map[data.charCodeAt(i)];\n    // each byte needs to contain 8 bits\n    if ((bits += 6) >= 8) {\n      out[++pos] = byte >>> (bits -= 8) & 0xff;\n    }\n  }\n  return out;\n}","map":{"version":3,"names":["CHR","map","Array","i","count","length","charCodeAt","base64Decode","data","out","byte","bits","pos","last"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/wasm-util/base64.js"],"sourcesContent":["const CHR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst map = new Array(256);\nfor (let i = 0, count = CHR.length; i < count; i++) {\n    map[CHR.charCodeAt(i)] = i;\n}\n/**\n * @name base64Decode\n * @description\n * A base64 decoding function that operates in all environments. Unlike decoding\n * from Buffer (Node.js only) or atob (browser-only) this implementation is\n * slightly slower, but it is platform independent.\n *\n * For our usage, since we have access to the static final size, so we decode\n * to a specified output buffer. This also means we have applied a number of\n * optimizations based on this - checking output position instead of chars.\n */\nexport function base64Decode(data, out) {\n    let byte = 0;\n    let bits = 0;\n    let pos = -1;\n    for (let i = 0, last = out.length - 1; pos !== last; i++) {\n        // each character represents 6 bits\n        byte = (byte << 6) | map[data.charCodeAt(i)];\n        // each byte needs to contain 8 bits\n        if ((bits += 6) >= 8) {\n            out[++pos] = (byte >>> (bits -= 8)) & 0xff;\n        }\n    }\n    return out;\n}\n"],"mappings":"AAAA,MAAMA,GAAG,GAAG,kEAAkE;AAC9E,MAAMC,GAAG,GAAG,IAAIC,KAAK,CAAC,GAAG,CAAC;AAC1B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,KAAK,GAAGJ,GAAG,CAACK,MAAM,EAAEF,CAAC,GAAGC,KAAK,EAAED,CAAC,EAAE,EAAE;EAChDF,GAAG,CAACD,GAAG,CAACM,UAAU,CAACH,CAAC,CAAC,CAAC,GAAGA,CAAC;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,YAAYA,CAACC,IAAI,EAAEC,GAAG,EAAE;EACpC,IAAIC,IAAI,GAAG,CAAC;EACZ,IAAIC,IAAI,GAAG,CAAC;EACZ,IAAIC,GAAG,GAAG,CAAC,CAAC;EACZ,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEU,IAAI,GAAGJ,GAAG,CAACJ,MAAM,GAAG,CAAC,EAAEO,GAAG,KAAKC,IAAI,EAAEV,CAAC,EAAE,EAAE;IACtD;IACAO,IAAI,GAAIA,IAAI,IAAI,CAAC,GAAIT,GAAG,CAACO,IAAI,CAACF,UAAU,CAACH,CAAC,CAAC,CAAC;IAC5C;IACA,IAAI,CAACQ,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE;MAClBF,GAAG,CAAC,EAAEG,GAAG,CAAC,GAAIF,IAAI,MAAMC,IAAI,IAAI,CAAC,CAAC,GAAI,IAAI;IAC9C;EACJ;EACA,OAAOF,GAAG;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}