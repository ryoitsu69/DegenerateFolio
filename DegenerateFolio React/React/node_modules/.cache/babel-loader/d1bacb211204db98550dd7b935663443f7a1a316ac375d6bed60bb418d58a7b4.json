{"ast":null,"code":"import _defineProperty from \"/home/ryoitsu/Documents/test/react-todo-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { BehaviorSubject, combineLatest, from, map, of, switchMap, tap, toArray } from 'rxjs';\nimport { getAvailableDerives } from '@polkadot/api-derive';\nimport { memo, RpcCore } from '@polkadot/rpc-core';\nimport { WsProvider } from '@polkadot/rpc-provider';\nimport { expandMetadata, GenericExtrinsic, typeDefinitions, TypeRegistry } from '@polkadot/types';\nimport { getSpecRuntime } from '@polkadot/types-known';\nimport { arrayChunk, arrayFlatten, assertReturn, BN, compactStripLength, lazyMethod, lazyMethods, logger, nextTick, objectSpread, stringCamelCase, stringUpperFirst, u8aConcatStrict, u8aToHex } from '@polkadot/util';\nimport { blake2AsHex } from '@polkadot/util-crypto';\nimport { createSubmittable } from '../submittable/index.js';\nimport { augmentObject } from '../util/augmentObject.js';\nimport { decorateDeriveSections } from '../util/decorate.js';\nimport { extractStorageArgs } from '../util/validate.js';\nimport { Events } from './Events.js';\nimport { findCall, findError } from './find.js';\nconst PAGE_SIZE_K = 1000; // limit aligned with the 1k on the node (trie lookups are heavy)\nconst PAGE_SIZE_V = 250; // limited since the data may be > 16MB (e.g. misfiring elections)\nconst PAGE_SIZE_Q = 50; // queue of pending storage queries (mapped together, next tick)\nconst l = logger('api/init');\nlet instanceCounter = 0;\nfunction getAtQueryFn(api, _ref) {\n  let {\n    method,\n    section\n  } = _ref;\n  return assertReturn(api.rx.query[section] && api.rx.query[section][method], () => \"query.\".concat(section, \".\").concat(method, \" is not available in this version of the metadata\"));\n}\nexport class Decorate extends Events {\n  /**\n   * @description Create an instance of the class\n   *\n   * @param options Options object to create API instance or a Provider instance\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * import Api from '@polkadot/api/promise';\n   *\n   * const api = new Api().isReady();\n   *\n   * api.rpc.subscribeNewHeads((header) => {\n   *   console.log(`new block #${header.number.toNumber()}`);\n   * });\n   * ```\n   */\n  constructor(options, type, decorateMethod) {\n    var _options$source;\n    super();\n    _defineProperty(this, \"__internal__instanceId\", void 0);\n    _defineProperty(this, \"__internal__runtimeLog\", {});\n    _defineProperty(this, \"__internal__registry\", void 0);\n    _defineProperty(this, \"__internal__storageGetQ\", []);\n    _defineProperty(this, \"__internal__storageSubQ\", []);\n    // HACK Use BN import so decorateDerive works... yes, wtf.\n    _defineProperty(this, \"__phantom\", new BN(0));\n    _defineProperty(this, \"_type\", void 0);\n    _defineProperty(this, \"_call\", {});\n    _defineProperty(this, \"_consts\", {});\n    _defineProperty(this, \"_derive\", void 0);\n    _defineProperty(this, \"_errors\", {});\n    _defineProperty(this, \"_events\", {});\n    _defineProperty(this, \"_extrinsics\", void 0);\n    _defineProperty(this, \"_extrinsicType\", GenericExtrinsic.LATEST_EXTRINSIC_VERSION);\n    _defineProperty(this, \"_genesisHash\", void 0);\n    _defineProperty(this, \"_isConnected\", void 0);\n    _defineProperty(this, \"_isReady\", false);\n    _defineProperty(this, \"_query\", {});\n    _defineProperty(this, \"_queryMulti\", void 0);\n    _defineProperty(this, \"_rpc\", void 0);\n    _defineProperty(this, \"_rpcCore\", void 0);\n    _defineProperty(this, \"_runtimeMap\", {});\n    _defineProperty(this, \"_runtimeChain\", void 0);\n    _defineProperty(this, \"_runtimeMetadata\", void 0);\n    _defineProperty(this, \"_runtimeVersion\", void 0);\n    _defineProperty(this, \"_rx\", {\n      call: {},\n      consts: {},\n      query: {},\n      tx: {}\n    });\n    _defineProperty(this, \"_options\", void 0);\n    /**\n     * This is the one and only method concrete children classes need to implement.\n     * It's a higher-order function, which takes one argument\n     * `method: Method extends (...args: any[]) => Observable<any>`\n     * (and one optional `options`), and should return the user facing method.\n     * For example:\n     * - For ApiRx, `decorateMethod` should just be identity, because the input\n     * function is already an Observable\n     * - For ApiPromise, `decorateMethod` should return a function that takes all\n     * the parameters from `method`, adds an optional `callback` argument, and\n     * returns a Promise.\n     *\n     * We could easily imagine other user-facing interfaces, which are simply\n     * implemented by transforming the Observable to Stream/Iterator/Kefir/Bacon\n     * via `decorateMethod`.\n     */\n    _defineProperty(this, \"_decorateMethod\", void 0);\n    /**\n     * Put the `this.onCall` function of ApiRx here, because it is needed by\n     * `api._rx`.\n     */\n    _defineProperty(this, \"_rxDecorateMethod\", method => {\n      return method;\n    });\n    this.__internal__instanceId = \"\".concat(++instanceCounter);\n    this.__internal__registry = ((_options$source = options.source) === null || _options$source === void 0 ? void 0 : _options$source.registry) || options.registry || new TypeRegistry();\n    this._rx.callAt = (blockHash, knownVersion) => from(this.at(blockHash, knownVersion)).pipe(map(a => a.rx.call));\n    this._rx.queryAt = (blockHash, knownVersion) => from(this.at(blockHash, knownVersion)).pipe(map(a => a.rx.query));\n    this._rx.registry = this.__internal__registry;\n    this._decorateMethod = decorateMethod;\n    this._options = options;\n    this._type = type;\n    const provider = options.source ? options.source._rpcCore.provider.isClonable ? options.source._rpcCore.provider.clone() : options.source._rpcCore.provider : options.provider || new WsProvider();\n    // The RPC interface decorates the known interfaces on init\n    this._rpcCore = new RpcCore(this.__internal__instanceId, this.__internal__registry, {\n      isPedantic: this._options.isPedantic,\n      provider,\n      userRpc: this._options.rpc\n    });\n    this._isConnected = new BehaviorSubject(this._rpcCore.provider.isConnected);\n    this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;\n  }\n  /**\n   * @description Return the current used registry\n   */\n  get registry() {\n    return this.__internal__registry;\n  }\n  /**\n   * @description Creates an instance of a type as registered\n   */\n  createType(type) {\n    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      params[_key - 1] = arguments[_key];\n    }\n    return this.__internal__registry.createType(type, ...params);\n  }\n  /**\n   * @description Register additional user-defined of chain-specific types in the type registry\n   */\n  registerTypes(types) {\n    types && this.__internal__registry.register(types);\n  }\n  /**\n   * @returns `true` if the API operates with subscriptions\n   */\n  get hasSubscriptions() {\n    return this._rpcCore.provider.hasSubscriptions;\n  }\n  /**\n   * @returns `true` if the API decorate multi-key queries\n   */\n  get supportMulti() {\n    return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;\n  }\n  _emptyDecorated(registry, blockHash) {\n    return {\n      call: {},\n      consts: {},\n      errors: {},\n      events: {},\n      query: {},\n      registry,\n      rx: {\n        call: {},\n        query: {}\n      },\n      tx: createSubmittable(this._type, this._rx, this._decorateMethod, registry, blockHash)\n    };\n  }\n  _createDecorated(registry, fromEmpty, decoratedApi, blockHash) {\n    if (!decoratedApi) {\n      decoratedApi = this._emptyDecorated(registry.registry, blockHash);\n    }\n    if (fromEmpty || !registry.decoratedMeta) {\n      registry.decoratedMeta = expandMetadata(registry.registry, registry.metadata);\n    }\n    const runtime = this._decorateCalls(registry, this._decorateMethod, blockHash);\n    const runtimeRx = this._decorateCalls(registry, this._rxDecorateMethod, blockHash);\n    const storage = this._decorateStorage(registry.decoratedMeta, this._decorateMethod, blockHash);\n    const storageRx = this._decorateStorage(registry.decoratedMeta, this._rxDecorateMethod, blockHash);\n    augmentObject('consts', registry.decoratedMeta.consts, decoratedApi.consts, fromEmpty);\n    augmentObject('errors', registry.decoratedMeta.errors, decoratedApi.errors, fromEmpty);\n    augmentObject('events', registry.decoratedMeta.events, decoratedApi.events, fromEmpty);\n    augmentObject('query', storage, decoratedApi.query, fromEmpty);\n    augmentObject('query', storageRx, decoratedApi.rx.query, fromEmpty);\n    augmentObject('call', runtime, decoratedApi.call, fromEmpty);\n    augmentObject('call', runtimeRx, decoratedApi.rx.call, fromEmpty);\n    decoratedApi.findCall = callIndex => findCall(registry.registry, callIndex);\n    decoratedApi.findError = errorIndex => findError(registry.registry, errorIndex);\n    decoratedApi.queryMulti = blockHash ? this._decorateMultiAt(decoratedApi, this._decorateMethod, blockHash) : this._decorateMulti(this._decorateMethod);\n    decoratedApi.runtimeVersion = registry.runtimeVersion;\n    return {\n      createdAt: blockHash,\n      decoratedApi,\n      decoratedMeta: registry.decoratedMeta\n    };\n  }\n  _injectMetadata(registry) {\n    let fromEmpty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // clear the decoration, we are redoing it here\n    if (fromEmpty || !registry.decoratedApi) {\n      registry.decoratedApi = this._emptyDecorated(registry.registry);\n    }\n    const {\n      decoratedApi,\n      decoratedMeta\n    } = this._createDecorated(registry, fromEmpty, registry.decoratedApi);\n    this._call = decoratedApi.call;\n    this._consts = decoratedApi.consts;\n    this._errors = decoratedApi.errors;\n    this._events = decoratedApi.events;\n    this._query = decoratedApi.query;\n    this._rx.call = decoratedApi.rx.call;\n    this._rx.query = decoratedApi.rx.query;\n    const tx = this._decorateExtrinsics(decoratedMeta, this._decorateMethod);\n    const rxtx = this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod);\n    if (fromEmpty || !this._extrinsics) {\n      this._extrinsics = tx;\n      this._rx.tx = rxtx;\n    } else {\n      augmentObject('tx', tx, this._extrinsics, false);\n      augmentObject(null, rxtx, this._rx.tx, false);\n    }\n    augmentObject(null, decoratedMeta.consts, this._rx.consts, fromEmpty);\n    this.emit('decorated');\n  }\n  /**\n   * @deprecated\n   * backwards compatible endpoint for metadata injection, may be removed in the future (However, it is still useful for testing injection)\n   */\n  injectMetadata(metadata, fromEmpty, registry) {\n    this._injectMetadata({\n      counter: 0,\n      metadata,\n      registry: registry || this.__internal__registry,\n      runtimeVersion: this.__internal__registry.createType('RuntimeVersionPartial')\n    }, fromEmpty);\n  }\n  _decorateFunctionMeta(input, output) {\n    output.meta = input.meta;\n    output.method = input.method;\n    output.section = input.section;\n    output.toJSON = input.toJSON;\n    if (input.callIndex) {\n      output.callIndex = input.callIndex;\n    }\n    return output;\n  }\n  // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following\n  // manner to cater for both old and new:\n  //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)\n  //   - when non-zero, remove anything that is not in the array (we don't do this)\n  _filterRpc(methods, additional) {\n    // add any specific user-base RPCs\n    if (Object.keys(additional).length !== 0) {\n      this._rpcCore.addUserInterfaces(additional);\n      // re-decorate, only adding any new additional interfaces\n      this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc);\n      this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc);\n    }\n    // extract the actual sections from the methods (this is useful when\n    // we try and create mappings to runtime names via a hash mapping)\n    const sectionMap = {};\n    for (let i = 0, count = methods.length; i < count; i++) {\n      const [section] = methods[i].split('_');\n      sectionMap[section] = true;\n    }\n    // convert the actual section names into an easy name lookup\n    const sections = Object.keys(sectionMap);\n    for (let i = 0, count = sections.length; i < count; i++) {\n      const nameA = stringUpperFirst(sections[i]);\n      const nameB = \"\".concat(nameA, \"Api\");\n      this._runtimeMap[blake2AsHex(nameA, 64)] = nameA;\n      this._runtimeMap[blake2AsHex(nameB, 64)] = nameB;\n    }\n    // finally we filter the actual methods to expose\n    this._filterRpcMethods(methods);\n  }\n  _filterRpcMethods(exposed) {\n    const hasResults = exposed.length !== 0;\n    const allKnown = [...this._rpcCore.mapping.entries()];\n    const allKeys = [];\n    const count = allKnown.length;\n    for (let i = 0; i < count; i++) {\n      const [, {\n        alias,\n        endpoint,\n        method,\n        pubsub,\n        section\n      }] = allKnown[i];\n      allKeys.push(\"\".concat(section, \"_\").concat(method));\n      if (pubsub) {\n        allKeys.push(\"\".concat(section, \"_\").concat(pubsub[1]));\n        allKeys.push(\"\".concat(section, \"_\").concat(pubsub[2]));\n      }\n      if (alias) {\n        allKeys.push(...alias);\n      }\n      if (endpoint) {\n        allKeys.push(endpoint);\n      }\n    }\n    const unknown = exposed.filter(k => !allKeys.includes(k) && !k.includes('_unstable_'));\n    if (unknown.length && !this._options.noInitWarn) {\n      l.warn(\"RPC methods not decorated: \".concat(unknown.join(', ')));\n    }\n    // loop through all entries we have (populated in decorate) and filter as required\n    // only remove when we have results and method missing, or with no results if optional\n    for (let i = 0; i < count; i++) {\n      const [k, {\n        method,\n        section\n      }] = allKnown[i];\n      if (hasResults && !exposed.includes(k) && k !== 'rpc_methods') {\n        if (this._rpc[section]) {\n          delete this._rpc[section][method];\n          delete this._rx.rpc[section][method];\n        }\n      }\n    }\n  }\n  _rpcSubmitter(decorateMethod) {\n    var _this = this;\n    const method = function (method) {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n      return from(_this._rpcCore.provider.send(method, params));\n    };\n    return decorateMethod(method);\n  }\n  _decorateRpc(rpc, decorateMethod) {\n    let input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._rpcSubmitter(decorateMethod);\n    const out = input;\n    const decorateFn = (section, method) => {\n      const source = rpc[section][method];\n      const fn = decorateMethod(source, {\n        methodName: method\n      });\n      fn.meta = source.meta;\n      fn.raw = decorateMethod(source.raw, {\n        methodName: method\n      });\n      return fn;\n    };\n    for (let s = 0, scount = rpc.sections.length; s < scount; s++) {\n      const section = rpc.sections[s];\n      if (!Object.prototype.hasOwnProperty.call(out, section)) {\n        const methods = Object.keys(rpc[section]);\n        const decorateInternal = method => decorateFn(section, method);\n        for (let m = 0, mcount = methods.length; m < mcount; m++) {\n          const method = methods[m];\n          //  skip subscriptions where we have a non-subscribe interface\n          if (this.hasSubscriptions || !(method.startsWith('subscribe') || method.startsWith('unsubscribe'))) {\n            if (!Object.prototype.hasOwnProperty.call(out, section)) {\n              out[section] = {};\n            }\n            lazyMethod(out[section], method, decorateInternal);\n          }\n        }\n      }\n    }\n    return out;\n  }\n  // add all definition entries\n  _addRuntimeDef(result, additional) {\n    if (!additional) {\n      return;\n    }\n    const entries = Object.entries(additional);\n    for (let j = 0, ecount = entries.length; j < ecount; j++) {\n      const [key, defs] = entries[j];\n      if (result[key]) {\n        // we have this one already, step through for new versions or\n        // new methods and add those as applicable\n        for (let k = 0, dcount = defs.length; k < dcount; k++) {\n          const def = defs[k];\n          const prev = result[key].find(_ref2 => {\n            let {\n              version\n            } = _ref2;\n            return def.version === version;\n          });\n          if (prev) {\n            // interleave the new methods with the old - last definition wins\n            objectSpread(prev.methods, def.methods);\n          } else {\n            // we don't have this specific version, add it\n            result[key].push(def);\n          }\n        }\n      } else {\n        // we don't have this runtime definition, add it as-is\n        result[key] = defs;\n      }\n    }\n  }\n  // extract all runtime definitions\n  _getRuntimeDefs(registry, specName) {\n    let chain = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    const result = {};\n    const defValues = Object.values(typeDefinitions);\n    // options > chain/spec > built-in, apply in reverse order with\n    // methods overriding previous definitions (or interleave missing)\n    for (let i = 0, count = defValues.length; i < count; i++) {\n      this._addRuntimeDef(result, defValues[i].runtime);\n    }\n    this._addRuntimeDef(result, getSpecRuntime(registry, chain, specName));\n    this._addRuntimeDef(result, this._options.runtime);\n    return Object.entries(result);\n  }\n  // pre-metadata decoration\n  _decorateCalls(_ref3, decorateMethod, blockHash) {\n    let {\n      registry,\n      runtimeVersion: {\n        apis,\n        specName,\n        specVersion\n      }\n    } = _ref3;\n    const result = {};\n    const named = {};\n    const hashes = {};\n    const sections = this._getRuntimeDefs(registry, specName, this._runtimeChain);\n    const older = [];\n    const implName = \"\".concat(specName.toString(), \"/\").concat(specVersion.toString());\n    const hasLogged = this.__internal__runtimeLog[implName] || false;\n    this.__internal__runtimeLog[implName] = true;\n    for (let i = 0, scount = sections.length; i < scount; i++) {\n      const [_section, secs] = sections[i];\n      const sectionHash = blake2AsHex(_section, 64);\n      const rtApi = apis.find(_ref4 => {\n        let [a] = _ref4;\n        return a.eq(sectionHash);\n      });\n      hashes[sectionHash] = true;\n      if (rtApi) {\n        const all = secs.map(_ref5 => {\n          let {\n            version\n          } = _ref5;\n          return version;\n        }).sort();\n        const sec = secs.find(_ref6 => {\n          let {\n            version\n          } = _ref6;\n          return rtApi[1].eq(version);\n        });\n        if (sec) {\n          const section = stringCamelCase(_section);\n          const methods = Object.entries(sec.methods);\n          if (methods.length) {\n            if (!named[section]) {\n              named[section] = {};\n            }\n            for (let m = 0, mcount = methods.length; m < mcount; m++) {\n              const [_method, def] = methods[m];\n              const method = stringCamelCase(_method);\n              named[section][method] = objectSpread({\n                method,\n                name: \"\".concat(_section, \"_\").concat(_method),\n                section,\n                sectionHash\n              }, def);\n            }\n          }\n        } else {\n          older.push(\"\".concat(_section, \"/\").concat(rtApi[1].toString(), \" (\").concat(all.join('/'), \" known)\"));\n        }\n      }\n    }\n    // find the runtimes that we don't have hashes for\n    const notFound = apis.map(_ref7 => {\n      let [a, v] = _ref7;\n      return [a.toHex(), v.toString()];\n    }).filter(_ref8 => {\n      let [a] = _ref8;\n      return !hashes[a];\n    }).map(_ref9 => {\n      let [a, v] = _ref9;\n      return \"\".concat(this._runtimeMap[a] || a, \"/\").concat(v);\n    });\n    if (!this._options.noInitWarn && !hasLogged) {\n      if (older.length) {\n        l.warn(\"\".concat(implName, \": Not decorating runtime apis without matching versions: \").concat(older.join(', ')));\n      }\n      if (notFound.length) {\n        l.warn(\"\".concat(implName, \": Not decorating unknown runtime apis: \").concat(notFound.join(', ')));\n      }\n    }\n    const stateCall = blockHash ? (name, bytes) => this._rpcCore.state.call(name, bytes, blockHash) : (name, bytes) => this._rpcCore.state.call(name, bytes);\n    const lazySection = section => lazyMethods({}, Object.keys(named[section]), method => this._decorateCall(registry, named[section][method], stateCall, decorateMethod));\n    const modules = Object.keys(named);\n    for (let i = 0, count = modules.length; i < count; i++) {\n      lazyMethod(result, modules[i], lazySection);\n    }\n    return result;\n  }\n  _decorateCall(registry, def, stateCall, decorateMethod) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const decorated = decorateMethod(function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      if (args.length !== def.params.length) {\n        throw new Error(\"\".concat(def.name, \":: Expected \").concat(def.params.length, \" arguments, found \").concat(args.length));\n      }\n      const bytes = registry.createType('Raw', u8aConcatStrict(args.map((a, i) => registry.createTypeUnsafe(def.params[i].type, [a]).toU8a())));\n      return stateCall(def.name, bytes).pipe(map(r => registry.createTypeUnsafe(def.type, [r])));\n    });\n    decorated.meta = def;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorated;\n  }\n  // only be called if supportMulti is true\n  _decorateMulti(decorateMethod) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorateMethod(keys => keys.length ? (this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt)(keys.map(args => Array.isArray(args) ? args[0].creator.meta.type.isPlain ? [args[0].creator] : args[0].creator.meta.type.asMap.hashers.length === 1 ? [args[0].creator, args.slice(1)] : [args[0].creator, ...args.slice(1)] : [args.creator])) : of([]));\n  }\n  _decorateMultiAt(atApi, decorateMethod, blockHash) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorateMethod(calls => calls.length ? this._rpcCore.state.queryStorageAt(calls.map(args => {\n      if (Array.isArray(args)) {\n        const {\n          creator\n        } = getAtQueryFn(atApi, args[0].creator);\n        return creator.meta.type.isPlain ? [creator] : creator.meta.type.asMap.hashers.length === 1 ? [creator, args.slice(1)] : [creator, ...args.slice(1)];\n      }\n      return [getAtQueryFn(atApi, args.creator).creator];\n    }), blockHash) : of([]));\n  }\n  _decorateExtrinsics(_ref10, decorateMethod) {\n    let {\n      tx\n    } = _ref10;\n    const result = createSubmittable(this._type, this._rx, decorateMethod);\n    const lazySection = section => lazyMethods({}, Object.keys(tx[section]), method => method.startsWith('$') ? tx[section][method] : this._decorateExtrinsicEntry(tx[section][method], result));\n    const sections = Object.keys(tx);\n    for (let i = 0, count = sections.length; i < count; i++) {\n      lazyMethod(result, sections[i], lazySection);\n    }\n    return result;\n  }\n  _decorateExtrinsicEntry(method, creator) {\n    const decorated = function () {\n      return creator(method(...arguments));\n    };\n    // pass through the `.is`\n    decorated.is = other => method.is(other);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return this._decorateFunctionMeta(method, decorated);\n  }\n  _decorateStorage(_ref11, decorateMethod, blockHash) {\n    let {\n      query,\n      registry\n    } = _ref11;\n    const result = {};\n    const lazySection = section => lazyMethods({}, Object.keys(query[section]), method => blockHash ? this._decorateStorageEntryAt(registry, query[section][method], decorateMethod, blockHash) : this._decorateStorageEntry(query[section][method], decorateMethod));\n    const sections = Object.keys(query);\n    for (let i = 0, count = sections.length; i < count; i++) {\n      lazyMethod(result, sections[i], lazySection);\n    }\n    return result;\n  }\n  _decorateStorageEntry(creator, decorateMethod) {\n    var _this2 = this;\n    const getArgs = (args, registry) => extractStorageArgs(registry || this.__internal__registry, creator, args);\n    const getQueryAt = blockHash => from(this.at(blockHash)).pipe(map(api => getAtQueryFn(api, creator)));\n    // Disable this where it occurs for each field we are decorating\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n    const decorated = this._decorateStorageCall(creator, decorateMethod);\n    decorated.creator = creator;\n    // eslint-disable-next-line deprecation/deprecation\n    decorated.at = decorateMethod(function (blockHash) {\n      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        args[_key4 - 1] = arguments[_key4];\n      }\n      return getQueryAt(blockHash).pipe(switchMap(q => q(...args)));\n    });\n    decorated.hash = decorateMethod(function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _this2._rpcCore.state.getStorageHash(getArgs(args));\n    });\n    decorated.is = key => key.section === creator.section && key.method === creator.method;\n    decorated.key = function () {\n      return u8aToHex(compactStripLength(creator(...arguments))[1]);\n    };\n    decorated.keyPrefix = function () {\n      return u8aToHex(creator.keyPrefix(...arguments));\n    };\n    decorated.size = decorateMethod(function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _this2._rpcCore.state.getStorageSize(getArgs(args));\n    });\n    // eslint-disable-next-line deprecation/deprecation\n    decorated.sizeAt = decorateMethod(function (blockHash) {\n      for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n        args[_key7 - 1] = arguments[_key7];\n      }\n      return getQueryAt(blockHash).pipe(switchMap(q => _this2._rpcCore.state.getStorageSize(getArgs(args, q.creator.meta.registry), blockHash)));\n    });\n    // .keys() & .entries() only available on map types\n    if (creator.iterKey && creator.meta.type.isMap) {\n      decorated.entries = decorateMethod(memo(this.__internal__instanceId, function () {\n        for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n          args[_key8] = arguments[_key8];\n        }\n        return _this2._retrieveMapEntries(creator, null, args);\n      }));\n      // eslint-disable-next-line deprecation/deprecation\n      decorated.entriesAt = decorateMethod(memo(this.__internal__instanceId, function (blockHash) {\n        for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n          args[_key9 - 1] = arguments[_key9];\n        }\n        return getQueryAt(blockHash).pipe(switchMap(q => _this2._retrieveMapEntries(q.creator, blockHash, args)));\n      }));\n      decorated.entriesPaged = decorateMethod(memo(this.__internal__instanceId, opts => this._retrieveMapEntriesPaged(creator, undefined, opts)));\n      decorated.keys = decorateMethod(memo(this.__internal__instanceId, function () {\n        for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n          args[_key10] = arguments[_key10];\n        }\n        return _this2._retrieveMapKeys(creator, null, args);\n      }));\n      // eslint-disable-next-line deprecation/deprecation\n      decorated.keysAt = decorateMethod(memo(this.__internal__instanceId, function (blockHash) {\n        for (var _len11 = arguments.length, args = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n          args[_key11 - 1] = arguments[_key11];\n        }\n        return getQueryAt(blockHash).pipe(switchMap(q => _this2._retrieveMapKeys(q.creator, blockHash, args)));\n      }));\n      decorated.keysPaged = decorateMethod(memo(this.__internal__instanceId, opts => this._retrieveMapKeysPaged(creator, undefined, opts)));\n    }\n    if (this.supportMulti && creator.meta.type.isMap) {\n      // When using double map storage function, user need to pass double map key as an array\n      decorated.multi = decorateMethod(args => creator.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(args.map(a => [creator, [a]])) : this._retrieveMulti(args.map(a => [creator, a])));\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n    return this._decorateFunctionMeta(creator, decorated);\n  }\n  _decorateStorageEntryAt(registry, creator, decorateMethod, blockHash) {\n    var _this3 = this;\n    const getArgs = args => extractStorageArgs(registry, creator, args);\n    // Disable this where it occurs for each field we are decorating\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n    const decorated = decorateMethod(function () {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return _this3._rpcCore.state.getStorage(getArgs(args), blockHash);\n    });\n    decorated.creator = creator;\n    decorated.hash = decorateMethod(function () {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return _this3._rpcCore.state.getStorageHash(getArgs(args), blockHash);\n    });\n    decorated.is = key => key.section === creator.section && key.method === creator.method;\n    decorated.key = function () {\n      return u8aToHex(compactStripLength(creator(...arguments))[1]);\n    };\n    decorated.keyPrefix = function () {\n      return u8aToHex(creator.keyPrefix(...arguments));\n    };\n    decorated.size = decorateMethod(function () {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return _this3._rpcCore.state.getStorageSize(getArgs(args), blockHash);\n    });\n    // .keys() & .entries() only available on map types\n    if (creator.iterKey && creator.meta.type.isMap) {\n      decorated.entries = decorateMethod(memo(this.__internal__instanceId, function () {\n        for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n          args[_key15] = arguments[_key15];\n        }\n        return _this3._retrieveMapEntries(creator, blockHash, args);\n      }));\n      decorated.entriesPaged = decorateMethod(memo(this.__internal__instanceId, opts => this._retrieveMapEntriesPaged(creator, blockHash, opts)));\n      decorated.keys = decorateMethod(memo(this.__internal__instanceId, function () {\n        for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n          args[_key16] = arguments[_key16];\n        }\n        return _this3._retrieveMapKeys(creator, blockHash, args);\n      }));\n      decorated.keysPaged = decorateMethod(memo(this.__internal__instanceId, opts => this._retrieveMapKeysPaged(creator, blockHash, opts)));\n    }\n    if (this.supportMulti && creator.meta.type.isMap) {\n      // When using double map storage function, user need to pass double map key as an array\n      decorated.multi = decorateMethod(args => creator.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(args.map(a => [creator, [a]]), blockHash) : this._retrieveMulti(args.map(a => [creator, a]), blockHash));\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n    return this._decorateFunctionMeta(creator, decorated);\n  }\n  _queueStorage(call, queue) {\n    const query = queue === this.__internal__storageSubQ ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;\n    let queueIdx = queue.length - 1;\n    let valueIdx = 0;\n    let valueObs;\n    // if we don't have queue entries yet,\n    // or the current queue has fired (see from below),\n    // or the current queue has the max entries,\n    // then we create a new queue\n    if (queueIdx === -1 || !queue[queueIdx] || queue[queueIdx][1].length === PAGE_SIZE_Q) {\n      queueIdx++;\n      valueObs = from(\n      // we delay the execution until the next tick, this allows\n      // any queries made in this timeframe to be added to the same\n      // queue for a single query\n      new Promise(resolve => {\n        nextTick(() => {\n          // get all the calls in this instance, resolve with it\n          // and then clear the queue so we don't add more\n          // (anything after this will be added to a new queue)\n          const calls = queue[queueIdx][1];\n          delete queue[queueIdx];\n          resolve(calls);\n        });\n      })).pipe(switchMap(calls => query(calls)));\n      queue.push([valueObs, [call]]);\n    } else {\n      valueObs = queue[queueIdx][0];\n      valueIdx = queue[queueIdx][1].length;\n      queue[queueIdx][1].push(call);\n    }\n    return valueObs.pipe(\n    // return the single value at this index\n    map(values => values[valueIdx]));\n  }\n  // Decorate the base storage call. In the case or rxjs or promise-without-callback (await)\n  // we make a subscription, alternatively we push this through a single-shot query\n  _decorateStorageCall(creator, decorateMethod) {\n    var _this4 = this;\n    const memoed = memo(this.__internal__instanceId, function () {\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n      const call = extractStorageArgs(_this4.__internal__registry, creator, args);\n      if (!_this4.hasSubscriptions) {\n        return _this4._rpcCore.state.getStorage(call);\n      }\n      return _this4._queueStorage(call, _this4.__internal__storageSubQ);\n    });\n    return decorateMethod(memoed, {\n      methodName: creator.method,\n      overrideNoSub: function () {\n        for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n          args[_key18] = arguments[_key18];\n        }\n        return _this4._queueStorage(extractStorageArgs(_this4.__internal__registry, creator, args), _this4.__internal__storageGetQ);\n      }\n    });\n  }\n  // retrieve a set of values for a specific set of keys - here we chunk the keys into PAGE_SIZE sizes\n  _retrieveMulti(keys, blockHash) {\n    if (!keys.length) {\n      return of([]);\n    }\n    const query = this.hasSubscriptions && !blockHash ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;\n    if (keys.length <= PAGE_SIZE_V) {\n      return blockHash ? query(keys, blockHash) : query(keys);\n    }\n    return combineLatest(arrayChunk(keys, PAGE_SIZE_V).map(k => blockHash ? query(k, blockHash) : query(k))).pipe(map(arrayFlatten));\n  }\n  _retrieveMapKeys(_ref12, at, args) {\n    let {\n      iterKey,\n      meta,\n      method,\n      section\n    } = _ref12;\n    if (!iterKey || !meta.type.isMap) {\n      throw new Error('keys can only be retrieved on maps');\n    }\n    const headKey = iterKey(...args).toHex();\n    const startSubject = new BehaviorSubject(headKey);\n    const query = at ? startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey, at) : startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey);\n    const setMeta = key => key.setMeta(meta, section, method);\n    return startSubject.pipe(switchMap(query), map(keys => keys.map(setMeta)), tap(keys => nextTick(() => {\n      keys.length === PAGE_SIZE_K ? startSubject.next(keys[PAGE_SIZE_K - 1].toHex()) : startSubject.complete();\n    })), toArray(),\n    // toArray since we want to startSubject to be completed\n    map(arrayFlatten));\n  }\n  _retrieveMapKeysPaged(_ref13, at, opts) {\n    let {\n      iterKey,\n      meta,\n      method,\n      section\n    } = _ref13;\n    if (!iterKey || !meta.type.isMap) {\n      throw new Error('keys can only be retrieved on maps');\n    }\n    const setMeta = key => key.setMeta(meta, section, method);\n    const query = at ? headKey => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey, at) : headKey => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey);\n    return query(iterKey(...opts.args).toHex()).pipe(map(keys => keys.map(setMeta)));\n  }\n  _retrieveMapEntries(entry, at, args) {\n    const query = at ? keys => this._rpcCore.state.queryStorageAt(keys, at) : keys => this._rpcCore.state.queryStorageAt(keys);\n    return this._retrieveMapKeys(entry, at, args).pipe(switchMap(keys => keys.length ? combineLatest(arrayChunk(keys, PAGE_SIZE_V).map(query)).pipe(map(valsArr => arrayFlatten(valsArr).map((value, index) => [keys[index], value]))) : of([])));\n  }\n  _retrieveMapEntriesPaged(entry, at, opts) {\n    const query = at ? keys => this._rpcCore.state.queryStorageAt(keys, at) : keys => this._rpcCore.state.queryStorageAt(keys);\n    return this._retrieveMapKeysPaged(entry, at, opts).pipe(switchMap(keys => keys.length ? query(keys).pipe(map(valsArr => valsArr.map((value, index) => [keys[index], value]))) : of([])));\n  }\n  _decorateDeriveRx(decorateMethod) {\n    var _this$_runtimeVersion, _this$_options$typesB;\n    const specName = (_this$_runtimeVersion = this._runtimeVersion) === null || _this$_runtimeVersion === void 0 ? void 0 : _this$_runtimeVersion.specName.toString();\n    // Pull in derive from api-derive\n    const available = getAvailableDerives(this.__internal__instanceId, this._rx, objectSpread({}, this._options.derives, (_this$_options$typesB = this._options.typesBundle) === null || _this$_options$typesB === void 0 || (_this$_options$typesB = _this$_options$typesB.spec) === null || _this$_options$typesB === void 0 || (_this$_options$typesB = _this$_options$typesB[specName || '']) === null || _this$_options$typesB === void 0 ? void 0 : _this$_options$typesB.derives));\n    return decorateDeriveSections(decorateMethod, available);\n  }\n  _decorateDerive(decorateMethod) {\n    return decorateDeriveSections(decorateMethod, this._rx.derive);\n  }\n}","map":{"version":3,"names":["BehaviorSubject","combineLatest","from","map","of","switchMap","tap","toArray","getAvailableDerives","memo","RpcCore","WsProvider","expandMetadata","GenericExtrinsic","typeDefinitions","TypeRegistry","getSpecRuntime","arrayChunk","arrayFlatten","assertReturn","BN","compactStripLength","lazyMethod","lazyMethods","logger","nextTick","objectSpread","stringCamelCase","stringUpperFirst","u8aConcatStrict","u8aToHex","blake2AsHex","createSubmittable","augmentObject","decorateDeriveSections","extractStorageArgs","Events","findCall","findError","PAGE_SIZE_K","PAGE_SIZE_V","PAGE_SIZE_Q","l","instanceCounter","getAtQueryFn","api","_ref","method","section","rx","query","concat","Decorate","constructor","options","type","decorateMethod","_options$source","_defineProperty","LATEST_EXTRINSIC_VERSION","call","consts","tx","__internal__instanceId","__internal__registry","source","registry","_rx","callAt","blockHash","knownVersion","at","pipe","a","queryAt","_decorateMethod","_options","_type","provider","_rpcCore","isClonable","clone","isPedantic","userRpc","rpc","_isConnected","isConnected","hasSubscriptions","createType","_len","arguments","length","params","Array","_key","registerTypes","types","register","supportMulti","state","queryStorageAt","_emptyDecorated","errors","events","_createDecorated","fromEmpty","decoratedApi","decoratedMeta","metadata","runtime","_decorateCalls","runtimeRx","_rxDecorateMethod","storage","_decorateStorage","storageRx","callIndex","errorIndex","queryMulti","_decorateMultiAt","_decorateMulti","runtimeVersion","createdAt","_injectMetadata","undefined","_call","_consts","_errors","_events","_query","_decorateExtrinsics","rxtx","_extrinsics","emit","injectMetadata","counter","_decorateFunctionMeta","input","output","meta","toJSON","_filterRpc","methods","additional","Object","keys","addUserInterfaces","_decorateRpc","_rpc","sectionMap","i","count","split","sections","nameA","nameB","_runtimeMap","_filterRpcMethods","exposed","hasResults","allKnown","mapping","entries","allKeys","alias","endpoint","pubsub","push","unknown","filter","k","includes","noInitWarn","warn","join","_rpcSubmitter","_this","_len2","_key2","send","out","decorateFn","fn","methodName","raw","s","scount","prototype","hasOwnProperty","decorateInternal","m","mcount","startsWith","_addRuntimeDef","result","j","ecount","key","defs","dcount","def","prev","find","_ref2","version","_getRuntimeDefs","specName","chain","defValues","values","_ref3","apis","specVersion","named","hashes","_runtimeChain","older","implName","toString","hasLogged","__internal__runtimeLog","_section","secs","sectionHash","rtApi","_ref4","eq","all","_ref5","sort","sec","_ref6","_method","name","notFound","_ref7","v","toHex","_ref8","_ref9","stateCall","bytes","lazySection","_decorateCall","modules","decorated","_len3","args","_key3","Error","createTypeUnsafe","toU8a","r","subscribeStorage","isArray","creator","isPlain","asMap","hashers","slice","atApi","calls","_ref10","_decorateExtrinsicEntry","is","other","_ref11","_decorateStorageEntryAt","_decorateStorageEntry","_this2","getArgs","getQueryAt","_decorateStorageCall","_len4","_key4","q","hash","_len5","_key5","getStorageHash","keyPrefix","size","_len6","_key6","getStorageSize","sizeAt","_len7","_key7","iterKey","isMap","_len8","_key8","_retrieveMapEntries","entriesAt","_len9","_key9","entriesPaged","opts","_retrieveMapEntriesPaged","_len10","_key10","_retrieveMapKeys","keysAt","_len11","_key11","keysPaged","_retrieveMapKeysPaged","multi","_retrieveMulti","_this3","_len12","_key12","getStorage","_len13","_key13","_len14","_key14","_len15","_key15","_len16","_key16","_queueStorage","queue","__internal__storageSubQ","queueIdx","valueIdx","valueObs","Promise","resolve","_this4","memoed","_len17","_key17","overrideNoSub","_len18","_key18","__internal__storageGetQ","_ref12","headKey","startSubject","startKey","getKeysPaged","setMeta","next","complete","_ref13","pageSize","entry","valsArr","value","index","_decorateDeriveRx","_this$_runtimeVersion","_this$_options$typesB","_runtimeVersion","available","derives","typesBundle","spec","_decorateDerive","derive"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api/base/Decorate.js"],"sourcesContent":["import { BehaviorSubject, combineLatest, from, map, of, switchMap, tap, toArray } from 'rxjs';\nimport { getAvailableDerives } from '@polkadot/api-derive';\nimport { memo, RpcCore } from '@polkadot/rpc-core';\nimport { WsProvider } from '@polkadot/rpc-provider';\nimport { expandMetadata, GenericExtrinsic, typeDefinitions, TypeRegistry } from '@polkadot/types';\nimport { getSpecRuntime } from '@polkadot/types-known';\nimport { arrayChunk, arrayFlatten, assertReturn, BN, compactStripLength, lazyMethod, lazyMethods, logger, nextTick, objectSpread, stringCamelCase, stringUpperFirst, u8aConcatStrict, u8aToHex } from '@polkadot/util';\nimport { blake2AsHex } from '@polkadot/util-crypto';\nimport { createSubmittable } from '../submittable/index.js';\nimport { augmentObject } from '../util/augmentObject.js';\nimport { decorateDeriveSections } from '../util/decorate.js';\nimport { extractStorageArgs } from '../util/validate.js';\nimport { Events } from './Events.js';\nimport { findCall, findError } from './find.js';\nconst PAGE_SIZE_K = 1000; // limit aligned with the 1k on the node (trie lookups are heavy)\nconst PAGE_SIZE_V = 250; // limited since the data may be > 16MB (e.g. misfiring elections)\nconst PAGE_SIZE_Q = 50; // queue of pending storage queries (mapped together, next tick)\nconst l = logger('api/init');\nlet instanceCounter = 0;\nfunction getAtQueryFn(api, { method, section }) {\n    return assertReturn(api.rx.query[section] && api.rx.query[section][method], () => `query.${section}.${method} is not available in this version of the metadata`);\n}\nexport class Decorate extends Events {\n    __internal__instanceId;\n    __internal__runtimeLog = {};\n    __internal__registry;\n    __internal__storageGetQ = [];\n    __internal__storageSubQ = [];\n    // HACK Use BN import so decorateDerive works... yes, wtf.\n    __phantom = new BN(0);\n    _type;\n    _call = {};\n    _consts = {};\n    _derive;\n    _errors = {};\n    _events = {};\n    _extrinsics;\n    _extrinsicType = GenericExtrinsic.LATEST_EXTRINSIC_VERSION;\n    _genesisHash;\n    _isConnected;\n    _isReady = false;\n    _query = {};\n    _queryMulti;\n    _rpc;\n    _rpcCore;\n    _runtimeMap = {};\n    _runtimeChain;\n    _runtimeMetadata;\n    _runtimeVersion;\n    _rx = { call: {}, consts: {}, query: {}, tx: {} };\n    _options;\n    /**\n     * This is the one and only method concrete children classes need to implement.\n     * It's a higher-order function, which takes one argument\n     * `method: Method extends (...args: any[]) => Observable<any>`\n     * (and one optional `options`), and should return the user facing method.\n     * For example:\n     * - For ApiRx, `decorateMethod` should just be identity, because the input\n     * function is already an Observable\n     * - For ApiPromise, `decorateMethod` should return a function that takes all\n     * the parameters from `method`, adds an optional `callback` argument, and\n     * returns a Promise.\n     *\n     * We could easily imagine other user-facing interfaces, which are simply\n     * implemented by transforming the Observable to Stream/Iterator/Kefir/Bacon\n     * via `decorateMethod`.\n     */\n    _decorateMethod;\n    /**\n     * @description Create an instance of the class\n     *\n     * @param options Options object to create API instance or a Provider instance\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * import Api from '@polkadot/api/promise';\n     *\n     * const api = new Api().isReady();\n     *\n     * api.rpc.subscribeNewHeads((header) => {\n     *   console.log(`new block #${header.number.toNumber()}`);\n     * });\n     * ```\n     */\n    constructor(options, type, decorateMethod) {\n        super();\n        this.__internal__instanceId = `${++instanceCounter}`;\n        this.__internal__registry = options.source?.registry || options.registry || new TypeRegistry();\n        this._rx.callAt = (blockHash, knownVersion) => from(this.at(blockHash, knownVersion)).pipe(map((a) => a.rx.call));\n        this._rx.queryAt = (blockHash, knownVersion) => from(this.at(blockHash, knownVersion)).pipe(map((a) => a.rx.query));\n        this._rx.registry = this.__internal__registry;\n        this._decorateMethod = decorateMethod;\n        this._options = options;\n        this._type = type;\n        const provider = options.source\n            ? options.source._rpcCore.provider.isClonable\n                ? options.source._rpcCore.provider.clone()\n                : options.source._rpcCore.provider\n            : (options.provider || new WsProvider());\n        // The RPC interface decorates the known interfaces on init\n        this._rpcCore = new RpcCore(this.__internal__instanceId, this.__internal__registry, {\n            isPedantic: this._options.isPedantic,\n            provider,\n            userRpc: this._options.rpc\n        });\n        this._isConnected = new BehaviorSubject(this._rpcCore.provider.isConnected);\n        this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;\n    }\n    /**\n     * @description Return the current used registry\n     */\n    get registry() {\n        return this.__internal__registry;\n    }\n    /**\n     * @description Creates an instance of a type as registered\n     */\n    createType(type, ...params) {\n        return this.__internal__registry.createType(type, ...params);\n    }\n    /**\n     * @description Register additional user-defined of chain-specific types in the type registry\n     */\n    registerTypes(types) {\n        types && this.__internal__registry.register(types);\n    }\n    /**\n     * @returns `true` if the API operates with subscriptions\n     */\n    get hasSubscriptions() {\n        return this._rpcCore.provider.hasSubscriptions;\n    }\n    /**\n     * @returns `true` if the API decorate multi-key queries\n     */\n    get supportMulti() {\n        return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;\n    }\n    _emptyDecorated(registry, blockHash) {\n        return {\n            call: {},\n            consts: {},\n            errors: {},\n            events: {},\n            query: {},\n            registry,\n            rx: {\n                call: {},\n                query: {}\n            },\n            tx: createSubmittable(this._type, this._rx, this._decorateMethod, registry, blockHash)\n        };\n    }\n    _createDecorated(registry, fromEmpty, decoratedApi, blockHash) {\n        if (!decoratedApi) {\n            decoratedApi = this._emptyDecorated(registry.registry, blockHash);\n        }\n        if (fromEmpty || !registry.decoratedMeta) {\n            registry.decoratedMeta = expandMetadata(registry.registry, registry.metadata);\n        }\n        const runtime = this._decorateCalls(registry, this._decorateMethod, blockHash);\n        const runtimeRx = this._decorateCalls(registry, this._rxDecorateMethod, blockHash);\n        const storage = this._decorateStorage(registry.decoratedMeta, this._decorateMethod, blockHash);\n        const storageRx = this._decorateStorage(registry.decoratedMeta, this._rxDecorateMethod, blockHash);\n        augmentObject('consts', registry.decoratedMeta.consts, decoratedApi.consts, fromEmpty);\n        augmentObject('errors', registry.decoratedMeta.errors, decoratedApi.errors, fromEmpty);\n        augmentObject('events', registry.decoratedMeta.events, decoratedApi.events, fromEmpty);\n        augmentObject('query', storage, decoratedApi.query, fromEmpty);\n        augmentObject('query', storageRx, decoratedApi.rx.query, fromEmpty);\n        augmentObject('call', runtime, decoratedApi.call, fromEmpty);\n        augmentObject('call', runtimeRx, decoratedApi.rx.call, fromEmpty);\n        decoratedApi.findCall = (callIndex) => findCall(registry.registry, callIndex);\n        decoratedApi.findError = (errorIndex) => findError(registry.registry, errorIndex);\n        decoratedApi.queryMulti = blockHash\n            ? this._decorateMultiAt(decoratedApi, this._decorateMethod, blockHash)\n            : this._decorateMulti(this._decorateMethod);\n        decoratedApi.runtimeVersion = registry.runtimeVersion;\n        return {\n            createdAt: blockHash,\n            decoratedApi,\n            decoratedMeta: registry.decoratedMeta\n        };\n    }\n    _injectMetadata(registry, fromEmpty = false) {\n        // clear the decoration, we are redoing it here\n        if (fromEmpty || !registry.decoratedApi) {\n            registry.decoratedApi = this._emptyDecorated(registry.registry);\n        }\n        const { decoratedApi, decoratedMeta } = this._createDecorated(registry, fromEmpty, registry.decoratedApi);\n        this._call = decoratedApi.call;\n        this._consts = decoratedApi.consts;\n        this._errors = decoratedApi.errors;\n        this._events = decoratedApi.events;\n        this._query = decoratedApi.query;\n        this._rx.call = decoratedApi.rx.call;\n        this._rx.query = decoratedApi.rx.query;\n        const tx = this._decorateExtrinsics(decoratedMeta, this._decorateMethod);\n        const rxtx = this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod);\n        if (fromEmpty || !this._extrinsics) {\n            this._extrinsics = tx;\n            this._rx.tx = rxtx;\n        }\n        else {\n            augmentObject('tx', tx, this._extrinsics, false);\n            augmentObject(null, rxtx, this._rx.tx, false);\n        }\n        augmentObject(null, decoratedMeta.consts, this._rx.consts, fromEmpty);\n        this.emit('decorated');\n    }\n    /**\n     * @deprecated\n     * backwards compatible endpoint for metadata injection, may be removed in the future (However, it is still useful for testing injection)\n     */\n    injectMetadata(metadata, fromEmpty, registry) {\n        this._injectMetadata({ counter: 0, metadata, registry: registry || this.__internal__registry, runtimeVersion: this.__internal__registry.createType('RuntimeVersionPartial') }, fromEmpty);\n    }\n    _decorateFunctionMeta(input, output) {\n        output.meta = input.meta;\n        output.method = input.method;\n        output.section = input.section;\n        output.toJSON = input.toJSON;\n        if (input.callIndex) {\n            output.callIndex = input.callIndex;\n        }\n        return output;\n    }\n    // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following\n    // manner to cater for both old and new:\n    //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)\n    //   - when non-zero, remove anything that is not in the array (we don't do this)\n    _filterRpc(methods, additional) {\n        // add any specific user-base RPCs\n        if (Object.keys(additional).length !== 0) {\n            this._rpcCore.addUserInterfaces(additional);\n            // re-decorate, only adding any new additional interfaces\n            this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc);\n            this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc);\n        }\n        // extract the actual sections from the methods (this is useful when\n        // we try and create mappings to runtime names via a hash mapping)\n        const sectionMap = {};\n        for (let i = 0, count = methods.length; i < count; i++) {\n            const [section] = methods[i].split('_');\n            sectionMap[section] = true;\n        }\n        // convert the actual section names into an easy name lookup\n        const sections = Object.keys(sectionMap);\n        for (let i = 0, count = sections.length; i < count; i++) {\n            const nameA = stringUpperFirst(sections[i]);\n            const nameB = `${nameA}Api`;\n            this._runtimeMap[blake2AsHex(nameA, 64)] = nameA;\n            this._runtimeMap[blake2AsHex(nameB, 64)] = nameB;\n        }\n        // finally we filter the actual methods to expose\n        this._filterRpcMethods(methods);\n    }\n    _filterRpcMethods(exposed) {\n        const hasResults = exposed.length !== 0;\n        const allKnown = [...this._rpcCore.mapping.entries()];\n        const allKeys = [];\n        const count = allKnown.length;\n        for (let i = 0; i < count; i++) {\n            const [, { alias, endpoint, method, pubsub, section }] = allKnown[i];\n            allKeys.push(`${section}_${method}`);\n            if (pubsub) {\n                allKeys.push(`${section}_${pubsub[1]}`);\n                allKeys.push(`${section}_${pubsub[2]}`);\n            }\n            if (alias) {\n                allKeys.push(...alias);\n            }\n            if (endpoint) {\n                allKeys.push(endpoint);\n            }\n        }\n        const unknown = exposed.filter((k) => !allKeys.includes(k) &&\n            !k.includes('_unstable_'));\n        if (unknown.length && !this._options.noInitWarn) {\n            l.warn(`RPC methods not decorated: ${unknown.join(', ')}`);\n        }\n        // loop through all entries we have (populated in decorate) and filter as required\n        // only remove when we have results and method missing, or with no results if optional\n        for (let i = 0; i < count; i++) {\n            const [k, { method, section }] = allKnown[i];\n            if (hasResults && !exposed.includes(k) && k !== 'rpc_methods') {\n                if (this._rpc[section]) {\n                    delete this._rpc[section][method];\n                    delete this._rx.rpc[section][method];\n                }\n            }\n        }\n    }\n    _rpcSubmitter(decorateMethod) {\n        const method = (method, ...params) => {\n            return from(this._rpcCore.provider.send(method, params));\n        };\n        return decorateMethod(method);\n    }\n    _decorateRpc(rpc, decorateMethod, input = this._rpcSubmitter(decorateMethod)) {\n        const out = input;\n        const decorateFn = (section, method) => {\n            const source = rpc[section][method];\n            const fn = decorateMethod(source, { methodName: method });\n            fn.meta = source.meta;\n            fn.raw = decorateMethod(source.raw, { methodName: method });\n            return fn;\n        };\n        for (let s = 0, scount = rpc.sections.length; s < scount; s++) {\n            const section = rpc.sections[s];\n            if (!Object.prototype.hasOwnProperty.call(out, section)) {\n                const methods = Object.keys(rpc[section]);\n                const decorateInternal = (method) => decorateFn(section, method);\n                for (let m = 0, mcount = methods.length; m < mcount; m++) {\n                    const method = methods[m];\n                    //  skip subscriptions where we have a non-subscribe interface\n                    if (this.hasSubscriptions || !(method.startsWith('subscribe') || method.startsWith('unsubscribe'))) {\n                        if (!Object.prototype.hasOwnProperty.call(out, section)) {\n                            out[section] = {};\n                        }\n                        lazyMethod(out[section], method, decorateInternal);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n    // add all definition entries\n    _addRuntimeDef(result, additional) {\n        if (!additional) {\n            return;\n        }\n        const entries = Object.entries(additional);\n        for (let j = 0, ecount = entries.length; j < ecount; j++) {\n            const [key, defs] = entries[j];\n            if (result[key]) {\n                // we have this one already, step through for new versions or\n                // new methods and add those as applicable\n                for (let k = 0, dcount = defs.length; k < dcount; k++) {\n                    const def = defs[k];\n                    const prev = result[key].find(({ version }) => def.version === version);\n                    if (prev) {\n                        // interleave the new methods with the old - last definition wins\n                        objectSpread(prev.methods, def.methods);\n                    }\n                    else {\n                        // we don't have this specific version, add it\n                        result[key].push(def);\n                    }\n                }\n            }\n            else {\n                // we don't have this runtime definition, add it as-is\n                result[key] = defs;\n            }\n        }\n    }\n    // extract all runtime definitions\n    _getRuntimeDefs(registry, specName, chain = '') {\n        const result = {};\n        const defValues = Object.values(typeDefinitions);\n        // options > chain/spec > built-in, apply in reverse order with\n        // methods overriding previous definitions (or interleave missing)\n        for (let i = 0, count = defValues.length; i < count; i++) {\n            this._addRuntimeDef(result, defValues[i].runtime);\n        }\n        this._addRuntimeDef(result, getSpecRuntime(registry, chain, specName));\n        this._addRuntimeDef(result, this._options.runtime);\n        return Object.entries(result);\n    }\n    // pre-metadata decoration\n    _decorateCalls({ registry, runtimeVersion: { apis, specName, specVersion } }, decorateMethod, blockHash) {\n        const result = {};\n        const named = {};\n        const hashes = {};\n        const sections = this._getRuntimeDefs(registry, specName, this._runtimeChain);\n        const older = [];\n        const implName = `${specName.toString()}/${specVersion.toString()}`;\n        const hasLogged = this.__internal__runtimeLog[implName] || false;\n        this.__internal__runtimeLog[implName] = true;\n        for (let i = 0, scount = sections.length; i < scount; i++) {\n            const [_section, secs] = sections[i];\n            const sectionHash = blake2AsHex(_section, 64);\n            const rtApi = apis.find(([a]) => a.eq(sectionHash));\n            hashes[sectionHash] = true;\n            if (rtApi) {\n                const all = secs.map(({ version }) => version).sort();\n                const sec = secs.find(({ version }) => rtApi[1].eq(version));\n                if (sec) {\n                    const section = stringCamelCase(_section);\n                    const methods = Object.entries(sec.methods);\n                    if (methods.length) {\n                        if (!named[section]) {\n                            named[section] = {};\n                        }\n                        for (let m = 0, mcount = methods.length; m < mcount; m++) {\n                            const [_method, def] = methods[m];\n                            const method = stringCamelCase(_method);\n                            named[section][method] = objectSpread({ method, name: `${_section}_${_method}`, section, sectionHash }, def);\n                        }\n                    }\n                }\n                else {\n                    older.push(`${_section}/${rtApi[1].toString()} (${all.join('/')} known)`);\n                }\n            }\n        }\n        // find the runtimes that we don't have hashes for\n        const notFound = apis\n            .map(([a, v]) => [a.toHex(), v.toString()])\n            .filter(([a]) => !hashes[a])\n            .map(([a, v]) => `${this._runtimeMap[a] || a}/${v}`);\n        if (!this._options.noInitWarn && !hasLogged) {\n            if (older.length) {\n                l.warn(`${implName}: Not decorating runtime apis without matching versions: ${older.join(', ')}`);\n            }\n            if (notFound.length) {\n                l.warn(`${implName}: Not decorating unknown runtime apis: ${notFound.join(', ')}`);\n            }\n        }\n        const stateCall = blockHash\n            ? (name, bytes) => this._rpcCore.state.call(name, bytes, blockHash)\n            : (name, bytes) => this._rpcCore.state.call(name, bytes);\n        const lazySection = (section) => lazyMethods({}, Object.keys(named[section]), (method) => this._decorateCall(registry, named[section][method], stateCall, decorateMethod));\n        const modules = Object.keys(named);\n        for (let i = 0, count = modules.length; i < count; i++) {\n            lazyMethod(result, modules[i], lazySection);\n        }\n        return result;\n    }\n    _decorateCall(registry, def, stateCall, decorateMethod) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const decorated = decorateMethod((...args) => {\n            if (args.length !== def.params.length) {\n                throw new Error(`${def.name}:: Expected ${def.params.length} arguments, found ${args.length}`);\n            }\n            const bytes = registry.createType('Raw', u8aConcatStrict(args.map((a, i) => registry.createTypeUnsafe(def.params[i].type, [a]).toU8a())));\n            return stateCall(def.name, bytes).pipe(map((r) => registry.createTypeUnsafe(def.type, [r])));\n        });\n        decorated.meta = def;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return decorated;\n    }\n    // only be called if supportMulti is true\n    _decorateMulti(decorateMethod) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return decorateMethod((keys) => keys.length\n            ? (this.hasSubscriptions\n                ? this._rpcCore.state.subscribeStorage\n                : this._rpcCore.state.queryStorageAt)(keys.map((args) => Array.isArray(args)\n                ? args[0].creator.meta.type.isPlain\n                    ? [args[0].creator]\n                    : args[0].creator.meta.type.asMap.hashers.length === 1\n                        ? [args[0].creator, args.slice(1)]\n                        : [args[0].creator, ...args.slice(1)]\n                : [args.creator]))\n            : of([]));\n    }\n    _decorateMultiAt(atApi, decorateMethod, blockHash) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return decorateMethod((calls) => calls.length\n            ? this._rpcCore.state.queryStorageAt(calls.map((args) => {\n                if (Array.isArray(args)) {\n                    const { creator } = getAtQueryFn(atApi, args[0].creator);\n                    return creator.meta.type.isPlain\n                        ? [creator]\n                        : creator.meta.type.asMap.hashers.length === 1\n                            ? [creator, args.slice(1)]\n                            : [creator, ...args.slice(1)];\n                }\n                return [getAtQueryFn(atApi, args.creator).creator];\n            }), blockHash)\n            : of([]));\n    }\n    _decorateExtrinsics({ tx }, decorateMethod) {\n        const result = createSubmittable(this._type, this._rx, decorateMethod);\n        const lazySection = (section) => lazyMethods({}, Object.keys(tx[section]), (method) => method.startsWith('$')\n            ? tx[section][method]\n            : this._decorateExtrinsicEntry(tx[section][method], result));\n        const sections = Object.keys(tx);\n        for (let i = 0, count = sections.length; i < count; i++) {\n            lazyMethod(result, sections[i], lazySection);\n        }\n        return result;\n    }\n    _decorateExtrinsicEntry(method, creator) {\n        const decorated = (...params) => creator(method(...params));\n        // pass through the `.is`\n        decorated.is = (other) => method.is(other);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return this._decorateFunctionMeta(method, decorated);\n    }\n    _decorateStorage({ query, registry }, decorateMethod, blockHash) {\n        const result = {};\n        const lazySection = (section) => lazyMethods({}, Object.keys(query[section]), (method) => blockHash\n            ? this._decorateStorageEntryAt(registry, query[section][method], decorateMethod, blockHash)\n            : this._decorateStorageEntry(query[section][method], decorateMethod));\n        const sections = Object.keys(query);\n        for (let i = 0, count = sections.length; i < count; i++) {\n            lazyMethod(result, sections[i], lazySection);\n        }\n        return result;\n    }\n    _decorateStorageEntry(creator, decorateMethod) {\n        const getArgs = (args, registry) => extractStorageArgs(registry || this.__internal__registry, creator, args);\n        const getQueryAt = (blockHash) => from(this.at(blockHash)).pipe(map((api) => getAtQueryFn(api, creator)));\n        // Disable this where it occurs for each field we are decorating\n        /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n        const decorated = this._decorateStorageCall(creator, decorateMethod);\n        decorated.creator = creator;\n        // eslint-disable-next-line deprecation/deprecation\n        decorated.at = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => q(...args))));\n        decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args)));\n        decorated.is = (key) => key.section === creator.section &&\n            key.method === creator.method;\n        decorated.key = (...args) => u8aToHex(compactStripLength(creator(...args))[1]);\n        decorated.keyPrefix = (...args) => u8aToHex(creator.keyPrefix(...args));\n        decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args)));\n        // eslint-disable-next-line deprecation/deprecation\n        decorated.sizeAt = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => this._rpcCore.state.getStorageSize(getArgs(args, q.creator.meta.registry), blockHash))));\n        // .keys() & .entries() only available on map types\n        if (creator.iterKey && creator.meta.type.isMap) {\n            decorated.entries = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapEntries(creator, null, args)));\n            // eslint-disable-next-line deprecation/deprecation\n            decorated.entriesAt = decorateMethod(memo(this.__internal__instanceId, (blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => this._retrieveMapEntries(q.creator, blockHash, args)))));\n            decorated.entriesPaged = decorateMethod(memo(this.__internal__instanceId, (opts) => this._retrieveMapEntriesPaged(creator, undefined, opts)));\n            decorated.keys = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapKeys(creator, null, args)));\n            // eslint-disable-next-line deprecation/deprecation\n            decorated.keysAt = decorateMethod(memo(this.__internal__instanceId, (blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => this._retrieveMapKeys(q.creator, blockHash, args)))));\n            decorated.keysPaged = decorateMethod(memo(this.__internal__instanceId, (opts) => this._retrieveMapKeysPaged(creator, undefined, opts)));\n        }\n        if (this.supportMulti && creator.meta.type.isMap) {\n            // When using double map storage function, user need to pass double map key as an array\n            decorated.multi = decorateMethod((args) => creator.meta.type.asMap.hashers.length === 1\n                ? this._retrieveMulti(args.map((a) => [creator, [a]]))\n                : this._retrieveMulti(args.map((a) => [creator, a])));\n        }\n        /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n        return this._decorateFunctionMeta(creator, decorated);\n    }\n    _decorateStorageEntryAt(registry, creator, decorateMethod, blockHash) {\n        const getArgs = (args) => extractStorageArgs(registry, creator, args);\n        // Disable this where it occurs for each field we are decorating\n        /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n        const decorated = decorateMethod((...args) => this._rpcCore.state.getStorage(getArgs(args), blockHash));\n        decorated.creator = creator;\n        decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args), blockHash));\n        decorated.is = (key) => key.section === creator.section &&\n            key.method === creator.method;\n        decorated.key = (...args) => u8aToHex(compactStripLength(creator(...args))[1]);\n        decorated.keyPrefix = (...keys) => u8aToHex(creator.keyPrefix(...keys));\n        decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args), blockHash));\n        // .keys() & .entries() only available on map types\n        if (creator.iterKey && creator.meta.type.isMap) {\n            decorated.entries = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapEntries(creator, blockHash, args)));\n            decorated.entriesPaged = decorateMethod(memo(this.__internal__instanceId, (opts) => this._retrieveMapEntriesPaged(creator, blockHash, opts)));\n            decorated.keys = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapKeys(creator, blockHash, args)));\n            decorated.keysPaged = decorateMethod(memo(this.__internal__instanceId, (opts) => this._retrieveMapKeysPaged(creator, blockHash, opts)));\n        }\n        if (this.supportMulti && creator.meta.type.isMap) {\n            // When using double map storage function, user need to pass double map key as an array\n            decorated.multi = decorateMethod((args) => creator.meta.type.asMap.hashers.length === 1\n                ? this._retrieveMulti(args.map((a) => [creator, [a]]), blockHash)\n                : this._retrieveMulti(args.map((a) => [creator, a]), blockHash));\n        }\n        /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n        return this._decorateFunctionMeta(creator, decorated);\n    }\n    _queueStorage(call, queue) {\n        const query = queue === this.__internal__storageSubQ\n            ? this._rpcCore.state.subscribeStorage\n            : this._rpcCore.state.queryStorageAt;\n        let queueIdx = queue.length - 1;\n        let valueIdx = 0;\n        let valueObs;\n        // if we don't have queue entries yet,\n        // or the current queue has fired (see from below),\n        // or the current queue has the max entries,\n        // then we create a new queue\n        if (queueIdx === -1 || !queue[queueIdx] || queue[queueIdx][1].length === PAGE_SIZE_Q) {\n            queueIdx++;\n            valueObs = from(\n            // we delay the execution until the next tick, this allows\n            // any queries made in this timeframe to be added to the same\n            // queue for a single query\n            new Promise((resolve) => {\n                nextTick(() => {\n                    // get all the calls in this instance, resolve with it\n                    // and then clear the queue so we don't add more\n                    // (anything after this will be added to a new queue)\n                    const calls = queue[queueIdx][1];\n                    delete queue[queueIdx];\n                    resolve(calls);\n                });\n            })).pipe(switchMap((calls) => query(calls)));\n            queue.push([valueObs, [call]]);\n        }\n        else {\n            valueObs = queue[queueIdx][0];\n            valueIdx = queue[queueIdx][1].length;\n            queue[queueIdx][1].push(call);\n        }\n        return valueObs.pipe(\n        // return the single value at this index\n        map((values) => values[valueIdx]));\n    }\n    // Decorate the base storage call. In the case or rxjs or promise-without-callback (await)\n    // we make a subscription, alternatively we push this through a single-shot query\n    _decorateStorageCall(creator, decorateMethod) {\n        const memoed = memo(this.__internal__instanceId, (...args) => {\n            const call = extractStorageArgs(this.__internal__registry, creator, args);\n            if (!this.hasSubscriptions) {\n                return this._rpcCore.state.getStorage(call);\n            }\n            return this._queueStorage(call, this.__internal__storageSubQ);\n        });\n        return decorateMethod(memoed, {\n            methodName: creator.method,\n            overrideNoSub: (...args) => this._queueStorage(extractStorageArgs(this.__internal__registry, creator, args), this.__internal__storageGetQ)\n        });\n    }\n    // retrieve a set of values for a specific set of keys - here we chunk the keys into PAGE_SIZE sizes\n    _retrieveMulti(keys, blockHash) {\n        if (!keys.length) {\n            return of([]);\n        }\n        const query = this.hasSubscriptions && !blockHash\n            ? this._rpcCore.state.subscribeStorage\n            : this._rpcCore.state.queryStorageAt;\n        if (keys.length <= PAGE_SIZE_V) {\n            return blockHash\n                ? query(keys, blockHash)\n                : query(keys);\n        }\n        return combineLatest(arrayChunk(keys, PAGE_SIZE_V).map((k) => blockHash\n            ? query(k, blockHash)\n            : query(k))).pipe(map(arrayFlatten));\n    }\n    _retrieveMapKeys({ iterKey, meta, method, section }, at, args) {\n        if (!iterKey || !meta.type.isMap) {\n            throw new Error('keys can only be retrieved on maps');\n        }\n        const headKey = iterKey(...args).toHex();\n        const startSubject = new BehaviorSubject(headKey);\n        const query = at\n            ? (startKey) => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey, at)\n            : (startKey) => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey);\n        const setMeta = (key) => key.setMeta(meta, section, method);\n        return startSubject.pipe(switchMap(query), map((keys) => keys.map(setMeta)), tap((keys) => nextTick(() => {\n            keys.length === PAGE_SIZE_K\n                ? startSubject.next(keys[PAGE_SIZE_K - 1].toHex())\n                : startSubject.complete();\n        })), toArray(), // toArray since we want to startSubject to be completed\n        map(arrayFlatten));\n    }\n    _retrieveMapKeysPaged({ iterKey, meta, method, section }, at, opts) {\n        if (!iterKey || !meta.type.isMap) {\n            throw new Error('keys can only be retrieved on maps');\n        }\n        const setMeta = (key) => key.setMeta(meta, section, method);\n        const query = at\n            ? (headKey) => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey, at)\n            : (headKey) => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey);\n        return query(iterKey(...opts.args).toHex()).pipe(map((keys) => keys.map(setMeta)));\n    }\n    _retrieveMapEntries(entry, at, args) {\n        const query = at\n            ? (keys) => this._rpcCore.state.queryStorageAt(keys, at)\n            : (keys) => this._rpcCore.state.queryStorageAt(keys);\n        return this._retrieveMapKeys(entry, at, args).pipe(switchMap((keys) => keys.length\n            ? combineLatest(arrayChunk(keys, PAGE_SIZE_V).map(query)).pipe(map((valsArr) => arrayFlatten(valsArr).map((value, index) => [keys[index], value])))\n            : of([])));\n    }\n    _retrieveMapEntriesPaged(entry, at, opts) {\n        const query = at\n            ? (keys) => this._rpcCore.state.queryStorageAt(keys, at)\n            : (keys) => this._rpcCore.state.queryStorageAt(keys);\n        return this._retrieveMapKeysPaged(entry, at, opts).pipe(switchMap((keys) => keys.length\n            ? query(keys).pipe(map((valsArr) => valsArr.map((value, index) => [keys[index], value])))\n            : of([])));\n    }\n    _decorateDeriveRx(decorateMethod) {\n        const specName = this._runtimeVersion?.specName.toString();\n        // Pull in derive from api-derive\n        const available = getAvailableDerives(this.__internal__instanceId, this._rx, objectSpread({}, this._options.derives, this._options.typesBundle?.spec?.[specName || '']?.derives));\n        return decorateDeriveSections(decorateMethod, available);\n    }\n    _decorateDerive(decorateMethod) {\n        return decorateDeriveSections(decorateMethod, this._rx.derive);\n    }\n    /**\n     * Put the `this.onCall` function of ApiRx here, because it is needed by\n     * `api._rx`.\n     */\n    _rxDecorateMethod = (method) => {\n        return method;\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}