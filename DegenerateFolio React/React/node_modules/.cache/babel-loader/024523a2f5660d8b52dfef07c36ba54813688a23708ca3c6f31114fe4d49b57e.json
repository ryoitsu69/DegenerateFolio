{"ast":null,"code":"import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\"use strict\";\nconst _MeshGeometry = class _MeshGeometry extends Geometry {\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Float32Array) {\n      deprecation(v8_0_0, \"use new MeshGeometry({ positions, uvs, indices }) instead\");\n      options = {\n        positions: options,\n        uvs: args[1],\n        indices: args[2]\n      };\n    }\n    options = {\n      ..._MeshGeometry.defaultOptions,\n      ...options\n    };\n    const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n    const shrinkToFit = options.shrinkBuffersToFit;\n    const positionBuffer = new Buffer({\n      data: positions,\n      label: \"attribute-mesh-positions\",\n      shrinkToFit,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    const uvBuffer = new Buffer({\n      data: uvs,\n      label: \"attribute-mesh-uvs\",\n      shrinkToFit,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    const indexBuffer = new Buffer({\n      data: indices,\n      label: \"index-mesh-buffer\",\n      shrinkToFit,\n      usage: BufferUsage.INDEX | BufferUsage.COPY_DST\n    });\n    super({\n      attributes: {\n        aPosition: {\n          buffer: positionBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        },\n        aUV: {\n          buffer: uvBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        }\n      },\n      indexBuffer,\n      topology: options.topology\n    });\n    this.batchMode = \"auto\";\n  }\n  /** The positions of the mesh. */\n  get positions() {\n    return this.attributes.aPosition.buffer.data;\n  }\n  set positions(value) {\n    this.attributes.aPosition.buffer.data = value;\n  }\n  /** The UVs of the mesh. */\n  get uvs() {\n    return this.attributes.aUV.buffer.data;\n  }\n  set uvs(value) {\n    this.attributes.aUV.buffer.data = value;\n  }\n  /** The indices of the mesh. */\n  get indices() {\n    return this.indexBuffer.data;\n  }\n  set indices(value) {\n    this.indexBuffer.data = value;\n  }\n};\n_MeshGeometry.defaultOptions = {\n  topology: \"triangle-list\",\n  shrinkBuffersToFit: false\n};\nlet MeshGeometry = _MeshGeometry;\nexport { MeshGeometry };","map":{"version":3,"names":["_MeshGeometry","Geometry","constructor","args","options","Float32Array","deprecation","v8_0_0","positions","uvs","indices","defaultOptions","Uint32Array","shrinkToFit","shrinkBuffersToFit","positionBuffer","Buffer","data","label","usage","BufferUsage","VERTEX","COPY_DST","uvBuffer","indexBuffer","INDEX","attributes","aPosition","buffer","format","stride","offset","aUV","topology","batchMode","value","MeshGeometry"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/mesh/shared/MeshGeometry.ts"],"sourcesContent":["import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @memberof scene\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @memberof scene\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {scene.MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n"],"mappings":";;;;;AA8BO,MAAMA,aAAA,GAAN,MAAMA,aAAA,SAAqBC,QAClC;EAcIC,YAAA,GAAeC,IACf;IACI,IAAIC,OAAU,GAAAD,IAAA,CAAK,CAAC,KAAK,EAAC;IAE1B,IAAIC,OAAA,YAAmBC,YACvB;MAEIC,WAAA,CAAYC,MAAA,EAAQ,2DAA2D;MAGrEH,OAAA;QACNI,SAAW,EAAAJ,OAAA;QACXK,GAAA,EAAKN,IAAA,CAAK,CAAC;QACXO,OAAA,EAASP,IAAA,CAAK,CAAC;MAAA,CACnB;IAAA;IAGJC,OAAA,GAAU;MAAE,GAAGJ,aAAa,CAAAW,cAAA;MAAgB,GAAGP;IAAQ;IAEvD,MAAMI,SAAY,GAAAJ,OAAA,CAAQI,SAAa,QAAIH,YAAA,CAAa,CAAC,GAAG,CAAG,KAAG,CAAG,KAAG,CAAG,KAAG,CAAC,CAAC;IAChF,MAAMI,GAAM,GAAAL,OAAA,CAAQK,GAAO,QAAIJ,YAAA,CAAa,CAAC,GAAG,CAAG,KAAG,CAAG,KAAG,CAAG,KAAG,CAAC,CAAC;IACpE,MAAMK,OAAU,GAAAN,OAAA,CAAQM,OAAW,QAAIE,WAAY,EAAC,CAAG,KAAG,CAAG,KAAG,CAAG,GAAC,CAAC;IAErE,MAAMC,WAAA,GAAcT,OAAQ,CAAAU,kBAAA;IAEtB,MAAAC,cAAA,GAAiB,IAAIC,MAAO;MAC9BC,IAAM,EAAAT,SAAA;MACNU,KAAO;MACPL,WAAA;MACAM,KAAA,EAAOC,WAAY,CAAAC,MAAA,GAASD,WAAY,CAAAE;IAAA,CAC3C;IAEK,MAAAC,QAAA,GAAW,IAAIP,MAAO;MACxBC,IAAM,EAAAR,GAAA;MACNS,KAAO;MACPL,WAAA;MACAM,KAAA,EAAOC,WAAY,CAAAC,MAAA,GAASD,WAAY,CAAAE;IAAA,CAC3C;IAEK,MAAAE,WAAA,GAAc,IAAIR,MAAO;MAC3BC,IAAM,EAAAP,OAAA;MACNQ,KAAO;MACPL,WAAA;MACAM,KAAA,EAAOC,WAAY,CAAAK,KAAA,GAAQL,WAAY,CAAAE;IAAA,CAC1C;IAEK;MACFI,UAAY;QACRC,SAAW;UACPC,MAAQ,EAAAb,cAAA;UACRc,MAAQ;UACRC,MAAA,EAAQ,CAAI;UACZC,MAAQ;QAAA,CACZ;QACAC,GAAK;UACDJ,MAAQ,EAAAL,QAAA;UACRM,MAAQ;UACRC,MAAA,EAAQ,CAAI;UACZC,MAAQ;QAAA;MACZ,CACJ;MACAP,WAAA;MACAS,QAAA,EAAU7B,OAAQ,CAAA6B;IAAA,CACrB;IAvEL,KAAOC,SAAuB;EAAA;EAwE9B;EAGA,IAAI1B,SACJA,CAAA;IACW,YAAKkB,UAAW,CAAAC,SAAA,CAAUC,MAAO,CAAAX,IAAA;EAAA;EAG5C,IAAIT,UAAU2B,KACd;IACS,KAAAT,UAAA,CAAWC,SAAU,CAAAC,MAAA,CAAOX,IAAO,GAAAkB,KAAA;EAAA;EAC5C;EAGA,IAAI1B,GACJA,CAAA;IACW,YAAKiB,UAAW,CAAAM,GAAA,CAAIJ,MAAO,CAAAX,IAAA;EAAA;EAGtC,IAAIR,IAAI0B,KACR;IACS,KAAAT,UAAA,CAAWM,GAAI,CAAAJ,MAAA,CAAOX,IAAO,GAAAkB,KAAA;EAAA;EACtC;EAGA,IAAIzB,OACJA,CAAA;IACI,OAAO,KAAKc,WAAY,CAAAP,IAAA;EAAA;EAG5B,IAAIP,QAAQyB,KACZ;IACI,KAAKX,WAAA,CAAYP,IAAO,GAAAkB,KAAA;EAAA;AAEhC;AAjHanC,aAAA,CAEKW,cAAsC;EAChDsB,QAAU;EACVnB,kBAAoB;AACxB;AALG,IAAMsB,YAAN,GAAApC,aAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}