{"ast":null,"code":"import { settings } from \"@pixi/settings\";\nimport { uid } from \"@pixi/utils\";\nimport { BaseImageResource } from \"./BaseImageResource.mjs\";\nconst _SVGResource = class _SVGResource2 extends BaseImageResource {\n  /**\n   * @param sourceBase64 - Base64 encoded SVG element or URL for SVG file.\n   * @param {object} [options] - Options to use\n   * @param {number} [options.scale=1] - Scale to apply to SVG. Overridden by...\n   * @param {number} [options.width] - Rasterize SVG this wide. Aspect ratio preserved if height not specified.\n   * @param {number} [options.height] - Rasterize SVG this high. Aspect ratio preserved if width not specified.\n   * @param {boolean} [options.autoLoad=true] - Start loading right away.\n   */\n  constructor(sourceBase64, options) {\n    options = options || {}, super(settings.ADAPTER.createCanvas()), this._width = 0, this._height = 0, this.svg = sourceBase64, this.scale = options.scale || 1, this._overrideWidth = options.width, this._overrideHeight = options.height, this._resolve = null, this._crossorigin = options.crossorigin, this._load = null, options.autoLoad !== !1 && this.load();\n  }\n  load() {\n    return this._load ? this._load : (this._load = new Promise(resolve => {\n      if (this._resolve = () => {\n        this.update(), resolve(this);\n      }, _SVGResource2.SVG_XML.test(this.svg.trim())) {\n        if (!btoa) throw new Error(\"Your browser doesn't support base64 conversions.\");\n        this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;\n      }\n      this._loadSvg();\n    }), this._load);\n  }\n  /** Loads an SVG image from `imageUrl` or `data URL`. */\n  _loadSvg() {\n    const tempImage = new Image();\n    BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin), tempImage.src = this.svg, tempImage.onerror = event => {\n      this._resolve && (tempImage.onerror = null, this.onError.emit(event));\n    }, tempImage.onload = () => {\n      if (!this._resolve) return;\n      const svgWidth = tempImage.width,\n        svgHeight = tempImage.height;\n      if (!svgWidth || !svgHeight) throw new Error(\"The SVG image must have width and height defined (in pixels), canvas API needs them.\");\n      let width = svgWidth * this.scale,\n        height = svgHeight * this.scale;\n      (this._overrideWidth || this._overrideHeight) && (width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth, height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight), width = Math.round(width), height = Math.round(height);\n      const canvas = this.source;\n      canvas.width = width, canvas.height = height, canvas._pixiId = `canvas_${uid()}`, canvas.getContext(\"2d\").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height), this._resolve(), this._resolve = null;\n    };\n  }\n  /**\n   * Get size from an svg string using a regular expression.\n   * @param svgString - a serialized svg element\n   * @returns - image extension\n   */\n  static getSize(svgString) {\n    const sizeMatch = _SVGResource2.SVG_SIZE.exec(svgString),\n      size = {};\n    return sizeMatch && (size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3])), size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]))), size;\n  }\n  /** Destroys this texture. */\n  dispose() {\n    super.dispose(), this._resolve = null, this._crossorigin = null;\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @param {string} extension - The extension of source, if set\n   * @returns {boolean} - If the source is a SVG source or data file\n   */\n  static test(source, extension) {\n    return extension === \"svg\" || typeof source == \"string\" && source.startsWith(\"data:image/svg+xml\") || typeof source == \"string\" && _SVGResource2.SVG_XML.test(source);\n  }\n  // eslint-disable-line max-len\n};\n_SVGResource.SVG_XML = /^(<\\?xml[^?]+\\?>)?\\s*(<!--[^(-->)]*-->)?\\s*\\<svg/m,\n/**\n* Regular expression for SVG size.\n* @example &lt;svg width=\"100\" height=\"100\"&gt;&lt;/svg&gt;\n* @readonly\n*/\n_SVGResource.SVG_SIZE = /<svg[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*>/i;\nlet SVGResource = _SVGResource;\nexport { SVGResource };","map":{"version":3,"names":["_SVGResource","_SVGResource2","BaseImageResource","constructor","sourceBase64","options","settings","ADAPTER","createCanvas","_width","_height","svg","scale","_overrideWidth","width","_overrideHeight","height","_resolve","_crossorigin","crossorigin","_load","autoLoad","load","Promise","resolve","update","SVG_XML","test","trim","btoa","Error","unescape","encodeURIComponent","_loadSvg","tempImage","Image","crossOrigin","src","onerror","event","onError","emit","onload","svgWidth","svgHeight","Math","round","canvas","source","_pixiId","uid","getContext","drawImage","getSize","svgString","sizeMatch","SVG_SIZE","exec","size","parseFloat","dispose","extension","startsWith","SVGResource"],"sources":["/home/ryoitsu/node_modules/@pixi/core/src/textures/resources/SVGResource.ts"],"sourcesContent":["import { settings } from '@pixi/settings';\nimport { uid } from '@pixi/utils';\nimport { BaseImageResource } from './BaseImageResource';\n\nimport type { ISize } from '@pixi/math';\nimport type { ICanvas } from '@pixi/settings';\n\nexport interface ISVGResourceOptions\n{\n    source?: string;\n    scale?: number;\n    width?: number;\n    height?: number;\n    autoLoad?: boolean;\n    crossorigin?: boolean | string;\n}\n/**\n * Resource type for SVG elements and graphics.\n * @memberof PIXI\n */\nexport class SVGResource extends BaseImageResource\n{\n    /** Base64 encoded SVG element or URL for SVG file. */\n    public readonly svg: string;\n\n    /** The source scale to apply when rasterizing on load. */\n    public readonly scale: number;\n\n    /** A width override for rasterization on load. */\n    public readonly _overrideWidth: number;\n\n    /** A height override for rasterization on load. */\n    public readonly _overrideHeight: number;\n\n    /** Call when completely loaded. */\n    private _resolve: () => void;\n\n    /** Promise when loading */\n    private _load: Promise<this>;\n\n    /** Cross origin value to use */\n    private _crossorigin?: boolean | string;\n\n    /**\n     * @param sourceBase64 - Base64 encoded SVG element or URL for SVG file.\n     * @param {object} [options] - Options to use\n     * @param {number} [options.scale=1] - Scale to apply to SVG. Overridden by...\n     * @param {number} [options.width] - Rasterize SVG this wide. Aspect ratio preserved if height not specified.\n     * @param {number} [options.height] - Rasterize SVG this high. Aspect ratio preserved if width not specified.\n     * @param {boolean} [options.autoLoad=true] - Start loading right away.\n     */\n    constructor(sourceBase64: string, options?: ISVGResourceOptions)\n    {\n        options = options || {};\n\n        super(settings.ADAPTER.createCanvas());\n        this._width = 0;\n        this._height = 0;\n\n        this.svg = sourceBase64;\n        this.scale = options.scale || 1;\n        this._overrideWidth = options.width;\n        this._overrideHeight = options.height;\n\n        this._resolve = null;\n        this._crossorigin = options.crossorigin;\n        this._load = null;\n\n        if (options.autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        this._load = new Promise((resolve): void =>\n        {\n            // Save this until after load is finished\n            this._resolve = (): void =>\n            {\n                this.update();\n                resolve(this);\n            };\n\n            // Convert SVG inline string to data-uri\n            if (SVGResource.SVG_XML.test(this.svg.trim()))\n            {\n                if (!btoa)\n                {\n                    throw new Error('Your browser doesn\\'t support base64 conversions.');\n                }\n                (this as any).svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;\n            }\n\n            this._loadSvg();\n        });\n\n        return this._load;\n    }\n\n    /** Loads an SVG image from `imageUrl` or `data URL`. */\n    private _loadSvg(): void\n    {\n        const tempImage = new Image();\n\n        BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);\n        tempImage.src = this.svg;\n\n        tempImage.onerror = (event): void =>\n        {\n            if (!this._resolve)\n            {\n                return;\n            }\n\n            tempImage.onerror = null;\n            this.onError.emit(event);\n        };\n\n        tempImage.onload = (): void =>\n        {\n            if (!this._resolve)\n            {\n                return;\n            }\n\n            const svgWidth = tempImage.width;\n            const svgHeight = tempImage.height;\n\n            if (!svgWidth || !svgHeight)\n            {\n                throw new Error('The SVG image must have width and height defined (in pixels), canvas API needs them.');\n            }\n\n            // Set render size\n            let width = svgWidth * this.scale;\n            let height = svgHeight * this.scale;\n\n            if (this._overrideWidth || this._overrideHeight)\n            {\n                width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth;\n                height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight;\n            }\n            width = Math.round(width);\n            height = Math.round(height);\n\n            // Create a canvas element\n            const canvas = this.source as ICanvas;\n\n            canvas.width = width;\n            canvas.height = height;\n            (canvas as any)._pixiId = `canvas_${uid()}`;\n\n            // Draw the Svg to the canvas\n            canvas\n                .getContext('2d')\n                .drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);\n\n            this._resolve();\n            this._resolve = null;\n        };\n    }\n\n    /**\n     * Get size from an svg string using a regular expression.\n     * @param svgString - a serialized svg element\n     * @returns - image extension\n     */\n    static getSize(svgString?: string): ISize\n    {\n        const sizeMatch = SVGResource.SVG_SIZE.exec(svgString);\n        const size: any = {};\n\n        if (sizeMatch)\n        {\n            size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));\n            size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));\n        }\n\n        return size;\n    }\n\n    /** Destroys this texture. */\n    dispose(): void\n    {\n        super.dispose();\n        this._resolve = null;\n        this._crossorigin = null;\n    }\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @param {string} extension - The extension of source, if set\n     * @returns {boolean} - If the source is a SVG source or data file\n     */\n    static test(source: unknown, extension?: string): boolean\n    {\n        // url file extension is SVG\n        return extension === 'svg'\n            // source is SVG data-uri\n            || (typeof source === 'string' && source.startsWith('data:image/svg+xml'))\n            // source is SVG inline\n            || (typeof source === 'string' && SVGResource.SVG_XML.test(source));\n    }\n\n    /**\n     * Regular expression for SVG XML document.\n     * @example &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!-- image/svg --&gt;&lt;svg\n     * @readonly\n     */\n    static SVG_XML = /^(<\\?xml[^?]+\\?>)?\\s*(<!--[^(-->)]*-->)?\\s*\\<svg/m;\n\n    /**\n     * Regular expression for SVG size.\n     * @example &lt;svg width=\"100\" height=\"100\"&gt;&lt;/svg&gt;\n     * @readonly\n     */\n    static SVG_SIZE = /<svg[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*>/i; // eslint-disable-line max-len\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}