{"ast":null,"code":"import { catchError, combineLatest, map, of, switchMap } from 'rxjs';\nimport { Enum } from '@polkadot/types';\nimport { isFunction, objectSpread, stringToHex } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nimport { getImageHashBounded } from './util.js';\nconst DEMOCRACY_ID = stringToHex('democrac');\nfunction isMaybeHashedOrBounded(call) {\n  // check for enum\n  return call instanceof Enum;\n}\nfunction isBounded(call) {\n  // check for type\n  return call.isInline || call.isLegacy || call.isLookup;\n}\nfunction queryQueue(api) {\n  return api.query.democracy['dispatchQueue']().pipe(switchMap(dispatches => combineLatest([of(dispatches), api.derive.democracy.preimages(dispatches.map(([, hash]) => hash))])), map(([dispatches, images]) => dispatches.map(([at, imageHash, index], dispatchIndex) => ({\n    at,\n    image: images[dispatchIndex],\n    imageHash: getImageHashBounded(imageHash),\n    index\n  }))));\n}\nfunction schedulerEntries(api) {\n  // We don't get entries, but rather we get the keys (triggered via finished referendums) and\n  // the subscribe to those keys - this means we pickup when the schedulers actually executes\n  // at a block, the entry for that block will become empty\n  return api.derive.democracy.referendumsFinished().pipe(switchMap(() => api.query.scheduler.agenda.keys()), switchMap(keys => {\n    const blockNumbers = keys.map(({\n      args: [blockNumber]\n    }) => blockNumber);\n    return blockNumbers.length ? combineLatest([of(blockNumbers),\n    // this should simply be api.query.scheduler.agenda.multi,\n    // however we have had cases on Darwinia where the indices have moved around after an\n    // upgrade, which results in invalid on-chain data\n    api.query.scheduler.agenda.multi(blockNumbers).pipe(catchError(() => of(blockNumbers.map(() => []))))]) : of([[], []]);\n  }));\n}\nfunction queryScheduler(api) {\n  return schedulerEntries(api).pipe(switchMap(([blockNumbers, agendas]) => {\n    const result = [];\n    blockNumbers.forEach((at, index) => {\n      (agendas[index] || []).filter(o => o.isSome).forEach(o => {\n        const scheduled = o.unwrap();\n        if (scheduled.maybeId.isSome) {\n          const id = scheduled.maybeId.unwrap().toHex();\n          if (id.startsWith(DEMOCRACY_ID)) {\n            const imageHash = isMaybeHashedOrBounded(scheduled.call) ? isBounded(scheduled.call) ? getImageHashBounded(scheduled.call) : scheduled.call.isHash ? scheduled.call.asHash.toHex() : scheduled.call.asValue.args[0].toHex() : scheduled.call.args[0].toHex();\n            result.push({\n              at,\n              imageHash,\n              index: api.registry.createType('(u64, ReferendumIndex)', id)[1]\n            });\n          }\n        }\n      });\n    });\n    return combineLatest([of(result), result.length ? api.derive.democracy.preimages(result.map(({\n      imageHash\n    }) => imageHash)) : of([])]);\n  }), map(([infos, images]) => infos.map((info, index) => objectSpread({\n    image: images[index]\n  }, info))));\n}\nexport function dispatchQueue(instanceId, api) {\n  return memo(instanceId, () => isFunction(api.query.scheduler?.agenda) ? queryScheduler(api) : api.query.democracy['dispatchQueue'] ? queryQueue(api) : of([]));\n}","map":{"version":3,"names":["catchError","combineLatest","map","of","switchMap","Enum","isFunction","objectSpread","stringToHex","memo","getImageHashBounded","DEMOCRACY_ID","isMaybeHashedOrBounded","call","isBounded","isInline","isLegacy","isLookup","queryQueue","api","query","democracy","pipe","dispatches","derive","preimages","hash","images","at","imageHash","index","dispatchIndex","image","schedulerEntries","referendumsFinished","scheduler","agenda","keys","blockNumbers","args","blockNumber","length","multi","queryScheduler","agendas","result","forEach","filter","o","isSome","scheduled","unwrap","maybeId","id","toHex","startsWith","isHash","asHash","asValue","push","registry","createType","infos","info","dispatchQueue","instanceId"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api-derive/democracy/dispatchQueue.js"],"sourcesContent":["import { catchError, combineLatest, map, of, switchMap } from 'rxjs';\nimport { Enum } from '@polkadot/types';\nimport { isFunction, objectSpread, stringToHex } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nimport { getImageHashBounded } from './util.js';\nconst DEMOCRACY_ID = stringToHex('democrac');\nfunction isMaybeHashedOrBounded(call) {\n    // check for enum\n    return call instanceof Enum;\n}\nfunction isBounded(call) {\n    // check for type\n    return call.isInline || call.isLegacy || call.isLookup;\n}\nfunction queryQueue(api) {\n    return api.query.democracy['dispatchQueue']().pipe(switchMap((dispatches) => combineLatest([\n        of(dispatches),\n        api.derive.democracy.preimages(dispatches.map(([, hash]) => hash))\n    ])), map(([dispatches, images]) => dispatches.map(([at, imageHash, index], dispatchIndex) => ({\n        at,\n        image: images[dispatchIndex],\n        imageHash: getImageHashBounded(imageHash),\n        index\n    }))));\n}\nfunction schedulerEntries(api) {\n    // We don't get entries, but rather we get the keys (triggered via finished referendums) and\n    // the subscribe to those keys - this means we pickup when the schedulers actually executes\n    // at a block, the entry for that block will become empty\n    return api.derive.democracy.referendumsFinished().pipe(switchMap(() => api.query.scheduler.agenda.keys()), switchMap((keys) => {\n        const blockNumbers = keys.map(({ args: [blockNumber] }) => blockNumber);\n        return blockNumbers.length\n            ? combineLatest([\n                of(blockNumbers),\n                // this should simply be api.query.scheduler.agenda.multi,\n                // however we have had cases on Darwinia where the indices have moved around after an\n                // upgrade, which results in invalid on-chain data\n                api.query.scheduler.agenda.multi(blockNumbers).pipe(catchError(() => of(blockNumbers.map(() => []))))\n            ])\n            : of([[], []]);\n    }));\n}\nfunction queryScheduler(api) {\n    return schedulerEntries(api).pipe(switchMap(([blockNumbers, agendas]) => {\n        const result = [];\n        blockNumbers.forEach((at, index) => {\n            (agendas[index] || []).filter((o) => o.isSome).forEach((o) => {\n                const scheduled = o.unwrap();\n                if (scheduled.maybeId.isSome) {\n                    const id = scheduled.maybeId.unwrap().toHex();\n                    if (id.startsWith(DEMOCRACY_ID)) {\n                        const imageHash = isMaybeHashedOrBounded(scheduled.call)\n                            ? isBounded(scheduled.call)\n                                ? getImageHashBounded(scheduled.call)\n                                : scheduled.call.isHash\n                                    ? scheduled.call.asHash.toHex()\n                                    : scheduled.call.asValue.args[0].toHex()\n                            : scheduled.call.args[0].toHex();\n                        result.push({ at, imageHash, index: api.registry.createType('(u64, ReferendumIndex)', id)[1] });\n                    }\n                }\n            });\n        });\n        return combineLatest([\n            of(result),\n            result.length\n                ? api.derive.democracy.preimages(result.map(({ imageHash }) => imageHash))\n                : of([])\n        ]);\n    }), map(([infos, images]) => infos.map((info, index) => objectSpread({ image: images[index] }, info))));\n}\nexport function dispatchQueue(instanceId, api) {\n    return memo(instanceId, () => isFunction(api.query.scheduler?.agenda)\n        ? queryScheduler(api)\n        : api.query.democracy['dispatchQueue']\n            ? queryQueue(api)\n            : of([]));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}