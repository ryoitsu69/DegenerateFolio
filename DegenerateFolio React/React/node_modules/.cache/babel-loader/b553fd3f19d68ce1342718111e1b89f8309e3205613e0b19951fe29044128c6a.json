{"ast":null,"code":"import { addBits } from './utils/addBits.mjs';\nimport { compileHooks } from './utils/compileHooks.mjs';\nimport { compileInputs } from './utils/compileInputs.mjs';\nimport { compileOutputs } from './utils/compileOutputs.mjs';\nimport { injectBits } from './utils/injectBits.mjs';\n\"use strict\";\nconst cacheMap = /* @__PURE__ */Object.create(null);\nconst bitCacheMap = /* @__PURE__ */new Map();\nlet CACHE_UID = 0;\nfunction compileHighShader({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId]) return cacheMap[cacheId];\n  const {\n    vertex,\n    fragment\n  } = compileInputsAndOutputs(template, bits);\n  cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileHighShaderGl({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId]) return cacheMap[cacheId];\n  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileInputsAndOutputs(template, bits) {\n  const vertexFragments = bits.map(shaderBit => shaderBit.vertex).filter(v => !!v);\n  const fragmentFragments = bits.map(shaderBit => shaderBit.fragment).filter(v => !!v);\n  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n  compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n  return {\n    vertex: compiledVertex,\n    fragment: compiledFragment\n  };\n}\nfunction generateCacheId(template, bits) {\n  return bits.map(highFragment => {\n    if (!bitCacheMap.has(highFragment)) {\n      bitCacheMap.set(highFragment, CACHE_UID++);\n    }\n    return bitCacheMap.get(highFragment);\n  }).sort((a, b) => a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction compileBits(vertex, fragment, bits) {\n  const vertexParts = compileHooks(vertex);\n  const fragmentParts = compileHooks(fragment);\n  bits.forEach(shaderBit => {\n    addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n  });\n  return {\n    vertex: injectBits(vertex, vertexParts),\n    fragment: injectBits(fragment, fragmentParts)\n  };\n}\nexport { compileHighShader, compileHighShaderGl };","map":{"version":3,"names":["cacheMap","Object","create","bitCacheMap","Map","CACHE_UID","compileHighShader","template","bits","cacheId","generateCacheId","vertex","fragment","compileInputsAndOutputs","compileBits","compileHighShaderGl","vertexFragments","map","shaderBit","filter","v","fragmentFragments","compiledVertex","compileInputs","compileOutputs","compiledFragment","highFragment","has","set","get","sort","a","b","join","vertexParts","compileHooks","fragmentParts","forEach","addBits","name","injectBits"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/high-shader/compiler/compileHighShader.ts"],"sourcesContent":["import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/** A high template consists of vertex and fragment source */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}