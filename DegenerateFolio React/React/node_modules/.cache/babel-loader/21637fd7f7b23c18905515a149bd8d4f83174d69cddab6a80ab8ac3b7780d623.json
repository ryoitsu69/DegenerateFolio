{"ast":null,"code":"import _defineProperty from \"/home/ryoitsu/Documents/test/react-todo-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { EventEmitter } from 'eventemitter3';\nimport { isError, isFunction, isObject, logger, noop, objectSpread } from '@polkadot/util';\nimport { RpcCoder } from '../coder/index.js';\nimport { healthChecker } from './Health.js';\nconst l = logger('api-substrate-connect');\nconst subscriptionUnsubscriptionMethods = new Map([['author_submitAndWatchExtrinsic', 'author_unwatchExtrinsic'], ['chain_subscribeAllHeads', 'chain_unsubscribeAllHeads'], ['chain_subscribeFinalizedHeads', 'chain_unsubscribeFinalizedHeads'], ['chain_subscribeFinalisedHeads', 'chain_subscribeFinalisedHeads'], ['chain_subscribeNewHeads', 'chain_unsubscribeNewHeads'], ['chain_subscribeNewHead', 'chain_unsubscribeNewHead'], ['chain_subscribeRuntimeVersion', 'chain_unsubscribeRuntimeVersion'], ['subscribe_newHead', 'unsubscribe_newHead'], ['state_subscribeRuntimeVersion', 'state_unsubscribeRuntimeVersion'], ['state_subscribeStorage', 'state_unsubscribeStorage']]);\nconst scClients = new WeakMap();\nexport class ScProvider {\n  constructor(Sc, spec, sharedSandbox) {\n    _defineProperty(this, \"__internal__Sc\", void 0);\n    _defineProperty(this, \"__internal__coder\", new RpcCoder());\n    _defineProperty(this, \"__internal__spec\", void 0);\n    _defineProperty(this, \"__internal__sharedSandbox\", void 0);\n    _defineProperty(this, \"__internal__subscriptions\", new Map());\n    _defineProperty(this, \"__internal__resubscribeMethods\", new Map());\n    _defineProperty(this, \"__internal__requests\", new Map());\n    _defineProperty(this, \"__internal__wellKnownChains\", void 0);\n    _defineProperty(this, \"__internal__eventemitter\", new EventEmitter());\n    _defineProperty(this, \"__internal__chain\", null);\n    _defineProperty(this, \"__internal__isChainReady\", false);\n    _defineProperty(this, \"__internal__resubscribe\", () => {\n      const promises = [];\n      this.__internal__resubscribeMethods.forEach(subDetails => {\n        // only re-create subscriptions which are not in author (only area where\n        // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n        // are not included (and will not be re-broadcast)\n        if (subDetails.type.startsWith('author_')) {\n          return;\n        }\n        try {\n          const promise = new Promise(resolve => {\n            this.subscribe(subDetails.type, subDetails.method, subDetails.params, subDetails.callback).catch(error => console.log(error));\n            resolve();\n          });\n          promises.push(promise);\n        } catch (error) {\n          l.error(error);\n        }\n      });\n      Promise.all(promises).catch(err => l.log(err));\n    });\n    if (!isObject(Sc) || !isObject(Sc.WellKnownChain) || !isFunction(Sc.createScClient)) {\n      throw new Error('Expected an @substrate/connect interface as first parameter to ScProvider');\n    }\n    this.__internal__Sc = Sc;\n    this.__internal__spec = spec;\n    this.__internal__sharedSandbox = sharedSandbox;\n    this.__internal__wellKnownChains = new Set(Object.values(Sc.WellKnownChain));\n  }\n  get hasSubscriptions() {\n    // Indicates that subscriptions are supported\n    return !!true;\n  }\n  get isClonable() {\n    return !!false;\n  }\n  get isConnected() {\n    return !!this.__internal__chain && this.__internal__isChainReady;\n  }\n  clone() {\n    throw new Error('clone() is not supported.');\n  }\n  // Config details can be found in @substrate/connect repo following the link:\n  // https://github.com/paritytech/substrate-connect/blob/main/packages/connect/src/connector/index.ts\n  async connect(config) {\n    var _this = this;\n    let checkerFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : healthChecker;\n    if (this.isConnected) {\n      throw new Error('Already connected!');\n    }\n    // it could happen that after emitting `disconnected` due to the fact that\n    // smoldot is syncing, the consumer tries to reconnect after a certain amount\n    // of time... In which case we want to make sure that we don't create a new\n    // chain.\n    if (this.__internal__chain) {\n      await this.__internal__chain;\n      return;\n    }\n    if (this.__internal__sharedSandbox && !this.__internal__sharedSandbox.isConnected) {\n      await this.__internal__sharedSandbox.connect();\n    }\n    const client = this.__internal__sharedSandbox ? scClients.get(this.__internal__sharedSandbox) : this.__internal__Sc.createScClient(config);\n    if (!client) {\n      throw new Error('Unknown ScProvider!');\n    }\n    scClients.set(this, client);\n    const hc = checkerFactory();\n    const onResponse = res => {\n      var _response$params, _this$__internal__sub;\n      const hcRes = hc.responsePassThrough(res);\n      if (!hcRes) {\n        return;\n      }\n      const response = JSON.parse(hcRes);\n      let decodedResponse;\n      try {\n        decodedResponse = this.__internal__coder.decodeResponse(response);\n      } catch (e) {\n        decodedResponse = e;\n      }\n      // It's not a subscription message, but rather a standar RPC response\n      if (((_response$params = response.params) === null || _response$params === void 0 ? void 0 : _response$params.subscription) === undefined || !response.method) {\n        var _this$__internal__req;\n        return (_this$__internal__req = this.__internal__requests.get(response.id)) === null || _this$__internal__req === void 0 ? void 0 : _this$__internal__req(decodedResponse);\n      }\n      // We are dealing with a subscription message\n      const subscriptionId = \"\".concat(response.method, \"::\").concat(response.params.subscription);\n      const callback = (_this$__internal__sub = this.__internal__subscriptions.get(subscriptionId)) === null || _this$__internal__sub === void 0 ? void 0 : _this$__internal__sub[0];\n      callback === null || callback === void 0 || callback(decodedResponse);\n    };\n    const addChain = this.__internal__sharedSandbox ? async function () {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const source = _this.__internal__sharedSandbox;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return (await source.__internal__chain).addChain(...arguments);\n    } : this.__internal__wellKnownChains.has(this.__internal__spec) ? client.addWellKnownChain : client.addChain;\n    this.__internal__chain = addChain(this.__internal__spec, onResponse).then(chain => {\n      hc.setSendJsonRpc(chain.sendJsonRpc);\n      this.__internal__isChainReady = false;\n      const cleanup = () => {\n        // If there are any callbacks left, we have to reject/error them.\n        // Otherwise, that would cause a memory leak.\n        const disconnectionError = new Error('Disconnected');\n        this.__internal__requests.forEach(cb => cb(disconnectionError));\n        this.__internal__subscriptions.forEach(_ref => {\n          let [cb] = _ref;\n          return cb(disconnectionError);\n        });\n        this.__internal__subscriptions.clear();\n      };\n      const staleSubscriptions = [];\n      const killStaleSubscriptions = () => {\n        if (staleSubscriptions.length === 0) {\n          return;\n        }\n        const stale = staleSubscriptions.pop();\n        if (!stale) {\n          throw new Error('Unable to get stale subscription');\n        }\n        const {\n          id,\n          unsubscribeMethod\n        } = stale;\n        Promise.race([this.send(unsubscribeMethod, [id]).catch(noop), new Promise(resolve => setTimeout(resolve, 500))]).then(killStaleSubscriptions).catch(noop);\n      };\n      hc.start(health => {\n        const isReady = !health.isSyncing && (health.peers > 0 || !health.shouldHavePeers);\n        // if it's the same as before, then nothing has changed and we are done\n        if (this.__internal__isChainReady === isReady) {\n          return;\n        }\n        this.__internal__isChainReady = isReady;\n        if (!isReady) {\n          // If we've reached this point, that means that the chain used to be \"ready\"\n          // and now we are about to emit `disconnected`.\n          //\n          // This will cause the PolkadotJs API think that the connection is\n          // actually dead. In reality the smoldot chain is not dead, of course.\n          // However, we have to cleanup all the existing callbacks because when\n          // the smoldot chain stops syncing, then we will emit `connected` and\n          // the PolkadotJs API will try to re-create the previous\n          // subscriptions and requests. Although, now is not a good moment\n          // to be sending unsubscription messages to the smoldot chain, we\n          // should wait until is no longer syncing to send the unsubscription\n          // messages from the stale subscriptions of the previous connection.\n          //\n          // That's why -before we perform the cleanup of `this.__internal__subscriptions`-\n          // we keep the necessary information that we will need later on to\n          // kill the stale subscriptions.\n          [...this.__internal__subscriptions.values()].forEach(s => {\n            staleSubscriptions.push(s[1]);\n          });\n          cleanup();\n          this.__internal__eventemitter.emit('disconnected');\n        } else {\n          killStaleSubscriptions();\n          this.__internal__eventemitter.emit('connected');\n          if (this.__internal__resubscribeMethods.size) {\n            this.__internal__resubscribe();\n          }\n        }\n      });\n      return objectSpread({}, chain, {\n        remove: () => {\n          hc.stop();\n          chain.remove();\n          cleanup();\n        },\n        sendJsonRpc: hc.sendJsonRpc.bind(hc)\n      });\n    });\n    try {\n      await this.__internal__chain;\n    } catch (e) {\n      this.__internal__chain = null;\n      this.__internal__eventemitter.emit('error', e);\n      throw e;\n    }\n  }\n  async disconnect() {\n    if (!this.__internal__chain) {\n      return;\n    }\n    const chain = await this.__internal__chain;\n    this.__internal__chain = null;\n    this.__internal__isChainReady = false;\n    try {\n      chain.remove();\n    } catch (_) {}\n    this.__internal__eventemitter.emit('disconnected');\n  }\n  on(type, sub) {\n    // It's possible. Although, quite unlikely, that by the time that polkadot\n    // subscribes to the `connected` event, the Provider is already connected.\n    // In that case, we must emit to let the consumer know that we are connected.\n    if (type === 'connected' && this.isConnected) {\n      sub();\n    }\n    this.__internal__eventemitter.on(type, sub);\n    return () => {\n      this.__internal__eventemitter.removeListener(type, sub);\n    };\n  }\n  async send(method, params) {\n    if (!this.isConnected || !this.__internal__chain) {\n      throw new Error('Provider is not connected');\n    }\n    const chain = await this.__internal__chain;\n    const [id, json] = this.__internal__coder.encodeJson(method, params);\n    const result = new Promise((resolve, reject) => {\n      this.__internal__requests.set(id, response => {\n        (isError(response) ? reject : resolve)(response);\n      });\n      try {\n        chain.sendJsonRpc(json);\n      } catch (e) {\n        this.__internal__chain = null;\n        try {\n          chain.remove();\n        } catch (_) {}\n        this.__internal__eventemitter.emit('error', e);\n      }\n    });\n    try {\n      return await result;\n    } finally {\n      // let's ensure that once the Promise is resolved/rejected, then we remove\n      // remove its entry from the internal #requests\n      this.__internal__requests.delete(id);\n    }\n  }\n  async subscribe(type, method, params, callback) {\n    if (!subscriptionUnsubscriptionMethods.has(method)) {\n      throw new Error(\"Unsupported subscribe method: \".concat(method));\n    }\n    const id = await this.send(method, params);\n    const subscriptionId = \"\".concat(type, \"::\").concat(id);\n    const cb = response => {\n      if (response instanceof Error) {\n        callback(response, undefined);\n      } else {\n        callback(null, response);\n      }\n    };\n    const unsubscribeMethod = subscriptionUnsubscriptionMethods.get(method);\n    if (!unsubscribeMethod) {\n      throw new Error('Invalid unsubscribe method found');\n    }\n    this.__internal__resubscribeMethods.set(subscriptionId, {\n      callback,\n      method,\n      params,\n      type\n    });\n    this.__internal__subscriptions.set(subscriptionId, [cb, {\n      id,\n      unsubscribeMethod\n    }]);\n    return id;\n  }\n  unsubscribe(type, method, id) {\n    if (!this.isConnected) {\n      throw new Error('Provider is not connected');\n    }\n    const subscriptionId = \"\".concat(type, \"::\").concat(id);\n    if (!this.__internal__subscriptions.has(subscriptionId)) {\n      return Promise.reject(new Error(\"Unable to find active subscription=\".concat(subscriptionId)));\n    }\n    this.__internal__resubscribeMethods.delete(subscriptionId);\n    this.__internal__subscriptions.delete(subscriptionId);\n    return this.send(method, [id]);\n  }\n}","map":{"version":3,"names":["EventEmitter","isError","isFunction","isObject","logger","noop","objectSpread","RpcCoder","healthChecker","l","subscriptionUnsubscriptionMethods","Map","scClients","WeakMap","ScProvider","constructor","Sc","spec","sharedSandbox","_defineProperty","promises","__internal__resubscribeMethods","forEach","subDetails","type","startsWith","promise","Promise","resolve","subscribe","method","params","callback","catch","error","console","log","push","all","err","WellKnownChain","createScClient","Error","__internal__Sc","__internal__spec","__internal__sharedSandbox","__internal__wellKnownChains","Set","Object","values","hasSubscriptions","isClonable","isConnected","__internal__chain","__internal__isChainReady","clone","connect","config","_this","checkerFactory","arguments","length","undefined","client","get","set","hc","onResponse","res","_response$params","_this$__internal__sub","hcRes","responsePassThrough","response","JSON","parse","decodedResponse","__internal__coder","decodeResponse","e","subscription","_this$__internal__req","__internal__requests","id","subscriptionId","concat","__internal__subscriptions","addChain","source","has","addWellKnownChain","then","chain","setSendJsonRpc","sendJsonRpc","cleanup","disconnectionError","cb","_ref","clear","staleSubscriptions","killStaleSubscriptions","stale","pop","unsubscribeMethod","race","send","setTimeout","start","health","isReady","isSyncing","peers","shouldHavePeers","s","__internal__eventemitter","emit","size","__internal__resubscribe","remove","stop","bind","disconnect","_","on","sub","removeListener","json","encodeJson","result","reject","delete","unsubscribe"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/rpc-provider/substrate-connect/index.js"],"sourcesContent":["import { EventEmitter } from 'eventemitter3';\nimport { isError, isFunction, isObject, logger, noop, objectSpread } from '@polkadot/util';\nimport { RpcCoder } from '../coder/index.js';\nimport { healthChecker } from './Health.js';\nconst l = logger('api-substrate-connect');\nconst subscriptionUnsubscriptionMethods = new Map([\n    ['author_submitAndWatchExtrinsic', 'author_unwatchExtrinsic'],\n    ['chain_subscribeAllHeads', 'chain_unsubscribeAllHeads'],\n    ['chain_subscribeFinalizedHeads', 'chain_unsubscribeFinalizedHeads'],\n    ['chain_subscribeFinalisedHeads', 'chain_subscribeFinalisedHeads'],\n    ['chain_subscribeNewHeads', 'chain_unsubscribeNewHeads'],\n    ['chain_subscribeNewHead', 'chain_unsubscribeNewHead'],\n    ['chain_subscribeRuntimeVersion', 'chain_unsubscribeRuntimeVersion'],\n    ['subscribe_newHead', 'unsubscribe_newHead'],\n    ['state_subscribeRuntimeVersion', 'state_unsubscribeRuntimeVersion'],\n    ['state_subscribeStorage', 'state_unsubscribeStorage']\n]);\nconst scClients = new WeakMap();\nexport class ScProvider {\n    __internal__Sc;\n    __internal__coder = new RpcCoder();\n    __internal__spec;\n    __internal__sharedSandbox;\n    __internal__subscriptions = new Map();\n    __internal__resubscribeMethods = new Map();\n    __internal__requests = new Map();\n    __internal__wellKnownChains;\n    __internal__eventemitter = new EventEmitter();\n    __internal__chain = null;\n    __internal__isChainReady = false;\n    constructor(Sc, spec, sharedSandbox) {\n        if (!isObject(Sc) || !isObject(Sc.WellKnownChain) || !isFunction(Sc.createScClient)) {\n            throw new Error('Expected an @substrate/connect interface as first parameter to ScProvider');\n        }\n        this.__internal__Sc = Sc;\n        this.__internal__spec = spec;\n        this.__internal__sharedSandbox = sharedSandbox;\n        this.__internal__wellKnownChains = new Set(Object.values(Sc.WellKnownChain));\n    }\n    get hasSubscriptions() {\n        // Indicates that subscriptions are supported\n        return !!true;\n    }\n    get isClonable() {\n        return !!false;\n    }\n    get isConnected() {\n        return !!this.__internal__chain && this.__internal__isChainReady;\n    }\n    clone() {\n        throw new Error('clone() is not supported.');\n    }\n    // Config details can be found in @substrate/connect repo following the link:\n    // https://github.com/paritytech/substrate-connect/blob/main/packages/connect/src/connector/index.ts\n    async connect(config, checkerFactory = healthChecker) {\n        if (this.isConnected) {\n            throw new Error('Already connected!');\n        }\n        // it could happen that after emitting `disconnected` due to the fact that\n        // smoldot is syncing, the consumer tries to reconnect after a certain amount\n        // of time... In which case we want to make sure that we don't create a new\n        // chain.\n        if (this.__internal__chain) {\n            await this.__internal__chain;\n            return;\n        }\n        if (this.__internal__sharedSandbox && !this.__internal__sharedSandbox.isConnected) {\n            await this.__internal__sharedSandbox.connect();\n        }\n        const client = this.__internal__sharedSandbox\n            ? scClients.get(this.__internal__sharedSandbox)\n            : this.__internal__Sc.createScClient(config);\n        if (!client) {\n            throw new Error('Unknown ScProvider!');\n        }\n        scClients.set(this, client);\n        const hc = checkerFactory();\n        const onResponse = (res) => {\n            const hcRes = hc.responsePassThrough(res);\n            if (!hcRes) {\n                return;\n            }\n            const response = JSON.parse(hcRes);\n            let decodedResponse;\n            try {\n                decodedResponse = this.__internal__coder.decodeResponse(response);\n            }\n            catch (e) {\n                decodedResponse = e;\n            }\n            // It's not a subscription message, but rather a standar RPC response\n            if (response.params?.subscription === undefined || !response.method) {\n                return this.__internal__requests.get(response.id)?.(decodedResponse);\n            }\n            // We are dealing with a subscription message\n            const subscriptionId = `${response.method}::${response.params.subscription}`;\n            const callback = this.__internal__subscriptions.get(subscriptionId)?.[0];\n            callback?.(decodedResponse);\n        };\n        const addChain = this.__internal__sharedSandbox\n            ? (async (...args) => {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const source = this.__internal__sharedSandbox;\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                return (await source.__internal__chain).addChain(...args);\n            })\n            : this.__internal__wellKnownChains.has(this.__internal__spec)\n                ? client.addWellKnownChain\n                : client.addChain;\n        this.__internal__chain = addChain(this.__internal__spec, onResponse).then((chain) => {\n            hc.setSendJsonRpc(chain.sendJsonRpc);\n            this.__internal__isChainReady = false;\n            const cleanup = () => {\n                // If there are any callbacks left, we have to reject/error them.\n                // Otherwise, that would cause a memory leak.\n                const disconnectionError = new Error('Disconnected');\n                this.__internal__requests.forEach((cb) => cb(disconnectionError));\n                this.__internal__subscriptions.forEach(([cb]) => cb(disconnectionError));\n                this.__internal__subscriptions.clear();\n            };\n            const staleSubscriptions = [];\n            const killStaleSubscriptions = () => {\n                if (staleSubscriptions.length === 0) {\n                    return;\n                }\n                const stale = staleSubscriptions.pop();\n                if (!stale) {\n                    throw new Error('Unable to get stale subscription');\n                }\n                const { id, unsubscribeMethod } = stale;\n                Promise\n                    .race([\n                    this.send(unsubscribeMethod, [id]).catch(noop),\n                    new Promise((resolve) => setTimeout(resolve, 500))\n                ])\n                    .then(killStaleSubscriptions)\n                    .catch(noop);\n            };\n            hc.start((health) => {\n                const isReady = !health.isSyncing && (health.peers > 0 || !health.shouldHavePeers);\n                // if it's the same as before, then nothing has changed and we are done\n                if (this.__internal__isChainReady === isReady) {\n                    return;\n                }\n                this.__internal__isChainReady = isReady;\n                if (!isReady) {\n                    // If we've reached this point, that means that the chain used to be \"ready\"\n                    // and now we are about to emit `disconnected`.\n                    //\n                    // This will cause the PolkadotJs API think that the connection is\n                    // actually dead. In reality the smoldot chain is not dead, of course.\n                    // However, we have to cleanup all the existing callbacks because when\n                    // the smoldot chain stops syncing, then we will emit `connected` and\n                    // the PolkadotJs API will try to re-create the previous\n                    // subscriptions and requests. Although, now is not a good moment\n                    // to be sending unsubscription messages to the smoldot chain, we\n                    // should wait until is no longer syncing to send the unsubscription\n                    // messages from the stale subscriptions of the previous connection.\n                    //\n                    // That's why -before we perform the cleanup of `this.__internal__subscriptions`-\n                    // we keep the necessary information that we will need later on to\n                    // kill the stale subscriptions.\n                    [...this.__internal__subscriptions.values()].forEach((s) => {\n                        staleSubscriptions.push(s[1]);\n                    });\n                    cleanup();\n                    this.__internal__eventemitter.emit('disconnected');\n                }\n                else {\n                    killStaleSubscriptions();\n                    this.__internal__eventemitter.emit('connected');\n                    if (this.__internal__resubscribeMethods.size) {\n                        this.__internal__resubscribe();\n                    }\n                }\n            });\n            return objectSpread({}, chain, {\n                remove: () => {\n                    hc.stop();\n                    chain.remove();\n                    cleanup();\n                },\n                sendJsonRpc: hc.sendJsonRpc.bind(hc)\n            });\n        });\n        try {\n            await this.__internal__chain;\n        }\n        catch (e) {\n            this.__internal__chain = null;\n            this.__internal__eventemitter.emit('error', e);\n            throw e;\n        }\n    }\n    __internal__resubscribe = () => {\n        const promises = [];\n        this.__internal__resubscribeMethods.forEach((subDetails) => {\n            // only re-create subscriptions which are not in author (only area where\n            // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n            // are not included (and will not be re-broadcast)\n            if (subDetails.type.startsWith('author_')) {\n                return;\n            }\n            try {\n                const promise = new Promise((resolve) => {\n                    this.subscribe(subDetails.type, subDetails.method, subDetails.params, subDetails.callback).catch((error) => console.log(error));\n                    resolve();\n                });\n                promises.push(promise);\n            }\n            catch (error) {\n                l.error(error);\n            }\n        });\n        Promise.all(promises).catch((err) => l.log(err));\n    };\n    async disconnect() {\n        if (!this.__internal__chain) {\n            return;\n        }\n        const chain = await this.__internal__chain;\n        this.__internal__chain = null;\n        this.__internal__isChainReady = false;\n        try {\n            chain.remove();\n        }\n        catch (_) { }\n        this.__internal__eventemitter.emit('disconnected');\n    }\n    on(type, sub) {\n        // It's possible. Although, quite unlikely, that by the time that polkadot\n        // subscribes to the `connected` event, the Provider is already connected.\n        // In that case, we must emit to let the consumer know that we are connected.\n        if (type === 'connected' && this.isConnected) {\n            sub();\n        }\n        this.__internal__eventemitter.on(type, sub);\n        return () => {\n            this.__internal__eventemitter.removeListener(type, sub);\n        };\n    }\n    async send(method, params) {\n        if (!this.isConnected || !this.__internal__chain) {\n            throw new Error('Provider is not connected');\n        }\n        const chain = await this.__internal__chain;\n        const [id, json] = this.__internal__coder.encodeJson(method, params);\n        const result = new Promise((resolve, reject) => {\n            this.__internal__requests.set(id, (response) => {\n                (isError(response) ? reject : resolve)(response);\n            });\n            try {\n                chain.sendJsonRpc(json);\n            }\n            catch (e) {\n                this.__internal__chain = null;\n                try {\n                    chain.remove();\n                }\n                catch (_) { }\n                this.__internal__eventemitter.emit('error', e);\n            }\n        });\n        try {\n            return await result;\n        }\n        finally {\n            // let's ensure that once the Promise is resolved/rejected, then we remove\n            // remove its entry from the internal #requests\n            this.__internal__requests.delete(id);\n        }\n    }\n    async subscribe(type, method, params, callback) {\n        if (!subscriptionUnsubscriptionMethods.has(method)) {\n            throw new Error(`Unsupported subscribe method: ${method}`);\n        }\n        const id = await this.send(method, params);\n        const subscriptionId = `${type}::${id}`;\n        const cb = (response) => {\n            if (response instanceof Error) {\n                callback(response, undefined);\n            }\n            else {\n                callback(null, response);\n            }\n        };\n        const unsubscribeMethod = subscriptionUnsubscriptionMethods.get(method);\n        if (!unsubscribeMethod) {\n            throw new Error('Invalid unsubscribe method found');\n        }\n        this.__internal__resubscribeMethods.set(subscriptionId, { callback, method, params, type });\n        this.__internal__subscriptions.set(subscriptionId, [cb, { id, unsubscribeMethod }]);\n        return id;\n    }\n    unsubscribe(type, method, id) {\n        if (!this.isConnected) {\n            throw new Error('Provider is not connected');\n        }\n        const subscriptionId = `${type}::${id}`;\n        if (!this.__internal__subscriptions.has(subscriptionId)) {\n            return Promise.reject(new Error(`Unable to find active subscription=${subscriptionId}`));\n        }\n        this.__internal__resubscribeMethods.delete(subscriptionId);\n        this.__internal__subscriptions.delete(subscriptionId);\n        return this.send(method, [id]);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}