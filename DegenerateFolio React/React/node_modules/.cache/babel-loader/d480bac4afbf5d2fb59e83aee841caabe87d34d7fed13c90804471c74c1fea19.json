{"ast":null,"code":"import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\"use strict\";\nconst findMixin = {\n  /**\n   * The instance label of the object.\n   * @memberof scene.Container#\n   * @member {string} label\n   */\n  label: null,\n  /**\n   * The instance name of the object.\n   * @deprecated since 8.0.0\n   * @see scene.Container#label\n   * @member {string} name\n   * @memberof scene.Container#\n   */\n  get name() {\n    deprecation(v8_0_0, \"Container.name property has been removed, use Container.label instead\");\n    return this.label;\n  },\n  set name(value) {\n    deprecation(v8_0_0, \"Container.name property has been removed, use Container.label instead\");\n    this.label = value;\n  },\n  /**\n   * @method getChildByName\n   * @deprecated since 8.0.0\n   * @param {string} name - Instance name.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified name.\n   * @see scene.Container#getChildByLabel\n   * @memberof scene.Container#\n   */\n  getChildByName(name, deep = false) {\n    return this.getChildByLabel(name, deep);\n  },\n  /**\n   * Returns the first child in the container with the specified label.\n   *\n   * Recursive searches are done in a pre-order traversal.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified label.\n   */\n  getChildByLabel(label, deep = false) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label)) return child;\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        const found = child.getChildByLabel(label, true);\n        if (found) {\n          return found;\n        }\n      }\n    }\n    return null;\n  },\n  /**\n   * Returns all children in the container with the specified label.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @param {Container[]} [out=[]] - The array to store matching children in.\n   * @returns {Container[]} An array of children with the specified label.\n   */\n  getChildrenByLabel(label, deep = false, out = []) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label)) {\n        out.push(child);\n      }\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        children[i].getChildrenByLabel(label, true, out);\n      }\n    }\n    return out;\n  }\n};\nexport { findMixin };","map":{"version":3,"names":["findMixin","label","name","deprecation","v8_0_0","value","getChildByName","deep","getChildByLabel","children","i","length","child","RegExp","test","found","getChildrenByLabel","out","push"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/container/container-mixins/findMixin.ts"],"sourcesContent":["import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Container } from '../Container';\n\nexport interface FindMixinConstructor\n{\n    label?: string;\n}\nexport interface FindMixin extends Required<FindMixinConstructor>\n{\n    /**\n     * @deprecated since 8.0.0\n     * @see Container#label\n     */\n    name: string;\n    getChildByName(label: RegExp | string, deep?: boolean): Container | null;\n    getChildByLabel(label: RegExp | string, deep?: boolean): Container | null;\n    getChildrenByLabel(label: RegExp | string, deep?: boolean, out?: Container[]): Container[];\n}\n\nexport const findMixin: Partial<Container> = {\n    /**\n     * The instance label of the object.\n     * @memberof scene.Container#\n     * @member {string} label\n     */\n    label: null,\n\n    /**\n     * The instance name of the object.\n     * @deprecated since 8.0.0\n     * @see scene.Container#label\n     * @member {string} name\n     * @memberof scene.Container#\n     */\n    get name(): string\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Container.name property has been removed, use Container.label instead');\n        // #endif\n\n        return this.label;\n    },\n    set name(value: string)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Container.name property has been removed, use Container.label instead');\n        // #endif\n\n        this.label = value;\n    },\n\n    /**\n     * @method getChildByName\n     * @deprecated since 8.0.0\n     * @param {string} name - Instance name.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @returns {Container} The child with the specified name.\n     * @see scene.Container#getChildByLabel\n     * @memberof scene.Container#\n     */\n    getChildByName(name: string, deep = false): Container | null\n    {\n        return this.getChildByLabel(name, deep);\n    },\n    /**\n     * Returns the first child in the container with the specified label.\n     *\n     * Recursive searches are done in a pre-order traversal.\n     * @memberof scene.Container#\n     * @param {string|RegExp} label - Instance label.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @returns {Container} The child with the specified label.\n     */\n    getChildByLabel(label: string | RegExp, deep = false): Container | null\n    {\n        const children = this.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.label === label || (label instanceof RegExp && label.test(child.label))) return child;\n        }\n\n        if (deep)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                const child = children[i];\n                const found = child.getChildByLabel(label, true);\n\n                if (found)\n                {\n                    return found;\n                }\n            }\n        }\n\n        return null;\n    },\n\n    /**\n     * Returns all children in the container with the specified label.\n     * @memberof scene.Container#\n     * @param {string|RegExp} label - Instance label.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @param {Container[]} [out=[]] - The array to store matching children in.\n     * @returns {Container[]} An array of children with the specified label.\n     */\n    getChildrenByLabel(label: string | RegExp, deep = false, out = []): Container[]\n    {\n        const children = this.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.label === label || (label instanceof RegExp && label.test(child.label)))\n            {\n                out.push(child);\n            }\n        }\n\n        if (deep)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                children[i].getChildrenByLabel(label, true, out);\n            }\n        }\n\n        return out;\n    },\n} as Container;\n"],"mappings":";;AAoBO,MAAMA,SAAgC;EAAA;AAAA;AAAA;AAAA;AAAA;EAMzCC,KAAO;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASP,IAAIC,IACJA,CAAA;IAEIC,WAAA,CAAYC,MAAA,EAAQ,uEAAuE;IAG3F,OAAO,IAAK,CAAAH,KAAA;EAAA,CAChB;EACA,IAAIC,KAAKG,KACT;IAEIF,WAAA,CAAYC,MAAA,EAAQ,uEAAuE;IAG3F,KAAKH,KAAQ,GAAAI,KAAA;EAAA,CACjB;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAWAC,eAAeJ,IAAc,EAAAK,IAAA,GAAO,KACpC;IACW,YAAKC,eAAgB,CAAAN,IAAA,EAAMK,IAAI;EAAA,CAC1C;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAUAC,gBAAgBP,KAAwB,EAAAM,IAAA,GAAO,KAC/C;IACI,MAAME,QAAA,GAAW,IAAK,CAAAA,QAAA;IAEtB,SAASC,CAAI,MAAGA,CAAI,GAAAD,QAAA,CAASE,MAAA,EAAQD,CACrC;MACU,MAAAE,KAAA,GAAQH,QAAA,CAASC,CAAC;MAEpB,IAAAE,KAAA,CAAMX,KAAA,KAAUA,KAAU,IAAAA,KAAA,YAAiBY,MAAA,IAAUZ,KAAM,CAAAa,IAAA,CAAKF,KAAA,CAAMX,KAAK,GAAW,OAAAW,KAAA;IAAA;IAG9F,IAAIL,IACJ;MACI,SAASG,CAAI,MAAGA,CAAI,GAAAD,QAAA,CAASE,MAAA,EAAQD,CACrC;QACU,MAAAE,KAAA,GAAQH,QAAA,CAASC,CAAC;QACxB,MAAMK,KAAQ,GAAAH,KAAA,CAAMJ,eAAgB,CAAAP,KAAA,EAAO,IAAI;QAE/C,IAAIc,KACJ;UACW,OAAAA,KAAA;QAAA;MACX;IACJ;IAGG;EAAA,CACX;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAUAC,mBAAmBf,KAAwB,EAAAM,IAAA,GAAO,KAAO,EAAAU,GAAA,GAAM,EAC/D;IACI,MAAMR,QAAA,GAAW,IAAK,CAAAA,QAAA;IAEtB,SAASC,CAAI,MAAGA,CAAI,GAAAD,QAAA,CAASE,MAAA,EAAQD,CACrC;MACU,MAAAE,KAAA,GAAQH,QAAA,CAASC,CAAC;MAEpB,IAAAE,KAAA,CAAMX,KAAA,KAAUA,KAAU,IAAAA,KAAA,YAAiBY,MAAA,IAAUZ,KAAM,CAAAa,IAAA,CAAKF,KAAM,CAAAX,KAAK,CAC/E;QACIgB,GAAA,CAAIC,IAAA,CAAKN,KAAK;MAAA;IAClB;IAGJ,IAAIL,IACJ;MACI,SAASG,CAAI,MAAGA,CAAI,GAAAD,QAAA,CAASE,MAAA,EAAQD,CACrC;QACID,QAAA,CAASC,CAAC,EAAEM,kBAAmB,CAAAf,KAAA,EAAO,MAAMgB,GAAG;MAAA;IACnD;IAGG,OAAAA,GAAA;EAAA;AAEf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}