{"ast":null,"code":"import { Color } from '../../../../color/Color.mjs';\nimport { GraphicsPath } from '../path/GraphicsPath.mjs';\n\"use strict\";\nfunction SVGParser(svg, graphicsContext) {\n  if (typeof svg === \"string\") {\n    const div = document.createElement(\"div\");\n    div.innerHTML = svg.trim();\n    svg = div.querySelector(\"svg\");\n  }\n  const session = {\n    context: graphicsContext,\n    path: new GraphicsPath()\n  };\n  renderChildren(svg, session, null, null);\n  return graphicsContext;\n}\nfunction renderChildren(svg, session, fillStyle, strokeStyle) {\n  const children = svg.children;\n  const {\n    fillStyle: f1,\n    strokeStyle: s1\n  } = parseStyle(svg);\n  if (f1 && fillStyle) {\n    fillStyle = {\n      ...fillStyle,\n      ...f1\n    };\n  } else if (f1) {\n    fillStyle = f1;\n  }\n  if (s1 && strokeStyle) {\n    strokeStyle = {\n      ...strokeStyle,\n      ...s1\n    };\n  } else if (s1) {\n    strokeStyle = s1;\n  }\n  session.context.fillStyle = fillStyle;\n  session.context.strokeStyle = strokeStyle;\n  let x;\n  let y;\n  let x1;\n  let y1;\n  let x2;\n  let y2;\n  let cx;\n  let cy;\n  let r;\n  let rx;\n  let ry;\n  let points;\n  let pointsString;\n  let d;\n  let graphicsPath;\n  let width;\n  let height;\n  switch (svg.nodeName.toLowerCase()) {\n    case \"path\":\n      d = svg.getAttribute(\"d\");\n      graphicsPath = new GraphicsPath(d);\n      session.context.path(graphicsPath);\n      if (fillStyle) session.context.fill();\n      if (strokeStyle) session.context.stroke();\n      break;\n    case \"circle\":\n      cx = parseFloatAttribute(svg, \"cx\", 0);\n      cy = parseFloatAttribute(svg, \"cy\", 0);\n      r = parseFloatAttribute(svg, \"r\", 0);\n      session.context.ellipse(cx, cy, r, r);\n      if (fillStyle) session.context.fill();\n      if (strokeStyle) session.context.stroke();\n      break;\n    case \"rect\":\n      x = parseFloatAttribute(svg, \"x\", 0);\n      y = parseFloatAttribute(svg, \"y\", 0);\n      width = parseFloatAttribute(svg, \"width\", 0);\n      height = parseFloatAttribute(svg, \"height\", 0);\n      rx = parseFloatAttribute(svg, \"rx\", 0);\n      ry = parseFloatAttribute(svg, \"ry\", 0);\n      if (rx || ry) {\n        session.context.roundRect(x, y, width, height, rx || ry);\n      } else {\n        session.context.rect(x, y, width, height);\n      }\n      if (fillStyle) session.context.fill();\n      if (strokeStyle) session.context.stroke();\n      break;\n    case \"ellipse\":\n      cx = parseFloatAttribute(svg, \"cx\", 0);\n      cy = parseFloatAttribute(svg, \"cy\", 0);\n      rx = parseFloatAttribute(svg, \"rx\", 0);\n      ry = parseFloatAttribute(svg, \"ry\", 0);\n      session.context.beginPath();\n      session.context.ellipse(cx, cy, rx, ry);\n      if (fillStyle) session.context.fill();\n      if (strokeStyle) session.context.stroke();\n      break;\n    case \"line\":\n      x1 = parseFloatAttribute(svg, \"x1\", 0);\n      y1 = parseFloatAttribute(svg, \"y1\", 0);\n      x2 = parseFloatAttribute(svg, \"x2\", 0);\n      y2 = parseFloatAttribute(svg, \"y2\", 0);\n      session.context.beginPath();\n      session.context.moveTo(x1, y1);\n      session.context.lineTo(x2, y2);\n      if (strokeStyle) session.context.stroke();\n      break;\n    case \"polygon\":\n      pointsString = svg.getAttribute(\"points\");\n      points = pointsString.match(/\\d+/g).map(n => parseInt(n, 10));\n      session.context.poly(points, true);\n      if (fillStyle) session.context.fill();\n      if (strokeStyle) session.context.stroke();\n      break;\n    case \"polyline\":\n      pointsString = svg.getAttribute(\"points\");\n      points = pointsString.match(/\\d+/g).map(n => parseInt(n, 10));\n      session.context.poly(points, false);\n      if (strokeStyle) session.context.stroke();\n      break;\n    case \"g\":\n    case \"svg\":\n      break;\n    default:\n      {\n        console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n        break;\n      }\n  }\n  for (let i = 0; i < children.length; i++) {\n    renderChildren(children[i], session, fillStyle, strokeStyle);\n  }\n}\nfunction parseFloatAttribute(svg, id, defaultValue) {\n  const value = svg.getAttribute(id);\n  return value ? Number(value) : defaultValue;\n}\nfunction parseStyle(svg) {\n  const style = svg.getAttribute(\"style\");\n  const strokeStyle = {};\n  const fillStyle = {};\n  let useFill = false;\n  let useStroke = false;\n  if (style) {\n    const styleParts = style.split(\";\");\n    for (let i = 0; i < styleParts.length; i++) {\n      const stylePart = styleParts[i];\n      const [key, value] = stylePart.split(\":\");\n      switch (key) {\n        case \"stroke\":\n          if (value !== \"none\") {\n            strokeStyle.color = Color.shared.setValue(value).toNumber();\n            useStroke = true;\n          }\n          break;\n        case \"stroke-width\":\n          strokeStyle.width = Number(value);\n          break;\n        case \"fill\":\n          if (value !== \"none\") {\n            useFill = true;\n            fillStyle.color = Color.shared.setValue(value).toNumber();\n          }\n          break;\n        case \"fill-opacity\":\n          fillStyle.alpha = Number(value);\n          break;\n        case \"stroke-opacity\":\n          strokeStyle.alpha = Number(value);\n          break;\n        case \"opacity\":\n          fillStyle.alpha = Number(value);\n          strokeStyle.alpha = Number(value);\n          break;\n      }\n    }\n  } else {\n    const stroke = svg.getAttribute(\"stroke\");\n    if (stroke && stroke !== \"none\") {\n      useStroke = true;\n      strokeStyle.color = Color.shared.setValue(stroke).toNumber();\n      strokeStyle.width = parseFloatAttribute(svg, \"stroke-width\", 1);\n    }\n    const fill = svg.getAttribute(\"fill\");\n    if (fill && fill !== \"none\") {\n      useFill = true;\n      fillStyle.color = Color.shared.setValue(fill).toNumber();\n    }\n  }\n  return {\n    strokeStyle: useStroke ? strokeStyle : null,\n    fillStyle: useFill ? fillStyle : null\n  };\n}\nexport { SVGParser };","map":{"version":3,"names":["SVGParser","svg","graphicsContext","div","document","createElement","innerHTML","trim","querySelector","session","context","path","GraphicsPath","renderChildren","fillStyle","strokeStyle","children","f1","s1","parseStyle","x","y","x1","y1","x2","y2","cx","cy","r","rx","ry","points","pointsString","d","graphicsPath","width","height","nodeName","toLowerCase","getAttribute","fill","stroke","parseFloatAttribute","ellipse","roundRect","rect","beginPath","moveTo","lineTo","match","map","n","parseInt","poly","console","info","i","length","id","defaultValue","value","Number","style","useFill","useStroke","styleParts","split","stylePart","key","color","Color","shared","setValue","toNumber","alpha"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/graphics/shared/svg/SVGParser.ts"],"sourcesContent":["import { Color } from '../../../../color/Color';\nimport { GraphicsPath } from '../path/GraphicsPath';\n\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillStyle,\n    GraphicsContext,\n    StrokeStyle,\n} from '../GraphicsContext';\n\ninterface Session\n{\n    context: GraphicsContext;\n    path: GraphicsPath;\n}\n\nexport function SVGParser(\n    svg: string | SVGElement | SVGSVGElement,\n    graphicsContext?: GraphicsContext\n): GraphicsContext\n{\n    if (typeof svg === 'string')\n    {\n        const div = document.createElement('div');\n\n        div.innerHTML = svg.trim();\n        svg = div.querySelector('svg') as SVGElement;\n    }\n\n    const session = {\n        context: graphicsContext,\n        path: new GraphicsPath(),\n    };\n\n    renderChildren(svg, session, null, null);\n\n    return graphicsContext;\n}\n\nfunction renderChildren(svg: SVGElement, session: Session, fillStyle: FillStyle, strokeStyle: StrokeStyle): void\n{\n    const children = svg.children;\n\n    const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);\n\n    if (f1 && fillStyle)\n    {\n        fillStyle = { ...fillStyle, ...f1 };\n    }\n    else if (f1)\n    {\n        fillStyle = f1;\n    }\n\n    if (s1 && strokeStyle)\n    {\n        strokeStyle = { ...strokeStyle, ...s1 };\n    }\n    else if (s1)\n    {\n        strokeStyle = s1;\n    }\n\n    session.context.fillStyle = fillStyle;\n    session.context.strokeStyle = strokeStyle;\n\n    let x;\n    let y;\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    let cx;\n    let cy;\n    let r;\n    let rx;\n    let ry;\n    let points;\n    let pointsString;\n    let d;\n    let graphicsPath;\n    let width;\n    let height;\n\n    switch (svg.nodeName.toLowerCase())\n    {\n        case 'path':\n            d = svg.getAttribute('d') as string;\n\n            graphicsPath = new GraphicsPath(d);\n\n            session.context.path(graphicsPath);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'circle':\n            cx = parseFloatAttribute(svg, 'cx', 0);\n            cy = parseFloatAttribute(svg, 'cy', 0);\n\n            r = parseFloatAttribute(svg, 'r', 0);\n\n            session.context.ellipse(cx, cy, r, r);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'rect':\n            x = parseFloatAttribute(svg, 'x', 0);\n            y = parseFloatAttribute(svg, 'y', 0);\n\n            width = parseFloatAttribute(svg, 'width', 0);\n            height = parseFloatAttribute(svg, 'height', 0);\n\n            rx = parseFloatAttribute(svg, 'rx', 0);\n            ry = parseFloatAttribute(svg, 'ry', 0);\n\n            if (rx || ry)\n            {\n                session.context.roundRect(x, y, width, height, rx || ry);\n            }\n            else\n            {\n                session.context.rect(x, y, width, height);\n            }\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'ellipse':\n            cx = parseFloatAttribute(svg, 'cx', 0);\n            cy = parseFloatAttribute(svg, 'cy', 0);\n\n            rx = parseFloatAttribute(svg, 'rx', 0);\n            ry = parseFloatAttribute(svg, 'ry', 0);\n\n            session.context.beginPath();\n            session.context.ellipse(cx, cy, rx, ry); // , 0, Math.PI * 2);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'line':\n            x1 = parseFloatAttribute(svg, 'x1', 0);\n            y1 = parseFloatAttribute(svg, 'y1', 0);\n\n            x2 = parseFloatAttribute(svg, 'x2', 0);\n            y2 = parseFloatAttribute(svg, 'y2', 0);\n\n            session.context.beginPath();\n            session.context.moveTo(x1, y1);\n            session.context.lineTo(x2, y2);\n\n            if (strokeStyle) session.context.stroke();\n\n            break;\n\n        case 'polygon':\n            pointsString = svg.getAttribute('points') as string;\n\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n\n            session.context.poly(points, true);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'polyline':\n            pointsString = svg.getAttribute('points') as string;\n\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n\n            session.context.poly(points, false);\n\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        // children will cover these two..\n        case 'g':\n        case 'svg':\n            break;\n        default: {\n            // eslint-disable-next-line no-console\n            console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n            break;\n        }\n    }\n\n    for (let i = 0; i < children.length; i++)\n    {\n        renderChildren(children[i] as SVGElement, session, fillStyle, strokeStyle);\n    }\n}\n\nfunction parseFloatAttribute(svg: SVGElement, id: string, defaultValue: number): number\n{\n    const value = svg.getAttribute(id) as string;\n\n    return value ? Number(value) : defaultValue;\n}\n\nfunction parseStyle(svg: SVGElement): { strokeStyle: ConvertedStrokeStyle; fillStyle: ConvertedFillStyle }\n{\n    const style = svg.getAttribute('style');\n\n    const strokeStyle: StrokeStyle = {};\n\n    const fillStyle: FillStyle = {};\n\n    let useFill = false;\n    let useStroke = false;\n\n    if (style)\n    {\n        const styleParts = style.split(';');\n\n        for (let i = 0; i < styleParts.length; i++)\n        {\n            const stylePart = styleParts[i];\n\n            const [key, value] = stylePart.split(':');\n\n            switch (key)\n            {\n                case 'stroke':\n                    if (value !== 'none')\n                    {\n                        strokeStyle.color = Color.shared.setValue(value).toNumber();\n                        useStroke = true;\n                    }\n\n                    break;\n                case 'stroke-width':\n                    strokeStyle.width = Number(value);\n                    break;\n                case 'fill':\n                    if (value !== 'none')\n                    {\n                        useFill = true;\n                        fillStyle.color = Color.shared.setValue(value).toNumber();\n                    }\n                    break;\n                case 'fill-opacity':\n                    fillStyle.alpha = Number(value);\n                    break;\n                case 'stroke-opacity':\n                    strokeStyle.alpha = Number(value);\n                    break;\n                case 'opacity':\n                    fillStyle.alpha = Number(value);\n                    strokeStyle.alpha = Number(value);\n                    break;\n            }\n        }\n    }\n    else\n    {\n        const stroke = svg.getAttribute('stroke');\n\n        if (stroke && stroke !== 'none')\n        {\n            useStroke = true;\n            strokeStyle.color = Color.shared.setValue(stroke).toNumber();\n\n            strokeStyle.width = parseFloatAttribute(svg, 'stroke-width', 1);\n        }\n\n        const fill = svg.getAttribute('fill');\n\n        if (fill && fill !== 'none')\n        {\n            useFill = true;\n            fillStyle.color = Color.shared.setValue(fill).toNumber();\n        }\n    }\n\n    return {\n        strokeStyle: useStroke ? (strokeStyle as ConvertedStrokeStyle) : null,\n        fillStyle: useFill ? (fillStyle as ConvertedFillStyle) : null,\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}