{"ast":null,"code":"\"use strict\";\n\nconst bitmapFontTextParser = {\n  test(data) {\n    return typeof data === \"string\" && data.startsWith(\"info face=\");\n  },\n  parse(txt) {\n    const items = txt.match(/^[a-z]+\\s+.+$/gm);\n    const rawData = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (const i in items) {\n      const name = items[i].match(/^[a-z]+/gm)[0];\n      const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n      const itemData = {};\n      for (const i2 in attributeList) {\n        const split = attributeList[i2].split(\"=\");\n        const key = split[0];\n        const strValue = split[1].replace(/\"/gm, \"\");\n        const floatValue = parseFloat(strValue);\n        const value = isNaN(floatValue) ? strValue : floatValue;\n        itemData[key] = value;\n      }\n      rawData[name].push(itemData);\n    }\n    const font = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: \"\",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const [info] = rawData.info;\n    const [common] = rawData.common;\n    const [distanceField] = rawData.distanceField ?? [];\n    if (distanceField) {\n      font.distanceField = {\n        range: parseInt(distanceField.distanceRange, 10),\n        type: distanceField.fieldType\n      };\n    }\n    font.fontSize = parseInt(info.size, 10);\n    font.fontFamily = info.face;\n    font.lineHeight = parseInt(common.lineHeight, 10);\n    const page = rawData.page;\n    for (let i = 0; i < page.length; i++) {\n      font.pages.push({\n        id: parseInt(page[i].id, 10) || 0,\n        file: page[i].file\n      });\n    }\n    const map = {};\n    font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n    const char = rawData.char;\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.id, 10);\n      let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n      if (letter === \"space\") letter = \" \";\n      map[id] = letter;\n      font.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.page, 10) || 0,\n        x: parseInt(charNode.x, 10),\n        y: parseInt(charNode.y, 10),\n        width: parseInt(charNode.width, 10),\n        height: parseInt(charNode.height, 10),\n        xOffset: parseInt(charNode.xoffset, 10),\n        yOffset: parseInt(charNode.yoffset, 10),\n        xAdvance: parseInt(charNode.xadvance, 10),\n        kerning: {}\n      };\n    }\n    const kerning = rawData.kerning || [];\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].first, 10);\n      const second = parseInt(kerning[i].second, 10);\n      const amount = parseInt(kerning[i].amount, 10);\n      font.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return font;\n  }\n};\nexport { bitmapFontTextParser };","map":{"version":3,"names":["bitmapFontTextParser","test","data","startsWith","parse","txt","items","match","rawData","info","common","page","char","chars","kerning","kernings","distanceField","i","name","attributeList","itemData","i2","split","key","strValue","replace","floatValue","parseFloat","value","isNaN","push","font","pages","lineHeight","fontSize","fontFamily","baseLineOffset","range","parseInt","distanceRange","type","fieldType","size","face","length","id","file","map","base","charNode","letter","String","fromCharCode","x","y","width","height","xOffset","xoffset","yOffset","yoffset","xAdvance","xadvance","first","second","amount"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontTextParser.ts"],"sourcesContent":["import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\n/**\n * Internal data format used to convert to BitmapFontData.\n * @private\n */\nexport interface BitmapFontRawData\n{\n    info: {\n        face: string;\n        size: string;\n    }[];\n    common: { lineHeight: string, base: string }[];\n    page: {\n        id: string;\n        file: string;\n    }[];\n    chars: {\n        count: number;\n    }[];\n    char: {\n        id: string\n        page: string\n        xoffset: string\n        yoffset: string\n        xadvance: string,\n        x: string\n        y: string\n        width: string\n        height: string\n        letter?: string\n        char?: string\n    }[];\n    kernings?: {\n        count: number;\n    }[];\n    kerning?: {\n        first: string;\n        second: string;\n        amount: string;\n    }[];\n    distanceField?: {\n        fieldType: 'sdf' | 'msdf' | 'none';\n        distanceRange: string;\n    }[]\n}\n\nexport const bitmapFontTextParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        return typeof data === 'string' && data.startsWith('info face=');\n    },\n\n    parse(txt: string): BitmapFontData\n    {\n        // Retrieve data item\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData: BitmapFontRawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: [],\n        };\n\n        for (const i in items)\n        {\n            // Extract item name\n            const name = items[i].match(/^[a-z]+/gm)[0] as keyof BitmapFontRawData;\n\n            // Extract item attribute list as string ex.: \"width=10\"\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n\n            // Convert attribute list into an object\n            const itemData: any = {};\n\n            for (const i in attributeList)\n            {\n                // Split key-value pairs\n                const split = attributeList[i].split('=');\n                const key = split[0];\n\n                // Remove eventual quotes from value\n                const strValue = split[1].replace(/\"/gm, '');\n\n                // Try to convert value into float\n                const floatValue = parseFloat(strValue);\n\n                // Use string value case float value is NaN\n                const value = isNaN(floatValue) ? strValue : floatValue;\n\n                itemData[key] = value;\n            }\n\n            // Push current item to the resulting data\n            rawData[name].push(itemData);\n        }\n\n        const font: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const [info] = rawData.info;\n        const [common] = rawData.common;\n        const [distanceField] = rawData.distanceField ?? [];\n\n        if (distanceField)\n        {\n            font.distanceField = {\n                range: parseInt(distanceField.distanceRange, 10),\n                type: distanceField.fieldType\n            };\n        }\n\n        font.fontSize = parseInt(info.size, 10);\n        font.fontFamily = info.face;\n        font.lineHeight = parseInt(common.lineHeight, 10);\n\n        const page = rawData.page;\n\n        for (let i = 0; i < page.length; i++)\n        {\n            font.pages.push({\n                id: parseInt(page[i].id, 10) || 0,\n                file: page[i].file,\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n\n        const char = rawData.char;\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.id, 10);\n\n            let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            font.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.page, 10) || 0,\n                x: parseInt(charNode.x, 10),\n                y: parseInt(charNode.y, 10),\n                width: parseInt(charNode.width, 10),\n                height: parseInt(charNode.height, 10),\n                xOffset: parseInt(charNode.xoffset, 10),\n                yOffset: parseInt(charNode.yoffset, 10),\n                xAdvance: parseInt(charNode.xadvance, 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        const kerning = rawData.kerning || [];\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].first, 10);\n            const second = parseInt(kerning[i].second, 10);\n            const amount = parseInt(kerning[i].amount, 10);\n\n            font.chars[map[second]].kerning[map[first]] = amount;\n        }\n\n        return font;\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}