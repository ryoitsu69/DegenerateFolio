{"ast":null,"code":"import _defineProperty from \"/home/ryoitsu/Documents/test/react-todo-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport SHA3 from \"js-sha3\";\nimport Nacl from \"tweetnacl\";\nimport { Buffer } from 'buffer';\nimport { hexstr } from \"../helpers/hex-string.js\";\nconst {\n  sign\n} = Nacl;\nconst {\n  sha3_256\n} = SHA3;\nexport class Account {\n  constructor(privateKey, address) {\n    _defineProperty(this, \"signingKey\", {});\n    _defineProperty(this, \"accountAddress\", \"\");\n    _defineProperty(this, \"accountAuthKey\", \"\");\n    if (privateKey) {\n      if (typeof privateKey === \"string\") {\n        privateKey = Uint8Array.from(Buffer.from(privateKey, 'hex'));\n      }\n      this.signingKey = sign.keyPair.fromSeed(privateKey.slice(0, 32));\n    } else {\n      this.signingKey = sign.keyPair();\n    }\n    this.accountAddress = hexstr(address || this.authKey()).hex();\n  }\n  privateKey() {\n    return Buffer.from(this.signingKey.secretKey).toString(\"hex\").slice(0, 64);\n  }\n  address() {\n    return this.accountAddress;\n  }\n  authKey() {\n    if (!this.accountAuthKey) {\n      let hash = sha3_256.create();\n      hash.update(Buffer.from(this.signingKey.publicKey));\n      hash.update(\"\\x00\");\n      this.accountAuthKey = hash.hex();\n    }\n    return this.accountAuthKey;\n  }\n  pubKey() {\n    return hexstr(Buffer.from(this.signingKey.publicKey).toString(\"hex\")).toString();\n  }\n  signBuffer(buffer) {\n    const signature = sign(buffer, this.signingKey.secretKey);\n    return hexstr(Buffer.from(signature).toString(\"hex\").slice(0, 128)).toString();\n  }\n  signHexString(hexString) {\n    const toSign = hexstr(hexString).toBuffer();\n    return this.signBuffer(toSign);\n  }\n  signString(str) {\n    let enc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf8';\n    const toSign = Buffer.from(str, enc);\n    return this.signBuffer(toSign);\n  }\n  signObject(obj) {\n    return this.signString(JSON.stringify(obj));\n  }\n  sign() {\n    return this.signHexString(this.accountAddress).slice(2);\n  }\n  toObject() {\n    return {\n      address: this.address(),\n      publicKey: this.pubKey(),\n      authKey: this.authKey(),\n      privateKey: this.privateKey()\n    };\n  }\n}\nAccount.fromSeed = seed => new Account(seed);\nAccount.fromObject = accountObject => new Account(accountObject.privateKey);\nAccount.norm = addr => hexstr(addr);\nAccount._0x = a => {\n  if (a instanceof Account) {\n    return a.address();\n  } else if (typeof a === \"string\") {\n    return hexstr(a).toString();\n  } else if (typeof a === \"object\" && a.address) {\n    return hexstr(a.address).toString();\n  } else {\n    throw new Error(\"Value is not an Aptos address or compatible object!\");\n  }\n};\nexport const account = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return new Account(...args);\n};","map":{"version":3,"names":["SHA3","Nacl","Buffer","hexstr","sign","sha3_256","Account","constructor","privateKey","address","_defineProperty","Uint8Array","from","signingKey","keyPair","fromSeed","slice","accountAddress","authKey","hex","secretKey","toString","accountAuthKey","hash","create","update","publicKey","pubKey","signBuffer","buffer","signature","signHexString","hexString","toSign","toBuffer","signString","str","enc","arguments","length","undefined","signObject","obj","JSON","stringify","toObject","seed","fromObject","accountObject","norm","addr","_0x","a","Error","account","_len","args","Array","_key"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/aptos-api-master/src/account/index.js"],"sourcesContent":["import SHA3 from \"js-sha3\"\nimport Nacl from \"tweetnacl\"\nimport {Buffer} from 'buffer'\nimport {hexstr} from \"../helpers/hex-string.js\"\n\nconst {sign} = Nacl\nconst {sha3_256} = SHA3\n\nexport class Account {\n    signingKey = {}\n    accountAddress = \"\"\n    accountAuthKey = \"\"\n\n    constructor(privateKey, address){\n        if (privateKey) {\n            if (typeof privateKey === \"string\") {\n                privateKey = Uint8Array.from(Buffer.from(privateKey, 'hex'))\n            }\n            this.signingKey = sign.keyPair.fromSeed(privateKey.slice(0, 32))\n        } else {\n            this.signingKey = sign.keyPair()\n        }\n        this.accountAddress = hexstr(address || this.authKey()).hex()\n    }\n\n    privateKey(){\n        return Buffer.from(this.signingKey.secretKey).toString(\"hex\").slice(0, 64)\n    }\n\n    address(){\n        return this.accountAddress\n    }\n\n    authKey(){\n        if (!this.accountAuthKey) {\n            let hash = sha3_256.create()\n            hash.update(Buffer.from(this.signingKey.publicKey))\n            hash.update(\"\\x00\")\n            this.accountAuthKey = hash.hex()\n        }\n        return this.accountAuthKey\n    }\n\n    pubKey(){\n        return hexstr(Buffer.from(this.signingKey.publicKey).toString(\"hex\")).toString()\n    }\n\n    signBuffer(buffer){\n        const signature = sign(buffer, this.signingKey.secretKey)\n        return hexstr(Buffer.from(signature).toString(\"hex\").slice(0, 128)).toString();\n    }\n\n    signHexString(hexString){\n        const toSign = hexstr(hexString).toBuffer();\n        return this.signBuffer(toSign);\n    }\n\n    signString(str, enc = 'utf8'){\n        const toSign = Buffer.from(str, enc);\n        return this.signBuffer(toSign);\n    }\n\n    signObject(obj){\n        return this.signString(JSON.stringify(obj))\n    }\n\n    sign(){\n        return this.signHexString(this.accountAddress).slice(2)\n    }\n\n    toObject() {\n        return {\n            address: this.address(),\n            publicKey: this.pubKey(),\n            authKey: this.authKey(),\n            privateKey: this.privateKey(),\n        };\n    }\n}\n\nAccount.fromSeed = (seed) => new Account(seed)\nAccount.fromObject = (accountObject) => new Account(accountObject.privateKey)\nAccount.norm = addr => hexstr(addr)\nAccount._0x = a => {\n    if (a instanceof Account) {\n        return a.address()\n    } else if (typeof a === \"string\") {\n        return hexstr(a).toString()\n    } else if (typeof a === \"object\" && a.address) {\n        return hexstr(a.address).toString()\n    } else {\n        throw new Error(\"Value is not an Aptos address or compatible object!\")\n    }\n}\n\nexport const account = (...args) => new Account(...args)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}