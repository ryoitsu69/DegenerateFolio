{"ast":null,"code":"import _defineProperty from \"/home/ryoitsu/Documents/test/react-todo-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { compactFromU8aLim, compactToU8a, isHex, isU8a, logger, stringify, u8aConcatStrict, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { compareSet, decodeU8aVec, sortSet, typeToConstructor } from '../utils/index.js';\nconst l = logger('BTreeSet');\n/** @internal */\nfunction decodeSetFromU8a(registry, ValClass, u8a) {\n  const output = new Set();\n  const [offset, count] = compactFromU8aLim(u8a);\n  const result = new Array(count);\n  const [decodedLength] = decodeU8aVec(registry, result, u8a, offset, ValClass);\n  for (let i = 0; i < count; i++) {\n    output.add(result[i]);\n  }\n  return [ValClass, output, decodedLength];\n}\n/** @internal */\nfunction decodeSetFromSet(registry, ValClass, value) {\n  const output = new Set();\n  value.forEach(val => {\n    try {\n      output.add(val instanceof ValClass ? val : new ValClass(registry, val));\n    } catch (error) {\n      l.error('Failed to decode key or value:', error.message);\n      throw error;\n    }\n  });\n  return [ValClass, output, 0];\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param ValClass - Type of the map value\n * @param value - Value to decode, one of:\n * - null\n * - undefined\n * - hex\n * - Uint8Array\n * - Set<any>, where both key and value types are either\n *   constructors or decodeable values for their types.\n * @param jsonSet\n * @internal\n */\nfunction decodeSet(registry, valType, value) {\n  const ValClass = typeToConstructor(registry, valType);\n  if (!value) {\n    return [ValClass, new Set(), 0];\n  } else if (isU8a(value) || isHex(value)) {\n    return decodeSetFromU8a(registry, ValClass, u8aToU8a(value));\n  } else if (Array.isArray(value) || value instanceof Set) {\n    return decodeSetFromSet(registry, ValClass, value);\n  }\n  throw new Error('BTreeSet: cannot decode type');\n}\nexport class BTreeSet extends Set {\n  constructor(registry, valType, rawValue) {\n    const [ValClass, values, decodedLength] = decodeSet(registry, valType, rawValue);\n    super(sortSet(values));\n    _defineProperty(this, \"registry\", void 0);\n    _defineProperty(this, \"createdAtHash\", void 0);\n    _defineProperty(this, \"initialU8aLength\", void 0);\n    _defineProperty(this, \"isStorageFallback\", void 0);\n    _defineProperty(this, \"__internal__ValClass\", void 0);\n    this.registry = registry;\n    this.initialU8aLength = decodedLength;\n    this.__internal__ValClass = ValClass;\n  }\n  static with(valType) {\n    return class extends BTreeSet {\n      constructor(registry, value) {\n        super(registry, valType, value);\n      }\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    let len = compactToU8a(this.size).length;\n    for (const v of this.values()) {\n      len += v.encodedLength;\n    }\n    return len;\n  }\n  /**\n   * @description Returns a hash of the value\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n  get isEmpty() {\n    return this.size === 0;\n  }\n  /**\n   * @description The actual set values as a string[]\n   */\n  get strings() {\n    return [...super.values()].map(v => v.toString());\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return compareSet(this, other);\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    const inner = [];\n    for (const v of this.values()) {\n      inner.push(v.inspect());\n    }\n    return {\n      inner,\n      outer: [compactToU8a(this.size)]\n    };\n  }\n  /**\n   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation\n   */\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExtended, disableAscii) {\n    const json = [];\n    for (const v of this.values()) {\n      json.push(v.toHuman(isExtended, disableAscii));\n    }\n    return json;\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    const json = [];\n    for (const v of this.values()) {\n      json.push(v.toJSON());\n    }\n    return json;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return \"BTreeSet<\".concat(this.registry.getClassName(this.__internal__ValClass) || new this.__internal__ValClass(this.registry).toRawType(), \">\");\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive(disableAscii) {\n    const json = [];\n    for (const v of this.values()) {\n      json.push(v.toPrimitive(disableAscii));\n    }\n    return json;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    const encoded = [];\n    if (!isBare) {\n      encoded.push(compactToU8a(this.size));\n    }\n    for (const v of this.values()) {\n      encoded.push(v.toU8a(isBare));\n    }\n    return u8aConcatStrict(encoded);\n  }\n}","map":{"version":3,"names":["compactFromU8aLim","compactToU8a","isHex","isU8a","logger","stringify","u8aConcatStrict","u8aToHex","u8aToU8a","compareSet","decodeU8aVec","sortSet","typeToConstructor","l","decodeSetFromU8a","registry","ValClass","u8a","output","Set","offset","count","result","Array","decodedLength","i","add","decodeSetFromSet","value","forEach","val","error","message","decodeSet","valType","isArray","Error","BTreeSet","constructor","rawValue","values","_defineProperty","initialU8aLength","__internal__ValClass","with","encodedLength","len","size","length","v","hash","toU8a","isEmpty","strings","map","toString","eq","other","inspect","inner","push","outer","toHex","toHuman","isExtended","disableAscii","json","toJSON","toRawType","concat","getClassName","toPrimitive","isBare","encoded"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/extended/BTreeSet.js"],"sourcesContent":["import { compactFromU8aLim, compactToU8a, isHex, isU8a, logger, stringify, u8aConcatStrict, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { compareSet, decodeU8aVec, sortSet, typeToConstructor } from '../utils/index.js';\nconst l = logger('BTreeSet');\n/** @internal */\nfunction decodeSetFromU8a(registry, ValClass, u8a) {\n    const output = new Set();\n    const [offset, count] = compactFromU8aLim(u8a);\n    const result = new Array(count);\n    const [decodedLength] = decodeU8aVec(registry, result, u8a, offset, ValClass);\n    for (let i = 0; i < count; i++) {\n        output.add(result[i]);\n    }\n    return [ValClass, output, decodedLength];\n}\n/** @internal */\nfunction decodeSetFromSet(registry, ValClass, value) {\n    const output = new Set();\n    value.forEach((val) => {\n        try {\n            output.add((val instanceof ValClass) ? val : new ValClass(registry, val));\n        }\n        catch (error) {\n            l.error('Failed to decode key or value:', error.message);\n            throw error;\n        }\n    });\n    return [ValClass, output, 0];\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param ValClass - Type of the map value\n * @param value - Value to decode, one of:\n * - null\n * - undefined\n * - hex\n * - Uint8Array\n * - Set<any>, where both key and value types are either\n *   constructors or decodeable values for their types.\n * @param jsonSet\n * @internal\n */\nfunction decodeSet(registry, valType, value) {\n    const ValClass = typeToConstructor(registry, valType);\n    if (!value) {\n        return [ValClass, new Set(), 0];\n    }\n    else if (isU8a(value) || isHex(value)) {\n        return decodeSetFromU8a(registry, ValClass, u8aToU8a(value));\n    }\n    else if (Array.isArray(value) || value instanceof Set) {\n        return decodeSetFromSet(registry, ValClass, value);\n    }\n    throw new Error('BTreeSet: cannot decode type');\n}\nexport class BTreeSet extends Set {\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    __internal__ValClass;\n    constructor(registry, valType, rawValue) {\n        const [ValClass, values, decodedLength] = decodeSet(registry, valType, rawValue);\n        super(sortSet(values));\n        this.registry = registry;\n        this.initialU8aLength = decodedLength;\n        this.__internal__ValClass = ValClass;\n    }\n    static with(valType) {\n        return class extends BTreeSet {\n            constructor(registry, value) {\n                super(registry, valType, value);\n            }\n        };\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        let len = compactToU8a(this.size).length;\n        for (const v of this.values()) {\n            len += v.encodedLength;\n        }\n        return len;\n    }\n    /**\n     * @description Returns a hash of the value\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        return this.size === 0;\n    }\n    /**\n     * @description The actual set values as a string[]\n     */\n    get strings() {\n        return [...super.values()].map((v) => v.toString());\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return compareSet(this, other);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        const inner = [];\n        for (const v of this.values()) {\n            inner.push(v.inspect());\n        }\n        return {\n            inner,\n            outer: [compactToU8a(this.size)]\n        };\n    }\n    /**\n     * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation\n     */\n    toHex() {\n        return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExtended, disableAscii) {\n        const json = [];\n        for (const v of this.values()) {\n            json.push(v.toHuman(isExtended, disableAscii));\n        }\n        return json;\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        const json = [];\n        for (const v of this.values()) {\n            json.push(v.toJSON());\n        }\n        return json;\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `BTreeSet<${this.registry.getClassName(this.__internal__ValClass) || new this.__internal__ValClass(this.registry).toRawType()}>`;\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive(disableAscii) {\n        const json = [];\n        for (const v of this.values()) {\n            json.push(v.toPrimitive(disableAscii));\n        }\n        return json;\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return stringify(this.toJSON());\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        const encoded = [];\n        if (!isBare) {\n            encoded.push(compactToU8a(this.size));\n        }\n        for (const v of this.values()) {\n            encoded.push(v.toU8a(isBare));\n        }\n        return u8aConcatStrict(encoded);\n    }\n}\n"],"mappings":";AAAA,SAASA,iBAAiB,EAAEC,YAAY,EAAEC,KAAK,EAAEC,KAAK,EAAEC,MAAM,EAAEC,SAAS,EAAEC,eAAe,EAAEC,QAAQ,EAAEC,QAAQ,QAAQ,gBAAgB;AACtI,SAASC,UAAU,EAAEC,YAAY,EAAEC,OAAO,EAAEC,iBAAiB,QAAQ,mBAAmB;AACxF,MAAMC,CAAC,GAAGT,MAAM,CAAC,UAAU,CAAC;AAC5B;AACA,SAASU,gBAAgBA,CAACC,QAAQ,EAAEC,QAAQ,EAAEC,GAAG,EAAE;EAC/C,MAAMC,MAAM,GAAG,IAAIC,GAAG,CAAC,CAAC;EACxB,MAAM,CAACC,MAAM,EAAEC,KAAK,CAAC,GAAGrB,iBAAiB,CAACiB,GAAG,CAAC;EAC9C,MAAMK,MAAM,GAAG,IAAIC,KAAK,CAACF,KAAK,CAAC;EAC/B,MAAM,CAACG,aAAa,CAAC,GAAGd,YAAY,CAACK,QAAQ,EAAEO,MAAM,EAAEL,GAAG,EAAEG,MAAM,EAAEJ,QAAQ,CAAC;EAC7E,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,EAAEI,CAAC,EAAE,EAAE;IAC5BP,MAAM,CAACQ,GAAG,CAACJ,MAAM,CAACG,CAAC,CAAC,CAAC;EACzB;EACA,OAAO,CAACT,QAAQ,EAAEE,MAAM,EAAEM,aAAa,CAAC;AAC5C;AACA;AACA,SAASG,gBAAgBA,CAACZ,QAAQ,EAAEC,QAAQ,EAAEY,KAAK,EAAE;EACjD,MAAMV,MAAM,GAAG,IAAIC,GAAG,CAAC,CAAC;EACxBS,KAAK,CAACC,OAAO,CAAEC,GAAG,IAAK;IACnB,IAAI;MACAZ,MAAM,CAACQ,GAAG,CAAEI,GAAG,YAAYd,QAAQ,GAAIc,GAAG,GAAG,IAAId,QAAQ,CAACD,QAAQ,EAAEe,GAAG,CAAC,CAAC;IAC7E,CAAC,CACD,OAAOC,KAAK,EAAE;MACVlB,CAAC,CAACkB,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAACC,OAAO,CAAC;MACxD,MAAMD,KAAK;IACf;EACJ,CAAC,CAAC;EACF,OAAO,CAACf,QAAQ,EAAEE,MAAM,EAAE,CAAC,CAAC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASe,SAASA,CAAClB,QAAQ,EAAEmB,OAAO,EAAEN,KAAK,EAAE;EACzC,MAAMZ,QAAQ,GAAGJ,iBAAiB,CAACG,QAAQ,EAAEmB,OAAO,CAAC;EACrD,IAAI,CAACN,KAAK,EAAE;IACR,OAAO,CAACZ,QAAQ,EAAE,IAAIG,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;EACnC,CAAC,MACI,IAAIhB,KAAK,CAACyB,KAAK,CAAC,IAAI1B,KAAK,CAAC0B,KAAK,CAAC,EAAE;IACnC,OAAOd,gBAAgB,CAACC,QAAQ,EAAEC,QAAQ,EAAER,QAAQ,CAACoB,KAAK,CAAC,CAAC;EAChE,CAAC,MACI,IAAIL,KAAK,CAACY,OAAO,CAACP,KAAK,CAAC,IAAIA,KAAK,YAAYT,GAAG,EAAE;IACnD,OAAOQ,gBAAgB,CAACZ,QAAQ,EAAEC,QAAQ,EAAEY,KAAK,CAAC;EACtD;EACA,MAAM,IAAIQ,KAAK,CAAC,8BAA8B,CAAC;AACnD;AACA,OAAO,MAAMC,QAAQ,SAASlB,GAAG,CAAC;EAM9BmB,WAAWA,CAACvB,QAAQ,EAAEmB,OAAO,EAAEK,QAAQ,EAAE;IACrC,MAAM,CAACvB,QAAQ,EAAEwB,MAAM,EAAEhB,aAAa,CAAC,GAAGS,SAAS,CAAClB,QAAQ,EAAEmB,OAAO,EAAEK,QAAQ,CAAC;IAChF,KAAK,CAAC5B,OAAO,CAAC6B,MAAM,CAAC,CAAC;IAACC,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IACvB,IAAI,CAAC1B,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC2B,gBAAgB,GAAGlB,aAAa;IACrC,IAAI,CAACmB,oBAAoB,GAAG3B,QAAQ;EACxC;EACA,OAAO4B,IAAIA,CAACV,OAAO,EAAE;IACjB,OAAO,cAAcG,QAAQ,CAAC;MAC1BC,WAAWA,CAACvB,QAAQ,EAAEa,KAAK,EAAE;QACzB,KAAK,CAACb,QAAQ,EAAEmB,OAAO,EAAEN,KAAK,CAAC;MACnC;IACJ,CAAC;EACL;EACA;AACJ;AACA;EACI,IAAIiB,aAAaA,CAAA,EAAG;IAChB,IAAIC,GAAG,GAAG7C,YAAY,CAAC,IAAI,CAAC8C,IAAI,CAAC,CAACC,MAAM;IACxC,KAAK,MAAMC,CAAC,IAAI,IAAI,CAACT,MAAM,CAAC,CAAC,EAAE;MAC3BM,GAAG,IAAIG,CAAC,CAACJ,aAAa;IAC1B;IACA,OAAOC,GAAG;EACd;EACA;AACJ;AACA;EACI,IAAII,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACnC,QAAQ,CAACmC,IAAI,CAAC,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC;EAC3C;EACA;AACJ;AACA;EACI,IAAIC,OAAOA,CAAA,EAAG;IACV,OAAO,IAAI,CAACL,IAAI,KAAK,CAAC;EAC1B;EACA;AACJ;AACA;EACI,IAAIM,OAAOA,CAAA,EAAG;IACV,OAAO,CAAC,GAAG,KAAK,CAACb,MAAM,CAAC,CAAC,CAAC,CAACc,GAAG,CAAEL,CAAC,IAAKA,CAAC,CAACM,QAAQ,CAAC,CAAC,CAAC;EACvD;EACA;AACJ;AACA;EACIC,EAAEA,CAACC,KAAK,EAAE;IACN,OAAOhD,UAAU,CAAC,IAAI,EAAEgD,KAAK,CAAC;EAClC;EACA;AACJ;AACA;EACIC,OAAOA,CAAA,EAAG;IACN,MAAMC,KAAK,GAAG,EAAE;IAChB,KAAK,MAAMV,CAAC,IAAI,IAAI,CAACT,MAAM,CAAC,CAAC,EAAE;MAC3BmB,KAAK,CAACC,IAAI,CAACX,CAAC,CAACS,OAAO,CAAC,CAAC,CAAC;IAC3B;IACA,OAAO;MACHC,KAAK;MACLE,KAAK,EAAE,CAAC5D,YAAY,CAAC,IAAI,CAAC8C,IAAI,CAAC;IACnC,CAAC;EACL;EACA;AACJ;AACA;EACIe,KAAKA,CAAA,EAAG;IACJ,OAAOvD,QAAQ,CAAC,IAAI,CAAC4C,KAAK,CAAC,CAAC,CAAC;EACjC;EACA;AACJ;AACA;EACIY,OAAOA,CAACC,UAAU,EAAEC,YAAY,EAAE;IAC9B,MAAMC,IAAI,GAAG,EAAE;IACf,KAAK,MAAMjB,CAAC,IAAI,IAAI,CAACT,MAAM,CAAC,CAAC,EAAE;MAC3B0B,IAAI,CAACN,IAAI,CAACX,CAAC,CAACc,OAAO,CAACC,UAAU,EAAEC,YAAY,CAAC,CAAC;IAClD;IACA,OAAOC,IAAI;EACf;EACA;AACJ;AACA;EACIC,MAAMA,CAAA,EAAG;IACL,MAAMD,IAAI,GAAG,EAAE;IACf,KAAK,MAAMjB,CAAC,IAAI,IAAI,CAACT,MAAM,CAAC,CAAC,EAAE;MAC3B0B,IAAI,CAACN,IAAI,CAACX,CAAC,CAACkB,MAAM,CAAC,CAAC,CAAC;IACzB;IACA,OAAOD,IAAI;EACf;EACA;AACJ;AACA;EACIE,SAASA,CAAA,EAAG;IACR,mBAAAC,MAAA,CAAmB,IAAI,CAACtD,QAAQ,CAACuD,YAAY,CAAC,IAAI,CAAC3B,oBAAoB,CAAC,IAAI,IAAI,IAAI,CAACA,oBAAoB,CAAC,IAAI,CAAC5B,QAAQ,CAAC,CAACqD,SAAS,CAAC,CAAC;EACxI;EACA;AACJ;AACA;EACIG,WAAWA,CAACN,YAAY,EAAE;IACtB,MAAMC,IAAI,GAAG,EAAE;IACf,KAAK,MAAMjB,CAAC,IAAI,IAAI,CAACT,MAAM,CAAC,CAAC,EAAE;MAC3B0B,IAAI,CAACN,IAAI,CAACX,CAAC,CAACsB,WAAW,CAACN,YAAY,CAAC,CAAC;IAC1C;IACA,OAAOC,IAAI;EACf;EACA;AACJ;AACA;EACIX,QAAQA,CAAA,EAAG;IACP,OAAOlD,SAAS,CAAC,IAAI,CAAC8D,MAAM,CAAC,CAAC,CAAC;EACnC;EACA;AACJ;AACA;AACA;EACIhB,KAAKA,CAACqB,MAAM,EAAE;IACV,MAAMC,OAAO,GAAG,EAAE;IAClB,IAAI,CAACD,MAAM,EAAE;MACTC,OAAO,CAACb,IAAI,CAAC3D,YAAY,CAAC,IAAI,CAAC8C,IAAI,CAAC,CAAC;IACzC;IACA,KAAK,MAAME,CAAC,IAAI,IAAI,CAACT,MAAM,CAAC,CAAC,EAAE;MAC3BiC,OAAO,CAACb,IAAI,CAACX,CAAC,CAACE,KAAK,CAACqB,MAAM,CAAC,CAAC;IACjC;IACA,OAAOlE,eAAe,CAACmE,OAAO,CAAC;EACnC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}