{"ast":null,"code":"import { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { buildUvs, buildSimpleUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs.mjs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { BigPool } from '../../../../utils/pool/PoolGroup.mjs';\nimport { BatchableGraphics } from '../BatchableGraphics.mjs';\nimport { buildCircle } from '../buildCommands/buildCircle.mjs';\nimport { buildLine } from '../buildCommands/buildLine.mjs';\nimport { buildPolygon } from '../buildCommands/buildPolygon.mjs';\nimport { buildRectangle } from '../buildCommands/buildRectangle.mjs';\nimport { buildTriangle } from '../buildCommands/buildTriangle.mjs';\nimport { triangulateWithHoles } from './triangulateWithHoles.mjs';\n\"use strict\";\nconst buildMap = {\n  rectangle: buildRectangle,\n  polygon: buildPolygon,\n  triangle: buildTriangle,\n  circle: buildCircle,\n  ellipse: buildCircle,\n  roundedRectangle: buildCircle\n};\nconst tempRect = new Rectangle();\nfunction buildContextBatches(context, gpuContext) {\n  const {\n    geometryData,\n    batches\n  } = gpuContext;\n  batches.length = 0;\n  geometryData.indices.length = 0;\n  geometryData.vertices.length = 0;\n  geometryData.uvs.length = 0;\n  for (let i = 0; i < context.instructions.length; i++) {\n    const instruction = context.instructions[i];\n    if (instruction.action === \"texture\") {\n      addTextureToGeometryData(instruction.data, batches, geometryData);\n    } else if (instruction.action === \"fill\" || instruction.action === \"stroke\") {\n      const isStroke = instruction.action === \"stroke\";\n      const shapePath = instruction.data.path.shapePath;\n      const style = instruction.data.style;\n      const hole = instruction.data.hole;\n      if (isStroke && hole) {\n        addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n      }\n      addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n    }\n  }\n}\nfunction addTextureToGeometryData(data, batches, geometryData) {\n  const {\n    vertices,\n    uvs,\n    indices\n  } = geometryData;\n  const indexOffset = indices.length;\n  const vertOffset = vertices.length / 2;\n  const points = [];\n  const build = buildMap.rectangle;\n  const rect = tempRect;\n  const texture = data.image;\n  rect.x = data.dx;\n  rect.y = data.dy;\n  rect.width = data.dw;\n  rect.height = data.dh;\n  const matrix = data.transform;\n  build.build(rect, points);\n  if (matrix) {\n    transformVertices(points, matrix);\n  }\n  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n  const textureUvs = texture.uvs;\n  uvs.push(textureUvs.x0, textureUvs.y0, textureUvs.x1, textureUvs.y1, textureUvs.x3, textureUvs.y3, textureUvs.x2, textureUvs.y2);\n  const graphicsBatch = BigPool.get(BatchableGraphics);\n  graphicsBatch.indexOffset = indexOffset;\n  graphicsBatch.indexSize = indices.length - indexOffset;\n  graphicsBatch.vertexOffset = vertOffset;\n  graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n  graphicsBatch.color = data.style;\n  graphicsBatch.alpha = data.alpha;\n  graphicsBatch.texture = texture;\n  graphicsBatch.geometryData = geometryData;\n  batches.push(graphicsBatch);\n}\nfunction addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {\n  const {\n    vertices,\n    uvs,\n    indices\n  } = geometryData;\n  const lastIndex = shapePath.shapePrimitives.length - 1;\n  shapePath.shapePrimitives.forEach(({\n    shape,\n    transform: matrix\n  }, i) => {\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    const points = [];\n    const build = buildMap[shape.type];\n    build.build(shape, points);\n    if (matrix) {\n      transformVertices(points, matrix);\n    }\n    if (!isStroke) {\n      if (hole && lastIndex === i) {\n        if (lastIndex !== 0) {\n          console.warn(\"[Pixi Graphics] only the last shape have be cut out\");\n        }\n        const holeIndices = [];\n        const otherPoints = points.slice();\n        const holeArrays = getHoleArrays(hole.shapePath);\n        holeArrays.forEach(holePoints => {\n          holeIndices.push(otherPoints.length / 2);\n          otherPoints.push(...holePoints);\n        });\n        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n      } else {\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n      }\n    } else {\n      const close = shape.closePath ?? true;\n      const lineStyle = style;\n      buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n    }\n    const uvsOffset = uvs.length / 2;\n    const texture = style.texture;\n    if (texture !== Texture.WHITE) {\n      const textureMatrix = style.matrix;\n      if (matrix) {\n        textureMatrix.append(matrix.clone().invert());\n      }\n      buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n    } else {\n      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n    }\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.vertexOffset = vertOffset;\n    graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.color = style.color;\n    graphicsBatch.alpha = style.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    batches.push(graphicsBatch);\n  });\n}\nfunction getHoleArrays(shape) {\n  if (!shape) return [];\n  const holePrimitives = shape.shapePrimitives;\n  const holeArrays = [];\n  for (let k = 0; k < holePrimitives.length; k++) {\n    const holePrimitive = holePrimitives[k].shape;\n    const holePoints = [];\n    const holeBuilder = buildMap[holePrimitive.type];\n    holeBuilder.build(holePrimitive, holePoints);\n    holeArrays.push(holePoints);\n  }\n  return holeArrays;\n}\nexport { buildContextBatches };","map":{"version":3,"names":["buildMap","rectangle","buildRectangle","polygon","buildPolygon","triangle","buildTriangle","circle","buildCircle","ellipse","roundedRectangle","tempRect","Rectangle","buildContextBatches","context","gpuContext","geometryData","batches","length","indices","vertices","uvs","i","instructions","instruction","action","addTextureToGeometryData","data","isStroke","shapePath","path","style","hole","addShapePathToGeometryData","indexOffset","vertOffset","points","build","rect","texture","image","x","dx","y","dy","width","dw","height","dh","matrix","transform","transformVertices","triangulate","textureUvs","push","x0","y0","x1","y1","x3","y3","x2","y2","graphicsBatch","BigPool","get","BatchableGraphics","indexSize","vertexOffset","vertexSize","color","alpha","lastIndex","shapePrimitives","forEach","shape","type","console","warn","holeIndices","otherPoints","slice","holeArrays","getHoleArrays","holePoints","triangulateWithHoles","close","closePath","lineStyle","buildLine","uvsOffset","Texture","WHITE","textureMatrix","append","clone","invert","buildUvs","buildSimpleUvs","holePrimitives","k","holePrimitive","holeBuilder"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/graphics/shared/utils/buildContextBatches.ts"],"sourcesContent":["import { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { BigPool } from '../../../../utils/pool/PoolGroup';\nimport { BatchableGraphics } from '../BatchableGraphics';\nimport { buildCircle } from '../buildCommands/buildCircle';\nimport { buildLine } from '../buildCommands/buildLine';\nimport { buildPolygon } from '../buildCommands/buildPolygon';\nimport { buildRectangle } from '../buildCommands/buildRectangle';\nimport { buildTriangle } from '../buildCommands/buildTriangle';\nimport { triangulateWithHoles } from './triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { ShapeBuildCommand } from '../buildCommands/ShapeBuildCommand';\nimport type { ConvertedFillStyle, GraphicsContext, TextureInstruction } from '../GraphicsContext';\nimport type { GpuGraphicsContext } from '../GraphicsContextSystem';\nimport type { GraphicsPath } from '../path/GraphicsPath';\nimport type { ShapePath } from '../path/ShapePath';\n\nconst buildMap: Record<string, ShapeBuildCommand> = {\n    rectangle: buildRectangle,\n    polygon: buildPolygon,\n    triangle: buildTriangle,\n    circle: buildCircle,\n    ellipse: buildCircle,\n    roundedRectangle: buildCircle,\n};\n\nconst tempRect = new Rectangle();\n\nexport function buildContextBatches(context: GraphicsContext, gpuContext: GpuGraphicsContext)\n{\n    const { geometryData, batches } = gpuContext;\n\n    // reset them..\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n\n    for (let i = 0; i < context.instructions.length; i++)\n    {\n        const instruction = context.instructions[i];\n\n        if (instruction.action === 'texture')\n        {\n            // add a quad!\n            addTextureToGeometryData(instruction.data, batches, geometryData);\n        }\n        else if (instruction.action === 'fill' || instruction.action === 'stroke')\n        {\n            const isStroke = instruction.action === 'stroke';\n\n            // build path collection of polys and shapes points..\n            const shapePath = instruction.data.path.shapePath;\n\n            const style = instruction.data.style;\n\n            const hole = instruction.data.hole;\n\n            if (isStroke && hole)\n            {\n                addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n            }\n\n            addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n        }\n    }\n}\n\nfunction addTextureToGeometryData(\n    data: TextureInstruction['data'],\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n\n    const points: number[] = [];\n\n    const build = buildMap.rectangle;\n\n    const rect = tempRect;\n\n    const texture = data.image;\n\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n\n    const matrix = data.transform;\n\n    // TODO - this can be cached...\n    build.build(rect, points);\n\n    if (matrix)\n    {\n        transformVertices(points, matrix);\n    }\n\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n    const textureUvs = texture.uvs;\n\n    uvs.push(\n        textureUvs.x0, textureUvs.y0,\n        textureUvs.x1, textureUvs.y1,\n        textureUvs.x3, textureUvs.y3,\n        textureUvs.x2, textureUvs.y2,\n    );\n\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n\n    graphicsBatch.vertexOffset = vertOffset;\n    graphicsBatch.vertexSize = (vertices.length / 2) - vertOffset;\n\n    graphicsBatch.color = data.style;\n    graphicsBatch.alpha = data.alpha;\n\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n\n    batches.push(graphicsBatch);\n}\n\nfunction addShapePathToGeometryData(\n    shapePath: ShapePath,\n    style: ConvertedFillStyle,\n    hole: GraphicsPath,\n    isStroke: boolean,\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n    const lastIndex = shapePath.shapePrimitives.length - 1;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) =>\n    {\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n\n        const points: number[] = [];\n\n        const build = buildMap[shape.type];\n\n        // TODO - this can be cached...\n        // TODO - THIS IS DONE TWICE!!!!!!\n        // ONCE FOR STROKE AND ONCE FOR FILL\n        // move to the ShapePath2D class itself?\n        build.build(shape, points);\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        if (!isStroke)\n        {\n            if (hole && lastIndex === i)\n            {\n                if (lastIndex !== 0)\n                {\n                    console.warn('[Pixi Graphics] only the last shape have be cut out');\n                }\n\n                const holeIndices: number[] = [];\n\n                const otherPoints = points.slice();\n\n                const holeArrays = getHoleArrays(hole.shapePath);\n\n                holeArrays.forEach((holePoints) =>\n                {\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n\n                triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            }\n            else\n            {\n                build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n            }\n        }\n        else\n        {\n            const close = (shape as Polygon).closePath ?? true;\n            const lineStyle = style;\n\n            buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n        }\n\n        const uvsOffset = uvs.length / 2;\n\n        const texture = style.texture;\n\n        if (texture !== Texture.WHITE)\n        {\n            const textureMatrix = style.matrix;\n\n            if (matrix)\n            {\n                // todo can prolly do this before calculating uvs..\n                textureMatrix.append(matrix.clone().invert());\n            }\n\n            buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n\n        const graphicsBatch = BigPool.get(BatchableGraphics);\n\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n\n        graphicsBatch.vertexOffset = vertOffset;\n        graphicsBatch.vertexSize = (vertices.length / 2) - vertOffset;\n\n        graphicsBatch.color = style.color as number;\n        graphicsBatch.alpha = style.alpha;\n\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n\n        batches.push(graphicsBatch);\n    });\n}\n\nfunction getHoleArrays(shape: ShapePath)\n{\n    if (!shape) return [];\n\n    const holePrimitives = shape.shapePrimitives;\n\n    const holeArrays = [];\n\n    for (let k = 0; k < holePrimitives.length; k++)\n    {\n        const holePrimitive = holePrimitives[k].shape;\n\n        // TODO - need to transform the points via there transform here..\n        const holePoints: number[] = [];\n\n        const holeBuilder = buildMap[holePrimitive.type] as ShapeBuildCommand;\n\n        holeBuilder.build(holePrimitive, holePoints);\n\n        holeArrays.push(holePoints);\n    }\n\n    return holeArrays;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}