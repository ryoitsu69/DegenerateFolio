{"ast":null,"code":"import { isNumber, isUndefined, objectSpread, stringify } from '@polkadot/util';\nimport { TypeDefInfo } from '../types/index.js';\nconst stringIdentity = value => value.toString();\nconst INFO_WRAP = ['BTreeMap', 'BTreeSet', 'Compact', 'HashMap', 'Option', 'Result', 'Vec'];\nexport function paramsNotation(outer, inner, transform = stringIdentity) {\n  return `${outer}${inner ? `<${(Array.isArray(inner) ? inner : [inner]).map(transform).join(', ')}>` : ''}`;\n}\nfunction encodeWithParams(registry, typeDef, outer) {\n  const {\n    info,\n    sub\n  } = typeDef;\n  switch (info) {\n    case TypeDefInfo.BTreeMap:\n    case TypeDefInfo.BTreeSet:\n    case TypeDefInfo.Compact:\n    case TypeDefInfo.HashMap:\n    case TypeDefInfo.Linkage:\n    case TypeDefInfo.Option:\n    case TypeDefInfo.Range:\n    case TypeDefInfo.RangeInclusive:\n    case TypeDefInfo.Result:\n    case TypeDefInfo.Vec:\n    case TypeDefInfo.WrapperKeepOpaque:\n    case TypeDefInfo.WrapperOpaque:\n      return paramsNotation(outer, sub, p => encodeTypeDef(registry, p));\n  }\n  throw new Error(`Unable to encode ${stringify(typeDef)} with params`);\n}\nfunction encodeSubTypes(registry, sub, asEnum, extra) {\n  const names = sub.map(({\n    name\n  }) => name);\n  if (!names.every(n => !!n)) {\n    throw new Error(`Subtypes does not have consistent names, ${names.join(', ')}`);\n  }\n  const inner = objectSpread({}, extra);\n  for (let i = 0, count = sub.length; i < count; i++) {\n    const def = sub[i];\n    if (!def.name) {\n      throw new Error(`No name found in ${stringify(def)}`);\n    }\n    inner[def.name] = encodeTypeDef(registry, def);\n  }\n  return stringify(asEnum ? {\n    _enum: inner\n  } : inner);\n}\nconst encoders = {\n  [TypeDefInfo.BTreeMap]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'BTreeMap'),\n  [TypeDefInfo.BTreeSet]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'BTreeSet'),\n  [TypeDefInfo.Compact]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Compact'),\n  [TypeDefInfo.DoNotConstruct]: (registry, {\n    displayName,\n    lookupIndex,\n    lookupName\n  }) => `DoNotConstruct<${lookupName || displayName || (isUndefined(lookupIndex) ? 'Unknown' : registry.createLookupType(lookupIndex))}>`,\n  [TypeDefInfo.Enum]: (registry, {\n    sub\n  }) => {\n    if (!Array.isArray(sub)) {\n      throw new Error('Unable to encode Enum type');\n    }\n    // c-like enums have all Null entries\n    // TODO We need to take the disciminant into account and auto-add empty entries\n    return sub.every(({\n      type\n    }) => type === 'Null') ? stringify({\n      _enum: sub.map(({\n        name\n      }, index) => `${name || `Empty${index}`}`)\n    }) : encodeSubTypes(registry, sub, true);\n  },\n  [TypeDefInfo.HashMap]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'HashMap'),\n  [TypeDefInfo.Int]: (_registry, {\n    length = 32\n  }) => `Int<${length}>`,\n  [TypeDefInfo.Linkage]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Linkage'),\n  [TypeDefInfo.Null]: (_registry, _typeDef) => 'Null',\n  [TypeDefInfo.Option]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Option'),\n  [TypeDefInfo.Plain]: (_registry, {\n    displayName,\n    type\n  }) => displayName || type,\n  [TypeDefInfo.Range]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Range'),\n  [TypeDefInfo.RangeInclusive]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'RangeInclusive'),\n  [TypeDefInfo.Result]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Result'),\n  [TypeDefInfo.Set]: (_registry, {\n    length = 8,\n    sub\n  }) => {\n    if (!Array.isArray(sub)) {\n      throw new Error('Unable to encode Set type');\n    }\n    return stringify({\n      _set: sub.reduce((all, {\n        index,\n        name\n      }, count) => objectSpread(all, {\n        [`${name || `Unknown${index || count}`}`]: index || count\n      }), {\n        _bitLength: length || 8\n      })\n    });\n  },\n  [TypeDefInfo.Si]: (_registry, {\n    lookupName,\n    type\n  }) => lookupName || type,\n  [TypeDefInfo.Struct]: (registry, {\n    alias,\n    sub\n  }) => {\n    if (!Array.isArray(sub)) {\n      throw new Error('Unable to encode Struct type');\n    }\n    return encodeSubTypes(registry, sub, false, alias ? {\n      _alias: [...alias.entries()].reduce((all, [k, v]) => objectSpread(all, {\n        [k]: v\n      }), {})\n    } : {});\n  },\n  [TypeDefInfo.Tuple]: (registry, {\n    sub\n  }) => {\n    if (!Array.isArray(sub)) {\n      throw new Error('Unable to encode Tuple type');\n    }\n    return `(${sub.map(type => encodeTypeDef(registry, type)).join(',')})`;\n  },\n  [TypeDefInfo.UInt]: (_registry, {\n    length = 32\n  }) => `UInt<${length}>`,\n  [TypeDefInfo.Vec]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Vec'),\n  [TypeDefInfo.VecFixed]: (_registry, {\n    length,\n    sub\n  }) => {\n    if (!isNumber(length) || !sub || Array.isArray(sub)) {\n      throw new Error('Unable to encode VecFixed type');\n    }\n    return `[${sub.type};${length}]`;\n  },\n  [TypeDefInfo.WrapperKeepOpaque]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'WrapperKeepOpaque'),\n  [TypeDefInfo.WrapperOpaque]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'WrapperOpaque')\n};\nfunction encodeType(registry, typeDef, withLookup = true) {\n  return withLookup && typeDef.lookupName ? typeDef.lookupName : encoders[typeDef.info](registry, typeDef);\n}\nexport function encodeTypeDef(registry, typeDef) {\n  // In the case of contracts we do have the unfortunate situation where the displayName would\n  // refer to \"Option\" when it is an option. For these, string it out, only using when actually\n  // not a top-level element to be used\n  return typeDef.displayName && !INFO_WRAP.some(i => typeDef.displayName === i) ? typeDef.displayName : encodeType(registry, typeDef);\n}\nexport function withTypeString(registry, typeDef) {\n  return objectSpread({}, typeDef, {\n    type: encodeType(registry, typeDef, false)\n  });\n}","map":{"version":3,"names":["isNumber","isUndefined","objectSpread","stringify","TypeDefInfo","stringIdentity","value","toString","INFO_WRAP","paramsNotation","outer","inner","transform","Array","isArray","map","join","encodeWithParams","registry","typeDef","info","sub","BTreeMap","BTreeSet","Compact","HashMap","Linkage","Option","Range","RangeInclusive","Result","Vec","WrapperKeepOpaque","WrapperOpaque","p","encodeTypeDef","Error","encodeSubTypes","asEnum","extra","names","name","every","n","i","count","length","def","_enum","encoders","DoNotConstruct","displayName","lookupIndex","lookupName","createLookupType","Enum","type","index","Int","_registry","Null","_typeDef","Plain","Set","_set","reduce","all","_bitLength","Si","Struct","alias","_alias","entries","k","v","Tuple","UInt","VecFixed","encodeType","withLookup","some","withTypeString"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-create/util/encodeTypes.js"],"sourcesContent":["import { isNumber, isUndefined, objectSpread, stringify } from '@polkadot/util';\nimport { TypeDefInfo } from '../types/index.js';\nconst stringIdentity = (value) => value.toString();\nconst INFO_WRAP = ['BTreeMap', 'BTreeSet', 'Compact', 'HashMap', 'Option', 'Result', 'Vec'];\nexport function paramsNotation(outer, inner, transform = stringIdentity) {\n    return `${outer}${inner\n        ? `<${(Array.isArray(inner) ? inner : [inner]).map(transform).join(', ')}>`\n        : ''}`;\n}\nfunction encodeWithParams(registry, typeDef, outer) {\n    const { info, sub } = typeDef;\n    switch (info) {\n        case TypeDefInfo.BTreeMap:\n        case TypeDefInfo.BTreeSet:\n        case TypeDefInfo.Compact:\n        case TypeDefInfo.HashMap:\n        case TypeDefInfo.Linkage:\n        case TypeDefInfo.Option:\n        case TypeDefInfo.Range:\n        case TypeDefInfo.RangeInclusive:\n        case TypeDefInfo.Result:\n        case TypeDefInfo.Vec:\n        case TypeDefInfo.WrapperKeepOpaque:\n        case TypeDefInfo.WrapperOpaque:\n            return paramsNotation(outer, sub, (p) => encodeTypeDef(registry, p));\n    }\n    throw new Error(`Unable to encode ${stringify(typeDef)} with params`);\n}\nfunction encodeSubTypes(registry, sub, asEnum, extra) {\n    const names = sub.map(({ name }) => name);\n    if (!names.every((n) => !!n)) {\n        throw new Error(`Subtypes does not have consistent names, ${names.join(', ')}`);\n    }\n    const inner = objectSpread({}, extra);\n    for (let i = 0, count = sub.length; i < count; i++) {\n        const def = sub[i];\n        if (!def.name) {\n            throw new Error(`No name found in ${stringify(def)}`);\n        }\n        inner[def.name] = encodeTypeDef(registry, def);\n    }\n    return stringify(asEnum\n        ? { _enum: inner }\n        : inner);\n}\nconst encoders = {\n    [TypeDefInfo.BTreeMap]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'BTreeMap'),\n    [TypeDefInfo.BTreeSet]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'BTreeSet'),\n    [TypeDefInfo.Compact]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Compact'),\n    [TypeDefInfo.DoNotConstruct]: (registry, { displayName, lookupIndex, lookupName }) => `DoNotConstruct<${lookupName || displayName || (isUndefined(lookupIndex) ? 'Unknown' : registry.createLookupType(lookupIndex))}>`,\n    [TypeDefInfo.Enum]: (registry, { sub }) => {\n        if (!Array.isArray(sub)) {\n            throw new Error('Unable to encode Enum type');\n        }\n        // c-like enums have all Null entries\n        // TODO We need to take the disciminant into account and auto-add empty entries\n        return sub.every(({ type }) => type === 'Null')\n            ? stringify({ _enum: sub.map(({ name }, index) => `${name || `Empty${index}`}`) })\n            : encodeSubTypes(registry, sub, true);\n    },\n    [TypeDefInfo.HashMap]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'HashMap'),\n    [TypeDefInfo.Int]: (_registry, { length = 32 }) => `Int<${length}>`,\n    [TypeDefInfo.Linkage]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Linkage'),\n    [TypeDefInfo.Null]: (_registry, _typeDef) => 'Null',\n    [TypeDefInfo.Option]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Option'),\n    [TypeDefInfo.Plain]: (_registry, { displayName, type }) => displayName || type,\n    [TypeDefInfo.Range]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Range'),\n    [TypeDefInfo.RangeInclusive]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'RangeInclusive'),\n    [TypeDefInfo.Result]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Result'),\n    [TypeDefInfo.Set]: (_registry, { length = 8, sub }) => {\n        if (!Array.isArray(sub)) {\n            throw new Error('Unable to encode Set type');\n        }\n        return stringify({\n            _set: sub.reduce((all, { index, name }, count) => objectSpread(all, { [`${name || `Unknown${index || count}`}`]: index || count }), { _bitLength: length || 8 })\n        });\n    },\n    [TypeDefInfo.Si]: (_registry, { lookupName, type }) => lookupName || type,\n    [TypeDefInfo.Struct]: (registry, { alias, sub }) => {\n        if (!Array.isArray(sub)) {\n            throw new Error('Unable to encode Struct type');\n        }\n        return encodeSubTypes(registry, sub, false, alias\n            ? {\n                _alias: [...alias.entries()].reduce((all, [k, v]) => objectSpread(all, { [k]: v }), {})\n            }\n            : {});\n    },\n    [TypeDefInfo.Tuple]: (registry, { sub }) => {\n        if (!Array.isArray(sub)) {\n            throw new Error('Unable to encode Tuple type');\n        }\n        return `(${sub.map((type) => encodeTypeDef(registry, type)).join(',')})`;\n    },\n    [TypeDefInfo.UInt]: (_registry, { length = 32 }) => `UInt<${length}>`,\n    [TypeDefInfo.Vec]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Vec'),\n    [TypeDefInfo.VecFixed]: (_registry, { length, sub }) => {\n        if (!isNumber(length) || !sub || Array.isArray(sub)) {\n            throw new Error('Unable to encode VecFixed type');\n        }\n        return `[${sub.type};${length}]`;\n    },\n    [TypeDefInfo.WrapperKeepOpaque]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'WrapperKeepOpaque'),\n    [TypeDefInfo.WrapperOpaque]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'WrapperOpaque')\n};\nfunction encodeType(registry, typeDef, withLookup = true) {\n    return withLookup && typeDef.lookupName\n        ? typeDef.lookupName\n        : encoders[typeDef.info](registry, typeDef);\n}\nexport function encodeTypeDef(registry, typeDef) {\n    // In the case of contracts we do have the unfortunate situation where the displayName would\n    // refer to \"Option\" when it is an option. For these, string it out, only using when actually\n    // not a top-level element to be used\n    return (typeDef.displayName && !INFO_WRAP.some((i) => typeDef.displayName === i))\n        ? typeDef.displayName\n        : encodeType(registry, typeDef);\n}\nexport function withTypeString(registry, typeDef) {\n    return objectSpread({}, typeDef, {\n        type: encodeType(registry, typeDef, false)\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}