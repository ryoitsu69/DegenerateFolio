{"ast":null,"code":"import { bnToBn, isBigInt, isBn, isBoolean, isCodec, isNumber, stringify } from '@polkadot/util';\n/** @internal **/\nfunction isArrayLike(arg) {\n  return arg instanceof Uint8Array || Array.isArray(arg);\n}\n/** @internal **/\nfunction isEnum(arg) {\n  return isCodec(arg) && isNumber(arg.index) && isCodec(arg.value);\n}\n/** @internal **/\nfunction isOption(arg) {\n  return isCodec(arg) && isBoolean(arg.isSome) && isCodec(arg.value);\n}\n/** @internal */\nfunction isNumberLike(arg) {\n  return isNumber(arg) || isBn(arg) || isBigInt(arg);\n}\n/** @internal */\nfunction sortArray(a, b) {\n  // Vec, Tuple, Bytes etc.\n  let sortRes = 0;\n  const minLen = Math.min(a.length, b.length);\n  for (let i = 0; i < minLen; ++i) {\n    sortRes = sortAsc(a[i], b[i]);\n    if (sortRes !== 0) {\n      return sortRes;\n    }\n  }\n  return a.length - b.length;\n}\n/** @internal */\nfunction checkForDuplicates(container, seen, arg) {\n  // Convert the value to hex.\n  if (isCodec(arg)) {\n    const hex = arg.toHex();\n    // Check if we have seen the value.\n    if (seen.has(hex)) {\n      // Duplicates are not allowed.\n      throw new Error(`Duplicate value in ${container}: ${stringify(arg)}`);\n    }\n    seen.add(hex);\n  }\n  return true;\n}\n/**\n* Sort keys/values of BTreeSet/BTreeMap in ascending order for encoding compatibility with Rust's BTreeSet/BTreeMap\n* (https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html)\n* (https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html)\n*/\nexport function sortAsc(a, b) {\n  if (isNumberLike(a) && isNumberLike(b)) {\n    return bnToBn(a).cmp(bnToBn(b));\n  } else if (a instanceof Map && b instanceof Map) {\n    return sortAsc(Array.from(a.values()), Array.from(b.values()));\n  } else if (isEnum(a) && isEnum(b)) {\n    return sortAsc(a.index, b.index) || sortAsc(a.value, b.value);\n  } else if (isOption(a) && isOption(b)) {\n    return sortAsc(a.isNone ? 0 : 1, b.isNone ? 0 : 1) || sortAsc(a.value, b.value);\n  } else if (isArrayLike(a) && isArrayLike(b)) {\n    return sortArray(a, b);\n  } else if (isCodec(a) && isCodec(b)) {\n    // Text, Bool etc.\n    return sortAsc(a.toU8a(true), b.toU8a(true));\n  }\n  throw new Error(`Attempting to sort unrecognized values: ${stringify(a)} (typeof ${typeof a}) <-> ${stringify(b)} (typeof ${typeof b})`);\n}\nexport function sortSet(set) {\n  const seen = new Set();\n  return new Set(Array.from(set).filter(value => checkForDuplicates('BTreeSet', seen, value)).sort(sortAsc));\n}\nexport function sortMap(map) {\n  const seen = new Set();\n  return new Map(Array.from(map.entries()).filter(([key]) => checkForDuplicates('BTreeMap', seen, key)).sort(([keyA], [keyB]) => sortAsc(keyA, keyB)));\n}","map":{"version":3,"names":["bnToBn","isBigInt","isBn","isBoolean","isCodec","isNumber","stringify","isArrayLike","arg","Uint8Array","Array","isArray","isEnum","index","value","isOption","isSome","isNumberLike","sortArray","a","b","sortRes","minLen","Math","min","length","i","sortAsc","checkForDuplicates","container","seen","hex","toHex","has","Error","add","cmp","Map","from","values","isNone","toU8a","sortSet","set","Set","filter","sort","sortMap","map","entries","key","keyA","keyB"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/utils/sortValues.js"],"sourcesContent":["import { bnToBn, isBigInt, isBn, isBoolean, isCodec, isNumber, stringify } from '@polkadot/util';\n/** @internal **/\nfunction isArrayLike(arg) {\n    return arg instanceof Uint8Array || Array.isArray(arg);\n}\n/** @internal **/\nfunction isEnum(arg) {\n    return isCodec(arg) && isNumber(arg.index) && isCodec(arg.value);\n}\n/** @internal **/\nfunction isOption(arg) {\n    return isCodec(arg) && isBoolean(arg.isSome) && isCodec(arg.value);\n}\n/** @internal */\nfunction isNumberLike(arg) {\n    return isNumber(arg) || isBn(arg) || isBigInt(arg);\n}\n/** @internal */\nfunction sortArray(a, b) {\n    // Vec, Tuple, Bytes etc.\n    let sortRes = 0;\n    const minLen = Math.min(a.length, b.length);\n    for (let i = 0; i < minLen; ++i) {\n        sortRes = sortAsc(a[i], b[i]);\n        if (sortRes !== 0) {\n            return sortRes;\n        }\n    }\n    return a.length - b.length;\n}\n/** @internal */\nfunction checkForDuplicates(container, seen, arg) {\n    // Convert the value to hex.\n    if (isCodec(arg)) {\n        const hex = arg.toHex();\n        // Check if we have seen the value.\n        if (seen.has(hex)) {\n            // Duplicates are not allowed.\n            throw new Error(`Duplicate value in ${container}: ${stringify(arg)}`);\n        }\n        seen.add(hex);\n    }\n    return true;\n}\n/**\n* Sort keys/values of BTreeSet/BTreeMap in ascending order for encoding compatibility with Rust's BTreeSet/BTreeMap\n* (https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html)\n* (https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html)\n*/\nexport function sortAsc(a, b) {\n    if (isNumberLike(a) && isNumberLike(b)) {\n        return bnToBn(a).cmp(bnToBn(b));\n    }\n    else if (a instanceof Map && b instanceof Map) {\n        return sortAsc(Array.from(a.values()), Array.from(b.values()));\n    }\n    else if (isEnum(a) && isEnum(b)) {\n        return sortAsc(a.index, b.index) || sortAsc(a.value, b.value);\n    }\n    else if (isOption(a) && isOption(b)) {\n        return sortAsc(a.isNone ? 0 : 1, b.isNone ? 0 : 1) || sortAsc(a.value, b.value);\n    }\n    else if (isArrayLike(a) && isArrayLike(b)) {\n        return sortArray(a, b);\n    }\n    else if (isCodec(a) && isCodec(b)) {\n        // Text, Bool etc.\n        return sortAsc(a.toU8a(true), b.toU8a(true));\n    }\n    throw new Error(`Attempting to sort unrecognized values: ${stringify(a)} (typeof ${typeof a}) <-> ${stringify(b)} (typeof ${typeof b})`);\n}\nexport function sortSet(set) {\n    const seen = new Set();\n    return new Set(Array.from(set).filter((value) => checkForDuplicates('BTreeSet', seen, value)).sort(sortAsc));\n}\nexport function sortMap(map) {\n    const seen = new Set();\n    return new Map(Array.from(map.entries()).filter(([key]) => checkForDuplicates('BTreeMap', seen, key)).sort(([keyA], [keyB]) => sortAsc(keyA, keyB)));\n}\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,SAAS,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,SAAS,QAAQ,gBAAgB;AAChG;AACA,SAASC,WAAWA,CAACC,GAAG,EAAE;EACtB,OAAOA,GAAG,YAAYC,UAAU,IAAIC,KAAK,CAACC,OAAO,CAACH,GAAG,CAAC;AAC1D;AACA;AACA,SAASI,MAAMA,CAACJ,GAAG,EAAE;EACjB,OAAOJ,OAAO,CAACI,GAAG,CAAC,IAAIH,QAAQ,CAACG,GAAG,CAACK,KAAK,CAAC,IAAIT,OAAO,CAACI,GAAG,CAACM,KAAK,CAAC;AACpE;AACA;AACA,SAASC,QAAQA,CAACP,GAAG,EAAE;EACnB,OAAOJ,OAAO,CAACI,GAAG,CAAC,IAAIL,SAAS,CAACK,GAAG,CAACQ,MAAM,CAAC,IAAIZ,OAAO,CAACI,GAAG,CAACM,KAAK,CAAC;AACtE;AACA;AACA,SAASG,YAAYA,CAACT,GAAG,EAAE;EACvB,OAAOH,QAAQ,CAACG,GAAG,CAAC,IAAIN,IAAI,CAACM,GAAG,CAAC,IAAIP,QAAQ,CAACO,GAAG,CAAC;AACtD;AACA;AACA,SAASU,SAASA,CAACC,CAAC,EAAEC,CAAC,EAAE;EACrB;EACA,IAAIC,OAAO,GAAG,CAAC;EACf,MAAMC,MAAM,GAAGC,IAAI,CAACC,GAAG,CAACL,CAAC,CAACM,MAAM,EAAEL,CAAC,CAACK,MAAM,CAAC;EAC3C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,MAAM,EAAE,EAAEI,CAAC,EAAE;IAC7BL,OAAO,GAAGM,OAAO,CAACR,CAAC,CAACO,CAAC,CAAC,EAAEN,CAAC,CAACM,CAAC,CAAC,CAAC;IAC7B,IAAIL,OAAO,KAAK,CAAC,EAAE;MACf,OAAOA,OAAO;IAClB;EACJ;EACA,OAAOF,CAAC,CAACM,MAAM,GAAGL,CAAC,CAACK,MAAM;AAC9B;AACA;AACA,SAASG,kBAAkBA,CAACC,SAAS,EAAEC,IAAI,EAAEtB,GAAG,EAAE;EAC9C;EACA,IAAIJ,OAAO,CAACI,GAAG,CAAC,EAAE;IACd,MAAMuB,GAAG,GAAGvB,GAAG,CAACwB,KAAK,CAAC,CAAC;IACvB;IACA,IAAIF,IAAI,CAACG,GAAG,CAACF,GAAG,CAAC,EAAE;MACf;MACA,MAAM,IAAIG,KAAK,CAAE,sBAAqBL,SAAU,KAAIvB,SAAS,CAACE,GAAG,CAAE,EAAC,CAAC;IACzE;IACAsB,IAAI,CAACK,GAAG,CAACJ,GAAG,CAAC;EACjB;EACA,OAAO,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASJ,OAAOA,CAACR,CAAC,EAAEC,CAAC,EAAE;EAC1B,IAAIH,YAAY,CAACE,CAAC,CAAC,IAAIF,YAAY,CAACG,CAAC,CAAC,EAAE;IACpC,OAAOpB,MAAM,CAACmB,CAAC,CAAC,CAACiB,GAAG,CAACpC,MAAM,CAACoB,CAAC,CAAC,CAAC;EACnC,CAAC,MACI,IAAID,CAAC,YAAYkB,GAAG,IAAIjB,CAAC,YAAYiB,GAAG,EAAE;IAC3C,OAAOV,OAAO,CAACjB,KAAK,CAAC4B,IAAI,CAACnB,CAAC,CAACoB,MAAM,CAAC,CAAC,CAAC,EAAE7B,KAAK,CAAC4B,IAAI,CAAClB,CAAC,CAACmB,MAAM,CAAC,CAAC,CAAC,CAAC;EAClE,CAAC,MACI,IAAI3B,MAAM,CAACO,CAAC,CAAC,IAAIP,MAAM,CAACQ,CAAC,CAAC,EAAE;IAC7B,OAAOO,OAAO,CAACR,CAAC,CAACN,KAAK,EAAEO,CAAC,CAACP,KAAK,CAAC,IAAIc,OAAO,CAACR,CAAC,CAACL,KAAK,EAAEM,CAAC,CAACN,KAAK,CAAC;EACjE,CAAC,MACI,IAAIC,QAAQ,CAACI,CAAC,CAAC,IAAIJ,QAAQ,CAACK,CAAC,CAAC,EAAE;IACjC,OAAOO,OAAO,CAACR,CAAC,CAACqB,MAAM,GAAG,CAAC,GAAG,CAAC,EAAEpB,CAAC,CAACoB,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC,IAAIb,OAAO,CAACR,CAAC,CAACL,KAAK,EAAEM,CAAC,CAACN,KAAK,CAAC;EACnF,CAAC,MACI,IAAIP,WAAW,CAACY,CAAC,CAAC,IAAIZ,WAAW,CAACa,CAAC,CAAC,EAAE;IACvC,OAAOF,SAAS,CAACC,CAAC,EAAEC,CAAC,CAAC;EAC1B,CAAC,MACI,IAAIhB,OAAO,CAACe,CAAC,CAAC,IAAIf,OAAO,CAACgB,CAAC,CAAC,EAAE;IAC/B;IACA,OAAOO,OAAO,CAACR,CAAC,CAACsB,KAAK,CAAC,IAAI,CAAC,EAAErB,CAAC,CAACqB,KAAK,CAAC,IAAI,CAAC,CAAC;EAChD;EACA,MAAM,IAAIP,KAAK,CAAE,2CAA0C5B,SAAS,CAACa,CAAC,CAAE,YAAW,OAAOA,CAAE,SAAQb,SAAS,CAACc,CAAC,CAAE,YAAW,OAAOA,CAAE,GAAE,CAAC;AAC5I;AACA,OAAO,SAASsB,OAAOA,CAACC,GAAG,EAAE;EACzB,MAAMb,IAAI,GAAG,IAAIc,GAAG,CAAC,CAAC;EACtB,OAAO,IAAIA,GAAG,CAAClC,KAAK,CAAC4B,IAAI,CAACK,GAAG,CAAC,CAACE,MAAM,CAAE/B,KAAK,IAAKc,kBAAkB,CAAC,UAAU,EAAEE,IAAI,EAAEhB,KAAK,CAAC,CAAC,CAACgC,IAAI,CAACnB,OAAO,CAAC,CAAC;AAChH;AACA,OAAO,SAASoB,OAAOA,CAACC,GAAG,EAAE;EACzB,MAAMlB,IAAI,GAAG,IAAIc,GAAG,CAAC,CAAC;EACtB,OAAO,IAAIP,GAAG,CAAC3B,KAAK,CAAC4B,IAAI,CAACU,GAAG,CAACC,OAAO,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC,CAAC,CAACK,GAAG,CAAC,KAAKtB,kBAAkB,CAAC,UAAU,EAAEE,IAAI,EAAEoB,GAAG,CAAC,CAAC,CAACJ,IAAI,CAAC,CAAC,CAACK,IAAI,CAAC,EAAE,CAACC,IAAI,CAAC,KAAKzB,OAAO,CAACwB,IAAI,EAAEC,IAAI,CAAC,CAAC,CAAC;AACxJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}