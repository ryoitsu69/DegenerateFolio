{"ast":null,"code":"import { Option } from '@polkadot/types-codec';\nimport { isHex, isU8a, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { createClassUnsafe } from './class.js';\nfunction checkInstance(created, matcher) {\n  const u8a = created.toU8a();\n  const rawType = created.toRawType();\n  const isOk =\n  // full match, all ok\n  u8aEq(u8a, matcher) ||\n  // on a length-prefixed type, just check the actual length\n  ['Bytes', 'Text', 'Type'].includes(rawType) && matcher.length === created.length ||\n  // when the created is empty and matcher is also empty, let it slide...\n  created.isEmpty && matcher.every(v => !v);\n  if (!isOk) {\n    throw new Error(`${rawType}:: Decoded input doesn't match input, received ${u8aToHex(matcher, 512)} (${matcher.length} bytes), created ${u8aToHex(u8a, 512)} (${u8a.length} bytes)`);\n  }\n}\nfunction checkPedantic(created, [value]) {\n  if (isU8a(value)) {\n    checkInstance(created, value);\n  } else if (isHex(value)) {\n    checkInstance(created, u8aToU8a(value));\n  }\n}\nfunction initType(registry, Type, params = [], {\n  blockHash,\n  isFallback,\n  isOptional,\n  isPedantic\n} = {}) {\n  const created = new (isOptional ? Option.with(Type) : Type)(registry, ...params);\n  isPedantic && checkPedantic(created, params);\n  if (blockHash) {\n    created.createdAtHash = createTypeUnsafe(registry, 'BlockHash', [blockHash]);\n  }\n  if (isFallback) {\n    created.isStorageFallback = true;\n  }\n  return created;\n}\nexport function createTypeUnsafe(registry, type, params = [], options = {}) {\n  let Clazz = null;\n  let firstError = null;\n  try {\n    Clazz = createClassUnsafe(registry, type);\n    return initType(registry, Clazz, params, options);\n  } catch (error) {\n    firstError = new Error(`createType(${type}):: ${error.message}`);\n  }\n  if (Clazz?.__fallbackType) {\n    try {\n      Clazz = createClassUnsafe(registry, Clazz.__fallbackType);\n      return initType(registry, Clazz, params, options);\n    } catch {\n      // swallow, we will throw the first error again\n    }\n  }\n  throw firstError;\n}","map":{"version":3,"names":["Option","isHex","isU8a","u8aEq","u8aToHex","u8aToU8a","createClassUnsafe","checkInstance","created","matcher","u8a","toU8a","rawType","toRawType","isOk","includes","length","isEmpty","every","v","Error","checkPedantic","value","initType","registry","Type","params","blockHash","isFallback","isOptional","isPedantic","with","createdAtHash","createTypeUnsafe","isStorageFallback","type","options","Clazz","firstError","error","message","__fallbackType"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-create/create/type.js"],"sourcesContent":["import { Option } from '@polkadot/types-codec';\nimport { isHex, isU8a, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { createClassUnsafe } from './class.js';\nfunction checkInstance(created, matcher) {\n    const u8a = created.toU8a();\n    const rawType = created.toRawType();\n    const isOk = (\n    // full match, all ok\n    u8aEq(u8a, matcher) ||\n        (\n        // on a length-prefixed type, just check the actual length\n        ['Bytes', 'Text', 'Type'].includes(rawType) &&\n            matcher.length === created.length) ||\n        (\n        // when the created is empty and matcher is also empty, let it slide...\n        created.isEmpty &&\n            matcher.every((v) => !v)));\n    if (!isOk) {\n        throw new Error(`${rawType}:: Decoded input doesn't match input, received ${u8aToHex(matcher, 512)} (${matcher.length} bytes), created ${u8aToHex(u8a, 512)} (${u8a.length} bytes)`);\n    }\n}\nfunction checkPedantic(created, [value]) {\n    if (isU8a(value)) {\n        checkInstance(created, value);\n    }\n    else if (isHex(value)) {\n        checkInstance(created, u8aToU8a(value));\n    }\n}\nfunction initType(registry, Type, params = [], { blockHash, isFallback, isOptional, isPedantic } = {}) {\n    const created = new (isOptional\n        ? Option.with(Type)\n        : Type)(registry, ...params);\n    isPedantic && checkPedantic(created, params);\n    if (blockHash) {\n        created.createdAtHash = createTypeUnsafe(registry, 'BlockHash', [blockHash]);\n    }\n    if (isFallback) {\n        created.isStorageFallback = true;\n    }\n    return created;\n}\nexport function createTypeUnsafe(registry, type, params = [], options = {}) {\n    let Clazz = null;\n    let firstError = null;\n    try {\n        Clazz = createClassUnsafe(registry, type);\n        return initType(registry, Clazz, params, options);\n    }\n    catch (error) {\n        firstError = new Error(`createType(${type}):: ${error.message}`);\n    }\n    if (Clazz?.__fallbackType) {\n        try {\n            Clazz = createClassUnsafe(registry, Clazz.__fallbackType);\n            return initType(registry, Clazz, params, options);\n        }\n        catch {\n            // swallow, we will throw the first error again\n        }\n    }\n    throw firstError;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}