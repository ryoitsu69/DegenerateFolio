{"ast":null,"code":"const BOUNDED = ['BTreeMap', 'BTreeSet', 'HashMap', 'Vec'];\nconst ALLOWED_BOXES = BOUNDED.concat(['Compact', 'DoNotConstruct', 'Int', 'Linkage', 'Range', 'RangeInclusive', 'Result', 'Opaque', 'Option', 'UInt', 'WrapperKeepOpaque', 'WrapperOpaque']);\nconst BOX_PRECEDING = ['<', '(', '[', '\"', ',', ' ']; // start of vec, tuple, fixed array, part of struct def or in tuple\nconst mappings = [\n// alias <T::InherentOfflineReport as InherentOfflineReport>::Inherent -> InherentOfflineReport\nalias('<T::InherentOfflineReport as InherentOfflineReport>::Inherent', 'InherentOfflineReport', false), alias('VecDeque<', 'Vec<', false),\n// <T::Balance as HasCompact>\ncleanupCompact(),\n// Change BoundedVec<Type, Size> to Vec<Type>\nremoveExtensions('Bounded', true),\n// Change WeakVec<Type> to Vec<Type>\nremoveExtensions('Weak', false),\n// Remove all the trait prefixes\nremoveTraits(),\n// remove PairOf<T> -> (T, T)\nremovePairOf(),\n// remove boxing, `Box<Proposal>` -> `Proposal`\nremoveWrap('Box<'),\n// remove generics, `MisbehaviorReport<Hash, BlockNumber>` -> `MisbehaviorReport`\nremoveGenerics(),\n// alias String -> Text (compat with jsonrpc methods)\nalias('String', 'Text'),\n// alias Vec<u8> -> Bytes\nalias('Vec<u8>', 'Bytes'), alias('&\\\\[u8\\\\]', 'Bytes'), alias(\"&'static\\\\[u8\\\\]\", 'Bytes'),\n// alias RawAddress -> Address\nalias('RawAddress', 'Address'),\n// lookups, mapped to Address/AccountId as appropriate in runtime\nalias('Lookup::Source', 'LookupSource'), alias('Lookup::Target', 'LookupTarget'),\n// HACK duplication between contracts & primitives, however contracts prefixed with exec\nalias('exec::StorageKey', 'ContractStorageKey'),\n// flattens tuples with one value, `(AccountId)` -> `AccountId`\nflattenSingleTuple(),\n// converts ::Type to Type, <T as Trait<I>>::Proposal -> Proposal\nremoveColons(),\n// remove all trailing spaces - this should always be the last\ntrim()];\nexport function trim() {\n  return value => value.trim();\n}\nexport function findClosing(value, start) {\n  let depth = 0;\n  for (let i = start, count = value.length; i < count; i++) {\n    if (value[i] === '>') {\n      if (!depth) {\n        return i;\n      }\n      depth--;\n    } else if (value[i] === '<') {\n      depth++;\n    }\n  }\n  throw new Error(\"Unable to find closing matching <> on '\".concat(value, \"' (start \").concat(start, \")\"));\n}\nexport function alias(src, dest) {\n  let withChecks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const from = new RegExp(\"(^\".concat(src, \"|\").concat(BOX_PRECEDING.map(box => \"\\\\\".concat(box).concat(src)).join('|'), \")\"), 'g');\n  const to = src => {\n    from.lastIndex = 0;\n    return withChecks && BOX_PRECEDING.includes(src[0]) ? \"\".concat(src[0]).concat(dest) : dest;\n  };\n  return value => value.replace(from, to);\n}\nexport function cleanupCompact() {\n  return value => {\n    if (value.includes(' as HasCompact')) {\n      for (let i = 0, count = value.length; i < count; i++) {\n        if (value[i] === '<') {\n          const end = findClosing(value, i + 1) - 14;\n          if (value.substring(end, end + 14) === ' as HasCompact') {\n            value = \"Compact<\".concat(value.substring(i + 1, end), \">\");\n          }\n        }\n      }\n    }\n    return value;\n  };\n}\nexport function flattenSingleTuple() {\n  const from1 = /,\\)/g;\n  const from2 = /\\(([^,]+)\\)/;\n  return value => {\n    from1.lastIndex = 0;\n    return value\n    // tuples may have trailing commas, e.g. (u32, BlockNumber, )\n    .replace(from1, ')')\n    // change (u32) -> u32\n    .replace(from2, '$1');\n  };\n}\nfunction replaceTagWith(value, matcher, replacer) {\n  let index = -1;\n  while (true) {\n    index = value.indexOf(matcher, index + 1);\n    if (index === -1) {\n      return value;\n    }\n    const start = index + matcher.length;\n    const end = findClosing(value, start);\n    value = \"\".concat(value.substring(0, index)).concat(replacer(value.substring(start, end))).concat(value.substring(end + 1));\n  }\n}\nexport function removeExtensions(type, isSized) {\n  return value => {\n    for (let i = 0, count = BOUNDED.length; i < count; i++) {\n      const tag = BOUNDED[i];\n      value = replaceTagWith(value, \"\".concat(type).concat(tag, \"<\"), v => {\n        const parts = v.split(',').map(s => s.trim()).filter(s => s);\n        if (isSized) {\n          parts.pop();\n        }\n        return \"\".concat(tag, \"<\").concat(parts.join(','), \">\");\n      });\n    }\n    return value;\n  };\n}\nexport function removeColons() {\n  return value => {\n    let index = 0;\n    while (index !== -1) {\n      index = value.indexOf('::');\n      if (index === 0) {\n        value = value.substring(2);\n      } else if (index !== -1) {\n        let start = index;\n        while (start !== -1 && !BOX_PRECEDING.includes(value[start])) {\n          start--;\n        }\n        value = \"\".concat(value.substring(0, start + 1)).concat(value.substring(index + 2));\n      }\n    }\n    return value;\n  };\n}\nexport function removeGenerics() {\n  return value => {\n    for (let i = 0, count = value.length; i < count; i++) {\n      if (value[i] === '<') {\n        // check against the allowed wrappers, be it Vec<..>, Option<...> ...\n        const box = ALLOWED_BOXES.find(box => {\n          const start = i - box.length;\n          return start >= 0 && value.substring(start, i) === box && (\n          // make sure it is stand-alone, i.e. don't catch ElectionResult<...> as Result<...>\n          start === 0 || BOX_PRECEDING.includes(value[start - 1]));\n        });\n        // we have not found anything, unwrap generic innards\n        if (!box) {\n          const end = findClosing(value, i + 1);\n          value = \"\".concat(value.substring(0, i)).concat(value.substring(end + 1));\n        }\n      }\n    }\n    return value;\n  };\n}\nexport function removePairOf() {\n  const replacer = v => \"(\".concat(v, \",\").concat(v, \")\");\n  return value => replaceTagWith(value, 'PairOf<', replacer);\n}\nexport function removeTraits() {\n  const from1 = /\\s/g;\n  const from2 = /(T|Self)::/g;\n  const from3 = /<(T|Self)asTrait>::/g;\n  const from4 = /<Tas[a-z]+::Trait>::/g;\n  const from5 = /<LookupasStaticLookup>/g;\n  const from6 = /::Type/g;\n  return value => {\n    from1.lastIndex = 0;\n    from2.lastIndex = 0;\n    from3.lastIndex = 0;\n    from4.lastIndex = 0;\n    from5.lastIndex = 0;\n    from6.lastIndex = 0;\n    return value\n    // remove all whitespaces\n    .replace(from1, '')\n    // anything `T::<type>` to end up as `<type>`\n    .replace(from2, '')\n    // replace `<T as Trait>::` (whitespaces were removed above)\n    .replace(from3, '')\n    // replace `<T as something::Trait>::` (whitespaces were removed above)\n    .replace(from4, '')\n    // replace <Lookup as StaticLookup>\n    .replace(from5, 'Lookup')\n    // replace `<...>::Type`\n    .replace(from6, '');\n  };\n}\nexport function removeWrap(check) {\n  const replacer = v => v;\n  return value => replaceTagWith(value, check, replacer);\n}\nconst sanitizeMap = new Map();\nexport function sanitize(value) {\n  const startValue = value.toString();\n  const memoized = sanitizeMap.get(startValue);\n  if (memoized) {\n    return memoized;\n  }\n  let result = startValue;\n  for (let i = 0, count = mappings.length; i < count; i++) {\n    result = mappings[i](result);\n  }\n  sanitizeMap.set(startValue, result);\n  return result;\n}","map":{"version":3,"names":["BOUNDED","ALLOWED_BOXES","concat","BOX_PRECEDING","mappings","alias","cleanupCompact","removeExtensions","removeTraits","removePairOf","removeWrap","removeGenerics","flattenSingleTuple","removeColons","trim","value","findClosing","start","depth","i","count","length","Error","src","dest","withChecks","arguments","undefined","from","RegExp","map","box","join","to","lastIndex","includes","replace","end","substring","from1","from2","replaceTagWith","matcher","replacer","index","indexOf","type","isSized","tag","v","parts","split","s","filter","pop","find","from3","from4","from5","from6","check","sanitizeMap","Map","sanitize","startValue","toString","memoized","get","result","set"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/types-codec/utils/sanitize.js"],"sourcesContent":["const BOUNDED = ['BTreeMap', 'BTreeSet', 'HashMap', 'Vec'];\nconst ALLOWED_BOXES = BOUNDED.concat(['Compact', 'DoNotConstruct', 'Int', 'Linkage', 'Range', 'RangeInclusive', 'Result', 'Opaque', 'Option', 'UInt', 'WrapperKeepOpaque', 'WrapperOpaque']);\nconst BOX_PRECEDING = ['<', '(', '[', '\"', ',', ' ']; // start of vec, tuple, fixed array, part of struct def or in tuple\nconst mappings = [\n    // alias <T::InherentOfflineReport as InherentOfflineReport>::Inherent -> InherentOfflineReport\n    alias('<T::InherentOfflineReport as InherentOfflineReport>::Inherent', 'InherentOfflineReport', false),\n    alias('VecDeque<', 'Vec<', false),\n    // <T::Balance as HasCompact>\n    cleanupCompact(),\n    // Change BoundedVec<Type, Size> to Vec<Type>\n    removeExtensions('Bounded', true),\n    // Change WeakVec<Type> to Vec<Type>\n    removeExtensions('Weak', false),\n    // Remove all the trait prefixes\n    removeTraits(),\n    // remove PairOf<T> -> (T, T)\n    removePairOf(),\n    // remove boxing, `Box<Proposal>` -> `Proposal`\n    removeWrap('Box<'),\n    // remove generics, `MisbehaviorReport<Hash, BlockNumber>` -> `MisbehaviorReport`\n    removeGenerics(),\n    // alias String -> Text (compat with jsonrpc methods)\n    alias('String', 'Text'),\n    // alias Vec<u8> -> Bytes\n    alias('Vec<u8>', 'Bytes'),\n    alias('&\\\\[u8\\\\]', 'Bytes'),\n    alias(\"&'static\\\\[u8\\\\]\", 'Bytes'),\n    // alias RawAddress -> Address\n    alias('RawAddress', 'Address'),\n    // lookups, mapped to Address/AccountId as appropriate in runtime\n    alias('Lookup::Source', 'LookupSource'),\n    alias('Lookup::Target', 'LookupTarget'),\n    // HACK duplication between contracts & primitives, however contracts prefixed with exec\n    alias('exec::StorageKey', 'ContractStorageKey'),\n    // flattens tuples with one value, `(AccountId)` -> `AccountId`\n    flattenSingleTuple(),\n    // converts ::Type to Type, <T as Trait<I>>::Proposal -> Proposal\n    removeColons(),\n    // remove all trailing spaces - this should always be the last\n    trim()\n];\nexport function trim() {\n    return (value) => value.trim();\n}\nexport function findClosing(value, start) {\n    let depth = 0;\n    for (let i = start, count = value.length; i < count; i++) {\n        if (value[i] === '>') {\n            if (!depth) {\n                return i;\n            }\n            depth--;\n        }\n        else if (value[i] === '<') {\n            depth++;\n        }\n    }\n    throw new Error(`Unable to find closing matching <> on '${value}' (start ${start})`);\n}\nexport function alias(src, dest, withChecks = true) {\n    const from = new RegExp(`(^${src}|${BOX_PRECEDING.map((box) => `\\\\${box}${src}`).join('|')})`, 'g');\n    const to = (src) => {\n        from.lastIndex = 0;\n        return withChecks && BOX_PRECEDING.includes(src[0])\n            ? `${src[0]}${dest}`\n            : dest;\n    };\n    return (value) => value.replace(from, to);\n}\nexport function cleanupCompact() {\n    return (value) => {\n        if (value.includes(' as HasCompact')) {\n            for (let i = 0, count = value.length; i < count; i++) {\n                if (value[i] === '<') {\n                    const end = findClosing(value, i + 1) - 14;\n                    if (value.substring(end, end + 14) === ' as HasCompact') {\n                        value = `Compact<${value.substring(i + 1, end)}>`;\n                    }\n                }\n            }\n        }\n        return value;\n    };\n}\nexport function flattenSingleTuple() {\n    const from1 = /,\\)/g;\n    const from2 = /\\(([^,]+)\\)/;\n    return (value) => {\n        from1.lastIndex = 0;\n        return value\n            // tuples may have trailing commas, e.g. (u32, BlockNumber, )\n            .replace(from1, ')')\n            // change (u32) -> u32\n            .replace(from2, '$1');\n    };\n}\nfunction replaceTagWith(value, matcher, replacer) {\n    let index = -1;\n    while (true) {\n        index = value.indexOf(matcher, index + 1);\n        if (index === -1) {\n            return value;\n        }\n        const start = index + matcher.length;\n        const end = findClosing(value, start);\n        value = `${value.substring(0, index)}${replacer(value.substring(start, end))}${value.substring(end + 1)}`;\n    }\n}\nexport function removeExtensions(type, isSized) {\n    return (value) => {\n        for (let i = 0, count = BOUNDED.length; i < count; i++) {\n            const tag = BOUNDED[i];\n            value = replaceTagWith(value, `${type}${tag}<`, (v) => {\n                const parts = v\n                    .split(',')\n                    .map((s) => s.trim())\n                    .filter((s) => s);\n                if (isSized) {\n                    parts.pop();\n                }\n                return `${tag}<${parts.join(',')}>`;\n            });\n        }\n        return value;\n    };\n}\nexport function removeColons() {\n    return (value) => {\n        let index = 0;\n        while (index !== -1) {\n            index = value.indexOf('::');\n            if (index === 0) {\n                value = value.substring(2);\n            }\n            else if (index !== -1) {\n                let start = index;\n                while (start !== -1 && !BOX_PRECEDING.includes(value[start])) {\n                    start--;\n                }\n                value = `${value.substring(0, start + 1)}${value.substring(index + 2)}`;\n            }\n        }\n        return value;\n    };\n}\nexport function removeGenerics() {\n    return (value) => {\n        for (let i = 0, count = value.length; i < count; i++) {\n            if (value[i] === '<') {\n                // check against the allowed wrappers, be it Vec<..>, Option<...> ...\n                const box = ALLOWED_BOXES.find((box) => {\n                    const start = i - box.length;\n                    return ((start >= 0 &&\n                        value.substring(start, i) === box) && (\n                    // make sure it is stand-alone, i.e. don't catch ElectionResult<...> as Result<...>\n                    start === 0 ||\n                        BOX_PRECEDING.includes(value[start - 1])));\n                });\n                // we have not found anything, unwrap generic innards\n                if (!box) {\n                    const end = findClosing(value, i + 1);\n                    value = `${value.substring(0, i)}${value.substring(end + 1)}`;\n                }\n            }\n        }\n        return value;\n    };\n}\nexport function removePairOf() {\n    const replacer = (v) => `(${v},${v})`;\n    return (value) => replaceTagWith(value, 'PairOf<', replacer);\n}\nexport function removeTraits() {\n    const from1 = /\\s/g;\n    const from2 = /(T|Self)::/g;\n    const from3 = /<(T|Self)asTrait>::/g;\n    const from4 = /<Tas[a-z]+::Trait>::/g;\n    const from5 = /<LookupasStaticLookup>/g;\n    const from6 = /::Type/g;\n    return (value) => {\n        from1.lastIndex = 0;\n        from2.lastIndex = 0;\n        from3.lastIndex = 0;\n        from4.lastIndex = 0;\n        from5.lastIndex = 0;\n        from6.lastIndex = 0;\n        return value\n            // remove all whitespaces\n            .replace(from1, '')\n            // anything `T::<type>` to end up as `<type>`\n            .replace(from2, '')\n            // replace `<T as Trait>::` (whitespaces were removed above)\n            .replace(from3, '')\n            // replace `<T as something::Trait>::` (whitespaces were removed above)\n            .replace(from4, '')\n            // replace <Lookup as StaticLookup>\n            .replace(from5, 'Lookup')\n            // replace `<...>::Type`\n            .replace(from6, '');\n    };\n}\nexport function removeWrap(check) {\n    const replacer = (v) => v;\n    return (value) => replaceTagWith(value, check, replacer);\n}\nconst sanitizeMap = new Map();\nexport function sanitize(value) {\n    const startValue = value.toString();\n    const memoized = sanitizeMap.get(startValue);\n    if (memoized) {\n        return memoized;\n    }\n    let result = startValue;\n    for (let i = 0, count = mappings.length; i < count; i++) {\n        result = mappings[i](result);\n    }\n    sanitizeMap.set(startValue, result);\n    return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}