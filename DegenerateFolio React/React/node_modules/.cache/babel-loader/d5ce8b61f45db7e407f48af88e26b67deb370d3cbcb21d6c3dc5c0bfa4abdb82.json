{"ast":null,"code":"import { isHex, isU8a, u8aToU8a } from '@polkadot/util';\nimport { base58Decode } from '../base58/index.js';\nimport { checkAddressChecksum } from './checksum.js';\nimport { defaults } from './defaults.js';\nexport function decodeAddress(encoded, ignoreChecksum, ss58Format = -1) {\n  if (!encoded) {\n    throw new Error('Invalid empty address passed');\n  }\n  if (isU8a(encoded) || isHex(encoded)) {\n    return u8aToU8a(encoded);\n  }\n  try {\n    const decoded = base58Decode(encoded);\n    if (!defaults.allowedEncodedLengths.includes(decoded.length)) {\n      throw new Error('Invalid decoded address length');\n    }\n    const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded);\n    if (!isValid && !ignoreChecksum) {\n      throw new Error('Invalid decoded address checksum');\n    } else if (ss58Format !== -1 && ss58Format !== ss58Decoded) {\n      throw new Error(`Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);\n    }\n    return decoded.slice(ss58Length, endPos);\n  } catch (error) {\n    throw new Error(`Decoding ${encoded}: ${error.message}`);\n  }\n}","map":{"version":3,"names":["isHex","isU8a","u8aToU8a","base58Decode","checkAddressChecksum","defaults","decodeAddress","encoded","ignoreChecksum","ss58Format","Error","decoded","allowedEncodedLengths","includes","length","isValid","endPos","ss58Length","ss58Decoded","slice","error","message"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util-crypto/address/decode.js"],"sourcesContent":["import { isHex, isU8a, u8aToU8a } from '@polkadot/util';\nimport { base58Decode } from '../base58/index.js';\nimport { checkAddressChecksum } from './checksum.js';\nimport { defaults } from './defaults.js';\nexport function decodeAddress(encoded, ignoreChecksum, ss58Format = -1) {\n    if (!encoded) {\n        throw new Error('Invalid empty address passed');\n    }\n    if (isU8a(encoded) || isHex(encoded)) {\n        return u8aToU8a(encoded);\n    }\n    try {\n        const decoded = base58Decode(encoded);\n        if (!defaults.allowedEncodedLengths.includes(decoded.length)) {\n            throw new Error('Invalid decoded address length');\n        }\n        const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded);\n        if (!isValid && !ignoreChecksum) {\n            throw new Error('Invalid decoded address checksum');\n        }\n        else if (ss58Format !== -1 && ss58Format !== ss58Decoded) {\n            throw new Error(`Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);\n        }\n        return decoded.slice(ss58Length, endPos);\n    }\n    catch (error) {\n        throw new Error(`Decoding ${encoded}: ${error.message}`);\n    }\n}\n"],"mappings":"AAAA,SAASA,KAAK,EAAEC,KAAK,EAAEC,QAAQ,QAAQ,gBAAgB;AACvD,SAASC,YAAY,QAAQ,oBAAoB;AACjD,SAASC,oBAAoB,QAAQ,eAAe;AACpD,SAASC,QAAQ,QAAQ,eAAe;AACxC,OAAO,SAASC,aAAaA,CAACC,OAAO,EAAEC,cAAc,EAAEC,UAAU,GAAG,CAAC,CAAC,EAAE;EACpE,IAAI,CAACF,OAAO,EAAE;IACV,MAAM,IAAIG,KAAK,CAAC,8BAA8B,CAAC;EACnD;EACA,IAAIT,KAAK,CAACM,OAAO,CAAC,IAAIP,KAAK,CAACO,OAAO,CAAC,EAAE;IAClC,OAAOL,QAAQ,CAACK,OAAO,CAAC;EAC5B;EACA,IAAI;IACA,MAAMI,OAAO,GAAGR,YAAY,CAACI,OAAO,CAAC;IACrC,IAAI,CAACF,QAAQ,CAACO,qBAAqB,CAACC,QAAQ,CAACF,OAAO,CAACG,MAAM,CAAC,EAAE;MAC1D,MAAM,IAAIJ,KAAK,CAAC,gCAAgC,CAAC;IACrD;IACA,MAAM,CAACK,OAAO,EAAEC,MAAM,EAAEC,UAAU,EAAEC,WAAW,CAAC,GAAGd,oBAAoB,CAACO,OAAO,CAAC;IAChF,IAAI,CAACI,OAAO,IAAI,CAACP,cAAc,EAAE;MAC7B,MAAM,IAAIE,KAAK,CAAC,kCAAkC,CAAC;IACvD,CAAC,MACI,IAAID,UAAU,KAAK,CAAC,CAAC,IAAIA,UAAU,KAAKS,WAAW,EAAE;MACtD,MAAM,IAAIR,KAAK,CAAE,uBAAsBD,UAAW,cAAaS,WAAY,EAAC,CAAC;IACjF;IACA,OAAOP,OAAO,CAACQ,KAAK,CAACF,UAAU,EAAED,MAAM,CAAC;EAC5C,CAAC,CACD,OAAOI,KAAK,EAAE;IACV,MAAM,IAAIV,KAAK,CAAE,YAAWH,OAAQ,KAAIa,KAAK,CAACC,OAAQ,EAAC,CAAC;EAC5D;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}