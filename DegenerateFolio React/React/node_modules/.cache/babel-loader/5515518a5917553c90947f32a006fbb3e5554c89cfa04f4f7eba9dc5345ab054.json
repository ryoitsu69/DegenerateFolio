{"ast":null,"code":"import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nimport { MAX_TEXTURES } from '../../../rendering/batcher/shared/const.mjs';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\n\"use strict\";\nclass GpuGraphicsAdaptor {\n  init() {\n    const localUniforms = new UniformGroup({\n      uTransformMatrix: {\n        value: new Matrix(),\n        type: \"mat3x3<f32>\"\n      },\n      uColor: {\n        value: new Float32Array([1, 1, 1, 1]),\n        type: \"vec4<f32>\"\n      },\n      uRound: {\n        value: 0,\n        type: \"f32\"\n      }\n    });\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"graphics\",\n      bits: [colorBit, generateTextureBatchBit(MAX_TEXTURES), localUniformBitGroup2, roundPixelsBit]\n    });\n    this.shader = new Shader({\n      gpuProgram,\n      resources: {\n        // added on the fly!\n        localUniforms\n      }\n    });\n  }\n  execute(graphicsPipe, renderable) {\n    const context = renderable.context;\n    const shader = context.customShader || this.shader;\n    const renderer = graphicsPipe.renderer;\n    const contextSystem = renderer.graphicsContext;\n    const {\n      geometry,\n      instructions\n    } = contextSystem.getContextRenderData(context);\n    const encoder = renderer.encoder;\n    encoder.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, graphicsPipe.state);\n    encoder.setGeometry(geometry);\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n    const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n    encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n    const batches = instructions.instructions;\n    for (let i = 0; i < instructions.instructionSize; i++) {\n      const batch = batches[i];\n      shader.groups[1] = batch.bindGroup;\n      if (!batch.gpuBindGroup) {\n        const textureBatch = batch.textures;\n        batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);\n        batch.gpuBindGroup = renderer.bindGroup.getBindGroup(batch.bindGroup, shader.gpuProgram, 1);\n      }\n      encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n      encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n  }\n  destroy() {\n    this.shader.destroy(true);\n    this.shader = null;\n  }\n}\n/** @ignore */\nGpuGraphicsAdaptor.extension = {\n  type: [ExtensionType.WebGPUPipesAdaptor],\n  name: \"graphics\"\n};\nexport { GpuGraphicsAdaptor };","map":{"version":3,"names":["GpuGraphicsAdaptor","init","localUniforms","UniformGroup","uTransformMatrix","value","Matrix","type","uColor","Float32Array","uRound","gpuProgram","compileHighShaderGpuProgram","name","bits","colorBit","generateTextureBatchBit","MAX_TEXTURES","localUniformBitGroup2","roundPixelsBit","shader","Shader","resources","execute","graphicsPipe","renderable","context","customShader","renderer","contextSystem","graphicsContext","geometry","instructions","getContextRenderData","encoder","setPipelineFromGeometryProgramAndState","state","setGeometry","globalUniformsBindGroup","globalUniforms","bindGroup","setBindGroup","localBindGroup","renderPipes","uniformBatch","getUniformBindGroup","batches","i","instructionSize","batch","groups","gpuBindGroup","textureBatch","textures","getTextureBatchBindGroup","count","getBindGroup","renderPassEncoder","drawIndexed","size","start","destroy","extension","ExtensionType","WebGPUPipesAdaptor"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/graphics/gpu/GpuGraphicsAdaptor.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { MAX_TEXTURES } from '../../../rendering/batcher/shared/const';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\n\nimport type { Batch } from '../../../rendering/batcher/shared/Batcher';\nimport type { GpuEncoderSystem } from '../../../rendering/renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsAdaptor, GraphicsPipe } from '../shared/GraphicsPipe';\n\n/**\n * A GraphicsAdaptor that uses the GPU to render graphics.\n * @memberof rendering\n * @ignore\n */\nexport class GpuGraphicsAdaptor implements GraphicsAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public shader: Shader;\n\n    public init()\n    {\n        const localUniforms = new UniformGroup({\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'graphics',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(MAX_TEXTURES),\n\n                localUniformBitGroup2,\n                roundPixelsBit\n            ]\n        });\n\n        this.shader = new Shader({\n            gpuProgram,\n            resources: {\n                // added on the fly!\n                localUniforms,\n            },\n        });\n    }\n\n    public execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void\n    {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer as WebGPURenderer;\n        const contextSystem = renderer.graphicsContext;\n\n        const {\n            geometry, instructions\n        } = contextSystem.getContextRenderData(context);\n\n        // WebGPU specific...\n\n        // TODO perf test this a bit...\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        encoder.setPipelineFromGeometryProgramAndState(\n            geometry,\n            shader.gpuProgram,\n            graphicsPipe.state\n        );\n\n        encoder.setGeometry(geometry);\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n\n        const localBindGroup = (renderer as WebGPURenderer)\n            .renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n\n        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n\n        const batches = instructions.instructions as Batch[];\n\n        for (let i = 0; i < instructions.instructionSize; i++)\n        {\n            const batch = batches[i];\n\n            shader.groups[1] = batch.bindGroup;\n\n            if (!batch.gpuBindGroup)\n            {\n                const textureBatch = batch.textures;\n\n                batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);\n                batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n                    batch.bindGroup, shader.gpuProgram, 1\n                );\n            }\n\n            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n\n            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n        }\n    }\n\n    public destroy(): void\n    {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}