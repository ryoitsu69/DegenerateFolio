{"ast":null,"code":"import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { compileHighShaderGpuProgram } from '../../high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit } from '../../high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit } from '../../high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { roundPixelsBit } from '../../high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../renderers/shared/shader/Shader.mjs';\nimport { State } from '../../renderers/shared/state/State.mjs';\nimport { MAX_TEXTURES } from '../shared/const.mjs';\nimport { getTextureBatchBindGroup } from './getTextureBatchBindGroup.mjs';\n\"use strict\";\nconst tempState = State.for2d();\nclass GpuBatchAdaptor {\n  init() {\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"batch\",\n      bits: [colorBit, generateTextureBatchBit(MAX_TEXTURES), roundPixelsBit]\n    });\n    this._shader = new Shader({\n      gpuProgram,\n      groups: {\n        // these will be dynamically allocated\n      }\n    });\n  }\n  start(batchPipe, geometry) {\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    const program = this._shader.gpuProgram;\n    this._geometry = geometry;\n    encoder.setGeometry(geometry);\n    tempState.blendMode = \"normal\";\n    renderer.pipeline.getPipeline(geometry, program, tempState);\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.resetBindGroup(1);\n    encoder.setBindGroup(0, globalUniformsBindGroup, program);\n  }\n  execute(batchPipe, batch) {\n    const program = this._shader.gpuProgram;\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    if (!batch.bindGroup) {\n      const textureBatch = batch.textures;\n      batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);\n    }\n    tempState.blendMode = batch.blendMode;\n    const gpuBindGroup = renderer.bindGroup.getBindGroup(batch.bindGroup, program, 1);\n    const pipeline = renderer.pipeline.getPipeline(this._geometry, program, tempState);\n    batch.bindGroup._touch(renderer.textureGC.count);\n    encoder.setPipeline(pipeline);\n    encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n    encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\n/** @ignore */\nGpuBatchAdaptor.extension = {\n  type: [ExtensionType.WebGPUPipesAdaptor],\n  name: \"batch\"\n};\nexport { GpuBatchAdaptor };","map":{"version":3,"names":["tempState","State","for2d","GpuBatchAdaptor","init","gpuProgram","compileHighShaderGpuProgram","name","bits","colorBit","generateTextureBatchBit","MAX_TEXTURES","roundPixelsBit","_shader","Shader","groups","start","batchPipe","geometry","renderer","encoder","program","_geometry","setGeometry","blendMode","pipeline","getPipeline","globalUniformsBindGroup","globalUniforms","bindGroup","resetBindGroup","setBindGroup","execute","batch","textureBatch","textures","getTextureBatchBindGroup","count","gpuBindGroup","getBindGroup","_touch","textureGC","setPipeline","renderPassEncoder","drawIndexed","size","destroy","extension","type","ExtensionType","WebGPUPipesAdaptor"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/batcher/gpu/GpuBatchAdaptor.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { compileHighShaderGpuProgram } from '../../high-shader/compileHighShaderToProgram';\nimport { colorBit } from '../../high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit } from '../../high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit } from '../../high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../renderers/shared/shader/Shader';\nimport { State } from '../../renderers/shared/state/State';\nimport { MAX_TEXTURES } from '../shared/const';\nimport { getTextureBatchBindGroup } from './getTextureBatchBindGroup';\n\nimport type { GpuEncoderSystem } from '../../renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../renderers/gpu/WebGPURenderer';\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { Batch } from '../shared/Batcher';\nimport type { BatcherAdaptor, BatcherPipe } from '../shared/BatcherPipe';\n\nconst tempState = State.for2d();\n\n/**\n * A BatcherAdaptor that uses the GPU to render batches.\n * @memberof rendering\n * @ignore\n */\nexport class GpuBatchAdaptor implements BatcherAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'batch',\n    } as const;\n\n    private _shader: Shader;\n    private _geometry: Geometry;\n\n    public init()\n    {\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'batch',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(MAX_TEXTURES),\n                roundPixelsBit,\n            ]\n        });\n\n        this._shader = new Shader({\n            gpuProgram,\n            groups: {\n                // these will be dynamically allocated\n            },\n        });\n    }\n\n    public start(batchPipe: BatcherPipe, geometry: Geometry): void\n    {\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n        const program = this._shader.gpuProgram;\n\n        this._geometry = geometry;\n\n        encoder.setGeometry(geometry);\n\n        tempState.blendMode = 'normal';\n\n        // this just initiates the pipeline, so we can then set bind groups on it\n        renderer.pipeline.getPipeline(\n            geometry,\n            program,\n            tempState\n        );\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        // low level - we need to reset the bind group at location 1 to null\n        // this is because we directly manipulate the bound buffer in the execture function for\n        // performance reasons.\n        // setting it to null ensures that the next bind group we set at location 1 will\n        // be the one we want.\n        encoder.resetBindGroup(1);\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, program);\n    }\n\n    public execute(batchPipe: BatcherPipe, batch: Batch): void\n    {\n        const program = this._shader.gpuProgram;\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        if (!batch.bindGroup)\n        {\n            const textureBatch = batch.textures;\n\n            batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);\n        }\n\n        tempState.blendMode = batch.blendMode;\n\n        const gpuBindGroup = renderer.bindGroup.getBindGroup(\n            batch.bindGroup, program, 1\n        );\n\n        const pipeline = renderer.pipeline.getPipeline(\n            this._geometry,\n            program,\n            tempState\n        );\n\n        batch.bindGroup._touch(renderer.textureGC.count);\n\n        encoder.setPipeline(pipeline);\n\n        encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n"],"mappings":";;;;;;;;;;AAgBA,MAAMA,SAAA,GAAYC,KAAA,CAAMC,KAAM;AAOvB,MAAMC,eACb;EAYWC,IACPA,CAAA;IACI,MAAMC,UAAA,GAAaC,2BAA4B;MAC3CC,IAAM;MACNC,IAAM,GACFC,QAAA,EACAC,uBAAA,CAAwBC,YAAY,GACpCC,cAAA;IACJ,CACH;IAEI,KAAAC,OAAA,GAAU,IAAIC,MAAO;MACtBT,UAAA;MACAU,MAAQ;QAAA;MAAA;IAER,CACH;EAAA;EAGEC,MAAMC,SAAA,EAAwBC,QACrC;IACI,MAAMC,QAAA,GAAWF,SAAU,CAAAE,QAAA;IAC3B,MAAMC,OAAA,GAAUD,QAAS,CAAAC,OAAA;IACnB,MAAAC,OAAA,GAAU,KAAKR,OAAQ,CAAAR,UAAA;IAE7B,KAAKiB,SAAY,GAAAJ,QAAA;IAEjBE,OAAA,CAAQG,WAAA,CAAYL,QAAQ;IAE5BlB,SAAA,CAAUwB,SAAY;IAGtBL,QAAA,CAASM,QAAS,CAAAC,WAAA,CACdR,QAAA,EACAG,OAAA,EACArB,SAAA,CACJ;IAEM,MAAA2B,uBAAA,GAA0BR,QAAA,CAASS,cAAe,CAAAC,SAAA;IAOxDT,OAAA,CAAQU,cAAA,CAAe,CAAC;IAEhBV,OAAA,CAAAW,YAAA,CAAa,CAAG,EAAAJ,uBAAA,EAAyBN,OAAO;EAAA;EAGrDW,QAAQf,SAAA,EAAwBgB,KACvC;IACU,MAAAZ,OAAA,GAAU,KAAKR,OAAQ,CAAAR,UAAA;IAC7B,MAAMc,QAAA,GAAWF,SAAU,CAAAE,QAAA;IAC3B,MAAMC,OAAA,GAAUD,QAAS,CAAAC,OAAA;IAErB,KAACa,KAAA,CAAMJ,SACX;MACI,MAAMK,YAAA,GAAeD,KAAM,CAAAE,QAAA;MAE3BF,KAAA,CAAMJ,SAAY,GAAAO,wBAAA,CAAyBF,YAAa,CAAAC,QAAA,EAAUD,YAAA,CAAaG,KAAK;IAAA;IAGxFrC,SAAA,CAAUwB,SAAA,GAAYS,KAAM,CAAAT,SAAA;IAEtB,MAAAc,YAAA,GAAenB,QAAA,CAASU,SAAU,CAAAU,YAAA,CACpCN,KAAM,CAAAJ,SAAA,EAAWR,OAAA,EAAS,EAC9B;IAEM,MAAAI,QAAA,GAAWN,QAAA,CAASM,QAAS,CAAAC,WAAA,CAC/B,IAAK,CAAAJ,SAAA,EACLD,OAAA,EACArB,SAAA,CACJ;IAEAiC,KAAA,CAAMJ,SAAU,CAAAW,MAAA,CAAOrB,QAAS,CAAAsB,SAAA,CAAUJ,KAAK;IAE/CjB,OAAA,CAAQsB,WAAA,CAAYjB,QAAQ;IAEpBL,OAAA,CAAAuB,iBAAA,CAAkBZ,YAAa,IAAGO,YAAY;IACtDlB,OAAA,CAAQuB,iBAAA,CAAkBC,WAAY,CAAAX,KAAA,CAAMY,IAAM,KAAGZ,KAAA,CAAMjB,KAAK;EAAA;EAG7D8B,OACPA,CAAA;IACS,KAAAjC,OAAA,CAAQiC,OAAA,CAAQ,IAAI;IACzB,KAAKjC,OAAU;EAAA;AAEvB;AAAA;AArGaV,eAAA,CAGK4C,SAAY;EACtBC,IAAM,GACFC,aAAc,CAAAC,kBAAA,CAClB;EACA3C,IAAM;AACV","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}