{"ast":null,"code":"import { GraphicsContextSystem } from '../GraphicsContextSystem.mjs';\n\"use strict\";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nfunction buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(0.99,\n  // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n  Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness));\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {\n  recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  let dx = x3 - x1;\n  let dy = y3 - y1;\n  const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);\n  if (d > FLT_EPSILON) {\n    if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {\n      if (mAngleTolerance < curveAngleToleranceEpsilon) {\n        points.push(x123, y123);\n        return;\n      }\n      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n      if (da >= pi) da = 2 * pi - da;\n      if (da < mAngleTolerance) {\n        points.push(x123, y123);\n        return;\n      }\n    }\n  } else {\n    dx = x123 - (x1 + x3) / 2;\n    dy = y123 - (y1 + y3) / 2;\n    if (dx * dx + dy * dy <= distanceTolerance) {\n      points.push(x123, y123);\n      return;\n    }\n  }\n  recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n  recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\nexport { buildAdaptiveQuadratic };","map":{"version":3,"names":["RECURSION_LIMIT","FLT_EPSILON","PATH_DISTANCE_EPSILON","curveAngleToleranceEpsilon","mAngleTolerance","buildAdaptiveQuadratic","points","sX","sY","cp1x","cp1y","eX","eY","smoothness","scale","smoothing","Math","min","max","GraphicsContextSystem","defaultOptions","bezierSmoothness","distanceTolerance","begin","recursive","push","x1","y1","x2","y2","x3","y3","level","pi","PI","x12","y12","x23","y23","x123","y123","dx","dy","d","abs","da","atan2"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.ts"],"sourcesContent":["// thanks to https://github.com/mattdesl/adaptive-quadratic-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\n\nexport function buildAdaptiveQuadratic(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    const scale = 1.0;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n\n    points.push(eX, eY);\n}\n\nfunction recursive(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    distanceTolerance: number,\n    level: number\n)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n\n    let dx = x3 - x1;\n    let dy = y3 - y1;\n    const d = Math.abs((((x2 - x3) * dy) - ((y2 - y3) * dx)));\n\n    if (d > FLT_EPSILON)\n    {\n        // Regular care\n        // -----------------\n        if (d * d <= distanceTolerance * ((dx * dx) + (dy * dy)))\n        {\n            // If the curvature doesn't exceed the distance_tolerance value\n            // we tend to finish subdivisions.\n            // ----------------------\n            if (mAngleTolerance < curveAngleToleranceEpsilon)\n            {\n                points.push(x123, y123);\n\n                return;\n            }\n\n            // Angle & Cusp Condition\n            // ----------------------\n            let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n\n            if (da >= pi) da = (2 * pi) - da;\n\n            if (da < mAngleTolerance)\n            {\n                // Finally we can stop the recursion\n                // ----------------------\n                points.push(x123, y123);\n\n                return;\n            }\n        }\n    }\n    else\n    {\n        // Collinear case\n        // -----------------\n        dx = x123 - ((x1 + x3) / 2);\n        dy = y123 - ((y1 + y3) / 2);\n        if ((dx * dx) + (dy * dy) <= distanceTolerance)\n        {\n            points.push(x123, y123);\n\n            return;\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n    recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}