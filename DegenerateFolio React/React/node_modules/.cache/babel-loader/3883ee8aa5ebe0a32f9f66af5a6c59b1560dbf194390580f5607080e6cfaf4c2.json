{"ast":null,"code":"import { combineLatest, map, switchMap } from 'rxjs';\nimport { BN, BN_ZERO, objectSpread } from '@polkadot/util';\nimport { firstMemo, memo } from '../util/index.js';\nconst QUERY_OPTS = {\n  withDestination: true,\n  withLedger: true,\n  withNominations: true,\n  withPrefs: true\n};\nfunction groupByEra(list) {\n  return list.reduce((map, _ref) => {\n    let {\n      era,\n      value\n    } = _ref;\n    const key = era.toString();\n    map[key] = (map[key] || BN_ZERO).add(value.unwrap());\n    return map;\n  }, {});\n}\nfunction calculateUnlocking(api, stakingLedger, sessionInfo) {\n  const results = Object.entries(groupByEra(((stakingLedger === null || stakingLedger === void 0 ? void 0 : stakingLedger.unlocking) || []).filter(_ref2 => {\n    let {\n      era\n    } = _ref2;\n    return era.unwrap().gt(sessionInfo.activeEra);\n  }))).map(_ref3 => {\n    let [eraString, value] = _ref3;\n    return {\n      remainingEras: new BN(eraString).isub(sessionInfo.activeEra),\n      value: api.registry.createType('Balance', value)\n    };\n  });\n  return results.length ? results : undefined;\n}\nfunction redeemableSum(api, stakingLedger, sessionInfo) {\n  return api.registry.createType('Balance', ((stakingLedger === null || stakingLedger === void 0 ? void 0 : stakingLedger.unlocking) || []).reduce((total, _ref4) => {\n    let {\n      era,\n      value\n    } = _ref4;\n    // aligns with https://github.com/paritytech/substrate/blob/fdfdc73f9e64dc47934b72eb9af3e1989e4ba699/frame/staking/src/pallet/mod.rs#L973-L975\n    // (ensure currentEra >= era passed, as per https://github.com/paritytech/substrate/blob/fdfdc73f9e64dc47934b72eb9af3e1989e4ba699/frame/staking/src/lib.rs#L477-L494)\n    // NOTE: Previously we used activeEra >= era, which is incorrect for the last session\n    return era.unwrap().gt(sessionInfo.currentEra) ? total : total.iadd(value.unwrap());\n  }, new BN(0)));\n}\nfunction parseResult(api, sessionInfo, keys, query) {\n  return objectSpread({}, keys, query, {\n    redeemable: redeemableSum(api, query.stakingLedger, sessionInfo),\n    unlocking: calculateUnlocking(api, query.stakingLedger, sessionInfo)\n  });\n}\n/**\n * @description From a list of stashes, fill in all the relevant staking details\n */\nexport function accounts(instanceId, api) {\n  return memo(instanceId, function (accountIds) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : QUERY_OPTS;\n    return api.derive.session.info().pipe(switchMap(sessionInfo => combineLatest([api.derive.staking.keysMulti(accountIds), api.derive.staking.queryMulti(accountIds, opts)]).pipe(map(_ref5 => {\n      let [keys, queries] = _ref5;\n      return queries.map((q, index) => parseResult(api, sessionInfo, keys[index], q));\n    }))));\n  });\n}\n/**\n * @description From a stash, retrieve the controllerId and fill in all the relevant staking details\n */\nexport const account = /*#__PURE__*/firstMemo((api, accountId, opts) => api.derive.staking.accounts([accountId], opts));","map":{"version":3,"names":["combineLatest","map","switchMap","BN","BN_ZERO","objectSpread","firstMemo","memo","QUERY_OPTS","withDestination","withLedger","withNominations","withPrefs","groupByEra","list","reduce","_ref","era","value","key","toString","add","unwrap","calculateUnlocking","api","stakingLedger","sessionInfo","results","Object","entries","unlocking","filter","_ref2","gt","activeEra","_ref3","eraString","remainingEras","isub","registry","createType","length","undefined","redeemableSum","total","_ref4","currentEra","iadd","parseResult","keys","query","redeemable","accounts","instanceId","accountIds","opts","arguments","derive","session","info","pipe","staking","keysMulti","queryMulti","_ref5","queries","q","index","account","accountId"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api-derive/staking/account.js"],"sourcesContent":["import { combineLatest, map, switchMap } from 'rxjs';\nimport { BN, BN_ZERO, objectSpread } from '@polkadot/util';\nimport { firstMemo, memo } from '../util/index.js';\nconst QUERY_OPTS = {\n    withDestination: true,\n    withLedger: true,\n    withNominations: true,\n    withPrefs: true\n};\nfunction groupByEra(list) {\n    return list.reduce((map, { era, value }) => {\n        const key = era.toString();\n        map[key] = (map[key] || BN_ZERO).add(value.unwrap());\n        return map;\n    }, {});\n}\nfunction calculateUnlocking(api, stakingLedger, sessionInfo) {\n    const results = Object\n        .entries(groupByEra((stakingLedger?.unlocking || []).filter(({ era }) => era.unwrap().gt(sessionInfo.activeEra))))\n        .map(([eraString, value]) => ({\n        remainingEras: new BN(eraString).isub(sessionInfo.activeEra),\n        value: api.registry.createType('Balance', value)\n    }));\n    return results.length\n        ? results\n        : undefined;\n}\nfunction redeemableSum(api, stakingLedger, sessionInfo) {\n    return api.registry.createType('Balance', (stakingLedger?.unlocking || []).reduce((total, { era, value }) => {\n        // aligns with https://github.com/paritytech/substrate/blob/fdfdc73f9e64dc47934b72eb9af3e1989e4ba699/frame/staking/src/pallet/mod.rs#L973-L975\n        // (ensure currentEra >= era passed, as per https://github.com/paritytech/substrate/blob/fdfdc73f9e64dc47934b72eb9af3e1989e4ba699/frame/staking/src/lib.rs#L477-L494)\n        // NOTE: Previously we used activeEra >= era, which is incorrect for the last session\n        return era.unwrap().gt(sessionInfo.currentEra)\n            ? total\n            : total.iadd(value.unwrap());\n    }, new BN(0)));\n}\nfunction parseResult(api, sessionInfo, keys, query) {\n    return objectSpread({}, keys, query, {\n        redeemable: redeemableSum(api, query.stakingLedger, sessionInfo),\n        unlocking: calculateUnlocking(api, query.stakingLedger, sessionInfo)\n    });\n}\n/**\n * @description From a list of stashes, fill in all the relevant staking details\n */\nexport function accounts(instanceId, api) {\n    return memo(instanceId, (accountIds, opts = QUERY_OPTS) => api.derive.session.info().pipe(switchMap((sessionInfo) => combineLatest([\n        api.derive.staking.keysMulti(accountIds),\n        api.derive.staking.queryMulti(accountIds, opts)\n    ]).pipe(map(([keys, queries]) => queries.map((q, index) => parseResult(api, sessionInfo, keys[index], q)))))));\n}\n/**\n * @description From a stash, retrieve the controllerId and fill in all the relevant staking details\n */\nexport const account = /*#__PURE__*/ firstMemo((api, accountId, opts) => api.derive.staking.accounts([accountId], opts));\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}