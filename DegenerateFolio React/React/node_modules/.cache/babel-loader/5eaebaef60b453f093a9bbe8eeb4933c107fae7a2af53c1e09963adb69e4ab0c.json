{"ast":null,"code":"import { map, of } from 'rxjs';\nimport { objectSpread } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nimport { didUpdateToBool } from './util.js';\nfunction parseActive(id, active) {\n  const found = active.find(_ref => {\n    let [paraId] = _ref;\n    return paraId === id;\n  });\n  if (found && found[1].isSome) {\n    const [collatorId, retriable] = found[1].unwrap();\n    return objectSpread({\n      collatorId\n    }, retriable.isWithRetries ? {\n      isRetriable: true,\n      retries: retriable.asWithRetries.toNumber()\n    } : {\n      isRetriable: false,\n      retries: 0\n    });\n  }\n  return null;\n}\nfunction parseCollators(id, collatorQueue) {\n  return collatorQueue.map(queue => {\n    const found = queue.find(_ref2 => {\n      let [paraId] = _ref2;\n      return paraId === id;\n    });\n    return found ? found[1] : null;\n  });\n}\nfunction parse(id, _ref3) {\n  let [active, retryQueue, selectedThreads, didUpdate, info, pendingSwap, heads, relayDispatchQueue] = _ref3;\n  if (info.isNone) {\n    return null;\n  }\n  return {\n    active: parseActive(id, active),\n    didUpdate: didUpdateToBool(didUpdate, id),\n    heads,\n    id,\n    info: objectSpread({\n      id\n    }, info.unwrap()),\n    pendingSwapId: pendingSwap.unwrapOr(null),\n    relayDispatchQueue,\n    retryCollators: parseCollators(id, retryQueue),\n    selectedCollators: parseCollators(id, selectedThreads)\n  };\n}\nexport function info(instanceId, api) {\n  return memo(instanceId, id => api.query['registrar'] && api.query['parachains'] ? api.queryMulti([api.query['registrar']['active'], api.query['registrar']['retryQueue'], api.query['registrar']['selectedThreads'], api.query['parachains']['didUpdate'], [api.query['registrar']['paras'], id], [api.query['registrar']['pendingSwap'], id], [api.query['parachains']['heads'], id], [api.query['parachains']['relayDispatchQueue'], id]]).pipe(map(result => parse(api.registry.createType('ParaId', id), result))) : of(null));\n}","map":{"version":3,"names":["map","of","objectSpread","memo","didUpdateToBool","parseActive","id","active","found","find","_ref","paraId","isSome","collatorId","retriable","unwrap","isWithRetries","isRetriable","retries","asWithRetries","toNumber","parseCollators","collatorQueue","queue","_ref2","parse","_ref3","retryQueue","selectedThreads","didUpdate","info","pendingSwap","heads","relayDispatchQueue","isNone","pendingSwapId","unwrapOr","retryCollators","selectedCollators","instanceId","api","query","queryMulti","pipe","result","registry","createType"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api-derive/parachains/info.js"],"sourcesContent":["import { map, of } from 'rxjs';\nimport { objectSpread } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nimport { didUpdateToBool } from './util.js';\nfunction parseActive(id, active) {\n    const found = active.find(([paraId]) => paraId === id);\n    if (found && found[1].isSome) {\n        const [collatorId, retriable] = found[1].unwrap();\n        return objectSpread({ collatorId }, retriable.isWithRetries\n            ? {\n                isRetriable: true,\n                retries: retriable.asWithRetries.toNumber()\n            }\n            : {\n                isRetriable: false,\n                retries: 0\n            });\n    }\n    return null;\n}\nfunction parseCollators(id, collatorQueue) {\n    return collatorQueue.map((queue) => {\n        const found = queue.find(([paraId]) => paraId === id);\n        return found ? found[1] : null;\n    });\n}\nfunction parse(id, [active, retryQueue, selectedThreads, didUpdate, info, pendingSwap, heads, relayDispatchQueue]) {\n    if (info.isNone) {\n        return null;\n    }\n    return {\n        active: parseActive(id, active),\n        didUpdate: didUpdateToBool(didUpdate, id),\n        heads,\n        id,\n        info: objectSpread({ id }, info.unwrap()),\n        pendingSwapId: pendingSwap.unwrapOr(null),\n        relayDispatchQueue,\n        retryCollators: parseCollators(id, retryQueue),\n        selectedCollators: parseCollators(id, selectedThreads)\n    };\n}\nexport function info(instanceId, api) {\n    return memo(instanceId, (id) => api.query['registrar'] && api.query['parachains']\n        ? api.queryMulti([\n            api.query['registrar']['active'],\n            api.query['registrar']['retryQueue'],\n            api.query['registrar']['selectedThreads'],\n            api.query['parachains']['didUpdate'],\n            [api.query['registrar']['paras'], id],\n            [api.query['registrar']['pendingSwap'], id],\n            [api.query['parachains']['heads'], id],\n            [api.query['parachains']['relayDispatchQueue'], id]\n        ])\n            .pipe(map((result) => parse(api.registry.createType('ParaId', id), result)))\n        : of(null));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}