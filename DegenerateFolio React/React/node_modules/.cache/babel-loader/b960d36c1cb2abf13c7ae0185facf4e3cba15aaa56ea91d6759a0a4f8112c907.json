{"ast":null,"code":"import { Texture, BaseTexture } from \"@pixi/core\";\nimport \"../utils/index.mjs\";\nimport { convertToList } from \"../utils/convertToList.mjs\";\nclass CacheClass {\n  constructor() {\n    this._parsers = [], this._cache = /* @__PURE__ */new Map(), this._cacheMap = /* @__PURE__ */new Map();\n  }\n  /** Clear all entries. */\n  reset() {\n    this._cacheMap.clear(), this._cache.clear();\n  }\n  /**\n   * Check if the key exists\n   * @param key - The key to check\n   */\n  has(key) {\n    return this._cache.has(key);\n  }\n  /**\n   * Fetch entry by key\n   * @param key - The key of the entry to get\n   */\n  get(key) {\n    const result = this._cache.get(key);\n    return result || console.warn(`[Assets] Asset id ${key} was not found in the Cache`), result;\n  }\n  /**\n   * Set a value by key or keys name\n   * @param key - The key or keys to set\n   * @param value - The value to store in the cache or from which cacheable assets will be derived.\n   */\n  set(key, value) {\n    const keys = convertToList(key);\n    let cacheableAssets;\n    for (let i = 0; i < this.parsers.length; i++) {\n      const parser = this.parsers[i];\n      if (parser.test(value)) {\n        cacheableAssets = parser.getCacheableAssets(keys, value);\n        break;\n      }\n    }\n    cacheableAssets || (cacheableAssets = {}, keys.forEach(key2 => {\n      cacheableAssets[key2] = value;\n    }));\n    const cacheKeys = Object.keys(cacheableAssets),\n      cachedAssets = {\n        cacheKeys,\n        keys\n      };\n    if (keys.forEach(key2 => {\n      this._cacheMap.set(key2, cachedAssets);\n    }), cacheKeys.forEach(key2 => {\n      this._cache.has(key2) && this._cache.get(key2) !== value && console.warn(\"[Cache] already has key:\", key2), this._cache.set(key2, cacheableAssets[key2]);\n    }), value instanceof Texture) {\n      const texture = value;\n      keys.forEach(key2 => {\n        texture.baseTexture !== Texture.EMPTY.baseTexture && BaseTexture.addToCache(texture.baseTexture, key2), Texture.addToCache(texture, key2);\n      });\n    }\n  }\n  /**\n   * Remove entry by key\n   *\n   * This function will also remove any associated alias from the cache also.\n   * @param key - The key of the entry to remove\n   */\n  remove(key) {\n    if (!this._cacheMap.has(key)) {\n      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n      return;\n    }\n    const cacheMap = this._cacheMap.get(key);\n    cacheMap.cacheKeys.forEach(key2 => {\n      this._cache.delete(key2);\n    }), cacheMap.keys.forEach(key2 => {\n      this._cacheMap.delete(key2);\n    });\n  }\n  /** All loader parsers registered */\n  get parsers() {\n    return this._parsers;\n  }\n}\nconst Cache = new CacheClass();\nexport { Cache };","map":{"version":3,"names":["CacheClass","constructor","_parsers","_cache","Map","_cacheMap","reset","clear","has","key","get","result","console","warn","set","value","keys","convertToList","cacheableAssets","i","parsers","length","parser","test","getCacheableAssets","forEach","key2","cacheKeys","Object","cachedAssets","Texture","texture","baseTexture","EMPTY","BaseTexture","addToCache","remove","cacheMap","delete","Cache"],"sources":["/home/ryoitsu/node_modules/@pixi/assets/src/cache/Cache.ts"],"sourcesContent":["import { BaseTexture, Texture } from '@pixi/core';\nimport { convertToList } from '../utils';\n\nimport type { CacheParser } from './CacheParser';\n\n/**\n * A single Cache for all assets.\n *\n * When assets are added to the cache via set they normally are added to the cache as key-value pairs.\n *\n * With this cache, you can add parsers that will take the object and convert it to a list of assets that can be cached.\n * for example a cacheSprite Sheet parser will add all of the textures found within its sprite sheet directly to the cache.\n *\n * This gives devs the flexibility to cache any type of object however we want.\n *\n * It is not intended that this class is created by developers - it is part of the Asset package.\n * This is the first major system of PixiJS' main Assets class.\n * @memberof PIXI\n * @class Cache\n */\nclass CacheClass\n{\n    private _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<string, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: string): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: string): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            if (process.env.DEBUG)\n            {\n                console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            }\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set(key: string | string[], value: unknown): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        if (!cacheableAssets)\n        {\n            cacheableAssets = {};\n\n            keys.forEach((key) =>\n            {\n                cacheableAssets[key] = value;\n            });\n        }\n\n        const cacheKeys = Object.keys(cacheableAssets);\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            if (this._cache.has(key) && this._cache.get(key) !== value)\n            {\n                if (process.env.DEBUG)\n                {\n                    console.warn('[Cache] already has key:', key);\n                }\n            }\n\n            this._cache.set(key, cacheableAssets[key]);\n        });\n\n        // temporary to keep compatible with existing texture caching.. until we remove them!\n        if (value instanceof Texture)\n        {\n            const texture: Texture = value;\n\n            keys.forEach((key) =>\n            {\n                if (texture.baseTexture !== Texture.EMPTY.baseTexture)\n                {\n                    BaseTexture.addToCache(texture.baseTexture, key);\n                }\n\n                Texture.addToCache(texture, key);\n            });\n        }\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: string): void\n    {\n        if (!this._cacheMap.has(key))\n        {\n            if (process.env.DEBUG)\n            {\n                console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            }\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\nexport const Cache = new CacheClass();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}