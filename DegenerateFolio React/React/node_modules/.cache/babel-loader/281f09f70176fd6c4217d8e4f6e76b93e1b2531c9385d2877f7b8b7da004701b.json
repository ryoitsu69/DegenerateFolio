{"ast":null,"code":"/**\n * @name objectProperty\n * @summary Assign a get property on the input object\n */\nexport function objectProperty(that, key, getter, getName, index = 0) {\n  const name = getName ? getName(key, index) : key;\n  // There are 3 approaches here -\n  //  - Object.prototype.hasOwnProperty.call(that, key) - this only checks the current class, i.e\n  //    will retuirn false if the property is set in the parent class\n  //  - isUndefined(...) - this may yield a false positive when the property is there, but not set.\n  //    Additionally, on pre-defined getters it may make a call\n  //  - key in that - Does not need to be combined with either of the above and checks the full chain\n  if (!(name in that)) {\n    Object.defineProperty(that, name, {\n      enumerable: true,\n      // Unlike in lazy, we always call into the upper function, i.e. this method\n      // does not cache old values (it is expected to be used for dynamic values)\n      get: function () {\n        return getter(key, index, this);\n      }\n    });\n  }\n}\n/**\n * @name objectProperties\n * @summary Assign get properties on the input object\n */\nexport function objectProperties(that, keys, getter, getName) {\n  for (let i = 0, count = keys.length; i < count; i++) {\n    objectProperty(that, keys[i], getter, getName, i);\n  }\n}","map":{"version":3,"names":["objectProperty","that","key","getter","getName","index","name","Object","defineProperty","enumerable","get","objectProperties","keys","i","count","length"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util/object/property.js"],"sourcesContent":["/**\n * @name objectProperty\n * @summary Assign a get property on the input object\n */\nexport function objectProperty(that, key, getter, getName, index = 0) {\n    const name = getName\n        ? getName(key, index)\n        : key;\n    // There are 3 approaches here -\n    //  - Object.prototype.hasOwnProperty.call(that, key) - this only checks the current class, i.e\n    //    will retuirn false if the property is set in the parent class\n    //  - isUndefined(...) - this may yield a false positive when the property is there, but not set.\n    //    Additionally, on pre-defined getters it may make a call\n    //  - key in that - Does not need to be combined with either of the above and checks the full chain\n    if (!(name in that)) {\n        Object.defineProperty(that, name, {\n            enumerable: true,\n            // Unlike in lazy, we always call into the upper function, i.e. this method\n            // does not cache old values (it is expected to be used for dynamic values)\n            get: function () {\n                return getter(key, index, this);\n            }\n        });\n    }\n}\n/**\n * @name objectProperties\n * @summary Assign get properties on the input object\n */\nexport function objectProperties(that, keys, getter, getName) {\n    for (let i = 0, count = keys.length; i < count; i++) {\n        objectProperty(that, keys[i], getter, getName, i);\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,SAASA,cAAcA,CAACC,IAAI,EAAEC,GAAG,EAAEC,MAAM,EAAEC,OAAO,EAAEC,KAAK,GAAG,CAAC,EAAE;EAClE,MAAMC,IAAI,GAAGF,OAAO,GACdA,OAAO,CAACF,GAAG,EAAEG,KAAK,CAAC,GACnBH,GAAG;EACT;EACA;EACA;EACA;EACA;EACA;EACA,IAAI,EAAEI,IAAI,IAAIL,IAAI,CAAC,EAAE;IACjBM,MAAM,CAACC,cAAc,CAACP,IAAI,EAAEK,IAAI,EAAE;MAC9BG,UAAU,EAAE,IAAI;MAChB;MACA;MACAC,GAAG,EAAE,SAAAA,CAAA,EAAY;QACb,OAAOP,MAAM,CAACD,GAAG,EAAEG,KAAK,EAAE,IAAI,CAAC;MACnC;IACJ,CAAC,CAAC;EACN;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO,SAASM,gBAAgBA,CAACV,IAAI,EAAEW,IAAI,EAAET,MAAM,EAAEC,OAAO,EAAE;EAC1D,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEC,KAAK,GAAGF,IAAI,CAACG,MAAM,EAAEF,CAAC,GAAGC,KAAK,EAAED,CAAC,EAAE,EAAE;IACjDb,cAAc,CAACC,IAAI,EAAEW,IAAI,CAACC,CAAC,CAAC,EAAEV,MAAM,EAAEC,OAAO,EAAES,CAAC,CAAC;EACrD;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}