{"ast":null,"code":"import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { matrixPool, boundsPool } from './utils/matrixAndBoundsPool.mjs';\n\"use strict\";\nfunction getGlobalBounds(target, skipUpdateTransform, bounds) {\n  bounds.clear();\n  let parentTransform;\n  let pooledMatrix;\n  if (target.parent) {\n    if (!skipUpdateTransform) {\n      pooledMatrix = matrixPool.get().identity();\n      parentTransform = updateTransformBackwards(target, pooledMatrix);\n    } else {\n      parentTransform = target.parent.worldTransform;\n    }\n  } else {\n    parentTransform = Matrix.IDENTITY;\n  }\n  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n  if (pooledMatrix) {\n    matrixPool.return(pooledMatrix);\n  }\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {\n  if (!target.visible || !target.measurable) return;\n  let worldTransform;\n  if (!skipUpdateTransform) {\n    target.updateLocalTransform();\n    worldTransform = matrixPool.get();\n    worldTransform.appendFrom(target.localTransform, parentTransform);\n  } else {\n    worldTransform = target.worldTransform;\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = boundsPool.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, worldTransform);\n  } else {\n    if (target.addBounds) {\n      bounds.matrix = worldTransform;\n      target.addBounds(bounds);\n    }\n    for (let i = 0; i < target.children.length; i++) {\n      _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addBounds?.(bounds);\n    }\n    parentBounds.addBounds(bounds, Matrix.IDENTITY);\n    boundsPool.return(bounds);\n  }\n  if (!skipUpdateTransform) {\n    matrixPool.return(worldTransform);\n  }\n}\nfunction updateTransformBackwards(target, parentTransform) {\n  const parent = target.parent;\n  if (parent) {\n    updateTransformBackwards(parent, parentTransform);\n    parent.updateLocalTransform();\n    parentTransform.append(parent.localTransform);\n  }\n  return parentTransform;\n}\nexport { _getGlobalBounds, getGlobalBounds, updateTransformBackwards };","map":{"version":3,"names":["getGlobalBounds","target","skipUpdateTransform","bounds","clear","parentTransform","pooledMatrix","parent","matrixPool","get","identity","updateTransformBackwards","worldTransform","Matrix","IDENTITY","_getGlobalBounds","return","isValid","set","visible","measurable","updateLocalTransform","appendFrom","localTransform","parentBounds","preserveBounds","effects","length","boundsPool","boundsArea","addRect","addBounds","matrix","i","children","append"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/container/bounds/getGlobalBounds.ts"],"sourcesContent":["import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool, matrixPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\nexport function getGlobalBounds(target: Container, skipUpdateTransform: boolean, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    let parentTransform;\n    let pooledMatrix;\n\n    if (target.parent)\n    {\n        if (!skipUpdateTransform)\n        {\n            pooledMatrix = matrixPool.get().identity();\n            parentTransform = updateTransformBackwards(target, pooledMatrix);\n        }\n        else\n        {\n            parentTransform = target.parent.worldTransform;\n        }\n    }\n    else\n    {\n        parentTransform = Matrix.IDENTITY;\n    }\n\n    // then collect them...\n\n    _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n\n    if (pooledMatrix)\n    {\n        matrixPool.return(pooledMatrix);\n    }\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    return bounds;\n}\n\nexport function _getGlobalBounds(\n    target: Container,\n    bounds: Bounds,\n    parentTransform: Matrix,\n    skipUpdateTransform: boolean,\n): void\n{\n    if (!target.visible || !target.measurable) return;\n\n    let worldTransform: Matrix;\n\n    if (!skipUpdateTransform)\n    {\n        target.updateLocalTransform();\n\n        worldTransform = matrixPool.get();\n\n        worldTransform.appendFrom(target.localTransform, parentTransform);\n    }\n    else\n    {\n        worldTransform = target.worldTransform;\n    }\n\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n\n    if (preserveBounds)\n    {\n        bounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, worldTransform);\n    }\n    else\n    {\n        if ((target as Renderable).addBounds)\n        {\n            // save a copy\n            bounds.matrix = worldTransform;\n\n            (target as Renderable).addBounds(bounds);\n        }\n\n        for (let i = 0; i < target.children.length; i++)\n        {\n            _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n        }\n    }\n\n    if (preserveBounds)\n    {\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            target.effects[i].addBounds?.(bounds);\n        }\n\n        parentBounds.addBounds(bounds, Matrix.IDENTITY);\n\n        boundsPool.return(bounds);\n    }\n\n    if (!skipUpdateTransform)\n    {\n        matrixPool.return(worldTransform);\n    }\n}\n\nexport function updateTransformBackwards(target: Container, parentTransform: Matrix)\n{\n    const parent = target.parent;\n\n    if (parent)\n    {\n        updateTransformBackwards(parent, parentTransform);\n\n        parent.updateLocalTransform();\n\n        parentTransform.append(parent.localTransform);\n    }\n\n    return parentTransform;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}