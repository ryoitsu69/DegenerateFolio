{"ast":null,"code":"import { u8aToU8a } from '../u8a/toU8a.js';\nimport { isString } from './string.js';\n/**\n * @name isUtf8\n * @summary Tests if the input is valid Utf8\n * @description\n * Checks to see if the input string or Uint8Array is valid Utf8\n */\nexport function isUtf8(value) {\n  if (!value) {\n    return isString(value);\n  }\n  const u8a = u8aToU8a(value);\n  const len = u8a.length;\n  let i = 0;\n  while (i < len) {\n    if (u8a[i] <= 0x7F) /* 00..7F */{\n        i += 1;\n      } else if (u8a[i] >= 0xC2 && u8a[i] <= 0xDF) /* C2..DF 80..BF */{\n        if (i + 1 < len) /* Expect a 2nd byte */{\n            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {\n              // *message = \"After a first byte between C2 and DF, expecting a 2nd byte between 80 and BF\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte between C2 and DF, expecting a 2nd byte.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n        i += 2;\n      } else if (u8a[i] === 0xE0) /* E0 A0..BF 80..BF */{\n        if (i + 2 < len) /* Expect a 2nd and 3rd byte */{\n            if (u8a[i + 1] < 0xA0 || u8a[i + 1] > 0xBF) {\n              // *message = \"After a first byte of E0, expecting a 2nd byte between A0 and BF.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte of E0, expecting a 3nd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte of E0, expecting two following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n        i += 3;\n      } else if (u8a[i] >= 0xE1 && u8a[i] <= 0xEC) /* E1..EC 80..BF 80..BF */{\n        if (i + 2 < len) /* Expect a 2nd and 3rd byte */{\n            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {\n              // *message = \"After a first byte between E1 and EC, expecting the 2nd byte between 80 and BF.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte between E1 and EC, expecting the 3rd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte between E1 and EC, expecting two following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n        i += 3;\n      } else if (u8a[i] === 0xED) /* ED 80..9F 80..BF */{\n        if (i + 2 < len) /* Expect a 2nd and 3rd byte */{\n            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0x9F) {\n              // *message = \"After a first byte of ED, expecting 2nd byte between 80 and 9F.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte of ED, expecting 3rd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte of ED, expecting two following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n        i += 3;\n      } else if (u8a[i] >= 0xEE && u8a[i] <= 0xEF) /* EE..EF 80..BF 80..BF */{\n        if (i + 2 < len) /* Expect a 2nd and 3rd byte */{\n            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {\n              // *message = \"After a first byte between EE and EF, expecting 2nd byte between 80 and BF.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte between EE and EF, expecting 3rd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte between EE and EF, two following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n        i += 3;\n      } else if (u8a[i] === 0xF0) /* F0 90..BF 80..BF 80..BF */{\n        if (i + 3 < len) /* Expect a 2nd, 3rd 3th byte */{\n            if (u8a[i + 1] < 0x90 || u8a[i + 1] > 0xBF) {\n              // *message = \"After a first byte of F0, expecting 2nd byte between 90 and BF.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte of F0, expecting 3rd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n            if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) {\n              // *message = \"After a first byte of F0, expecting 4th byte between 80 and BF.\";\n              // *faulty_bytes = 4;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte of F0, expecting three following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n        i += 4;\n      } else if (u8a[i] >= 0xF1 && u8a[i] <= 0xF3) /* F1..F3 80..BF 80..BF 80..BF */{\n        if (i + 3 < len) /* Expect a 2nd, 3rd 3th byte */{\n            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {\n              // *message = \"After a first byte of F1, F2, or F3, expecting a 2nd byte between 80 and BF.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte of F1, F2, or F3, expecting a 3rd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n            if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) {\n              // *message = \"After a first byte of F1, F2, or F3, expecting a 4th byte between 80 and BF.\";\n              // *faulty_bytes = 4;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte of F1, F2, or F3, expecting three following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n        i += 4;\n      } else if (u8a[i] === 0xF4) /* F4 80..8F 80..BF 80..BF */{\n        if (i + 3 < len) /* Expect a 2nd, 3rd 3th byte */{\n            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0x8F) {\n              // *message = \"After a first byte of F4, expecting 2nd byte between 80 and 8F.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte of F4, expecting 3rd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n            if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) {\n              // *message = \"After a first byte of F4, expecting 4th byte between 80 and BF.\";\n              // *faulty_bytes = 4;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte of F4, expecting three following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n        i += 4;\n      } else {\n      // *message = \"Expecting bytes in the following ranges: 00..7F C2..F4.\";\n      // *faulty_bytes = 1;\n      return false;\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["u8aToU8a","isString","isUtf8","value","u8a","len","length","i"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util/is/utf8.js"],"sourcesContent":["import { u8aToU8a } from '../u8a/toU8a.js';\nimport { isString } from './string.js';\n/**\n * @name isUtf8\n * @summary Tests if the input is valid Utf8\n * @description\n * Checks to see if the input string or Uint8Array is valid Utf8\n */\nexport function isUtf8(value) {\n    if (!value) {\n        return isString(value);\n    }\n    const u8a = u8aToU8a(value);\n    const len = u8a.length;\n    let i = 0;\n    while (i < len) {\n        if (u8a[i] <= 0x7F) /* 00..7F */ {\n            i += 1;\n        }\n        else if (u8a[i] >= 0xC2 && u8a[i] <= 0xDF) /* C2..DF 80..BF */ {\n            if (i + 1 < len) /* Expect a 2nd byte */ {\n                if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {\n                    // *message = \"After a first byte between C2 and DF, expecting a 2nd byte between 80 and BF\";\n                    // *faulty_bytes = 2;\n                    return false;\n                }\n            }\n            else {\n                // *message = \"After a first byte between C2 and DF, expecting a 2nd byte.\";\n                // *faulty_bytes = 1;\n                return false;\n            }\n            i += 2;\n        }\n        else if (u8a[i] === 0xE0) /* E0 A0..BF 80..BF */ {\n            if (i + 2 < len) /* Expect a 2nd and 3rd byte */ {\n                if (u8a[i + 1] < 0xA0 || u8a[i + 1] > 0xBF) {\n                    // *message = \"After a first byte of E0, expecting a 2nd byte between A0 and BF.\";\n                    // *faulty_bytes = 2;\n                    return false;\n                }\n                if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n                    // *message = \"After a first byte of E0, expecting a 3nd byte between 80 and BF.\";\n                    // *faulty_bytes = 3;\n                    return false;\n                }\n            }\n            else {\n                // *message = \"After a first byte of E0, expecting two following bytes.\";\n                // *faulty_bytes = 1;\n                return false;\n            }\n            i += 3;\n        }\n        else if (u8a[i] >= 0xE1 && u8a[i] <= 0xEC) /* E1..EC 80..BF 80..BF */ {\n            if (i + 2 < len) /* Expect a 2nd and 3rd byte */ {\n                if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {\n                    // *message = \"After a first byte between E1 and EC, expecting the 2nd byte between 80 and BF.\";\n                    // *faulty_bytes = 2;\n                    return false;\n                }\n                if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n                    // *message = \"After a first byte between E1 and EC, expecting the 3rd byte between 80 and BF.\";\n                    // *faulty_bytes = 3;\n                    return false;\n                }\n            }\n            else {\n                // *message = \"After a first byte between E1 and EC, expecting two following bytes.\";\n                // *faulty_bytes = 1;\n                return false;\n            }\n            i += 3;\n        }\n        else if (u8a[i] === 0xED) /* ED 80..9F 80..BF */ {\n            if (i + 2 < len) /* Expect a 2nd and 3rd byte */ {\n                if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0x9F) {\n                    // *message = \"After a first byte of ED, expecting 2nd byte between 80 and 9F.\";\n                    // *faulty_bytes = 2;\n                    return false;\n                }\n                if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n                    // *message = \"After a first byte of ED, expecting 3rd byte between 80 and BF.\";\n                    // *faulty_bytes = 3;\n                    return false;\n                }\n            }\n            else {\n                // *message = \"After a first byte of ED, expecting two following bytes.\";\n                // *faulty_bytes = 1;\n                return false;\n            }\n            i += 3;\n        }\n        else if (u8a[i] >= 0xEE && u8a[i] <= 0xEF) /* EE..EF 80..BF 80..BF */ {\n            if (i + 2 < len) /* Expect a 2nd and 3rd byte */ {\n                if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {\n                    // *message = \"After a first byte between EE and EF, expecting 2nd byte between 80 and BF.\";\n                    // *faulty_bytes = 2;\n                    return false;\n                }\n                if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n                    // *message = \"After a first byte between EE and EF, expecting 3rd byte between 80 and BF.\";\n                    // *faulty_bytes = 3;\n                    return false;\n                }\n            }\n            else {\n                // *message = \"After a first byte between EE and EF, two following bytes.\";\n                // *faulty_bytes = 1;\n                return false;\n            }\n            i += 3;\n        }\n        else if (u8a[i] === 0xF0) /* F0 90..BF 80..BF 80..BF */ {\n            if (i + 3 < len) /* Expect a 2nd, 3rd 3th byte */ {\n                if (u8a[i + 1] < 0x90 || u8a[i + 1] > 0xBF) {\n                    // *message = \"After a first byte of F0, expecting 2nd byte between 90 and BF.\";\n                    // *faulty_bytes = 2;\n                    return false;\n                }\n                if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n                    // *message = \"After a first byte of F0, expecting 3rd byte between 80 and BF.\";\n                    // *faulty_bytes = 3;\n                    return false;\n                }\n                if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) {\n                    // *message = \"After a first byte of F0, expecting 4th byte between 80 and BF.\";\n                    // *faulty_bytes = 4;\n                    return false;\n                }\n            }\n            else {\n                // *message = \"After a first byte of F0, expecting three following bytes.\";\n                // *faulty_bytes = 1;\n                return false;\n            }\n            i += 4;\n        }\n        else if (u8a[i] >= 0xF1 && u8a[i] <= 0xF3) /* F1..F3 80..BF 80..BF 80..BF */ {\n            if (i + 3 < len) /* Expect a 2nd, 3rd 3th byte */ {\n                if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {\n                    // *message = \"After a first byte of F1, F2, or F3, expecting a 2nd byte between 80 and BF.\";\n                    // *faulty_bytes = 2;\n                    return false;\n                }\n                if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n                    // *message = \"After a first byte of F1, F2, or F3, expecting a 3rd byte between 80 and BF.\";\n                    // *faulty_bytes = 3;\n                    return false;\n                }\n                if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) {\n                    // *message = \"After a first byte of F1, F2, or F3, expecting a 4th byte between 80 and BF.\";\n                    // *faulty_bytes = 4;\n                    return false;\n                }\n            }\n            else {\n                // *message = \"After a first byte of F1, F2, or F3, expecting three following bytes.\";\n                // *faulty_bytes = 1;\n                return false;\n            }\n            i += 4;\n        }\n        else if (u8a[i] === 0xF4) /* F4 80..8F 80..BF 80..BF */ {\n            if (i + 3 < len) /* Expect a 2nd, 3rd 3th byte */ {\n                if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0x8F) {\n                    // *message = \"After a first byte of F4, expecting 2nd byte between 80 and 8F.\";\n                    // *faulty_bytes = 2;\n                    return false;\n                }\n                if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n                    // *message = \"After a first byte of F4, expecting 3rd byte between 80 and BF.\";\n                    // *faulty_bytes = 3;\n                    return false;\n                }\n                if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) {\n                    // *message = \"After a first byte of F4, expecting 4th byte between 80 and BF.\";\n                    // *faulty_bytes = 4;\n                    return false;\n                }\n            }\n            else {\n                // *message = \"After a first byte of F4, expecting three following bytes.\";\n                // *faulty_bytes = 1;\n                return false;\n            }\n            i += 4;\n        }\n        else {\n            // *message = \"Expecting bytes in the following ranges: 00..7F C2..F4.\";\n            // *faulty_bytes = 1;\n            return false;\n        }\n    }\n    return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}