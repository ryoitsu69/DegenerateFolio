{"ast":null,"code":"import { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision.mjs';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines.mjs';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision.mjs';\nimport { insertVersion } from './program/preprocessors/insertVersion.mjs';\nimport { setProgramName } from './program/preprocessors/setProgramName.mjs';\nimport { stripVersion } from './program/preprocessors/stripVersion.mjs';\n\"use strict\";\nconst processes = {\n  // strips any version headers..\n  stripVersion,\n  // adds precision string if not already present\n  ensurePrecision,\n  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n  addProgramDefines,\n  // add the program name to the shader\n  setProgramName,\n  // add the version string to the shader header\n  insertVersion\n};\nconst programCache = /* @__PURE__ */Object.create(null);\nconst _GlProgram = class _GlProgram {\n  /**\n   * Creates a shiny new GlProgram. Used by WebGL renderer.\n   * @param options - The options for the program.\n   */\n  constructor(options) {\n    options = {\n      ..._GlProgram.defaultOptions,\n      ...options\n    };\n    const isES300 = options.fragment.indexOf(\"#version 300 es\") !== -1;\n    const preprocessorOptions = {\n      stripVersion: isES300,\n      ensurePrecision: {\n        requestedFragmentPrecision: options.preferredFragmentPrecision,\n        requestedVertexPrecision: options.preferredVertexPrecision,\n        maxSupportedVertexPrecision: \"highp\",\n        maxSupportedFragmentPrecision: getMaxFragmentPrecision()\n      },\n      setProgramName: {\n        name: options.name\n      },\n      addProgramDefines: isES300,\n      insertVersion: isES300\n    };\n    let fragment = options.fragment;\n    let vertex = options.vertex;\n    Object.keys(processes).forEach(processKey => {\n      const processOptions = preprocessorOptions[processKey];\n      fragment = processes[processKey](fragment, processOptions, true);\n      vertex = processes[processKey](vertex, processOptions, false);\n    });\n    this.fragment = fragment;\n    this.vertex = vertex;\n    this._key = createIdFromString(`${this.vertex}:${this.fragment}`, \"gl-program\");\n  }\n  /** destroys the program */\n  destroy() {\n    this.fragment = null;\n    this.vertex = null;\n    this._attributeData = null;\n    this._uniformData = null;\n    this._uniformBlockData = null;\n    this.transformFeedbackVaryings = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex}:${options.fragment}`;\n    if (!programCache[key]) {\n      programCache[key] = new _GlProgram(options);\n    }\n    return programCache[key];\n  }\n};\n/** The default options used by the program. */\n_GlProgram.defaultOptions = {\n  preferredVertexPrecision: \"highp\",\n  preferredFragmentPrecision: \"mediump\"\n};\nlet GlProgram = _GlProgram;\nexport { GlProgram };","map":{"version":3,"names":["processes","stripVersion","ensurePrecision","addProgramDefines","setProgramName","insertVersion","programCache","Object","create","_GlProgram","constructor","options","defaultOptions","isES300","fragment","indexOf","preprocessorOptions","requestedFragmentPrecision","preferredFragmentPrecision","requestedVertexPrecision","preferredVertexPrecision","maxSupportedVertexPrecision","maxSupportedFragmentPrecision","getMaxFragmentPrecision","name","vertex","keys","forEach","processKey","processOptions","_key","createIdFromString","destroy","_attributeData","_uniformData","_uniformBlockData","transformFeedbackVaryings","from","key","GlProgram"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gl/shader/GlProgram.ts"],"sourcesContent":["import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision';\nimport { insertVersion } from './program/preprocessors/insertVersion';\nimport { setProgramName } from './program/preprocessors/setProgramName';\nimport { stripVersion } from './program/preprocessors/stripVersion';\n\nimport type { TypedArray } from '../../shared/buffer/Buffer';\nimport type { ExtractedAttributeData } from './program/extractAttributesFromGlProgram';\n\nexport interface GlAttributeData\n{\n    type: string;\n    size: number;\n    location: number;\n    name: string;\n}\n\nexport interface GlUniformData\n{\n    name: string;\n    index: number;\n    type: string;\n    size: number;\n    isArray: boolean;\n    value: any;\n}\n\nexport interface GlUniformBlockData\n{\n    index: number;\n    name: string;\n    size: number;\n    value?: TypedArray;\n}\n\n/**\n * The options for the gl program\n * @memberof rendering\n */\nexport interface GlProgramOptions\n{\n    /** The fragment glsl shader source. */\n    fragment: string;\n    /** The vertex glsl shader source. */\n    vertex: string;\n    /** the name of the program, defaults to 'pixi-program' */\n    name?: string;\n    /** the preferred vertex precision for the shader, this may not be used if the device does not support it  */\n    preferredVertexPrecision?: string;\n    /** the preferred fragment precision for the shader, this may not be used if the device does not support it  */\n    preferredFragmentPrecision?: string;\n}\n\nconst processes: Record<string, ((source: string, options: any, isFragment?: boolean) => string)> = {\n    // strips any version headers..\n    stripVersion,\n    // adds precision string if not already present\n    ensurePrecision,\n    // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    addProgramDefines,\n    // add the program name to the shader\n    setProgramName,\n    // add the version string to the shader header\n    insertVersion,\n};\n\nconst programCache: Record<string, GlProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGL Program. You can create one and then pass it to a shader.\n * This will manage the WebGL program that is compiled and uploaded to the GPU.\n *\n * To get the most out of this class, you should be familiar with glsl shaders and how they work.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram\n * @example\n *\n * // Create a new program\n * const program = new GlProgram({\n *   vertex: '...',\n *   fragment: '...',\n * });\n *\n *\n * There are a few key things that pixi shader will do for you automatically:\n * <br>\n * - If no precision is provided in the shader, it will be injected into the program source for you.\n * This precision will be taken form the options provided, if none is provided,\n * then the program will default to the defaultOptions.\n * <br>\n * - It will inject the program name into the shader source if none is provided.\n * <br>\n *  - It will set the program version to 300 es.\n *\n * For optimal usage and best performance, its best to reuse programs as much as possible.\n * You should use the {@link GlProgram.from} helper function to create programs.\n * @class\n * @memberof rendering\n */\nexport class GlProgram\n{\n    /** The default options used by the program. */\n    public static defaultOptions: Partial<GlProgramOptions> = {\n        preferredVertexPrecision: 'highp',\n        preferredFragmentPrecision: 'mediump',\n    };\n\n    /** the fragment glsl shader source. */\n    public readonly fragment?: string;\n    /** the vertex glsl shader source */\n    public readonly vertex?: string;\n    /**\n     * attribute data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _attributeData: Record<string, ExtractedAttributeData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformData: Record<string, GlUniformData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformBlockData: Record<string, GlUniformBlockData>;\n    /** details on how to use this program with transform feedback */\n    public transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n    /**\n     * the key that identifies the program via its source vertex + fragment\n     * @internal\n     * @ignore\n     */\n    public readonly _key: number;\n\n    /**\n     * Creates a shiny new GlProgram. Used by WebGL renderer.\n     * @param options - The options for the program.\n     */\n    constructor(options: GlProgramOptions)\n    {\n        options = { ...GlProgram.defaultOptions, ...options };\n\n        // only need to check one as they both need to be the same or\n        // errors ensue!\n        const isES300 = options.fragment.indexOf('#version 300 es') !== -1;\n\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: 'highp',\n                maxSupportedFragmentPrecision: getMaxFragmentPrecision(),\n            },\n            setProgramName: {\n                name: options.name,\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n\n        Object.keys(processes).forEach((processKey) =>\n        {\n            const processOptions = preprocessorOptions[processKey as keyof typeof preprocessorOptions];\n\n            fragment = processes[processKey](fragment, processOptions, true);\n            vertex = processes[processKey](vertex, processOptions, false);\n        });\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, 'gl-program');\n    }\n\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n\n        this.transformFeedbackVaryings = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GlProgramOptions): GlProgram\n    {\n        const key = `${options.vertex}:${options.fragment}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GlProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n"],"mappings":";;;;;;;;AAuDA,MAAMA,SAA8F;EAAA;EAEhGC,YAAA;EAAA;EAEAC,eAAA;EAAA;EAEAC,iBAAA;EAAA;EAEAC,cAAA;EAAA;EAEAC;AACJ;AAEA,MAAMC,YAAA,kBAAiDC,MAAA,CAAAC,MAAA,CAAO,IAAI;AAgC3D,MAAMC,UAAA,GAAN,MAAMA,UACb;EAAA;AAAA;AAAA;AAAA;EA0CIC,YAAYC,OACZ;IACIA,OAAA,GAAU;MAAE,GAAGF,UAAU,CAAAG,cAAA;MAAgB,GAAGD;IAAQ;IAIpD,MAAME,OAAU,GAAAF,OAAA,CAAQG,QAAS,CAAAC,OAAA,CAAQ,iBAAiB,CAAM;IAEhE,MAAMC,mBAAsB;MACxBf,YAAc,EAAAY,OAAA;MACdX,eAAiB;QACbe,0BAAA,EAA4BN,OAAQ,CAAAO,0BAAA;QACpCC,wBAAA,EAA0BR,OAAQ,CAAAS,wBAAA;QAClCC,2BAA6B;QAC7BC,6BAAA,EAA+BC,uBAAwB;MAAA,CAC3D;MACAnB,cAAgB;QACZoB,IAAA,EAAMb,OAAQ,CAAAa;MAAA,CAClB;MACArB,iBAAmB,EAAAU,OAAA;MACnBR,aAAe,EAAAQ;IAAA,CACnB;IAEA,IAAIC,QAAA,GAAWH,OAAQ,CAAAG,QAAA;IACvB,IAAIW,MAAA,GAASd,OAAQ,CAAAc,MAAA;IAErBlB,MAAA,CAAOmB,IAAK,CAAA1B,SAAS,CAAE,CAAA2B,OAAA,CAASC,UAChC;MACU,MAAAC,cAAA,GAAiBb,mBAAA,CAAoBY,UAA8C;MAEzFd,QAAA,GAAWd,SAAU,CAAA4B,UAAU,CAAE,CAAAd,QAAA,EAAUe,cAAA,EAAgB,IAAI;MAC/DJ,MAAA,GAASzB,SAAU,CAAA4B,UAAU,CAAE,CAAAH,MAAA,EAAQI,cAAA,EAAgB,KAAK;IAAA,CAC/D;IAED,KAAKf,QAAW,GAAAA,QAAA;IAChB,KAAKW,MAAS,GAAAA,MAAA;IAET,KAAAK,IAAA,GAAOC,kBAAA,CAAsB,QAAKN,MAAU,SAAKX,QAAQ,IAAI,YAAY;EAAA;EAClF;EAGOkB,OACPA,CAAA;IACK,KAAKlB,QAAoB;IACzB,KAAKW,MAAkB;IAExB,KAAKQ,cAAiB;IACtB,KAAKC,YAAe;IACpB,KAAKC,iBAAoB;IAEzB,KAAKC,yBAA4B;EAAA;EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASA,OAAcC,KAAK1B,OACnB;IACI,MAAM2B,GAAA,GAAS,GAAA3B,OAAA,CAAQc,MAAM,IAAId,OAAA,CAAQG,QAAQ;IAE7C,KAACR,YAAa,CAAAgC,GAAG,CACrB;MACIhC,YAAA,CAAagC,GAAG,IAAI,IAAI7B,UAAA,CAAUE,OAAO;IAAA;IAG7C,OAAOL,YAAA,CAAagC,GAAG;EAAA;AAE/B;AAAA;AAlHa7B,UAAA,CAGKG,cAA4C;EACtDQ,wBAA0B;EAC1BF,0BAA4B;AAChC;AANG,IAAMqB,SAAN,GAAA9B,UAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}