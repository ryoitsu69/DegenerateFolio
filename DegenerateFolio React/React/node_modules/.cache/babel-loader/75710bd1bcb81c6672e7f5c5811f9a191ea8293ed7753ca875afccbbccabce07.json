{"ast":null,"code":"import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../filters/FilterEffect.mjs';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter.mjs';\nimport { Bounds } from '../../../scene/container/bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds.mjs';\nimport { collectAllRenderables } from '../../../scene/container/utils/buildInstructions.mjs';\nimport { Sprite } from '../../../scene/sprite/Sprite.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { Texture } from '../../renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool.mjs';\n\"use strict\";\nconst tempBounds = new Bounds();\nclass AlphaMaskEffect extends FilterEffect {\n  constructor() {\n    super();\n    this.filters = [new MaskFilter({\n      sprite: new Sprite(Texture.EMPTY)\n    })];\n  }\n  get sprite() {\n    return this.filters[0].sprite;\n  }\n  set sprite(value) {\n    this.filters[0].sprite = value;\n  }\n}\nclass AlphaMaskPipe {\n  constructor(renderer) {\n    this._activeMaskStage = [];\n    this._renderer = renderer;\n  }\n  push(mask, maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      canBundle: false,\n      maskedContainer\n    });\n    if (mask.renderMaskToTexture) {\n      const maskContainer = mask.mask;\n      maskContainer.includeInBuild = true;\n      collectAllRenderables(maskContainer, instructionSet, renderer.renderPipes);\n      maskContainer.includeInBuild = false;\n    }\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      maskedContainer,\n      canBundle: false\n    });\n  }\n  pop(mask, _maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"popMaskEnd\",\n      mask,\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    const renderMask = instruction.mask.renderMaskToTexture;\n    if (instruction.action === \"pushMaskBegin\") {\n      const filterEffect = BigPool.get(AlphaMaskEffect);\n      if (renderMask) {\n        instruction.mask.mask.measurable = true;\n        const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n        instruction.mask.mask.measurable = false;\n        bounds.ceil();\n        const filterTexture = TexturePool.getOptimalTexture(bounds.width, bounds.height, 1, false);\n        renderer.renderTarget.push(filterTexture, true);\n        renderer.globalUniforms.push({\n          offset: bounds,\n          worldColor: 4294967295\n        });\n        const sprite = filterEffect.sprite;\n        sprite.texture = filterTexture;\n        sprite.worldTransform.tx = bounds.minX;\n        sprite.worldTransform.ty = bounds.minY;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer,\n          filterTexture\n        });\n      } else {\n        filterEffect.sprite = instruction.mask.mask;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer\n        });\n      }\n    } else if (instruction.action === \"pushMaskEnd\") {\n      const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n      if (renderMask) {\n        renderer.renderTarget.pop();\n        renderer.globalUniforms.pop();\n      }\n      renderer.filter.push({\n        renderPipeId: \"filter\",\n        action: \"pushFilter\",\n        container: maskData.maskedContainer,\n        filterEffect: maskData.filterEffect,\n        canBundle: false\n      });\n    } else if (instruction.action === \"popMaskEnd\") {\n      renderer.filter.pop();\n      const maskData = this._activeMaskStage.pop();\n      if (renderMask) {\n        TexturePool.returnTexture(maskData.filterTexture);\n      }\n      BigPool.return(maskData.filterEffect);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n    this._activeMaskStage = null;\n  }\n}\n/** @ignore */\nAlphaMaskPipe.extension = {\n  type: [ExtensionType.WebGLPipes, ExtensionType.WebGPUPipes, ExtensionType.CanvasPipes],\n  name: \"alphaMask\"\n};\nexport { AlphaMaskPipe };","map":{"version":3,"names":["tempBounds","Bounds","AlphaMaskEffect","FilterEffect","constructor","filters","MaskFilter","sprite","Sprite","Texture","EMPTY","value","AlphaMaskPipe","renderer","_activeMaskStage","_renderer","push","mask","maskedContainer","instructionSet","renderPipes","batch","break","add","renderPipeId","action","canBundle","renderMaskToTexture","maskContainer","includeInBuild","collectAllRenderables","pop","_maskedContainer","execute","instruction","renderMask","filterEffect","BigPool","get","measurable","bounds","getGlobalBounds","ceil","filterTexture","TexturePool","getOptimalTexture","width","height","renderTarget","globalUniforms","offset","worldColor","texture","worldTransform","tx","minX","ty","minY","maskData","length","filter","container","returnTexture","return","destroy","extension","type","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","name"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/mask/alpha/AlphaMaskPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter';\nimport { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\nimport { collectAllRenderables } from '../../../scene/container/utils/buildInstructions';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { RenderTarget } from '../../renderers/shared/renderTarget/RenderTarget';\nimport type { Renderer } from '../../renderers/types';\nimport type { AlphaMask } from './AlphaMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nconst tempBounds = new Bounds();\n\nclass AlphaMaskEffect extends FilterEffect implements PoolItem\n{\n    constructor()\n    {\n        super();\n\n        this.filters = [new MaskFilter({\n            sprite: new Sprite(Texture.EMPTY)\n        })];\n    }\n\n    get sprite(): Sprite\n    {\n        return (this.filters[0] as MaskFilter).sprite;\n    }\n\n    set sprite(value: Sprite)\n    {\n        (this.filters[0] as MaskFilter).sprite = value;\n    }\n\n    public init: () => void;\n}\n\nexport interface AlphaMaskInstruction extends Instruction\n{\n    renderPipeId: 'alphaMask',\n    action: MaskMode,\n    mask: AlphaMask,\n    maskedContainer: Container,\n    renderMask: boolean,\n}\n\nexport interface AlphaMaskData\n{\n    filterEffect: AlphaMaskEffect,\n    maskedContainer: Container,\n    previousRenderTarget?: RenderTarget,\n    filterTexture?: Texture,\n}\n\nexport class AlphaMaskPipe implements InstructionPipe<AlphaMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'alphaMask',\n    } as const;\n\n    private _renderer: Renderer;\n    private _activeMaskStage: AlphaMaskData[] = [];\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskBegin',\n            mask,\n            canBundle: false,\n            maskedContainer\n        } as AlphaMaskInstruction);\n\n        if ((mask as AlphaMask).renderMaskToTexture)\n        {\n            const maskContainer = (mask as AlphaMask).mask;\n\n            maskContainer.includeInBuild = true;\n\n            collectAllRenderables(\n                maskContainer,\n                instructionSet,\n                renderer.renderPipes\n            );\n\n            maskContainer.includeInBuild = false;\n        }\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskEnd',\n            mask,\n            maskedContainer,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public pop(mask: Effect, _maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'popMaskEnd',\n            mask,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public execute(instruction: AlphaMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderMask = instruction.mask.renderMaskToTexture;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            const filterEffect = BigPool.get(AlphaMaskEffect);\n\n            if (renderMask)\n            {\n                instruction.mask.mask.measurable = true;\n\n                const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n\n                instruction.mask.mask.measurable = false;\n\n                bounds.ceil();\n\n                const filterTexture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    1,\n                    false\n                );\n\n                renderer.renderTarget.push(filterTexture, true);\n\n                renderer.globalUniforms.push({\n                    offset: bounds,\n                    worldColor: 0xFFFFFFFF\n                });\n\n                const sprite = filterEffect.sprite;\n\n                sprite.texture = filterTexture;\n\n                sprite.worldTransform.tx = bounds.minX;\n                sprite.worldTransform.ty = bounds.minY;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                    filterTexture,\n                });\n            }\n            else\n            {\n                filterEffect.sprite = instruction.mask.mask as Sprite;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                });\n            }\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n\n            if (renderMask)\n            {\n                renderer.renderTarget.pop();\n                renderer.globalUniforms.pop();\n            }\n\n            renderer.filter.push({\n                renderPipeId: 'filter',\n                action: 'pushFilter',\n                container: maskData.maskedContainer,\n                filterEffect: maskData.filterEffect,\n                canBundle: false,\n            });\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            renderer.filter.pop();\n\n            const maskData = this._activeMaskStage.pop();\n\n            if (renderMask)\n            {\n                TexturePool.returnTexture(maskData.filterTexture);\n            }\n\n            BigPool.return(maskData.filterEffect);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._activeMaskStage = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}