{"ast":null,"code":"/**\n * @name u8aToNumber\n * @summary Creates a number from a Uint8Array object.\n */\nexport function u8aToNumber(value, {\n  isLe = true,\n  isNegative = false\n} = {}) {\n  // slice + reverse is expensive, however SCALE is LE by default so this is the path\n  // we are most interested in (the BE is added for the sake of being comprehensive)\n  if (!isLe) {\n    value = value.slice().reverse();\n  }\n  const count = value.length;\n  // When the value is a i{8, 16, 24, 32, 40, 40} values and the top-most bit\n  // indicates a signed value, we use a two's complement conversion. If one of these\n  // flags are not set, we just do a normal unsigned conversion (the same shortcut\n  // applies in both the u8aTo{BigInt, Bn} conversions as well)\n  if (isNegative && count && value[count - 1] & 0x80) {\n    switch (count) {\n      case 0:\n        return 0;\n      case 1:\n        return (value[0] ^ 255) * -1 - 1;\n      case 2:\n        return (value[0] + (value[1] << 8) ^ 65535) * -1 - 1;\n      case 3:\n        return (value[0] + (value[1] << 8) + (value[2] << 16) ^ 16777215) * -1 - 1;\n      case 4:\n        // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n        // 32-bit, in the case where the top-most bit is set this yields a negative value\n        return (value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) * -1 - 1;\n      case 5:\n        return ((value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) + (value[4] ^ 0xff) * 4294967296) * -1 - 1;\n      case 6:\n        return ((value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) + (value[4] + (value[5] << 8) ^ 65535) * 4294967296) * -1 - 1;\n      default:\n        throw new Error('Value more than 48-bits cannot be reliably converted');\n    }\n  }\n  switch (count) {\n    case 0:\n      return 0;\n    case 1:\n      return value[0];\n    case 2:\n      return value[0] + (value[1] << 8);\n    case 3:\n      return value[0] + (value[1] << 8) + (value[2] << 16);\n    case 4:\n      // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n      // 32-bit, in the case where the top-most bit is set this yields a negative value\n      return value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216;\n    case 5:\n      return value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8)) * 16777216;\n    case 6:\n      return value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8) + (value[5] << 16)) * 16777216;\n    default:\n      throw new Error('Value more than 48-bits cannot be reliably converted');\n  }\n}","map":{"version":3,"names":["u8aToNumber","value","isLe","isNegative","slice","reverse","count","length","Error"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util/u8a/toNumber.js"],"sourcesContent":["/**\n * @name u8aToNumber\n * @summary Creates a number from a Uint8Array object.\n */\nexport function u8aToNumber(value, { isLe = true, isNegative = false } = {}) {\n    // slice + reverse is expensive, however SCALE is LE by default so this is the path\n    // we are most interested in (the BE is added for the sake of being comprehensive)\n    if (!isLe) {\n        value = value.slice().reverse();\n    }\n    const count = value.length;\n    // When the value is a i{8, 16, 24, 32, 40, 40} values and the top-most bit\n    // indicates a signed value, we use a two's complement conversion. If one of these\n    // flags are not set, we just do a normal unsigned conversion (the same shortcut\n    // applies in both the u8aTo{BigInt, Bn} conversions as well)\n    if (isNegative && count && (value[count - 1] & 0x80)) {\n        switch (count) {\n            case 0:\n                return 0;\n            case 1:\n                return (((value[0] ^ 255) * -1) - 1);\n            case 2:\n                return ((((value[0] + (value[1] << 8)) ^ 65535) * -1) - 1);\n            case 3:\n                return ((((value[0] + (value[1] << 8) + (value[2] << 16)) ^ 16777215) * -1) - 1);\n            case 4:\n                // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n                // 32-bit, in the case where the top-most bit is set this yields a negative value\n                return ((((value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216)) ^ 4294967295) * -1) - 1);\n            case 5:\n                return (((((value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216)) ^ 4294967295) + ((value[4] ^ 0xff) * 4294967296)) * -1) - 1);\n            case 6:\n                return (((((value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216)) ^ 4294967295) + (((value[4] + (value[5] << 8)) ^ 65535) * 4294967296)) * -1) - 1);\n            default:\n                throw new Error('Value more than 48-bits cannot be reliably converted');\n        }\n    }\n    switch (count) {\n        case 0:\n            return 0;\n        case 1:\n            return value[0];\n        case 2:\n            return value[0] + (value[1] << 8);\n        case 3:\n            return value[0] + (value[1] << 8) + (value[2] << 16);\n        case 4:\n            // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n            // 32-bit, in the case where the top-most bit is set this yields a negative value\n            return value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216);\n        case 5:\n            return value[0] + (value[1] << 8) + (value[2] << 16) + ((value[3] + (value[4] << 8)) * 16777216);\n        case 6:\n            return value[0] + (value[1] << 8) + (value[2] << 16) + ((value[3] + (value[4] << 8) + (value[5] << 16)) * 16777216);\n        default:\n            throw new Error('Value more than 48-bits cannot be reliably converted');\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}