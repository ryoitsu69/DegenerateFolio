{"ast":null,"code":"import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Texture } from '../../shared/texture/Texture.mjs';\nimport { GlTexture } from './GlTexture.mjs';\nimport { glUploadBufferImageResource } from './uploaders/glUploadBufferImageResource.mjs';\nimport { glUploadCompressedTextureResource } from './uploaders/glUploadCompressedTextureResource.mjs';\nimport { glUploadImageResource } from './uploaders/glUploadImageResource.mjs';\nimport { glUploadVideoResource } from './uploaders/glUploadVideoResource.mjs';\nimport { applyStyleParams } from './utils/applyStyleParams.mjs';\nimport { mapFormatToGlFormat } from './utils/mapFormatToGlFormat.mjs';\nimport { mapFormatToGlInternalFormat } from './utils/mapFormatToGlInternalFormat.mjs';\nimport { mapFormatToGlType } from './utils/mapFormatToGlType.mjs';\nimport './utils/unpremultiplyAlpha.mjs';\n\"use strict\";\nconst BYTES_PER_PIXEL = 4;\nclass GlTextureSystem {\n  constructor(renderer) {\n    this.managedTextures = [];\n    this._glTextures = /* @__PURE__ */Object.create(null);\n    this._glSamplers = /* @__PURE__ */Object.create(null);\n    this._boundTextures = [];\n    this._activeTextureLocation = -1;\n    this._boundSamplers = /* @__PURE__ */Object.create(null);\n    this._uploads = {\n      image: glUploadImageResource,\n      buffer: glUploadBufferImageResource,\n      video: glUploadVideoResource,\n      compressed: glUploadCompressedTextureResource\n    };\n    // TODO - separate samplers will be a cool thing to add, but not right now!\n    this._useSeparateSamplers = false;\n    this._renderer = renderer;\n  }\n  contextChange(gl) {\n    this._gl = gl;\n    if (!this._mapFormatToInternalFormat) {\n      this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);\n      this._mapFormatToType = mapFormatToGlType(gl);\n      this._mapFormatToFormat = mapFormatToGlFormat(gl);\n    }\n    this._glTextures = /* @__PURE__ */Object.create(null);\n    this._glSamplers = /* @__PURE__ */Object.create(null);\n    this._boundSamplers = /* @__PURE__ */Object.create(null);\n    for (let i = 0; i < 16; i++) {\n      this.bind(Texture.EMPTY, i);\n    }\n  }\n  initSource(source) {\n    this.bind(source);\n  }\n  bind(texture, location = 0) {\n    const source = texture.source;\n    if (texture) {\n      this.bindSource(source, location);\n      if (this._useSeparateSamplers) {\n        this._bindSampler(source.style, location);\n      }\n    } else {\n      this.bindSource(null, location);\n      if (this._useSeparateSamplers) {\n        this._bindSampler(null, location);\n      }\n    }\n  }\n  bindSource(source, location = 0) {\n    const gl = this._gl;\n    source._touched = this._renderer.textureGC.count;\n    if (this._boundTextures[location] !== source) {\n      this._boundTextures[location] = source;\n      this._activateLocation(location);\n      source = source || Texture.EMPTY.source;\n      const glTexture = this.getGlSource(source);\n      gl.bindTexture(glTexture.target, glTexture.texture);\n    }\n  }\n  _bindSampler(style, location = 0) {\n    const gl = this._gl;\n    if (!style) {\n      this._boundSamplers[location] = null;\n      gl.bindSampler(location, null);\n      return;\n    }\n    const sampler = this._getGlSampler(style);\n    if (this._boundSamplers[location] !== sampler) {\n      this._boundSamplers[location] = sampler;\n      gl.bindSampler(location, sampler);\n    }\n  }\n  unbind(texture) {\n    const source = texture.source;\n    const boundTextures = this._boundTextures;\n    const gl = this._gl;\n    for (let i = 0; i < boundTextures.length; i++) {\n      if (boundTextures[i] === source) {\n        this._activateLocation(i);\n        const glTexture = this.getGlSource(source);\n        gl.bindTexture(glTexture.target, null);\n        boundTextures[i] = null;\n      }\n    }\n  }\n  _activateLocation(location) {\n    if (this._activeTextureLocation !== location) {\n      this._activeTextureLocation = location;\n      this._gl.activeTexture(this._gl.TEXTURE0 + location);\n    }\n  }\n  _initSource(source) {\n    const gl = this._gl;\n    const glTexture = new GlTexture(gl.createTexture());\n    glTexture.type = this._mapFormatToType[source.format];\n    glTexture.internalFormat = this._mapFormatToInternalFormat[source.format];\n    glTexture.format = this._mapFormatToFormat[source.format];\n    if (source.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source.isPowerOfTwo)) {\n      const biggestDimension = Math.max(source.width, source.height);\n      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n    }\n    this._glTextures[source.uid] = glTexture;\n    if (!this.managedTextures.includes(source)) {\n      source.on(\"update\", this.onSourceUpdate, this);\n      source.on(\"resize\", this.onSourceUpdate, this);\n      source.on(\"styleChange\", this.onStyleChange, this);\n      source.on(\"destroy\", this.onSourceDestroy, this);\n      source.on(\"unload\", this.onSourceUnload, this);\n      source.on(\"updateMipmaps\", this.onUpdateMipmaps, this);\n      this.managedTextures.push(source);\n    }\n    this.onSourceUpdate(source);\n    this.updateStyle(source, false);\n    return glTexture;\n  }\n  onStyleChange(source) {\n    this.updateStyle(source, false);\n  }\n  updateStyle(source, firstCreation) {\n    const gl = this._gl;\n    const glTexture = this.getGlSource(source);\n    gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n    this._boundTextures[this._activeTextureLocation] = source;\n    applyStyleParams(source.style, gl, source.mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, \"texParameteri\", gl.TEXTURE_2D,\n    // will force a clamp to edge if the texture is not a power of two\n    !this._renderer.context.supports.nonPowOf2wrapping && !source.isPowerOfTwo, firstCreation);\n  }\n  onSourceUnload(source) {\n    const glTexture = this._glTextures[source.uid];\n    if (!glTexture) return;\n    this.unbind(source);\n    this._glTextures[source.uid] = null;\n    this._gl.deleteTexture(glTexture.texture);\n  }\n  onSourceUpdate(source) {\n    const gl = this._gl;\n    const glTexture = this.getGlSource(source);\n    gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n    this._boundTextures[this._activeTextureLocation] = source;\n    if (this._uploads[source.uploadMethodId]) {\n      this._uploads[source.uploadMethodId].upload(source, glTexture, gl, this._renderer.context.webGLVersion);\n    } else {\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.pixelWidth, source.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    }\n    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {\n      this.onUpdateMipmaps(source, false);\n    }\n  }\n  onUpdateMipmaps(source, bind = true) {\n    if (bind) this.bindSource(source, 0);\n    const glTexture = this.getGlSource(source);\n    this._gl.generateMipmap(glTexture.target);\n  }\n  onSourceDestroy(source) {\n    source.off(\"destroy\", this.onSourceDestroy, this);\n    source.off(\"update\", this.onSourceUpdate, this);\n    source.off(\"resize\", this.onSourceUpdate, this);\n    source.off(\"unload\", this.onSourceUnload, this);\n    source.off(\"styleChange\", this.onStyleChange, this);\n    source.off(\"updateMipmaps\", this.onUpdateMipmaps, this);\n    this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n    this.onSourceUnload(source);\n  }\n  _initSampler(style) {\n    const gl = this._gl;\n    const glSampler = this._gl.createSampler();\n    this._glSamplers[style._resourceId] = glSampler;\n    applyStyleParams(style, gl, this._boundTextures[this._activeTextureLocation].mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, \"samplerParameteri\", glSampler, false, true);\n    return this._glSamplers[style._resourceId];\n  }\n  _getGlSampler(sampler) {\n    return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);\n  }\n  getGlSource(source) {\n    return this._glTextures[source.uid] || this._initSource(source);\n  }\n  generateCanvas(texture) {\n    const {\n      pixels,\n      width,\n      height\n    } = this.getPixels(texture);\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext(\"2d\");\n    if (ctx) {\n      const imageData = ctx.createImageData(width, height);\n      imageData.data.set(pixels);\n      ctx.putImageData(imageData, 0, 0);\n    }\n    return canvas;\n  }\n  getPixels(texture) {\n    const resolution = texture.source.resolution;\n    const frame = texture.frame;\n    const width = Math.max(Math.round(frame.width * resolution), 1);\n    const height = Math.max(Math.round(frame.height * resolution), 1);\n    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n    const renderer = this._renderer;\n    const renderTarget = renderer.renderTarget.getRenderTarget(texture);\n    const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);\n    const gl = renderer.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);\n    gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n    if (false) {\n      unpremultiplyAlpha(pixels);\n    }\n    return {\n      pixels: new Uint8ClampedArray(pixels.buffer),\n      width,\n      height\n    };\n  }\n  destroy() {\n    this.managedTextures.slice().forEach(source => this.onSourceDestroy(source));\n    this.managedTextures = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGlTextureSystem.extension = {\n  type: [ExtensionType.WebGLSystem],\n  name: \"texture\"\n};\nexport { GlTextureSystem };","map":{"version":3,"names":["BYTES_PER_PIXEL","GlTextureSystem","constructor","renderer","managedTextures","_glTextures","Object","create","_glSamplers","_boundTextures","_activeTextureLocation","_boundSamplers","_uploads","image","glUploadImageResource","buffer","glUploadBufferImageResource","video","glUploadVideoResource","compressed","glUploadCompressedTextureResource","_useSeparateSamplers","_renderer","contextChange","gl","_gl","_mapFormatToInternalFormat","mapFormatToGlInternalFormat","context","extensions","_mapFormatToType","mapFormatToGlType","_mapFormatToFormat","mapFormatToGlFormat","i","bind","Texture","EMPTY","initSource","source","texture","location","bindSource","_bindSampler","style","_touched","textureGC","count","_activateLocation","glTexture","getGlSource","bindTexture","target","bindSampler","sampler","_getGlSampler","unbind","boundTextures","length","activeTexture","TEXTURE0","_initSource","GlTexture","createTexture","type","format","internalFormat","autoGenerateMipmaps","supports","nonPowOf2mipmaps","isPowerOfTwo","biggestDimension","Math","max","width","height","mipLevelCount","floor","log2","uid","includes","on","onSourceUpdate","onStyleChange","onSourceDestroy","onSourceUnload","onUpdateMipmaps","push","updateStyle","firstCreation","TEXTURE_2D","applyStyleParams","anisotropicFiltering","nonPowOf2wrapping","deleteTexture","uploadMethodId","upload","webGLVersion","texImage2D","RGBA","pixelWidth","pixelHeight","UNSIGNED_BYTE","generateMipmap","off","splice","indexOf","_initSampler","glSampler","createSampler","_resourceId","generateCanvas","pixels","getPixels","canvas","DOMAdapter","get","createCanvas","ctx","getContext","imageData","createImageData","data","set","putImageData","resolution","frame","round","Uint8Array","renderTarget","getRenderTarget","glRenterTarget","getGpuRenderTarget","bindFramebuffer","FRAMEBUFFER","resolveTargetFramebuffer","readPixels","x","y","unpremultiplyAlpha","Uint8ClampedArray","destroy","slice","forEach","extension","ExtensionType","WebGLSystem","name"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gl/texture/GlTextureSystem.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Texture } from '../../shared/texture/Texture';\nimport { GlTexture } from './GlTexture';\nimport { glUploadBufferImageResource } from './uploaders/glUploadBufferImageResource';\nimport { glUploadCompressedTextureResource } from './uploaders/glUploadCompressedTextureResource';\nimport { glUploadImageResource } from './uploaders/glUploadImageResource';\nimport { glUploadVideoResource } from './uploaders/glUploadVideoResource';\nimport { applyStyleParams } from './utils/applyStyleParams';\nimport { mapFormatToGlFormat } from './utils/mapFormatToGlFormat';\nimport { mapFormatToGlInternalFormat } from './utils/mapFormatToGlInternalFormat';\nimport { mapFormatToGlType } from './utils/mapFormatToGlType';\nimport { unpremultiplyAlpha } from './utils/unpremultiplyAlpha';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { BindableTexture } from '../../shared/texture/Texture';\nimport type { TextureStyle } from '../../shared/texture/TextureStyle';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GLTextureUploader } from './uploaders/GLTextureUploader';\n\nconst BYTES_PER_PIXEL = 4;\n\n/**\n * The system for managing textures in WebGL.\n * @memberof rendering\n */\nexport class GlTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    public readonly managedTextures: TextureSource[] = [];\n\n    private readonly _renderer: WebGLRenderer;\n\n    private _glTextures: Record<number, GlTexture> = Object.create(null);\n    private _glSamplers: Record<string, WebGLSampler> = Object.create(null);\n\n    private _boundTextures: TextureSource[] = [];\n    private _activeTextureLocation = -1;\n\n    private _boundSamplers: Record<number, WebGLSampler> = Object.create(null);\n\n    private readonly _uploads: Record<string, GLTextureUploader> = {\n        image: glUploadImageResource,\n        buffer: glUploadBufferImageResource,\n        video: glUploadVideoResource,\n        compressed: glUploadCompressedTextureResource,\n    };\n\n    private _gl: GlRenderingContext;\n    private _mapFormatToInternalFormat: Record<string, number>;\n    private _mapFormatToType: Record<string, number>;\n    private _mapFormatToFormat: Record<string, number>;\n\n    // TODO - separate samplers will be a cool thing to add, but not right now!\n    private readonly _useSeparateSamplers = false;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this._gl = gl;\n\n        if (!this._mapFormatToInternalFormat)\n        {\n            this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);\n\n            this._mapFormatToType = mapFormatToGlType(gl);\n            this._mapFormatToFormat = mapFormatToGlFormat(gl);\n        }\n\n        this._glTextures = Object.create(null);\n        this._glSamplers = Object.create(null);\n        this._boundSamplers = Object.create(null);\n\n        for (let i = 0; i < 16; i++)\n        {\n            this.bind(Texture.EMPTY, i);\n        }\n    }\n\n    public initSource(source: TextureSource)\n    {\n        this.bind(source);\n    }\n\n    public bind(texture: BindableTexture, location = 0)\n    {\n        const source = texture.source;\n\n        if (texture)\n        {\n            this.bindSource(source, location);\n\n            if (this._useSeparateSamplers)\n            {\n                this._bindSampler(source.style, location);\n            }\n        }\n        else\n        {\n            this.bindSource(null, location);\n\n            if (this._useSeparateSamplers)\n            {\n                this._bindSampler(null, location);\n            }\n        }\n    }\n\n    public bindSource(source: TextureSource, location = 0): void\n    {\n        const gl = this._gl;\n\n        source._touched = this._renderer.textureGC.count;\n\n        if (this._boundTextures[location] !== source)\n        {\n            this._boundTextures[location] = source;\n            this._activateLocation(location);\n\n            source = source || Texture.EMPTY.source;\n\n            // bind texture and source!\n            const glTexture = this.getGlSource(source);\n\n            gl.bindTexture(glTexture.target, glTexture.texture);\n        }\n    }\n\n    private _bindSampler(style: TextureStyle, location = 0): void\n    {\n        const gl = this._gl;\n\n        if (!style)\n        {\n            this._boundSamplers[location] = null;\n            gl.bindSampler(location, null);\n\n            return;\n        }\n\n        const sampler = this._getGlSampler(style);\n\n        if (this._boundSamplers[location] !== sampler)\n        {\n            this._boundSamplers[location] = sampler;\n            gl.bindSampler(location, sampler);\n        }\n    }\n\n    public unbind(texture: BindableTexture): void\n    {\n        const source = texture.source;\n        const boundTextures = this._boundTextures;\n        const gl = this._gl;\n\n        for (let i = 0; i < boundTextures.length; i++)\n        {\n            if (boundTextures[i] === source)\n            {\n                this._activateLocation(i);\n\n                const glTexture = this.getGlSource(source);\n\n                gl.bindTexture(glTexture.target, null);\n                boundTextures[i] = null;\n            }\n        }\n    }\n\n    private _activateLocation(location: number): void\n    {\n        if (this._activeTextureLocation !== location)\n        {\n            this._activeTextureLocation = location;\n            this._gl.activeTexture(this._gl.TEXTURE0 + location);\n        }\n    }\n\n    private _initSource(source: TextureSource): GlTexture\n    {\n        const gl = this._gl;\n\n        const glTexture = new GlTexture(gl.createTexture());\n\n        glTexture.type = this._mapFormatToType[source.format];\n        glTexture.internalFormat = this._mapFormatToInternalFormat[source.format];\n        glTexture.format = this._mapFormatToFormat[source.format];\n\n        if (source.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source.isPowerOfTwo))\n        {\n            const biggestDimension = Math.max(source.width, source.height);\n\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n\n        this._glTextures[source.uid] = glTexture;\n\n        if (!this.managedTextures.includes(source))\n        {\n            source.on('update', this.onSourceUpdate, this);\n            source.on('resize', this.onSourceUpdate, this);\n            source.on('styleChange', this.onStyleChange, this);\n            source.on('destroy', this.onSourceDestroy, this);\n            source.on('unload', this.onSourceUnload, this);\n            source.on('updateMipmaps', this.onUpdateMipmaps, this);\n\n            this.managedTextures.push(source);\n        }\n\n        this.onSourceUpdate(source);\n        this.updateStyle(source, false);\n\n        return glTexture;\n    }\n\n    protected onStyleChange(source: TextureSource): void\n    {\n        this.updateStyle(source, false);\n    }\n\n    protected updateStyle(source: TextureSource, firstCreation: boolean): void\n    {\n        const gl = this._gl;\n\n        const glTexture = this.getGlSource(source);\n\n        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n\n        this._boundTextures[this._activeTextureLocation] = source;\n\n        applyStyleParams(\n            source.style,\n            gl,\n            source.mipLevelCount > 1,\n            this._renderer.context.extensions.anisotropicFiltering,\n            'texParameteri',\n            gl.TEXTURE_2D,\n            // will force a clamp to edge if the texture is not a power of two\n            !this._renderer.context.supports.nonPowOf2wrapping && !source.isPowerOfTwo,\n            firstCreation,\n        );\n    }\n\n    protected onSourceUnload(source: TextureSource): void\n    {\n        const glTexture = this._glTextures[source.uid];\n\n        if (!glTexture) return;\n\n        this.unbind(source);\n        this._glTextures[source.uid] = null;\n\n        this._gl.deleteTexture(glTexture.texture);\n    }\n\n    protected onSourceUpdate(source: TextureSource): void\n    {\n        const gl = this._gl;\n\n        const glTexture = this.getGlSource(source);\n\n        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n\n        this._boundTextures[this._activeTextureLocation] = source;\n\n        if (this._uploads[source.uploadMethodId])\n        {\n            this._uploads[source.uploadMethodId].upload(source, glTexture, gl, this._renderer.context.webGLVersion);\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.pixelWidth, source.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1)\n        {\n            this.onUpdateMipmaps(source, false);\n        }\n    }\n\n    protected onUpdateMipmaps(source: TextureSource, bind = true): void\n    {\n        if (bind) this.bindSource(source, 0);\n\n        const glTexture = this.getGlSource(source);\n\n        this._gl.generateMipmap(glTexture.target);\n    }\n\n    protected onSourceDestroy(source: TextureSource): void\n    {\n        source.off('destroy', this.onSourceDestroy, this);\n        source.off('update', this.onSourceUpdate, this);\n        source.off('resize', this.onSourceUpdate, this);\n        source.off('unload', this.onSourceUnload, this);\n        source.off('styleChange', this.onStyleChange, this);\n        source.off('updateMipmaps', this.onUpdateMipmaps, this);\n\n        this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n\n        this.onSourceUnload(source);\n    }\n\n    private _initSampler(style: TextureStyle): WebGLSampler\n    {\n        const gl = this._gl;\n\n        const glSampler = this._gl.createSampler();\n\n        this._glSamplers[style._resourceId] = glSampler;\n\n        applyStyleParams(\n            style,\n            gl,\n            this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,\n            this._renderer.context.extensions.anisotropicFiltering,\n            'samplerParameteri',\n            glSampler,\n            false,\n            true,\n        );\n\n        return this._glSamplers[style._resourceId];\n    }\n\n    private _getGlSampler(sampler: TextureStyle): WebGLSampler\n    {\n        return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n\n    public getGlSource(source: TextureSource): GlTexture\n    {\n        return this._glTextures[source.uid] || this._initSource(source);\n    }\n\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const { pixels, width, height } = this.getPixels(texture);\n\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = width;\n        canvas.height = height;\n\n        const ctx = canvas.getContext('2d');\n\n        if (ctx)\n        {\n            const imageData = ctx.createImageData(width, height);\n\n            imageData.data.set(pixels);\n            ctx.putImageData(imageData, 0, 0);\n        }\n\n        return canvas;\n    }\n\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const resolution = texture.source.resolution;\n        const frame = texture.frame;\n\n        const width = Math.max(Math.round(frame.width * resolution), 1);\n        const height = Math.max(Math.round(frame.height * resolution), 1);\n        const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n        const renderer = this._renderer;\n\n        const renderTarget = renderer.renderTarget.getRenderTarget(texture);\n        const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);\n\n        const gl = renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);\n\n        gl.readPixels(\n            Math.round(frame.x * resolution),\n            Math.round(frame.y * resolution),\n            width,\n            height,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            pixels\n        );\n\n        // if (texture.source.premultiplyAlpha > 0)\n        // TODO - premultiplied alpha does not exist right now, need to add that back in!\n        // eslint-disable-next-line no-constant-condition\n        if (false)\n        {\n            unpremultiplyAlpha(pixels);\n        }\n\n        return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };\n    }\n\n    public destroy(): void\n    {\n        // we copy the array as the array with a slice as onSourceDestroy\n        // will remove the source from the real managedTextures array\n        this.managedTextures\n            .slice()\n            .forEach((source) => this.onSourceDestroy(source));\n\n        (this.managedTextures as null) = null;\n\n        (this._renderer as null) = null;\n    }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}