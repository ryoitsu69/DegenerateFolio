{"ast":null,"code":"import { Buffer } from 'buffer';\nimport * as nacl from './nacl/naclWrappers';\nimport * as address from './encoding/address';\nimport * as encoding from './encoding/encoding';\nimport * as txnBuilder from './transaction';\nimport * as utils from './utils/utils';\n/**\n Utilities for manipulating multisig transaction blobs.\n */\nexport const MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = 'Not enough multisig transactions to merge. Need at least two';\nexport const MULTISIG_MERGE_MISMATCH_ERROR_MSG = 'Cannot merge txs. txIDs differ';\nexport const MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG = 'Cannot merge txs. Auth addrs differ';\nexport const MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = 'Cannot merge txs. Multisig preimages differ';\nexport const MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = 'Cannot merge txs. subsigs are mismatched.';\nconst MULTISIG_KEY_NOT_EXIST_ERROR_MSG = 'Key does not exist';\nexport const MULTISIG_NO_MUTATE_ERROR_MSG = 'Cannot mutate a multisig field as it would invalidate all existing signatures.';\nexport const MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG = 'Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.';\nexport const MULTISIG_SIGNATURE_LENGTH_ERROR_MSG = 'Cannot add multisig signature. Signature is not of the correct length.';\n/**\n * createMultisigTransaction creates a raw, unsigned multisig transaction blob.\n * @param txn - the actual transaction.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nexport function createMultisigTransaction(txn, _ref) {\n  let {\n    version,\n    threshold,\n    addrs\n  } = _ref;\n  // construct the appendable multisigned transaction format\n  const pks = addrs.map(addr => address.decodeAddress(addr).publicKey);\n  const subsigs = pks.map(pk => ({\n    pk: Buffer.from(pk)\n  }));\n  const msig = {\n    v: version,\n    thr: threshold,\n    subsig: subsigs\n  };\n  const txnForEncoding = txn.get_obj_for_encoding();\n  const signedTxn = {\n    msig,\n    txn: txnForEncoding\n  };\n  // if the address of this multisig is different from the transaction sender,\n  // we need to add the auth-addr field\n  const msigAddr = address.fromMultisigPreImg({\n    version,\n    threshold,\n    pks\n  });\n  if (address.encodeAddress(txnForEncoding.snd) !== address.encodeAddress(msigAddr)) {\n    signedTxn.sgnr = Buffer.from(msigAddr);\n  }\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n/**\n * createMultisigTransactionWithSignature creates a multisig transaction blob with an included signature.\n * @param txn - the actual transaction to sign.\n * @param rawSig - a Buffer raw signature of that transaction\n * @param myPk - a public key that corresponds with rawSig\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nfunction createMultisigTransactionWithSignature(txn, _ref2, _ref3) {\n  let {\n    rawSig,\n    myPk\n  } = _ref2;\n  let {\n    version,\n    threshold,\n    pks\n  } = _ref3;\n  // Create an empty encoded multisig transaction\n  const encodedMsig = createMultisigTransaction(txn, {\n    version,\n    threshold,\n    addrs: pks.map(pk => address.encodeAddress(pk))\n  });\n  // note: this is not signed yet, but will be shortly\n  const signedTxn = encoding.decode(encodedMsig);\n  let keyExist = false;\n  // append the multisig signature to the corresponding public key in the multisig blob\n  signedTxn.msig.subsig.forEach((subsig, i) => {\n    if (nacl.bytesEqual(subsig.pk, myPk)) {\n      keyExist = true;\n      signedTxn.msig.subsig[i].s = rawSig;\n    }\n  });\n  if (keyExist === false) {\n    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);\n  }\n  // if the address of this multisig is different from the transaction sender,\n  // we need to add the auth-addr field\n  const msigAddr = address.fromMultisigPreImg({\n    version,\n    threshold,\n    pks\n  });\n  if (address.encodeAddress(signedTxn.txn.snd) !== address.encodeAddress(msigAddr)) {\n    signedTxn.sgnr = Buffer.from(msigAddr);\n  }\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n/**\n * MultisigTransaction is a Transaction that also supports creating partially-signed multisig transactions.\n */\nexport class MultisigTransaction extends txnBuilder.Transaction {\n  /* eslint-disable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */\n  /**\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\n   */\n  addLease() {\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n  }\n  /**\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\n   */\n  addRekey() {\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n  }\n  signTxn(sk) {\n    throw new Error(MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG);\n  }\n  /* eslint-enable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */\n  /**\n   * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,\n   * encoded with msgpack as a typed array.\n   * @param version - multisig version\n   * @param threshold - multisig threshold\n   * @param pks - multisig public key list, order is important.\n   * @param sk - an Algorand secret key to sign with.\n   * @returns an encoded, partially signed multisig transaction.\n   */\n  partialSignTxn(_ref4, sk) {\n    let {\n      version,\n      threshold,\n      pks\n    } = _ref4;\n    // get signature verifier\n    const myPk = nacl.keyPairFromSecretKey(sk).publicKey;\n    return createMultisigTransactionWithSignature(this, {\n      rawSig: this.rawSignTxn(sk),\n      myPk\n    }, {\n      version,\n      threshold,\n      pks\n    });\n  }\n  /**\n   * partialSignWithMultisigSignature partially signs this transaction with an external raw multisig signature and returns\n   * a partially-signed multisig transaction, encoded with msgpack as a typed array.\n   * @param metadata - multisig metadata\n   * @param signerAddr - address of the signer\n   * @param signature - raw multisig signature\n   * @returns an encoded, partially signed multisig transaction.\n   */\n  partialSignWithMultisigSignature(metadata, signerAddr, signature) {\n    if (!nacl.isValidSignatureLength(signature.length)) {\n      throw new Error(MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);\n    }\n    return createMultisigTransactionWithSignature(this, {\n      rawSig: signature,\n      myPk: address.decodeAddress(signerAddr).publicKey\n    }, metadata);\n  }\n  // eslint-disable-next-line camelcase\n  static from_obj_for_encoding(txnForEnc) {\n    return super.from_obj_for_encoding(txnForEnc);\n  }\n}\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs - a list of blobs representing encoded multisig txns\n * @returns typed array msg-pack encoded multisig txn\n */\nexport function mergeMultisigTransactions(multisigTxnBlobs) {\n  if (multisigTxnBlobs.length < 2) {\n    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);\n  }\n  const refSigTx = encoding.decode(multisigTxnBlobs[0]);\n  const refTxID = MultisigTransaction.from_obj_for_encoding(refSigTx.txn).txID();\n  const refAuthAddr = refSigTx.sgnr ? address.encodeAddress(refSigTx.sgnr) : undefined;\n  const refPreImage = {\n    version: refSigTx.msig.v,\n    threshold: refSigTx.msig.thr,\n    pks: refSigTx.msig.subsig.map(subsig => subsig.pk)\n  };\n  const refMsigAddr = address.encodeAddress(address.fromMultisigPreImg(refPreImage));\n  const newSubsigs = refSigTx.msig.subsig.map(sig => ({\n    ...sig\n  }));\n  for (let i = 1; i < multisigTxnBlobs.length; i++) {\n    const unisig = encoding.decode(multisigTxnBlobs[i]);\n    const unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);\n    if (unisigAlgoTxn.txID() !== refTxID) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);\n    }\n    const authAddr = unisig.sgnr ? address.encodeAddress(unisig.sgnr) : undefined;\n    if (refAuthAddr !== authAddr) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);\n    }\n    // check multisig has same preimage as reference\n    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n    const preimg = {\n      version: unisig.msig.v,\n      threshold: unisig.msig.thr,\n      pks: unisig.msig.subsig.map(subsig => subsig.pk)\n    };\n    const msgigAddr = address.encodeAddress(address.fromMultisigPreImg(preimg));\n    if (refMsigAddr !== msgigAddr) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n    // now, we can merge\n    unisig.msig.subsig.forEach((uniSubsig, index) => {\n      if (!uniSubsig.s) return;\n      const current = newSubsigs[index];\n      // we convert the Uint8Arrays uniSubsig.s and current.s to Buffers here because (as\n      // of Dec 2020) React overrides the buffer package with an older version that does\n      // not support Uint8Arrays in the comparison function. See this thread for more\n      // info: https://github.com/algorand/js-algorand-sdk/issues/252\n      if (current.s && Buffer.compare(Buffer.from(uniSubsig.s), Buffer.from(current.s)) !== 0) {\n        // mismatch\n        throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);\n      }\n      current.s = uniSubsig.s;\n    });\n  }\n  const msig = {\n    v: refSigTx.msig.v,\n    thr: refSigTx.msig.thr,\n    subsig: newSubsigs\n  };\n  const signedTxn = {\n    msig,\n    txn: refSigTx.txn\n  };\n  if (typeof refAuthAddr !== 'undefined') {\n    signedTxn.sgnr = Buffer.from(address.decodeAddress(refAuthAddr).publicKey);\n  }\n  return new Uint8Array(encoding.encode(signedTxn));\n}\nexport function verifyMultisig(toBeVerified, msig, publicKey) {\n  const version = msig.v;\n  const threshold = msig.thr;\n  const subsigs = msig.subsig;\n  const pks = subsigs.map(subsig => subsig.pk);\n  if (msig.subsig.length < threshold) {\n    return false;\n  }\n  let pk;\n  try {\n    pk = address.fromMultisigPreImg({\n      version,\n      threshold,\n      pks\n    });\n  } catch (e) {\n    return false;\n  }\n  if (!utils.arrayEqual(pk, publicKey)) {\n    return false;\n  }\n  let counter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      counter += 1;\n    }\n  }\n  if (counter < threshold) {\n    return false;\n  }\n  let verifiedCounter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      if (nacl.verify(toBeVerified, subsig.s, subsig.pk)) {\n        verifiedCounter += 1;\n      }\n    }\n  }\n  if (verifiedCounter < threshold) {\n    return false;\n  }\n  return true;\n}\n/**\n * signMultisigTransaction takes a raw transaction (see signTransaction), a multisig preimage, a secret key, and returns\n * a multisig transaction, which is a blob representing a transaction and multisignature account preimage. The returned\n * multisig txn can accumulate additional signatures through mergeMultisigTransactions or appendSignMultisigTransaction.\n * @param txn - object with either payment or key registration fields\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk - Algorand secret key. The corresponding pk should be in the pre image.\n * @returns object containing txID, and blob of partially signed multisig transaction (with multisig preimage information)\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n */\nexport function signMultisigTransaction(txn, _ref5, sk) {\n  let {\n    version,\n    threshold,\n    addrs\n  } = _ref5;\n  // check that the from field matches the mSigPreImage. If from field is not populated, fill it in.\n  const expectedFromRaw = address.fromMultisigPreImgAddrs({\n    version,\n    threshold,\n    addrs\n  });\n  if (!Object.prototype.hasOwnProperty.call(txn, 'from')) {\n    // eslint-disable-next-line no-param-reassign\n    txn.from = expectedFromRaw;\n  }\n  // build pks for partialSign\n  const pks = addrs.map(addr => address.decodeAddress(addr).publicKey);\n  // `txn` needs to be handled differently if it's a constructed `Transaction` vs a dict of constructor args\n  const txnAlreadyBuilt = txn instanceof txnBuilder.Transaction;\n  let algoTxn;\n  let blob;\n  if (txnAlreadyBuilt) {\n    algoTxn = txn;\n    blob = MultisigTransaction.prototype.partialSignTxn.call(algoTxn, {\n      version,\n      threshold,\n      pks\n    }, sk);\n  } else {\n    algoTxn = new MultisigTransaction(txn);\n    blob = algoTxn.partialSignTxn({\n      version,\n      threshold,\n      pks\n    }, sk);\n  }\n  return {\n    txID: algoTxn.txID().toString(),\n    blob\n  };\n}\n/**\n * appendSignMultisigTransaction takes a multisig transaction blob, and appends our signature to it.\n * While we could derive public key preimagery from the partially-signed multisig transaction,\n * we ask the caller to pass it back in, to ensure they know what they are signing.\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk - Algorand secret key\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nexport function appendSignMultisigTransaction(multisigTxnBlob, _ref6, sk) {\n  let {\n    version,\n    threshold,\n    addrs\n  } = _ref6;\n  const pks = addrs.map(addr => address.decodeAddress(addr).publicKey);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decode(multisigTxnBlob);\n  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  const partialSignedBlob = msigTxn.partialSignTxn({\n    version,\n    threshold,\n    pks\n  }, sk);\n  return {\n    txID: msigTxn.txID().toString(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])\n  };\n}\n/**\n * appendMultisigTransactionSignature takes a multisig transaction blob, and appends a given raw signature to it.\n * This makes it possible to compile a multisig signature using only raw signatures from external methods.\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param signerAddr - address of the signer\n * @param signature - raw multisig signature\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nexport function appendSignRawMultisigSignature(multisigTxnBlob, _ref7, signerAddr, signature) {\n  let {\n    version,\n    threshold,\n    addrs\n  } = _ref7;\n  const pks = addrs.map(addr => address.decodeAddress(addr).publicKey);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decode(multisigTxnBlob);\n  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  const partialSignedBlob = msigTxn.partialSignWithMultisigSignature({\n    version,\n    threshold,\n    pks\n  }, signerAddr, signature);\n  return {\n    txID: msigTxn.txID().toString(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])\n  };\n}\n/**\n * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - list of Algorand addresses\n */\nexport function multisigAddress(_ref8) {\n  let {\n    version,\n    threshold,\n    addrs\n  } = _ref8;\n  return address.fromMultisigPreImgAddrs({\n    version,\n    threshold,\n    addrs\n  });\n}","map":{"version":3,"names":["Buffer","nacl","address","encoding","txnBuilder","utils","MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG","MULTISIG_MERGE_MISMATCH_ERROR_MSG","MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG","MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG","MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG","MULTISIG_KEY_NOT_EXIST_ERROR_MSG","MULTISIG_NO_MUTATE_ERROR_MSG","MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG","MULTISIG_SIGNATURE_LENGTH_ERROR_MSG","createMultisigTransaction","txn","_ref","version","threshold","addrs","pks","map","addr","decodeAddress","publicKey","subsigs","pk","from","msig","v","thr","subsig","txnForEncoding","get_obj_for_encoding","signedTxn","msigAddr","fromMultisigPreImg","encodeAddress","snd","sgnr","Uint8Array","encode","createMultisigTransactionWithSignature","_ref2","_ref3","rawSig","myPk","encodedMsig","decode","keyExist","forEach","i","bytesEqual","s","Error","MultisigTransaction","Transaction","addLease","addRekey","signTxn","sk","partialSignTxn","_ref4","keyPairFromSecretKey","rawSignTxn","partialSignWithMultisigSignature","metadata","signerAddr","signature","isValidSignatureLength","length","from_obj_for_encoding","txnForEnc","mergeMultisigTransactions","multisigTxnBlobs","refSigTx","refTxID","txID","refAuthAddr","undefined","refPreImage","refMsigAddr","newSubsigs","sig","unisig","unisigAlgoTxn","authAddr","preimg","msgigAddr","uniSubsig","index","current","compare","verifyMultisig","toBeVerified","e","arrayEqual","counter","verifiedCounter","verify","signMultisigTransaction","_ref5","expectedFromRaw","fromMultisigPreImgAddrs","Object","prototype","hasOwnProperty","call","txnAlreadyBuilt","algoTxn","blob","toString","appendSignMultisigTransaction","multisigTxnBlob","_ref6","multisigTxObj","msigTxn","partialSignedBlob","appendSignRawMultisigSignature","_ref7","multisigAddress","_ref8"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/algosdk/src/multisig.ts"],"sourcesContent":["import { Buffer } from 'buffer';\nimport * as nacl from './nacl/naclWrappers';\nimport * as address from './encoding/address';\nimport * as encoding from './encoding/encoding';\nimport * as txnBuilder from './transaction';\nimport * as utils from './utils/utils';\nimport AnyTransaction, { EncodedTransaction } from './types/transactions';\nimport { MultisigMetadata } from './types/multisig';\nimport {\n  EncodedMultisig,\n  EncodedSignedTransaction,\n} from './types/transactions/encoded';\n\n/**\n Utilities for manipulating multisig transaction blobs.\n */\n\nexport const MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG =\n  'Not enough multisig transactions to merge. Need at least two';\nexport const MULTISIG_MERGE_MISMATCH_ERROR_MSG =\n  'Cannot merge txs. txIDs differ';\nexport const MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG =\n  'Cannot merge txs. Auth addrs differ';\nexport const MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG =\n  'Cannot merge txs. Multisig preimages differ';\nexport const MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG =\n  'Cannot merge txs. subsigs are mismatched.';\nconst MULTISIG_KEY_NOT_EXIST_ERROR_MSG = 'Key does not exist';\nexport const MULTISIG_NO_MUTATE_ERROR_MSG =\n  'Cannot mutate a multisig field as it would invalidate all existing signatures.';\nexport const MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG =\n  'Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.';\nexport const MULTISIG_SIGNATURE_LENGTH_ERROR_MSG =\n  'Cannot add multisig signature. Signature is not of the correct length.';\n\ninterface MultisigOptions {\n  rawSig: Uint8Array;\n  myPk: Uint8Array;\n}\n\ninterface MultisigMetadataWithPks extends Omit<MultisigMetadata, 'addrs'> {\n  pks: Uint8Array[];\n}\n\n/**\n * createMultisigTransaction creates a raw, unsigned multisig transaction blob.\n * @param txn - the actual transaction.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nexport function createMultisigTransaction(\n  txn: txnBuilder.Transaction,\n  { version, threshold, addrs }: MultisigMetadata\n) {\n  // construct the appendable multisigned transaction format\n  const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);\n  const subsigs = pks.map((pk) => ({ pk: Buffer.from(pk) }));\n\n  const msig: EncodedMultisig = {\n    v: version,\n    thr: threshold,\n    subsig: subsigs,\n  };\n  const txnForEncoding = txn.get_obj_for_encoding();\n  const signedTxn: EncodedSignedTransaction = {\n    msig,\n    txn: txnForEncoding,\n  };\n\n  // if the address of this multisig is different from the transaction sender,\n  // we need to add the auth-addr field\n  const msigAddr = address.fromMultisigPreImg({\n    version,\n    threshold,\n    pks,\n  });\n  if (\n    address.encodeAddress(txnForEncoding.snd) !==\n    address.encodeAddress(msigAddr)\n  ) {\n    signedTxn.sgnr = Buffer.from(msigAddr);\n  }\n\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n\n/**\n * createMultisigTransactionWithSignature creates a multisig transaction blob with an included signature.\n * @param txn - the actual transaction to sign.\n * @param rawSig - a Buffer raw signature of that transaction\n * @param myPk - a public key that corresponds with rawSig\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nfunction createMultisigTransactionWithSignature(\n  txn: txnBuilder.Transaction,\n  { rawSig, myPk }: MultisigOptions,\n  { version, threshold, pks }: MultisigMetadataWithPks\n) {\n  // Create an empty encoded multisig transaction\n  const encodedMsig = createMultisigTransaction(txn, {\n    version,\n    threshold,\n    addrs: pks.map((pk) => address.encodeAddress(pk)),\n  });\n  // note: this is not signed yet, but will be shortly\n  const signedTxn = encoding.decode(encodedMsig) as EncodedSignedTransaction;\n\n  let keyExist = false;\n  // append the multisig signature to the corresponding public key in the multisig blob\n  signedTxn.msig.subsig.forEach((subsig, i) => {\n    if (nacl.bytesEqual(subsig.pk, myPk)) {\n      keyExist = true;\n      signedTxn.msig.subsig[i].s = rawSig;\n    }\n  });\n  if (keyExist === false) {\n    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);\n  }\n\n  // if the address of this multisig is different from the transaction sender,\n  // we need to add the auth-addr field\n  const msigAddr = address.fromMultisigPreImg({\n    version,\n    threshold,\n    pks,\n  });\n  if (\n    address.encodeAddress(signedTxn.txn.snd) !== address.encodeAddress(msigAddr)\n  ) {\n    signedTxn.sgnr = Buffer.from(msigAddr);\n  }\n\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n\n/**\n * MultisigTransaction is a Transaction that also supports creating partially-signed multisig transactions.\n */\nexport class MultisigTransaction extends txnBuilder.Transaction {\n  /* eslint-disable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */\n  /**\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\n   */\n  addLease() {\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n  }\n\n  /**\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\n   */\n  addRekey() {\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n  }\n\n  /**\n   * Override inherited method to throw an error, as traditional signing is not allowed\n   */\n  signTxn(sk: Uint8Array): Uint8Array; // This overload ensures that the override has a compatible type definition with the parent method\n  signTxn(sk: any): any {\n    throw new Error(MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG);\n  }\n  /* eslint-enable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */\n\n  /**\n   * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,\n   * encoded with msgpack as a typed array.\n   * @param version - multisig version\n   * @param threshold - multisig threshold\n   * @param pks - multisig public key list, order is important.\n   * @param sk - an Algorand secret key to sign with.\n   * @returns an encoded, partially signed multisig transaction.\n   */\n  partialSignTxn(\n    { version, threshold, pks }: MultisigMetadataWithPks,\n    sk: Uint8Array\n  ) {\n    // get signature verifier\n    const myPk = nacl.keyPairFromSecretKey(sk).publicKey;\n    return createMultisigTransactionWithSignature(\n      this,\n      { rawSig: this.rawSignTxn(sk), myPk },\n      { version, threshold, pks }\n    );\n  }\n\n  /**\n   * partialSignWithMultisigSignature partially signs this transaction with an external raw multisig signature and returns\n   * a partially-signed multisig transaction, encoded with msgpack as a typed array.\n   * @param metadata - multisig metadata\n   * @param signerAddr - address of the signer\n   * @param signature - raw multisig signature\n   * @returns an encoded, partially signed multisig transaction.\n   */\n  partialSignWithMultisigSignature(\n    metadata: MultisigMetadataWithPks,\n    signerAddr: string,\n    signature: Uint8Array\n  ) {\n    if (!nacl.isValidSignatureLength(signature.length)) {\n      throw new Error(MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);\n    }\n    return createMultisigTransactionWithSignature(\n      this,\n      {\n        rawSig: signature,\n        myPk: address.decodeAddress(signerAddr).publicKey,\n      },\n      metadata\n    );\n  }\n\n  // eslint-disable-next-line camelcase\n  static from_obj_for_encoding(\n    txnForEnc: EncodedTransaction\n  ): MultisigTransaction {\n    return super.from_obj_for_encoding(txnForEnc) as MultisigTransaction;\n  }\n}\n\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs - a list of blobs representing encoded multisig txns\n * @returns typed array msg-pack encoded multisig txn\n */\nexport function mergeMultisigTransactions(multisigTxnBlobs: Uint8Array[]) {\n  if (multisigTxnBlobs.length < 2) {\n    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);\n  }\n  const refSigTx = encoding.decode(\n    multisigTxnBlobs[0]\n  ) as EncodedSignedTransaction;\n  const refTxID = MultisigTransaction.from_obj_for_encoding(\n    refSigTx.txn\n  ).txID();\n  const refAuthAddr = refSigTx.sgnr\n    ? address.encodeAddress(refSigTx.sgnr)\n    : undefined;\n  const refPreImage = {\n    version: refSigTx.msig.v,\n    threshold: refSigTx.msig.thr,\n    pks: refSigTx.msig.subsig.map((subsig) => subsig.pk),\n  };\n  const refMsigAddr = address.encodeAddress(\n    address.fromMultisigPreImg(refPreImage)\n  );\n\n  const newSubsigs = refSigTx.msig.subsig.map((sig) => ({ ...sig }));\n  for (let i = 1; i < multisigTxnBlobs.length; i++) {\n    const unisig = encoding.decode(\n      multisigTxnBlobs[i]\n    ) as EncodedSignedTransaction;\n\n    const unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);\n    if (unisigAlgoTxn.txID() !== refTxID) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);\n    }\n\n    const authAddr = unisig.sgnr\n      ? address.encodeAddress(unisig.sgnr)\n      : undefined;\n    if (refAuthAddr !== authAddr) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);\n    }\n\n    // check multisig has same preimage as reference\n    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n    const preimg: MultisigMetadataWithPks = {\n      version: unisig.msig.v,\n      threshold: unisig.msig.thr,\n      pks: unisig.msig.subsig.map((subsig) => subsig.pk),\n    };\n    const msgigAddr = address.encodeAddress(address.fromMultisigPreImg(preimg));\n    if (refMsigAddr !== msgigAddr) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n\n    // now, we can merge\n    unisig.msig.subsig.forEach((uniSubsig, index) => {\n      if (!uniSubsig.s) return;\n      const current = newSubsigs[index];\n      // we convert the Uint8Arrays uniSubsig.s and current.s to Buffers here because (as\n      // of Dec 2020) React overrides the buffer package with an older version that does\n      // not support Uint8Arrays in the comparison function. See this thread for more\n      // info: https://github.com/algorand/js-algorand-sdk/issues/252\n      if (\n        current.s &&\n        Buffer.compare(Buffer.from(uniSubsig.s), Buffer.from(current.s)) !== 0\n      ) {\n        // mismatch\n        throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);\n      }\n      current.s = uniSubsig.s;\n    });\n  }\n  const msig: EncodedMultisig = {\n    v: refSigTx.msig.v,\n    thr: refSigTx.msig.thr,\n    subsig: newSubsigs,\n  };\n  const signedTxn: EncodedSignedTransaction = {\n    msig,\n    txn: refSigTx.txn,\n  };\n  if (typeof refAuthAddr !== 'undefined') {\n    signedTxn.sgnr = Buffer.from(address.decodeAddress(refAuthAddr).publicKey);\n  }\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n\nexport function verifyMultisig(\n  toBeVerified: Uint8Array,\n  msig: EncodedMultisig,\n  publicKey: Uint8Array\n) {\n  const version = msig.v;\n  const threshold = msig.thr;\n  const subsigs = msig.subsig;\n\n  const pks = subsigs.map((subsig) => subsig.pk);\n  if (msig.subsig.length < threshold) {\n    return false;\n  }\n\n  let pk: Uint8Array;\n  try {\n    pk = address.fromMultisigPreImg({ version, threshold, pks });\n  } catch (e) {\n    return false;\n  }\n\n  if (!utils.arrayEqual(pk, publicKey)) {\n    return false;\n  }\n\n  let counter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      counter += 1;\n    }\n  }\n  if (counter < threshold) {\n    return false;\n  }\n\n  let verifiedCounter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      if (nacl.verify(toBeVerified, subsig.s, subsig.pk)) {\n        verifiedCounter += 1;\n      }\n    }\n  }\n\n  if (verifiedCounter < threshold) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * signMultisigTransaction takes a raw transaction (see signTransaction), a multisig preimage, a secret key, and returns\n * a multisig transaction, which is a blob representing a transaction and multisignature account preimage. The returned\n * multisig txn can accumulate additional signatures through mergeMultisigTransactions or appendSignMultisigTransaction.\n * @param txn - object with either payment or key registration fields\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk - Algorand secret key. The corresponding pk should be in the pre image.\n * @returns object containing txID, and blob of partially signed multisig transaction (with multisig preimage information)\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n */\nexport function signMultisigTransaction(\n  txn: txnBuilder.TransactionLike,\n  { version, threshold, addrs }: MultisigMetadata,\n  sk: Uint8Array\n) {\n  // check that the from field matches the mSigPreImage. If from field is not populated, fill it in.\n  const expectedFromRaw = address.fromMultisigPreImgAddrs({\n    version,\n    threshold,\n    addrs,\n  });\n  if (!Object.prototype.hasOwnProperty.call(txn, 'from')) {\n    // eslint-disable-next-line no-param-reassign\n    txn.from = expectedFromRaw;\n  }\n  // build pks for partialSign\n  const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);\n  // `txn` needs to be handled differently if it's a constructed `Transaction` vs a dict of constructor args\n  const txnAlreadyBuilt = txn instanceof txnBuilder.Transaction;\n  let algoTxn: MultisigTransaction;\n  let blob: Uint8Array;\n  if (txnAlreadyBuilt) {\n    algoTxn = (txn as unknown) as MultisigTransaction;\n    blob = MultisigTransaction.prototype.partialSignTxn.call(\n      algoTxn,\n      { version, threshold, pks },\n      sk\n    );\n  } else {\n    algoTxn = new MultisigTransaction(txn as AnyTransaction);\n    blob = algoTxn.partialSignTxn({ version, threshold, pks }, sk);\n  }\n  return {\n    txID: algoTxn.txID().toString(),\n    blob,\n  };\n}\n\n/**\n * appendSignMultisigTransaction takes a multisig transaction blob, and appends our signature to it.\n * While we could derive public key preimagery from the partially-signed multisig transaction,\n * we ask the caller to pass it back in, to ensure they know what they are signing.\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk - Algorand secret key\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nexport function appendSignMultisigTransaction(\n  multisigTxnBlob: Uint8Array,\n  { version, threshold, addrs }: MultisigMetadata,\n  sk: Uint8Array\n) {\n  const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decode(\n    multisigTxnBlob\n  ) as EncodedSignedTransaction;\n  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  const partialSignedBlob = msigTxn.partialSignTxn(\n    { version, threshold, pks },\n    sk\n  );\n  return {\n    txID: msigTxn.txID().toString(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob]),\n  };\n}\n\n/**\n * appendMultisigTransactionSignature takes a multisig transaction blob, and appends a given raw signature to it.\n * This makes it possible to compile a multisig signature using only raw signatures from external methods.\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param signerAddr - address of the signer\n * @param signature - raw multisig signature\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nexport function appendSignRawMultisigSignature(\n  multisigTxnBlob: Uint8Array,\n  { version, threshold, addrs }: MultisigMetadata,\n  signerAddr: string,\n  signature: Uint8Array\n) {\n  const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decode(\n    multisigTxnBlob\n  ) as EncodedSignedTransaction;\n  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  const partialSignedBlob = msigTxn.partialSignWithMultisigSignature(\n    { version, threshold, pks },\n    signerAddr,\n    signature\n  );\n  return {\n    txID: msigTxn.txID().toString(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob]),\n  };\n}\n\n/**\n * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - list of Algorand addresses\n */\nexport function multisigAddress({\n  version,\n  threshold,\n  addrs,\n}: MultisigMetadata) {\n  return address.fromMultisigPreImgAddrs({ version, threshold, addrs });\n}\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,QAAQ;AAC/B,OAAO,KAAKC,IAAI,MAAM,qBAAqB;AAC3C,OAAO,KAAKC,OAAO,MAAM,oBAAoB;AAC7C,OAAO,KAAKC,QAAQ,MAAM,qBAAqB;AAC/C,OAAO,KAAKC,UAAU,MAAM,eAAe;AAC3C,OAAO,KAAKC,KAAK,MAAM,eAAe;AAQtC;;;AAIA,OAAO,MAAMC,oCAAoC,GAC/C,8DAA8D;AAChE,OAAO,MAAMC,iCAAiC,GAC5C,gCAAgC;AAClC,OAAO,MAAMC,qCAAqC,GAChD,qCAAqC;AACvC,OAAO,MAAMC,uCAAuC,GAClD,6CAA6C;AAC/C,OAAO,MAAMC,qCAAqC,GAChD,2CAA2C;AAC7C,MAAMC,gCAAgC,GAAG,oBAAoB;AAC7D,OAAO,MAAMC,4BAA4B,GACvC,gFAAgF;AAClF,OAAO,MAAMC,mCAAmC,GAC9C,mFAAmF;AACrF,OAAO,MAAMC,mCAAmC,GAC9C,wEAAwE;AAW1E;;;;;;;;AAQA,OAAM,SAAUC,yBAAyBA,CACvCC,GAA2B,EAAAC,IAAA,EACoB;EAAA,IAA/C;IAAEC,OAAO;IAAEC,SAAS;IAAEC;EAAK,CAAoB,GAAAH,IAAA;EAE/C;EACA,MAAMI,GAAG,GAAGD,KAAK,CAACE,GAAG,CAAEC,IAAI,IAAKrB,OAAO,CAACsB,aAAa,CAACD,IAAI,CAAC,CAACE,SAAS,CAAC;EACtE,MAAMC,OAAO,GAAGL,GAAG,CAACC,GAAG,CAAEK,EAAE,KAAM;IAAEA,EAAE,EAAE3B,MAAM,CAAC4B,IAAI,CAACD,EAAE;EAAC,CAAE,CAAC,CAAC;EAE1D,MAAME,IAAI,GAAoB;IAC5BC,CAAC,EAAEZ,OAAO;IACVa,GAAG,EAAEZ,SAAS;IACda,MAAM,EAAEN;GACT;EACD,MAAMO,cAAc,GAAGjB,GAAG,CAACkB,oBAAoB,EAAE;EACjD,MAAMC,SAAS,GAA6B;IAC1CN,IAAI;IACJb,GAAG,EAAEiB;GACN;EAED;EACA;EACA,MAAMG,QAAQ,GAAGlC,OAAO,CAACmC,kBAAkB,CAAC;IAC1CnB,OAAO;IACPC,SAAS;IACTE;GACD,CAAC;EACF,IACEnB,OAAO,CAACoC,aAAa,CAACL,cAAc,CAACM,GAAG,CAAC,KACzCrC,OAAO,CAACoC,aAAa,CAACF,QAAQ,CAAC,EAC/B;IACAD,SAAS,CAACK,IAAI,GAAGxC,MAAM,CAAC4B,IAAI,CAACQ,QAAQ,CAAC;;EAGxC,OAAO,IAAIK,UAAU,CAACtC,QAAQ,CAACuC,MAAM,CAACP,SAAS,CAAC,CAAC;AACnD;AAEA;;;;;;;;;;AAUA,SAASQ,sCAAsCA,CAC7C3B,GAA2B,EAAA4B,KAAA,EAAAC,KAAA,EAEyB;EAAA,IADpD;IAAEC,MAAM;IAAEC;EAAI,CAAmB,GAAAH,KAAA;EAAA,IACjC;IAAE1B,OAAO;IAAEC,SAAS;IAAEE;EAAG,CAA2B,GAAAwB,KAAA;EAEpD;EACA,MAAMG,WAAW,GAAGjC,yBAAyB,CAACC,GAAG,EAAE;IACjDE,OAAO;IACPC,SAAS;IACTC,KAAK,EAAEC,GAAG,CAACC,GAAG,CAAEK,EAAE,IAAKzB,OAAO,CAACoC,aAAa,CAACX,EAAE,CAAC;GACjD,CAAC;EACF;EACA,MAAMQ,SAAS,GAAGhC,QAAQ,CAAC8C,MAAM,CAACD,WAAW,CAA6B;EAE1E,IAAIE,QAAQ,GAAG,KAAK;EACpB;EACAf,SAAS,CAACN,IAAI,CAACG,MAAM,CAACmB,OAAO,CAAC,CAACnB,MAAM,EAAEoB,CAAC,KAAI;IAC1C,IAAInD,IAAI,CAACoD,UAAU,CAACrB,MAAM,CAACL,EAAE,EAAEoB,IAAI,CAAC,EAAE;MACpCG,QAAQ,GAAG,IAAI;MACff,SAAS,CAACN,IAAI,CAACG,MAAM,CAACoB,CAAC,CAAC,CAACE,CAAC,GAAGR,MAAM;;EAEvC,CAAC,CAAC;EACF,IAAII,QAAQ,KAAK,KAAK,EAAE;IACtB,MAAM,IAAIK,KAAK,CAAC5C,gCAAgC,CAAC;;EAGnD;EACA;EACA,MAAMyB,QAAQ,GAAGlC,OAAO,CAACmC,kBAAkB,CAAC;IAC1CnB,OAAO;IACPC,SAAS;IACTE;GACD,CAAC;EACF,IACEnB,OAAO,CAACoC,aAAa,CAACH,SAAS,CAACnB,GAAG,CAACuB,GAAG,CAAC,KAAKrC,OAAO,CAACoC,aAAa,CAACF,QAAQ,CAAC,EAC5E;IACAD,SAAS,CAACK,IAAI,GAAGxC,MAAM,CAAC4B,IAAI,CAACQ,QAAQ,CAAC;;EAGxC,OAAO,IAAIK,UAAU,CAACtC,QAAQ,CAACuC,MAAM,CAACP,SAAS,CAAC,CAAC;AACnD;AAEA;;;AAGA,OAAM,MAAOqB,mBAAoB,SAAQpD,UAAU,CAACqD,WAAW;EAC7D;EACA;;;EAGAC,QAAQA,CAAA;IACN,MAAM,IAAIH,KAAK,CAAC3C,4BAA4B,CAAC;EAC/C;EAEA;;;EAGA+C,QAAQA,CAAA;IACN,MAAM,IAAIJ,KAAK,CAAC3C,4BAA4B,CAAC;EAC/C;EAMAgD,OAAOA,CAACC,EAAO;IACb,MAAM,IAAIN,KAAK,CAAC1C,mCAAmC,CAAC;EACtD;EACA;EAEA;;;;;;;;;EASAiD,cAAcA,CAAAC,KAAA,EAEZF,EAAc;IAAA,IADd;MAAE3C,OAAO;MAAEC,SAAS;MAAEE;IAAG,CAA2B,GAAA0C,KAAA;IAGpD;IACA,MAAMhB,IAAI,GAAG9C,IAAI,CAAC+D,oBAAoB,CAACH,EAAE,CAAC,CAACpC,SAAS;IACpD,OAAOkB,sCAAsC,CAC3C,IAAI,EACJ;MAAEG,MAAM,EAAE,IAAI,CAACmB,UAAU,CAACJ,EAAE,CAAC;MAAEd;IAAI,CAAE,EACrC;MAAE7B,OAAO;MAAEC,SAAS;MAAEE;IAAG,CAAE,CAC5B;EACH;EAEA;;;;;;;;EAQA6C,gCAAgCA,CAC9BC,QAAiC,EACjCC,UAAkB,EAClBC,SAAqB;IAErB,IAAI,CAACpE,IAAI,CAACqE,sBAAsB,CAACD,SAAS,CAACE,MAAM,CAAC,EAAE;MAClD,MAAM,IAAIhB,KAAK,CAACzC,mCAAmC,CAAC;;IAEtD,OAAO6B,sCAAsC,CAC3C,IAAI,EACJ;MACEG,MAAM,EAAEuB,SAAS;MACjBtB,IAAI,EAAE7C,OAAO,CAACsB,aAAa,CAAC4C,UAAU,CAAC,CAAC3C;KACzC,EACD0C,QAAQ,CACT;EACH;EAEA;EACA,OAAOK,qBAAqBA,CAC1BC,SAA6B;IAE7B,OAAO,KAAK,CAACD,qBAAqB,CAACC,SAAS,CAAwB;EACtE;;AAGF;;;;;AAKA,OAAM,SAAUC,yBAAyBA,CAACC,gBAA8B;EACtE,IAAIA,gBAAgB,CAACJ,MAAM,GAAG,CAAC,EAAE;IAC/B,MAAM,IAAIhB,KAAK,CAACjD,oCAAoC,CAAC;;EAEvD,MAAMsE,QAAQ,GAAGzE,QAAQ,CAAC8C,MAAM,CAC9B0B,gBAAgB,CAAC,CAAC,CAAC,CACQ;EAC7B,MAAME,OAAO,GAAGrB,mBAAmB,CAACgB,qBAAqB,CACvDI,QAAQ,CAAC5D,GAAG,CACb,CAAC8D,IAAI,EAAE;EACR,MAAMC,WAAW,GAAGH,QAAQ,CAACpC,IAAI,GAC7BtC,OAAO,CAACoC,aAAa,CAACsC,QAAQ,CAACpC,IAAI,CAAC,GACpCwC,SAAS;EACb,MAAMC,WAAW,GAAG;IAClB/D,OAAO,EAAE0D,QAAQ,CAAC/C,IAAI,CAACC,CAAC;IACxBX,SAAS,EAAEyD,QAAQ,CAAC/C,IAAI,CAACE,GAAG;IAC5BV,GAAG,EAAEuD,QAAQ,CAAC/C,IAAI,CAACG,MAAM,CAACV,GAAG,CAAEU,MAAM,IAAKA,MAAM,CAACL,EAAE;GACpD;EACD,MAAMuD,WAAW,GAAGhF,OAAO,CAACoC,aAAa,CACvCpC,OAAO,CAACmC,kBAAkB,CAAC4C,WAAW,CAAC,CACxC;EAED,MAAME,UAAU,GAAGP,QAAQ,CAAC/C,IAAI,CAACG,MAAM,CAACV,GAAG,CAAE8D,GAAG,KAAM;IAAE,GAAGA;EAAG,CAAE,CAAC,CAAC;EAClE,KAAK,IAAIhC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuB,gBAAgB,CAACJ,MAAM,EAAEnB,CAAC,EAAE,EAAE;IAChD,MAAMiC,MAAM,GAAGlF,QAAQ,CAAC8C,MAAM,CAC5B0B,gBAAgB,CAACvB,CAAC,CAAC,CACQ;IAE7B,MAAMkC,aAAa,GAAG9B,mBAAmB,CAACgB,qBAAqB,CAACa,MAAM,CAACrE,GAAG,CAAC;IAC3E,IAAIsE,aAAa,CAACR,IAAI,EAAE,KAAKD,OAAO,EAAE;MACpC,MAAM,IAAItB,KAAK,CAAChD,iCAAiC,CAAC;;IAGpD,MAAMgF,QAAQ,GAAGF,MAAM,CAAC7C,IAAI,GACxBtC,OAAO,CAACoC,aAAa,CAAC+C,MAAM,CAAC7C,IAAI,CAAC,GAClCwC,SAAS;IACb,IAAID,WAAW,KAAKQ,QAAQ,EAAE;MAC5B,MAAM,IAAIhC,KAAK,CAAC/C,qCAAqC,CAAC;;IAGxD;IACA,IAAI6E,MAAM,CAACxD,IAAI,CAACG,MAAM,CAACuC,MAAM,KAAKK,QAAQ,CAAC/C,IAAI,CAACG,MAAM,CAACuC,MAAM,EAAE;MAC7D,MAAM,IAAIhB,KAAK,CAAC9C,uCAAuC,CAAC;;IAE1D,MAAM+E,MAAM,GAA4B;MACtCtE,OAAO,EAAEmE,MAAM,CAACxD,IAAI,CAACC,CAAC;MACtBX,SAAS,EAAEkE,MAAM,CAACxD,IAAI,CAACE,GAAG;MAC1BV,GAAG,EAAEgE,MAAM,CAACxD,IAAI,CAACG,MAAM,CAACV,GAAG,CAAEU,MAAM,IAAKA,MAAM,CAACL,EAAE;KAClD;IACD,MAAM8D,SAAS,GAAGvF,OAAO,CAACoC,aAAa,CAACpC,OAAO,CAACmC,kBAAkB,CAACmD,MAAM,CAAC,CAAC;IAC3E,IAAIN,WAAW,KAAKO,SAAS,EAAE;MAC7B,MAAM,IAAIlC,KAAK,CAAC9C,uCAAuC,CAAC;;IAG1D;IACA4E,MAAM,CAACxD,IAAI,CAACG,MAAM,CAACmB,OAAO,CAAC,CAACuC,SAAS,EAAEC,KAAK,KAAI;MAC9C,IAAI,CAACD,SAAS,CAACpC,CAAC,EAAE;MAClB,MAAMsC,OAAO,GAAGT,UAAU,CAACQ,KAAK,CAAC;MACjC;MACA;MACA;MACA;MACA,IACEC,OAAO,CAACtC,CAAC,IACTtD,MAAM,CAAC6F,OAAO,CAAC7F,MAAM,CAAC4B,IAAI,CAAC8D,SAAS,CAACpC,CAAC,CAAC,EAAEtD,MAAM,CAAC4B,IAAI,CAACgE,OAAO,CAACtC,CAAC,CAAC,CAAC,KAAK,CAAC,EACtE;QACA;QACA,MAAM,IAAIC,KAAK,CAAC7C,qCAAqC,CAAC;;MAExDkF,OAAO,CAACtC,CAAC,GAAGoC,SAAS,CAACpC,CAAC;IACzB,CAAC,CAAC;;EAEJ,MAAMzB,IAAI,GAAoB;IAC5BC,CAAC,EAAE8C,QAAQ,CAAC/C,IAAI,CAACC,CAAC;IAClBC,GAAG,EAAE6C,QAAQ,CAAC/C,IAAI,CAACE,GAAG;IACtBC,MAAM,EAAEmD;GACT;EACD,MAAMhD,SAAS,GAA6B;IAC1CN,IAAI;IACJb,GAAG,EAAE4D,QAAQ,CAAC5D;GACf;EACD,IAAI,OAAO+D,WAAW,KAAK,WAAW,EAAE;IACtC5C,SAAS,CAACK,IAAI,GAAGxC,MAAM,CAAC4B,IAAI,CAAC1B,OAAO,CAACsB,aAAa,CAACuD,WAAW,CAAC,CAACtD,SAAS,CAAC;;EAE5E,OAAO,IAAIgB,UAAU,CAACtC,QAAQ,CAACuC,MAAM,CAACP,SAAS,CAAC,CAAC;AACnD;AAEA,OAAM,SAAU2D,cAAcA,CAC5BC,YAAwB,EACxBlE,IAAqB,EACrBJ,SAAqB;EAErB,MAAMP,OAAO,GAAGW,IAAI,CAACC,CAAC;EACtB,MAAMX,SAAS,GAAGU,IAAI,CAACE,GAAG;EAC1B,MAAML,OAAO,GAAGG,IAAI,CAACG,MAAM;EAE3B,MAAMX,GAAG,GAAGK,OAAO,CAACJ,GAAG,CAAEU,MAAM,IAAKA,MAAM,CAACL,EAAE,CAAC;EAC9C,IAAIE,IAAI,CAACG,MAAM,CAACuC,MAAM,GAAGpD,SAAS,EAAE;IAClC,OAAO,KAAK;;EAGd,IAAIQ,EAAc;EAClB,IAAI;IACFA,EAAE,GAAGzB,OAAO,CAACmC,kBAAkB,CAAC;MAAEnB,OAAO;MAAEC,SAAS;MAAEE;IAAG,CAAE,CAAC;GAC7D,CAAC,OAAO2E,CAAC,EAAE;IACV,OAAO,KAAK;;EAGd,IAAI,CAAC3F,KAAK,CAAC4F,UAAU,CAACtE,EAAE,EAAEF,SAAS,CAAC,EAAE;IACpC,OAAO,KAAK;;EAGd,IAAIyE,OAAO,GAAG,CAAC;EACf,KAAK,MAAMlE,MAAM,IAAIN,OAAO,EAAE;IAC5B,IAAIM,MAAM,CAACsB,CAAC,KAAK0B,SAAS,EAAE;MAC1BkB,OAAO,IAAI,CAAC;;;EAGhB,IAAIA,OAAO,GAAG/E,SAAS,EAAE;IACvB,OAAO,KAAK;;EAGd,IAAIgF,eAAe,GAAG,CAAC;EACvB,KAAK,MAAMnE,MAAM,IAAIN,OAAO,EAAE;IAC5B,IAAIM,MAAM,CAACsB,CAAC,KAAK0B,SAAS,EAAE;MAC1B,IAAI/E,IAAI,CAACmG,MAAM,CAACL,YAAY,EAAE/D,MAAM,CAACsB,CAAC,EAAEtB,MAAM,CAACL,EAAE,CAAC,EAAE;QAClDwE,eAAe,IAAI,CAAC;;;;EAK1B,IAAIA,eAAe,GAAGhF,SAAS,EAAE;IAC/B,OAAO,KAAK;;EAGd,OAAO,IAAI;AACb;AAEA;;;;;;;;;;;;AAYA,OAAM,SAAUkF,uBAAuBA,CACrCrF,GAA+B,EAAAsF,KAAA,EAE/BzC,EAAc;EAAA,IADd;IAAE3C,OAAO;IAAEC,SAAS;IAAEC;EAAK,CAAoB,GAAAkF,KAAA;EAG/C;EACA,MAAMC,eAAe,GAAGrG,OAAO,CAACsG,uBAAuB,CAAC;IACtDtF,OAAO;IACPC,SAAS;IACTC;GACD,CAAC;EACF,IAAI,CAACqF,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAAC5F,GAAG,EAAE,MAAM,CAAC,EAAE;IACtD;IACAA,GAAG,CAACY,IAAI,GAAG2E,eAAe;;EAE5B;EACA,MAAMlF,GAAG,GAAGD,KAAK,CAACE,GAAG,CAAEC,IAAI,IAAKrB,OAAO,CAACsB,aAAa,CAACD,IAAI,CAAC,CAACE,SAAS,CAAC;EACtE;EACA,MAAMoF,eAAe,GAAG7F,GAAG,YAAYZ,UAAU,CAACqD,WAAW;EAC7D,IAAIqD,OAA4B;EAChC,IAAIC,IAAgB;EACpB,IAAIF,eAAe,EAAE;IACnBC,OAAO,GAAI9F,GAAsC;IACjD+F,IAAI,GAAGvD,mBAAmB,CAACkD,SAAS,CAAC5C,cAAc,CAAC8C,IAAI,CACtDE,OAAO,EACP;MAAE5F,OAAO;MAAEC,SAAS;MAAEE;IAAG,CAAE,EAC3BwC,EAAE,CACH;GACF,MAAM;IACLiD,OAAO,GAAG,IAAItD,mBAAmB,CAACxC,GAAqB,CAAC;IACxD+F,IAAI,GAAGD,OAAO,CAAChD,cAAc,CAAC;MAAE5C,OAAO;MAAEC,SAAS;MAAEE;IAAG,CAAE,EAAEwC,EAAE,CAAC;;EAEhE,OAAO;IACLiB,IAAI,EAAEgC,OAAO,CAAChC,IAAI,EAAE,CAACkC,QAAQ,EAAE;IAC/BD;GACD;AACH;AAEA;;;;;;;;;;;AAWA,OAAM,SAAUE,6BAA6BA,CAC3CC,eAA2B,EAAAC,KAAA,EAE3BtD,EAAc;EAAA,IADd;IAAE3C,OAAO;IAAEC,SAAS;IAAEC;EAAK,CAAoB,GAAA+F,KAAA;EAG/C,MAAM9F,GAAG,GAAGD,KAAK,CAACE,GAAG,CAAEC,IAAI,IAAKrB,OAAO,CAACsB,aAAa,CAACD,IAAI,CAAC,CAACE,SAAS,CAAC;EACtE;EACA,MAAM2F,aAAa,GAAGjH,QAAQ,CAAC8C,MAAM,CACnCiE,eAAe,CACY;EAC7B,MAAMG,OAAO,GAAG7D,mBAAmB,CAACgB,qBAAqB,CAAC4C,aAAa,CAACpG,GAAG,CAAC;EAC5E,MAAMsG,iBAAiB,GAAGD,OAAO,CAACvD,cAAc,CAC9C;IAAE5C,OAAO;IAAEC,SAAS;IAAEE;EAAG,CAAE,EAC3BwC,EAAE,CACH;EACD,OAAO;IACLiB,IAAI,EAAEuC,OAAO,CAACvC,IAAI,EAAE,CAACkC,QAAQ,EAAE;IAC/BD,IAAI,EAAErC,yBAAyB,CAAC,CAACwC,eAAe,EAAEI,iBAAiB,CAAC;GACrE;AACH;AAEA;;;;;;;;;;;AAWA,OAAM,SAAUC,8BAA8BA,CAC5CL,eAA2B,EAAAM,KAAA,EAE3BpD,UAAkB,EAClBC,SAAqB;EAAA,IAFrB;IAAEnD,OAAO;IAAEC,SAAS;IAAEC;EAAK,CAAoB,GAAAoG,KAAA;EAI/C,MAAMnG,GAAG,GAAGD,KAAK,CAACE,GAAG,CAAEC,IAAI,IAAKrB,OAAO,CAACsB,aAAa,CAACD,IAAI,CAAC,CAACE,SAAS,CAAC;EACtE;EACA,MAAM2F,aAAa,GAAGjH,QAAQ,CAAC8C,MAAM,CACnCiE,eAAe,CACY;EAC7B,MAAMG,OAAO,GAAG7D,mBAAmB,CAACgB,qBAAqB,CAAC4C,aAAa,CAACpG,GAAG,CAAC;EAC5E,MAAMsG,iBAAiB,GAAGD,OAAO,CAACnD,gCAAgC,CAChE;IAAEhD,OAAO;IAAEC,SAAS;IAAEE;EAAG,CAAE,EAC3B+C,UAAU,EACVC,SAAS,CACV;EACD,OAAO;IACLS,IAAI,EAAEuC,OAAO,CAACvC,IAAI,EAAE,CAACkC,QAAQ,EAAE;IAC/BD,IAAI,EAAErC,yBAAyB,CAAC,CAACwC,eAAe,EAAEI,iBAAiB,CAAC;GACrE;AACH;AAEA;;;;;;AAMA,OAAM,SAAUG,eAAeA,CAAAC,KAAA,EAIZ;EAAA,IAJa;IAC9BxG,OAAO;IACPC,SAAS;IACTC;EAAK,CACY,GAAAsG,KAAA;EACjB,OAAOxH,OAAO,CAACsG,uBAAuB,CAAC;IAAEtF,OAAO;IAAEC,SAAS;IAAEC;EAAK,CAAE,CAAC;AACvE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}