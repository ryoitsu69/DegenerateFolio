{"ast":null,"code":"import { u8aToU8a } from '@polkadot/util';\n/** @internal */\nexport function createDecode({\n  coder,\n  ipfs\n}, validate) {\n  return (value, ipfsCompat) => {\n    validate(value, ipfsCompat);\n    return coder.decode(ipfs && ipfsCompat ? value.substring(1) : value);\n  };\n}\n/** @internal */\nexport function createEncode({\n  coder,\n  ipfs\n}) {\n  return (value, ipfsCompat) => {\n    const out = coder.encode(u8aToU8a(value));\n    return ipfs && ipfsCompat ? `${ipfs}${out}` : out;\n  };\n}\n/** @internal */\nexport function createIs(validate) {\n  return (value, ipfsCompat) => {\n    try {\n      return validate(value, ipfsCompat);\n    } catch {\n      return false;\n    }\n  };\n}\n/** @internal */\nexport function createValidate({\n  chars,\n  ipfs,\n  type,\n  withPadding\n}) {\n  return (value, ipfsCompat) => {\n    if (typeof value !== 'string') {\n      throw new Error(`Expected ${type} string input`);\n    } else if (ipfs && ipfsCompat && !value.startsWith(ipfs)) {\n      throw new Error(`Expected ipfs-compatible ${type} to start with '${ipfs}'`);\n    }\n    for (let i = ipfsCompat ? 1 : 0, count = value.length; i < count; i++) {\n      if (chars.includes(value[i])) {\n        // all ok, character found\n      } else if (withPadding && value[i] === '=') {\n        if (i === count - 1) {\n          // last character, everything ok\n        } else if (value[i + 1] === '=') {\n          // next one is also padding, sequence ok\n        } else {\n          throw new Error(`Invalid ${type} padding sequence \"${value[i]}${value[i + 1]}\" at index ${i}`);\n        }\n      } else {\n        throw new Error(`Invalid ${type} character \"${value[i]}\" (0x${value.charCodeAt(i).toString(16)}) at index ${i}`);\n      }\n    }\n    return true;\n  };\n}","map":{"version":3,"names":["u8aToU8a","createDecode","coder","ipfs","validate","value","ipfsCompat","decode","substring","createEncode","out","encode","createIs","createValidate","chars","type","withPadding","Error","startsWith","i","count","length","includes","charCodeAt","toString"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/util-crypto/base32/helpers.js"],"sourcesContent":["import { u8aToU8a } from '@polkadot/util';\n/** @internal */\nexport function createDecode({ coder, ipfs }, validate) {\n    return (value, ipfsCompat) => {\n        validate(value, ipfsCompat);\n        return coder.decode(ipfs && ipfsCompat\n            ? value.substring(1)\n            : value);\n    };\n}\n/** @internal */\nexport function createEncode({ coder, ipfs }) {\n    return (value, ipfsCompat) => {\n        const out = coder.encode(u8aToU8a(value));\n        return ipfs && ipfsCompat\n            ? `${ipfs}${out}`\n            : out;\n    };\n}\n/** @internal */\nexport function createIs(validate) {\n    return (value, ipfsCompat) => {\n        try {\n            return validate(value, ipfsCompat);\n        }\n        catch {\n            return false;\n        }\n    };\n}\n/** @internal */\nexport function createValidate({ chars, ipfs, type, withPadding }) {\n    return (value, ipfsCompat) => {\n        if (typeof value !== 'string') {\n            throw new Error(`Expected ${type} string input`);\n        }\n        else if (ipfs && ipfsCompat && !value.startsWith(ipfs)) {\n            throw new Error(`Expected ipfs-compatible ${type} to start with '${ipfs}'`);\n        }\n        for (let i = (ipfsCompat ? 1 : 0), count = value.length; i < count; i++) {\n            if (chars.includes(value[i])) {\n                // all ok, character found\n            }\n            else if (withPadding && value[i] === '=') {\n                if (i === count - 1) {\n                    // last character, everything ok\n                }\n                else if (value[i + 1] === '=') {\n                    // next one is also padding, sequence ok\n                }\n                else {\n                    throw new Error(`Invalid ${type} padding sequence \"${value[i]}${value[i + 1]}\" at index ${i}`);\n                }\n            }\n            else {\n                throw new Error(`Invalid ${type} character \"${value[i]}\" (0x${value.charCodeAt(i).toString(16)}) at index ${i}`);\n            }\n        }\n        return true;\n    };\n}\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,gBAAgB;AACzC;AACA,OAAO,SAASC,YAAYA,CAAC;EAAEC,KAAK;EAAEC;AAAK,CAAC,EAAEC,QAAQ,EAAE;EACpD,OAAO,CAACC,KAAK,EAAEC,UAAU,KAAK;IAC1BF,QAAQ,CAACC,KAAK,EAAEC,UAAU,CAAC;IAC3B,OAAOJ,KAAK,CAACK,MAAM,CAACJ,IAAI,IAAIG,UAAU,GAChCD,KAAK,CAACG,SAAS,CAAC,CAAC,CAAC,GAClBH,KAAK,CAAC;EAChB,CAAC;AACL;AACA;AACA,OAAO,SAASI,YAAYA,CAAC;EAAEP,KAAK;EAAEC;AAAK,CAAC,EAAE;EAC1C,OAAO,CAACE,KAAK,EAAEC,UAAU,KAAK;IAC1B,MAAMI,GAAG,GAAGR,KAAK,CAACS,MAAM,CAACX,QAAQ,CAACK,KAAK,CAAC,CAAC;IACzC,OAAOF,IAAI,IAAIG,UAAU,GAClB,GAAEH,IAAK,GAAEO,GAAI,EAAC,GACfA,GAAG;EACb,CAAC;AACL;AACA;AACA,OAAO,SAASE,QAAQA,CAACR,QAAQ,EAAE;EAC/B,OAAO,CAACC,KAAK,EAAEC,UAAU,KAAK;IAC1B,IAAI;MACA,OAAOF,QAAQ,CAACC,KAAK,EAAEC,UAAU,CAAC;IACtC,CAAC,CACD,MAAM;MACF,OAAO,KAAK;IAChB;EACJ,CAAC;AACL;AACA;AACA,OAAO,SAASO,cAAcA,CAAC;EAAEC,KAAK;EAAEX,IAAI;EAAEY,IAAI;EAAEC;AAAY,CAAC,EAAE;EAC/D,OAAO,CAACX,KAAK,EAAEC,UAAU,KAAK;IAC1B,IAAI,OAAOD,KAAK,KAAK,QAAQ,EAAE;MAC3B,MAAM,IAAIY,KAAK,CAAE,YAAWF,IAAK,eAAc,CAAC;IACpD,CAAC,MACI,IAAIZ,IAAI,IAAIG,UAAU,IAAI,CAACD,KAAK,CAACa,UAAU,CAACf,IAAI,CAAC,EAAE;MACpD,MAAM,IAAIc,KAAK,CAAE,4BAA2BF,IAAK,mBAAkBZ,IAAK,GAAE,CAAC;IAC/E;IACA,KAAK,IAAIgB,CAAC,GAAIb,UAAU,GAAG,CAAC,GAAG,CAAE,EAAEc,KAAK,GAAGf,KAAK,CAACgB,MAAM,EAAEF,CAAC,GAAGC,KAAK,EAAED,CAAC,EAAE,EAAE;MACrE,IAAIL,KAAK,CAACQ,QAAQ,CAACjB,KAAK,CAACc,CAAC,CAAC,CAAC,EAAE;QAC1B;MAAA,CACH,MACI,IAAIH,WAAW,IAAIX,KAAK,CAACc,CAAC,CAAC,KAAK,GAAG,EAAE;QACtC,IAAIA,CAAC,KAAKC,KAAK,GAAG,CAAC,EAAE;UACjB;QAAA,CACH,MACI,IAAIf,KAAK,CAACc,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;UAC3B;QAAA,CACH,MACI;UACD,MAAM,IAAIF,KAAK,CAAE,WAAUF,IAAK,sBAAqBV,KAAK,CAACc,CAAC,CAAE,GAAEd,KAAK,CAACc,CAAC,GAAG,CAAC,CAAE,cAAaA,CAAE,EAAC,CAAC;QAClG;MACJ,CAAC,MACI;QACD,MAAM,IAAIF,KAAK,CAAE,WAAUF,IAAK,eAAcV,KAAK,CAACc,CAAC,CAAE,QAAOd,KAAK,CAACkB,UAAU,CAACJ,CAAC,CAAC,CAACK,QAAQ,CAAC,EAAE,CAAE,cAAaL,CAAE,EAAC,CAAC;MACpH;IACJ;IACA,OAAO,IAAI;EACf,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}