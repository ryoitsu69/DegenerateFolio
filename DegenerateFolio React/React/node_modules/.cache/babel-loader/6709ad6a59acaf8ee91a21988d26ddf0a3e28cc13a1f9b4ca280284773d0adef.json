{"ast":null,"code":"import { isUndefined } from '@polkadot/util';\nfunction sig({\n  lookup\n}, {\n  method,\n  section\n}, args) {\n  return `${section}.${method}(${args.map(a => lookup.getTypeDef(a).type).join(', ')})`;\n}\nexport function extractStorageArgs(registry, creator, _args) {\n  const args = _args.filter(a => !isUndefined(a));\n  if (creator.meta.type.isPlain) {\n    if (args.length !== 0) {\n      throw new Error(`${sig(registry, creator, [])} does not take any arguments, ${args.length} found`);\n    }\n  } else {\n    const {\n      hashers,\n      key\n    } = creator.meta.type.asMap;\n    const keys = hashers.length === 1 ? [key] : registry.lookup.getSiType(key).def.asTuple.map(t => t);\n    if (args.length !== keys.length) {\n      throw new Error(`${sig(registry, creator, keys)} is a map, requiring ${keys.length} arguments, ${args.length} found`);\n    }\n  }\n  // pass as tuple\n  return [creator, args];\n}","map":{"version":3,"names":["isUndefined","sig","lookup","method","section","args","map","a","getTypeDef","type","join","extractStorageArgs","registry","creator","_args","filter","meta","isPlain","length","Error","hashers","key","asMap","keys","getSiType","def","asTuple","t"],"sources":["/home/ryoitsu/Documents/test/react-todo-app/node_modules/@polkadot/api/util/validate.js"],"sourcesContent":["import { isUndefined } from '@polkadot/util';\nfunction sig({ lookup }, { method, section }, args) {\n    return `${section}.${method}(${args.map((a) => lookup.getTypeDef(a).type).join(', ')})`;\n}\nexport function extractStorageArgs(registry, creator, _args) {\n    const args = _args.filter((a) => !isUndefined(a));\n    if (creator.meta.type.isPlain) {\n        if (args.length !== 0) {\n            throw new Error(`${sig(registry, creator, [])} does not take any arguments, ${args.length} found`);\n        }\n    }\n    else {\n        const { hashers, key } = creator.meta.type.asMap;\n        const keys = hashers.length === 1\n            ? [key]\n            : registry.lookup.getSiType(key).def.asTuple.map((t) => t);\n        if (args.length !== keys.length) {\n            throw new Error(`${sig(registry, creator, keys)} is a map, requiring ${keys.length} arguments, ${args.length} found`);\n        }\n    }\n    // pass as tuple\n    return [creator, args];\n}\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,gBAAgB;AAC5C,SAASC,GAAGA,CAAC;EAAEC;AAAO,CAAC,EAAE;EAAEC,MAAM;EAAEC;AAAQ,CAAC,EAAEC,IAAI,EAAE;EAChD,OAAQ,GAAED,OAAQ,IAAGD,MAAO,IAAGE,IAAI,CAACC,GAAG,CAAEC,CAAC,IAAKL,MAAM,CAACM,UAAU,CAACD,CAAC,CAAC,CAACE,IAAI,CAAC,CAACC,IAAI,CAAC,IAAI,CAAE,GAAE;AAC3F;AACA,OAAO,SAASC,kBAAkBA,CAACC,QAAQ,EAAEC,OAAO,EAAEC,KAAK,EAAE;EACzD,MAAMT,IAAI,GAAGS,KAAK,CAACC,MAAM,CAAER,CAAC,IAAK,CAACP,WAAW,CAACO,CAAC,CAAC,CAAC;EACjD,IAAIM,OAAO,CAACG,IAAI,CAACP,IAAI,CAACQ,OAAO,EAAE;IAC3B,IAAIZ,IAAI,CAACa,MAAM,KAAK,CAAC,EAAE;MACnB,MAAM,IAAIC,KAAK,CAAE,GAAElB,GAAG,CAACW,QAAQ,EAAEC,OAAO,EAAE,EAAE,CAAE,iCAAgCR,IAAI,CAACa,MAAO,QAAO,CAAC;IACtG;EACJ,CAAC,MACI;IACD,MAAM;MAAEE,OAAO;MAAEC;IAAI,CAAC,GAAGR,OAAO,CAACG,IAAI,CAACP,IAAI,CAACa,KAAK;IAChD,MAAMC,IAAI,GAAGH,OAAO,CAACF,MAAM,KAAK,CAAC,GAC3B,CAACG,GAAG,CAAC,GACLT,QAAQ,CAACV,MAAM,CAACsB,SAAS,CAACH,GAAG,CAAC,CAACI,GAAG,CAACC,OAAO,CAACpB,GAAG,CAAEqB,CAAC,IAAKA,CAAC,CAAC;IAC9D,IAAItB,IAAI,CAACa,MAAM,KAAKK,IAAI,CAACL,MAAM,EAAE;MAC7B,MAAM,IAAIC,KAAK,CAAE,GAAElB,GAAG,CAACW,QAAQ,EAAEC,OAAO,EAAEU,IAAI,CAAE,wBAAuBA,IAAI,CAACL,MAAO,eAAcb,IAAI,CAACa,MAAO,QAAO,CAAC;IACzH;EACJ;EACA;EACA,OAAO,CAACL,OAAO,EAAER,IAAI,CAAC;AAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}