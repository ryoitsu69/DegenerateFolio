{"ast":null,"code":"\"use strict\";\n\nclass UboBatch {\n  constructor({\n    minUniformOffsetAlignment\n  }) {\n    this._minUniformOffsetAlignment = 256;\n    this.byteIndex = 0;\n    this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n    this.data = new Float32Array(65535);\n  }\n  clear() {\n    this.byteIndex = 0;\n  }\n  addEmptyGroup(size) {\n    if (size > this._minUniformOffsetAlignment / 4) {\n      throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n    }\n    const start = this.byteIndex;\n    let newSize = start + size * 4;\n    newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n    if (newSize > this.data.length * 4) {\n      throw new Error(\"UniformBufferBatch: ubo batch got too big\");\n    }\n    this.byteIndex = newSize;\n    return start;\n  }\n  addGroup(array) {\n    const offset = this.addEmptyGroup(array.length);\n    for (let i = 0; i < array.length; i++) {\n      this.data[offset / 4 + i] = array[i];\n    }\n    return offset;\n  }\n  destroy() {\n    this._buffer.destroy();\n    this._buffer = null;\n    this.data = null;\n  }\n}\nexport { UboBatch };","map":{"version":3,"names":["UboBatch","constructor","minUniformOffsetAlignment","_minUniformOffsetAlignment","byteIndex","data","Float32Array","clear","addEmptyGroup","size","Error","start","newSize","Math","ceil","length","addGroup","array","offset","i","destroy","_buffer"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/rendering/renderers/gpu/buffer/UboBatch.ts"],"sourcesContent":["import type { Buffer } from '../../shared/buffer/Buffer';\n\nexport class UboBatch\n{\n    private _buffer: Buffer;\n    public data: Float32Array;\n    private readonly _minUniformOffsetAlignment: number = 256;\n\n    public byteIndex = 0;\n\n    constructor({ minUniformOffsetAlignment }: {minUniformOffsetAlignment: number})\n    {\n        this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n        this.data = new Float32Array(65535);\n    }\n\n    public clear(): void\n    {\n        this.byteIndex = 0;\n    }\n\n    public addEmptyGroup(size: number): number\n    {\n        // update the buffer.. only float32 for now!\n        if (size > this._minUniformOffsetAlignment / 4)\n        {\n            throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n        }\n\n        const start = this.byteIndex;\n\n        let newSize = start + (size * 4);\n\n        newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n\n        if (newSize > this.data.length * 4)\n        {\n            // TODO push a new buffer\n            throw new Error('UniformBufferBatch: ubo batch got too big');\n        }\n\n        this.byteIndex = newSize;\n\n        return start;\n    }\n\n    public addGroup(array: Float32Array): number\n    {\n        const offset = this.addEmptyGroup(array.length);\n\n        for (let i = 0; i < array.length; i++)\n        {\n            this.data[(offset / 4) + i] = array[i];\n        }\n\n        return offset;\n    }\n\n    public destroy()\n    {\n        this._buffer.destroy();\n        this._buffer = null;\n\n        this.data = null;\n    }\n}\n"],"mappings":";;AAEO,MAAMA,QACb;EAOIC,YAAY;IAAEC;EAAA,CACd;IALA,KAAiBC,0BAAqC;IAEtD,KAAOC,SAAY;IAIf,KAAKD,0BAA6B,GAAAD,yBAAA;IAC7B,KAAAG,IAAA,GAAO,IAAIC,YAAA,CAAa,KAAK;EAAA;EAG/BC,KACPA,CAAA;IACI,KAAKH,SAAY;EAAA;EAGdI,cAAcC,IACrB;IAEQ,IAAAA,IAAA,GAAO,IAAK,CAAAN,0BAAA,GAA6B,CAC7C;MACI,MAAM,IAAIO,KAAA,CAAiD,2CAAAD,IAAA,GAAO,CAAG;IAAA;IAGzE,MAAME,KAAA,GAAQ,IAAK,CAAAP,SAAA;IAEf,IAAAQ,OAAA,GAAUD,KAAA,GAASF,IAAO;IAE9BG,OAAA,GAAUC,IAAA,CAAKC,IAAK,CAAAF,OAAA,GAAU,IAAK,CAAAT,0BAA0B,IAAI,IAAK,CAAAA,0BAAA;IAEtE,IAAIS,OAAU,QAAKP,IAAK,CAAAU,MAAA,GAAS,CACjC;MAEU,UAAIL,KAAA,CAAM,2CAA2C;IAAA;IAG/D,KAAKN,SAAY,GAAAQ,OAAA;IAEV,OAAAD,KAAA;EAAA;EAGJK,SAASC,KAChB;IACI,MAAMC,MAAS,QAAKV,aAAc,CAAAS,KAAA,CAAMF,MAAM;IAE9C,SAASI,CAAI,MAAGA,CAAI,GAAAF,KAAA,CAAMF,MAAA,EAAQI,CAClC;MACI,KAAKd,IAAA,CAAMa,MAAS,OAAKC,CAAC,IAAIF,KAAA,CAAME,CAAC;IAAA;IAGlC,OAAAD,MAAA;EAAA;EAGJE,OACPA,CAAA;IACI,KAAKC,OAAA,CAAQD,OAAQ;IACrB,KAAKC,OAAU;IAEf,KAAKhB,IAAO;EAAA;AAEpB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}