{"ast":null,"code":"import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../maths/point/Point.mjs';\nimport { updateTransformBackwards } from '../bounds/getGlobalBounds.mjs';\n\"use strict\";\nconst toLocalGlobalMixin = {\n  /**\n   * Returns the global position of the container.\n   * @param point - The optional point to write the global value to.\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - The updated point.\n   * @memberof scene.Container#\n   */\n  getGlobalPosition(point = new Point(), skipUpdate = false) {\n    if (this.parent) {\n      this.parent.toGlobal(this._position, point, skipUpdate);\n    } else {\n      point.x = this._position.x;\n      point.y = this._position.y;\n    }\n    return point;\n  },\n  /**\n   * Calculates the global position of the container.\n   * @param position - The world origin to calculate from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - A point object representing the position of this object.\n   * @memberof scene.Container#\n   */\n  toGlobal(position, point, skipUpdate = false) {\n    if (!skipUpdate) {\n      this.updateLocalTransform();\n      const globalMatrix = updateTransformBackwards(this, new Matrix());\n      globalMatrix.append(this.localTransform);\n      return globalMatrix.apply(position, point);\n    }\n    return this.worldTransform.apply(position, point);\n  },\n  /**\n   * Calculates the local position of the container relative to another point.\n   * @param position - The world origin to calculate from.\n   * @param from - The Container to calculate the global position from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform\n   * @returns - A point object representing the position of this object\n   * @memberof scene.Container#\n   */\n  toLocal(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    if (!skipUpdate) {\n      this.updateLocalTransform();\n      const globalMatrix = updateTransformBackwards(this, new Matrix());\n      globalMatrix.append(this.localTransform);\n      return globalMatrix.applyInverse(position, point);\n    }\n    return this.worldTransform.applyInverse(position, point);\n  }\n};\nexport { toLocalGlobalMixin };","map":{"version":3,"names":["toLocalGlobalMixin","getGlobalPosition","point","Point","skipUpdate","parent","toGlobal","_position","x","y","position","updateLocalTransform","globalMatrix","updateTransformBackwards","Matrix","append","localTransform","apply","worldTransform","toLocal","from","applyInverse"],"sources":["/home/ryoitsu/node_modules/pixi.js/src/scene/container/container-mixins/toLocalGlobalMixin.ts"],"sourcesContent":["import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { updateTransformBackwards } from '../bounds/getGlobalBounds';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Container } from '../Container';\n\nexport interface ToLocalGlobalMixin\n{\n    getGlobalPosition(point?: Point, skipUpdate?: boolean): Point;\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate?: boolean): P;\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P;\n}\n\nexport const toLocalGlobalMixin: Partial<Container> = {\n    /**\n     * Returns the global position of the container.\n     * @param point - The optional point to write the global value to.\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - The updated point.\n     * @memberof scene.Container#\n     */\n    getGlobalPosition(point: Point = new Point(), skipUpdate = false): Point\n    {\n        if (this.parent)\n        {\n            this.parent.toGlobal(this._position, point, skipUpdate);\n        }\n        else\n        {\n            point.x = this._position.x;\n            point.y = this._position.y;\n        }\n\n        return point;\n    },\n\n    /**\n     * Calculates the global position of the container.\n     * @param position - The world origin to calculate from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - A point object representing the position of this object.\n     * @memberof scene.Container#\n     */\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate = false): P\n    {\n        if (!skipUpdate)\n        {\n            this.updateLocalTransform();\n\n            const globalMatrix = updateTransformBackwards(this, new Matrix());\n\n            globalMatrix.append(this.localTransform);\n\n            return globalMatrix.apply<P>(position, point);\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.apply<P>(position, point);\n    },\n\n    /**\n     * Calculates the local position of the container relative to another point.\n     * @param position - The world origin to calculate from.\n     * @param from - The Container to calculate the global position from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform\n     * @returns - A point object representing the position of this object\n     * @memberof scene.Container#\n     */\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        if (!skipUpdate)\n        {\n            this.updateLocalTransform();\n\n            const globalMatrix = updateTransformBackwards(this, new Matrix());\n\n            globalMatrix.append(this.localTransform);\n\n            return globalMatrix.applyInverse<P>(position, point);\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.applyInverse<P>(position, point);\n    }\n} as Container;\n"],"mappings":";;;;AAcO,MAAMA,kBAAyC;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQlDC,kBAAkBC,KAAe,OAAIC,KAAM,IAAGC,UAAA,GAAa,KAC3D;IACI,IAAI,KAAKC,MACT;MACI,KAAKA,MAAO,CAAAC,QAAA,CAAS,IAAK,CAAAC,SAAA,EAAWL,KAAA,EAAOE,UAAU;IAAA,CAG1D;MACUF,KAAA,CAAAM,CAAA,GAAI,KAAKD,SAAU,CAAAC,CAAA;MACnBN,KAAA,CAAAO,CAAA,GAAI,KAAKF,SAAU,CAAAE,CAAA;IAAA;IAGtB,OAAAP,KAAA;EAAA,CACX;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAWAI,QAAsCA,CAAAI,QAAA,EAAqBR,KAAW,EAAAE,UAAA,GAAa,KACnF;IACI,IAAI,CAACA,UACL;MACI,KAAKO,oBAAqB;MAE1B,MAAMC,YAAe,GAAAC,wBAAA,CAAyB,IAAM,MAAIC,MAAA,EAAQ;MAEnDF,YAAA,CAAAG,MAAA,CAAO,KAAKC,cAAc;MAEhC,OAAAJ,YAAA,CAAaK,KAAS,CAAAP,QAAA,EAAUR,KAAK;IAAA;IAIhD,OAAO,IAAK,CAAAgB,cAAA,CAAeD,KAAS,CAAAP,QAAA,EAAUR,KAAK;EAAA,CACvD;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAYAiB,OAAqCA,CAAAT,QAAA,EAAqBU,IAAkB,EAAAlB,KAAA,EAAWE,UACvF;IACI,IAAIgB,IACJ;MACIV,QAAA,GAAWU,IAAK,CAAAd,QAAA,CAASI,QAAU,EAAAR,KAAA,EAAOE,UAAU;IAAA;IAGxD,IAAI,CAACA,UACL;MACI,KAAKO,oBAAqB;MAE1B,MAAMC,YAAe,GAAAC,wBAAA,CAAyB,IAAM,MAAIC,MAAA,EAAQ;MAEnDF,YAAA,CAAAG,MAAA,CAAO,KAAKC,cAAc;MAEhC,OAAAJ,YAAA,CAAaS,YAAgB,CAAAX,QAAA,EAAUR,KAAK;IAAA;IAIvD,OAAO,IAAK,CAAAgB,cAAA,CAAeG,YAAgB,CAAAX,QAAA,EAAUR,KAAK;EAAA;AAElE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}