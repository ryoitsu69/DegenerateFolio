{"ast":null,"code":"import { BaseTexture } from \"../BaseTexture.mjs\";\nimport { autoDetectResource } from \"./autoDetectResource.mjs\";\nimport { Resource } from \"./Resource.mjs\";\nclass AbstractMultiResource extends Resource {\n  /**\n   * @param length\n   * @param options - Options to for Resource constructor\n   * @param {number} [options.width] - Width of the resource\n   * @param {number} [options.height] - Height of the resource\n   */\n  constructor(length, options) {\n    const {\n      width,\n      height\n    } = options || {};\n    super(width, height), this.items = [], this.itemDirtyIds = [];\n    for (let i = 0; i < length; i++) {\n      const partTexture = new BaseTexture();\n      this.items.push(partTexture), this.itemDirtyIds.push(-2);\n    }\n    this.length = length, this._load = null, this.baseTexture = null;\n  }\n  /**\n   * Used from ArrayResource and CubeResource constructors.\n   * @param resources - Can be resources, image elements, canvas, etc. ,\n   *  length should be same as constructor length\n   * @param options - Detect options for resources\n   */\n  initFromArray(resources, options) {\n    for (let i = 0; i < this.length; i++) resources[i] && (resources[i].castToBaseTexture ? this.addBaseTextureAt(resources[i].castToBaseTexture(), i) : resources[i] instanceof Resource ? this.addResourceAt(resources[i], i) : this.addResourceAt(autoDetectResource(resources[i], options), i));\n  }\n  /** Destroy this BaseImageResource. */\n  dispose() {\n    for (let i = 0, len = this.length; i < len; i++) this.items[i].destroy();\n    this.items = null, this.itemDirtyIds = null, this._load = null;\n  }\n  /**\n   * Set a resource by ID\n   * @param resource\n   * @param index - Zero-based index of resource to set\n   * @returns - Instance for chaining\n   */\n  addResourceAt(resource, index) {\n    if (!this.items[index]) throw new Error(`Index ${index} is out of bounds`);\n    return resource.valid && !this.valid && this.resize(resource.width, resource.height), this.items[index].setResource(resource), this;\n  }\n  /**\n   * Set the parent base texture.\n   * @param baseTexture\n   */\n  bind(baseTexture) {\n    if (this.baseTexture !== null) throw new Error(\"Only one base texture per TextureArray is allowed\");\n    super.bind(baseTexture);\n    for (let i = 0; i < this.length; i++) this.items[i].parentTextureArray = baseTexture, this.items[i].on(\"update\", baseTexture.update, baseTexture);\n  }\n  /**\n   * Unset the parent base texture.\n   * @param baseTexture\n   */\n  unbind(baseTexture) {\n    super.unbind(baseTexture);\n    for (let i = 0; i < this.length; i++) this.items[i].parentTextureArray = null, this.items[i].off(\"update\", baseTexture.update, baseTexture);\n  }\n  /**\n   * Load all the resources simultaneously\n   * @returns - When load is resolved\n   */\n  load() {\n    if (this._load) return this._load;\n    const promises = this.items.map(item => item.resource).filter(item => item).map(item => item.load());\n    return this._load = Promise.all(promises).then(() => {\n      const {\n        realWidth,\n        realHeight\n      } = this.items[0];\n      return this.resize(realWidth, realHeight), this.update(), Promise.resolve(this);\n    }), this._load;\n  }\n}\nexport { AbstractMultiResource };","map":{"version":3,"names":["AbstractMultiResource","Resource","constructor","length","options","width","height","items","itemDirtyIds","i","partTexture","BaseTexture","push","_load","baseTexture","initFromArray","resources","castToBaseTexture","addBaseTextureAt","addResourceAt","autoDetectResource","dispose","len","destroy","resource","index","Error","valid","resize","setResource","bind","parentTextureArray","on","update","unbind","off","load","promises","map","item","filter","Promise","all","then","realWidth","realHeight","resolve"],"sources":["/home/ryoitsu/node_modules/@pixi/core/src/textures/resources/AbstractMultiResource.ts"],"sourcesContent":["import { BaseTexture } from '../BaseTexture';\nimport { autoDetectResource } from './autoDetectResource';\nimport { Resource } from './Resource';\n\nimport type { ISize } from '@pixi/math';\nimport type { IAutoDetectOptions } from './autoDetectResource';\n\n/**\n * Resource that can manage several resource (items) inside.\n * All resources need to have the same pixel size.\n * Parent class for CubeResource and ArrayResource\n * @memberof PIXI\n */\nexport abstract class AbstractMultiResource extends Resource\n{\n    /** Number of elements in array. */\n    readonly length: number;\n\n    /**\n     * Collection of partial baseTextures that correspond to resources.\n     * @readonly\n     */\n    items: Array<BaseTexture>;\n\n    /**\n     * Dirty IDs for each part.\n     * @readonly\n     */\n    itemDirtyIds: Array<number>;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    /** Bound baseTexture, there can only be one. */\n    baseTexture: BaseTexture;\n\n    /**\n     * @param length\n     * @param options - Options to for Resource constructor\n     * @param {number} [options.width] - Width of the resource\n     * @param {number} [options.height] - Height of the resource\n     */\n    constructor(length: number, options?: ISize)\n    {\n        const { width, height } = options || {};\n\n        super(width, height);\n\n        this.items = [];\n        this.itemDirtyIds = [];\n\n        for (let i = 0; i < length; i++)\n        {\n            const partTexture = new BaseTexture();\n\n            this.items.push(partTexture);\n            // -2 - first run of texture array upload\n            // -1 - texture item was allocated\n            // >=0 - texture item uploaded , in sync with items[i].dirtyId\n            this.itemDirtyIds.push(-2);\n        }\n\n        this.length = length;\n        this._load = null;\n        this.baseTexture = null;\n    }\n\n    /**\n     * Used from ArrayResource and CubeResource constructors.\n     * @param resources - Can be resources, image elements, canvas, etc. ,\n     *  length should be same as constructor length\n     * @param options - Detect options for resources\n     */\n    protected initFromArray(resources: Array<any>, options?: IAutoDetectOptions): void\n    {\n        for (let i = 0; i < this.length; i++)\n        {\n            if (!resources[i])\n            {\n                continue;\n            }\n            if (resources[i].castToBaseTexture)\n            {\n                this.addBaseTextureAt(resources[i].castToBaseTexture(), i);\n            }\n            else if (resources[i] instanceof Resource)\n            {\n                this.addResourceAt(resources[i], i);\n            }\n            else\n            {\n                this.addResourceAt(autoDetectResource(resources[i], options), i);\n            }\n        }\n    }\n\n    /** Destroy this BaseImageResource. */\n    dispose(): void\n    {\n        for (let i = 0, len = this.length; i < len; i++)\n        {\n            this.items[i].destroy();\n        }\n        this.items = null;\n        this.itemDirtyIds = null;\n        this._load = null;\n    }\n\n    /**\n     * Set a baseTexture by ID\n     * @param baseTexture\n     * @param index - Zero-based index of resource to set\n     * @returns - Instance for chaining\n     */\n    abstract addBaseTextureAt(baseTexture: BaseTexture, index: number): this;\n\n    /**\n     * Set a resource by ID\n     * @param resource\n     * @param index - Zero-based index of resource to set\n     * @returns - Instance for chaining\n     */\n    addResourceAt(resource: Resource, index: number): this\n    {\n        if (!this.items[index])\n        {\n            throw new Error(`Index ${index} is out of bounds`);\n        }\n\n        // Inherit the first resource dimensions\n        if (resource.valid && !this.valid)\n        {\n            this.resize(resource.width, resource.height);\n        }\n\n        this.items[index].setResource(resource);\n\n        return this;\n    }\n\n    /**\n     * Set the parent base texture.\n     * @param baseTexture\n     */\n    bind(baseTexture: BaseTexture): void\n    {\n        if (this.baseTexture !== null)\n        {\n            throw new Error('Only one base texture per TextureArray is allowed');\n        }\n        super.bind(baseTexture);\n\n        for (let i = 0; i < this.length; i++)\n        {\n            this.items[i].parentTextureArray = baseTexture;\n            this.items[i].on('update', baseTexture.update, baseTexture);\n        }\n    }\n\n    /**\n     * Unset the parent base texture.\n     * @param baseTexture\n     */\n    unbind(baseTexture: BaseTexture): void\n    {\n        super.unbind(baseTexture);\n\n        for (let i = 0; i < this.length; i++)\n        {\n            this.items[i].parentTextureArray = null;\n            this.items[i].off('update', baseTexture.update, baseTexture);\n        }\n    }\n\n    /**\n     * Load all the resources simultaneously\n     * @returns - When load is resolved\n     */\n    load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const resources = this.items.map((item) => item.resource).filter((item) => item);\n\n        // TODO: also implement load part-by-part strategy\n        const promises = resources.map((item) => item.load());\n\n        this._load = Promise.all(promises)\n            .then(() =>\n            {\n                const { realWidth, realHeight } = this.items[0];\n\n                this.resize(realWidth, realHeight);\n                this.update();\n\n                return Promise.resolve(this);\n            }\n            );\n\n        return this._load;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}